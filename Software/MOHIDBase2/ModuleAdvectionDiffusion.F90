!------------------------------------------------------------------------------
!        IST/MARETEC, Water Modelling Group, Mohid modelling system
!------------------------------------------------------------------------------
!
! TITLE         : Mohid Model
! PROJECT       : Mohid Base 2
! MODULE        : ModuleAdvectionDiffusion 
! URL           : http://www.mohid.com
! AFFILIATION   : IST/MARETEC, Marine Modelling Group
! DATE          : Jun 2003
! REVISION      : Paulo Leitão - v4.0
! DESCRIPTION   : Module responsbile for computing advection/diffusion processes
!
!------------------------------------------------------------------------------
!
!This program is free software; you can redistribute it and/or
!modify it under the terms of the GNU General Public License 
!version 2, as published by the Free Software Foundation.
!
!This program is distributed in the hope that it will be useful,
!but WITHOUT ANY WARRANTY; without even the implied warranty of
!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!GNU General Public License for more details.
!
!You should have received a copy of the GNU General Public License
!along with this program; if not, write to the Free Software
!Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
!
!------------------------------------------------------------------------------

Module ModuleAdvectionDiffusion
                                    
    use ModuleGlobalData
    use ModuleFunctions     , only : OrlanskiCelerity2D, THOMAS_3D, THOMASZ, ComputeAdvection1D_V2,     &
                                     SetMatrixValue, Chunk_J, Chunk_K, Chunk_I, T_THOMAS, T_VECGW, T_D_E_F, Pad, &
                                     ComputeAdvection1D_TVD_SuperBee_2, THOMASZ_NewType2
    use ModuleTime          , only : GetComputeCurrentTime, T_Time, KillComputeTime, &
                                     null_time, operator(+), operator(-),            &
                                     operator (.eq.), operator (.ne.)
    use ModuleStopWatch     , only : StartWatch, StopWatch     
    use ModuleHorizontalGrid, only : KillHorizontalGrid, GetHorizontalGrid, UnGetHorizontalGrid, GetDDecompParameters
#ifdef _USE_MPI    
    use ModuleHorizontalGrid, only : THOMAS_DDecompHorizGrid
#endif _USE_MPI        
    
    use ModuleHorizontalMap , only : KillHorizontalMap, GetBoundaries, UnGetHorizontalMap
    use ModuleGeometry      , only : GetGeometrySize, GetGeometryKFloor, GetGeometryWaterColumn, &
                                     GetGeometryAreas, GetGeometryDistances, UnGetGeometry


#ifdef _ENABLE_CUDA
    use ModuleCuda
#endif

    !$ use omp_lib

    implicit none

    private 

    !Subroutines---------------------------------------------------------------

    !Constructor
    public  :: StartAdvectionDiffusion
    private ::      AllocateInstance
    private ::      AllocateVariables                                                


    !Selector
    public  :: GetAdvFlux
    public  :: GetDifFlux
    public  :: GetBoundaryConditionList

    public  :: UngetAdvectionDiffusion

    public  :: SetDischarges
    public  :: UnSetDischarges

    !Modifier
    public  :: AdvectionDiffusion                                                
    private ::      Set_Internal_State          
    private ::      Convert_Dif_Vertical
    
    private ::      Compute_DifH_Constants
    private ::      Compute_DifV_Constants

    private ::      AdvectionDiffusionIteration

    private ::          Convert_Visc_Dif_Horizontal
    private ::          Convert_Visc_Dif_Horizontal_opt

    private ::          VolumeVariation                     !OK

    private ::          Discharges

    private ::          HorizontalDiffusion                 !OK                                         
    private ::              HorizontalDiffusionXX           !OK                             
    private ::                  CalcHorizontalDifFluxXX     !OK
    private ::              HorizontalDiffusionXX2           !OK
    private ::                  CalcHorizontalDifFluxXX2
    private ::              HorizontalDiffusionYY           !OK
    private ::                  CalcHorizontalDifFluxYY     !OK
    private ::              HorizontalDiffusionYY2           !OK
    private ::                  CalcHorizontalDifFluxYY2     !OK
                                      
    private ::          OpenBoundaryCondition                                                     
    private ::              FluxAtOpenBoundary                                               

    private ::          HorizontalAdvection                                             
    private ::              HorizontalAdvectionXX
    private ::              HorizontalAdvectionXX_Explicit
    private ::                  CalcHorizontalAdvFluxXX
    private ::                  CalcHorizontalAdvFluxXX_opt
    private ::              HorizontalAdvectionYY
    private ::              HorizontalAdvectionYY_Explicit
    private ::                  CalcHorizontalAdvFluxYY
    private ::                  CalcHorizontalAdvFluxYY_opt
    private ::          HorizontalAdvectionUpwindExplict
    
    private ::          VerticalDiffusion  
    private ::          VerticalDiffusion2
    private ::              CalcVerticalDifFlux 
    private ::              CalcVerticalDifFlux2
    private ::          VerticalAdvection
    private ::              VerticalAdvection_ExplicitScheme
    private ::              CalcVerticalAdvFlux
    private ::              CalcVerticalAdvFlux_opt

    private ::      FinishAdvectionDiffusionIt                            

    !Destructor
    public  ::  KillAdvectionDiffusion
    private ::      DeallocateInstance
                
                                        

    !Management
    private ::      Ready
    private ::          LocateObjAdvectionDiffusion

    
    !Interfaces----------------------------------------------------------------

    private :: UngetAdvectionDiffusion3Dreal4
    private :: UngetAdvectionDiffusion3Dreal8
    interface  UngetAdvectionDiffusion
        module procedure UngetAdvectionDiffusion3Dreal4
        module procedure UngetAdvectionDiffusion3Dreal8
    end interface  UngetAdvectionDiffusion

    !Parameter-----------------------------------------------------------------
    integer, parameter :: MassConservation_           = 1
    integer, parameter :: ImposedValue_               = 2
    integer, parameter :: NullGradient_               = 4
    integer, parameter :: SubModel_                   = 5
    integer, parameter :: Orlanski_                   = 6
    integer, parameter :: MassConservNullGrad_        = 7
    integer, parameter :: CyclicBoundary_             = 8

    !Maximum internal wave velocity allowed is 10 m/s.
    real,    parameter :: MaxInternalCelerity = 10. 

    !Types---------------------------------------------------------------------

    type       T_State
        !This state defines if the coeficients D E and F need to be recalculated
        logical :: VertAdv      = ON   
        !This state defines if the coeficients D E and F need to be recalculated        
        logical :: HorAdv       = ON    
        logical :: VertDif      = ON    
        logical :: HorDif       = ON
        logical :: CellFluxes   = OFF
        logical :: OpenBoundary = OFF
    end type T_State

    type       T_FluxCoef
        !Coeficients to calculate AdvFlux and DifFlux
        real   , pointer, dimension(: , : , :)  :: C_flux       => null()  
        real   , pointer, dimension(: , : , :)  :: D_flux       => null()    
        real   , pointer, dimension(: , : , :)  :: E_flux       => null()    
        real   , pointer, dimension(: , : , :)  :: F_flux       => null()    
    end type T_FluxCoef

    type       T_CellFluxes
        !Former CFLUX 
        real(8), pointer, dimension(:,:,:)      :: AdvFluxX     => null()
        real(8), pointer, dimension(:,:,:)      :: AdvFluxY     => null()
        real(8), pointer, dimension(:,:,:)      :: AdvFluxZ     => null()
        !Former DFLUX
        real(8), pointer, dimension(:,:,:)      :: DifFluxX     => null()
        real(8), pointer, dimension(:,:,:)      :: DifFluxY     => null()
        real(8), pointer, dimension(:,:,:)      :: DifFluxZ     => null()
        type(T_Time)                            :: LastFluxCalculation          
    end type T_CellFluxes
    

    type       T_External
        real,    pointer, dimension(:,:,:) :: PROP              => null()                          
        real,    pointer, dimension(:,:,:) :: ReferenceProp     => null()            
        real,    pointer, dimension(:,:,:) :: PROPOld           => null()
    
        !Map    
        integer, pointer, dimension(:,:,:) :: ComputeFacesU3D   => null()
        integer, pointer, dimension(:,:,:) :: ComputeFacesV3D   => null()
        integer, pointer, dimension(:,:,:) :: ComputeFacesW3D   => null()
        integer, pointer, dimension(:,:,:) :: LandPoints3D      => null()
        integer, pointer, dimension(:,:,:) :: OpenPoints3D      => null()
        integer, pointer, dimension(:,:,:) :: WaterPoints3D     => null()
        integer, pointer, dimension(:,:  ) :: BoundaryPoints2D  => null()
                                                                
        integer, pointer, dimension(:,:  ) :: KFloorZ           => null()
        integer, pointer, dimension(:,:  ) :: KFloorU           => null()
        integer, pointer, dimension(:,:  ) :: KFloorV           => null()
        real(8), pointer, dimension(:,:,:) :: VolumeZ           => null()
        real(8), pointer, dimension(:,:,:) :: VolumeZOld        => null()
        real,    pointer, dimension(:,:  ) :: DUX               => null()
        real,    pointer, dimension(:,:  ) :: DVY               => null()
        real,    pointer, dimension(:,:  ) :: DZX               => null()
        real,    pointer, dimension(:,:  ) :: DZY               => null()
        real,    pointer, dimension(:,:,:) :: DWZ               => null()
        real,    pointer, dimension(:,:,:) :: DZZ               => null()
        real,    pointer, dimension(:,:,:) :: AreaU             => null()
        real,    pointer, dimension(:,:,:) :: AreaV             => null()
                                                                

        real                               :: Schmidt_H             = null_real
        real                               :: SchmidtCoef_V         = null_real
        real                               :: SchmidtBackground_V   = null_real
        real                               :: DecayTime             = null_real
        real                               :: DTProp                = null_real

        integer                            :: BoundaryCondition     = null_int


        !Implicit-Explicit weight coeficients -> 1 = Implicit, 0 = Explicit
        !Presentlty horizontal is explicitly computed
        real                               :: ImpExp_AdvXX  = null_real             
        real                               :: ImpExp_AdvYY  = null_real             
        real                               :: ImpExp_DifH   = null_real            
        real                               :: ImpExp_AdvV   = null_real      
        real                               :: ImpExp_DifV   = null_real      



        !Hydrodynamic
        logical                            :: Nulldif       =  .false. 
        real(8), pointer, dimension(:,:,:) :: Wflux_X       => null()
        real(8), pointer, dimension(:,:,:) :: Wflux_Y       => null()
        real(8), pointer, dimension(:,:,:) :: Wflux_Z       => null()
                                                            

        !Turbulence
        real,    pointer, dimension(:,:,:) :: Visc_H        => null()
        real,    pointer, dimension(:,:,:) :: Diff_V        => null()
        logical, pointer, dimension(:,:  ) :: SmallDepths   => null()
                                                            
        !Advection
        logical                            :: SmallDepthsPresent    = .false. 
        real                               :: VolumeRelMax          = null_real
        integer                            :: AdvMethodH            = null_int
        integer                            :: TVDLimitationH        = null_int
        integer                            :: AdvMethodV            = null_int
        integer                            :: TVDLimitationV        = null_int
        logical                            :: Upwind2H              = .false.
        logical                            :: Upwind2V              = .false.
        logical                            :: AdvectionNudging      = .false.
        integer                            :: AdvectionNudgingCells = null_int             

        !Discharges
        real,    pointer, dimension(:)     :: DischFlow     => null()
        real,    pointer, dimension(:)     :: DischConc     => null()
        integer, pointer, dimension(:)     :: DischI        => null()
        integer, pointer, dimension(:)     :: DischJ        => null()
        integer, pointer, dimension(:)     :: DischK        => null()
        integer, pointer, dimension(:)     :: DischnCells   => null()
        integer, pointer, dimension(:)     :: DischKmin     => null()
        integer, pointer, dimension(:)     :: DischKmax     => null()
        integer, pointer, dimension(:)     :: DischVert     => null()
        logical, pointer, dimension(:)     :: IgnoreDisch   => null()
        logical, pointer, dimension(:)     :: ByPass        => null()
        integer                            :: DischNumber   = null_int
        logical                            :: DischON       = .false.

        !No flux condition
        logical                            :: NoAdvFlux     = .false.
        logical                            :: NoDifFlux     = .false.        
        integer, dimension(:,:,:), pointer :: NoFluxU       => null()
        integer, dimension(:,:,:), pointer :: NoFluxV       => null()
        integer, dimension(:,:,:), pointer :: NoFluxW       => null()
        
        !Optimizations
        logical                            :: Optimize = .false.
        logical                            :: Optimize_AdvH = .false.
        logical                            :: Optimize_DifH = .false.
        logical                            :: Optimize_AdvV = .false.
        logical                            :: Optimize_DifV = .false.


    end type T_External
    
    private :: T_DDecomp
    type       T_DDecomp        
        logical                                 :: ON               = .false. 
        logical                                 :: MasterOrSlave    = .false. 
    end type T_DDecomp
    

    !For performance reasons the coeffiecient are order in the way the are allocated
    type      T_AdvectionDiffusion
        real , dimension(:,:,:), pointer        :: Diffusion_CoeficientX    => null()
        real , dimension(:,:,:), pointer        :: Diffusion_CoeficientY    => null()
        real , dimension(:,:,:), pointer        :: Diffusion_CoeficientZ    => null()
        real(8), dimension(:,:,:), allocatable  :: Diff_H_Const_U, Diff_H_Const_V
        real(8), dimension(:,:,:), allocatable  :: Diff_V_Const
        type(T_CellFluxes)                      :: Fluxes
        !Former DCOEF3  ECOEF3  FCOEF3
        type(T_D_E_F)                           :: COEF3                    
        !Vertical    advection coeficients
        type(T_FluxCoef)                        :: COEF3_VertAdv            
        !Horinzontal advection coeficients
        type(T_FluxCoef)                        :: COEF3_HorAdvXX           
        type(T_FluxCoef)                        :: COEF3_HorAdvYY           
        real, pointer, dimension(: , : , :)     :: TICOEF3              => null()
        real, pointer, dimension(: , : , :)     :: AdvectionE           => null()
        real, pointer, dimension(: , : , :)     :: AdvectionD           => null()
        real, pointer, dimension(: , : , :)     :: AdvectionF           => null()
        real, pointer, dimension(: , : , :)     :: AdvectionTi          => null()
#ifdef _USE_PAGELOCKED
        type(C_PTR)                             :: TICOEF3Ptr
#endif _USE_PAGELOCKED
        real(8), pointer, dimension(:,:,:)      :: WaterFluxOBoundary   => null()
        !griflet
        type(T_THOMAS), pointer                 :: THOMAS
        !Auxiliar thomas arrays
        real(8), pointer, dimension(:)          :: VECG                 => null()         
        real(8), pointer, dimension(:)          :: VECW                 => null()    

        !griflet
        integer                                 :: MaxThreads           = null_int

        type(T_External  )                      :: ExternalVar

        integer                                 :: InstanceID           = null_int
        type(T_Size3D    )                      :: Size
        type(T_Size3D    )                      :: WorkSize
        type(T_State     )                      :: State

        type(T_Time      )                      :: Now
        type(T_Time      )                      :: LastCalc  

        logical                                 :: Vertical1D           = .false.
        logical                                 :: XZFlow               = .false.
        logical                                 :: FirstTime            = .true.
        logical                                 :: FirstProperty        = .false.
        
        integer                                 :: Docycle_method = 1
    
        type(T_DDecomp   )                      :: DDecomp
   
        !Instance of ModuleHorizontalMap
        integer                                 :: ObjHorizontalMap     = 0
       
        !Instance of ModuleHorizontalGrid
        integer                                 :: ObjHorizontalGrid    = 0
       
        !Instance of ModuleGeometry
        integer                                 :: ObjGeometry          = 0
    
        !Instance of ModuleTime
        integer                                 :: ObjTime              = 0

#ifdef _ENABLE_CUDA
        integer                                 :: ObjCuda              = 0
#endif

        !Collection of instances
        type(T_AdvectionDiffusion),  pointer    :: Next                 => null()

    end type T_AdvectionDiffusion


    !Global Module Variables
    type (T_AdvectionDiffusion), pointer        :: FirstAdvectionDiffusion => null()
    type (T_AdvectionDiffusion), pointer        :: Me                      => null()
    
    !--------------------------------------------------------------------------
    
    contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CO

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    subroutine StartAdvectionDiffusion(AdvectionDiffusionID,                            &
                                       GeometryID,                                      &
                                       HorizontalMapID,                                 &
                                       HorizontalGridID,                                &
                                       TimeID,                                          &
                                       Vertical1D,                                      &
                                       XZFlow,                                          &
                                       Docycle_method,                                  &
#ifdef _ENABLE_CUDA
                                       ObjCudaID,                                       &
#endif    
                                       STAT)

        !Arguments-------------------------------------------------------------

        integer                             :: AdvectionDiffusionID
        integer                             :: GeometryID     
        integer                             :: HorizontalMapID
        integer                             :: HorizontalGridID
        integer                             :: TimeID    
        logical, optional, intent(IN )      :: Vertical1D, XZFlow
#ifdef _ENABLE_CUDA
        integer                             :: ObjCudaID
#endif
        integer, optional, intent(OUT)      :: STAT
        integer                             :: Docycle_method

        !External--------------------------------------------------------------

        integer :: STAT_CALL
        integer :: ready_         

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable
 
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_
        
        !Assures nullification of the global variable
        if (.not. ModuleIsRegistered(mAdvectionDiffusion_)) then
            nullify (FirstAdvectionDiffusion)
            call RegisterModule (mAdvectionDiffusion_) 
        endif
        

        call Ready(AdvectionDiffusionID, ready_)

cd0 :   if (ready_ == OFF_ERR_) then
            
            call AllocateInstance 
            
            !Associates External Instances
            Me%ObjTime           = AssociateInstance (mTIME_,           TimeID          )
            Me%ObjHorizontalGrid = AssociateInstance (mHORIZONTALGRID_, HorizontalGridID)
            Me%ObjHorizontalMap  = AssociateInstance (mHORIZONTALMAP_,  HorizontalMapID )
            Me%ObjGeometry       = AssociateInstance (mGEOMETRY_,       GeometryID      )
#ifdef _ENABLE_CUDA
            Me%ObjCuda           = AssociateInstance (mCUDA_,           ObjCudaID       )
#endif

            !Gets the size from the Geometry
            call GetGeometrySize(Me%ObjGeometry,                                         &
                                 Size        = Me%Size,                                  &
                                 WorkSize    = Me%WorkSize,                              &
                                 STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'StartAdvectionDiffusion - ModuleAdvectionDiffusion - ERR01'

            Me%Docycle_method = Docycle_method
            !Allocates variables
            call AllocateVariables

            if (present(Vertical1D)) Me%Vertical1D = Vertical1D

            if (present(XZFlow    )) Me%XZFlow     = XZFlow

            call null_time(Me%Now)        

            STAT_ = SUCCESS_

           !Returns ID
            AdvectionDiffusionID    = Me%InstanceID

        else

            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'StartAdvectionDiffusion - ModuleAdvectionDiffusion - ERR02'

        end if cd0


        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine StartAdvectionDiffusion

    !--------------------------------------------------------------------------

    subroutine AllocateInstance ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_AdvectionDiffusion), pointer           :: NewAdvectionDiffusion
        type (T_AdvectionDiffusion), pointer           :: PreviousAdvectionDiffusion


        !Allocates new instance
        allocate (NewAdvectionDiffusion)
        nullify  (NewAdvectionDiffusion%Next)

        !Insert New Instance into list and makes Current point to it
        if (.not. associated(FirstAdvectionDiffusion)) then
            FirstAdvectionDiffusion         => NewAdvectionDiffusion
            Me                              => NewAdvectionDiffusion
        else
            PreviousAdvectionDiffusion      => FirstAdvectionDiffusion
            Me                              => FirstAdvectionDiffusion%Next
            do while (associated(Me))
                PreviousAdvectionDiffusion  => Me
                Me                          => Me%Next
            enddo
            Me                              => NewAdvectionDiffusion
            PreviousAdvectionDiffusion%Next => NewAdvectionDiffusion
        endif

        Me%InstanceID = RegisterNewInstance (mADVECTIONDIFFUSION_)

    end subroutine AllocateInstance

    !--------------------------------------------------------------------------
    ! This subroutine allocates the auxiliar variables need
    ! to compute the Advection & Diffusion of a generic propriety 
    subroutine AllocateVariables()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: IJKLB, IJKUB
        
        !griflet
        integer                                     :: m
        type(T_VECGW), pointer                      :: VECGW

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB 
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        IJKLB = min (ILB, JLB, KLB)
        IJKUB = max (IUB, JUB, KUB)


        allocate(Me%Diffusion_CoeficientX   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Diffusion_CoeficientY   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Diffusion_CoeficientZ   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Fluxes%AdvFluxX         (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Fluxes%AdvFluxY         (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Fluxes%AdvFluxZ         (ILB:IUB, JLB:JUB, KLB:KUB))

        allocate(Me%Fluxes%DifFluxX         (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Fluxes%DifFluxY         (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%Fluxes%DifFluxZ         (ILB:IUB, JLB:JUB, KLB:KUB))

#ifdef _USE_PAGELOCKED
        ! Allocate pagelocked memory to optimize CUDA transfers
        call Alloc3DPageLocked(Me%ObjCuda, Me%COEF3%DPtr, Me%COEF3%D, IUB + 1, JUB + 1, KUB + 1)        
        call Alloc3DPageLocked(Me%ObjCuda, Me%COEF3%EPtr, Me%COEF3%E, IUB + 1, JUB + 1, KUB + 1)        
        call Alloc3DPageLocked(Me%ObjCuda, Me%COEF3%FPtr, Me%COEF3%F, IUB + 1, JUB + 1, KUB + 1)        
#else
        allocate(Me%COEF3%D                 (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate(Me%COEF3%E                 (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate(Me%COEF3%F                 (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
#endif _USE_PAGELOCKED

        allocate(Me%COEF3_VertAdv%C_Flux    (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_VertAdv%D_Flux    (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_VertAdv%E_Flux    (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_VertAdv%F_Flux    (ILB:IUB, JLB:JUB, KLB:KUB))

        allocate(Me%COEF3_HorAdvXX%C_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_HorAdvXX%D_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_HorAdvXX%E_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_HorAdvXX%F_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))

        allocate(Me%COEF3_HorAdvYY%C_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_HorAdvYY%D_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_HorAdvYY%E_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%COEF3_HorAdvYY%F_Flux   (ILB:IUB, JLB:JUB, KLB:KUB))

#ifdef _USE_PAGELOCKED       
        allocate(Me%TICOEF3         (ILB:IUB, JLB:JUB, KLB:KUB))
        ! Allocate pagelocked memory to optimize CUDA transfers
!        call Alloc3DPageLocked(Me%ObjCuda, Me%TICOEF3Ptr, Me%TICOEF3, IUB + 1, JUB + 1, KUB + 1)        
#else
        allocate(Me%TICOEF3                 (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
#endif _USE_PAGELOCKED

        allocate(Me%AdvectionE              (ILB:IUB, JLB:JUB, KLB:KUB))
        allocate(Me%AdvectionD              (ILB:IUB, JLB:JUB, KLB:KUB))        
        allocate(Me%AdvectionF              (ILB:IUB, JLB:JUB, KLB:KUB))                
        allocate(Me%AdvectionTi             (ILB:IUB, JLB:JUB, KLB:KUB))                

        allocate(Me%WaterFluxOBoundary      (ILB:IUB, JLB:JUB, KLB:KUB))

        allocate(Me%VECG                    (IJKLB:IJKUB))
        allocate(Me%VECW                    (IJKLB:IJKUB))

        !griflet: BEGIN this is the alternate version that allows parallel openmp

        !Me%MaxThreads = 1
        !!$ Me%MaxThreads = omp_get_max_threads()

        Me%MaxThreads = openmp_num_threads
        
        allocate(Me%THOMAS)
        allocate(Me%THOMAS%COEF3)
        allocate(Me%THOMAS%VEC(1:Me%MaxThreads))

        do m = 1, Me%MaxThreads

            VECGW => Me%THOMAS%VEC(m)

            allocate(VECGW%G(IJKLB:IJKUB))
            allocate(VECGW%W(IJKLB:IJKUB))

        enddo

        Me%THOMAS%COEF3 => Me%COEF3
        Me%THOMAS%TI => Me%TICOEF3

        !griflet: END

        Me%Diffusion_CoeficientX    = Null_real
        Me%Diffusion_CoeficientY    = Null_real
        Me%Diffusion_CoeficientZ    = Null_real
                            
        Me%Fluxes%AdvFluxX          = Null_real
        Me%Fluxes%AdvFluxY          = Null_real
        Me%Fluxes%AdvFluxZ          = Null_Real

        Me%Fluxes%DifFluxX          = Null_real
        Me%Fluxes%DifFluxY          = Null_real
        Me%Fluxes%DifFluxZ          = Null_Real

        Me%COEF3%D                  = Null_real
        Me%COEF3%E                  = Null_real
        Me%COEF3%F                  = Null_real

        Me%COEF3_VertAdv%C_Flux     = Null_real
        Me%COEF3_VertAdv%D_Flux     = Null_real
        Me%COEF3_VertAdv%E_Flux     = Null_real
        Me%COEF3_VertAdv%F_Flux     = Null_real

        Me%COEF3_HorAdvXX%C_Flux    = Null_real
        Me%COEF3_HorAdvXX%D_Flux    = Null_real
        Me%COEF3_HorAdvXX%E_Flux    = Null_real
        Me%COEF3_HorAdvXX%F_Flux    = Null_real

        Me%COEF3_HorAdvYY%C_Flux    = Null_real
        Me%COEF3_HorAdvYY%D_Flux    = Null_real
        Me%COEF3_HorAdvYY%E_Flux    = Null_real
        Me%COEF3_HorAdvYY%F_Flux    = Null_real

        Me%TICOEF3                  = Null_real
        Me%WaterFluxOBoundary       = Null_real

        Me%VECG                     = Null_real 
        Me%VECW                     = Null_real 


        !----------------------------------------------------------------------

    end subroutine AllocateVariables   


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SE

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



    subroutine GetAdvFlux(AdvectionDiffusionID, AdvFluxX,                  &
                                                AdvFluxY,                  &
                                                AdvFluxZ, STAT)    !AdvFlux is the former CFLUX

        !Arguments-------------------------------------------------------------
        integer                                      :: AdvectionDiffusionID

        real(8), pointer, optional, dimension(:,:,:) :: AdvFluxX
        real(8), pointer, optional, dimension(:,:,:) :: AdvFluxY
        real(8), pointer, optional, dimension(:,:,:) :: AdvFluxZ

        integer,      optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_          
        integer :: STAT_CALL

        !Local-----------------------------------------------------------------

        integer :: STAT_   
           

        !----------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)
        
cd1 :   if ((ready_ == IDLE_ERR_     ) .OR.                                            &
            (ready_ == READ_LOCK_ERR_)) then

            call GetComputeCurrentTime(Me%ObjTime, Me%Now, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'GetAdvFlux - ModuleAdvectionDiffusion - ERR01'



cd5 :       if (Me%Now == Me%Fluxes%LastFluxCalculation) then

cd2 :           if (present(AdvFluxX)) then
                    call Read_Lock(mADVECTIONDIFFUSION_,  Me%InstanceID)   
                    AdvFluxX => Me%Fluxes%AdvFluxX
                end if cd2


cd3 :           if (present(AdvFluxY)) then
                    call Read_Lock(mADVECTIONDIFFUSION_,  Me%InstanceID)      
                    AdvFluxY => Me%Fluxes%AdvFluxY
                end if cd3


cd4 :           if (present(AdvFluxZ)) then
                    call Read_Lock(mADVECTIONDIFFUSION_,  Me%InstanceID)
                    AdvFluxZ => Me%Fluxes%AdvFluxZ
                end if cd4
                
                STAT_ = SUCCESS_
            else 
                STAT_ = TIME_ERR_
            end if cd5

            call null_time(Me%Now)
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetAdvFlux

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------
 
    subroutine GetDifFlux(AdvectionDiffusionID, DifFluxX,                     &
                                                DifFluxY,                     &
                                                DifFluxZ, STAT)      !DifFlux is the former CFLUX

        !Arguments-------------------------------------------------------------
        integer                                      :: AdvectionDiffusionID

        real(8), pointer, optional, dimension(:,:,:) :: DifFluxX
        real(8), pointer, optional, dimension(:,:,:) :: DifFluxY
        real(8), pointer, optional, dimension(:,:,:) :: DifFluxZ

        integer,      optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_          
        integer :: STAT_CALL

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)
        
cd1 :   if ((ready_ == IDLE_ERR_     ) .OR.                                            &
            (ready_ == READ_LOCK_ERR_)) then

            call GetComputeCurrentTime(Me%ObjTime,                    &
                                       Me%Now, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'GetDifFlux - ModuleAdvectionDiffusion - ERR01'

cd5 :       if (Me%Now ==                                           &
                Me%Fluxes%LastFluxCalculation) then
cd2 :           if (present(DifFluxX)) then
                    call Read_Lock(mADVECTIONDIFFUSION_,  Me%InstanceID)
                    DifFluxX => Me%Fluxes%DifFluxX
                end if cd2
           

cd3 :           if (present(DifFluxY)) then
                    call Read_Lock(mADVECTIONDIFFUSION_,  Me%InstanceID)
                    DifFluxY => Me%Fluxes%DifFluxY
                end if cd3
           

cd4 :           if (present(DifFluxZ)) then
                    call Read_Lock(mADVECTIONDIFFUSION_,  Me%InstanceID)   
                    DifFluxZ => Me%Fluxes%DifFluxZ
                end if cd4
                STAT_ = SUCCESS_
            else
                STAT_ = TIME_ERR_
            end if cd5
           
            call null_time(Me%Now)
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetDifFlux

    !--------------------------------------------------------------------------

    subroutine GetBoundaryConditionList(MassConservation,                     &
                                        ImposedValue,                         &
                                        NullGradient, SubModel, Orlanski,     &
                                        MassConservNullGrad, CyclicBoundary)

        !Arguments-------------------------------------------------------------

        integer, optional, intent(OUT) :: MassConservation      
        integer, optional, intent(OUT) :: ImposedValue       
        integer, optional, intent(OUT) :: NullGradient        
        integer, optional, intent(OUT) :: SubModel        
        integer, optional, intent(OUT) :: Orlanski
        integer, optional, intent(OUT) :: MassConservNullGrad
        integer, optional, intent(OUT) :: CyclicBoundary

        !----------------------------------------------------------------------
     
        if (present(MassConservation          )) MassConservation           = MassConservation_
        if (present(ImposedValue              )) ImposedValue               = ImposedValue_
        if (present(NullGradient              )) NullGradient               = NullGradient_
        if (present(SubModel                  )) SubModel                   = SubModel_
        if (present(Orlanski                  )) Orlanski                   = Orlanski_                            
        if (present(MassConservNullGrad       )) MassConservNullGrad        = MassConservNullGrad_
        if (present(CyclicBoundary            )) CyclicBoundary             = CyclicBoundary_
        !----------------------------------------------------------------------

    end subroutine GetBoundaryConditionList

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine UngetAdvectionDiffusion3Dreal4(AdvectionDiffusionID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer                            :: AdvectionDiffusionID

        real(4), pointer, dimension(:,:,:) :: Array

        integer, optional, intent (OUT)    :: STAT
   

        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable
        
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)

cd1 :   if (ready_ == READ_LOCK_ERR_) then
            nullify(Array)

            call Read_Unlock(mADVECTIONDIFFUSION_, Me%InstanceID,"UngetAdvectionDiffusion3Dreal4")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetAdvectionDiffusion3Dreal4

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine UngetAdvectionDiffusion3Dreal8(AdvectionDiffusionID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer                            :: AdvectionDiffusionID

        real(8), pointer, dimension(:,:,:) :: Array

        integer, optional, intent (OUT) :: STAT
   
        !External--------------------------------------------------------------

        integer :: ready_   

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)

cd1 :   if (ready_ == READ_LOCK_ERR_) then
            nullify(Array)

            call Read_Unlock(mADVECTIONDIFFUSION_, Me%InstanceID,"UngetAdvectionDiffusion3Dreal4")

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetAdvectionDiffusion3Dreal8

        !----------------------------------------------------------------------

    subroutine SetDischarges (AdvectionDiffusionID, DischFlow, DischConc,               &
                              DischI, DischJ, DischK, DischKmin, DischKmax,             &
                              DischVert, DischNumber, IgnoreDisch, DischnCells, ByPass, &
                              STAT)
    
    
        !Arguments--------------------------------------------------------------
        integer,           intent(IN )     :: AdvectionDiffusionID
        real,    pointer, dimension(:)     :: DischFlow, DischConc
        integer, pointer, dimension(:)     :: DischI, DischJ, DischK, DischKmin, DischKmax
        integer, pointer, dimension(:)     :: DischVert 
        integer,           intent(IN )     :: DischNumber
        logical, pointer, dimension(:)     :: IgnoreDisch, ByPass
        integer, pointer, dimension(:)     :: DischnCells
        integer, optional, intent(OUT)     :: STAT

        !Local-----------------------------------------------------------------

        integer :: STAT_            
        integer :: ready_              

        !----------------------------------------------------------------------                         

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)

cd1 :   if (ready_ == IDLE_ERR_) then

            Me%ExternalVar%DischON      = .true.

            Me%ExternalVar%DischNumber  =  DischNumber

            Me%ExternalVar%DischFlow    => DischFlow 
            Me%ExternalVar%DischConc    => DischConc 
            Me%ExternalVar%DischI       => DischI 
            Me%ExternalVar%DischJ       => DischJ 
            Me%ExternalVar%DischK       => DischK 
            Me%ExternalVar%DischKmin    => DischKmin 
            Me%ExternalVar%DischKmax    => DischKmax
            Me%ExternalVar%DischVert    => DischVert
            Me%ExternalVar%IgnoreDisch  => IgnoreDisch
            Me%ExternalVar%DischnCells  => DischnCells
            Me%ExternalVar%ByPass       => ByPass


            STAT_ = SUCCESS_
        else               
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                              &
            STAT = STAT_

    end subroutine SetDischarges 

        !----------------------------------------------------------------------

        !----------------------------------------------------------------------

    subroutine UnSetDischarges (AdvectionDiffusionID, STAT)
    
    
        !Arguments--------------------------------------------------------------
        integer,           intent(IN )     :: AdvectionDiffusionID
        integer, optional, intent(OUT)     :: STAT

        !Local-----------------------------------------------------------------

        integer :: STAT_            
        integer :: ready_              

        !----------------------------------------------------------------------                         

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)

cd1 :   if (ready_ == IDLE_ERR_) then

            Me%ExternalVar%DischON      = .false.

            Me%ExternalVar%DischNumber  = null_int

            nullify(Me%ExternalVar%DischFlow)
            nullify(Me%ExternalVar%DischConc)
            nullify(Me%ExternalVar%DischI   )
            nullify(Me%ExternalVar%DischJ   )
            nullify(Me%ExternalVar%DischK   )
            nullify(Me%ExternalVar%DischKmin)            
            nullify(Me%ExternalVar%DischKmax)            
            nullify(Me%ExternalVar%DischVert)
            nullify(Me%ExternalVar%IgnoreDisch)
            nullify(Me%ExternalVar%DischnCells)
            nullify(Me%ExternalVar%ByPass     )


            STAT_ = SUCCESS_
        else               
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                              &
            STAT = STAT_

    end subroutine UnSetDischarges 

        !----------------------------------------------------------------------


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MO 

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



    !   AdvectionDiffusion Resolve a equacao de adveccao-difusao                      
    !                      na sua forma Euleriana com adveccao vertical e 
    !                      difusao vertical implicitas. Considera-se que a                      
    !                      propriedade encontra-se no centro das celulas e que os                     
    !                      fluxos de agua nas suas faces sao conhecidos.       


    subroutine AdvectionDiffusion(AdvectionDiffusionID,                         &
                                  PROP,                                         &    
                                  schmidt_H,                                    &
                                  SchmidtCoef_V,                                &
                                  SchmidtBackground_V,                          &
                                  AdvMethodH,                                   &
                                  TVDLimitationH,                               &
                                  AdvMethodV,                                   &
                                  TVDLimitationV,                               &
                                  Upwind2H,                                     &
                                  Upwind2V,                                     &
                                  VolumeRelMax,                                 &
                                  AdvectionNudging,                             &
                                  AdvectionNudgingCells,                        &
                                  DTProp,                                       &
                                  ImpExp_AdvV, ImpExp_DifV,                     &
                                  ImpExp_AdvXX, ImpExp_AdvYY,                   &
                                  ImpExp_DifH, NullDif,                         &
                                  Wflux_X, Wflux_Y, Wflux_Z,                    &
                                  VolumeZOld, VolumeZ,                          &
                                  OpenPoints3D,                                 &
                                  LandPoints3D,                                 &
                                  ComputeFacesU3D, ComputeFacesV3D,             &
                                  ComputeFacesW3D,                              &
                                  Visc_H, Diff_V,                               &
                                  CellFluxes,                                   &
                                  WaterPoints3D,                                &
                                  ReferenceProp,                                &
                                  BoundaryCondition,                            &
                                  DecayTime,                                    &
                                  NumericStability,                             &   
                                  PROPOld,                                      &
                                  SmallDepths,                                  &
                                  NoAdvFlux,                                    &
                                  NoDifFlux,                                    &                                  
                                  NoFluxU,                                      &
                                  NoFluxV,                                      &
                                  NoFluxW,                                      &
                                  Optimize, FirstProperty,                      &
                                  STAT)

        !Arguments-------------------------------------------------------------
        integer                            :: AdvectionDiffusionID

        integer, optional, intent(OUT)     :: STAT

        logical, optional, intent(IN )     :: NumericStability

        real,                          pointer, dimension(:,:,:) :: PROP
        real,    optional,             pointer, dimension(:,:,:) :: ReferenceProp
        real,    optional,             pointer, dimension(:,:,:) :: PROPOld

        !Hydrodynamic
        real(8),                       pointer, dimension(:,:,:) :: Wflux_X, Wflux_Y, Wflux_Z
        real(8),                       pointer, dimension(:,:,:) :: VolumeZOld, VolumeZ
        real,                          pointer, dimension(:,:,:) :: Visc_H
        real,                          pointer, dimension(:,:,:) :: Diff_V
        integer, dimension(:, :, :), pointer                     :: OpenPoints3D
        integer, dimension(:, :, :), pointer, optional           :: WaterPoints3D
        integer, dimension(:, :, :), pointer                     :: LandPoints3D
        integer, dimension(:, :, :), pointer                     :: ComputeFacesU3D
        integer, dimension(:, :, :), pointer                     :: ComputeFacesV3D
        integer, dimension(:, :, :), pointer                     :: ComputeFacesW3D

        real,              intent(IN )     :: schmidt_H
        real,              intent(IN)      :: SchmidtCoef_V
        real,              intent(IN)      :: SchmidtBackground_V 
        integer,           intent(IN)      :: AdvMethodH, TVDLimitationH
        integer,           intent(IN)      :: AdvMethodV, TVDLimitationV
        logical,           intent(IN)      :: Upwind2H, Upwind2V
        real   ,           intent(IN)      :: VolumeRelMax 
        logical,           intent(IN)      :: AdvectionNudging
        integer,           intent(IN)      :: AdvectionNudgingCells
        real,    optional, intent(IN )     :: DecayTime 
        real,              intent(IN )     :: DTProp
        real,              intent(IN )     :: ImpExp_DifV, ImpExp_AdvV 
        real,              intent(IN )     :: ImpExp_AdvXX, ImpExp_AdvYY, ImpExp_DifH
        Logical,           intent(IN )     :: NullDif
 
        logical, optional, intent(IN )     :: CellFluxes                    !State variable to calculate Difusive 
                                                                            ! and Advective fluxes among cells.

        integer, optional, intent(IN )     :: BoundaryCondition             !State variable to impose
                                                                            ! boundary conditions

        logical, dimension(:, : ), pointer, optional :: SmallDepths
        
        logical, optional, intent(IN )     :: NoAdvFlux, Optimize, FirstProperty
        logical, optional, intent(IN )     :: NoDifFlux        

        integer, dimension(:,:,:), pointer, optional :: NoFluxU, NoFluxV, NoFluxW

        !External--------------------------------------------------------------

        integer :: STAT_CALL
        integer :: ready_              

        logical :: NumericStability_
        logical :: CellFluxes_                

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable
        integer :: ILB, IUB, JLB, JUB, KLB, KUB

        !----------------------------------------------------------------------                         

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)

cd1 :   if (ready_ == IDLE_ERR_) then

            if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusion")

            ! Actualized the time
            call GetComputeCurrentTime(Me%ObjTime, Me%Now, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_)                                        &
                stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR01'

            ILB = Me%Size%ILB;  JLB = Me%Size%JLB;  KLB = Me%Size%KLB
            IUB = Me%Size%IUB;  JUB = Me%Size%JUB;  KUB = Me%Size%KUB

            if ((ImpExp_AdvXX == ImplicitScheme .or. ImpExp_AdvYY == ImplicitScheme) .and.  &
                (AdvMethodH   == UpwindOrder2   .or. AdvMethodH   == UpwindOrder3  )) then
                stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR100'
            endif

            if ((ImpExp_AdvV  == ImplicitScheme                                    ) .and.  &
                (AdvMethodV   == UpwindOrder2   .or. AdvMethodV   == UpwindOrder3  )) then
                stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR200'
            endif


cd12 :      if (present(ReferenceProp)) then
cd6  :          if (associated(ReferenceProp)) then
                    Me%ExternalVar%ReferenceProp => ReferenceProp
                else
                    nullify(Me%ExternalVar%ReferenceProp)
                end if cd6
            else
                nullify(Me%ExternalVar%ReferenceProp)
            end if cd12


cd62 :      if (present(PROPOld)) then
cd65  :          if (associated(PROPOld)) then
                    Me%ExternalVar%PROPOld => PROPOld
                else
                    nullify(Me%ExternalVar%PROPOld)
                end if cd65
            else 
                nullify(Me%ExternalVar%PROPOld)
            end if cd62



cd99 :      if (present(NumericStability)) then
                NumericStability_ = NumericStability
            else cd99
                NumericStability_ =.FALSE.
            end if cd99

            Me%ExternalVar%PROP               => PROP
            Me%ExternalVar%Wflux_X            => Wflux_X
            Me%ExternalVar%Wflux_Y            => Wflux_Y
            Me%ExternalVar%Wflux_Z            => Wflux_Z
            Me%ExternalVar%Visc_H             => Visc_H
            Me%ExternalVar%Diff_V             => Diff_V
            Me%ExternalVar%VolumeZOld         => VolumeZOld
            Me%ExternalVar%VolumeZ            => VolumeZ
            Me%ExternalVar%OpenPoints3D       => OpenPoints3D
            Me%ExternalVar%LandPoints3D       => LandPoints3D
            Me%ExternalVar%ComputeFacesU3D    => ComputeFacesU3D
            Me%ExternalVar%ComputeFacesV3D    => ComputeFacesV3D
            Me%ExternalVar%ComputeFacesW3D    => ComputeFacesW3D
            
            if (present(WaterPoints3D)) Me%ExternalVar%WaterPoints3D => WaterPoints3D
            
            if (present(SmallDepths)) then
                Me%ExternalVar%SmallDepthsPresent = .true.
                Me%ExternalVar%SmallDepths        => SmallDepths
            else
                Me%ExternalVar%SmallDepthsPresent = .false.
            endif

            Me%ExternalVar%ImpExp_DifV      = ImpExp_DifV   
            Me%ExternalVar%ImpExp_AdvXX     = ImpExp_AdvXX 
            Me%ExternalVar%ImpExp_AdvYY     = ImpExp_AdvYY
            Me%ExternalVar%ImpExp_AdvV      = ImpExp_AdvV

            Me%ExternalVar%ImpExp_DifH      = ImpExp_DifH

            Me%ExternalVar%Upwind2H         = Upwind2H
            Me%ExternalVar%Upwind2V         = Upwind2V
            Me%ExternalVar%VolumeRelMax     = VolumeRelMax
            Me%ExternalVar%AdvectionNudging = AdvectionNudging            
            Me%ExternalVar%AdvectionNudgingCells = AdvectionNudgingCells

cd9 :       if (present(DecayTime)) then
                Me%ExternalVar%DecayTime = DecayTime
            else
                Me%ExternalVar%DecayTime = null_real
            end if cd9


cd10 :      if (present(BoundaryCondition)) then
                Me%ExternalVar%BoundaryCondition = BoundaryCondition
            else
                Me%ExternalVar%BoundaryCondition = null_int
            end if cd10


cd110:      if (present(NoAdvFlux)) then
                Me%ExternalVar%NoAdvFlux  =  NoAdvFlux
            else
                Me%ExternalVar%NoAdvFlux  = .false.
            end if cd110

cd111:      if (present(NoDifFlux)) then
                Me%ExternalVar%NoDifFlux  =  NoDifFlux
            else
                Me%ExternalVar%NoDifFlux  = .false.
            end if cd111
            
            if (present(NoFluxU)) Me%ExternalVar%NoFluxU => NoFluxU
            if (present(NoFluxV)) Me%ExternalVar%NoFluxV => NoFluxV
            if (present(NoFluxW)) Me%ExternalVar%NoFluxW => NoFluxW
            
            if (present(Optimize))      Me%ExternalVar%Optimize = Optimize
            if (present(FirstProperty)) Me%FirstProperty        = FirstProperty

cd7 :       if (ImpExp_DifH  /= 0.0) then    !0 = Explicit
                write(*,*) 'Horizontal Diffusion must be explicit.'
                stop       'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR02'
            end if cd7


cd66 :      if (ImpExp_AdvXX == ImplicitScheme .and. ImpExp_AdvYY == ImplicitScheme) then    
                write(*,*) 'Horizontal Advection can not be implicit in both directions.'
                stop       'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR03'
            end if cd66


            !DUX, DVY, DZX, DZY
            call GetHorizontalGrid(Me%ObjHorizontalGrid,                                &
                                   DUX = Me%ExternalVar%DUX,                            &
                                   DVY = Me%ExternalVar%DVY,                            &
                                   DZX = Me%ExternalVar%DZX,                            &
                                   DZY = Me%ExternalVar%DZY,                            &
                                   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR04'
                
            call GetDDecompParameters(HorizontalGridID = Me%ObjHorizontalGrid,          &
                                      ON               = Me%DDecomp%ON,                 &
                                      MasterOrSlave    = Me%DDecomp%MasterOrSlave,      &
                                      STAT             = STAT_CALL)
                                                  
            if (STAT_CALL /= SUCCESS_) then
                stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR04a'
            endif                


            !BoundaryPoints2D
            call GetBoundaries(Me%ObjHorizontalMap, Me%ExternalVar%BoundaryPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR05'

            !KFloorZ
            call GetGeometryKFloor(Me%ObjGeometry, Z = Me%ExternalVar%KFloorZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR06a'
            
            !KFloorU
            call GetGeometryKFloor(Me%ObjGeometry, U = Me%ExternalVar%KFloorU, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR06b'
            
            !KFloorV
            call GetGeometryKFloor(Me%ObjGeometry, V = Me%ExternalVar%KFloorV, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR06c'

            !AreaU, AreaV
            call GetGeometryAreas(Me%ObjGeometry,                     &
                                  AreaU = Me%ExternalVar%AreaU,       &
                                  AreaV = Me%ExternalVar%AreaV,       &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR08'

            !DZZ, DWZ
            call GetGeometryDistances(Me%ObjGeometry,                 &
                                      DZZ = Me%ExternalVar%DZZ,       &
                                      DWZ = Me%ExternalVar%DWZ,       &
                                      STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'AdvectionDiffusion - ModuleAdvectionDiffusion - ERR09'

cd11 :      if (present(CellFluxes)) then
                CellFluxes_ = CellFluxes
            else
                CellFluxes_ = .FALSE.
            end if cd11

            call Set_Internal_State(DTProp, CellFluxes_, AdvMethodH, TVDLimitationH, AdvMethodV, TVDLimitationV, &
                                    SchmidtCoef_V, SchmidtBackground_V, Schmidt_H, NullDif)

            Me%ExternalVar%DTProp              = DTProp
            Me%ExternalVar%AdvMethodH          = AdvMethodH
            Me%ExternalVar%TVDLimitationH      = TVDLimitationH
            Me%ExternalVar%SchmidtCoef_V       = SchmidtCoef_V    
            Me%ExternalVar%SchmidtBackground_V = SchmidtBackground_V
            Me%ExternalVar%NullDif            =  NullDif
            Me%ExternalVar%Schmidt_H           = Schmidt_H
            Me%ExternalVar%DTProp              = DTProp
            
            if(Me%Vertical1D) Me%ExternalVar%Optimize = .false.
            
            if (Me%State%VertDif) then
                if (Me%ExternalVar%Optimize) then
                    if (Me%FirstProperty) call Convert_Dif_Vertical()
                else
                    call Convert_Dif_Vertical()
                endif
            endif

            if (Me%State%HorDif) then
                if (Me%ExternalVar%Optimize) then
                    if (Me%FirstProperty) call Convert_Visc_Dif_Horizontal_opt() 
                else
                    call Convert_Visc_Dif_Horizontal()   
                endif
            endif

cd8 :       if (Me%State%VertAdv) then

                Me%ExternalVar%AdvMethodV       = AdvMethodV
                Me%ExternalVar%TVDLimitationV   = TVDLimitationV
                
                if (Me%ExternalVar%Optimize) then
                    if (Me%FirstProperty) then
                        call SetMatrixValue (Me%COEF3_VertAdv%D_flux, Me%Size, 0.0)
                        call SetMatrixValue (Me%COEF3_VertAdv%E_flux, Me%Size, 0.0)
                    endif
                else
                    call SetMatrixValue (Me%COEF3_VertAdv%C_flux, Me%Size, 0.0)
                    call SetMatrixValue (Me%COEF3_VertAdv%D_flux, Me%Size, 0.0)
                    call SetMatrixValue (Me%COEF3_VertAdv%E_flux, Me%Size, 0.0)
                    call SetMatrixValue (Me%COEF3_VertAdv%F_flux, Me%Size, 0.0)
                endif
                    
            end if cd8

cd5 :       if (Me%State%CellFluxes) then
                
                Me%Fluxes%LastFluxCalculation = Me%Now  !Now is former TIMEI

                call SetMatrixValue (Me%Fluxes%AdvFluxX, Me%Size, dble(0.0))
                call SetMatrixValue (Me%Fluxes%AdvFluxY, Me%Size, dble(0.0))
                call SetMatrixValue (Me%Fluxes%AdvFluxZ, Me%Size, dble(0.0))

                call SetMatrixValue (Me%Fluxes%DifFluxX, Me%Size, dble(0.0))
                call SetMatrixValue (Me%Fluxes%DifFluxY, Me%Size, dble(0.0))
                call SetMatrixValue (Me%Fluxes%DifFluxZ, Me%Size, dble(0.0))

            end if cd5
            
            if (Me%ExternalVar%Optimize) then
                if (Me%FirstTime) then
                    allocate(Me%Diff_H_Const_U(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
                    allocate(Me%Diff_H_Const_V(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
                    
                    allocate(Me%Diff_V_Const  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
                    Me%FirstTime = .false.
                endif
                
                if (Me%FirstProperty) then
                    call Compute_DifH_Constants
                    call Compute_DifV_Constants
                endif
            endif

            call AdvectionDiffusionIteration(ImpExp_AdvXX, ImpExp_AdvYY)                     !AdvectionDiffusion main cycle

            call FinishAdvectionDiffusionIt()                  !Nullify external variables

            Me%LastCalc = Me%Now

            call null_time   (Me%Now)

            STAT_ = SUCCESS_

            if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusion")

        else               
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine AdvectionDiffusion

    !--------------------------------------------------------------------------
                                  
    !-----------------------------------------------------------------------
    subroutine Compute_DifH_Constants
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k, ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: CHUNK

        !----------------------------------------------------------------------
        CHUNK = Chunk_K(Me%WorkSize%KLB,Me%WorkSize%KUB)
        
        ILB = Me%Size%ILB ; JLB = Me%Size%JLB ; KLB = Me%Size%KLB
        IUB = Me%Size%IUB ; JUB = Me%Size%JUB ; KUB = Me%Size%KUB 
        
        !$OMP PARALLEL PRIVATE(i,j,k) 
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB
            if (Me%ExternalVar%ComputeFacesV3D(i, j, k) == 1) then
                
                Me%Diff_H_Const_V(i, j, k) = Me%Diffusion_CoeficientY (i,j,k) * Me%ExternalVar%AreaV(i  ,j,k) / &
                                                                                Me%ExternalVar%DZY  (i-1,j  )

            endif
        end do
        end do
        end do
        !$OMP END DO
        
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB
            if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then
                
                Me%Diff_H_Const_U(i, j, k) = Me%Diffusion_CoeficientX (i,j,k) * Me%ExternalVar%AreaU(i,j  ,k) / &
                                                                                Me%ExternalVar%DZX  (i,j-1  )

            endif
        end do
        end do
        end do
        !$OMP END DO
        !$OMP END PARALLEL
        
    end subroutine Compute_DifH_Constants

    !--------------------------------------------------------------------------
    
    subroutine Compute_DifV_Constants
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: AuxK
        integer                                     :: i, j, k, ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: CHUNK

        !----------------------------------------------------------------------
        CHUNK = Chunk_K(Me%WorkSize%KLB,Me%WorkSize%KUB)
        
        ILB = Me%WorkSize%ILB ; JLB = Me%WorkSize%JLB ; KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB ; JUB = Me%WorkSize%JUB ; KUB = Me%WorkSize%KUB
        
        !$OMP PARALLEL PRIVATE(i,j,k,AuxK) 
        
        if (Me%ExternalVar%SmallDepthsPresent) then
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1) then
                    if (.not. Me%ExternalVar%SmallDepths(i,j)) then
                        
                        AuxK  =  Me%Diffusion_CoeficientZ (i,j,k  )                              &
                                * Me%ExternalVar%DUX      (i,j    )                              &
                                * Me%ExternalVar%DVY      (i,j    )
                        ! [m^2/s * m * m / m]
                        Me%Diff_V_Const(i, j, k) = AuxK / Me%ExternalVar%DZZ (i,j,k-1)
                    endif
                endif
            end do
            end do
            end do
            !$OMP END DO
        else
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1) then
                
                    AuxK  =  Me%Diffusion_CoeficientZ (i,j,k  )                              &
                            * Me%ExternalVar%DUX      (i,j    )                              &
                            * Me%ExternalVar%DVY      (i,j    )
                
                    Me%Diff_V_Const(i, j, k) = AuxK / Me%ExternalVar%DZZ (i,j,k-1)

                endif
            end do
            end do
            end do
            !$OMP END DO
        endif
        !$OMP END PARALLEL
        
    end subroutine Compute_DifV_Constants

    
    !--------------------------------------------------------------------------

    subroutine AdvectionDiffusionIteration(ImpExp_AdvXX, ImpExp_AdvYY)

        !Arguments-------------------------------------------------------------
        real,    intent(IN)                 :: ImpExp_AdvXX, ImpExp_AdvYY

        !Local-----------------------------------------------------------------
        integer                             :: ILBWS, IUBWS, JLBWS, JUBWS, KLBWS, KUBWS
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: di, dj
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusionIteration")

        ILBWS = Me%WorkSize%ILB
        IUBWS = Me%WorkSize%IUB

        JLBWS = Me%WorkSize%JLB
        JUBWS = Me%WorkSize%JUB

        KLBWS = Me%WorkSize%KLB
        KUBWS = Me%WorkSize%KUB

        ILB   = Me%Size%ILB
        IUB   = Me%Size%IUB

        JLB   = Me%Size%JLB 
        JUB   = Me%Size%JUB

        KLB   = Me%Size%KLB
        KUB   = Me%Size%KUB

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusionIteration_1")

        !Inicializacao dos coeficientes DCOEF3,ECOEF3,FCOEF3 e independent term
        if (Me%ExternalVar%Optimize) then
            if (Me%FirstProperty) then
                call SetMatrixValue (Me%TICOEF3, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3%E, Me%Size, dble(1.0))
            endif
            call SetMatrixValue (Me%COEF3%D, Me%Size, 0.0)
            call SetMatrixValue (Me%COEF3%F, Me%Size, 0.0)
            
        else
            call SetMatrixValue (Me%COEF3%D, Me%Size, 0.0)
            call SetMatrixValue (Me%COEF3%E, Me%Size, dble(1.0))
            call SetMatrixValue (Me%COEF3%F, Me%Size, 0.0)
            call SetMatrixValue (Me%TICOEF3, Me%Size, 0.0)
        endif
        
     
cd2 :   if (Me%State%HorAdv) then
            
            if (Me%ExternalVar%Optimize) then
                 if (Me%FirstProperty) then
                    call SetMatrixValue (Me%COEF3_HorAdvXX%D_flux, Me%Size, 0.0)
                    call SetMatrixValue (Me%COEF3_HorAdvXX%E_flux, Me%Size, 0.0)

                    call SetMatrixValue (Me%COEF3_HorAdvYY%D_flux, Me%Size, 0.0)
                    call SetMatrixValue (Me%COEF3_HorAdvYY%E_flux, Me%Size, 0.0)
                 endif   
            else
                call SetMatrixValue (Me%COEF3_HorAdvXX%C_flux, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3_HorAdvXX%D_flux, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3_HorAdvXX%E_flux, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3_HorAdvXX%F_flux, Me%Size, 0.0)

                call SetMatrixValue (Me%COEF3_HorAdvYY%C_flux, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3_HorAdvYY%D_flux, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3_HorAdvYY%E_flux, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3_HorAdvYY%F_flux, Me%Size, 0.0)
            endif
        end if cd2

        ! evolutive term + Volume Variation
        call VolumeVariation()

        if (Me%ExternalVar%DischON) call Discharges ()

        if (.not. Me%Vertical1D) then

            ! Calculo dos fluxos difusivos horizontais da propriedade e actualizacao                         
            ! imediata do termo independente
            call HorizontalDiffusion()

            ! Calculo dos fluxos advectivos da propriedade 
            !if (Me%ExternalVar%AdvMethodH == UpwindOrder1       .and.                   &
            !    ImpExp_AdvXX == ExplicitScheme .and. ImpExp_AdvYY == ExplicitScheme) then
                
            !    call HorizontalAdvectionUpwindExplict          
                      
            !else
            
            call HorizontalAdvection(ImpExp_AdvXX, ImpExp_AdvYY)
                
            !endif                

        endif


        if (KUBWS > 1) then
            if (Me%ExternalVar%Optimize) then
                call VerticalDiffusion2 ()
            else
                call VerticalDiffusion ()
            endif
            
            if (.not. Me%ExternalVar%AdvectionNudging) then
                if (.not. Me%Vertical1D) call VerticalAdvection()
            else
                if (.not. Me%Vertical1D) call VerticalAdvection_Nudge()
            endif
        endif
        
        if (Me%ExternalVar%AdvectionNudging) then
        
            call AdvectionNudging( Me%ExternalVar%AdvectionNudging, Me%ExternalVar%AdvectionNudgingCells)
        
        endif

        ! This subroutine must be always the last to be called
        if (Me%State%OpenBoundary)                                                      &
            call OpenBoundaryCondition() 

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusionIteration_1")
        
!        ! At this stage the variable TICOEF3 have null values in the land points
!        ! We want that all proprieties in land points have the value of Null_Real.
        call SetMatrixValue (Me%TICOEF3, Me%Size, Null_Real, Me%ExternalVar%LandPoints3D)

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusionIteration_TH")

cd3:    if (KUBWS == 1 .and. ImpExp_AdvXX == ImplicitScheme) then !ImplicitScheme = 0

            di = 0
            dj = 1
            
            if (Me%DDecomp%MasterOrSlave) then
            
#if _USE_MPI            
            
                call THOMAS_DDecompHorizGrid(HorizontalGridID = Me%ObjHorizontalGrid,   &
                                             DCoef_3D         = Me%COEF3%D,             &
                                             FCoef_3D         = Me%COEF3%F,             &
                                             TiCoef_3D        = Me%TICOEF3,             &
                                             ECoef_3D         = Me%COEF3%E,             &
                                             Results_3D       = Me%ExternalVar%PROP,    &
                                             di               = di,                     &
                                             dj               = dj,                     &
                                             KLB              = KLB,                    &
                                             KUB              = KUB,                    &
                                             STAT             = STAT_CALL)
                                             
#else                        
                STAT_CALL = SUCCESS_                 
                                             
#endif _USE_MPI

                if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusionIteration - ModuleAdvectionDiffusion - ERR10'

            else
                                                         
                call THOMAS_3D(ILBWS, IUBWS,                                                &
                               JLBWS, JUBWS,                                                &
                               KLBWS, KUBWS,                                                &
                               di, dj,                                                      &
                               Me%THOMAS,                                                   &
                               Me%ExternalVar%PROP                                          &     
#ifdef _ENABLE_CUDA
                               , Me%ObjCuda,                                                &
                               .FALSE.                                                      &
#endif _ENABLE_CUDA
                               )
                               
            endif      
                                  
        else if (KUBWS == 1 .and. ImpExp_AdvYY == ImplicitScheme) then cd3 !ImplicitScheme = 0

            di = 1
            dj = 0
            
            if (Me%DDecomp%MasterOrSlave) then

#if _USE_MPI
            
                call THOMAS_DDecompHorizGrid(HorizontalGridID = Me%ObjHorizontalGrid,   &
                                             DCoef_3D         = Me%COEF3%D,             &
                                             FCoef_3D         = Me%COEF3%F,             &
                                             TiCoef_3D        = Me%TICOEF3,             &
                                             ECoef_3D         = Me%COEF3%E,             &
                                             Results_3D       = Me%ExternalVar%PROP,    &
                                             di               = di,                     &
                                             dj               = dj,                     &
                                             KLB              = KLB,                    &
                                             KUB              = KUB,                    &
                                             STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusionIteration - ModuleAdvectionDiffusion - ERR20'
                                             
#endif _USE_MPI


            else            

                call THOMAS_3D(JLBWS, JUBWS,                                            &
                               ILBWS, IUBWS,                                            &
                               KLBWS, KUBWS,                                            &
                               di, dj,                                                  &
                               Me%THOMAS,                                               &
                               Me%ExternalVar%PROP                                      &      
#ifdef _ENABLE_CUDA
                               , Me%ObjCuda,                                            &
                               .FALSE.                                                  &
#endif _ENABLE_CUDA
                               )
                               
            endif
                                           
        else cd3
 
            ! If the model is 3D the vertical diffusion must be implicit so is necessary to 
            ! compute the vertical diffusion  implicitly
            
!            call THOMASZ(ILBWS, IUBWS,                                                  &
!                         JLBWS, JUBWS,                                                  &
!                         KLBWS, KUBWS,                                                  &
!                         Me%THOMAS,                                                     &
!                         Me%ExternalVar%PROP                                            &
!#ifdef _ENABLE_CUDA
!                         , Me%ObjCuda,                                                  &
!                         .FALSE.                                                        &
!#endif _ENABLE_CUDA
!                        )
            call THOMASZ_NewType2(ILBWS, IUBWS,                                         &
                         JLBWS, JUBWS,                                                  &
                         KLBWS, KUBWS,                                                  &
                         Me%THOMAS,                                                     &
                         Me%ExternalVar%PROP, Me%ExternalVar%WaterPoints3D             &
#ifdef _ENABLE_CUDA
                         , Me%ObjCuda,                                                  &
                         .FALSE.                                                        &
#endif _ENABLE_CUDA
                        )

        endif cd3

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusionIteration_TH")


        if      (Me%ExternalVar%BoundaryCondition == NullGradient_) then

            call ImposeNullGradient()

        else if (Me%ExternalVar%BoundaryCondition == CyclicBoundary_) then

            call Prop_CyclicBoundary()

        endif


cd5 :   if (Me%State%CellFluxes) then
            if (Me%ExternalVar%Optimize) then
                
                if (Me%ExternalVar%ImpExp_AdvV > 0.0 .and. KUBWS > 1)                       &
                    call CalcVerticalAdvFlux_opt(Me%ExternalVar%ImpExp_AdvV)

                if (Me%ExternalVar%ImpExp_DifV > 0.0 .and. KUBWS > 1) then
                    call CalcVerticalDifFlux2 (Me%ExternalVar%ImpExp_DifV )
                endif

                if (Me%ExternalVar%ImpExp_AdvXX == ImplicitScheme)                          &
                    call CalcHorizontalAdvFluxXX_opt(Me%ExternalVar%ImpExp_AdvXX)

                if (Me%ExternalVar%ImpExp_AdvYY == ImplicitScheme)                          &
                    call CalcHorizontalAdvFluxYY_opt(Me%ExternalVar%ImpExp_AdvYY)
            else
                if (Me%ExternalVar%ImpExp_AdvV > 0.0 .and. KUBWS > 1)                       &
                    call CalcVerticalAdvFlux(Me%ExternalVar%ImpExp_AdvV)

                if (Me%ExternalVar%ImpExp_DifV > 0.0 .and. KUBWS > 1)                       &
                    call CalcVerticalDifFlux (Me%ExternalVar%ImpExp_DifV )


                if (Me%ExternalVar%ImpExp_AdvXX == ImplicitScheme)                          &
                    call CalcHorizontalAdvFluxXX(Me%ExternalVar%ImpExp_AdvXX)

                if (Me%ExternalVar%ImpExp_AdvYY == ImplicitScheme)                          &
                    call CalcHorizontalAdvFluxYY(Me%ExternalVar%ImpExp_AdvYY)  
            endif
            

        end if cd5

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "AdvectionDiffusionIteration")

        !----------------------------------------------------------------------

    end subroutine AdvectionDiffusionIteration

    !--------------------------------------------------------------------------

    subroutine ImposeNullGradient()


        !Arguments--------------------------------------------------------------

        !Local------------------------------------------------------------------
        real     :: BoundaryProp
        logical  :: Found
        integer  :: i, j, k, ILB, IUB, JLB, JUB, KLB, KUB
        integer  :: CHUNK
 

        !Begin------------------------------------------------------------------


        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KUB = Me%WorkSize%KUB

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "ImposeNullGradient")

        CHUNK = CHUNK_J(JLB,JUB)

        !!$OMP PARALLEL PRIVATE(j,i,k,KLB,BoundaryProp,Found)
        !!$OMP DO SCHEDULE(GUIDED,CHUNK)
do3 :   do  j = JLB, JUB
do2 :   do  i = ILB, IUB

cd1 :       if (Me%ExternalVar%BoundaryPoints2D(i,j) == 1) then 

                KLB = ABS(Me%ExternalVar%KFloorZ(i,j))
                

do1 :           do  k = KLB, KUB


                    call NullGradProp(BoundaryProp, i, j, k, Found)

                    if (Found) then

                        Me%ExternalVar%Prop(i, j, k) = BoundaryProp 

                    endif


                enddo do1


            endif cd1

        enddo do2
        enddo do3
        !!$OMP END DO
        !!$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "ImposeNullGradient")

    end subroutine ImposeNullGradient
    
    subroutine AdvectionNudging ( AdvectionNudge, nCells )

       !Arguments--------------------------------------------------------------
        logical, intent(IN)  :: AdvectionNudge
        integer, intent(IN)  :: nCells

        !Local------------------------------------------------------------------
        integer  :: i, j, k, ILB, IUB, JLB, JUB
        logical  :: NudgeCell
        integer  :: in, jn
        real     :: n 
        !$ integer :: CHUNK

        !Begin------------------------------------------------------------------    

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE(i,j,k,NudgeCell,in,jn,n)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            NudgeCell = .false.

            if ( AdvectionNudge ) then

                if (i<nCells+1) then 
                    NudgeCell = .true.    
                    in = max(0, i-ILB+1) 
                else if (i>IUB-nCells) then 
                    NudgeCell = .true.    
                    in = max(0, IUB-i+1) 
                endif

                if (j<nCells+1) then 
                    NudgeCell = .true.    
                    jn = max(0, j-JLB+1) 
                else if (j>JUB-nCells) then 
                    NudgeCell = .true.    
                    jn = max(0, JUB-j+1) 
                endif

            endif

            if (NudgeCell) then
                n = min(in,jn)
                n = n/nCells
            else
                n = 1.0
            endif

!            Me%AdvectionTi(i,j,:) = n * Me%AdvectionTi(i,j,:)
!            Me%AdvectionD (i,j,:) = n * Me%AdvectionD (i,j,:)            
!            Me%AdvectionE (i,j,:) = n * Me%AdvectionE (i,j,:)            
!            Me%AdvectionF (i,j,:) = n * Me%AdvectionF (i,j,:)   

            do k=Me%WorkSize%KLB,Me%WorkSize%KUB

                if (Me%ExternalVar%OpenPoints3D (i,j,k) == 1) then                                 

                    Me%TICOEF3(i, j, k) = Me%TICOEF3(i, j, k) + n * Me%AdvectionTi(i, j, k)
                    Me%Coef3%D(i, j, k) = Me%Coef3%D(i, j, k) + n * Me%AdvectionD (i, j, k)
                    Me%Coef3%E(i, j, k) = Me%Coef3%E(i, j, k) + n * Me%AdvectionE (i, j, k)
                    Me%Coef3%F(i, j, k) = Me%Coef3%F(i, j, k) + n * Me%AdvectionF (i, j, k)

                endif
            enddo

        enddo
        enddo
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

    end subroutine AdvectionNudging


    subroutine NullGradProp(BoundaryProp, i, j, k, Found)

        !Arguments--------------------------------------------------------------
        integer, intent(IN)                 :: i, j, k  
        real,    intent(OUT)                :: BoundaryProp
        logical, intent(OUT)                :: Found

        !Local------------------------------------------------------------------
        integer  :: Aux

        !Begin------------------------------------------------------------------

        Aux = Me%ExternalVar%ComputeFacesV3D(i + 1, j, k)+&
              Me%ExternalVar%ComputeFacesV3D(i    , j, k)+&  
              Me%ExternalVar%ComputeFacesU3D(i, j + 1, k)+&  
              Me%ExternalVar%ComputeFacesU3D(i    , j, k)

cd2:    if (Aux > 0) then

            BoundaryProp =                                                               &
               (Me%ExternalVar%Prop           (i + 1,     j, k)    *  &
                Me%ExternalVar%ComputeFacesV3D(i + 1,     j, k)    +  &
                Me%ExternalVar%Prop           (i - 1,     j, k)    *  &
                Me%ExternalVar%ComputeFacesV3D(i    ,     j, k)    +  &
                Me%ExternalVar%Prop           (i    , j + 1, k)    *  &
                Me%ExternalVar%ComputeFacesU3D(i    , j + 1, k)    +  &
                Me%ExternalVar%Prop           (i    , j - 1, k)    *  &
                Me%ExternalVar%ComputeFacesU3D(i    ,     j, k))   /  &
                real(Aux)

            Found = .true.

        else 

            Found = .false.

        endif cd2


    end subroutine NullGradProp

    !--------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed Cyclic conditions in the open boundary                         !
    !                                                                                      !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Prop_CyclicBoundary ()

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------
        integer, dimension(:,:  ), pointer  :: BoundaryPoints2D, KFloorZ

        real,    dimension(:,:,:), pointer  :: Prop, PropRef

        real                                :: DT_Prop

        integer                             :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                             :: i, j, k, kbottom

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name 

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        DT_Prop          =  Me%ExternalVar%DTProp

        BoundaryPoints2D => Me%ExternalVar%BoundaryPoints2D
        KFloorZ          => Me%ExternalVar%KFloorZ

        Prop             => Me%ExternalVar%Prop
        PropRef          => Me%ExternalVar%ReferenceProp


       
        !End   - Shorten variables name

do6:    do j = JLB, JUB     
do5:    do i = ILB, IUB     

            if (BoundaryPoints2D(i, j) == Boundary) Prop(i, j, KLB:KUB) = PropRef(i, j, KLB:KUB)

        enddo do5
        enddo do6
       
do1:    do  i = ILB + 1, IUB - 1

cd1:        if (BoundaryPoints2D(i, JLB) == Boundary .and.                               &
                BoundaryPoints2D(i, JUB) == Boundary) then

                kbottom = KFloorZ(i, JUB - 1)

do3:            do k = kbottom, KUB

                    Prop(i, JLB, k) = Prop(i, JUB-1, k)

                enddo do3

                kbottom = KFloorZ(i, JLB + 1)

do7:            do k = kbottom, KUB

                    Prop(i, JUB, k) = Prop(i, JLB+1, k)

                enddo do7

           
            endif cd1
                           
        enddo do1

        
do2:    do  j = JLB + 1, JUB - 1

cd2:        if (BoundaryPoints2D(ILB, j) == Boundary .and.                               &
                BoundaryPoints2D(IUB, j) == Boundary) then

                kbottom = KFloorZ(IUB-1, j)

do4:            do k=kbottom, KUB

                    Prop(ILB, j, k) = Prop(IUB-1, j, k)

                enddo do4

                kbottom = KFloorZ(ILB+1, j)

do8:            do k=kbottom, KUB

                    Prop(IUB, j, k) = Prop(ILB+1, j, k)

                enddo do8

            endif cd2
                           
        enddo do2

        !Nullify auxiliar variables
        nullify (Prop, PropRef, BoundaryPoints2D, KFloorZ)

        !----------------------------------------------------------------------

    End Subroutine Prop_CyclicBoundary

    !--------------------------------------------------------------------------


    subroutine FinishAdvectionDiffusionIt()

        !External--------------------------------------------------------------

        !----------------------------------------------------------------------
        integer                             :: STAT_CALL

        Me%ExternalVar%DecayTime = null_real

        !Nullifies pointer which entered per argument
        nullify(Me%ExternalVar%PROP              )
        nullify(Me%ExternalVar%Wflux_X           )
        nullify(Me%ExternalVar%Wflux_Y           )
        nullify(Me%ExternalVar%Wflux_Z           )
        nullify(Me%ExternalVar%Visc_H            )
        nullify(Me%ExternalVar%Diff_V            )
        nullify(Me%ExternalVar%VolumeZOld        )
        nullify(Me%ExternalVar%VolumeZ           )
        nullify(Me%ExternalVar%OpenPoints3D      )
        nullify(Me%ExternalVar%ComputeFacesU3D   )
        nullify(Me%ExternalVar%ComputeFacesV3D   )
        nullify(Me%ExternalVar%ComputeFacesW3D   )

        nullify(Me%ExternalVar%NoFluxU           )
        nullify(Me%ExternalVar%NoFluxV           )
        nullify(Me%ExternalVar%NoFluxW           )


        if (associated(Me%ExternalVar%ReferenceProp)) nullify(Me%ExternalVar%ReferenceProp)
        if (associated(Me%ExternalVar%PROPOld))       nullify(Me%ExternalVar%PROPOld)
            

        !DUX, DVY, DZY, DZX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                                  &
                                 Me%ExternalVar%DUX,                                    &
                                 STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR01'

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                                  &
                                 Me%ExternalVar%DVY,                                    &
                                 STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR02'

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                                  &
                                 Me%ExternalVar%DZY,                                    &
                                 STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR03'

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                                  &
                                 Me%ExternalVar%DZX,                                    &
                                 STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR04'

        !BoundaryPoints2D
        call UngetHorizontalMap(Me%ObjHorizontalMap,                                    &
                                Me%ExternalVar%BoundaryPoints2D,                        &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR05'

        !AreaU
        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%AreaU, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR08'

        !AreaV
        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%AreaV, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR09'

        !DZZ
        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%DZZ, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR10'

        !DWZ
        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%DWZ, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR11'

        !KFloorZ
        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%KFloorZ, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR12'
        
        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%KFloorU, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR13'

        call UnGetGeometry(Me%ObjGeometry,                                              &
                           Me%ExternalVar%KFloorV, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR14'
        !LandPoints3D
!        call UngetMap(Me%AppMap,                                      &
!                      Me%ExternalVar%LandPoints3D, STAT = STAT_CALL) 
!        if (STAT_CALL /= SUCCESS_)                                                     &
!            stop 'FinishAdvectionDiffusionIt - ModuleAdvectionDiffusion - ERR17'


        !Implicit-Explicit weight coeficients -> 1 = Implicit, 0 = Explicit
        Me%ExternalVar%ImpExp_AdvXX  = null_real         
        Me%ExternalVar%ImpExp_AdvYY  = null_real         
        Me%ExternalVar%ImpExp_AdvV   = null_real      
        Me%ExternalVar%ImpExp_DifH   = null_real    
        Me%ExternalVar%ImpExp_DifV   = null_real      


        !----------------------------------------------------------------------

    end subroutine FinishAdvectionDiffusionIt

    !--------------------------------------------------------------------------



    
    !--------------------------------------------------------------------------
    !MAnolo. Modification to Convert_VIsc_Dif_Vertical
    ! Computes diffusivities for every property from turbulent diffusivity and 
    ! SchmidtCoef_V and SchmidtBackground_V (read in WaterProperties)
    ! Diffusivity= SchmidtCoef_V * TurbulentDiffusivity + SchmidtBackground_V
    ! Also does some preparation work for subroutine vertical diffusion
    !--------------------------------------------------------------------------

    subroutine Convert_Dif_Vertical()

        !Local-----------------------------------------------------------------
        integer :: ILB, IUB 
        integer :: JLB, JUB 
        integer :: KLB, KUB
        integer :: i, j, k
        integer :: CHUNK
        
        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB 
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB
         

        !Begin-----------------------------------------------------------------
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "Convert_Dif_Vertical")
        
        !CHUNK = CHUNK_K(Me%Size%KLB, Me%Size%KUB)
        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)

do1:   do k = KLB + 1, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do2:   do j = JLB, JUB
do3:   do i = ILB, IUB     

cd1 :       if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1) then   

                Me%Diffusion_CoeficientZ(i,j,k) =                                       &                    
                              (Me%ExternalVar%SchmidtCoef_V                             &
                               * Me%ExternalVar%Diff_V(i,j,k)                           &
                               + Me%ExternalVar%SchmidtBackground_V)

            endif  cd1

        end do do3
        end do do2
        !$OMP END DO
        end do do1
        !! $OMP END PARALLEL


        if (Me%ExternalVar%NullDif)then

            do k = KLB + 1, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB     

                if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1) then   

                    if (Me%ExternalVar%Wflux_Z(i,j,k)==0.) then

                        Me%Diffusion_CoeficientZ(i, j, k) = 0.

                    end if

                end if

            enddo    
            enddo
            !$OMP END DO NOWAIT
            enddo   
         
        endif          
 
        !$OMP END PARALLEL
 
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "Convert_Dif_Vertical")
 
    end subroutine Convert_Dif_Vertical


    !--------------------------------------------------------------------------
    !
    ! Converte viscosidades turbulentas (definidas nos centros das células Z) 
    ! em difusões turbulentas (definidas nas faces das células Z)
    !
    !--------------------------------------------------------------------------

    subroutine Convert_Visc_Dif_Horizontal()

        !External--------------------------------------------------------------


        !Local-----------------------------------------------------------------
        
        integer :: ILB, IUB 
        integer :: JLB, JUB 
        integer :: KLB, KUB
        integer :: i, j, k
        integer :: CHUNK
        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB 
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "Convert_Visc_Dif_Horizontal")

        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)

        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then
 
                Me%Diffusion_CoeficientX(i, j, k) =                  &
                        Me%ExternalVar%Schmidt_H                     &
                        * (Me%ExternalVar%Visc_H(i,j,  k)            &
                        *  Me%ExternalVar%DUX(i,j-1)                 &
                        +  Me%ExternalVar%Visc_H(i,j-1,k)            &
                        *  Me%ExternalVar%DUX(i,j  ))                &
                        / (Me%ExternalVar%DUX(i,j    )               &
                        +  Me%ExternalVar%DUX(i,j-1))     
                        
                if (Me%ExternalVar%NoDifFlux) then
                    if (Me%ExternalVar%NoFluxU(i, j, k) == 1) then
                        Me%Diffusion_CoeficientX(i, j, k) = 0.
                    endif
                endif
                              

            endif

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            If (Me%ExternalVar%ComputeFacesV3D(i, j, k) == 1) then


                Me%Diffusion_CoeficientY(i,j,k)  =                    &
                            Me%ExternalVar%Schmidt_H                  &
                         * (Me%ExternalVar%Visc_H(i,  j,k)            &
                         *  Me%ExternalVar%DVY(i-1,j)                 &
                         +  Me%ExternalVar%Visc_H(i-1,j,k)            &
                         *  Me%ExternalVar%DVY(i,  j))                &
                         / (Me%ExternalVar%DVY(i,j)                   &
                         +  Me%ExternalVar%DVY(i-1,j))

                if (Me%ExternalVar%NoDifFlux) then
                    if (Me%ExternalVar%NoFluxV(i, j, k) == 1) then
                        Me%Diffusion_CoeficientY(i, j, k) = 0.
                    endif
                endif

            Endif

        
        enddo
        enddo
        !$OMP END DO
        enddo


nulldif:If (Me%ExternalVar%NullDif) Then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then

                    if (Me%ExternalVar%Wflux_X(i,j,k)==0.) then

                        Me%Diffusion_CoeficientX(i, j, k)=0.

                    endif

                endif

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo


            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%ComputeFacesV3D(i, j, k) == 1) then

                    if (Me%ExternalVar%Wflux_Y(i,j,k)==0.) then 

                        Me%Diffusion_CoeficientY(i,j,k)=0.

                    endif

                endif

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo


        end if nulldif

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "Convert_Visc_Dif_Horizontal")


        !----------------------------------------------------------------------

    end subroutine Convert_Visc_Dif_Horizontal

    !--------------------------------------------------------------------------
    subroutine Convert_Visc_Dif_Horizontal_opt()

        !External--------------------------------------------------------------


        !Local-----------------------------------------------------------------
        
        integer :: ILB, IUB 
        integer :: JLB, JUB 
        integer :: KLB, KUB
        integer :: i, j, k
        integer :: CHUNK
        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB 
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "Convert_Visc_Dif_Horizontal_opt")

        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)

        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then
 
                Me%Diffusion_CoeficientX(i, j, k) =                  &
                        Me%ExternalVar%Schmidt_H                     &
                        * (Me%ExternalVar%Visc_H(i,j,  k)            &
                        *  Me%ExternalVar%DUX(i,j-1)                 &
                        +  Me%ExternalVar%Visc_H(i,j-1,k)            &
                        *  Me%ExternalVar%DUX(i,j  ))                &
                        / (Me%ExternalVar%DUX(i,j    )               &
                        +  Me%ExternalVar%DUX(i,j-1))     
                              
            endif

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            If (Me%ExternalVar%ComputeFacesV3D(i, j, k) == 1) then

                Me%Diffusion_CoeficientY(i,j,k)  =                    &
                            Me%ExternalVar%Schmidt_H                  &
                         * (Me%ExternalVar%Visc_H(i,  j,k)            &
                         *  Me%ExternalVar%DVY(i-1,j)                 &
                         +  Me%ExternalVar%Visc_H(i-1,j,k)            &
                         *  Me%ExternalVar%DVY(i,  j))                &
                         / (Me%ExternalVar%DVY(i,j)                   &
                         +  Me%ExternalVar%DVY(i-1,j))

            Endif
        
        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "Convert_Visc_Dif_Horizontal_opt")
        !----------------------------------------------------------------------

    end subroutine Convert_Visc_Dif_Horizontal_opt
    
    !-----------------------------------------------------------------------------


    logical function SmallDepthCell (i, j) 

        !Arguments-------------------------------------------------------------
        integer                             :: i, j

        !Begin-----------------------------------------------------------------

        if (Me%ExternalVar%SmallDepthsPresent) then

            SmallDepthCell = Me%ExternalVar%SmallDepths(i,j)

        else

            SmallDepthCell = .false.

        endif
        
        !--------------------------------------------------------------------------

    end function SmallDepthCell

    !--------------------------------------------------------------------------
    !
    !This routine works either explicitly or implicitly, according to ImpExp_DifV
    !   1 = Implicit, 0 = Explicit
    !
    !--------------------------------------------------------------------------

    Subroutine VerticalDiffusion()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------               
        real(8) :: AuxK, Aux1, Aux2

        integer :: i, j, k

        integer :: CHUNK

        !----------------------------------------------------------------------
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "VerticalDiffusion")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
      
        !$OMP PARALLEL PRIVATE(i,j,k,AuxK,Aux1,Aux2)

do2 :   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do3 :   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
do1 :   do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%ExternalVar%ComputeFacesW3D(i, j, k  ) == 1 .and.                    &
                .not. SmallDepthCell (i, j))  then
                
                ! [m^2/s * m * m / m]
                AuxK  =  Me%Diffusion_CoeficientZ(i,j,k  )                              &
                       * Me%ExternalVar%DUX      (i,j    )                              &
                       * Me%ExternalVar%DVY      (i,j    )                              &
                       / Me%ExternalVar%DZZ      (i,j,k-1)

                if (Me%ExternalVar%NoDifFlux) then
                    if (Me%ExternalVar%NoFluxW(i, j, k) == 1) then
                        AuxK = 0.
                    endif
                endif

                ![m^3/s * s / m^3]
                Aux1 = AuxK * dble(Me%ExternalVar%DTProp) / Me%ExternalVar%VolumeZ(i, j, k-1) 
                Aux2 = AuxK * dble(Me%ExternalVar%DTProp) / Me%ExternalVar%VolumeZ(i, j, k  ) 

                Me%COEF3%E(i,j,k-1) = Me%COEF3%E(i,j,k-1) + Aux1 * Me%ExternalVar%ImpExp_DifV

                Me%COEF3%F(i,j,k-1) = Me%COEF3%F(i,j,k-1) - Aux1 * Me%ExternalVar%ImpExp_DifV

                Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) + Aux1 *                                  &
                                     (Me%ExternalVar%PROP(i,j,k)-Me%ExternalVar%PROP(i,j,k-1)) *    &
                                     (1. - Me%ExternalVar%ImpExp_DifV)

                Me%COEF3%D(i,j,k  ) = Me%COEF3%D(i,j,k  ) - Aux2 * Me%ExternalVar%ImpExp_DifV

                Me%COEF3%E(i,j,k  ) = Me%COEF3%E(i,j,k  ) + Aux2 * Me%ExternalVar%ImpExp_DifV

                Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) - Aux2 *                                  &
                                     (Me%ExternalVar%PROP(i,j,k)-Me%ExternalVar%PROP(i,j,k-1)) *    &
                                     (1. - Me%ExternalVar%ImpExp_DifV)

            endif

        end do do1
        end do do3
        !$OMP END DO
        end do do2

        !$OMP END PARALLEL

        if (Me%State%CellFluxes .and. Me%ExternalVar%ImpExp_DifV < 1.)                              &
            call CalcVerticalDifFlux(1. - Me%ExternalVar%ImpExp_DifV)


        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "VerticalDiffusion")

        !----------------------------------------------------------------------

    End Subroutine VerticalDiffusion                                                          

    !--------------------------------------------------------------------------

    Subroutine VerticalDiffusion2()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------               
        real(8) :: AuxK, Aux1, Aux2, VolumeBottomCell
        real    :: PropBottomCell, Gradient
        integer :: i, j, k, Kbottom
        integer :: CHUNK

        !----------------------------------------------------------------------
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "VerticalDiffusion2")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
      
        !$OMP PARALLEL PRIVATE(i,j,k,AuxK,Aux1,Aux2, Kbottom, VolumeBottomCell, PropBottomCell, Gradient)
        
        if (Me%ExternalVar%ImpExp_DifV > 0.0) then
            !Implicit calculation
            
            if (Me%Docycle_method == 1)then
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                    if (Me%ExternalVar%ComputeFacesW3D(i, j, Me%WorkSize%KUB) == 1 .and. .not. SmallDepthCell (i, j))  then
                        
                        Kbottom = Me%ExternalVar%KFloorZ(i, j)
                        VolumeBottomCell = Me%ExternalVar%VolumeZ(i, j, Kbottom) 
                        
                        do k = Kbottom + 1, Me%WorkSize%KUB

                            AuxK  =  Me%Diff_V_Const (i, j, k) * dble(Me%ExternalVar%DTProp) 

                            ![m^3/s * s / m^3]
                            Aux1 = AuxK  / VolumeBottomCell
                            Aux2 = AuxK  / Me%ExternalVar%VolumeZ(i, j, k) 

                            VolumeBottomCell = Me%ExternalVar%VolumeZ(i, j, k)
                            
                            Me%COEF3%D(i,j,k  ) = Me%COEF3%D(i,j,k  ) - Aux2
                            Me%COEF3%E(i,j,k  ) = Me%COEF3%E(i,j,k  ) + Aux2
                            Me%COEF3%E(i,j,k-1) = Me%COEF3%E(i,j,k-1) + Aux1
                            Me%COEF3%F(i,j,k-1) = Me%COEF3%F(i,j,k-1) - Aux1
                        end do
                    endif 
                end do
                end do
                !$OMP END DO
            else
                do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1 .and.                    &
                        .not. SmallDepthCell (i, j))  then
                
                        AuxK  =  Me%Diff_V_Const (i, j, k) * dble(Me%ExternalVar%DTProp) 

                        ![m^3/s * s / m^3]
                        Aux1 = AuxK  / Me%ExternalVar%VolumeZ(i, j, k-1) 
                        Aux2 = AuxK  / Me%ExternalVar%VolumeZ(i, j, k  ) 

                        Me%COEF3%D(i,j,k  ) = Me%COEF3%D(i,j,k  ) - Aux2
                        Me%COEF3%E(i,j,k  ) = Me%COEF3%E(i,j,k  ) + Aux2
                        Me%COEF3%E(i,j,k-1) = Me%COEF3%E(i,j,k-1) + Aux1
                        Me%COEF3%F(i,j,k-1) = Me%COEF3%F(i,j,k-1) - Aux1
                    endif

                end do
                end do
                !$OMP END DO
                end do
            endif
            
        else
            !Explicit calculation
            
            if (Me%Docycle_method == 1)then
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%ExternalVar%ComputeFacesW3D(i, j, Me%WorkSize%KUB) == 1 .and.                    &
                        .not. SmallDepthCell (i, j))  then
                        
                        Kbottom          = Me%ExternalVar%KFloorZ(i, j)
                        VolumeBottomCell = Me%ExternalVar%VolumeZ(i, j, Kbottom)
                        PropBottomCell   = Me%ExternalVar%PROP   (i, j, Kbottom)
                        
                        do k = Kbottom + 1, Me%WorkSize%KUB
                
                            AuxK  =  Me%Diff_V_Const (i, j, k) * dble(Me%ExternalVar%DTProp) 

                            ![m^3/s * s / m^3]
                            Aux1     = AuxK  / VolumeBottomCell
                            Aux2     = AuxK  / Me%ExternalVar%VolumeZ(i, j, k)
                            VolumeBottomCell = Me%ExternalVar%VolumeZ(i, j, k)
                            
                            Gradient = Me%ExternalVar%PROP(i,j,k)- PropBottomCell
        
                            Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) - Aux2 * Gradient

                            Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) + Aux1 * Gradient
                            
                            PropBottomCell = Me%ExternalVar%PROP(i,j,k)
                        end do
                    endif
                end do
                end do
                !$OMP END DO  
            else
                do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1 .and.                    &
                        .not. SmallDepthCell (i, j))  then
                
                        AuxK  =  Me%Diff_V_Const (i, j, k) * dble(Me%ExternalVar%DTProp) 

                        ![m^3/s * s / m^3]
                        Aux1 = AuxK  / Me%ExternalVar%VolumeZ(i, j, k-1) 
                        Aux2 = AuxK  / Me%ExternalVar%VolumeZ(i, j, k  ) 
        
                        Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) - Aux2 *                                  &
                                             (Me%ExternalVar%PROP(i,j,k)-Me%ExternalVar%PROP(i,j,k-1))

                        Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) + Aux1 *                                  &
                                             (Me%ExternalVar%PROP(i,j,k)-Me%ExternalVar%PROP(i,j,k-1))

                    endif
                end do
                end do
                !$OMP END DO
                end do 
            endif
        endif
        !$OMP END PARALLEL

        if (Me%State%CellFluxes .and. Me%ExternalVar%ImpExp_DifV < 1.)                              &
            call CalcVerticalDifFlux2(1. - Me%ExternalVar%ImpExp_DifV)

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "VerticalDiffusion2")

        !----------------------------------------------------------------------

    End Subroutine VerticalDiffusion2
    
    !--------------------------------------------------------------------------

    subroutine VerticalAdvection()

        !Local-----------------------------------------------------------------               
        real(8)             :: AdvFluxZ, DT1, DT2, Volume_BottomCell
        integer             :: i, j, k, KLB_Aux, KUB_Aux, Kbottom
        integer             :: CHUNK
        !----------------------------------------------------------------------
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "VerticalAdvection")
        
        KLB_Aux = Me%WorkSize%KLB + 1
        KUB_Aux = Me%WorkSize%KUB + 1

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)
st:     if (Me%State%VertAdv) then
            
             if (Me%ExternalVar%Optimize) then
            
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            
                    if (Me%ExternalVar%OpenPoints3D (i,j,Me%WorkSize%KUB) == 1) then
                        call ComputeAdvection1D_TVD_SuperBee_2( KLB_Aux, KUB_Aux,             &
                                                Me%ExternalVar%DTProp,                      &
                                                Me%ExternalVar%DWZ          (i,j,:),        &
                                                Me%ExternalVar%PROP         (i,j,:),        &
                                                Me%ExternalVar%Wflux_Z      (i,j,:),        &
                                                Me%ExternalVar%VolumeZ      (i,j,:),        & 
                                                Me%ExternalVar%OpenPoints3D (i,j,:),        &
                                                Me%COEF3_VertAdv%D_flux (i,j,:),            &
                                                Me%COEF3_VertAdv%E_flux(i,j,:))                                
                    endif
                end do
                end do
                !$OMP END DO
            
            else
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    j1:         do j = Me%WorkSize%JLB, Me%WorkSize%JUB
    i1:         do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%ExternalVar%OpenPoints3D (i,j,Me%WorkSize%KUB) == 1) then
                        call ComputeAdvection1D_V2( Me%WorkSize%KLB+1,                          &
                                                    Me%WorkSize%KUB+1,                          &
                                                    Me%ExternalVar%DTProp,                      &
                                                    Me%ExternalVar%DWZ          (i,j,:),        &
                                                    Me%ExternalVar%PROP         (i,j,:),        &
                                                    Me%ExternalVar%Wflux_Z      (i,j,:),        &
                                                    Me%ExternalVar%VolumeZ      (i,j,:),        & 
                                                    Me%ExternalVar%OpenPoints3D (i,j,:),        &
                                                    Me%COEF3_VertAdv%C_flux     (i,j,:),        &
                                                    Me%COEF3_VertAdv%D_flux     (i,j,:),        &
                                                    Me%COEF3_VertAdv%E_flux     (i,j,:),        &
                                                    Me%COEF3_VertAdv%F_flux     (i,j,:),        &
                                                    Me%ExternalVar%AdvMethodV,                  &
                                                    Me%ExternalVar%TVDLimitationV,              &
                                                    Me%ExternalVar%VolumeRelMax,                &
                                                    Me%ExternalVar%Upwind2V)
                                                

                        if (Me%ExternalVar%NoAdvFlux) then

                            do k=Me%ExternalVar%KFloorZ(i, j), Me%WorkSize%KUB
                                if (Me%ExternalVar%NoFluxW(i, j, k)==1) then
                                    Me%COEF3_VertAdv%C_flux     (i,j,k) = 0.
                                    Me%COEF3_VertAdv%D_flux     (i,j,k) = 0. 
                                    Me%COEF3_VertAdv%E_flux     (i,j,k) = 0.
                                    Me%COEF3_VertAdv%F_flux     (i,j,k) = 0.
                                endif
                            enddo
                        endif 
                                                                 
                    endif

                end do i1
                end do j1
            
                !$OMP END DO
            endif

        endif st
        !$OMP END PARALLEL
cd6:    if (Me%ExternalVar%ImpExp_AdvV == ExplicitScheme)  then !ExplicitScheme = 0
    
            if (Me%ExternalVar%Optimize) then
                !optimized only for the TVD. also checks which docycle method the user wants to use.
                !If anyone wants to add an optimized version for other methods, they can just create here another routine.
                call VerticalAdvection_ExplicitScheme
                
            else
                
                !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxZ)
dok3 :          do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj3 :          do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi3 :          do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                if (Me%ExternalVar%ComputeFacesW3D(i, j  , k) == 1) then
                
                AdvFluxZ =    (Me%COEF3_VertAdv%C_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j, k-2)                     &
                            +  Me%COEF3_VertAdv%D_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j, k-1)                     &
                            +  Me%COEF3_VertAdv%E_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j,   k)                     &
                            +  Me%COEF3_VertAdv%F_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j, k+1))

                Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) - AdvFluxZ *                  &
                                      Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k-1)
                Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) + AdvFluxZ *                  &
                                      Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k  )

                endif

                end do doi3
                end do doj3
                !$OMP END DO
                end do dok3
                !$OMP END PARALLEL
            endif

        else if (Me%ExternalVar%ImpExp_AdvV == ImplicitScheme) then cd6 !ImplicitScheme = 1
            
            !$OMP PARALLEL PRIVATE(i,j,k,DT1,DT2, Kbottom, Volume_BottomCell)

            if (Me%Docycle_method == 1)then
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                    if (Me%ExternalVar%ComputeFacesW3D(i, j  , Me%WorkSize%KUB) == 1) then
                        
                        !Start at the first computefacesW3D
                        Kbottom           = Me%ExternalVar%KFloorZ(i, j         )
                        Volume_BottomCell = Me%ExternalVar%VolumeZ(i, j, Kbottom)
                        
                        do k = Kbottom + 1, Me%WorkSize%KUB

                            DT1 = Me%ExternalVar%DTProp / Volume_BottomCell
                            DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k  )
                            
                            Volume_BottomCell = Me%ExternalVar%VolumeZ(i,j,k)
                    
                            Me%COEF3%D(i,j,k  ) = Me%COEF3%D(i,j,k  ) - Me%COEF3_VertAdv%D_flux(i,   j, k) * DT2
                            Me%COEF3%E(i,j,k  ) = Me%COEF3%E(i,j,k  ) - Me%COEF3_VertAdv%E_flux(i,   j, k) * DT2

                            Me%COEF3%E(i,j,k-1) = Me%COEF3%E(i,j,k-1) + Me%COEF3_VertAdv%D_flux(i,   j, k) * DT1
                            Me%COEF3%F(i,j,k-1) = Me%COEF3%F(i,j,k-1) + Me%COEF3_VertAdv%E_flux(i,   j, k) * DT1
                        end do
                    endif
                end do
                end do
                !$OMP END DO  
            else
    dok4 :      do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doj4 :      do j = Me%WorkSize%JLB, Me%WorkSize%JUB
    doi4 :      do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%ExternalVar%ComputeFacesW3D(i, j  , k) == 1) then

                        DT1 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k-1)
                        DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k  )
                    
                        Me%COEF3%D(i,j,k  ) = Me%COEF3%D(i,j,k  ) - Me%COEF3_VertAdv%D_flux(i,   j, k) * DT2
                        Me%COEF3%E(i,j,k  ) = Me%COEF3%E(i,j,k  ) - Me%COEF3_VertAdv%E_flux(i,   j, k) * DT2

                        Me%COEF3%E(i,j,k-1) = Me%COEF3%E(i,j,k-1) + Me%COEF3_VertAdv%D_flux(i,   j, k) * DT1
                        Me%COEF3%F(i,j,k-1) = Me%COEF3%F(i,j,k-1) + Me%COEF3_VertAdv%E_flux(i,   j, k) * DT1
                    
                    endif

                end do doi4
                end do doj4
                !$OMP END DO           
                end do dok4
            endif
            !$OMP END PARALLEL
        else cd6

            stop 'sub. VerticalAdvection - ModuleAdvectionDiffusion - ERR01'
        
        endif cd6

        !Fluxes among cells
        if (Me%State%CellFluxes .and. Me%ExternalVar%ImpExp_AdvV < 1.) then
            if (Me%ExternalVar%Optimize)then
                call CalcVerticalAdvFlux_opt(1. - Me%ExternalVar%ImpExp_AdvV)
            else
                call CalcVerticalAdvFlux(1. - Me%ExternalVar%ImpExp_AdvV)
            endif
        endif
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "VerticalAdvection")

        !----------------------------------------------------------------------

    end subroutine VerticalAdvection

    !--------------------------------------------------------------------------
    
    subroutine VerticalAdvection_ExplicitScheme
        !Local-----------------------------------------------------------------               
        real(8)             :: AdvFluxZ, Volume_BottomCell
        real                :: PROP_BottomCell
        integer             :: i, j, k, Kbottom
        integer             :: CHUNK
        !----------------------------------------------------------------------

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxZ,Kbottom, Volume_BottomCell, PROP_BottomCell)
        if (Me%Docycle_method == 1)then
                
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%ExternalVar%ComputeFacesW3D(i, j  , Me%WorkSize%KUB) == 1) then
                    !Start at the first computefacesW3D
                    Kbottom = Me%ExternalVar%KFloorZ(i, j)
                    Volume_BottomCell = Me%ExternalVar%VolumeZ(i, j, Kbottom)
                    PROP_BottomCell   = Me%ExternalVar%PROP   (i, j, Kbottom)
                        
                    do k = Kbottom + 1, Me%WorkSize%KUB
                        !                                               Me%ExternalVar%PROP(i, j, k - 1)
                        AdvFluxZ = (Me%COEF3_VertAdv%D_flux(i, j, k) *  PROP_BottomCell                     &
                                 +  Me%COEF3_VertAdv%E_flux(i, j, k) *  Me%ExternalVar%PROP(i, j, k    ))   &
                                 *  Me%ExternalVar%DTProp
                        
                        PROP_BottomCell   = Me%ExternalVar%PROP   (i,j,k)
                            
                        Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) - AdvFluxZ / Volume_BottomCell
                        Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) + AdvFluxZ / Me%ExternalVar%VolumeZ(i,j,k  )
                    
                        Volume_BottomCell = Me%ExternalVar%VolumeZ(i,j,k)
                    end do
                endif
            end do
            end do
            !$OMP END DO
        else
            do k = Me%WorkSize%KLB, Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%ExternalVar%ComputeFacesW3D(i, j  , k) == 1) then
                
                    AdvFluxZ =    (Me%COEF3_VertAdv%D_flux(i,   j,   k)                     &
                                *  Me%ExternalVar%PROP    (i,   j, k-1)                     &
                                +  Me%COEF3_VertAdv%E_flux(i,   j,   k)                     &
                                *  Me%ExternalVar%PROP    (i,   j,   k))                    &
                                * Me%ExternalVar%DTProp

                    Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) - AdvFluxZ / Me%ExternalVar%VolumeZ(i,j,k-1)
                    Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) + AdvFluxZ / Me%ExternalVar%VolumeZ(i,j,k  )

                endif
            end do
            end do
            !$OMP END DO
            end do
        endif
         !$OMP END PARALLEL
        
    end subroutine VerticalAdvection_ExplicitScheme

    !--------------------------------------------------------------------------

    subroutine VerticalAdvection_Nudge()

        !Local-----------------------------------------------------------------               
        real(8)             :: AdvFluxZ, DT1, DT2
        integer             :: i, j, k  
        integer             :: CHUNK                           

        !----------------------------------------------------------------------
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "VerticalAdvection_Nudge")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxZ,DT1,DT2)

st:     if (Me%State%VertAdv) then
        
            !! $OMP PARALLEL SHARED(CHUNK) PRIVATE(I,J)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)

j1:         do j = Me%WorkSize%JLB, Me%WorkSize%JUB
i1:         do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                if (Me%ExternalVar%OpenPoints3D (i,j,Me%WorkSize%KUB) == 1) then
                    call ComputeAdvection1D_V2( Me%WorkSize%KLB+1,                          &
                                                Me%WorkSize%KUB+1,                          &
                                                Me%ExternalVar%DTProp,                      &
                                                Me%ExternalVar%DWZ          (i,j,:),        &
                                                Me%ExternalVar%PROP         (i,j,:),        &
                                                Me%ExternalVar%Wflux_Z      (i,j,:),        &
                                                Me%ExternalVar%VolumeZ      (i,j,:),        & 
                                                Me%ExternalVar%OpenPoints3D (i,j,:),        &
                                                Me%COEF3_VertAdv%C_flux     (i,j,:),        &
                                                Me%COEF3_VertAdv%D_flux     (i,j,:),        &
                                                Me%COEF3_VertAdv%E_flux     (i,j,:),        &
                                                Me%COEF3_VertAdv%F_flux     (i,j,:),        &
                                                Me%ExternalVar%AdvMethodV,                  &
                                                Me%ExternalVar%TVDLimitationV,              &
                                                Me%ExternalVar%VolumeRelMax,                &
                                                Me%ExternalVar%Upwind2V)
                    
                                               
                endif

            end do i1
            end do j1
            
            !$OMP END DO
            !! $OMP END PARALLEL

        endif st

        

cd6:    if (Me%ExternalVar%ImpExp_AdvV == ExplicitScheme)  then !ExplicitScheme = 0

dok3 :      do k = Me%WorkSize%KLB, Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj3 :      do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi3 :      do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%ExternalVar%ComputeFacesW3D(i, j  , k) == 1) then
                
                AdvFluxZ =    (Me%COEF3_VertAdv%C_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j, k-2)                     &
                            +  Me%COEF3_VertAdv%D_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j, k-1)                     &
                            +  Me%COEF3_VertAdv%E_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j,   k)                     &
                            +  Me%COEF3_VertAdv%F_flux(i,   j,   k)                     &
                            *  Me%ExternalVar%PROP    (i,   j, k+1))

                !Me%TICOEF3(i,j,k-1) = Me%TICOEF3(i,j,k-1) - AdvFluxZ *                  &
                !                      Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k-1)
                !Me%TICOEF3(i,j,k  ) = Me%TICOEF3(i,j,k  ) + AdvFluxZ *                  &
                !                      Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k  )

                Me%AdvectionTi(i,j,k-1) = Me%AdvectionTi(i,j,k-1) - AdvFluxZ *                  &
                                      Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k-1)
                Me%AdvectionTi(i,j,k  ) = Me%AdvectionTi(i,j,k  ) + AdvFluxZ *                  &

                                      Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k  )


            endif

            end do doi3
            end do doj3
            !$OMP END DO
            end do dok3

        else if (Me%ExternalVar%ImpExp_AdvV == ImplicitScheme) then cd6 !ImplicitScheme = 1

dok4 :      do k = Me%WorkSize%KLB, Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj4 :      do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi4 :      do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                if (Me%ExternalVar%ComputeFacesW3D(i, j  , k) == 1) then

                    DT1 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k-1)
                    DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j,k  )

                    !Me%COEF3%D(i,j,k  ) = Me%COEF3%D(i,j,k  ) - Me%COEF3_VertAdv%D_flux(i,   j, k) * DT2
                    !Me%COEF3%E(i,j,k  ) = Me%COEF3%E(i,j,k  ) - Me%COEF3_VertAdv%E_flux(i,   j, k) * DT2

                    !Me%COEF3%E(i,j,k-1) = Me%COEF3%E(i,j,k-1) + Me%COEF3_VertAdv%D_flux(i,   j, k) * DT1
                    !Me%COEF3%F(i,j,k-1) = Me%COEF3%F(i,j,k-1) + Me%COEF3_VertAdv%E_flux(i,   j, k) * DT1
                    

                    Me%AdvectionD(i,j,k  ) = Me%AdvectionD(i,j,k  ) - Me%COEF3_VertAdv%D_flux(i,   j, k) * DT2
                    Me%AdvectionE(i,j,k  ) = Me%AdvectionE(i,j,k  ) - Me%COEF3_VertAdv%E_flux(i,   j, k) * DT2

                    Me%AdvectionE(i,j,k-1) = Me%AdvectionE(i,j,k-1) + Me%COEF3_VertAdv%D_flux(i,   j, k) * DT1
                    Me%AdvectionF(i,j,k-1) = Me%AdvectionF(i,j,k-1) + Me%COEF3_VertAdv%E_flux(i,   j, k) * DT1                    

                endif

            end do doi4
            end do doj4
            !$OMP END DO           
            end do dok4

        else cd6

            stop 'sub. VerticalAdvection_Nudge - ModuleAdvectionDiffusion - ERR01'
        
        endif cd6

        !$OMP END PARALLEL

        !Fluxes among cells
        if (Me%State%CellFluxes .and. Me%ExternalVar%ImpExp_AdvV < 1.)    &
            call CalcVerticalAdvFlux(1. - Me%ExternalVar%ImpExp_AdvV)

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "VerticalAdvection_Nudge")

        !----------------------------------------------------------------------

    end subroutine VerticalAdvection_Nudge

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine CalcVerticalAdvFlux(Weigth)


        !Arguments-------------------------------------------------------------
        real, intent(IN)                            :: Weigth !Refers to the wigth of Implicit-Explicit calculations

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcVerticalAdvFlux")

        CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(k,j,i)

dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB

        if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1) then

            Me%Fluxes%AdvFluxZ(i, j, k) =                                               &
                          Me%Fluxes%AdvFluxZ(i, j, k)                                   &
                        + Weigth                                                        &
                        *(Me%COEF3_VertAdv%C_flux(i,j,k)                                &
                        * Me%ExternalVar%PROP(i, j, k-2)                                &
                        + Me%COEF3_VertAdv%D_flux(i,j,k)                                &
                        * Me%ExternalVar%PROP(i, j, k-1)                                &
                        + Me%COEF3_VertAdv%E_flux(i,j,k)                                &
                        * Me%ExternalVar%PROP(i, j, k )                                 &
                        + Me%COEF3_VertAdv%F_flux(i,j,k)                                &
                        * Me%ExternalVar%PROP(i, j, k+1))

        endif

        end do doi1
        end do doj1
        !$OMP END DO NOWAIT
        end do dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcVerticalAdvFlux")

        !----------------------------------------------------------------------

    end subroutine CalcVerticalAdvFlux

    !--------------------------------------------------------------------------
    
    subroutine CalcVerticalAdvFlux_opt(Weigth)


        !Arguments-------------------------------------------------------------
        real, intent(IN)                            :: Weigth !Refers to the wigth of Implicit-Explicit calculations

        !Local-----------------------------------------------------------------
        real                                        :: PROP_BottomCell
        integer                                     :: i, j, k, kbottom  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcVerticalAdvFlux_opt")

        CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)
        
        !$OMP PARALLEL PRIVATE(k,j,i, kbottom, PROP_BottomCell)
        if (Me%Docycle_method == 1)then
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%ExternalVar%ComputeFacesW3D(i, j, Me%WorkSize%KUB) == 1) then
                
                    kbottom         = Me%ExternalVar%KFloorZ(i, j)
                    PROP_BottomCell = Me%ExternalVar%PROP   (i, j, kbottom)
                    do k = kbottom + 1, Me%WorkSize%KUB

                        Me%Fluxes%AdvFluxZ(i, j, k) = Me%Fluxes%AdvFluxZ(i, j, k)               &
                                                    + Weigth                                    &
                                                    *(Me%COEF3_VertAdv%D_flux(i,j,k) * PROP_BottomCell            &
                                                    + Me%COEF3_VertAdv%E_flux(i,j,k) * Me%ExternalVar%PROP(i, j, k ))
                        PROP_BottomCell = Me%ExternalVar%PROP(i, j, k)
                    end do
                endif
            end do
            end do
            !$OMP END DO
        else
            do k = Me%WorkSize%KLB, Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1) then

                Me%Fluxes%AdvFluxZ(i, j, k) =                                               &
                              Me%Fluxes%AdvFluxZ(i, j, k)                                   &
                            + Weigth                                                        &
                            *(Me%COEF3_VertAdv%D_flux(i,j,k)                                &
                            * Me%ExternalVar%PROP(i, j, k-1)                                &
                            + Me%COEF3_VertAdv%E_flux(i,j,k)                                &
                            * Me%ExternalVar%PROP(i, j, k))
            endif

            end do
            end do
            !$OMP END DO NOWAIT
            end do 
        endif
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcVerticalAdvFlux_opt")

        !----------------------------------------------------------------------

    end subroutine CalcVerticalAdvFlux_opt
    
    !--------------------------------------------------------------------------

    subroutine CalcHorizontalAdvFluxXX(Weigth)

        !External--------------------------------------------------------------
    
        real, intent(IN) :: Weigth !Refers to the wigth of Implicit-Explicit calculations

        !Local-----------------------------------------------------------------

        integer :: i,     j,     k  
        integer :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxXX")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(i,j,k)
dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then

            Me%Fluxes%AdvFluxX(i, j, k) =                                               &
                          Me%Fluxes%AdvFluxX(i, j, k)                                   &
                        + Weigth                                                        &
                        * (Me%COEF3_HorAdvXX%C_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i, j-2, k)                          &
                        +  Me%COEF3_HorAdvXX%D_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i, j-1, k)                          &
                        +  Me%COEF3_HorAdvXX%E_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i,   j, k)                          &
                        +  Me%COEF3_HorAdvXX%F_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i, j+1, k))

        endif
        end do doi1
        end do doj1
        !$OMP END DO NOWAIT
        end do dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxXX")

        !----------------------------------------------------------------------

    end subroutine CalcHorizontalAdvFluxXX

    !--------------------------------------------------------------------------

    subroutine CalcHorizontalAdvFluxXX_opt(Weigth)
        !External--------------------------------------------------------------
    
        real, intent(IN) :: Weigth !Refers to the wigth of Implicit-Explicit calculations

        !Local-----------------------------------------------------------------

        integer :: i,     j,     k 
        integer :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxXX")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(i,j,k)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then

            Me%Fluxes%AdvFluxX(i, j, k) = Me%Fluxes%AdvFluxX(i, j, k)                   &
                        + Weigth                                                        &
                        * (Me%COEF3_HorAdvXX%D_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i, j-1, k)                          &
                        +  Me%COEF3_HorAdvXX%E_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i,   j, k))

        endif
        end do
        end do
        !$OMP END DO NOWAIT
        end do 
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxXX")
    end subroutine CalcHorizontalAdvFluxXX_opt

    !--------------------------------------------------------------------------

    subroutine CalcHorizontalAdvFluxYY(Weigth)

        !External--------------------------------------------------------------
    
        real, intent(IN) :: Weigth !Refers to the wigth of Implicit-Explicit calculations


        !Local-----------------------------------------------------------------

        integer :: i,     j,     k  
        integer :: CHUNK
        
        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxYY")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)
        
dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesV3D(i  , j, k) == 1) then
            Me%Fluxes%AdvFluxY(i, j, k) =                                               &
                          Me%Fluxes%AdvFluxY(i, j, k)                                   &
                        + Weigth                                                        &
                        * (Me%COEF3_HorAdvYY%C_flux(i  , j, k)                          &
                        *  Me%ExternalVar%PROP     (i-2, j, k)                          &
                        +  Me%COEF3_HorAdvYY%D_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i-1, j, k)                          &
                        +  Me%COEF3_HorAdvYY%E_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i,   j, k)                          &
                        +  Me%COEF3_HorAdvYY%F_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i+1, j, k))
        endif
        end do doi1
        end do doj1
        !$OMP END DO NOWAIT
        end do dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxYY")

        !----------------------------------------------------------------------

    end subroutine CalcHorizontalAdvFluxYY

    !--------------------------------------------------------------------------
    
    subroutine CalcHorizontalAdvFluxYY_opt(Weigth)

        !External--------------------------------------------------------------
    
        real, intent(IN) :: Weigth !Refers to the wigth of Implicit-Explicit calculations


        !Local-----------------------------------------------------------------

        integer :: i,     j,     k
        integer :: CHUNK
        
        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxYY_opt")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesV3D(i  , j, k) == 1) then
            Me%Fluxes%AdvFluxY(i, j, k) = Me%Fluxes%AdvFluxY(i, j, k)                   &
                        + Weigth                                                        &
                        * (Me%COEF3_HorAdvYY%D_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i-1, j, k)                          &
                        +  Me%COEF3_HorAdvYY%E_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i,   j, k))
        endif
        end do
        end do
        !$OMP END DO NOWAIT
        end do
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalAdvFluxYY_opt")

        !----------------------------------------------------------------------

    end subroutine CalcHorizontalAdvFluxYY_opt
    
    !--------------------------------------------------------------------------

    subroutine CalcVerticalDifFlux(Weigth)

        !Arguments-------------------------------------------------------------
        real, intent(IN)                            :: Weigth !Refers to the wigth of Implicit-Explicit calculations

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcVerticalDifFlux")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i, j, k)

dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesW3D(i, j, k  ) == 1) then
            Me%Fluxes%DifFluxZ(i, j, k) =                                               &
                          Me%Fluxes%DifFluxZ(i, j, k)                                   &
                        - Weigth                                                        &
                        * Me%Diffusion_CoeficientZ(i,j,k)                               &
                        * Me%ExternalVar%DUX(i,j)                                       &
                        * Me%ExternalVar%DVY(i,j)                                       &
                        / Me%ExternalVar%DZZ(i,j,k-1)                                   &
                        *(Me%ExternalVar%PROP(i, j, k  )                                &
                        - Me%ExternalVar%PROP(i, j, k-1))
        endif
        end do doi1
        end do doj1
        !$OMP END DO NOWAIT
        end do dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcVerticalDifFlux")

        !----------------------------------------------------------------------

    end subroutine CalcVerticalDifFlux

    !--------------------------------------------------------------------------
    
    subroutine CalcVerticalDifFlux2(Weigth)

        !Arguments-------------------------------------------------------------
        real, intent(IN)                            :: Weigth !Refers to the wigth of Implicit-Explicit calculations

        !Local-----------------------------------------------------------------
        real                                        :: PropBottomCell
        integer                                     :: i, j, k, Kbottom
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcVerticalDifFlux")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i, j, k, KBottom, PropBottomCell)
        
        if (Me%Docycle_method == 1)then
            
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
    doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%ExternalVar%ComputeFacesW3D(i, j, Me%WorkSize%KUB) == 1) then
                
                Kbottom        = Me%ExternalVar%KFloorZ(i, j)
                PropBottomCell = Me%ExternalVar%PROP   (i, j, Kbottom)
                
        dok1:   do k = Kbottom + 1, Me%WorkSize%KUB
                    Me%Fluxes%DifFluxZ(i, j, k) = Me%Fluxes%DifFluxZ(i, j, k)               &
                                                - Weigth                                    &
                                                * Me%Diff_V_Const(i,j, k)                   &
                                                *(Me%ExternalVar%PROP(i, j, k  ) - PropBottomCell)
                    PropBottomCell = Me%ExternalVar%PROP(i, j, k)
                end do dok1
            endif
            end do doi1
            end do doj1
            !$OMP END DO
            
        else
    dok2:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doj2:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
    doi2:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%ExternalVar%ComputeFacesW3D(i, j, k  ) == 1) then
                Me%Fluxes%DifFluxZ(i, j, k) =                                               &
                              Me%Fluxes%DifFluxZ(i, j, k)                                   &
                            - Weigth                                                        &
                            * Me%Diff_V_Const(i,j, k)                                       &
                            *(Me%ExternalVar%PROP(i, j, k  )                                &
                            - Me%ExternalVar%PROP(i, j, k-1))
            endif
            end do doi2
            end do doj2
            !$OMP END DO NOWAIT
            end do dok2 
        endif

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcVerticalDifFlux")

        !----------------------------------------------------------------------

    end subroutine CalcVerticalDifFlux2
    
    !-------------------------------------------------------------------------

    subroutine CalcHorizontalDifFluxXX()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k  
        integer                                     :: CHUNK
        
        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxXX")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k)
        
dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then                           
                Me%Fluxes%DifFluxX(i, j, k) =                                           &
                              Me%Fluxes%DifFluxX      (i,  j, k)                        &
                            - Me%Diffusion_CoeficientX(i,  j, k)                        &
                            * Me%ExternalVar%AreaU    (i,  j, k)                        &
                            / Me%ExternalVar%DZX      (i,j-1   )                        &
                            *(Me%ExternalVar%PROP     (i,  j, k)                        &
                            - Me%ExternalVar%PROP     (i,j-1, k))

            endif
        end do doi1
        end do doj1
        !$OMP END DO NOWAIT
        end do dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxXX")

        !----------------------------------------------------------------------

    end subroutine CalcHorizontalDifFluxXX
    
    !--------------------------------------------------------------------------
    subroutine CalcHorizontalDifFluxXX2()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k  
        integer                                     :: CHUNK
        
        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxXX2")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k)
        
dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then                           
                Me%Fluxes%DifFluxX(i, j, k) =                                           &
                              Me%Fluxes%DifFluxX      (i,  j, k)                        &
                            - Me%Diff_H_Const_U       (i,  j, k)                        &
                            *(Me%ExternalVar%PROP     (i,  j, k)                        &
                            - Me%ExternalVar%PROP     (i,j-1, k))

            endif
        end do doi1
        end do doj1
        !$OMP END DO NOWAIT
        end do dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxXX2")

        !----------------------------------------------------------------------

    end subroutine CalcHorizontalDifFluxXX2

    !--------------------------------------------------------------------------

    subroutine CalcHorizontalDifFluxYY()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxYY")

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)

dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesV3D(i  , j, k) == 1) then
            Me%Fluxes%DifFluxY(i, j, k) =                                               &
                          Me%Fluxes%DifFluxY      (i  , j, k)                           &
                        - Me%Diffusion_CoeficientY(i  , j, k)                           &
                        * Me%ExternalVar%AreaV    (i  , j, k)                           &
                        / Me%ExternalVar%DZY      (i-1, j   )                           &
                        *(Me%ExternalVar%PROP     (i  , j, k)                           &
                        - Me%ExternalVar%PROP     (i-1, j, k))
        endif
        end do doi1
        end do doj1
        !$OMP END DO
        end do dok1
        
        !$OMP END PARALLEL
        
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxYY")
        
        !----------------------------------------------------------------------

    end subroutine CalcHorizontalDifFluxYY
    
    subroutine CalcHorizontalDifFluxYY2()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k  
        integer                                     :: CHUNK
        real(8)                                     :: DTPropDouble

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxYY2")
        
        DTPropDouble = dble(Me%ExternalVar%DTProp)

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        !$OMP PARALLEL PRIVATE(i,j,k)

dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        if (Me%ExternalVar%ComputeFacesV3D(i  , j, k) == 1) then
            Me%Fluxes%DifFluxY(i, j, k) =                                               &
                          Me%Fluxes%DifFluxY      (i  , j, k)                           &
                        - Me%Diff_H_Const_V       (i  , j, k)                           &
                        *(Me%ExternalVar%PROP     (i  , j, k)                           &
                        - Me%ExternalVar%PROP     (i-1, j, k))
        endif
        end do doi1
        end do doj1
        !$OMP END DO
        end do dok1
        
        !$OMP END PARALLEL
        
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "CalcHorizontalDifFluxYY")
        
        !----------------------------------------------------------------------

    end subroutine CalcHorizontalDifFluxYY2

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------
    !
    !This term appears due to (Ct+Dt.Vt+Dt - Ct.Vt)/Dt -> Ct.Vt/Vt+Dt
    !
    !--------------------------------------------------------------------------

    subroutine VolumeVariation()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: DT_V
        integer                                     :: i, j, k
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "VolumeVariation")

        CHUNK = Chunk_J(Me%WorkSize%JLB,Me%WorkSize%JUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k,DT_V) 
        
dok1:   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj1:   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB, Me%WorkSize%IUB

cd1:       if (Me%ExternalVar%OpenPoints3D(i, j, k) == 1) then

                Me%TICOEF3(i,j,k) = Me%ExternalVar%PROP(i,j,k)         &
                                  * (Me%ExternalVar%VolumeZOld(i,j,k)  &
                                  /  Me%ExternalVar%VolumeZ(i,j,k)   )
                
                if (k == Me%WorkSize%KUB) then
                
                    DT_V              = dble(Me%ExternalVar%DTProp) / Me%ExternalVar%VolumeZ(i,j,k)
                    Me%COEF3%E(i,j,k) = dble(1.0) + DT_V * Me%ExternalVar%Wflux_Z(i,j, k + 1)
                elseif (Me%ExternalVar%Optimize) then
                    !Initialize so that the setmatrixvalue does not need to be called for every property
                    Me%COEF3%E(i,j,k) = dble(1.0)
                endif
                
            else cd1 !This is important for the tidal flats points to maintain 
                     !their concentration when they are not covered 

                Me%TICOEF3(i,j,k) = Me%ExternalVar%PROP(i,j,k)

            endif cd1

         enddo doi1
         enddo doj1
         !$OMP END DO     
         enddo dok1

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "VolumeVariation")

        !----------------------------------------------------------------------
    
    end Subroutine VolumeVariation    

    !--------------------------------------------------------------------------

    subroutine Discharges ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: DT_V
        real                                        :: Flow
        integer                                     :: i, j, k, kd, n, dis, nc, kmin, kmax
        real                                        :: WaterColumn

        !----------------------------------------------------------------------


        n = 0
        
ddis:   do dis = 1, Me%ExternalVar%DischNumber  

            if (Me%ExternalVar%IgnoreDisch(dis)) cycle 
            
dnc:        do   nc = 1, Me%ExternalVar%DischnCells(dis)     

                n = n + 1
            
                i    = Me%ExternalVar%DischI   (n)
                j    = Me%ExternalVar%DischJ   (n)
                kd   = Me%ExternalVar%DischK   (n)
                kmin = Me%ExternalVar%DischKmin(n)
                kmax = Me%ExternalVar%DischKmax(n)                

                if (Me%ExternalVar%DischVert(dis) == DischUniform_) then

                    if (kmin == FillValueInt) kmin = Me%ExternalVar%KFloorZ(i, j)
                    if (kmax == FillValueInt) kmax = Me%WorkSize%KUB
                    
                else
        
                    kmin = kd; kmax = kd

                endif
                
                WaterColumn = 0.0
                do k=kmin, kmax
                    WaterColumn = WaterColumn + Me%ExternalVar%DWZ(i,j,k)
                enddo

dk:             do k=kmin, kmax

                    DT_V  = dble(Me%ExternalVar%DTProp) / Me%ExternalVar%VolumeZ(i,j,k)

                    if (Me%ExternalVar%DischVert(dis)  == DischUniform_) then

                        Flow = Me%ExternalVar%DischFlow(n) *                            &
                               Me%ExternalVar%DWZ(i,j,k) / WaterColumn

                    else

                        Flow = Me%ExternalVar%DischFlow(n)

                    endif

cd1:                if (Me%ExternalVar%OpenPoints3D(i, j, k) == OpenPoint) then

                        if (Me%ExternalVar%ByPass(dis)) then
                        
                            Me%TICOEF3(i,j,k) = Me%TICOEF3(i,j,k)           +           &
                                                Flow * DT_V * Me%ExternalVar%DischConc(n)  
                        else
                        
fl:                         if (Flow > 0.) then
                    
                                Me%TICOEF3(i,j,k) = Me%TICOEF3(i,j,k)       +           &
                                                    Flow * DT_V * Me%ExternalVar%DischConc(n)
                            else fl
                    
                                Me%COEF3%E(i,j,k) = Me%COEF3%E(i,j,k)       -           &
                                                    Flow * DT_V 
                            endif fl
                            
                        endif
                    else
                    !This for the case that tonly discharges changes the volume
                    ! In this case the cell is water point and is not open point
                    !In this case the subroutine VolumeVariation do not change the cell concentration (no dilution)
                        if (Flow > 0) then

                            Me%TICOEF3(i,j,k) = Me%ExternalVar%PROP(i, j, k)     *          &
                                                Me%ExternalVar%VolumeZOld(i,j,k) /          &
                                                Me%ExternalVar%VolumeZ   (i,j,k) +          &
                                                Flow * DT_V * Me%ExternalVar%DischConc(n)
                        endif
                    
                    endif cd1

                enddo dk

            enddo dnc
        
        enddo ddis


    end subroutine Discharges 

    !--------------------------------------------------------------------------

    subroutine HorizontalAdvection(ImpExp_AdvXX, ImpExp_AdvYY)

        !Arguments-------------------------------------------------------------
        real                                :: ImpExp_AdvXX, ImpExp_AdvYY
        !Local-----------------------------------------------------------------
        integer                             :: di,    dj    
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: ILBWS, IUBWS, JLBWS, JUBWS, KLBWS, KUBWS
        integer                             :: STAT_CALL        
        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvection")

        ILBWS = Me%WorkSize%ILB;  JLBWS = Me%WorkSize%JLB;  KLBWS = Me%WorkSize%KLB
        IUBWS = Me%WorkSize%IUB;  JUBWS = Me%WorkSize%JUB;  KUBWS = Me%WorkSize%KUB

        ILB   = Me%Size%ILB;  JLB   = Me%Size%JLB;  KLB   = Me%Size%KLB
        IUB   = Me%Size%IUB;  JUB   = Me%Size%JUB;  KUB   = Me%Size%KUB
     
        if (.not. Me%ExternalVar%AdvectionNudging) then
            call HorizontalAdvectionXX(ImpExp_AdvXX)
        else
            Me%AdvectionTi(:,:,:) = 0.
            Me%AdvectionD (:,:,:) = 0.        
            Me%AdvectionE (:,:,:) = 0.                
            Me%AdvectionF (:,:,:) = 0.                
            call HorizontalAdvectionXX_Nudge(ImpExp_AdvXX)
        endif

        if (.not. Me%ExternalVar%AdvectionNudging) then
            if (.not. Me%XZFlow) call HorizontalAdvectionYY(ImpExp_AdvYY)
        else
            if (.not. Me%XZFlow) call HorizontalAdvectionYY_Nudge(ImpExp_AdvYY)
        endif

cd1:    if (ImpExp_AdvYY == ImplicitScheme .or. ImpExp_AdvXX == ImplicitScheme) then 

cd3D:       if (KUBWS > 1) then

cd2:            if (ImpExp_AdvXX == ImplicitScheme) then 

                    di = 0
                    dj = 1
                        
                    if (Me%DDecomp%MasterOrSlave) then
                    
#if _USE_MPI                    
                    
                        call THOMAS_DDecompHorizGrid(HorizontalGridID = Me%ObjHorizontalGrid,   &
                                                     DCoef_3D         = Me%COEF3%D,             &
                                                     FCoef_3D         = Me%COEF3%F,             &
                                                     TiCoef_3D        = Me%TICOEF3,             &
                                                     ECoef_3D         = Me%COEF3%E,             &
                                                     Results_3D       = Me%ExternalVar%PROP,    &
                                                     di               = di,                     &
                                                     dj               = dj,                     &
                                                     KLB              = KLB,                    &
                                                     KUB              = KUB,                    &
                                                     STAT             = STAT_CALL)

#else                        
                        STAT_CALL = SUCCESS_                                             
#endif _USE_MPI

                        if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusionIteration - ModuleAdvectionDiffusion - ERR30'

                    else                    

                        call THOMAS_3D(ILBWS, IUBWS, JLBWS, JUBWS, KLBWS, KUBWS, di, dj,    &
                             Me%THOMAS,                                                     &
                             Me%ExternalVar%PROP                                            &
#ifdef _ENABLE_CUDA
                             , Me%ObjCuda,                                                  &
                             .FALSE.                                                         &
#endif _ENABLE_CUDA
                             )
                    endif
                                                 
                else if (ImpExp_AdvYY == ImplicitScheme) then cd2

                    di = 1
                    dj = 0

                    if (Me%DDecomp%MasterOrSlave) then

#if _USE_MPI
                    
                        call THOMAS_DDecompHorizGrid(HorizontalGridID = Me%ObjHorizontalGrid,   &
                                                     DCoef_3D         = Me%COEF3%D,             &
                                                     FCoef_3D         = Me%COEF3%F,             &
                                                     TiCoef_3D        = Me%TICOEF3,             &
                                                     ECoef_3D         = Me%COEF3%E,             &
                                                     Results_3D       = Me%ExternalVar%PROP,    &
                                                     di               = di,                     &
                                                     dj               = dj,                     &
                                                     KLB              = KLB,                    &
                                                     KUB              = KUB,                    &
                                                     STAT             = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_) stop 'AdvectionDiffusionIteration - ModuleAdvectionDiffusion - ERR40'
                                             
#endif _USE_MPI

                    else                    

                        call THOMAS_3D(JLBWS, JUBWS, ILBWS, IUBWS, KLBWS, KUBWS, di, dj,    &
                             Me%THOMAS,                                                     &
                             Me%ExternalVar%PROP                                            &      
#ifdef _ENABLE_CUDA
                             , Me%ObjCuda,                                                  &
                             .FAlSE.                                                         &
#endif _ENABLE_CUDA
                             )
                    endif
                                                 
                endif cd2

                
                call SetMatrixValue (Me%COEF3%D, Me%Size, 0.0)
                call SetMatrixValue (Me%COEF3%E, Me%Size, dble(1.0))
                call SetMatrixValue (Me%COEF3%F, Me%Size, 0.0)
                call SetMatrixValue (Me%TICOEF3, Me%Size, Me%ExternalVar%PROP)

            endif cd3D
     

        endif cd1

        
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvection")

        !----------------------------------------------------------------------

    end subroutine HorizontalAdvection

    !--------------------------------------------------------------------------
    

    !--------------------------------------------------------------------------

    subroutine HorizontalAdvectionUpwindExplict

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                             :: AdvFluxX, AdvFluxY
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k
        integer                             :: CHUNK        

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionUpwindExplict")

        ILB   = Me%WorkSize%ILB;  JLB   = Me%WorkSize%JLB;  KLB   = Me%WorkSize%KLB
        IUB   = Me%WorkSize%IUB;  JUB   = Me%WorkSize%JUB;  KUB   = Me%WorkSize%KUB
                   
        CHUNK = ChunkJ        

        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxX, AdvFluxY)
iHA:    if (Me%State%HorAdv) then

dok1 :      do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)    
doj1 :      do j = JLB, JUB
doi1 :      do i = ILB, IUB
    
                Me%COEF3_HorAdvXX%D_flux(i,   j, k) = 0.  
                Me%COEF3_HorAdvXX%E_flux(i,   j, k) = 0.
    
                if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then
                
                    if (Me%ExternalVar%Wflux_X(i, j, k) > 0.) then
                        Me%COEF3_HorAdvXX%D_flux(i,   j, k) =   Me%ExternalVar%Wflux_X(i, j, k)
                    else
                        Me%COEF3_HorAdvXX%E_flux(i,   j, k) = - Me%ExternalVar%Wflux_X(i, j, k)
                    endif

                endif
                
                Me%COEF3_HorAdvYY%D_flux(i,   j, k) = 0.
                Me%COEF3_HorAdvYY%E_flux(i,   j, k) = 0.

                if (Me%ExternalVar%ComputeFacesV3D(i, j, k) == 1) then

                    if (Me%ExternalVar%Wflux_Y(i, j, k) > 0.) then
                        Me%COEF3_HorAdvYY%D_flux(i,   j, k) =   Me%ExternalVar%Wflux_Y(i, j, k)
                    else
                        Me%COEF3_HorAdvYY%E_flux(i,   j, k) = - Me%ExternalVar%Wflux_Y(i, j, k)
                    endif

                endif                

            end do doi1
            end do doj1
            !$OMP END DO NOWAIT             
            end do dok1

        endif iHA                

dok2 :  do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj2 :  do j = JLB, JUB
doi2 :  do i = ILB, IUB

            AdvFluxX =     Me%COEF3_HorAdvXX%D_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i, j-1, k)                          &
                        +  Me%COEF3_HorAdvXX%E_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i,   j, k)

            Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) + AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j  ,k)
            Me%TICOEF3(i,j-1,k) = Me%TICOEF3(i,j-1,k) - AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j-1,k)
            
            AdvFluxY =     Me%COEF3_HorAdvYY%D_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i-1, j, k)                          &
                        +  Me%COEF3_HorAdvYY%E_flux(i,   j, k)                          &
                        *  Me%ExternalVar%PROP     (i,   j, k)

            Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) + AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(  i,j  ,k)
            Me%TICOEF3(i-1,j,k) = Me%TICOEF3(i-1,j,k) - AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i-1,j  ,k)
            
        end do doi2
        end do doj2
        !$OMP END DO NOWAIT         
        end do dok2        

        !$OMP END PARALLEL
        
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionUpwindExplict")

        !----------------------------------------------------------------------

    end subroutine HorizontalAdvectionUpwindExplict

    !--------------------------------------------------------------------------    

    subroutine HorizontalAdvectionXX(ImpExp_AdvXX)

        !External--------------------------------------------------------------

        real                                :: ImpExp_AdvXX

        !Local-----------------------------------------------------------------               

        real(8) :: AdvFluxX, DT1, DT2

        integer :: i,     j,     k                             
        integer :: ILB, IUB, JLB, JUB, KLB, KUB, JLB_Aux, JUB_Aux
        integer :: CHUNK
        !----------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionXX")

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        JLB_Aux = JLB + 1 ; JUB_Aux = JUB + 1

        CHUNK = CHUNK_I(ILB, IUB)
        !$OMP PARALLEL PRIVATE(i,j,k)

st:     if (Me%State%HorAdv) then
            
             if (Me%ExternalVar%Optimize) then
                
                do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do i = ILB, IUB
                
                    call ComputeAdvection1D_TVD_SuperBee_2(JLB_Aux, JUB_Aux, Me%ExternalVar%DTProp,                 &
                                            Me%ExternalVar%DUX          (i,:),                                    &
                                            Me%ExternalVar%PROP         (i,:,k),                                  &
                                            Me%ExternalVar%Wflux_X      (i,:,k),                                  &
                                            Me%ExternalVar%VolumeZ      (i,:,k),                                  & 
                                            Me%ExternalVar%OpenPoints3D (i,:,k),                                  &
                                            Me%COEF3_HorAdvXX%D_flux(i,:,k), Me%COEF3_HorAdvXX%E_flux(i,:,k))
                end do
                !$OMP END DO
                end do

            else
    k1:         do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    i1:         do i = ILB, IUB


                    call ComputeAdvection1D_V2(JLB+1, JUB+1, Me%ExternalVar%DTProp,         &
                                            Me%ExternalVar%DUX          (i,:),              &
                                            Me%ExternalVar%PROP         (i,:,k),            &
                                            Me%ExternalVar%Wflux_X      (i,:,k),            &
                                            Me%ExternalVar%VolumeZ      (i,:,k),            & 
                                            Me%ExternalVar%OpenPoints3D (i,:,k),            &
                                            Me%COEF3_HorAdvXX%C_flux    (i,:,k),            &
                                            Me%COEF3_HorAdvXX%D_flux    (i,:,k),            &
                                            Me%COEF3_HorAdvXX%E_flux    (i,:,k),            &
                                            Me%COEF3_HorAdvXX%F_flux    (i,:,k),            &
                                            Me%ExternalVar%AdvMethodH,                      &
                                            Me%ExternalVar%TVDLimitationH,                  &
                                            Me%ExternalVar%VolumeRelMax,                    &
                                            Me%ExternalVar%Upwind2H)

                        if (Me%ExternalVar%NoAdvFlux) then
                            do j = JLB, JUB
                                if (Me%ExternalVar%NoFluxU(i, j, k)==1) then
                                    Me%COEF3_HorAdvXX%C_flux     (i,j,k) = 0.
                                    Me%COEF3_HorAdvXX%D_flux     (i,j,k) = 0. 
                                    Me%COEF3_HorAdvXX%E_flux     (i,j,k) = 0.
                                    Me%COEF3_HorAdvXX%F_flux     (i,j,k) = 0.
                                endif
                            enddo
                        endif                                                
                    
                end do i1
                !$OMP END DO
                end do k1
            endif

        endif st
        !$OMP END PARALLEL
        CHUNK = CHUNK_K(KLB, KUB)

cd6:    if (ImpExp_AdvXX == ExplicitScheme)  then !ExplicitScheme = 0
    
            if (Me%ExternalVar%Optimize) then
                
                call HorizontalAdvectionXX_Explicit
                
            else
                !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxX)
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    dok3 :      do k = KLB, KUB
    doj3 :      do j = JLB, JUB
    doi3 :      do i = ILB, IUB

                if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then

                    AdvFluxX =    (Me%COEF3_HorAdvXX%C_flux(i,   j, k)                          &
                                *  Me%ExternalVar%PROP     (i, j-2, k)                          &
                                +  Me%COEF3_HorAdvXX%D_flux(i,   j, k)                          &
                                *  Me%ExternalVar%PROP     (i, j-1, k)                          &
                                +  Me%COEF3_HorAdvXX%E_flux(i,   j, k)                          &
                                *  Me%ExternalVar%PROP     (i,   j, k)                          &
                                +  Me%COEF3_HorAdvXX%F_flux(i,   j, k)                          &
                                *  Me%ExternalVar%PROP     (i, j+1, k))

                    Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) + AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j  ,k)
                    Me%TICOEF3(i,j-1,k) = Me%TICOEF3(i,j-1,k) - AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j-1,k)

                endif

                end do doi3
                end do doj3
                end do dok3
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif

    else if (ImpExp_AdvXX == ImplicitScheme) then cd6 !ImplicitScheme = 1
        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxX,DT2,DT1)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
dok5 :  do k = KLB, KUB
doj5 :  do j = JLB, JUB
doi5 :  do i = ILB, IUB

        if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then

            DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j  ,k)
            DT1 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j-1,k)

            Me%COEF3%D(i,j  ,k) = Me%COEF3%D(i,j  ,k) - Me%COEF3_HorAdvXX%D_flux(i,   j, k) * DT2
            Me%COEF3%E(i,j  ,k) = Me%COEF3%E(i,j  ,k) - Me%COEF3_HorAdvXX%E_flux(i,   j, k) * DT2

            Me%COEF3%E(i,j-1,k) = Me%COEF3%E(i,j-1,k) + Me%COEF3_HorAdvXX%D_flux(i,   j, k) * DT1
            Me%COEF3%F(i,j-1,k) = Me%COEF3%F(i,j-1,k) + Me%COEF3_HorAdvXX%E_flux(i,   j, k) * DT1

!The module advection is only able to compute tridiagonal linear systems 
!
!                    Me%COEF3%C(i,j,k) =  not computed
!                    Me%COEF3%G(i,j,k) =  not computed

!                      The aux variables
!                      Me%COEF3_VertAdv%C_flux and are not used Me%COEF3_VertAdv%G_flux

        endif

        end do doi5
        end do doj5
        end do dok5
        !$OMP END DO NOWAIT   
        !$OMP END PARALLEL
        else cd6

            stop 'sub. HorizontalAdvectionXX - ModuleAdvectionDiffusion - ERR01'
        
        endif cd6

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionXX")

        if (Me%State%CellFluxes .and. ImpExp_AdvXX == ExplicitScheme) then
            if (Me%ExternalVar%Optimize)then
                call CalcHorizontalAdvFluxXX_opt(1. - ImpExp_AdvXX)
            else
                call CalcHorizontalAdvFluxXX(1. - ImpExp_AdvXX)
            endif
        endif
        !----------------------------------------------------------------------

    end subroutine HorizontalAdvectionXX

    !--------------------------------------------------------------------------
    
    subroutine HorizontalAdvectionXX_Explicit
        !External--------------------------------------------------------------

        !Local-----------------------------------------------------------------               

        real(8) :: AdvFluxX

        integer :: i,     j,     k                             
        integer :: ILB, IUB, JLB, JUB, KLB, KUB
        integer :: CHUNK
        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB; KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_K(KLB, KUB)
        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxX)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then

                AdvFluxX =    (Me%COEF3_HorAdvXX%D_flux(i,   j, k)                          &
                            *  Me%ExternalVar%PROP     (i, j-1, k)                          &
                            +  Me%COEF3_HorAdvXX%E_flux(i,   j, k)                          &
                            *  Me%ExternalVar%PROP     (i,   j, k))

                Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) + AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j  ,k)
                Me%TICOEF3(i,j-1,k) = Me%TICOEF3(i,j-1,k) - AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j-1,k)
            endif

        end do
        end do
        end do
        !$OMP END DO
        !$OMP END PARALLEL
    end subroutine HorizontalAdvectionXX_Explicit
    
    !--------------------------------------------------------------------------

    subroutine HorizontalAdvectionXX_Nudge(ImpExp_AdvXX)

        !External--------------------------------------------------------------

        real                                :: ImpExp_AdvXX

        !Local-----------------------------------------------------------------               

        real(8) :: AdvFluxX, DT1, DT2

        integer :: i,     j,     k                             
        integer :: ILB, IUB, JLB, JUB, KLB, KUB
        integer :: CHUNK
        !----------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionXX")

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_I(ILB, IUB)
        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxX,DT2,DT1)

st:     if (Me%State%HorAdv) then

k1:         do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
i1:         do i = ILB, IUB


                call ComputeAdvection1D_V2(JLB+1, JUB+1, Me%ExternalVar%DTProp,         &
                                        Me%ExternalVar%DUX          (i,:),              &
                                        Me%ExternalVar%PROP         (i,:,k),            &
                                        Me%ExternalVar%Wflux_X      (i,:,k),            &
                                        Me%ExternalVar%VolumeZ      (i,:,k),            & 
                                        Me%ExternalVar%OpenPoints3D (i,:,k),            &
                                        Me%COEF3_HorAdvXX%C_flux    (i,:,k),            &
                                        Me%COEF3_HorAdvXX%D_flux    (i,:,k),            &
                                        Me%COEF3_HorAdvXX%E_flux    (i,:,k),            &
                                        Me%COEF3_HorAdvXX%F_flux    (i,:,k),            &
                                        Me%ExternalVar%AdvMethodH,                      &
                                        Me%ExternalVar%TVDLimitationH,                  &
                                        Me%ExternalVar%VolumeRelMax,                    &
                                        Me%ExternalVar%Upwind2H)

            end do i1
            !$OMP END DO
            end do k1

        endif st

        CHUNK = CHUNK_K(KLB, KUB)

cd6:    if (ImpExp_AdvXX == ExplicitScheme)  then !ExplicitScheme = 0

            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
dok3 :      do k = KLB, KUB
doj3 :      do j = JLB, JUB
doi3 :      do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then

                AdvFluxX =    (Me%COEF3_HorAdvXX%C_flux(i,   j, k)                          &
                            *  Me%ExternalVar%PROP     (i, j-2, k)                          &
                            +  Me%COEF3_HorAdvXX%D_flux(i,   j, k)                          &
                            *  Me%ExternalVar%PROP     (i, j-1, k)                          &
                            +  Me%COEF3_HorAdvXX%E_flux(i,   j, k)                          &
                            *  Me%ExternalVar%PROP     (i,   j, k)                          &
                            +  Me%COEF3_HorAdvXX%F_flux(i,   j, k)                          &
                            *  Me%ExternalVar%PROP     (i, j+1, k))

                !Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) + AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j  ,k)
                !Me%TICOEF3(i,j-1,k) = Me%TICOEF3(i,j-1,k) - AdvFluxX * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j-1,k)

                Me%AdvectionTi(i,j  ,k) = Me%AdvectionTi(i,j  ,k) + AdvFluxX * Me%ExternalVar%DTProp / &
                                          Me%ExternalVar%VolumeZ(i,j  ,k)
                Me%AdvectionTi(i,j-1,k) = Me%AdvectionTi(i,j-1,k) - AdvFluxX * Me%ExternalVar%DTProp / &
                                          Me%ExternalVar%VolumeZ(i,j-1,k)

            endif

            end do doi3
            end do doj3
            end do dok3
            !$OMP END DO NOWAIT 

        else if (ImpExp_AdvXX == ImplicitScheme) then cd6 !ImplicitScheme = 1

            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
dok4 :      do k = KLB, KUB
doj4 :      do j = JLB, JUB
doi4 :      do i = ILB, IUB


            if (Me%ExternalVar%ComputeFacesU3D(i, j  , k) == 1) then

                DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j  ,k)
                DT1 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i,j-1,k)

                !Me%COEF3%D(i,j  ,k) = Me%COEF3%D(i,j  ,k) - Me%COEF3_HorAdvXX%D_flux(i,   j, k) * DT2
                !Me%COEF3%E(i,j  ,k) = Me%COEF3%E(i,j  ,k) - Me%COEF3_HorAdvXX%E_flux(i,   j, k) * DT2

                !Me%COEF3%E(i,j-1,k) = Me%COEF3%E(i,j-1,k) + Me%COEF3_HorAdvXX%D_flux(i,   j, k) * DT1
                !Me%COEF3%F(i,j-1,k) = Me%COEF3%F(i,j-1,k) + Me%COEF3_HorAdvXX%E_flux(i,   j, k) * DT1

                Me%AdvectionD(i,j  ,k) = Me%AdvectionD(i,j  ,k) - Me%COEF3_HorAdvXX%D_flux(i,   j, k) * DT2
                Me%AdvectionE(i,j  ,k) = Me%AdvectionE(i,j  ,k) - Me%COEF3_HorAdvXX%E_flux(i,   j, k) * DT2

                Me%AdvectionE(i,j-1,k) = Me%AdvectionE(i,j-1,k) + Me%COEF3_HorAdvXX%D_flux(i,   j, k) * DT1
                Me%AdvectionF(i,j-1,k) = Me%AdvectionF(i,j-1,k) + Me%COEF3_HorAdvXX%E_flux(i,   j, k) * DT1




!The module advection is only able to compute tridiagonal linear systems 
!
!                    Me%COEF3%C(i,j,k) =  not computed
!                    Me%COEF3%G(i,j,k) =  not computed

!                      The aux variables
!                      Me%COEF3_VertAdv%C_flux and are not used Me%COEF3_VertAdv%G_flux


            endif


            end do doi4
            end do doj4
            end do dok4
            !$OMP END DO NOWAIT 

        else cd6

            stop 'sub. HorizontalAdvectionXX - ModuleAdvectionDiffusion - ERR01'
        
        endif cd6

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionXX")

        if (Me%State%CellFluxes .and. ImpExp_AdvXX == ExplicitScheme)                   &
            call CalcHorizontalAdvFluxXX(1. - ImpExp_AdvXX)

        !----------------------------------------------------------------------

    end subroutine HorizontalAdvectionXX_Nudge

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine HorizontalAdvectionYY(ImpExp_AdvYY)

        !Arguments--------------------------------------------------------------
        real                                :: ImpExp_AdvYY

        !Local-----------------------------------------------------------------               
        real(8)                             :: AdvFluxY, DT1, DT2
        integer                             :: i,     j,     k                             
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB, ILB_Aux, IUB_Aux
        integer                             :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB ; IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB ; JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB ; KUB = Me%WorkSize%KUB
        
        ILB_Aux = ILB + 1 ; IUB_Aux = IUB + 1
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionYY")
        
        CHUNK = CHUNK_J(JLB, JUB)
      
        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxY,DT2,DT1)

st:     if (Me%State%HorAdv) then
            
             if (Me%ExternalVar%Optimize) then
                
                do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                
                    call ComputeAdvection1D_TVD_SuperBee_2(ILB_Aux, IUB_Aux, Me%ExternalVar%DTProp,                 &
                                            Me%ExternalVar%DVY          (:,j),                                    &
                                            Me%ExternalVar%PROP         (:,j,k),                                  &
                                            Me%ExternalVar%Wflux_Y      (:,j,k),                                  &
                                            Me%ExternalVar%VolumeZ      (:,j,k),                                  & 
                                            Me%ExternalVar%OpenPoints3D (:,j,k),                                  &
                                            Me%COEF3_HorAdvYY%D_flux(:,j,k), Me%COEF3_HorAdvYY%E_flux(:,j,k))
                end do
                !$OMP END DO
                end do
                
             else
    k1:         do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    j1:         do j = JLB, JUB

                    call ComputeAdvection1D_V2(ILB+1, IUB+1, Me%ExternalVar%DTProp,         &
                                            Me%ExternalVar%DVY          (:,j),              &
                                            Me%ExternalVar%PROP         (:,j,k),            &
                                            Me%ExternalVar%Wflux_Y      (:,j,k),            &
                                            Me%ExternalVar%VolumeZ      (:,j,k),            & 
                                            Me%ExternalVar%OpenPoints3D (:,j,k),            &
                                            Me%COEF3_HorAdvYY%C_flux    (:,j,k),            &
                                            Me%COEF3_HorAdvYY%D_flux    (:,j,k),            &
                                            Me%COEF3_HorAdvYY%E_flux    (:,j,k),            &
                                            Me%COEF3_HorAdvYY%F_flux    (:,j,k),            &
                                            Me%ExternalVar%AdvMethodH,                      &
                                            Me%ExternalVar%TVDLimitationH,                  &
                                            Me%ExternalVar%VolumeRelMax,                    &
                                            Me%ExternalVar%Upwind2H)


                        if (Me%ExternalVar%NoAdvFlux) then
                            do i = ILB, IUB
                                if (Me%ExternalVar%NoFluxV(i, j, k)==1) then
                                    Me%COEF3_HorAdvXX%C_flux     (i,j,k) = 0.
                                    Me%COEF3_HorAdvXX%D_flux     (i,j,k) = 0. 
                                    Me%COEF3_HorAdvXX%E_flux     (i,j,k) = 0.
                                    Me%COEF3_HorAdvXX%F_flux     (i,j,k) = 0.
                                endif
                            enddo
                        endif                                                

                end do j1
                !$OMP END DO
                end do k1
            endif

        endif st
        !$OMP END PARALLEL
cd6:    if (ImpExp_AdvYY == ExplicitScheme)  then !ExplicitScheme = 0
    
            if (Me%ExternalVar%Optimize) then
                call HorizontalAdvectionYY_Explicit
            else
                !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxY)
    dok3 :      do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doj3 :      do j = JLB, JUB
    doi3 :      do i = ILB, IUB

                if (Me%ExternalVar%ComputeFacesV3D(i, j  , k) == 1) then

                    AdvFluxY =    (Me%COEF3_HorAdvYY%C_flux(  i, j, k)                          &
                                *  Me%ExternalVar%PROP     (i-2, j, k)                          &
                                +  Me%COEF3_HorAdvYY%D_flux(  i, j, k)                          &
                                *  Me%ExternalVar%PROP     (i-1, j, k)                          &
                                +  Me%COEF3_HorAdvYY%E_flux(  i, j, k)                          &
                                *  Me%ExternalVar%PROP     (  i, j, k)                          &
                                +  Me%COEF3_HorAdvYY%F_flux(  i, j, k)                          &
                                *  Me%ExternalVar%PROP     (i+1, j, k))

                    Me%TICOEF3(i  ,j,k) = Me%TICOEF3(i  ,j,k) + AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i  ,j,k)
                    Me%TICOEF3(i-1,j,k) = Me%TICOEF3(i-1,j,k) - AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i-1,j,k)

                endif

                end do doi3
                end do doj3
                !$OMP END DO NOWAIT
                end do dok3
                !$OMP END PARALLEL
            endif

        else if (ImpExp_AdvYY == ImplicitScheme) then cd6 !ImplicitScheme = 1
            !$OMP PARALLEL PRIVATE(i,j,k,DT2,DT1)
dok4 :      do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj4 :      do j = JLB, JUB
doi4 :      do i = ILB, IUB


            if (Me%ExternalVar%ComputeFacesV3D(i, j  , k) == 1) then

                DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i  ,j  ,k)
                DT1 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i-1,j  ,k)

                Me%COEF3%D(i,j  ,k) = Me%COEF3%D(i,j  ,k) - Me%COEF3_HorAdvYY%D_flux(i,   j, k) * DT2
                Me%COEF3%E(i,j  ,k) = Me%COEF3%E(i,j  ,k) - Me%COEF3_HorAdvYY%E_flux(i,   j, k) * DT2

                Me%COEF3%E(i-1,j,k) = Me%COEF3%E(i-1,j,k) + Me%COEF3_HorAdvYY%D_flux(i,   j, k) * DT1
                Me%COEF3%F(i-1,j,k) = Me%COEF3%F(i-1,j,k) + Me%COEF3_HorAdvYY%E_flux(i,   j, k) * DT1
                
!The module advection is only able to compute tridiagonal linear systems 
!
!                    Me%COEF3%C(i,j,k) =  not computed
!                    Me%COEF3%G(i,j,k) =  not computed

!                      The aux variables
!                      Me%COEF3_VertAdv%C_flux and are not used Me%COEF3_VertAdv%G_flux


            endif


            end do doi4
            end do doj4
            !$OMP END DO NOWAIT
            end do dok4
            !$OMP END PARALLEL
        else cd6

            stop 'sub. HorizontalAdvectionYY - ModuleAdvectionDiffusion - ERR01'
        
        endif cd6

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionYY")

        if (Me%State%CellFluxes .and. ImpExp_AdvYY == ExplicitScheme) then
             if (Me%ExternalVar%Optimize)then
                call CalcHorizontalAdvFluxYY_opt(1. - ImpExp_AdvYY)
            else
                call CalcHorizontalAdvFluxYY(1. - ImpExp_AdvYY)
            endif
        endif

        !----------------------------------------------------------------------

    end subroutine HorizontalAdvectionYY

    !--------------------------------------------------------------------------
    
    subroutine HorizontalAdvectionYY_Explicit

        !Local-----------------------------------------------------------------               
        real(8)                             :: AdvFluxY
        integer                             :: i,     j,     k                             
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB ; IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB ; JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB ; KUB = Me%WorkSize%KUB
        CHUNK = CHUNK_K(KLB, KUB)

        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxY)
        CHUNK = CHUNK_K(KLB, KUB)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB

        if (Me%ExternalVar%ComputeFacesV3D(i, j  , k) == 1) then

            AdvFluxY =    (Me%COEF3_HorAdvYY%D_flux(  i, j, k)                          &
                        *  Me%ExternalVar%PROP     (i-1, j, k)                          &
                        +  Me%COEF3_HorAdvYY%E_flux(  i, j, k)                          &
                        *  Me%ExternalVar%PROP     (  i, j, k))

            Me%TICOEF3(i  ,j,k) = Me%TICOEF3(i  ,j,k) + AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i  ,j,k)
            Me%TICOEF3(i-1,j,k) = Me%TICOEF3(i-1,j,k) - AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i-1,j,k)

        endif

        end do
        end do
        end do
        !$OMP END DO
        !$OMP END PARALLEL
    end subroutine HorizontalAdvectionYY_Explicit
    
    !--------------------------------------------------------------------------

    subroutine HorizontalAdvectionYY_Nudge(ImpExp_AdvYY)

        !Arguments--------------------------------------------------------------
        real                                :: ImpExp_AdvYY

        !Local-----------------------------------------------------------------               
        real(8)                             :: AdvFluxY, DT1, DT2
        integer                             :: i,     j,     k                             
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: CHUNK

        !----------------------------------------------------------------------

        !if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionYY")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB
        
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionYY")
        
        !CHUNK = CHUNK_K(Me%Size%KLB, Me%Size%KUB)
        CHUNK = CHUNK_J(JLB, JUB)
      
        !$OMP PARALLEL PRIVATE(i,j,k,AdvFluxY,DT2,DT1)

st:     if (Me%State%HorAdv) then
        
            !! $OMP PARALLEL SHARED(CHUNK) PRIVATE(J,K)
            !! $OMP DO SCHEDULE(DYNAMIC, CHUNK)

k1:         do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
j1:         do j = JLB, JUB


                call ComputeAdvection1D_V2(ILB+1, IUB+1, Me%ExternalVar%DTProp,         &
                                        Me%ExternalVar%DVY          (:,j),              &
                                        Me%ExternalVar%PROP         (:,j,k),            &
                                        Me%ExternalVar%Wflux_Y      (:,j,k),            &
                                        Me%ExternalVar%VolumeZ      (:,j,k),            & 
                                        Me%ExternalVar%OpenPoints3D (:,j,k),            &
                                        Me%COEF3_HorAdvYY%C_flux    (:,j,k),            &
                                        Me%COEF3_HorAdvYY%D_flux    (:,j,k),            &
                                        Me%COEF3_HorAdvYY%E_flux    (:,j,k),            &
                                        Me%COEF3_HorAdvYY%F_flux    (:,j,k),            &
                                        Me%ExternalVar%AdvMethodH,                      &
                                        Me%ExternalVar%TVDLimitationH,                  &
                                        Me%ExternalVar%VolumeRelMax,                    &
                                        Me%ExternalVar%Upwind2H)

            end do j1
            !$OMP END DO
            end do k1
            
            !! $OMP END DO NOWAIT
            !! $OMP END PARALLEL

        endif st


cd6:    if (ImpExp_AdvYY == ExplicitScheme)  then !ExplicitScheme = 0

dok3 :      do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj3 :      do j = JLB, JUB
doi3 :      do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesV3D(i, j  , k) == 1) then

                AdvFluxY =    (Me%COEF3_HorAdvYY%C_flux(  i, j, k)                          &
                            *  Me%ExternalVar%PROP     (i-2, j, k)                          &
                            +  Me%COEF3_HorAdvYY%D_flux(  i, j, k)                          &
                            *  Me%ExternalVar%PROP     (i-1, j, k)                          &
                            +  Me%COEF3_HorAdvYY%E_flux(  i, j, k)                          &
                            *  Me%ExternalVar%PROP     (  i, j, k)                          &
                            +  Me%COEF3_HorAdvYY%F_flux(  i, j, k)                          &
                            *  Me%ExternalVar%PROP     (i+1, j, k))

                !Me%TICOEF3(i  ,j,k) = Me%TICOEF3(i  ,j,k) + AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i  ,j,k)
                !Me%TICOEF3(i-1,j,k) = Me%TICOEF3(i-1,j,k) - AdvFluxY * Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i-1,j,k)

                Me%AdvectionTi(i  ,j,k) = Me%AdvectionTi(i  ,j,k) + AdvFluxY * Me%ExternalVar%DTProp / &
                                          Me%ExternalVar%VolumeZ(i  ,j,k)
                Me%AdvectionTi(i-1,j,k) = Me%AdvectionTi(i-1,j,k) - AdvFluxY * Me%ExternalVar%DTProp / &
                                          Me%ExternalVar%VolumeZ(i-1,j,k)
                

            endif

            end do doi3
            end do doj3
            !$OMP END DO NOWAIT
            end do dok3

        else if (ImpExp_AdvYY == ImplicitScheme) then cd6 !ImplicitScheme = 1

dok4 :      do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
doj4 :      do j = JLB, JUB
doi4 :      do i = ILB, IUB


            if (Me%ExternalVar%ComputeFacesV3D(i, j  , k) == 1) then

                DT2 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i  ,j  ,k)
                DT1 = Me%ExternalVar%DTProp / Me%ExternalVar%VolumeZ(i-1,j  ,k)

                !Me%COEF3%D(i,j  ,k) = Me%COEF3%D(i,j  ,k) - Me%COEF3_HorAdvYY%D_flux(i,   j, k) * DT2
                !Me%COEF3%E(i,j  ,k) = Me%COEF3%E(i,j  ,k) - Me%COEF3_HorAdvYY%E_flux(i,   j, k) * DT2

                !Me%COEF3%E(i-1,j,k) = Me%COEF3%E(i-1,j,k) + Me%COEF3_HorAdvYY%D_flux(i,   j, k) * DT1
                !Me%COEF3%F(i-1,j,k) = Me%COEF3%F(i-1,j,k) + Me%COEF3_HorAdvYY%E_flux(i,   j, k) * DT1
                
                Me%AdvectionD(i,j  ,k) = Me%AdvectionD(i,j  ,k) - Me%COEF3_HorAdvYY%D_flux(i,   j, k) * DT2
                Me%AdvectionE(i,j  ,k) = Me%AdvectionE(i,j  ,k) - Me%COEF3_HorAdvYY%E_flux(i,   j, k) * DT2

                Me%AdvectionE(i-1,j,k) = Me%AdvectionE(i-1,j,k) + Me%COEF3_HorAdvYY%D_flux(i,   j, k) * DT1
                Me%AdvectionF(i-1,j,k) = Me%AdvectionF(i-1,j,k) + Me%COEF3_HorAdvYY%E_flux(i,   j, k) * DT1                
                
                

!The module advection is only able to compute tridiagonal linear systems 
!
!                    Me%COEF3%C(i,j,k) =  not computed
!                    Me%COEF3%G(i,j,k) =  not computed

!                      The aux variables
!                      Me%COEF3_VertAdv%C_flux and are not used Me%COEF3_VertAdv%G_flux


            endif


            end do doi4
            end do doj4
            !$OMP END DO NOWAIT
            end do dok4

        else cd6

            stop 'sub. HorizontalAdvectionYY - ModuleAdvectionDiffusion - ERR01'
        
        endif cd6

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionYY")

        if (Me%State%CellFluxes .and. ImpExp_AdvYY == ExplicitScheme)                   &
            call CalcHorizontalAdvFluxYY(1. - ImpExp_AdvYY)
        
        !if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalAdvectionYY")

        !----------------------------------------------------------------------

    end subroutine HorizontalAdvectionYY_Nudge
    
    !--------------------------------------------------------------------------


    subroutine HorizontalDiffusion()

        !External--------------------------------------------------------------

        !----------------------------------------------------------------------
        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusion")
        
        if (Me%ExternalVar%Optimize)then
            call HorizontalDiffusionXX2()
        else
            call HorizontalDiffusionXX()
        endif
        
        if (.not. Me%XZFlow)then
            if (Me%ExternalVar%Optimize)then
                call HorizontalDiffusionYY2()
            else
                call HorizontalDiffusionYY()
            endif
        endif
                
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusion")

        !----------------------------------------------------------------------

    end subroutine HorizontalDiffusion

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine HorizontalDiffusionXX()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: DTPropDouble 
        real(8)                                     :: AuxJ
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        DTPropDouble = dble(Me%ExternalVar%DTProp)

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionXX")

        CHUNK = Chunk_K(Me%WorkSize%KLB,Me%WorkSize%KUB)
        !$OMP PARALLEL PRIVATE(i,j,k,AuxJ) 
 
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do3 :   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
do2 :   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
do1 :   do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then

                !DTV1 = DTPropDouble / Me%ExternalVar%VolumeZ(i, j-1, k)
                !DTV2 = DTPropDouble / Me%ExternalVar%VolumeZ(i, j  , k)
                        
                AuxJ = Me%Diffusion_CoeficientX (i,j  ,k)                               &
                       * Me%ExternalVar%AreaU   (i,j  ,k)                               &
                       / Me%ExternalVar%DZX     (i,j-1  )                    

                Me%TICOEF3(i,j-1,k) = Me%TICOEF3(i,j-1,k) + AuxJ * DTPropDouble /       &
                                      Me%ExternalVar%VolumeZ(i, j-1, k) *               &
                                     (Me%ExternalVar%PROP(i,j,k) - Me%ExternalVar%PROP(i,j-1,k))


                Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) - AuxJ * DTPropDouble /       &
                                      Me%ExternalVar%VolumeZ(i, j  , k) *               &
                                     (Me%ExternalVar%PROP(i,j,k) - Me%ExternalVar%PROP(i,j-1,k))


            endif

        end do do1
        end do do2
        end do do3
        !$OMP END DO
            
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionXX")
    
        if (Me%State%CellFluxes) call CalcHorizontalDifFluxXX()

        !----------------------------------------------------------------------

    end subroutine HorizontalDiffusionXX
    
    subroutine HorizontalDiffusionXX2()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: DTPropDouble, Gradient
        real(8)                                     :: AuxJ
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        DTPropDouble = dble(Me%ExternalVar%DTProp)

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionXX2")

        CHUNK = Chunk_K(Me%WorkSize%KLB,Me%WorkSize%KUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k,AuxJ, Gradient) 
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1) then
                
                Gradient  = Me%ExternalVar%PROP(i, j, k) -  Me%ExternalVar%PROP   (i, j-1, k)
                AuxJ      = Me%Diff_H_Const_U  (i, j ,k) * Gradient * DTPropDouble  
                
                Me%TICOEF3(i,j-1,k) = Me%TICOEF3(i,j-1,k) + AuxJ / Me%ExternalVar%VolumeZ(i, j-1, k)
                Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) - AuxJ / Me%ExternalVar%VolumeZ(i, j  , k)

            endif
        end do
        end do
        end do
        !$OMP END DO 
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionXX2")
    
        if (Me%State%CellFluxes) call CalcHorizontalDifFluxXX2()

        !----------------------------------------------------------------------

    end subroutine HorizontalDiffusionXX2

    !--------------------------------------------------------------------------

    subroutine HorizontalDiffusionYY2()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: DTPropDouble, Gradient
        real(8)                                     :: AuxI
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        DTPropDouble = dble(Me%ExternalVar%DTProp) 

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionYY2")

        CHUNK = Chunk_K(Me%WorkSize%KLB,Me%WorkSize%KUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k,AuxI, Gradient) 
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do3 :   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
do2 :   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
do1 :   do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%ExternalVar%ComputeFacesV3D(i  , j, k) == 1) then
                
                Gradient   = Me%ExternalVar%PROP(i, j, k) -  Me%ExternalVar%PROP   (i-1, j, k)
                AuxI       = Me%Diff_H_Const_V  (i, j ,k) * DTPropDouble * Gradient
                
                Me%TICOEF3(i-1, j, k) = Me%TICOEF3(i-1,j,k) + AuxI / Me%ExternalVar%VolumeZ(i-1, j, k)
                Me%TICOEF3(i  , j, k) = Me%TICOEF3(i  ,j,k) - AuxI / Me%ExternalVar%VolumeZ(i  , j, k)
                
            endif
        end do do1
        end do do2
        end do do3
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionYY2")

        if (Me%State%CellFluxes) call CalcHorizontalDifFluxYY2()

        !----------------------------------------------------------------------

    end subroutine HorizontalDiffusionYY2

    !--------------------------------------------------------------------------
    
    subroutine HorizontalDiffusionYY()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real(8)                                     :: DTPropDouble 
        real(8)                                     :: AuxI
        integer                                     :: i, j, k  
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        DTPropDouble = dble(Me%ExternalVar%DTProp) 

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionYY")

        CHUNK = Chunk_J(Me%WorkSize%JLB,Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,AuxI) 

do3 :   do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do2 :   do j = Me%WorkSize%JLB, Me%WorkSize%JUB
do1 :   do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%ExternalVar%ComputeFacesV3D(i  , j, k) == 1) then
                        
                AuxI = Me%Diffusion_CoeficientY (i  ,j,k)                               &
                       * Me%ExternalVar%AreaV   (i  ,j,k)                               &
                       / Me%ExternalVar%DZY     (i-1,j  )                    

                Me%TICOEF3(i-1,j,k) = Me%TICOEF3(i-1,j,k) + AuxI * DTPropDouble /       &
                                      Me%ExternalVar%VolumeZ(i-1, j, k) *               &
                                     (Me%ExternalVar%PROP(i,j,k) - Me%ExternalVar%PROP(i-1,j,k))


                Me%TICOEF3(i,j  ,k) = Me%TICOEF3(i,j  ,k) - AuxI * DTPropDouble /       &
                                      Me%ExternalVar%VolumeZ(i  , j, k) *               &
                                     (Me%ExternalVar%PROP(i,j,k) - Me%ExternalVar%PROP(i-1,j,k))
            endif
        end do do1
        end do do2
        !$OMP END DO
        end do do3

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "HorizontalDiffusionYY")

        if (Me%State%CellFluxes) call CalcHorizontalDifFluxYY()

        !----------------------------------------------------------------------

    end subroutine HorizontalDiffusionYY
    
    !-----------------------------------------------------------------------------

    subroutine OpenBoundaryCondition()

        !Arguments-------------------------------------------------------------

        !local-----------------------------------------------------------------

        integer :: i, j, k  
        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB
        integer :: ILBSize, IUBSize, JLBSize, JUBSize

        integer :: BoundaryCondition

        real    :: TdecAux
        real    :: ExteriorProp, ImpExp_DifV
        real(8) :: DT_V, DTPropDouble
        real    :: Atotal, A1, A2, A3, A4
        real    :: P1, P2, P3, P4, InteriorProp, VelBound
        logical :: EastNorthBoundary
        integer :: di, dj, iext, jext
        real    :: LimitMax, BoundaryProp
        logical :: Found
        
        !integer :: CHUNK

        !----------------------------------------------------------------------

        !if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "OpenBoundaryCondition")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        ILBSize = Me%WorkSize%ILB
        IUBSize = Me%WorkSize%IUB

        JLBSize = Me%WorkSize%JLB
        JUBSize = Me%WorkSize%JUB


        KUB = Me%WorkSize%KUB

        BoundaryCondition = Me%ExternalVar%BoundaryCondition

        ImpExp_DifV       = Me%ExternalVar%ImpExp_DifV

        DTPropDouble      = dble(Me%ExternalVar%DTProp)

        TdecAux           =  1.0 / (1.0 + Me%ExternalVar%DecayTime &
                             / Me%ExternalVar%DTProp)    

        if (BoundaryCondition == MassConservation_ .or. BoundaryCondition == Orlanski_ .or. &
            BoundaryCondition == MassConservNullGrad_ )                                     &
            call FluxAtOpenBoundary()


        if (BoundaryCondition == Orlanski_ )                                             &
            Me%ExternalVar%PROPOld(:,:,:) = Me%ExternalVar%PROP(:,:,:)

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "OpenBoundaryCondition")

        !CHUNK = CHUNK_J(JLB,JUB)

        !! $OMP PARALLEL PRIVATE(i,j,k,KLB,DT_V,A1,A2,A3,A4,P1,P2,P3,P4,Atotal,InteriorProp) &
        !! $OMP PRIVATE(ExteriorProp,VelBound,di,dj,iext,jext,LimitMax,Found,Me%ExternalVar%PROP)

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
do3 :   do  j = JLB, JUB
do1 :   do  i = ILB, IUB

cd9 :       if (Me%ExternalVar%BoundaryPoints2D(i,j) == 1) then 

                KLB = ABS(Me%ExternalVar%KFloorZ(i,j))


do2 :           do  k = KLB, KUB
                                         
cd3:                if (Me%ExternalVar%OpenPoints3D(i, j, k) == 1) then
                
                        DT_V = DTPropDouble / Me%ExternalVar%VolumeZ(i,j,k)    


                        if (BoundaryCondition == ImposedValue_ .or.                      &
                            BoundaryCondition == SubModel_) then

                            !Valor da propriedade a entrar no dominio em funcao do                      
                            !  valor imposto no exterior e do tempo de decaimento
                            !A expressao do tempo de decaimento e' resolvida para 
                            !  trás no tempo por razoes de estabilidade (Tese de doutoramento 
                            !  do Aires pág. 129

                            !Neighbours points of the "boundary point" that are interior.                         
                            A1 = Me%ExternalVar%OpenPoints3D(i + 1, j    , k) * &
                                 (1 - Me%ExternalVar%BoundaryPoints2D(i + 1, j    ))

                            A2 = Me%ExternalVar%OpenPoints3D(i - 1, j    , k) * &
                                 (1 - Me%ExternalVar%BoundaryPoints2D(i - 1, j    ))

                            A3 = Me%ExternalVar%OpenPoints3D(i    , j + 1, k) * &
                                 (1 - Me%ExternalVar%BoundaryPoints2D(i    , j + 1))

                            A4 = Me%ExternalVar%OpenPoints3D(i    , j - 1, k) * &
                                 (1 - Me%ExternalVar%BoundaryPoints2D(i    , j - 1))

                            !Property values of Neighbours points
                            P1 = Me%ExternalVar%PROP        (i + 1, j    , k)
                            P2 = Me%ExternalVar%PROP        (i - 1, j    , k)
                            P3 = Me%ExternalVar%PROP        (i    , j + 1, k)
                            P4 = Me%ExternalVar%PROP        (i    , j - 1, k)

                            Atotal = A1 + A2 + A3 + A4

                            if (Atotal > 0) then

                                InteriorProp = (P1 * A1 + P2 * A2 + P3 * A3 + P4 * A4) / Atotal

                                !Property imposed in the exterior using a decay time 
                                ExteriorProp = InteriorProp * (1.0 - TdecAux)            &
                                           +   Me%ExternalVar%ReferenceProp(i,j,k) *  TdecAux
                            else 

                                ExteriorProp = Me%ExternalVar%ReferenceProp(i,j,k)

                            endif

                        endif

                                               
cd1:                    if (BoundaryCondition == MassConservation_ .or.                  &
                            BoundaryCondition == Orlanski_         .or.                  &
                            BoundaryCondition == MassConservNullGrad_ ) then 

                            if (BoundaryCondition == Orlanski_) then


                                ![]      = [m^3/s] * [s/m^3]
                                VelBound = Me%WaterFluxOBoundary(i,j,k) * DT_V 

                                if      (i == ILB .or. i == IUB) then

                                    di = 1 
                                    dj = 0

                                else if (j == JLB .or. j == JUB) then

                                    di = 0 
                                    dj = 1

                                else

                                    Stop 'Orlanski Advection 2'

                                endif

                                if      (i == ILB .or. j == JLB) then

                                    EastNorthBoundary = .false.

                                    iext = i - di
                                    jext = j - dj

                                else if (i == IUB .or. j == JUB) then

                                    EastNorthBoundary = .true.

                                    iext = i + di
                                    jext = j + dj

                                else

                                    Stop 'Orlanski Advection 1'

                                endif

                                LimitMax = MaxInternalCelerity * Me%ExternalVar%DTProp / &
                                            (Me%ExternalVar%DUX(i, j) + &
                                             Me%ExternalVar%DVY(i, j)) * 2


                                call OrlanskiCelerity2D(NewField          = Me%ExternalVar%PROP,          &
                                                        OldField          = Me%ExternalVar%PROPOld,       &
                                                        ComputePoints     = Me%ExternalVar%OpenPoints3D,  &
                                                        ReferenceField    = Me%ExternalVar%ReferenceProp, &
                                                        Imin              = ILBSize,                                         &
                                                        Imax              = IUBSize,                                         &
                                                        Jmin              = JLBSize,                                         &
                                                        Jmax              = JUBSize,                                         &
                                                        di                = di,                                              &
                                                        dj                = dj,                                              &
                                                        i                 = iext,                                            &
                                                        j                 = jext,                                            &
                                                        k                 =  k,                                              &
                                                        LimitMax          = LimitMax,                                        &
                                                        EastNorthBoundary = EastNorthBoundary,                               &
                                                        DT                = Me%ExternalVar%DTProp,        &
                                                        FlowVelX          = VelBound,                                        &
                                                        NewValue          = ExteriorProp)

!                                call ExteriorValuesRadiation(Me, VelBound, i, j, k, BP2D)

                            else if (BoundaryCondition == MassConservation_ ) then

                                !In this option the interior point is also the boundary point
                                InteriorProp = Me%ExternalVar%PROP(i, j, k)


                                ! dP/dt = (Preference -P ) / Tdec
                                ! Tdec - infinity => TdecAux = 0 => ExteriorProp = P
                                ! Tdec - zero     => TdecAux = 1 => ExteriorProp = Preference

                                !Property imposed in the exterior using a decay time 
                                ExteriorProp = InteriorProp * (1.0 - TdecAux)            &
                                           +   Me%ExternalVar%ReferenceProp(i,j,k) *  TdecAux

                            endif


                            ! This method don't conserve mass if the Diffusion fluxe between the 
                            ! frontier and the interior is of the same magnitude of the advective fluxe
                        
cd2 :                       if (Me%WaterFluxOBoundary(i,j,k) < 0.0) Then ! water is flowing in    


                                if (.not. BoundaryCondition == MassConservNullGrad_) then
                                !Mass is being Added to the domain by default the flow 
                                ! is negative when is going in and this process is explicit computed
                                    Me%TICOEF3(i, j, k) = Me%TICOEF3(i, j, k)  &               
                                          -  Me%WaterFluxOBoundary(i,j,k)                         &
                                          *  ExteriorProp * DT_V

                                else if (BoundaryCondition == MassConservNullGrad_) then

                                    call NullGradProp(BoundaryProp, i, j, k, Found)

                                    if (Found) then

                                        Me%TICOEF3(i, j, k) = BoundaryProp

                                    else 
                                        
                                        Me%TICOEF3(i, j, k) = Me%ExternalVar%Prop(i, j, k)

                                    endif

                                    Me%COEF3%E(i,j,k) = 1.
                                    Me%COEF3%D(i,j,k) = 0.
                                    Me%COEF3%F(i,j,k) = 0.


                                endif



                            else   cd2
                                !Mass is being taken from the domain by default the 
                                ! flow is positive when is  going out and this 
                                ! process is implicit computed 
                                Me%COEF3%E(i,j,k) =  Me%COEF3%E(i,j,k)   &
                                      + Me%WaterFluxOBoundary(i,j,k) * DT_V 
                            end if cd2                                                      
                            
                         else if (BoundaryCondition == ImposedValue_ .or. BoundaryCondition == SubModel_) then cd1


                            !Property in the exterior constant in time and
                            ! boundary property equal to the exterior

                            Me%TICOEF3(i, j, k) = ExteriorProp

                            Me%COEF3%D(i,j,k) = 0.0
                            Me%COEF3%E(i,j,k) = 1.0
                            Me%COEF3%F(i,j,k) = 0.0

                         else if (BoundaryCondition == NullGradient_ .or. BoundaryCondition == CyclicBoundary_) then

                            Me%TICOEF3(i, j, k) = Me%ExternalVar%PROP(i,j,k)

                            Me%COEF3%D(i,j,k) = 0.0
                            Me%COEF3%E(i,j,k) = 1.0
                            Me%COEF3%F(i,j,k) = 0.0

                         else if (BoundaryCondition /= NullGradient_ .and. BoundaryCondition /= CyclicBoundary_) then
                            
                            write(*,*) ' This is not a valid boundary Condition'
                            stop 'sub. OpenBoundaryCondition - ModuleAdvectionDiffusion - ERR02'
                   
                        end if cd1
                    end if cd3
                end do do2
            end if cd9
        end do do1
        end do do3
        !! $OMP END DO
               
        !! $OMP END PARALLEL   
                
        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "OpenBoundaryCondition")
                                                                   
        !----------------------------------------------------------------------

    end subroutine OpenBoundaryCondition

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine FluxAtOpenBoundary()

        !Arguments-------------------------------------------------------------

        !local-----------------------------------------------------------------

        integer                            :: i, j, k  
        integer                            :: ILB, IUB
        integer                            :: JLB, JUB
        integer                            :: KLB, KUB
        integer, pointer, dimension(:,:,:) :: ComputeFacesU3D
        integer, pointer, dimension(:,:,:) :: ComputeFacesV3D
        integer, pointer, dimension(:,:,:) :: ComputeFacesW3D
        integer                            :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        ComputeFacesU3D => Me%ExternalVar%ComputeFacesU3D
        ComputeFacesV3D => Me%ExternalVar%ComputeFacesV3D
        ComputeFacesW3D => Me%ExternalVar%ComputeFacesW3D

        if (MonitorPerformance) call StartWatch ("ModuleAdvectionDiffusion", "FluxAtOpenBoundary")

        CHUNK = CHUNK_J(JLB,JUB)
        
        !$OMP PARALLEL PRIVATE(i,j,k,KLB)

        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do3 :   do j = JLB, JUB
do1 :   do i = ILB, IUB
cd1 :       if (Me%ExternalVar%BoundaryPoints2D(i,j) == 1) then 
                KLB = ABS(Me%ExternalVar%KFloorZ(i,j))

do2 :           do k = KLB, KUB 

                    Me%WaterFluxOBoundary(i, j, k) =                                           &            
                        Me%ExternalVar%Wflux_X(i  , j  , k)   * ComputeFacesU3D(i  , j  , k  ) &
                      - Me%ExternalVar%Wflux_X(i  , j+1, k)   * ComputeFacesU3D(i  , j+1, k  ) &            
                      + Me%ExternalVar%Wflux_Y(i  , j  , k)   * ComputeFacesV3D(i  , j  , k  ) &
                      - Me%ExternalVar%Wflux_Y(i+1, j  , k)   * ComputeFacesV3D(i+1, j  , k  ) &
                      + Me%ExternalVar%Wflux_Z(i  , j  , k)   * ComputeFacesW3D(i  , j  , k  ) &            
                      - Me%ExternalVar%Wflux_Z(i  , j  , k+1) * ComputeFacesW3D(i  , j  , k+1) &            
                      -(Me%ExternalVar%VolumeZ(i  , j  , k)                                    &
                       -Me%ExternalVar%VolumeZOld(i, j, k))                                    &
                      / Me%ExternalVar%DTProp
                end do do2

            end if cd1
        end do do1
        end do do3
        !$OMP END DO

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleAdvectionDiffusion", "FluxAtOpenBoundary")

        nullify(ComputeFacesU3D, ComputeFacesV3D, ComputeFacesW3D)
        !----------------------------------------------------------------------

    end subroutine FluxAtOpenBoundary

    !--------------------------------------------------------------------------

    subroutine Set_Internal_State(DTProp, CellFluxes, AdvMethodH, TVDLimitationH,        &
                                  AdvMethodV, TVDLimitationV, SchmidtCoef_V,             &
                                  SchmidtBackground_V, Schmidt_H, NullDif)

        !Arguments-------------------------------------------------------------
        real,       intent(IN)                      :: DTProp
        integer,    intent(IN)                      :: AdvMethodH, TVDLimitationH
        integer,    intent(IN)                      :: AdvMethodV, TVDLimitationV
        logical,    intent(IN)                      :: CellFluxes    
        real,       intent(IN)                      :: SchmidtCoef_V, SchmidtBackground_V
        real,       intent(IN)                      :: Schmidt_H
        logical,    intent(IN)                      :: NullDif

        !----------------------------------------------------------------------

        !If DTProp is different from previous DT Prop or 
        !the time the last time advection diffusion was called is different
        !from the current time, State%VertAdv & HorAdv must be set true 

cd2 :   if ((Me%ExternalVar%DTProp    /= DTProp) .OR.                                           &
            (Me%LastCalc              /= Me%Now)) then

            Me%State%VertAdv = ON
            Me%State%HorAdv  = ON

            Me%State%VertDif = ON
            Me%State%HorDif  = ON
        else

            !If parameters for AdvMethodH are diferent 
            if ((Me%ExternalVar%AdvMethodH      /= AdvMethodH    )              .OR.            &
                (Me%ExternalVar%TVDLimitationH  /= TVDLimitationH)              .OR.            &
                (Me%ExternalVar%AdvMethodH      == P2_TVD)) then 
                Me%State%HorAdv  = ON
            else
                Me%State%HorAdv  = OFF
            endif

            if ((Me%ExternalVar%AdvMethodV      /= AdvMethodV    )              .OR.            &
                (Me%ExternalVar%TVDLimitationV  /= TVDLimitationV)              .OR.            &
                (Me%ExternalVar%AdvMethodV      == P2_TVD)) then 
                Me%State%VertAdv  = ON
            else
                Me%State%VertAdv  = OFF
            endif

            if ((Me%ExternalVar%SchmidtCoef_V       /= SchmidtCoef_V)           .OR.            &
                (Me%ExternalVar%SchmidtBackground_V /= SchmidtBackground_V)     .OR.            &
                 NullDif) then
                Me%State%VertDif = ON
            else
                Me%State%VertDif = OFF
            endif

            if ((Me%ExternalVar%Schmidt_H           /= Schmidt_H)               .OR.            &
                NullDif) then
                Me%State%HorDif = ON
            else
                Me%State%HorDif = OFF
            endif

        end if cd2

cd3 :   if (CellFluxes) then
            Me%State%CellFluxes = ON
        else
            Me%State%CellFluxes = OFF
        end if cd3


cd6 :   if (associated(Me%ExternalVar%ReferenceProp)) then
            Me%State%OpenBoundary = ON

            if ((Me%ExternalVar%BoundaryCondition /= MassConservation_          ) .AND. &
                (Me%ExternalVar%BoundaryCondition /= ImposedValue_              ) .AND. &
                (Me%ExternalVar%BoundaryCondition /= SubModel_                  ) .AND. &
                (Me%ExternalVar%BoundaryCondition /= Orlanski_                  ) .AND. &
                (Me%ExternalVar%BoundaryCondition /= NullGradient_              ) .AND. &
                (Me%ExternalVar%BoundaryCondition /= CyclicBoundary_            ) .AND. &
                (Me%ExternalVar%BoundaryCondition /= MassConservNullGrad_       ))      &

                stop 'Set_Internal_State - ModuleAdvectionDiffusion - ERR01'
        else
            Me%State%OpenBoundary = OFF
        end if cd6


        !----------------------------------------------------------------------

    end subroutine Set_Internal_State

    !--------------------------------------------------------------------------

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR  

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



    subroutine KillAdvectionDiffusion(AdvectionDiffusionID, STAT)

        !Arguments-------------------------------------------------------------
        integer                        :: AdvectionDiffusionID
        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_             
        integer :: STAT_CALL

        !Local-----------------------------------------------------------------

        integer :: STAT_, nUsers
        !griflet
        integer                 :: p
        type(T_VECGW), pointer  :: VECGW

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(AdvectionDiffusionID, ready_)

cd1 :   if (ready_ /= OFF_ERR_) then
            
            nUsers = DeassociateInstance(mADVECTIONDIFFUSION_,  Me%InstanceID)

            if (nUsers == 0) then

                nUsers = DeassociateInstance (mTIME_,           Me%ObjTime)
                if (nUsers == 0) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR01'

                nUsers = DeassociateInstance (mHORIZONTALGRID_,  Me%ObjHorizontalGrid)
                if (nUsers == 0) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR02'
                
                nUsers = DeassociateInstance (mHORIZONTALMAP_,  Me%ObjHorizontalMap)
                if (nUsers == 0) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR03'
                
                nUsers = DeassociateInstance (mGEOMETRY_,       Me%ObjGeometry)
                if (nUsers == 0) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR04'

#ifdef _ENABLE_CUDA                
                !Kills ModuleCuda
                call KillCuda (Me%ObjCuda, STAT = STAT_CALL)
                ! No need to give error yet, Module still has users
#endif _ENABLE_CUDA                

                deallocate(Me%Diffusion_CoeficientX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR06'
                nullify   (Me%Diffusion_CoeficientX)

                deallocate(Me%Diffusion_CoeficientY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR06a'
                nullify   (Me%Diffusion_CoeficientY)

                deallocate(Me%Diffusion_CoeficientZ, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR06b'
                nullify   (Me%Diffusion_CoeficientZ)
                
                if (allocated(Me%Diff_H_Const_U)) then
                    deallocate (Me%Diff_H_Const_U, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR06c'
                endif
                
                if (allocated(Me%Diff_H_Const_V)) then
                    deallocate (Me%Diff_H_Const_V, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR06d'
                endif
                
                if (allocated(Me%Diff_V_Const)) then
                    deallocate (Me%Diff_V_Const, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR06e'
                endif
                
                deallocate(Me%Fluxes%AdvFluxX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR07'
                nullify   (Me%Fluxes%AdvFluxX   ) 

                deallocate(Me%Fluxes%AdvFluxY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR08'
                nullify   (Me%Fluxes%AdvFluxY   ) 

                deallocate(Me%Fluxes%AdvFluxZ, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR09'
                nullify   (Me%Fluxes%AdvFluxZ) 

                deallocate(Me%Fluxes%DifFluxX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR10'
                nullify   (Me%Fluxes%DifFluxX) 
 
                deallocate(Me%Fluxes%DifFluxY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR11'
                nullify   (Me%Fluxes%DifFluxY) 
 
                deallocate(Me%Fluxes%DifFluxZ, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR12'
                nullify   (Me%Fluxes%DifFluxZ) 
 
                deallocate(Me%WaterFluxOBoundary, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR13'
                nullify   (Me%WaterFluxOBoundary)

#ifdef _USE_PAGELOCKED
                ! FreePageLocked will also nullify the pointers and arrays
                call FreePageLocked(Me%ObjCuda, Me%COEF3%DPtr, Me%COEF3%D)
                call FreePageLocked(Me%ObjCuda, Me%COEF3%EPtr, Me%COEF3%E)
                call FreePageLocked(Me%ObjCuda, Me%COEF3%FPtr, Me%COEF3%F)
#else
                deallocate(Me%COEF3%D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR14a'
                nullify   (Me%COEF3%D) 

                deallocate(Me%COEF3%E, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR14b'
                nullify   (Me%COEF3%E) 

                deallocate(Me%COEF3%F, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR14c'
                nullify   (Me%COEF3%F) 
#endif

                deallocate(Me%COEF3_VertAdv%D_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR16f'
                nullify   (Me%COEF3_VertAdv%D_Flux) 

                deallocate(Me%COEF3_VertAdv%E_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR16g'
                nullify   (Me%COEF3_VertAdv%E_Flux)

                deallocate(Me%COEF3_VertAdv%C_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR16h'
                nullify   (Me%COEF3_VertAdv%C_Flux) 

                deallocate(Me%COEF3_VertAdv%F_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR16i'
                nullify   (Me%COEF3_VertAdv%F_Flux)
                
                deallocate(Me%COEF3_HorAdvXX%C_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR18h'
                nullify   (Me%COEF3_HorAdvXX%C_Flux) 

                deallocate(Me%COEF3_HorAdvXX%D_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR18f'
                nullify   (Me%COEF3_HorAdvXX%D_Flux) 

                deallocate(Me%COEF3_HorAdvXX%E_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR18g'
                nullify   (Me%COEF3_HorAdvXX%E_Flux) 

                deallocate(Me%COEF3_HorAdvXX%F_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR18i'
                nullify   (Me%COEF3_HorAdvXX%F_Flux) 

                deallocate(Me%COEF3_HorAdvYY%D_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR20f'
                nullify   (Me%COEF3_HorAdvYY%D_Flux) 

                deallocate(Me%COEF3_HorAdvYY%E_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR20g'
                nullify   (Me%COEF3_HorAdvYY%E_Flux) 

                deallocate(Me%COEF3_HorAdvYY%C_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR20h'
                nullify   (Me%COEF3_HorAdvYY%C_Flux) 

                deallocate(Me%COEF3_HorAdvYY%F_Flux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR20i'
                nullify   (Me%COEF3_HorAdvYY%F_Flux) 
#ifdef _USE_PAGELOCKED
                ! FreePageLocked will also nullify the pointers and arrays
                call FreePageLocked(Me%ObjCuda, Me%TICOEF3Ptr, Me%TICOEF3)
#else
                deallocate(Me%TICOEF3, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR21'
                nullify   (Me%TICOEF3)
                
#endif
                deallocate(Me%AdvectionTi,Me%AdvectionE, Me%AdvectionD, Me%AdvectionF)
                nullify   (Me%AdvectionTi,Me%AdvectionE, Me%AdvectionD, Me%AdvectionF) 
                !griflet
                do p = 1, Me%MaxThreads
                    VECGW => Me%THOMAS%VEC(p)
                    deallocate(VECGW%G)
                    deallocate(VECGW%W)
                enddo 
                deallocate(Me%THOMAS%VEC)
                !deallocate(Me%THOMAS%COEF3)
                deallocate(Me%THOMAS)

                deallocate(Me%VECW, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR22'
                nullify   (Me%VECW)

                deallocate(Me%VECG, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillAdvectionDiffusion - ModuleAdvectionDiffusion - ERR23'
                nullify   (Me%VECG)

                call DeallocateInstance()

                AdvectionDiffusionID = 0
                STAT_                = SUCCESS_

            endif

        else cd1

            STAT_ = UNKNOWN_

        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine KillAdvectionDiffusion

        !--------------------------------------------------------------------------

    subroutine DeallocateInstance ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_AdvectionDiffusion), pointer           :: AuxAdvectionDiffusion
        type (T_AdvectionDiffusion), pointer           :: PreviousAdvectionDiffusion

        !Updates pointers
        if (Me%InstanceID == FirstAdvectionDiffusion%InstanceID) then
            FirstAdvectionDiffusion => FirstAdvectionDiffusion%Next
        else
            PreviousAdvectionDiffusion => FirstAdvectionDiffusion
            AuxAdvectionDiffusion      => FirstAdvectionDiffusion%Next
            do while (AuxAdvectionDiffusion%InstanceID /= Me%InstanceID)
                PreviousAdvectionDiffusion => AuxAdvectionDiffusion
                AuxAdvectionDiffusion      => AuxAdvectionDiffusion%Next
            enddo

            !Now update linked list
            PreviousAdvectionDiffusion%Next => AuxAdvectionDiffusion%Next

        endif

        !Deallocates instance
        deallocate (Me)
        nullify    (Me) 
            
    end subroutine DeallocateInstance

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEME

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    subroutine Ready (AdvectionDiffusionID, ready_) 

        !Arguments-------------------------------------------------------------
        integer                                     :: AdvectionDiffusionID
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (Me)

cd1:    if (AdvectionDiffusionID > 0) then
            call LocateObjAdvectionDiffusion (AdvectionDiffusionID)
            ready_ = VerifyReadLock (mADVECTIONDIFFUSION_, Me%InstanceID)
        else
            ready_ = OFF_ERR_
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Ready

    !--------------------------------------------------------------------------

    subroutine LocateObjAdvectionDiffusion (AdvectionDiffusionID)

        !Arguments-------------------------------------------------------------
        integer                                     :: AdvectionDiffusionID

        !Local-----------------------------------------------------------------

        Me => FirstAdvectionDiffusion
        do while (associated (Me))
            if (Me%InstanceID == AdvectionDiffusionID) exit
            Me => Me%Next
        enddo

        if (.not. associated(Me))                                        &
            stop 'ModuleAdvectionDiffusion - LocateObjAdvectionDiffusion - ERR01'

    end subroutine LocateObjAdvectionDiffusion


end module ModuleAdvectionDiffusion

!----------------------------------------------------------------------------------------------------------
!MOHID Water Modelling System.
!Copyright (C) 1985, 1998, 2002, 2005. Instituto Superior Técnico, Technical University of Lisbon. 
!----------------------------------------------------------------------------------------------------------

