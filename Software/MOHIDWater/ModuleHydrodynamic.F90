!------------------------------------------------------------------------------
!        IST/MARETEC, Water Modelling Group, Mohid modelling system
!------------------------------------------------------------------------------
!
! TITLE         : Mohid Hydrodynamic
! PROJECT       : Mohid Water
! MODULE        : ModuleHydrodynamic
! URL           : http://www.mohid.com
! AFFILIATION   : IST/MARETEC, Marine Modelling Group
! DATE          : Nov 2018
! REVISION      : Paulo Leitao - v4.0
! DESCRIPTION   : Module responsbile for computing non-turbulent hydrodynamic processes
!
!------------------------------------------------------------------------------
!
!This program is free software; you can redistribute it and/or
!modify it under the terms of the GNU General Public License
!version 2, as published by the Free Software Foundation.
!
!This program is distributed in the hope that it will be useful,
!but WITHOUT ANY WARRANTY; without even the implied warranty of
!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!GNU General Public License for more details.
!
!You should have received a copy of the GNU General Public License
!along with this program; if not, write to the Free Software
!Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
!
!------------------------------------------------------------------------------
!
! Use this for the occasional introduction to a long file.
!

!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------
!BOI
! !TITLE: Mohid2000 hydrodynamic model
! !AUTHORS: Paulo Chambel
! !AFFILIATION: IST/MARETEC, Marine Modelling Group
! !DATE: 15Nov2000
! !INTRODUCTION: General description of the hydrodynamic model
!  The hydrodynamic class solves the three-dimensional primitive
!  equations in Cartesian coordinates for incompressible flows.
!  Hydrostatic equilibrium is assumed as well as Boussinesq Objroximation.
!  The mass and momentum evolution equations solve by the model are:
!  $$
!   \frac{\partial \int dV}{\partial t}=\oint
!   \overrightarrow{F}_{Water}\cdot d\overrightarrow{n}
!  $$
!  $$
!   \frac{\partial \int \overrightarrow{\text{v}}dV}
!   {\partial t}= \oint
!   \overrightarrow{\text{v}}\left( \overrightarrow
!   {\text{v}}+v\nabla \cdot
!   \overrightarrow{\text{v}}\right) \cdot
!   d\overrightarrow{n}-\nabla \eta \int
!   dV-\frac 1\rho \stackunder{\eta +z}
!   {\nabla \cdot \stackrel{\eta }{\int }\rho
!   dz}\cdot \int dV
!  $$
!  $$
!  \nabla =\left( \frac \partial {\partial x},\frac
!  \partial {\partial y}\right)
!  $$
!
!EOI
!-------------------------------------------------------------------------


Module ModuleHydrodynamic
!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------

!BOP
!
! !MODULE: ModuleHydrodynamic

!    !DESCRIPTION:
!     This model is responsible for all hydrodynamic properties:
!     Water level, velocites, water fluxes

! !REVISION HISTORY:
!   1Jan2000   Paulo Chambel       First experimental version.
!  16Nov2000   Paulo Chambel       Comments are introduce in the Protex format
!                                  to produce a manual
!  21Dec2000   Frank Braunschweig  Writes Velocity Modulus to HDF file
!
! !FILES USED:
!  'nomfich.dat' file is where the name files are given .
!  The keywords relevant for the hydrodynamic model are:
!    IN_DAD3D : input file
!    OUT_DESF : output file
!    IN_CNDI  : restart file
!    OUT_FIN  : final output use to restart the model
!
!
! !SEE ALSO:
!  http://194.65.82.103/manuais/default.htm
!

! !USES:
    use ModuleGlobalData
    use ModuleFunctions
    use ModuleTime
    use ModuleEnterData
    use ModuleGridData,         only : GetGridData, WriteGridData, UngetGridData,        &
                                       ConstructGridData, GetGridDataEvolution,          &
                                       KillGridData
    use ModuleProfile,          only : StartProfile, WriteProfile, KillProfile, GetProfileNextOutputTime
    use ModuleDischarges,       only : Construct_Discharges, GetDischargesNumber,        &
                                       GetDischargesGridLocalization, GetDischargeON,    &
                                       GetDischargeWaterFlow, GetDischargeFlowVelocity,  &
                                       GetByPassON, GetDischargesIDName,                 &
                                       CorrectsCellsDischarges, SetLocationCellsZ,       &
                                       GetDischargeSpatialEmission, SetLayer,            &
                                       TryIgnoreDischarge, GetDischargeSpatialType,      &
                                       GetDischargeFlowDistribuiton, UnGetDischarges,    &
                                       SetDischargeInterceptionRatio,                    &
                                       GetDischargeInterceptionRatio,                    &
                                       Kill_Discharges, CorrectsBypassCellsDischarges,   &
                                       SetDistributionCoefMass, IsUpscaling, UpscalingDischargeType
    use ModuleTimeSerie,        only : StartTimeSerie, StartTimeSerieInput,              &
                                       GetTimeSerieLocation, CorrectsCellsTimeSerie,     &
                                       GetNumberOfTimeSeries, TryIgnoreTimeSerie,        &
                                       GetTimeSerieValue, WriteTimeSerie,                &
                                       GetTimeSerieName, WriteTimeSerieLine,             &
                                       GetTimeSerieNextOutput, KillTimeSerie
    use ModuleHorizontalMap,    only : GetWaterPoints2D, GetBoundaries, GetBoundaryFaces,&
                                       GetExteriorBoundaryFaces, UnGetHorizontalMap,     &
                                       GetLandPoints2D
    use ModuleHorizontalGrid,   only : WriteHorizontalGrid, GetComputeZUV,               &
                                       GetCoriolisFrequency, GetHorizontalGrid,          &
                                       InterpolRegularGrid, UnGetHorizontalGrid,         &
                                       GetGridCoordType, GetCoordTypeList, GetGridOrigin,&
                                       GetGridLatitudeLongitude, GetHorizontalGridSize,  &
                                       GetCheckDistortion, GetGridRotation, GetGridAngle,&
                                       RotateVectorFieldToGrid, GetXYCellZ,              &
                                       GetCellZInterceptByPolygon, GetCellZInterceptByLine,&
                                       GetCellZInterceptByXYZPoints,                     &
                                       GetDDecompMPI_ID, GetDDecompON,                   &
                                       GetDDecompSlaves,                                 &
                                       GetDDecompSlavesSize,                             &
                                       GetDDecompParameters,                             &
                                       WindowIntersectDomain,                            &
                                       ReturnsIntersectionCorners,                       &
                                       GetGridOutBorderPolygon,                          &
                                       GetDDecompWorkSize2D, WriteHorizontalGrid_UV,     &
                                       GetCellRotation, GetGridCellArea, GetConnections, &
                                       GetCornersCoordinates
    use ModuleTwoWay,           only : ConstructTwoWayHydrodynamic, ModifyTwoWay,        &
                                       AllocateTwoWayAux, PrepTwoWay, UngetTwoWayExternal_Vars, &
                                       ConstructUpscalingDischarges, UpscaleDischarge, &
                                       GetUpscalingDischarge
#ifdef _USE_MPI
    use ModuleHorizontalGrid,   only : ReceiveSendProperitiesMPI, THOMAS_DDecompHorizGrid
#endif


    use ModuleGeometry,         only : GetGeometrySize, GetGeometryWaterColumn,          &
                                       GetGeometryDistances, GetGeometryKFloor,          &
                                       GetGeometryMinWaterColumn, UnGetGeometry,         &
                                       ReadGeometryBin, ComputeInitialGeometry,          &
                                       ComputeVerticalGeometry, WriteGeometryBin,        &
                                       GetGeometryVolumes, GetGeometryAreas,             &
                                       GetLayer4Level, WriteGeometryHDF, ReadGeometryHDF
    use ModuleMap,              only : GetWaterPoints3D, GetOpenPoints3D,                &
                                       GetComputeFaces3D, GetImposedTangentialFaces,     &
                                       GetImposedNormalFaces, UnGetMap,                  &
                                       UpdateComputeFaces3D, SetComputesFaces3D,         &
                                       GetLandBoundaryFaces3D, GetWetFaces,              &
                                       GetWaterFaces3D
    use ModuleBoxDif,           only : StartBoxDif, GetBoxes, BoxDif, UngetBoxDif,       &
                                       KillBoxDif
    use ModuleOpenBoundary,     only : ConstructOpenBoundary, Modify_OpenBoundary,       &
                                       GetAverageImposedElevation, GetImposedElevation,  &
                                       UnGetOpenBoundary,                                &
                                       GetOpenBoundParameter, GetImposedVelocity,        &
                                       GetBoundaryReferenceLevel, KillOpenBoundary,      &
                                       Modify_AllDomain
    use ModuleTurbulence,       only : GetContinuousGOTM, GetMLD_Surf, UnGetTurbulence,  &
                                       GetHorizontalViscosity, GetVerticalViscosity
    use ModuleHydrodynamicFile, only : StartHydrodynamicFile, GetHydrodynamicFileIOState,&
                                       ModifyHydrodynamicFile, GetFileWaterLevel,        &
                                       GetFileFluxes, GetFileMapping,                    &
                                       UnGetHydrodynamicFile, KillHydrodynamicFile

    use ModuleAssimilation,     only : StartAssimilation, GetAssimilationField,          &
                                       GetAssimilationCoef, UnGetAssimilation,           &
                                       KillAssimilation, GetAssimilationAltimetry,       &
                                       GetAssimilationAltimetryDT, GetAltimetryDecayTime,&
                                       GetAltimSigmaDensAnalyzed, GetAssimilationVectorField, &
                                       GetWaveCelerityField, GetNumberOfFields
    use ModuleStopWatch,        only : StartWatch, StopWatch
    use ModuleStatistic,        only : ConstructStatistic, GetStatisticMethod,           &
                                       GetStatisticParameters, GetStatisticLayersNumber, &
                                       GetStatisticLayerDef, ModifyStatistic,            &
                                       AddStatisticLayers, KillStatistic
    use ModuleHDF5
#ifndef _WAVES_
    use ModuleWaves,            only : GetWavesStress, GetWaves, SetGeneric4DValues, UnGetWaves, &
                                       SetWavesSeaLevelVel2DSwan, GetWavesForcing3D, UnGetWaves3D
#endif
    use ModuleFillMatrix,       only : ConstructFillMatrix, ModifyFillMatrix, KillFillMatrix
    use ModuleDrawing
    !$ use omp_lib

#if _USE_MPI
    use mpi
#endif

#ifdef _ENABLE_CUDA
    use ModuleCuda
#endif _ENABLE_CUDA
    use ModuleTurbine,           only : ConstructTurbine, ModifyTurbine, ComputeTurbineEnergy,          &
                                       GetTurbineAcceleration, UnGetTurbineAcceleration, KillTurbine, OutPut_turbine
    implicit none

    private

!   !PUBLIC SUBROUTINES

    !Constructor
        !  StartHydrodynamic
    !Modifier
        !  Modify_Hydrodynamic
    !Selector
        !  GetWaterFluxes
        !  GetHorizontalVelocity
        !  GetOldHorizontalVelocity
        !  GetVerticalVelocity
        !  GetWaterLevel
        !  GetChezy
        !  GetDirection
        !  GetHydrodynamicSource
        !  GetDischargesFluxes
        !  GetPointDischargesState
        !  UngetHydrodynamic
    !Destructor
        !  KillHydrodynamic

    !PUBLIC TYPES:
        !  T_Hydrodynamic

 !EOP

    !subroutines tree---------------------------------------------------------------



    !Should be transfer for a Bottom boundary module
    private :: Bottom_Boundary
    private :: Modify_ChezyZ
    private :: Modify_ChezyVelUV


    !Constructor
    public  :: StartHydrodynamic
    private ::      Construct_Hydrodynamic
    private ::          Construct_HydrodynamicTime
    private ::          Read_Hydrodynamic_Files_Name
    private ::          Construct_Numerical_Options
    private ::              InicWaveStressOptions
    private ::          Verify_Numerical_Options
    private ::          Actualize_HydrodynamicTimeStep
    private ::          InitialHydrodynamicField
    private ::          StartOutputBoxFluxes
    private ::          AllocateVariables
    private ::          Construct_Sub_Modules
    private ::          Construct_OutPutTime
    private ::          Construct_Time_Serie
    private ::          ConstructMatrixesOutput
    private ::          ConstructHydrodynamicProperties
    private ::              Read_Final_Hydrodynamic_File
    private ::                  Read_Final_HDF5
    private ::                  Read_Final_Bin
    private ::          ReadInitialImposedSolution
    private ::          Initial_Geometry

    private ::          InitialReferenceWaterFluxes
    private ::          Open_HDF5_OutPut_File
    private ::          Open_Surface_HDF5_OutPut_File
    private ::          ConstructEnergy
    private ::          ConstructTidePotential

    private ::          ConstructRelaxation
    private ::          ConstructHydroStatistic

    private ::      CourantGH
    private ::          F_Courant                   !Function
    private ::          OutputCourant

#ifdef OVERLAP
    private  :: ConstructHydroOverlap
#endif OVERLAP

#ifdef _USE_SEQASSIMILATION
    !Subroutine to point to memory space of hydrodynamic properties
    public  :: PointToHydroState
#endif _USE_SEQASSIMILATION

    !Modifier
    public  :: Modify_Hydrodynamic
    private ::      Actualises_Hydrodynamic
    private ::      CalcNewDT

    private ::      One_Iteration
    private ::      MomentumMassConservation
    private ::          ReadImposedSolution
    private ::          Abbott_Scheme
    private ::          Leendertse_Scheme
    private ::              ChangeDirection
    private ::                  AssociateDirectionX
    private ::                  AssociateDirectionY
    private ::              Explicit_Forces
    private ::                  Modify_Horizontal_Transport
    private ::                      Modify_Advection_UX_VY
    private ::                      Modify_Advection_UX_VY2
    private ::                              Modify_Advection_UX_VY_Y
    private ::                              Modify_Advection_UX_VY_X
    private ::                      Modify_Advection_UY_VX
    private ::                      Modify_Advection_UY_VX2
    private ::                          Modify_Advection_UY_VX_Y
    private ::                          Modify_Advection_UY_VX_X
    private ::                      Modify_Advection_Bound
    private ::                          Modify_UX_VY_Boundary
    private ::                          Modify_UY_VX_Boundary
    private ::                          Modify_UX_VY_SubModel
    private ::                          Modify_UY_VX_SubModel
    private ::                      Modify_Diffusion_UX_VY
    private ::                      Modify_Diffusion_UX_VY2
    private ::                          Modify_Diffusion_UX_VY_Y
    private ::                          Modify_Diffusion_UX_VY_X
    private ::                      Modify_Diffusion_UY_VX
    private ::                      Modify_Diffusion_UY_VX2
    private ::                          Modify_Diffusion_UY_VX_Y
    private ::                          Modify_Diffusion_UY_VX_X
    private ::                      ModifyDiffSub_UX_VY
    private ::                      ModifyDiffSub_UY_VX
    private ::                      ModifyVolumeVariation
    private ::                      ModifyMomentumDischarge
    private ::                  Modify_WaveForces3D
    private ::                  ModifyRelaxHorizAdv
    private ::                  Modify_InertiaForces
    private ::                  Modify_InertiaForces2
    private ::                      InertialForces_Coriolis_Y
    private ::                      InertialForces_Coriolis_X
    private ::                      InertialForces_Centrifugal_Cir
    private ::                      InertialForces_Centrifugal_Y
    private ::                      InertialForces_Centrifugal_X
    private ::                  Modify_ROX3
    private ::                  ModifyTidePotential
    private ::                  ModifyRelaxAceleration
    private ::                  ModifyAltimAceleration
    private ::                  DumpingWaveStress
    private ::              VerticalMomentum
    private ::              NonHydroStaticCorrection
    private ::                  NonHydroOpenBoundary

    private ::          ReadHydrodynamicFile
    !private ::          ModifyBackgroundVelocity

    private ::              Compute_Velocity
    private ::                  Velocity_ExplicitForces
    private ::                  Velocity_ExplicitForces2
    private ::                      AddBarotropicForce
    private ::                      AddWaterPressure_acceleration_S !South direction
    private ::                      AddWaterPressure_acceleration_W ! West direction
    private ::                      AddTidePotential
    private ::                      AddAtmPressure
    private ::                  Velocity_VerticalAdvection
    private ::                  Velocity_VerticalAdvection2
    private ::                      Vel_VertAdv_P2_TVD_SB
    private ::                          Vel_VertAdv_P2_TVD_SB_Imp_Y
    private ::                          Vel_VertAdv_P2_TVD_SB_Imp_X
    private ::                          Vel_VertAdv_P2_TVD_SB_Exp_Y
    private ::                          Vel_VertAdv_P2_TVD_SB_Exp_X
    private ::                  Velocity_VerticalDiffusion
    private ::                  Velocity_VerticalDiffusion2
    private ::                      Velocity_VerticalImpDiffusion_Y
    private ::                      Velocity_VerticalExpDiffusion_Y
    private ::                      Velocity_VerticalImpDiffusion_X
    private ::                      Velocity_VerticalExpDiffusion_X
    private ::                  VelVerticalDiffusionBoundaries
    private ::                  Velocity_OpenBoundary
    private ::                      Compute_BaroclinicHorVelocity
    private ::                      VelTangentialOpenBoundary
    private ::                      VelNormalOpenBoundary
    private ::                      VelSubModelNormalOB
    private ::                      VelSubModelTangentialOB
    private ::                      CyclicBoundVectTangential
    private ::                      CyclicBoundVectNormal
    private ::                      CyclicBoundVertical

    private ::              Compute_WaterLevel
    private ::                  WaterLevel_BarotropicPressure
    private ::                  WaterLevel_BottomFriction
    private ::                  WaterLevel_ExplicitForces
    private ::                  WaterLevel_WaterFluxes
    private ::                  WaterLevel_OpenBoundary
    private ::                      WaterLevel_ImposedWave
    private ::                      WaterLevel_FlatherWindWave
    private ::                      WaterLevel_FlatherLocalSolution
    private ::                      WaterLevel_BlumbergKantha
    private ::                  WaterLevelDischarges
    private ::                  WaterLevelRelaxation
    private ::                  WaterLevelRelaxationAltimetry
    private ::                  WaterLevelCorrection
    private ::                  WaterLevelMaxMin

    private ::                  Waterlevel_CyclicBoundary
    private ::                      CyclicCoef2D

    private ::                  WaterLevel_Tsunami
    private ::                      Dip_Slip
    private ::                      Strike_Slip

    private ::              Modify_HorizontalWaterFlow

    private ::          New_Geometry
    private ::          New_VerticalHydrodynamic
    private ::              Modify_VerticalWaterFlow
    private ::                  WaterFlux_Z_VarGrid
    private ::                  WaterFlux_Z_FixGrid
    private ::              Modify_VerticalWaterFlow2
    private ::              Filter_3D_Fluxes
    private ::              Compute_VerticalVelocity
    private ::              ComputeCartesianVertVelocity
    private ::              CartesianVertVelocity_X
    private ::              CartesianVertVelocity_Y
    private ::              CartesianVertVelocity_dszdt
    private ::              ComputeCartesianVertVelocity_Waves
    private ::              ComputeCartesianNH
    private ::              Boundary_VerticalFlow
    private ::                  ComputeBaroclinicVertVelocity
    private ::                  Compute_BoundaryVertFlux

    private ::          ModifyWaterDischarges

    private ::      ComputeResidualFlowProperties
    private ::      ComputeEmersionTime
    private ::      ComputeSystemEnergy
    private ::          WriteEnergyDataFile
    private ::      Hydrodynamic_OutPut
    private ::      ComputeTwoWay

    private ::          Write_HDF5_Format
    private ::          Write_Surface_HDF5_Format
    private ::              CenterVelocity
    private ::              Statistics_OutPut
    private ::          OutPut_TimeSeries
    private ::          OutputTimeSeries_FileOK
    private ::          ModifyMatrixesOutput

    private ::          ComputeFloodRisk

    private ::      FaceDensityUpdate

#ifdef _USE_SEQASSIMILATION
    !Copy subroutines usable in sequential data assimilation to change variables' value
    public  :: CopyWaterLevel
    public  :: CopyHorizontalVelocity
    public  :: CopyVerticalVelocity
    public  :: CopyWaterFluxes
    public  :: CopySubModelFluxes
    public  :: CopyChezyVelUV
#endif _USE_SEQASSIMILATION

    !private ::         ASCII_Format

    !Selector
    public  :: GetWaterFluxes
    public  :: GetHorizontalVelocity
    public  :: GetOldHorizontalVelocity
    public  :: GetVerticalVelocity
    public  :: GetWaterLevel
    public  :: GetChezy
    public  :: GetHydrodynamicAirOptions
    public  :: GetDirection
    public  :: GetHydrodynamicSource
    public  :: GetDischargesFluxes
    public  :: GetPointDischargesState
    public  :: GetHydroNeedsFather
    public  :: GetWavesStressON
    public  :: GetHydroAltimAssim
    public  :: GetVertical1D
    public  :: GetXZFlow
    public  :: GetVelocityModulus
    public  :: GetResidualVelocityON
    public  :: GetResidualHorizontalVelocity
    public  :: GetResidualVelocityPeriod

#ifdef _USE_SEQASSIMILATION
    public  :: GetHydroSeqAssimilation
    public  :: GetCyclicBoundary
    public  :: GetSubModelFluxes
    public  :: GetChezyVelUV
#endif _USE_SEQASSIMILATION

#ifdef OVERLAP
    public  :: GetHydroOverlap
    public  :: SetModelOverlapHydro
#endif OVERLAP


    public  :: SetHydroFather
    private ::      ConstructTimeInterpolation
    private ::      TestSubModelOptionsConsistence
    private ::      ReadNextOrInitialField
    private ::      AddSubmodelWaterLevel
    private ::          ReadLockFather
    private ::          ReadUnLockFather
    private ::      ActualizeSubModelValues
    private ::      ActualizeSon3DWithFather2D
    private ::          RemoveLowerSpikes
    private ::          ReadLockSon
    private ::          ReadUnLockSon
    private ::      ActualizeSon3DWithFather3D
    private ::      Set_Upscaling_Discharges
    public  :: SetHydrodynamicManning
    public  :: SetHydrodynamicChezy
    public  :: SetHydrodynamicRugosityMatrix
    public  :: SetSurfaceWaterFlux
    public  :: SetBottomWaterFlux
    public  :: SetWindStress
    public  :: SetAtmosphericPressure
    public  :: SetWaveChezyVel
    public  :: SetShearStressMethod
    public  :: SetWaveShearStress

#ifdef _USE_SEQASSIMILATION
    !Set subroutines usable to point variables to external variables/memory space
    public  :: SetWaterLevel
    public  :: SetHorizontalVelocity
    public  :: SetVerticalVelocity
    public  :: SetWaterFluxes
    public  :: SetSubModelFluxes
    public  :: SetChezyVelUV

    !Set subroutine to manage a virtual run of the model for EOF propagation
    public  :: SetHydroVirtualRun

    !Reset subroutine usable to reestablish variables to internal memory space
    public  :: ReSetHydrodynamicProperties
#endif _USE_SEQASSIMILATION

    public  :: UngetHydrodynamic


    !Destructor
    public  :: KillHydrodynamic
    private ::      KillHydroStatistics
    private ::      Write_Final_Hydrodynamic_File
    private ::          Write_Final_Bin
    private ::          Write_Final_HDF5
    private ::      OutputFloodRisk
    private ::      Deassociate_External_Modules
    private ::      Kill_Sub_Modules
    private ::          KillEnergy
    private ::          KillTidePotential
    private ::          KillSubModel
    private ::      DeallocateVariables
    private ::          KillMatrixesOutput

#ifdef _USE_SEQASSIMILATION
    !Subroutine to point to memory space of hydrodynamic properties
    public  :: NullifyHydroStatePointer
#endif _USE_SEQASSIMILATION

    !Management
    private :: ReadLock_External_Modules
    private ::      ReadLock_ModuleHorizontalGrid
    private ::      ReadLock_ModuleHorizontalMap
    private ::      ReadLock_ModuleGeometry
    private ::      ReadLock_ModuleMap
    private :: ReadLock_ModuleTurbulence
#ifndef _WAVES_
    private :: ReadLock_ModuleWaves
#endif
    private ::          Read_Lock

    private :: ReadUnLock_External_Modules
    private ::      ReadUnLock_ModuleHorizontalGrid
    private ::      ReadUnLock_ModuleHorizontalMap
    private ::      ReadUnLock_ModuleGeometry
    private ::      ReadUnLock_ModuleMap
    private :: ReadUnLock_ModuleTurbulence
#ifndef _WAVES_
    private :: ReadUnLock_ModuleWaves
#endif
    private ::          Read_UnLock

    !Functions
    private :: TangentialVelInterpolation
    private :: spythag
    private :: dpythag
    private :: Locate_Layer
    private :: Face_Interpolation
    private :: FrictionCoefficient
    private  :: Face_Velocity_Modulus


    !Interfaces----------------------------------------------------------------

    private :: NullGradProp3D_W_R4
    private :: NullGradProp3D_W_R8
    interface  NullGradProp3D_W
        module procedure NullGradProp3D_W_R4
        module procedure NullGradProp3D_W_R8
    end interface NullGradProp3D_W

    private :: UngetHydrodynamic2Dinteger
    private :: UngetHydrodynamic2Dreal4
    private :: UngetHydrodynamic2Dreal8
    private :: UngetHydrodynamic3Dreal4
    private :: UngetHydrodynamic3Dreal8
    interface  UngetHydrodynamic
        module procedure UngetHydrodynamic2Dinteger
        module procedure UngetHydrodynamic2Dreal4
        module procedure UngetHydrodynamic2Dreal8
        module procedure UngetHydrodynamic3Dreal4
        module procedure UngetHydrodynamic3Dreal8
        module procedure UngetHydrodynamic3Dinteger
    end interface UngetHydrodynamic

    private :: pythag
    interface  pythag
        module procedure spythag
        module procedure dpythag
    end interface pythag

    private :: HydroPropAssimilationVelocity
    private :: HydroPropAssimilation2D

    private HydroPropAssimilation
    interface  HydroPropAssimilation
        module procedure HydroPropAssimilationVelocity
        module procedure HydroPropAssimilation2D
    end interface HydroPropAssimilation

#ifdef _USE_MPI
    public  :: SendHydrodynamicMPI
    public  :: RecvHydrodynamicMPI
    public  :: UpdateHydroMPI
    !include  "mpif.f90"
#endif _USE_MPI

    !ModuleHydrodynamic parameters---------------------------------------------------------------------------


    !Direction
    integer, parameter :: DirectionX_      = 1
    integer, parameter :: DirectionY_      = 2
    integer, parameter :: DirectionXY_     = 3

    !Numeric Options
    integer, parameter :: UpWind_Scheme   = 1
    integer, parameter :: Quick_Scheme    = 2

    !Parameters
    character(LEN = StringLength), parameter :: Char_Upwind_Scheme          = trim(adjustl('Upwind'               ))
    character(LEN = StringLength), parameter :: Char_Quick_Scheme           = trim(adjustl('Quick'                ))


    real,    parameter :: Abbott          = 1.
    real,    parameter :: Leendertse      = 2.

    integer, parameter :: CurrentVelocity           = 0
    integer, parameter :: ResidualVelocity          = 1
    integer, parameter :: ResidualFlux              = 2
    integer, parameter :: ResidualFluxVel           = 3
    integer, parameter :: BaroclinicVelocity        = 4
    integer, parameter :: AltimGeostrophicVelocity  = 5
    integer, parameter :: BaroclinicForce           = 6
    integer, parameter :: SubModelVelocity          = 7
    integer, parameter :: StokesDriftVelocity       = 8
    integer, parameter :: WaveBreakingForceAccel    = 9
    integer, parameter :: WaveVortexForceAccel      = 10
    integer, parameter :: WavePressureForceAccel    = 11

    integer, parameter :: Solve_Equations_       = 1
    integer, parameter :: Read_File_             = 2
    integer, parameter :: No_hydrodynamic_       = 3
    integer, parameter :: Residual_hydrodynamic_ = 4
    integer, parameter :: Run_Off_               = 5
    integer, parameter :: ImposedSolution_       = 6
    !Guillaume
    integer, parameter :: Vertical1D_            = 7
    integer, parameter :: Harmonics_             = 8

    !Parameters
    character(LEN = StringLength), parameter :: Char_Solve_Equations        = trim(adjustl('Solve_Equations'      ))
    character(LEN = StringLength), parameter :: Char_Read_File              = trim(adjustl('Read_File'            ))
    character(LEN = StringLength), parameter :: Char_No_hydrodynamic        = trim(adjustl('No_hydrodynamic'      ))
    character(LEN = StringLength), parameter :: Char_Residual_hydrodynamic  = trim(adjustl('Residual_hydrodynamic'))
    character(LEN = StringLength), parameter :: Char_Run_Off                = trim(adjustl('Run_Off'              ))
    character(LEN = StringLength), parameter :: Char_ImposedSolution        = trim(adjustl('Imposed Solution'     ))
    character(LEN = StringLength), parameter :: Char_Vertical1D             = trim(adjustl('Vertical1D'           ))
    character(LEN = StringLength), parameter :: Char_Harmonics              = trim(adjustl('Harmonics'            ))



    integer, parameter :: NULL_VALUE           = 1
    integer, parameter :: NULL_GRADIENT        = 2

    !Input / Output
    integer, parameter :: FileOpen = 1, FileClose = 0
    integer, parameter :: EnergyBufferSize        = 1000

    !Geometry
    integer, parameter :: Fix         = 1
    integer, parameter :: Variable    = 2



    !Boxes
    real,    parameter :: Boxes_MinDepth = 0.0

    !Water
    character(5), parameter :: Char_Water = 'water'

    !Internal Waves Celerity
    integer, parameter :: Orlanski_    = 0
    integer, parameter :: Constant_    = 1
    integer, parameter :: OeyAndChen_  = 2

    !Wind waves celerity
    integer, parameter :: LongWaves_     = 0
    integer, parameter :: AnalyticWaves_ = 3

    !Maximum internal wave velocity allowed is 10 m/s.
    real,    parameter :: MaxInternalCelerity = 10.

    !Internal waves radiation
    integer, parameter :: NoRadiation_ = 0
    integer, parameter :: Horizontal_  = 1
    integer, parameter :: Vertical_    = 2


    !Barotropic boundary radiation conditions
    integer, parameter :: FlatherWindWave_      = 1
    integer, parameter :: FlatherLocalSolution_ = 2
    integer, parameter :: BlumbergKantha_       = 3

    !Local solution type
    integer, parameter :: NoLocalSolution_      = 1
    integer, parameter :: Submodel_             = 2
    integer, parameter :: AssimilationField_    = 3
    integer, parameter :: Gauge_                = 4
    integer, parameter :: AssimilaPlusSubModel_ = 5
    integer, parameter :: GaugePlusSubModel_    = 6
    integer, parameter :: AssimilaGaugeSubModel_= 7
    integer, parameter :: AssimilaGauge_        = 8

    !Baroclinic open boundary conditio discretization options
    integer, parameter :: Explicit_  = 1
    integer, parameter :: Implicit_  = 2
    integer, parameter :: StoreWave_ = 3


    ! Velocity use in the process of relaxation
    integer, parameter :: TotalVel_    = 1
    integer, parameter :: BarotrVel_   = 2
    integer, parameter :: BaroclVel_   = 3

    ! Wind forcing type
    integer, parameter :: NoWind_           = 0
    integer, parameter :: WithWind_         = 1
    integer, parameter :: InitialSmoothWind_= 2

    !Tidal components use to compute the tide potential effect
    integer, parameter     :: M2=1, S2=2, K2=3, N2=4, K1=5, O1=6, P1=7, Q1=8, Ssa = 9,   &
                              Mm =10, Mf = 11 , M3=12

    !Ways of computing the tide potential phase of each constituint using the doodson numbers
    integer, parameter     :: Kantha = 1, Lefevre=2

    !Methods to generate a water level perturbation due to a tsunami/fault
    integer, parameter     :: FaultOkada1985_ = 0, FaultFile_ = 1

    integer, parameter     :: Mass_               = 1
    integer, parameter     :: MomentumHorizontal_ = 2
    integer, parameter     :: MomentumVertical_   = 3

    !Wave forcing 3D
    integer, parameter        :: NoWave3D             = 0
    integer, parameter        :: ExpRadiationStress   = 1
    integer, parameter        :: GLM                  = 2

    integer, parameter        :: TauSurface           = 1
    integer, parameter        :: TauWalstra           = 2

    !Wave stress relaxation coefficients
    character(LEN = StringLength), parameter :: relax_wave_stress_begin = '<begin_relax_wave_stress>'
    character(LEN = StringLength), parameter :: relax_wave_stress_end   = '<end_relax_wave_stress>'

    integer, parameter        :: UpscalingDischargeByVolume = 1


    !Types---------------------------------------------------------------------

    private :: T_State
    type       T_State
        logical :: BOXFLUXES  = OFF         !Calculates fluxes among boxes, concentracions, etc.
        logical :: SURFACE    = OFF
        logical :: Initial    = OFF
    end type T_State


    private :: T_Direction
    type       T_Direction
        integer  :: XY = null_int
        integer  :: YX = null_int
        integer  :: di = null_int
        integer  :: dj = null_int
    end type       T_Direction

    private :: T_Files
    type       T_Files
         character(len=PathLength) :: InitialHydrodynamic = null_str
         character(len=PathLength) :: FinalHydrodynamic   = null_str
         character(len=PathLength) :: OutPutFields        = null_str
         character(len=PathLength) :: ConstructData       = null_str
         character(len=PathLength) :: BoxFluxesFileName   = null_str
         character(len=PathLength) :: Energy              = null_str
    end type T_Files

    private :: T_DDecomp
    type       T_DDecomp
        logical                                 :: ON               = .false.
        logical                                 :: Master           = .false.
        logical                                 :: MasterOrSlave    = .false.
        integer                                 :: Master_MPI_ID    = null_int
        integer                                 :: Nslaves          = 0
        integer, dimension(:), pointer          :: Slaves_MPI_ID    => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_Size      => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_Inner     => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_Mapping   => null()
        type (T_Size2D), dimension(:), pointer  :: Slaves_HaloMap   => null()
        integer                                 :: MPI_ID           = null_int
        type (T_Size2D)                         :: Global
        type (T_Size2D)                         :: Mapping
        type (T_Size2D)                         :: Inner
        type (T_Size2D)                         :: HaloMap
        real(8), pointer, dimension(:)          :: VECG             => null()
        real(8), pointer, dimension(:)          :: VECW             => null()
        real,    pointer, dimension(:,:)        :: WaterLevel_New   => null()
        type(T_Coef_2D ), pointer               :: Coef             => null()
        integer                                 :: Halo_Points      = null_int
        integer, pointer, dimension(:,:)        :: Interfaces       => null()
        integer                                 :: NInterfaces      = null_int
    end type T_DDecomp

    !Generic 4D
    private :: T_Generic4D
    type T_Generic4D
        logical                            :: ON              = .false.
        integer                            :: ObjTimeSerie    = null_int
        integer                            :: TimeSerieColumn = null_int
        real                               :: CurrentValue    = null_real
    end type T_Generic4D

    !NonHydrostatic
    private :: T_NonHydrostatic
    type T_NonHydrostatic
        real, dimension (:, :, :), pointer :: PressureCorrect => null()
        real, dimension (:, :, :), pointer :: PrevisionalQ    => null()
        real, dimension (:, :, :), pointer :: CCoef           => null()
        real, dimension (:, :, :), pointer :: GCoef           => null()
        real, dimension (:, :   ), pointer :: VerticalSurfLayerOld  => null()
        logical                            :: ON                    = .false.
        real                               :: Residual              = 1.e-6
        logical                            :: NormalizedResidual    = .false.
        real                               :: alphaLU               = 0.5
        integer                            :: MaxIt                 = 500
        logical                            :: PressureCorrection    = .false.
        logical                            :: SurfBoundHydrostatic  = .false.
        !logical                            :: SZZGrad               = .false.
    end type T_NonHydrostatic

    private :: T_HighLowTide
    type T_HighLowTide
        logical                         :: ON                   =  .false.
        real, dimension (:, :), pointer :: SeaLevel             => null()
        real, dimension (:, :), pointer :: Instant              => null()
        character (len=PathLength)      :: FileRefGauge         =  null_str
        integer                         :: ObjTimeSerieRef      =  null_int
        integer                         :: DataColumn           =  null_int 
        character (len=PathLength)      :: FilenameOut          =  null_str  
        integer                         :: ObjHDF5              =  null_int        
        type(T_Time)                    :: StartWindow      
        type(T_Time)                    :: EndWindow              
        type(T_Time)                    :: RefGaugeTime
        real                            :: BackwardDT           =  null_real
        real                            :: ForwardDT            =  null_real
        integer                         :: NextOuput            =  null_int
        logical                         :: HighTide             = .false. 
    end type T_HighLowTide    

    private :: T_WaterLevel
    type T_WaterLevel
        type(T_PropertyID)              :: ID
        type(T_PropertyID)              :: ID_Astro
        real, dimension (:, :), pointer :: New           => null()
        real, dimension (:, :), pointer :: Old           => null()
        real, dimension (:, :), pointer :: VolumeCreated => null()
        real, dimension (:, :), pointer :: Maxi          => null()
        real, dimension (:, :), pointer :: Mini          => null()
        type(T_PropertyID)              :: TideStateID
        real, dimension (:, :), pointer :: TideState     => null()
        real                            :: DT      = null_real
        real                            :: Default = null_real
        logical                         :: InitalizedByFile = .false.
    end type T_WaterLevel

    private :: T_Vel_UV
    type T_Vel_UV
        type(T_PropertyID)                 :: ID
        type(T_PropertyID)                 :: ID_Astro
        real, dimension (:, :, :), pointer :: New      => null()
        real, dimension (:, :, :), pointer :: Old      => null()
#ifdef _USE_PAGELOCKED
        type(C_PTR)                        :: OldPtr
        type(C_PTR)                        :: NewPtr
#endif _USE_PAGELOCKED
        real                               :: Default   = null_real
        integer                            :: InTypeZUV = null_int
    end type T_Vel_UV

    private :: T_Horizontal
    type T_Horizontal
        type(T_Vel_UV)   ::   U
        type(T_Vel_UV)   ::   V
        type(T_Vel_UV)   ::   UV
        type(T_Vel_UV)   ::   VU
    end type T_Horizontal

    private :: T_Vertical
    type T_Vertical
        real, dimension (:, :, :), pointer :: Cartesian    => null()
        real, dimension (:, :, :), pointer :: CartesianOld => null()
        real, dimension (:, :, :), pointer :: Across       => null()
#ifdef _USE_PAGELOCKED
        type(C_PTR)                        :: CartesianPtr
#endif
    end type T_Vertical

    private :: T_Velocity
    type T_Velocity
        type (T_Horizontal)             :: Horizontal
        type (T_Vertical)               :: Vertical
        real                            :: DT = null_real
        real, dimension (:, :), pointer :: BarotropicUc
        real, dimension (:, :), pointer :: BarotropicVc
    end type T_Velocity

    private :: T_WaterFluxes
    type T_WaterFluxes
        real(8), dimension(:,:,:), pointer     :: X               => null()
        real(8), dimension(:,:,:), pointer     :: Y               => null()
        real(8), dimension(:,:,:), pointer     :: Z               => null()
        real(8), dimension(:,:,:), pointer     :: XY              => null()
        real(8), dimension(:,:,:), pointer     :: YX              => null()
        real(8), dimension(:,:,:), pointer     :: Discharges      => null()
        real(8), dimension(:,:,:), pointer     :: DischargesVelU  => null()
        real(8), dimension(:,:,:), pointer     :: DischargesVelV  => null()
        real(8), dimension(:,:,:), pointer     :: DischargesVelUV => null()
        real                                   :: New_Old = null_real
    end type T_WaterFluxes

    private :: T_Residual
    type T_Residual
        real                                :: ResidualTime      = null_real
        real, dimension(:,:),   pointer     :: WaterLevel        => null()
        real, dimension(:,:,:), pointer     :: Velocity_U        => null()
        real, dimension(:,:,:), pointer     :: Velocity_V        => null()
        real, dimension(:,:,:), pointer     :: Vertical_Velocity => null()
        real, dimension(:,:,:), pointer     :: DWZ               => null()
        real(8), dimension(:,:,:), pointer  :: WaterFlux_X       => null()
        real(8), dimension(:,:,:), pointer  :: WaterFlux_Y       => null()
    end type T_Residual

    private :: T_Geostroph
    type T_Geostroph
        real,    dimension (:, :, :), pointer :: PressGrad    => null()
        real,    dimension (:, :, :), pointer :: U            => null()
        real,    dimension (:, :, :), pointer :: V            => null()
        real,    dimension (:, :, :), pointer :: UV           => null()
        real,    dimension (:, :, :), pointer :: VU           => null()
        real,    dimension (:, :, :), pointer :: AuxDesCentre => null()
        real,    dimension (:, :), pointer    :: U_barotropic => null()
        real,    dimension (:, :), pointer    :: V_barotropic => null()
        real,    dimension (:, :), pointer    :: Reference_U_barotropic => null()
        real,    dimension (:, :), pointer    :: Reference_V_barotropic => null()
        real,    dimension (:, :), pointer    :: Coef_U_barotropic => null()
        real,    dimension (:, :), pointer    :: Coef_V_barotropic => null()
        logical                               :: ON = .false.
    end type T_Geostroph

    private :: T_Forces
    type T_Forces
        real,    dimension (:, :, :), pointer :: Rox3XY => null() ! Baroclinic
        real,    dimension (:, :, :), pointer :: Rox3X  => null() ! Baroclinic
        real,    dimension (:, :, :), pointer :: Rox3Y  => null() ! Baroclinic
        real(8), dimension (:, :, :), pointer :: Horizontal_Transport => null()
        real,    dimension (:, :, :), pointer :: Inertial_Aceleration => null()
        real,    dimension (:, :, :), pointer :: Relax_Aceleration => null()
        real,    dimension (:, :, :), pointer :: ObstacleDrag_Aceleration => null()
        real,    dimension (:, :, :), pointer :: Altim_Relax_Aceleration => null()
        real,    dimension (:,:),     pointer :: TidePotentialLevel => null()
        real,    dimension (:, :, :), pointer :: Scraper_Aceleration => null()
        real,    dimension (:, :, :), pointer :: ThinWalls_Dissipation => null()
        real,    dimension (:, :, :), pointer :: Turbine_Acceleration => null()

        real,    dimension (:, :, :), pointer :: Wave3DExplicit_Acceleration

        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FPressureAccelU
        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FPressureAccelV
        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FPressureAccelUV

        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FVortexAccelU
        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FVortexAccelV
        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FVortexAccelUV

        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FBreakingAccelU
        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FBreakingAccelV
        real,    dimension (:, :, :), pointer :: Wave3DExplicit_FBreakingAccelUV
    end type T_Forces

    private :: T_WaveRad3D
    type T_WaveRad3D
        real,    dimension (:,:,:),   pointer :: WaveExpRadU
        real,    dimension (:,:,:),   pointer :: WaveExpRadV
        real,    dimension (:,:,:),   pointer :: WaveExpRadUV
    end type T_WaveRad3D

    private :: T_StokesVel
    type T_StokesVel
        type (T_Horizontal)                   :: Horizontal

        type (T_Vertical)                     :: Vertical

        real,    dimension (:,:),     pointer :: BottomStokesVertVel

    end type T_StokesVel

    private :: T_WaveStress
    type T_WaveStress
        logical                               :: ON
        logical                               :: Dumping
        real,    dimension (:,:),     pointer :: DumpCoef
    end type T_WaveStress


    private :: T_HorAdvection
    type T_HorAdvection

        real :: Coef1_Up = null_real
        real :: Coef2_Up = null_real
        real :: Coef3_Up = null_real

    end type T_HorAdvection

    private :: T_Coef_1D
    type T_Coef_1D
        real,    dimension (:), pointer :: a   => null(), &
                                           c   => null(), &
                                           r   => null(), &
                                           x   => null(), &
                                           u   => null(), &
                                           z   => null()
        real(8), dimension (:), pointer :: b   => null(), &
                                           bb  => null(), &
                                           gam => null()
    end type T_Coef_1D


    private :: T_Coef_2D
    type T_Coef_2D
        real,    dimension (:, :), pointer :: D     => null(), &
                                              F     => null(), &
                                              Ti    => null(), &
                                              Tiaux => null(), &
                                              Rad   => null(), &
                                              TiRad => null()
        real(8), dimension (:, :), pointer :: E     => null(), &
                                              Eaux  => null()
    end type T_Coef_2D


    private :: T_Coef_3D
    type T_Coef_3D
#ifdef _ENABLE_CUDA
        real(C_DOUBLE), dimension (:, :, :), pointer    :: D  => null(), &
                                                           F  => null(), &
                                                           Ti => null(), &
                                                           E  => null()
#else
        real,    dimension (:, :, :), pointer :: D  => null(), &
                                                 F  => null(), &
                                                 Ti => null()
        real(8), dimension (:, :, :), pointer :: E  => null()
#endif _ENABLE_CUDA
#ifdef _USE_PAGELOCKED
        type(C_PTR)                                     :: DPtr, &
                                                           EPtr, &
                                                           FPtr, &
                                                           TiPtr
#endif _USE_PAGELOCKED
    end type T_Coef_3D

    private :: T_Coef_Baroc
    type T_Coef_Baroc

        Integer, dimension( : ), pointer   :: Kleft  => null(), &
                                              Kright => null()

        Real(8), dimension( : ), pointer   :: Depth_integ => null(), &
                                              Hcenter     => null(), &
                                              Hleft       => null(), &
                                              Hright      => null(), &
                                              HroLeft     => null(), &
                                              HroRight    => null(), &
                                              DensRight   => null(), &
                                              DensLeft    => null()
    end type T_Coef_Baroc

    private :: T_InstantBound
    type T_InstantBound

        type (T_Time)                  :: TimeB
        real                           :: BaroclVel = null_real
        type (T_InstantBound), pointer :: Next => null(), &
                                          Prev => null()

    end type T_InstantBound


    private :: T_Imposed
    type T_Imposed

        integer                        :: Number     = null_int
        real                           :: DTInterval = null_real
        type (T_InstantBound), pointer :: FirstInstant => null(), &
                                          LastInstant  => null()

    end type T_Imposed

    private :: T_VelBaroclinic
    type T_VelBaroclinic

        type(T_Vel_UV)   ::   U
        type(T_Vel_UV)   ::   V
        type(T_Vel_UV)   ::   UV
        type(T_Vel_UV)   ::   VU
        !This velocity is compute for the cartesian referential
        real, dimension (:, :, :), pointer :: W_New => null(), &
                                              W_Old => null()

        real, dimension (:, :   ), pointer :: U2D  => null(), &
                                              V2D  => null(), &
                                              UV2D => null()

        type (T_Imposed), dimension(:), pointer :: ImposedNormX  => null(), &
                                                   ImposedNormY  => null(), &
                                                   ImposedNormXY => null(), &
                                                   ImposedTangX  => null(), &
                                                   ImposedTangY  => null(), &
                                                   ImposedTangXY => null()

        integer :: CelerityType              = null_int
        real    :: InternalCelerity          = null_real
        real    :: TRelaxOut                 = null_real
        real    :: TRelaxIn                  = null_real
        real    :: MinLeavingBaroclincVel    = null_real
        logical :: BaroclinicNormalRadiation = .false.
        integer :: BaroclinicOBCDiscret      = null_int
        logical :: StoreBaroclinicWave       = .false.

        real    :: DTWave = null_real

    end type T_VelBaroclinic

#ifdef _USE_SEQASSIMILATION
    private :: T_StatePointer
    type T_StatePointer
        real, dimension (:, :),    pointer :: WaterLevelNew        => null()
        real, dimension (:, :, :), pointer :: VelocityUNew         => null(), &
                                              VelocityVNew         => null(), &
                                              VelocityUOld         => null(), &
                                              VelocityVOld         => null(), &
                                              VelVerticalCartesian => null(), &
                                              VelVerticalAcross    => null()
        real(8), dimension(:,:,:), pointer :: WaterFluxX           => null(), &
                                              WaterFluxY           => null(), &
                                              WaterFluxZ           => null(), &
                                              SubModelqX           => null(), &
                                              SubModelqY           => null()
        real, dimension(:,:),      pointer :: ChezyVelUV           => null()
    end type T_StatePointer
#endif _USE_SEQASSIMILATION

    private :: T_Coefficients
    type T_Coefficients
        type(T_Coef_1D)                    :: D1
        type(T_Coef_2D)                    :: D2
        type(T_Coef_3D)                    :: D3
        !griflet
        type(T_Coef_Baroc), dimension(:), pointer   :: Baroc => null()
    end type T_Coefficients


    private :: T_External
    type T_External
        !Horizontal Mapping

        !Boundary faces : boundary point in one side and a interior point in another
        integer, dimension(:,:),   pointer :: BoundaryFacesUV => null(), &
                                              BoundaryFacesVU => null(), &
                                              BoundaryFacesU  => null(), &
                                              BoundaryFacesV  => null(), &
                                              BoundaryPoints  => null(), &
                                              WaterPoints2D   => null(), &
                                              LandPoints2D

        !3D Mapping

        !Compute faces. Faces where is possible to compute a velocity
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U  => null(), &
                                              ComputeFaces3D_V  => null(), &
                                              ComputeFaces3D_UV => null(), &
                                              ComputeFaces3D_VU => null(), &
                                              WaterPoints3D     => null(), &
                                              ComputeFaces3D_W  => null(), &
                                              OpenPoints3D      => null()

        !Land Water faces. Faces that have a land point in one side and a interior point in another
        integer, dimension(:,:,:), pointer :: LandBoundaryFacesUV => null(), &
                                              LandBoundaryFacesVU => null(), &
                                              LandBoundaryFacesU  => null(), &
                                              LandBoundaryFacesV  => null()


        !Imposed faces  : faces where the model do not compute velocites
        !                 but need to imposed values to define the
        !                 the velocities boundary condition
        integer, dimension(:,:,:),   pointer :: ImposedNormalFacesUV     => null(), &
                                                ImposedNormalFacesU      => null(), &
                                                ImposedNormalFacesV      => null(), &
                                                ImposedTangentialFacesU  => null(), &
                                                ImposedTangentialFacesV  => null(), &
                                                ImposedTangentialFacesUV => null(), &
                                                ImposedTangentialFacesVU => null()



        !Horizontal Grid
        !DUX - distance between the West face and the East face of a cell along the center cell
        !DVY - distance between the South face and the North face of a cell along the center cell
        !DZX - distance between the cell center and the center of the West cell (X direction)
        !DZY - distance between the cell center and the center of the South cell (Y direction)
        !DYY - width of the West face of a cell
        !DXX - width of the South face of a cell
        real,    dimension(:,:  ), pointer :: DUX => null(), &
                                              DVY => null(), &
                                              DZX => null(), &
                                              DZY => null(), &
                                              DYY => null(), &
                                              DXX => null()
        !Auxiliar pointers
        real,    dimension(:,:  ), pointer :: DUX_VY => null(), &
                                              DZX_ZY => null(), &
                                              DZY_ZX => null(), &
                                              DYY_XX => null(), &
                                              DXX_YY => null(), &
                                              DVY_UX => null()

        real,    dimension(:, :),  pointer :: Coriolis_Freq => null(), &
                                              RotationX     => null(), &
                                              RotationY     => null()

        logical                            :: Distortion   = .false.
        real                               :: GridRotation = null_real

        real, dimension(:, :), pointer     :: LatitudeZ  => null()
        real, dimension(:, :), pointer     :: LongitudeZ => null()


        !3D Geometry

        !Volume_Z_New - Last compute control volume of the water level compute point,
        !               basically is the volume of our grid
        !Volume_Z_Old - Previous compute control volume of the water level compute point
        !Volume_U     - Last compute control volume of the velocity U compute point
        !Volume_V     - Last compute control volume of the velocity V compute point
        !Volume_W     - Last compute control volume of the velocity W compute point
        !Area_U       - Area of the grid cell West face
        !Area_V       - Area of the grid cell South face
        !DWZ          - Thickness of the cell grid
        real(8), dimension(:,:,:), pointer :: Volume_Z_Old => null(), &
                                              Volume_Z_New => null(), &
                                              Volume_U     => null(), &
                                              Volume_V     => null(), &
                                              Volume_W     => null()

        real,    dimension(:,:,:), pointer :: Area_U        => null(), &
                                              Area_V        => null(), &
                                              DWZ           => null(), &
                                              SZZ           => null(), &
                                              DUZ           => null(), &
                                              DVZ           => null(), &
                                              DUZ_VZ        => null(), &
                                              DZZ           => null()

        real,    dimension(:,:  ), pointer :: WaterColumn   => null(), &
                                              WaterColumnU  => null(), &
                                              WaterColumnV  => null(), &
                                              WaterColumnUV => null(), &
                                              WaterColumnVU => null()

        !Auxiliar
        real(8), dimension(:,:,:), pointer :: Volume_UV => null()

        real,    dimension(:,:,:), pointer :: Area_UV   => null(), &
                                              Area_VU   => null()

        !KFloor variables (matrix that stores the first layer of the water column)
        integer, dimension(:,:),   pointer :: KFloor_Z => null(), &
                                              KFloor_U => null(), &
                                              KFloor_V => null()

        !Auxiliar
        integer, dimension(:,:),   pointer :: KFloor_UV => null(), &
                                              KFloor_VU => null()

        !Turbulence
        !Visc_H_Corner - Turbulent horizontal viscosity in the cell SW corner
        !Visc_H_Corner - Turbulent horizontal viscosity in the cell center
        !Visc_H_Corner - Turbulent vertical   viscosity
        real,    dimension(:,:,:), pointer :: Visc_H_Corner         => null(), &
                                              Visc_H_Center         => null(), &
                                              Vertical_Viscosity    => null()

        !Water Properties
        real,    dimension(:,:,:), pointer :: Density   => null(), &
                                              SigmaDens => null()

        !Bottom
        real,    dimension(:,:),   pointer :: ChezyZ            => null(), &
                                              ChezyVelUV        => null(), &
                                              WaveChezyVel      => null(), &
                                              RugosityMatrix    => null()

        real                               :: Hmin_Chezy    = null_real, &
                                              Vmin_Chezy    = null_real, &
                                              ChezyCoef     = null_real

        logical                            :: Manning = .false., &
                                              Chezy   = .false.

        integer                            :: ShearStressMethod = null_int

        !Surface
        real,    dimension(:,:),   pointer :: TauWindU      => null(), &
                                              TauWindV      => null(), &
                                              TauWind_UV    => null()

        real(8), dimension(:,:  ), pointer :: BottomWaterFlux   => null()

        real,    dimension(:,:  ), pointer :: SurfaceWaterFlux      => null(), &
                                              WindStress_X          => null(), &
                                              WindStress_Y          => null(), &
                                              AtmosphericPressure   => null()

        !Waves
        real,    dimension(:,:),   pointer :: TauWavesU        => null(), &
                                              TauWavesV        => null(), &
                                              TauWaves_UV      => null()
        real,    pointer, dimension(:,:  ) :: WavePeriod       => null(), &
                                              WaveHeight       => null()
        real,    pointer, dimension(:,:,:) :: DirectionH       => null()
        real,    pointer, dimension(:,:  ) :: Ubw              => null(), &
                                              Abw              => null()

        integer,                   pointer :: StokesFreqNum
        real,    dimension(:,:,:), pointer :: StokesWaveNumber
        real,    dimension(:,:),   pointer :: WaveInducedPressureJ
        real,    dimension(:,:,:), pointer :: StokesDriftSpectrumX
        real,    dimension(:,:,:), pointer :: StokesDriftSpectrumY
        real,    dimension(:,:),   pointer :: AtmToWaveMomentumU, AtmToWaveMomentumV, AtmToWaveMomentum_UV
        real,    dimension(:,:),   pointer :: WaveToOceanMomentumU, WaveToOceanMomentumV, WaveToOceanMomentum_UV
        real,    dimension(:,:),   pointer :: WaveLength

        !Altimetry Assimilation
        real,    dimension(:,:  ), pointer :: AltimWaterLevelAnalyzed   => null()

        real                               :: AltimDecayTime    = null_real, &
                                              AltimAssimDT      = null_real

        real,    dimension(:,:,:), pointer :: AltimSigmaDensAnalyzed    => null()

        logical                            :: Backtracking  = .false.


    end type T_External

    type T_Drag
        type(T_PropertyID)              :: ID
        real, dimension(:,:,:), pointer :: Coef => null()
    end type T_Drag

    type T_Scraper
        type(T_PropertyID)                  :: ID_U, ID_V, ID_W

        real,    dimension(:,:,:), pointer  :: VelU => null(), &
                                               VelV => null(), &
                                               VelW => null()

        integer, dimension(:,:,:), pointer  :: Position => null()

        logical                             :: UOn  = .false., &
                                               VOn  = .false., &
                                               WOn  = .false.

        real                                :: VelLimit     = -1e8
        real                                :: TimeScale    = null_real !initialization: Jauch
    end type T_Scraper

    type T_ThinWalls
        integer, dimension(:),     pointer  :: FaceU_I  => null(), &
                                               FaceU_J  => null(), &
                                               FaceU_K  => null(), &
                                               FaceV_I  => null(), &
                                               FaceV_J  => null(), &
                                               FaceV_K  => null(), &
                                               FaceW_I  => null(), &
                                               FaceW_J  => null(), &
                                               FaceW_K  => null()

        logical                             :: UOn  = .false., &
                                               VOn  = .false., &
                                               WOn  = .false., &
                                               ON   = .false.

        integer                             :: Nu   = null_int, &
                                               Nv   = null_int, &
                                               Nw   = null_int

        integer                             :: ObjTimeSerie     = null_int, &
                                               CloseFlagColumn  = null_int

        logical                             :: VariableInTime   = .false.

        real                                :: GradWL_Limit = null_real

                                               !CloseFlag = 1 close, CloseFlag = 0 open
        integer                             :: CloseFlag    = null_int
    end type T_ThinWalls

    type T_WindWaves
        integer                             :: CelerityType     = null_int
        real                                :: CelerityConstant = null_real
    end type T_WindWaves

    type       T_HydroCoupling
         type(T_Time)                           :: NextCompute
         real                                   :: DT_Compute   = FillValueReal
         logical                                :: Yes          = .false.
         logical                                :: flag         = .false.
    end type T_HydroCoupling

    private :: T_HydroOptions
    type       T_HydroOptions
        real(8)                         :: EnteringWaveDirection    = null_real !initialization: Jauch

        real, dimension(:,:,:), pointer :: BiHarmonicUX_VY  => null(), &
                                           BiHarmonicUY_VX  => null()

        real, dimension(:,:),   pointer :: Tlag => null()

        real                            :: BiHarmonicCoef           = null_real, &
                                           BottomViscCoef           = null_real, &
                                           UpStream_CenterDif       = null_real, &
                                           ImplicitVertAdvection    = null_real, &
                                           ImplicitVertDiffusion    = null_real, &
                                           Num_Discretization       = null_real, &
                                           MinLeavingVelocity       = null_real, &
                                           MinLeavingComponent      = null_real, &
                                           InertialPeriods          = null_real, &
                                           RampPeriod               = null_real, &
                                           TideSlowStartCoef        = null_real, &
                                           Hmin_Advection           = null_real, &
                                           !AtmosphereCoef: This is the coefficient bounded by [0 1] to multiply the atmospheric forces with.
                                           AtmosphereCoef           = null_real, &
                                           !AtmospherePeriod: This period will substitute the SmoothInitial period
                                           AtmospherePeriod         = null_real, &
                                           TwoWayWaitPeriod         = null_real, &
                                           TwoWayTimeDecay          = null_real
                                           !Calibration coefficent of the inverted barometer solution
        real                            :: InvertBaroCoef
                                           !Reference atmospheric pressure to be used in the inverted barometer solution
        real                            :: AtmSeaLevelReference

        integer                         :: UpStream                 = null_int, &
                                           Evolution                = null_int, &
                                           VelTangentialBoundary    = null_int, &
                                           VelNormalBoundary        = null_int, &
                                           BaroclinicMethod         = null_int, &
                                           TwoWayNumIgnOBCells      = null_int, &
                                           TwoWayIntMethod          = null_int, &
                                           TwoWayIWDn               = null_int

        logical                         :: Baroclinic           = .false., &
                                           BoundaryBaroclinic   = .false., &
                                           Coriolis             = .false., &
                                           Continuous           = .false., &
                                           Compute_Tide         = .false., &
                                           Imposed_BoundaryWave = .false., &
                                           WaterDischarges      = .false., &
                                           Residual             = .false., &
                                           RestartResidual      = .false., &
                                           ComputeEnteringWave  = .false., &
                                           Energy               = .false., &
                                           VolumeVariation      = .false., &
                                           HorizontalDiffusion  = .false., &
                                           HorizontalAdvection  = .false., &
                                           VerticalDiffusion    = .false., &
                                           VerticalAdvection    = .false., &
                                           BaroclinicRAMP       = .false., &
                                           NullBoundaryHorAdv   = .false., &
                                           AtmosphereRAMP       = .false., &
                                           InvertBarometer      = .false., &
                                           InvertBaromSomeBound = .false., &
                                           NullWaterLevelGradI  = .false., &
                                           NullWaterLevelGradJ  = .false., &
                                           TwoWay               = .false., &
                                           TwoWayWaterLevel     = .false.
        real, pointer, dimension(:,:)   :: InvertBarometerCells => null()

        integer                         :: Wind                 = null_int
        real                            :: SmoothInitialPeriod  = null_real

        logical                         :: AtmPressure      = .false.
        integer                         :: AtmPressureType  = null_int
                                            ! 0 - don't use atmospheric pressure
                                            ! 1 - Use atmospheric pressure
                                            ! 2 - Use Mean Sea Level Pressure (MSLP)

        logical                         :: SurfaceWaterFlux     = .false., &
                                           BottomWaterFlux      = .false., &
                                           Relaxation           = .false., &
                                           Geost_Initialization = .false., &
                                           Level_Bottom_Anomaly = .false.

        type(T_HydroCoupling)           :: AltimetryAssimilation

        logical                         :: CoriolisBoundary     = .false., &
                                           Recording            = .false., &
                                           MomentumDischarge    = .false., &
                                           UpscalingDischarge   = .false., &
                                           LocalDensity         = .false., &
                                           BlumbergKantha       = .false., &
                                           InitialElevation     = .false., &
                                           ConservativeHorDif   = .false., &
                                           BiHarmonic           = .false., &
                                           BottomVisc_LIM       = .false., &
                                           WaterLevelMaxMin     = .false., &
                                           TideStateON          = .false.

#ifdef OVERLAP
        logical                         :: Overlap  = .false.
#endif OVERLAP

        integer                         :: BarotropicRadia  = null_int, &
                                           BaroclinicRadia  = null_int, &
                                           LocalSolution    = null_int

        logical                         :: CorrectWaterLevel    = .false.
        real                            :: WaterLevelMin        = null_real, &
                                           WaterColumn2D        = null_real

        logical                         :: SlippingCondition    = .false., &
                                           WaveStress           = .false., & !Generation of currents by the waves
                                           WaveShearStress      = .false., & !Enhancement of bed shear stress by the waves
                                           Obstacle             = .false., &
                                           Scraper              = .false.

        logical                         :: Turbine              = .false.

        type (T_Time)                   :: RAMP_BeginTime

        logical                         :: CentrifugalForce = .false., &
                                           InertiaForces    = .false.

        integer                         :: AdvectionMethodH = null_int, &
                                           TVD_LimH         = null_int, &
                                           AdvectionMethodV = null_int, &
                                           TVD_LimV         = null_int

        logical                         :: Upwind2H = .false., &
                                           Upwind2V = .false.

        real                            :: VolumeRelMax = null_real

        integer                         :: BaroclinicPoliDegree         = null_int, &
                                           Vertical_AxiSymmetric_Model  = null_int

        real                            :: FlatherColdPeriod    = null_real, &
                                           FlatherColdSeaLevel  = null_real

        !PCL
        logical                         :: XZFlow   = .false.

        logical                         :: ExternalBarotropicVel2D  = .true.

        integer                         :: ReadContinuousFormat  = null_int
        integer                         :: WriteContinuousFormat = null_int
        integer                         :: ContinuousFormat      = null_int

        logical                         :: EmersionTime          = .false.

        integer                         :: WaveForcing3D
        integer                         :: WaveForcing3D_Two

        logical                         :: AssimilaOneField         = .false.
        logical                         :: GlobalOptimization       = .false.
        logical                         :: InertiaForcesOpt         = .false.
        logical                         :: VelExpForcesOpt          = .false.
        logical                         :: VerticalWaterFlowOpt     = .false.
        logical                         :: CartesianVertVelocityOpt = .false.
        logical                         :: HorizontalAdvectionOpt   = .false.
        logical                         :: VerticalAdvectionOpt     = .false.
        logical                         :: HorizontalDiffusionOpt   = .false.
        logical                         :: VerticalDiffusionOpt     = .false.
        logical                         :: MatrixesOutputOpt        = .false.

    end type T_HydroOptions


    type       T_OutPut
         type (T_Time), dimension(:), pointer     :: OutTime, &
                                                     RestartOutTime, &
                                                     SurfaceOutTime

         integer                                  :: NextOutPut             = null_int, &
                                                     Number                 = null_int, &
                                                     NextRestartOutput      = null_int, &
                                                     NextSurfaceOutput      = null_int, &
                                                     NumberSurfaceOutputs   = null_int

         logical                                  :: HDF5ON             = .false., &
                                                     HDF5_Surface_ON    = .false., &
                                                     Run_End            = .false., &
                                                     WriteRestartFile   = .false., &
                                                     TimeSerieON        = .false., &
                                                     ProfileON          = .false., &
                                                    TurbineON           = .false.

         logical                                  :: Simple             = .false.

         real,          dimension(:,:,:), pointer :: ModulusH       => null(), &
                                                     CenterU        => null(), &
                                                     CenterV        => null(), &
                                                     CenterW        => null(), &
                                                     DirectionH     => null(), &
                                                     Vorticity3D    => null(), &
                                                     CenterUaux     => null(), &
                                                     CenterVaux     => null(), &
                                                     ModulusUVaux   => null(), &
                                                     CenterWaux     => null()

         real(4),       dimension(:,:,:), pointer :: AuxReal4       => null()
         real(4),       dimension(:,:  ), pointer :: Aux2DReal4     => null()


         real,          dimension(:,:),   pointer :: Aux2D          => null(), &
                                                     WaterLevelMax  => null(), &
                                                     WaterLevelMin  => null(), &
                                                     WaterLevelDif  => null()

         logical                                  :: RestartOverwrite   = .false.
         logical                                  :: Faces              = .false.
         logical                                  :: Real4              = .true.

         real                                     :: WaterLevelUnits    = null_real
         logical                                  :: TimeSerieDischON   = .false.

         integer                                  :: DischargesNumber   = null_int

         integer, dimension(:),   pointer         :: TimeSerieDischID   => null()
         real,    dimension(:,:), pointer         :: TimeSerieDischProp => null()

         logical                                  :: FloodRisk                = .false.
         real                                     :: FloodRiskVelCoef         = null_real
         real,    dimension(:,:), pointer         :: MaxWaterColumn           => null()
         real,    dimension(:,:), pointer         :: VelocityAtMaxWaterColumn => null()
         real,    dimension(:,:), pointer         :: MaxFloodRisk             => null()
         real,    dimension(:,:), pointer         :: MaxVelocity              => null()
         real,    dimension(:,:), pointer         :: MaxWaterLevel            => null()
         real,    dimension(:,:), pointer         :: MapMax                   => null()
         real,    dimension(:,:), pointer         :: MapMin                   => null()
         character(Pathlength)                    :: FloodRiskRootPath        = null_str

         real,          dimension(:,:,:), pointer :: ModulusHglm, CenterUglm, CenterVglm, CenterWglm
         real,          dimension(:,:,:), pointer :: ModulusHstokes, CenterUstokes, CenterVstokes, CenterWstokes
         real,          dimension(:,:,:), pointer :: Wave3D_FBreakingAccelU, Wave3D_FBreakingAccelV
         real,          dimension(:,:,:), pointer :: Wave3D_FVortexAccelU, Wave3D_FVortexAccelV
         real,          dimension(:,:,:), pointer :: Wave3D_FPressureAccelU, Wave3D_FPressureAccelV

    end type T_OutPut

    type      T_OutW
        type(T_OutPutTime), dimension(:), pointer :: OutPutWindows      => null()
        type(T_Size2D    ), dimension(:), pointer :: OriginalCorners    => null()
        logical                                   :: OutPutWindowsON    = .false.
        integer                                   :: WindowsNumber      = 0
        integer,            dimension(:), pointer :: ObjHDF5            => null()
        logical                                   :: Simple             = .false.
    end type  T_OutW

    type T_Energy
        integer                         :: FileID       = null_int
        integer                         :: BufferCount  = null_int
        real(8)                         :: PotentialEnergyReference = null_real
        logical                         :: FirstTime                = .true.
        real, dimension(:), pointer     :: SecondsBuffer             => null(), &
                                           RelativeKEBuffer         => null(), &
                                           RelativePEBuffer         => null(), &
                                           KineticBuffer            => null(), &
                                           PotentialBuffer          => null(), &
                                           VorticityBuffer          => null(), &
                                           MassBuffer               => null(), &
                                           VolumeBuffer             => null(), &
                                           OpenVolumeBuffer         => null(), &
                                           WaterLevelBuffer         => null(), &
                                           BarotropicKEBuffer       => null(), &
                                           BaroclinicKEBuffer       => null(), &
                                           VelMaxBaroclinicBuffer   => null(), &
                                           VelMaxBuffer             => null()

        real, dimension(:,:,:), pointer :: CenterU  => null(), &
                                           CenterV  => null(), &
                                           CenterW  => null()

        real, dimension(:,:  ), pointer :: BarotropicU  => null(), &
                                           BarotropicV  => null()

        type (T_Size3D)                 :: Window
        type (T_Time)                   :: NextOutPut

        real                            :: DtOut = null_real
    end type T_Energy


    private :: T_Astro
    type       T_Astro
        logical                           :: Compute    = .false.

        integer                           :: ComponentsNumber = 12

        real,    pointer, dimension (:  ) :: Beta       => null(), &
                                             Amplitude  => null(), &
                                             Frequency  => null(), &
                                             Arguments  => null(), &
                                             L          => null()

        integer, pointer, dimension (:  ) :: m  => null()

        type (T_Time)                     :: TimeRef
        real                              :: Alpha      = 1.
        integer                           :: Algorithm  = null_int
    end type T_Astro

    private ::  T_Fault
    type        T_Fault
        ! Fault input method (0 - Okada 1985 Model, 1 - input grid data file)
        integer                     :: InputMethod      = null_int
        ! Filename of the input grid data file
        character(len=PathLength)   :: FileName         = null_str
        !Instance of ModuleGridData
        integer                     :: ObjGridData      = 0
        ! FOCAL DEPTH, MEASURED FROM MEAN EARTH SURFACE TO THE TOP EDGE OF FAULT PLANE
        real                        :: HH               = null_real
        ! LENGTH OF THE FAULT PLANE
        real                        :: L                = null_real
        ! WIDTH OF THE FAULT PLANE
        real                        :: W                = null_real
        ! DISLOCATION
        real                        :: D                = null_real
        ! (=THETA) STRIKE DIRECTION
        real                        :: TH               = null_real
        ! (=DELTA) DIP ANGLE
        real                        :: DL               = null_real
        ! (=LAMDA) SLIP ANGLE
        real                        :: RD               = null_real
        ! EPICENTER (LATITUDE)
        real                        :: Y0               = null_real
        ! EPICENTER (LONGITUDE)
        real                        :: X0               = null_real
        ! TIME WHEN THE RUTPURE STARTS
        type (T_Time)               :: T0
        ! By default is 1. Allow s the amplifcation of the initial condition. Relevante for sensitive analysis
        real                        :: Amplification    = null_real
    end type T_Fault

    private :: T_Tsunami
    type T_Tsunami
        logical         :: ON       = .true.
        type (T_Fault)  :: Fault
    end type T_Tsunami

    private :: T_Relaxation
    type       T_Relaxation
        logical                             :: Rox3                 = .false.
        logical                             :: HorizAdv             = .false.
        logical                             :: Coriolis             = .false.
        logical                             :: Velocity             = .false.
        logical                             :: WaterLevel           = .false.
        logical                             :: RefBoundWaterLevel   = .false.
        logical                             :: Force                = .false.
        logical                             :: Geometry             = .false.
        logical                             :: WaveStress           = .false.
        integer                             :: ReferenceVelocity    = TotalVel_
        real,   dimension(:,:,:), pointer   :: DecayTimeGeo         => null()
        logical                             :: BrFroceOnlyAssimil   = .false.
        real,   dimension(:,:  ), pointer   :: CoefWaveStress       => null()
    endtype

    private :: T_SubModel
    type       T_SubModel
        logical                              :: ON              = .false., &
                                                Set             = .false., &
                                                InterPolTime    = .false., &
                                                DeadZone        = .false., &
                                                MissingNull     = .false., &
                                                FatherHotStart  = .false.

        character (Len = PathLength)         :: DeadZoneFile    = null_str
        integer                              :: VertComunic     = null_int

        logical                              :: Extrapolate     = .false., &
                                                HotStartData    = .false.

        logical, dimension(:,:,:), pointer   :: DeadZonePoint   => null()

        real,    dimension(:,:  ), pointer   :: Z   => null()

        real,    dimension(:,:,:), pointer   :: U_New                => null(), &
                                                V_New                => null(), &
                                                UV_New               => null(), &
                                                VU_New               => null(), &
                                                U_Old                => null(), &
                                                V_Old                => null(), &
                                                UV_Old               => null(), &
                                                DUZ_Old              => null(), &
                                                DVZ_Old              => null(), &
                                                DUVZ_Old             => null(), &
                                                DUZ_New              => null(), &
                                                DVZ_New              => null()

        real(8), dimension(:,:,:), pointer   :: qX  => null(), &
                                                qY  => null(), &
                                                qXY => null(), &
                                                qYX => null()

        real, dimension(:,:,:), allocatable  :: CopyU_New
        real, dimension(:,:,:), allocatable  :: CopyV_New

        !Time Interpolation
        type(T_Time)                         :: NextTime, PreviousTime

        real,    dimension(:,:  ), pointer   :: Z_Previous  => null(), &
                                                Z_Next      => null()

        real,    dimension(:,:,:), pointer   :: U_Previous      => null(), &
                                                V_Previous      => null(), &
                                                U_Next          => null(), &
                                                V_Next          => null(), &
                                                DUZ_Previous    => null(), &
                                                DUZ_Next        => null(), &
                                                DVZ_Previous    => null(), &
                                                DVZ_Next        => null()

        ! Ang: new implementation father-son 3D
        !Father3D-Son3D connection auxiliary
        real(8), dimension(:,:,:), pointer   :: Aux_qX  => null(), &
                                                Aux_qY  => null()

        real,    dimension(:,:,:), pointer   :: Aux_DUZ => null(), &
                                                Aux_DVZ => null(), &
                                                Aux_U   => null(), &
                                                Aux_V   => null()

        logical                              :: MomentConserv   = .false.

        integer                              :: FatherKLB   = null_int, &
                                                FatherKUB   = null_int

        type(T_Time)                         :: GetFatherTime

        integer                              :: ObjBoxDif = 0
        real                                 :: WaterLevelIncrease = 0.0

    endtype

    type T_HydroStatistic
        logical                              :: ON      = .false.
        character(len=StringLength)          :: File    = null_str
        integer                              :: NProp   = 4

        integer, dimension(:), allocatable   :: PropList, &
                                                ID
    end type T_HydroStatistic

    type T_CyclicBoundary
        logical                              :: ON          = .false.
        integer                              :: Direction   = null_int
    end type T_CyclicBoundary

    type T_Emersion
        real,    dimension(:,:), pointer     :: EmersionTime  => null()
        real,    dimension(:,:), pointer     :: ImmersionTime => null()
        real                                 :: TotalSimulationTime = null_real
    end type T_Emersion

    private :: T_Hydrodynamic
    type       T_Hydrodynamic
        private
        type(T_Direction     ) :: Direction
        type(T_State         ) :: State
        integer                :: FatherInstanceID
        integer                :: InstanceID    = null_int
        character(PathLength)  :: ModelName     = null_str
        type(T_Size2D        ) :: Size2D
        type(T_Size2D        ) :: WorkSize2D
        type(T_Size3D        ) :: Size
        type(T_Size3D        ) :: WorkSize
        type(T_Files         ) :: Files
        type(T_Time          ) :: BeginTime
        type(T_Time          ) :: CurrentTime
        type(T_Time          ) :: EndTime
        type(T_Time          ) :: LastIteration
        type(T_WaterLevel    ) :: Waterlevel
        type(T_Velocity      ) :: Velocity
        type(T_Geostroph     ) :: Geostroph
        type(T_WaterFluxes   ) :: WaterFluxes
        type(T_Residual      ) :: Residual
        type(T_Forces        ) :: Forces
        type(T_HorAdvection  ) :: HorAdvection
        type(T_Coefficients  ) :: Coef
        type(T_External      ) :: External_Var
        type(T_HydroOptions  ) :: ComputeOptions
        type(T_OutPut        ) :: OutPut
        type(T_OutW          ) :: OutW
        type(T_Energy        ) :: Energy
        type(T_Astro         ) :: TidePotential
        type(T_Relaxation    ) :: Relaxation
        type(T_SubModel      ) :: SubModel
        type(T_VelBaroclinic ) :: VelBaroclinic
        type(T_HydroStatistic) :: Statistics
        type(T_HydroStatistic) :: Statistics2d
        type(T_CyclicBoundary) :: CyclicBoundary
        type(T_NonHydrostatic) :: NonHydrostatic
        type(T_Generic4D     ) :: Generic4D
        type(T_Drag          ) :: Drag
        type(T_Scraper       ) :: Scraper
        type(T_Thinwalls     ) :: Thinwalls
        type(T_WindWaves     ) :: WindWaves
        type(T_Emersion      ) :: Emersion
        type(T_DDecomp       ) :: DDecomp
        type(T_Tsunami       ) :: Tsunami

        type(T_WaveRad3D     ) :: WaveRad3D
        type(T_StokesVel     ) :: StokesVel
        type(T_WaterFluxes   ) :: StokesWaterFluxes

        type(T_WaveStress    ) :: WaveStress

        type(T_HighLowTide   ) :: HighLowTide

        logical                :: FirstIteration = .true.
#ifdef _USE_SEQASSIMILATION
        !This variable is used to retain location of original memory space for variables
        !changed in sequential data assimilation (some external memory is used ocasionally)
        type(T_StatePointer  ) :: AuxPointer
        logical                :: RunSeqAssimilation    = .false.
        logical                :: VirtualRun            = .false.
#endif _USE_SEQASSIMILATION

        !Auxiliar thomas arrays
        real(8), pointer, dimension(:) :: VECG_3D   => null(), &
                                          VECW_3D   => null(), &
                                          VECG_2D   => null(), &
                                          VECW_2D   => null()
        real, dimension(:,:,:), pointer :: FaceDensity => null()

        !Auxiliar flux properties
        real(8), pointer, dimension(:,:,:) :: Aux3DFlux => null()

        integer                            :: Docycle_method = 1

        !Instance of ModuleGridData
        integer :: ObjGridData              = 0

        !Instance of ModuleHorizontalGrid
        integer :: ObjHorizontalGrid        = 0

        !Instance of ModuleTime
        integer :: ObjTime                  = 0

        !Instance of ModuleGeometry
        integer :: ObjGeometry              = 0

        !Instance of ModuleHorizontalMap
        integer :: ObjHorizontalMap         = 0

        !Instance of ModuleMap
        integer :: ObjMap                   = 0

        !Modules construct INSIDE the hydrodynamic module

        !Instance of Module HDF5
        integer :: ObjHDF5                  = 0

        !Instance of Module HDF5 for surface outputs
        integer :: ObjSurfaceHDF5           = 0

        !Instance of Module_EnterData
        integer :: ObjEnterData             = 0

        !Instance of Module_EnterData
        integer :: ObjEnterData1            = 0

        !Instance of Module_EnterData
        integer :: ObjEnterData2            = 0

        !Instance of ModuleOpenBoundary
        integer :: ObjOpenBoundary          = 0

        !Instance of ModuleTurbulence
        integer :: ObjTurbulence            = 0

        !Instance of ModuleSurface
        integer :: ObjDischarges            = 0

        !Instance of ModuleBoxDif
        integer :: ObjBoxDif                = 0

        !Instance of ModuleTimeSerie
        integer :: ObjTimeSerie             = 0

        !!Instance of ModuleProfile
        integer :: ObjProfile               = 0

        !Instance of ModuleHydrodynamicFile (Input)
        integer :: ObjHydrodynamicFileIn    = 0

        !Instance of ModuleHydrodynamicFile (Output)
        integer :: ObjHydrodynamicFileOut   = 0

        !Instance of ModuleAssimilation
        integer :: ObjAssimilation          = 0

        !Instance of Waves
        integer :: ObjWaves                 = 0

        !Instance of TwoWay
        integer  :: ObjTwoWay               = 0

#ifdef _ENABLE_CUDA
        !Instance of CUDA
        integer :: ObjCuda                  = 0
#endif _ENABLE_CUDA

        !Instance of ModuleTurbine
        integer :: ObjTurbine               = 0
        !griflet
        integer                         :: MaxThreads   = null_int
        type(T_THOMAS), pointer         :: THOMAS   => null()
        type(T_THOMAS2D), pointer       :: THOMAS2D => null()

        type (T_Hydrodynamic), pointer :: Next

    end type T_Hydrodynamic

    !Global Module Variables
    type (T_Hydrodynamic), pointer                  :: FirstHydrodynamic    => null()
    type (T_Hydrodynamic), pointer                  :: Me                   => null()

    contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CO

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------


!BOP
!
! !ROUTINE: StartHydrodynamic

! !DESCRIPTION:
!     This routine is responsible for the initialization of the
!     hydrodynamic model: numerical options, hydrodynamic initial values, etc.

! !REVISION HISTORY:
!  1Jan2000    Paulo Chambel  First experimental version.
!  16Nov2000   Paulo Chambel  Comments are introduce in the Protex format
!                             to produce a manual
!

! !INTERFACE:

    subroutine StartHydrodynamic (ModelName,                                            &
                                  HydrodynamicID,                                       &
                                  GridDataID,                                           &
                                  HorizontalGridID,                                     &
                                  GeometryID,                                           &
                                  HorizontalMapID,                                      &
                                  MapID,                                                &
                                  AssimilationID,                                       &
                                  TimeID,                                               &
                                  TurbulenceID,                                         &
                                  DischargesID,                                         &
                                  WavesID,                                              &
                                  TwoWayID,                                             &
                                  DoCycle_method,                                       &
#ifdef _ENABLE_CUDA
                                  CudaID,                                               &
#endif _ENABLE_CUDA
                                  STAT)

!
! !INPUT PARAMETERS:

        !Arguments-------------------------------------------------------------
        character(Len=*)              :: ModelName
        integer, intent (INOUT)       :: HydrodynamicID
        integer, intent (IN)          :: GridDataID
        integer, intent (IN)          :: HorizontalGridID
        integer, intent (IN)          :: GeometryID
        integer, intent (IN)          :: HorizontalMapID
        integer, intent (IN)          :: MapID
        integer                       :: AssimilationID
        integer, intent (IN)          :: TimeID
        integer, intent (IN)          :: TurbulenceID
        integer, intent (IN)          :: WavesID
        integer                       :: DischargesID
        integer, intent (IN)          :: TwoWayID
        integer, intent (IN)          :: DoCycle_method
#ifdef _ENABLE_CUDA
        integer                       :: CudaID
#endif _ENABLE_CUDA
! !OUTPUT PARAMETERS:

        integer, optional, intent(OUT):: STAT


!EOP

        !Local-----------------------------------------------------------------

        integer :: ready_
        integer :: STAT_
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        !Assures nullification of the global variable
        if (.not. ModuleIsRegistered(mHydrodynamic_)) then
            nullify (FirstHydrodynamic)
            call RegisterModule (mHydrodynamic_)
        endif


        call Ready(HydrodynamicID, ready_)

cd0 :   if (ready_ .EQ. OFF_ERR_) then

            call AllocateInstance

            Me%ModelName = ModelName

            !Associates External Instances
            Me%ObjTime           = AssociateInstance (mTIME_,           TimeID          )
            Me%ObjGridData       = AssociateInstance (mGRIDDATA_,       GridDataID      )
            Me%ObjHorizontalGrid = AssociateInstance (mHORIZONTALGRID_, HorizontalGridID)
            Me%ObjHorizontalMap  = AssociateInstance (mHORIZONTALMAP_,  HorizontalMapID )
            Me%ObjGeometry       = AssociateInstance (mGEOMETRY_,       GeometryID      )
            Me%ObjMap            = AssociateInstance (mMAP_,            MapID           )
            Me%ObjTurbulence     = AssociateInstance (mTURBULENCE_,     TurbulenceID    )
            Me%ObjTwoWay         = AssociateInstance (mTwoWay_,         TwoWayID        )

            if(WavesID /= 0)then
                Me%ObjWaves      = AssociateInstance (mWAVES_,          WavesID)
            end if

#ifdef _ENABLE_CUDA
            Me%ObjCuda          = AssociateInstance (mCUDA_,             CudaID)
#endif _ENABLE_CUDA

            call Construct_Hydrodynamic (DischargesID,  AssimilationID)

            if (Me%ComputeOptions%Evolution == Solve_Equations_)                        &
                call CourantGH()

            call null_time   (Me%LastIteration)
            call null_time   (Me%CurrentTime)

            !Returns ID
            HydrodynamicID = Me%InstanceID

            !structure of do cycle iterations.
            Me%DoCycle_method = DoCycle_method

            STAT_ = SUCCESS_

        else cd0

            STAT_ = UNKNOWN_

        end if cd0

        if (present(STAT)) STAT = STAT_

    !----------------------------------------------------------------------

    end subroutine StartHydrodynamic

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine AllocateInstance

        !Local-----------------------------------------------------------------
        type (T_Hydrodynamic), pointer              :: NewHydrodynamic
        type (T_Hydrodynamic), pointer              :: PreviousHydrodynamic

        !Allocates new instance
        allocate (NewHydrodynamic)
        nullify  (NewHydrodynamic%Next)

        !Insert New Instance into list and makes Current point to it
        if (.not. associated(FirstHydrodynamic)) then
            FirstHydrodynamic         => NewHydrodynamic
            Me                        => NewHydrodynamic
        else
            PreviousHydrodynamic      => FirstHydrodynamic
            Me                        => FirstHydrodynamic%Next
            do while (associated(Me))
                PreviousHydrodynamic  => Me
                Me                    => Me%Next
            enddo
            Me                        => NewHydrodynamic
            PreviousHydrodynamic%Next => NewHydrodynamic
        endif

        Me%InstanceID = RegisterNewInstance (mHYDRODYNAMIC_)


    end subroutine AllocateInstance


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Construct_Hydrodynamic(DischargesID,  AssimilationID)

        !Arguments-------------------------------------------------------------
        integer             :: DischargesID
        integer             :: AssimilationID
        !Local-----------------------------------------------------------------
        integer             :: STAT_CALL, iW

        !----------------------------------------------------------------------

        Me%State%Initial = ON

        Me%FirstIteration = .true.

        call GetHorizontalGridSize(Me%ObjHorizontalGrid,                                &
                                   Size     = Me%Size2D,                                &
                                   WorkSize = Me%WorkSize2D,                            &
                                   STAT     = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Hydrodynamic - ModuleHydrodynamic - ERR00'


        call GetGeometrySize(Me%ObjGeometry,                                            &
                             Size = Me%Size, WorkSize = Me%WorkSize,                    &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Hydrodynamic - ModuleHydrodynamic - ERR01'


        call Construct_HydrodynamicTime(  )


        call Read_Hydrodynamic_Files_Name(  )


        !Construct enter data
        call ConstructEnterData(Me%ObjEnterData, Me%Files%ConstructData,                &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Construct_Hydrodynamic - ModuleHydrodynamic. ERR02.'

        call Construct_Numerical_Options

        call OperationalModelDefaultOptions

        call Verify_Numerical_Options

        call ConstructDDecomp

        call Construct_OutPutTime

        !Opens the HDF 5 file
        if (Me%OutPut%hdf5ON)          call Open_HDF5_OutPut_File

        if (Me%OutW%OutPutWindowsON)  then
            do iW = 1, Me%OutW%WindowsNumber
                call Open_HDF5_OutPut_File(iW)
            enddo
        endif

        !Opens the HDF 5 file for surface outputs
        if (Me%OutPut%HDF5_Surface_ON) call Open_Surface_HDF5_OutPut_File

        call Actualize_HydrodynamicTimeStep

        call InitialHydrodynamicField (DischargesID, AssimilationID)

        call StartOutputBoxFluxes

#ifdef OVERLAP
        call ConstructHydroOverlap
#endif OVERLAP

        !Construct the Time Serie Obj
        if (Me%OutPut%TimeSerieON) call Construct_Time_Serie

        if (Me%OutPut%TimeSerieON .or. Me%OutPut%hdf5ON .or.                            &
            Me%OutPut%ProfileON   .or. Me%OutPut%HDF5_Surface_ON.or.                    &
            Me%OutW%OutPutWindowsON) then
            call ConstructMatrixesOutput
        endif

        if (Me%OutPut%ProfileON) call Construct_Output_Profile

        if (Me%ThinWalls%ON) then
            call ConstructThinWalls
        endif

        !if (Me%ComputeOptions%ComputeEnteringWave) then
            call ConstructWindWaves
        !endif

        call ConstructTsunami

        call ConstructHighLowTideOutput        

        !call External Modules
        call ReadLock_External_Modules

        !Do the first output
        call Hydrodynamic_OutPut

        !call External Modules
        call ReadUnLock_External_Modules

        call KillEnterData(Me%ObjEnterData, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine Construct_Hydrodynamic - ModuleHydrodynamic. ERR03.'

        !To let the model take access to the Mapping and geometry variables
        call ReadLock_External_Modules

        if (Me%ComputeOptions%TwoWay) then
            if ( Me%ComputeOptions%TwoWayIntMethod == 1) then

                !Gives TwoWay module parametrizations from user Keywords
                call ConstructTwoWayHydrodynamic(TwoWayID         = Me%InstanceID,                         &
                                                 TimeDecay        = Me%ComputeOptions%TwoWayTimeDecay,     &
                                                 IntMethod        = Me%ComputeOptions%TwoWayIntMethod,     &
                                                 VelDT            = Me%Velocity%DT,                        &
                                                 DT               = Me%WaterLevel%DT,                      &
                                                 IgnoreOBNumCells = Me%ComputeOptions%TwoWayNumIgnOBCells, &
                                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine Construct_Hydrodynamic - ModuleHydrodynamic. ERR04.'
            else
                !Gives TwoWay module parametrizations from user Keywords
                call ConstructTwoWayHydrodynamic(TwoWayID         = Me%InstanceID,                         &
                                                 TimeDecay        = Me%ComputeOptions%TwoWayTimeDecay,     &
                                                 IntMethod        = Me%ComputeOptions%TwoWayIntMethod,     &
                                                 IWDn             = Me%ComputeOptions%TwoWayIWDn,          &
                                                 VelDT            = Me%Velocity%DT,                        &
                                                 DT               = Me%WaterLevel%DT,                      &
                                                 IgnoreOBNumCells = Me%ComputeOptions%TwoWayNumIgnOBCells, &
                                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine Construct_Hydrodynamic - ModuleHydrodynamic. ERR05.'
            endif

        endif

        !Call this subroutine to actualize the variabel DUZ_VY
        !Only this way the subroutine ModifyChezyVelUV nows the
        !face direction where the chezy coeficient must be compute.
        !
        call MaintainDirection

        !Initialize bottom boundary (Chezy coefficient is computed for the first time)
!        call Bottom_Boundary

        !Unget the Mapping and geometry variables
        call ReadUnLock_External_Modules

        Me%State%Initial = OFF

    End Subroutine Construct_Hydrodynamic

    !End----------------------------------------------------------------

    subroutine ConstructDDecomp

#ifdef _USE_MPI

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                 :: GILB, GIUB, GJLB, GJUB, JImin, JImax, STAT_CALL
        integer                                 :: i
        integer, dimension(:), pointer          :: Slaves_MPI_ID
        !----------------------------------------------------------------------



        call GetDDecompParameters                                           &
                             (HorizontalGridID = Me%ObjHorizontalGrid,      &
                              ON               = Me%DDecomp%ON,             &
                              Master           = Me%DDecomp%Master,         &
                              Master_MPI_ID    = Me%DDecomp%Master_MPI_ID,  &
                              MasterOrSlave    = Me%DDecomp%MasterOrSlave,  &
                              NInterfaces      = Me%DDecomp%NInterfaces,    &
                              Halo_Points      = Me%DDecomp%Halo_Points,    &
                              MPI_ID           = Me%DDecomp%MPI_ID,         &
                              Global           = Me%DDecomp%Global,         &
                              Mapping          = Me%DDecomp%Mapping,        &
                              Inner            = Me%DDecomp%Inner,          &
                              HaloMap          = Me%DDecomp%HaloMap,        &
                              STAT             = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendProperities3DMPI - ModuleHydrodynamic - ERR10'

        if (Me%DDecomp%MasterOrSlave) then

            GILB = Me%DDecomp%Global%ILB - 1
            GIUB = Me%DDecomp%Global%IUB + 1
            GJLB = Me%DDecomp%Global%JLB - 1
            GJUB = Me%DDecomp%Global%JUB + 1

            if (Me%DDecomp%Master) then


                JImin = min (GILB, GJLB)
                JImax = max (GIUB, GJUB)

                allocate (Me%DDecomp%VECG(JImin : JImax), STAT = STAT_CALL)
                allocate (Me%DDecomp%VECW(JImin : JImax), STAT = STAT_CALL)

                Me%DDecomp%VECG(:) = 0
                Me%DDecomp%VECW(:) = 0

                allocate(Me%DDecomp%Coef)

                allocate (Me%DDecomp%Coef%D    (GILB:GIUB, GJLB:GJUB))
                allocate (Me%DDecomp%Coef%E    (GILB:GIUB, GJLB:GJUB))
                allocate (Me%DDecomp%Coef%Eaux (GILB:GIUB, GJLB:GJUB))
                allocate (Me%DDecomp%Coef%F    (GILB:GIUB, GJLB:GJUB))
                allocate (Me%DDecomp%Coef%Ti   (GILB:GIUB, GJLB:GJUB))
                allocate (Me%DDecomp%Coef%TiAux(GILB:GIUB, GJLB:GJUB))

                Me%DDecomp%Coef%D    (:,:)= 0
                Me%DDecomp%Coef%E    (:,:)= 1
                Me%DDecomp%Coef%Eaux (:,:)= 1
                Me%DDecomp%Coef%F    (:,:)= 0
                Me%DDecomp%Coef%Ti   (:,:)= 0
                Me%DDecomp%Coef%TiAux(:,:)= 0

                allocate (Me%DDecomp%WaterLevel_New(GILB:GIUB, GJLB:GJUB))

                Me%DDecomp%WaterLevel_New(:,:) = 0.

                call GetDDecompSlaves(HorizontalGridID = Me%ObjHorizontalGrid,          &
                                      Nslaves          = Me%DDecomp%Nslaves,            &
                                      Slaves_MPI_ID    = Slaves_MPI_ID,                 &
                                      STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendProperities3DMPI - ModuleWaterProperties - ERR20'

                allocate(Me%DDecomp%Slaves_MPI_ID (Me%DDecomp%Nslaves))

                Me%DDecomp%Slaves_MPI_ID(:) = Slaves_MPI_ID(:)

                call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Slaves_MPI_ID, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendProperities3DMPI - ModuleWaterProperties - ERR30'

                allocate(Me%DDecomp%Slaves_Inner  (Me%DDecomp%Nslaves))
                allocate(Me%DDecomp%Slaves_Size   (Me%DDecomp%Nslaves))
                allocate(Me%DDecomp%Slaves_Mapping(Me%DDecomp%Nslaves))
                allocate(Me%DDecomp%Slaves_HaloMap(Me%DDecomp%Nslaves))

                do i=1, Me%DDecomp%Nslaves
                    call GetDDecompSlavesSize                                           &
                          (HorizontalGridID = Me%ObjHorizontalGrid,                     &
                          iSlave           = i,                                         &
                          Slaves_Inner     = Me%DDecomp%Slaves_Inner(i),                &
                          Slaves_Size      = Me%DDecomp%Slaves_Size(i),                 &
                          Slaves_Mapping   = Me%DDecomp%Slaves_Mapping(i),              &
                          Slaves_HaloMap   = Me%DDecomp%Slaves_HaloMap(i),              &
                          STAT             = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendProperities3DMPI - ModuleWaterProperties - ERR40'
                enddo

            endif

        endif

#endif _USE_MPI

    end subroutine ConstructDDecomp

    !End----------------------------------------------------------------

    Subroutine InitialHydrodynamicField(DischargesID, AssimilationID)

        !Arguments-------------------------------------------------------------

        integer             :: DischargesID
        integer             :: AssimilationID

        !Local-----------------------------------------------------------------

        integer :: OutputStateEx, STAT_CALL

        !----------------------------------------------------------------------

        if (Me%ComputeOptions%BaroclinicRadia /= NoRadiation_)              &
            call Construct_RadiaBaroclinic


        call AllocateVariables


        !This must be called before initial_geometry. Elevation is needed.
        call ConstructHydrodynamicProperties

        if (.not. Me%ComputeOptions%Continuous) then
            call ReadInitialImposedSolution

            if (Me%ComputeOptions%TideStateON) then
                call ReadInitialTideState
            endif
        endif

        !Guillaume
        if (Me%ComputeOptions%Evolution == Vertical1D_) then
            Me%WaterFluxes%X (:,:,:) = 0.
            Me%WaterFluxes%Y (:,:,:) = 0.
            Me%WaterFluxes%Z (:,:,:) = 0.
            Me%Waterlevel%New(:,:  ) = 0.
        endif

        call Generic4thDimension

        if (Me%ComputeOptions%Continuous) then
            call Initial_Geometry
        endif

        call Construct_Sub_Modules (DischargesID, AssimilationID)


        call ReadLock_ModuleMap

        call ReadLock_ModuleGeometry
        call ModifyWaterDischarges
        call ReadUnLock_ModuleGeometry

        !The subroutine StartHydrodynamicFile in RECORDING mode must be called
        !after the Initial_Geometry where the Mapping update is done because
        !to record the intial field is necessary to have have the Mapping of
        !the compute points
cd11:   if (Me%ComputeOptions%Recording) then

            call GetHydrodynamicFileIOState(OutputStateEx = OutputStateEx)
            call StartHydrodynamicFile (Me%ObjHydrodynamicFileOut,          &
                                        Me%ObjGridData,                     &
                                        Me%ObjHorizontalGrid,               &
                                        Me%ObjGeometry,                     &
                                        Me%ObjMap,                          &
                                        Me%ObjHorizontalMap,                &
                                        Me%ObjTime,                         &
                                        OutputStateEx,                      &
                                        InitialWaterLevel      =            &
                                        Me%WaterLevel%New,                  &
                                        InitialWaterFluxX      =            &
                                        Me%WaterFluxes%X,                   &
                                        InitialWaterFluxY      =            &
                                        Me%WaterFluxes%Y,                   &
                                        InitialDischarges      =            &
                                        Me%WaterFluxes%Discharges,          &
                                        InitialComputeFacesU3D =            &
                                        Me%External_Var%ComputeFaces3D_U,   &
                                        InitialComputeFacesV3D =            &
                                        Me%External_Var%ComputeFaces3D_V,   &
                                        STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine InitialHydrodynamicField - ModuleHydrodynamic. ERR01'

        endif cd11

        call ReadUnLock_ModuleMap

        !PCL - This initial field is only constructed
        !if the run is new and the user wants to imposed
        !a flow relaxation scheme OR hydrodynamic field is equal to the residual one (Evolution == Residual_hydrodynamic_)
        call InitialReferenceWaterFluxes

        !PCL - This initial field is only constructed
        !if the transisent hydrodynamic is read from a file
        call InitialHydrodynamicFileVel

        if (.not. Me%ComputeOptions%Continuous)                             &
            call NewEqualsOld


    End Subroutine InitialHydrodynamicField

    !-----------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine Generic4thDimension

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        character(len = StringLength)      :: BeginBlock, EndBlock
        character(len = PathLength)        :: Filename
        integer                            :: STAT_CALL, ClientNumber, iflag
        logical                            :: BlockFound

        !----------------------------------------------------------------------


        BeginBlock = "<begin_generic4D>"
        EndBlock   = "<end_generic4D>"

        !Searches for water level
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR10'

        if (BlockFound) then

            Me%Generic4D%ON = .true.

            call GetData(Filename, Me%ObjEnterData, iflag,                              &
                         keyword        = 'FILENAME',                                   &
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "******.***",                                 &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR20'
            if (iflag == 0) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR30'

            call GetData(Me%Generic4D%TimeSerieColumn, Me%ObjEnterData, iflag,          &
                         keyword        = 'TIME_SERIE_COLUMN',                          &
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = 2,                                            &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR40'

            !Starts Time Serie
            call StartTimeSerieInput(Me%Generic4D%ObjTimeSerie,                         &
                                     FileName,                                          &
                                     Me%ObjTime,                                        &
                                     STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Generic4thDimension - ModuleFillMatrix - ERR50'


#ifndef _WAVES_

            Me%Generic4D%CurrentValue = TimeSerieValue(Me%Generic4D%ObjTimeSerie,       &
                                                       Me%CurrentTime,                  &
                                                       Me%Generic4D%TimeSerieColumn)

            call SetGeneric4DValues(Me%ObjWaves, Me%Generic4D%CurrentValue, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'Generic4thDimension - ModuleHydrodynamic - ERR60'

#endif

        else

            Me%Generic4D%ON = .false.

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR70'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Generic4thDimension  - ModuleHydrodynamic - ERR80'


    end subroutine Generic4thDimension
   !----------------------------------------------------------------------------

    subroutine ReadInitialImposedSolution

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------

        logical                    :: RotateX, RotateY

        !Begin-----------------------------------------------------------------


            call ReadInitialImposedSolutionSSH

            call ReadInitialImposedSolutionSSH_Astro

            call Initial_Geometry

            call ReadInitialImposedSolutionVel      (RotateX, RotateY)

            call ReadInitialImposedSolutionVel_Astro(RotateX, RotateY)

            call InitialImposedSolution_RotateFlux  (RotateX, RotateY)



    end subroutine ReadInitialImposedSolution

      !----------------------------------------------------------------------------

    subroutine ReadInitialImposedSolutionSSH

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        character(len = StringLength)      :: BeginBlock, EndBlock
        integer                            :: STAT_CALL, ClientNumber, i, j
        logical                            :: BlockFound
        real                               :: MinWaterColumn
        real,    dimension(:,:),   pointer :: Bathymetry

        !Begin-----------------------------------------------------------------


        BeginBlock = "<begin_waterlevel>"
        EndBlock   = "<end_waterlevel>"

        !Searches for water level
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR10'

        Me%WaterLevel%InitalizedByFile = BlockFound

        if (BlockFound) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR20'

            call ConstructPropertyID  (Me%WaterLevel%ID, Me%ObjEnterData, FromBlock)

            call ConstructFillMatrix  (PropertyID           = Me%WaterLevel%ID,             &
                                       EnterDataID          = Me%ObjEnterData,              &
                                       TimeID               = Me%ObjTime,                   &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                       ExtractType          = FromBlock,                    &
                                       PointsToFill2D       = Me%External_Var%WaterPoints2D,&
                                       Matrix2D             = Me%WaterLevel%New,            &
                                       TypeZUV              = TypeZ_,                       &
                                       ClientID             = ClientNumber,                 &
                                       STAT                 = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR30'

            if (Me%WaterLevel%ID%SolutionFromFile .and.                                 &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Water level input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialImposedSolutionSSH - ModuleHydrodynamic - ERR40'

            endif


            Me%WaterLevel%New (:,:) = Me%WaterLevel%New (:,:) / Me%OutPut%WaterLevelUnits

            !Gets Bathymetry
            call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH - ModuleHydrodynamic - ERR50'

            call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH - ModuleHydrodynamic - ERR60'

do1:        do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
do2:        do  i=Me%WorkSize%ILB, Me%WorkSize%IUB

cd1:            if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then

                    !The water level can not be located below the bottom
cd2:                if (Me%WaterLevel%New(i, j) < (- Bathymetry(i, j) + MinWaterColumn / 2.)) then
                        Me%WaterLevel%New(i, j) = - Bathymetry(i, j) + MinWaterColumn / 2.
                    endif cd2

                endif cd1
            enddo do2
            enddo do1

            call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH - ModuleHydrodynamic - ERR70'

            if(.not. Me%WaterLevel%ID%SolutionFromFile) then

                do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
                do  i=Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then

                        Me%WaterLevel%Old(i, j) = Me%WaterLevel%New(i, j)

                    endif

                enddo
                enddo

                call KillFillMatrix(Me%WaterLevel%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR80'

            end if

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &
                                    Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR90'


        else
            if (Me%ComputeOptions%Evolution == ImposedSolution_) then
                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR100'
            endif

        endif



        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR110'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH  - ModuleHydrodynamic - ERR120'


    end subroutine ReadInitialImposedSolutionSSH

    !--------------------------------------------------------------------------

    !----------------------------------------------------------------------------

    subroutine ReadInitialImposedSolutionVel (RotateX, RotateY)

        !Arguments-------------------------------------------------------------
        logical, intent(OUT)               :: RotateX, RotateY

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Matrix3D
        integer, dimension(:,:,:), pointer :: PointsToFill3D
        integer, dimension(:,:,:), pointer :: WaterFaces3D_U, WaterFaces3D_V
        character(len = StringLength)      :: BeginBlock, EndBlock, Char_TypeZUV
        integer                            :: STAT_CALL, ClientNumber, i, j, k, iflag
        logical                            :: BlockFound

        !Begin-----------------------------------------------------------------



        !Module - ModuleMap
        !3D Mapping Properties
        call GetComputeFaces3D(Me%ObjMap,                                               &
                               ComputeFacesU3D = Me%External_Var%ComputeFaces3D_U,      &
                               ComputeFacesV3D = Me%External_Var%ComputeFaces3D_V,      &
                               STAT            = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR10'

        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR20'

        RotateX = .false.
        RotateY = .false.

        BeginBlock = "<begin_velocity_u>"
        EndBlock   = "<end_velocity_u>"

        !Searches for velocity u
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR30'

        if (BlockFound) then

            call ConstructPropertyID  (Me%Velocity%Horizontal%U%ID, Me%ObjEnterData, FromBlock)

            call GetData(Char_TypeZUV, Me%ObjEnterData, iflag,                          &
                         keyword        = 'TYPE_ZUV',                                   &
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "Z",                                          &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR40'

            Me%Velocity%Horizontal%U%InTypeZUV = TranslateTypeZUV(Char_TypeZUV)

            if      (Me%Velocity%Horizontal%U%InTypeZUV == TypeU_) then

                call GetWaterFaces3D(Me%ObjMap,                                         &
                                     WaterFacesU3D = WaterFaces3D_U,                    &
                                     WaterFacesV3D = WaterFaces3D_V,                    &
                                     STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR50'

                PointsToFill3D => WaterFaces3D_U
                Matrix3D       => Me%Velocity%Horizontal%U%New

            else if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%WaterPoints3D

                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))
                Matrix3D(:,:,:) = FillValueReal

            else if (Me%Velocity%Horizontal%U%InTypeZUV == TypeV_) then

                stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR60'

            else

                stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR70'

            endif

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Velocity%Horizontal%U%ID,      &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = PointsToFill3D,                   &
                                       Matrix3D             = Matrix3D,                         &
                                       TypeZUV              = Me%Velocity%Horizontal%U%InTypeZUV,&
                                       FillMatrix           = 0.,                               &
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR80'

            if      (Me%Velocity%Horizontal%U%InTypeZUV == TypeU_) then

                call UnGetMap(Me%ObjMap, WaterFaces3D_U, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR90'

                call UnGetMap(Me%ObjMap, WaterFaces3D_V, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR100'

            endif

            if (Me%Velocity%Horizontal%U%ID%SolutionFromFile .and.                      &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Velocity U input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialImposedSolutionVel - ModuleHydrodynamic - ERR110'

            endif

            RotateX = .true.

            if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%U%New(:,:,:) = 0.

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                    if (PointsToFill3D(i,j-1,k) == OpenPoint .and.                      &
                        PointsToFill3D(i,j  ,k) == OpenPoint) then
                        Me%Velocity%Horizontal%U%New(i,j,k) = (Matrix3D(i,j-1,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                enddo

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)

            if(.not. Me%Velocity%Horizontal%U%ID%SolutionFromFile)then

                call KillFillMatrix(Me%Velocity%Horizontal%U%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR120'
            end if

        else

            if (Me%ComputeOptions%Evolution == ImposedSolution_) then
                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR130'
            endif

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR140'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR150'



        BeginBlock = "<begin_velocity_v>"
        EndBlock   = "<end_velocity_v>"

        !Searches for velocity v
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR160'

        if (BlockFound) then

            call ConstructPropertyID  (Me%Velocity%Horizontal%V%ID, Me%ObjEnterData, FromBlock)

            call GetData(Char_TypeZUV, Me%ObjEnterData, iflag,                          &
                         keyword        = 'TYPE_ZUV',                                   &
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "Z",                                          &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR170'

            Me%Velocity%Horizontal%V%InTypeZUV = TranslateTypeZUV(Char_TypeZUV)

            if      (Me%Velocity%Horizontal%V%InTypeZUV == TypeV_) then

                call GetWaterFaces3D(Me%ObjMap,                                         &
                                     WaterFacesU3D = WaterFaces3D_U,                    &
                                     WaterFacesV3D = WaterFaces3D_V,                    &
                                     STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR180'

                PointsToFill3D => WaterFaces3D_V

                Matrix3D       => Me%Velocity%Horizontal%V%New

            else if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%WaterPoints3D

                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))
                Matrix3D(:,:,:) = FillValueReal

            else if (Me%Velocity%Horizontal%V%InTypeZUV == TypeU_) then

                stop 'ReadInitialImposedSolutionVel - ModuleHydrodynamic - ERR190'

            else

                stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR200'

            endif


            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Velocity%Horizontal%V%ID,      &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = PointsToFill3D,                   &
                                       Matrix3D             = Matrix3D,                         &
                                       TypeZUV              = Me%Velocity%Horizontal%V%InTypeZUV,&
                                       FillMatrix           = 0.,                               &
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR210'

            if      (Me%Velocity%Horizontal%V%InTypeZUV == TypeV_) then

                call UnGetMap(Me%ObjMap, WaterFaces3D_U, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR220'

                call UnGetMap(Me%ObjMap, WaterFaces3D_V, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR230'

            endif

            if (Me%Velocity%Horizontal%V%ID%SolutionFromFile .and.                      &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Velocity V input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialImposedSolutionVel - ModuleHydrodynamic - ERR240'

            endif

            RotateY = .true.

            if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%V%New(:,:,:) = 0.

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                    if (PointsToFill3D(i-1,j,k) == OpenPoint .and.                       &
                        PointsToFill3D(i  ,j,k) == OpenPoint) then
                        Me%Velocity%Horizontal%V%New(i,j,k) = (Matrix3D(i-1,j,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                enddo

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)

            if(.not. Me%Velocity%Horizontal%V%ID%SolutionFromFile)then

                call KillFillMatrix(Me%Velocity%Horizontal%V%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR250'
            end if

        else

            if (Me%ComputeOptions%Evolution == ImposedSolution_) then

                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR260'

            endif

        endif


        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR270'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel  - ModuleHydrodynamic - ERR280'

        !Module - ModuleMap
        !3D Mapping Properties
        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_U,                      &
                        STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel - ModuleHydrodynamic - ERR290'

        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_V,                      &
                        STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel - ModuleHydrodynamic - ERR300'

        call UnGetMap(Me%ObjMap, Me%External_Var%WaterPoints3D,                         &
                        STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel - ModuleHydrodynamic - ERR310'

    end subroutine ReadInitialImposedSolutionVel

    !--------------------------------------------------------------------------

    subroutine ReadInitialImposedSolutionSSH_Astro

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: Matrix2D
        character(len = StringLength)      :: BeginBlock, EndBlock
        integer                            :: STAT_CALL, ClientNumber, i, j
        logical                            :: BlockFound
        real                               :: MinWaterColumn
        real,    dimension(:,:),   pointer :: Bathymetry

        !Begin-----------------------------------------------------------------

        allocate (Matrix2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

        !Gets WaterPoints2D
        call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
            stop 'ReadInitialImposedSolutionSSH_Astro  - ModuleHydrodynamic - ERR10'


        BeginBlock = "<begin_waterlevel_astro>"
        EndBlock   = "<end_waterlevel_astro>"

        !Searches for water level
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro  - ModuleHydrodynamic - ERR20'

        if (BlockFound .and. Me%WaterLevel%InitalizedByFile) then

            Matrix2D(:,:) = 0.

            call ConstructPropertyID  (Me%WaterLevel%ID_Astro, Me%ObjEnterData, FromBlock)

            call ConstructFillMatrix  (PropertyID           = Me%WaterLevel%ID_Astro,       &
                                       EnterDataID          = Me%ObjEnterData,              &
                                       TimeID               = Me%ObjTime,                   &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                       ExtractType          = FromBlock,                    &
                                       PointsToFill2D       = Me%External_Var%WaterPoints2D,&
                                       Matrix2D             = Matrix2D,                     &
                                       TypeZUV              = TypeZ_,                       &
                                       ClientID             = ClientNumber,                 &
                                       STAT                 = STAT_CALL)



            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolution_Astro  - ModuleHydrodynamic - ERR30'

            if (Me%WaterLevel%ID_Astro%SolutionFromFile .and.                                 &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Water level input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialImposedSolution_Astro - ModuleHydrodynamic - ERR40'

            endif


            Matrix2D (:,:) = Matrix2D (:,:) / Me%OutPut%WaterLevelUnits

do1:        do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
do2:        do  i=Me%WorkSize%ILB, Me%WorkSize%IUB

cd1:            if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    Me%WaterLevel%New(i, j) = Me%WaterLevel%New(i, j) + Matrix2D(i, j)
                endif cd1

            enddo do2
            enddo do1

            !Gets Bathymetry
            call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro - ModuleHydrodynamic - ERR50'

            call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro - ModuleHydrodynamic - ER680'

do21:       do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
do22:       do  i=Me%WorkSize%ILB, Me%WorkSize%IUB

cd11:           if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then

                    !The water level can not be located below the bottom
cd21:               if (Me%WaterLevel%New(i, j) < (- Bathymetry(i, j) + MinWaterColumn / 2.)) then
                        Me%WaterLevel%New(i, j) = - Bathymetry(i, j) + MinWaterColumn / 2.
                    endif cd21

                endif cd11
            enddo do22
            enddo do21

            call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro - ModuleHydrodynamic - ERR70'

            if(.not. Me%WaterLevel%ID_Astro%SolutionFromFile) then

                do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
                do  i=Me%WorkSize%ILB, Me%WorkSize%IUB

                    if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then

                        Me%WaterLevel%Old(i, j) = Me%WaterLevel%New(i, j)

                    endif

                enddo
                enddo

                call KillFillMatrix(Me%WaterLevel%ID_Astro%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro  - ModuleHydrodynamic - ERR80'

            end if


        endif



        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro  - ModuleHydrodynamic - ERR90'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionSSH_Astro  - ModuleHydrodynamic - ERR100'


        !UnGets WaterPoints2D
        call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
            stop 'ReadInitialImposedSolutionSSH_Astro  - ModuleHydrodynamic - ERR110'

    end subroutine ReadInitialImposedSolutionSSH_Astro

    !----------------------------------------------------------------------------


    subroutine ReadInitialImposedSolutionVel_Astro(RotateX, RotateY)

        !Arguments-------------------------------------------------------------
        logical, intent(IN)                :: RotateX, RotateY

        !Local-----------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: Matrix2D
        character(len = StringLength)      :: BeginBlock, EndBlock, Char_TypeZUV
        integer                            :: STAT_CALL, ClientNumber, i, j, k, iflag
        logical                            :: BlockFound

        !Begin-----------------------------------------------------------------


        !Gets WaterPoints2D
        call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
            stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR10'


        !Module - ModuleMap
        !3D Mapping Properties
        call GetComputeFaces3D(Me%ObjMap,                                               &
                               ComputeFacesU3D = Me%External_Var%ComputeFaces3D_U,      &
                               ComputeFacesV3D = Me%External_Var%ComputeFaces3D_V,      &
                               STAT            = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR20'


        BeginBlock = "<begin_velocity_u_astro>"
        EndBlock   = "<end_velocity_u_astro>"

        !Searches for velocity u
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR30'

        if (BlockFound .and. RotateX) then

            call ConstructPropertyID  (Me%Velocity%Horizontal%U%ID_Astro, Me%ObjEnterData, FromBlock)

            call GetData(Char_TypeZUV, Me%ObjEnterData, iflag,                          &
                         keyword        = 'TYPE_ZUV',                                   &
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "Z",                                          &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR40'


            if (Me%Velocity%Horizontal%U%InTypeZUV /= TypeZ_) then

                stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR50'
            endif

            allocate (Matrix2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

            Matrix2D(:,:) = 0.

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Velocity%Horizontal%U%ID_Astro,&
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill2D       = Me%External_Var%WaterPoints2D,    &
                                       Matrix2D             = Matrix2D,                         &
                                       TypeZUV              = Me%Velocity%Horizontal%U%InTypeZUV,&
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR60'



            if (Me%Velocity%Horizontal%U%ID_Astro%SolutionFromFile .and.                      &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Velocity U input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialImposedSolutionVel_Astro - ModuleHydrodynamic - ERR70'

            endif

            do k = Me%WorkSize%KLB,Me%WorkSize%KUB
            do j = Me%WorkSize%JLB,Me%WorkSize%JUB
            do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                if (Me%External_Var%ComputeFaces3D_U(i,j-1,k) == OpenPoint .and.        &
                    Me%External_Var%ComputeFaces3D_U(i,j  ,k) == OpenPoint) then
                    Me%Velocity%Horizontal%U%New(i,j,k) =                               &
                            Me%Velocity%Horizontal%U%New(i,j,k) + (Matrix2D(i,j-1) + Matrix2D(i,j)) / 2.
                endif

            enddo
            enddo
            enddo

            deallocate (Matrix2D)

            if(.not. Me%Velocity%Horizontal%U%ID_Astro%SolutionFromFile)then

                call KillFillMatrix(Me%Velocity%Horizontal%U%ID_Astro%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR80'
            end if

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR90'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR100'



        BeginBlock = "<begin_velocity_v_astro>"
        EndBlock   = "<end_velocity_v_astro>"

        !Searches for velocity v
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR110'

        if (BlockFound .and. RotateY) then

            call ConstructPropertyID  (Me%Velocity%Horizontal%V%ID_Astro, Me%ObjEnterData, FromBlock)

            call GetData(Char_TypeZUV, Me%ObjEnterData, iflag,                          &
                         keyword        = 'TYPE_ZUV',                                   &
                         SearchType     = FromBlock,                                    &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         default        = "Z",                                          &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR120'

            Me%Velocity%Horizontal%V%InTypeZUV = TranslateTypeZUV(Char_TypeZUV)

            if (Me%Velocity%Horizontal%V%InTypeZUV /= TypeZ_) then

                stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR130'
            endif

            allocate (Matrix2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

            Matrix2D(:,:) = 0.

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Velocity%Horizontal%V%ID_Astro,&
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill2D       = Me%External_Var%WaterPoints2D,    &
                                       Matrix2D             = Matrix2D,                         &
                                       TypeZUV              = Me%Velocity%Horizontal%V%InTypeZUV,&
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR140'

            if (Me%Velocity%Horizontal%V%ID_Astro%SolutionFromFile .and.                &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Velocity V input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialImposedSolutionVel_Astro - ModuleHydrodynamic - ERR160'

            endif

            do k = Me%WorkSize%KLB,Me%WorkSize%KUB
            do j = Me%WorkSize%JLB,Me%WorkSize%JUB
            do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                if (Me%External_Var%ComputeFaces3D_V(i-1,j,k) == OpenPoint .and.      &
                    Me%External_Var%ComputeFaces3D_V(i  ,j,k) == OpenPoint) then
                    Me%Velocity%Horizontal%V%New(i,j,k) =                               &
                            Me%Velocity%Horizontal%V%New(i,j,k) + (Matrix2D(i-1,j) + Matrix2D(i,j)) / 2.
                endif

            enddo
            enddo
            enddo

            deallocate (Matrix2D)

            if(.not. Me%Velocity%Horizontal%V%ID_Astro%SolutionFromFile)then

                call KillFillMatrix(Me%Velocity%Horizontal%V%ID_Astro%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR170'
            end if


        endif


        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR180'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR190'

        !UnGets WaterPoints2D
        call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
            stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR200'

        !Module - ModuleMap
        !3D Mapping Properties
        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_U,                      &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR210'

        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_V,                      &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialImposedSolutionVel_Astro  - ModuleHydrodynamic - ERR220'


    end subroutine ReadInitialImposedSolutionVel_Astro

    !--------------------------------------------------------------------------

    subroutine InitialImposedSolution_RotateFlux (RotateX, RotateY)

        !Arguments-------------------------------------------------------------
        logical, intent(IN)                :: RotateX, RotateY


        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL, i, j, k

        !Begin-----------------------------------------------------------------


        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'InitialImposedSolution_RotateFlux - ModuleHydrodynamic - ERR10'

        !Module - ModuleMap
        !3D Mapping Properties
        call GetComputeFaces3D(Me%ObjMap,                                               &
                               ComputeFacesU3D = Me%External_Var%ComputeFaces3D_U,      &
                               ComputeFacesV3D = Me%External_Var%ComputeFaces3D_V,      &
                               STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'InitialImposedSolution_RotateFlux - ModuleHydrodynamic - ERR20'

        call RotateVectorFieldToGrid(HorizontalGridID  = Me%ObjHorizontalGrid,           &
                                     VectorInX         = Me%Velocity%Horizontal%U%New,   &
                                     VectorInY         = Me%Velocity%Horizontal%V%New,   &
                                     VectorOutX        = Me%Velocity%Horizontal%U%New,   &
                                     VectorOutY        = Me%Velocity%Horizontal%V%New,   &
                                     WaterPoints3D     = Me%External_Var%WaterPoints3D,  &
                                     RotateX           = RotateX,                        &
                                     RotateY           = RotateY,                        &
                                     KLB               = Me%WorkSize%KLB,                &
                                     KUB               = Me%WorkSize%KUB,                &
                                     STAT              = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)  Stop 'InitialImposedSolution_RotateFlux - ModuleHydrodynamic - ERR30'


        call GetGeometryAreas(Me%ObjGeometry,                                           &
                              AreaU = Me%External_Var%Area_U,                           &
                              AreaV = Me%External_Var%Area_V,                           &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'InitialImposedSolution_RotateFlux  - ModuleHydrodynamic - ERR40'

dok1:   do k = Me%WorkSize%KLB,Me%WorkSize%KUB
doj1:   do j = Me%WorkSize%JLB,Me%WorkSize%JUB
doi1:   do i = Me%WorkSize%ILB,Me%WorkSize%IUB

Cov1:       if (Me%External_Var%ComputeFaces3D_U(I, J, K) == Covered) then

                Me%WaterFluxes%X(i, j, k) = dble(Me%Velocity%Horizontal%U%New(i,j,k)) * &
                                            dble(Me%External_Var%Area_U      (i,j,k))
            endif Cov1

        enddo doi1
        enddo doj1
        enddo dok1


dok2:   do k = Me%WorkSize%KLB,Me%WorkSize%KUB
doj2:   do j = Me%WorkSize%JLB,Me%WorkSize%JUB
doi2:   do i = Me%WorkSize%ILB,Me%WorkSize%IUB

Cov2:       if ( Me%External_Var%ComputeFaces3D_V(I, J, K) == Covered) then

                    Me%WaterFluxes%Y(i, j, k) = dble(Me%Velocity%Horizontal%V%New(i,j,k)) * &
                                                dble(Me%External_Var%Area_V      (i,j,k))
            endif Cov2

        enddo doi2
        enddo doj2
        enddo dok2

        !Module - ModuleMap
        !3D Mapping Properties
        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_U,                      &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'InitialImposedSolution_RotateFlux  - ModuleHydrodynamic - ERR50'

        call UnGetMap(Me%ObjMap, Me%External_Var%ComputeFaces3D_V,                      &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'InitialImposedSolution_RotateFlux  - ModuleHydrodynamic - ERR60'

        call UnGetMap(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'InitialImposedSolution_RotateFlux  - ModuleHydrodynamic - ERR70'

        call UnGetGeometry(Me%ObjGeometry, Me%External_Var%Area_U, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'InitialImposedSolution_RotateFlux  - ModuleHydrodynamic - ERR80'

        call UnGetGeometry(Me%ObjGeometry, Me%External_Var%Area_V, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'InitialImposedSolution_RotateFlux  - ModuleHydrodynamic - ERR90'

    end subroutine InitialImposedSolution_RotateFlux

    !----------------------------------------------------------------------------

    subroutine ReadInitialTideState

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        character(len = StringLength)      :: BeginBlock, EndBlock
        integer                            :: STAT_CALL, ClientNumber
        logical                            :: BlockFound

        !----------------------------------------------------------------------


        BeginBlock = "<begin_tidestate>"
        EndBlock   = "<end_tidestate>"

        !Searches for water level
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                     BeginBlock, EndBlock,                              &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR10'



        if (BlockFound) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR20'

            call ConstructPropertyID  (Me%WaterLevel%TideStateID, Me%ObjEnterData, FromBlock)

            call ConstructFillMatrix  (PropertyID           = Me%WaterLevel%TideStateID,    &
                                       EnterDataID          = Me%ObjEnterData,              &
                                       TimeID               = Me%ObjTime,                   &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                       ExtractType          = FromBlock,                    &
                                       PointsToFill2D       = Me%External_Var%WaterPoints2D,&
                                       Matrix2D             = Me%WaterLevel%TideState,      &
                                       TypeZUV              = TypeZ_,                       &
                                       ClientID             = ClientNumber,                 &
                                       STAT                 = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR30'

            if (Me%WaterLevel%TideStateID%SolutionFromFile .and.                                 &
                Me%ComputeOptions%Evolution /= ImposedSolution_) then

                write(*,*) "Tide State input field can not change in time"
                write(*,*) "must be FILE_IN_TIME : None"
                stop 'ReadInitialTideState - ModuleHydrodynamic - ERR65'

            endif


            if(.not. Me%WaterLevel%TideStateID%SolutionFromFile) then

                call KillFillMatrix(Me%WaterLevel%TideStateID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR70'

            end if

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &
                                    Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR80'


        else
            if (Me%ComputeOptions%Evolution == ImposedSolution_) then
                write(*,*) 'Block not found'
                write(*,*) 'Begin = ',trim(BeginBlock)
                write(*,*) 'End   = ',trim(EndBlock)
                stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR90'
            endif

        endif



        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR100'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadInitialTideState  - ModuleHydrodynamic - ERR110'



    end subroutine ReadInitialTideState

    !--------------------------------------------------------------------------

    subroutine ConstructDragCoefficients

        !Local-----------------------------------------------------------------
        character(len = StringLength)           :: BeginBlock, EndBlock
        integer                                 :: STAT_CALL, ClientNumber
        logical                                 :: BlockFound

        !----------------------------------------------------------------------

        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'StartOutputBoxFluxes - ModuleHydrodynamic - ERR01'

        BeginBlock = "<begin_dragcoef>"
        EndBlock   = "<end_dragcoef>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR01'

        if (BlockFound) then

            call ConstructPropertyID  (Me%Drag%ID, Me%ObjEnterData, FromBlock)

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Drag%ID,                       &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = Me%External_Var%WaterPoints3D,    &
                                       Matrix3D             = Me%Drag%Coef,                     &
                                       TypeZUV              = TypeZ_,                           &
                                       FillMatrix           = 0.,                               &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR08'

            if(.not. Me%Drag%ID%SolutionFromFile)then

                call KillFillMatrix(Me%Drag%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR10'
            end if

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)
            stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR11'

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR12'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR13'

        call UnGetMap (Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructDragCoefficients - ModuleHydrodynamic - ERR14'


    end subroutine ConstructDragCoefficients

    !-----------------------------------------------------------------------------------

    subroutine ConstructScraper

        !Local-----------------------------------------------------------------
        character(len = StringLength)           :: BeginBlock, EndBlock
        integer                                 :: STAT_CALL, ClientNumber
        logical                                 :: BlockFound

        !----------------------------------------------------------------------


        Me%Scraper%UOn            = .false.
        Me%Scraper%VOn            = .false.
        Me%Scraper%WOn            = .false.

        !call GetData

        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR10'

        BeginBlock = "<begin_scraper_u>"
        EndBlock   = "<end_scraper_u>"

        allocate(Me%Scraper%Position(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, Me%Size%KLB:Me%Size%KUB))

        Me%Scraper%Position(:,:,:) = Me%External_Var%WaterPoints3D(:,:,:)

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR20'

        if (BlockFound) then

            Me%Scraper%UOn            = .true.

            call ConstructPropertyID  (Me%Scraper%ID_U, Me%ObjEnterData, FromBlock)

            allocate(Me%Scraper%VelU(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, Me%Size%KLB:Me%Size%KUB))

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Scraper%ID_U,                  &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = Me%External_Var%WaterPoints3D,    &
                                       Matrix3D             = Me%Scraper%VelU,                  &
                                       TypeZUV              = TypeU_,                           &
                                       FillMatrix           = FillValueReal,                    &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR30'

            if(.not. Me%Scraper%ID_U%SolutionFromFile)then

                call KillFillMatrix(Me%Scraper%ID_U%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR40'
            end if

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)
            stop 'ConstructScraper - ModuleHydrodynamic - ERR50'

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR60'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR70'


        BeginBlock = "<begin_scraper_v>"
        EndBlock   = "<end_scraper_v>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR80'

        if (BlockFound) then

            Me%Scraper%VOn            = .true.

            call ConstructPropertyID  (Me%Scraper%ID_V, Me%ObjEnterData, FromBlock)

            allocate(Me%Scraper%VelV(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, Me%Size%KLB:Me%Size%KUB))

            !Uncovered cells are set to zero
            call ConstructFillMatrix  (PropertyID           = Me%Scraper%ID_V,                  &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       GeometryID           = Me%ObjGeometry,                   &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill3D       = Me%External_Var%WaterPoints3D,    &
                                       Matrix3D             = Me%Scraper%VelV,                  &
                                       TypeZUV              = TypeV_,                           &
                                       FillMatrix           = FillValueReal,                    &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR90'

            if(.not. Me%Scraper%ID_V%SolutionFromFile)then

                call KillFillMatrix(Me%Scraper%ID_V%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR100'
            end if

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)
            stop 'ConstructScraper - ModuleHydrodynamic - ERR110'

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR120'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR130'

        call UnGetMap (Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructScraper - ModuleHydrodynamic - ERR140'


    end subroutine ConstructScraper

    !-----------------------------------------------------------------------------------

    subroutine ConstructThinWalls

        !Local-----------------------------------------------------------------
        integer, dimension(3)                   :: Cell
        character(len = PathLength  )           :: TimeSerieFile
        character(len = StringLength)           :: BeginBlock, EndBlock
        integer                                 :: STAT_CALL, ClientNumber
        integer                                 :: FirstLine, LastLine, n, l, iflag
        logical                                 :: BlockFound
        type(T_Time)                            :: Time1, Time2
        real                                    :: Value1, Value2
        logical                                 :: TimeCycle

        !----------------------------------------------------------------------

        Me%ThinWalls%UOn = .false.
        Me%ThinWalls%Nu  = FillValueInt

        Me%ThinWalls%VOn = .false.
        Me%ThinWalls%Nv  = FillValueInt

        Me%ThinWalls%WOn = .false.
        Me%ThinWalls%Nw  = FillValueInt

        BeginBlock = "<begin_thinwalls_u>"
        EndBlock   = "<end_thinwalls_u>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, FirstLine, LastLine, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR10'

        if (BlockFound) then

            Me%ThinWalls%UOn = .true.

            Me%ThinWalls%Nu  = LastLine - FirstLine - 1

            allocate(Me%ThinWalls%FaceU_I(Me%ThinWalls%Nu))
            allocate(Me%ThinWalls%FaceU_J(Me%ThinWalls%Nu))
            allocate(Me%ThinWalls%FaceU_K(Me%ThinWalls%Nu))

d1:         do l = FirstLine+1, LastLine-1

                call GetData(Cell, Me%ObjEnterData, iflag, Buffer_Line  = l, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR20'
                endif

                if (iflag /= 3) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR30'
                endif

                n = l - FirstLine

                Me%ThinWalls%FaceU_I(n) = cell(1)
                Me%ThinWalls%FaceU_J(n) = cell(2)
                Me%ThinWalls%FaceU_K(n) = cell(3)

            enddo d1

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR40'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR50'


        BeginBlock = "<begin_thinwalls_v>"
        EndBlock   = "<end_thinwalls_v>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, FirstLine, LastLine, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR60'

        if (BlockFound) then

            Me%ThinWalls%VOn = .true.

            Me%ThinWalls%Nv  = LastLine - FirstLine - 1

            allocate(Me%ThinWalls%FaceV_I(Me%ThinWalls%Nv))
            allocate(Me%ThinWalls%FaceV_J(Me%ThinWalls%Nv))
            allocate(Me%ThinWalls%FaceV_K(Me%ThinWalls%Nv))

d2:         do l = FirstLine+1, LastLine-1

                call GetData(Cell, Me%ObjEnterData, iflag, Buffer_Line  = l, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR70'
                endif

                if (iflag /= 3) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR80'
                endif

                n = l - FirstLine

                Me%ThinWalls%FaceV_I(n) = cell(1)
                Me%ThinWalls%FaceV_J(n) = cell(2)
                Me%ThinWalls%FaceV_K(n) = cell(3)

            enddo d2

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR90'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR100'


        BeginBlock = "<begin_thinwalls_w>"
        EndBlock   = "<end_thinwalls_w>"

        !Searches for drag coefficients block
        call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                             &
                                     BeginBlock, EndBlock,                                      &
                                     BlockFound, FirstLine, LastLine, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR110'

        if (BlockFound) then

            Me%ThinWalls%WOn = .true.

            Me%ThinWalls%Nw  = LastLine - FirstLine - 1

            allocate(Me%ThinWalls%FaceW_I(Me%ThinWalls%Nw))
            allocate(Me%ThinWalls%FaceW_J(Me%ThinWalls%Nw))
            allocate(Me%ThinWalls%FaceW_K(Me%ThinWalls%Nw))

d3:         do l = FirstLine+1, LastLine-1

                call GetData(Cell, Me%ObjEnterData, iflag, Buffer_Line  = l, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR120'
                endif

                if (iflag /= 3) then
                    stop 'ConstructThinWalls - ModuleHydrodynamic - ERR130'
                endif

                n = l - FirstLine

                Me%ThinWalls%FaceW_I(n) = cell(1)
                Me%ThinWalls%FaceW_J(n) = cell(2)
                Me%ThinWalls%FaceW_K(n) = cell(3)

            enddo d3

        else

            write(*,*) 'Block not found'
            write(*,*) 'Begin = ',trim(BeginBlock)
            write(*,*) 'End   = ',trim(EndBlock)

        endif

        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR140'

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR150'

        call GetData(Me%ThinWalls%VariableInTime,                                       &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'THIN_WALLS_VARIABLE',                                &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR160'

        if (Me%ThinWalls%VariableInTime) then

            call GetData(TimeSerieFile,                                                 &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword    = 'THIN_WALLS_TIME_SERIE',                          &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR170'


            !Starts Time Serie
            call StartTimeSerieInput(Me%ThinWalls%ObjTimeSerie,                         &
                                     TimeSerieFile,                                     &
                                     Me%ObjTime,                                        &
                                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR180'

            call GetData(Me%ThinWalls%GradWL_Limit,                                     &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword    = 'WATER_LEVEL_GRAD_LIMIT',                         &
                         !units = water level gradient [m/m]
                         Default    = 0.001,                                            &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR190'


            allocate(Me%Forces%ThinWalls_Dissipation(Me%Size%ILB:Me%Size%IUB,           &
                                          Me%Size%JLB:Me%Size%JUB,                      &
                                          Me%Size%KLB:Me%Size%KUB))

            Me%Forces%ThinWalls_Dissipation(:,:,:) = 0.

            call GetData(Me%ThinWalls%CloseFlagColumn,                                  &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword    = 'TIME_FLAG_COLUMN',                               &
                         Default    = 2,                                                &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR200'


            !Gets Value for current Time
            call GetTimeSerieValue (Me%ThinWalls%ObjTimeSerie, Me%CurrentTime,          &
                                    Me%ThinWalls%CloseFlagColumn,                       &
                                    Time1, Value1, Time2, Value2, TimeCycle,            &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR210'

            if (Value1 == 1. .and. Value2 == 1) then
                Me%ThinWalls%CloseFlag = 1
            else
                Me%ThinWalls%CloseFlag = 0
            endif

        else

            Me%ThinWalls%CloseFlag = 1

        endif




    end subroutine ConstructThinWalls

    !--------------------------------------------------------------------------

    subroutine ConstructWindWaves

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL, iflag

        !----------------------------------------------------------------------

        call GetData(Me%WindWaves%CelerityType,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'WIND_WAVES_CELERITY_TYPE',                           &
                     Default    = LongWaves_,                                           &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructWindWaves - ModuleHydrodynamic - ERR10'

        if (Me%WindWaves%CelerityType == Constant_) then

            call GetData(Me%WindWaves%CelerityConstant,                                 &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword    = 'CELERITY_CONSTANT',                              &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructWindWaves - ModuleHydrodynamic - ERR20'

            if (iflag == 0) then
                write(*,*) 'The user needs to specify the keyword CELERITY_CONSTANT'
                stop 'ConstructWindWaves - ModuleHydrodynamic - ERR30'
            endif

        endif

    end subroutine ConstructWindWaves


    !--------------------------------------------------------------------------

    subroutine ConstructTsunami

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL, iflag

        !----------------------------------------------------------------------

        call GetData(Me%Tsunami%ON,                                                     &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'TSUNAMI',                                        &
                     Default        = .false.,                                          &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleHydrodynamic',                             &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR10'

i1:     if (Me%Tsunami%ON) then

            ! TIME WHEN THE RUTPURE STARTS [YYYY MM DD HH MM SS]
            call GetData(Me%Tsunami%Fault%T0,                                           &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'FAULT_RUTPURE_START_TIME',                   &
                         default        = Me%BeginTime,                                 &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR20'


            ! Fault input method (0 - Okada 1985 Model, 1 - input grid data file)
            call GetData(Me%Tsunami%Fault%InputMethod,                                  &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'FAULT_INPUT_METHOD',                         &
                         default        = FaultOkada1985_,                              &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR30'

            if (Me%Tsunami%Fault%InputMethod /= FaultFile_ .and.                        &
                Me%Tsunami%Fault%InputMethod /= FaultOkada1985_) then
                stop 'ConstructTsunami - ModuleHydrodynamic - ERR40'
            endif

            !  AMPLIFICATION OF THE TSUNAMI
            call GetData(Me%Tsunami%Fault%Amplification,                            &
                            Me%ObjEnterData, iflag,                                    &
                            Keyword        = 'FAULT_AMPLIFICATION',                    &
                            SearchType     = FromFile,                                 &
                            ClientModule   = 'ModuleHydrodynamic',                     &
                            default        = 1.,                                       &
                            STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR245'

i3:         if      (Me%Tsunami%Fault%InputMethod == FaultFile_     ) then

                ! Fault filemane of the input grid data file
                call GetData(Me%Tsunami%Fault%FileName,                                 &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_FILENAME',                         &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR50'

                if (iflag == 0) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR60'
                endif

                call ConstructGridData(GridDataID       = Me%Tsunami%Fault%ObjGridData, &
                                       HorizontalGridID = Me%ObjHorizontalGrid,         &
                                       FileName         = Me%Tsunami%Fault%FileName,    &
                                       DefaultValue     = 0.,                           &
                                       STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR70'


            elseif  (Me%Tsunami%Fault%InputMethod == FaultOkada1985_) then i3

                ! FOCAL DEPTH, MEASURED FROM MEAN EARTH SURFACE TO THE TOP EDGE OF FAULT PLANE [m]
                call GetData(Me%Tsunami%Fault%HH,                                       &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_FOCAL_DEPTH',                      &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR80'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR90'
                endif

                ! LENGTH OF THE FAULT PLANE [m]
                call GetData(Me%Tsunami%Fault%L,                                        &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_LENGTH',                           &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR100'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR110'
                endif

                ! WIDTH OF THE FAULT PLANE [m]
                call GetData(Me%Tsunami%Fault%W,                                        &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_WIDTH',                            &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR120'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR130'
                endif

                ! DISLOCATION [m]
                call GetData(Me%Tsunami%Fault%D,                                        &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_DISLOCATION',                      &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR50'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR140'
                endif

                ! (=THETA) STRIKE DIRECTION []
                call GetData(Me%Tsunami%Fault%TH,                                       &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_STRIKE_DIRECTION',                 &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR150'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR160'
                endif

                ! (=DELTA) DIP ANGLE []
                call GetData(Me%Tsunami%Fault%DL,                                       &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_DIP_ANGLE',                        &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR170'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR180'
                endif

                !  (=LAMDA) SLIP ANGLE []
                call GetData(Me%Tsunami%Fault%RD,                                       &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_SLIP_ANGLE',                       &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR190'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR200'
                endif

                !  EPICENTER (LATITUDE)[]
                call GetData(Me%Tsunami%Fault%Y0,                                       &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_EPICENTER_Y',                      &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR210'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR220'
                endif

                !  EPICENTER (LONGITUDE)[]
                call GetData(Me%Tsunami%Fault%X0,                                       &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'FAULT_EPICENTER_X',                      &
                             SearchType     = FromFile,                                 &
                             ClientModule   = 'ModuleHydrodynamic',                     &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami - ModuleHydrodynamic - ERR230'

                if (iflag /= 1) then
                    stop 'ConstructTsunami - ModuleHydrodynamic - ERR240'
                endif

            endif i3

        endif i1


i2:     if (Me%Tsunami%ON) then
            if (Me%Tsunami%Fault%T0 <= Me%BeginTime) then

                call GetOpenPoints3D(Me%ObjMap, Me%External_Var%OpenPoints3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami  - ModuleHydrodynamic - ERR250'

                call GetGridLatitudeLongitude(Me%ObjHorizontalGrid,                     &
                                              GridLatitude  = Me%External_Var%LatitudeZ,&
                                              GridLongitude = Me%External_Var%LongitudeZ,&
                                              STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR260.'

                call WaterLevel_Tsunami

                Me%Tsunami%ON = .false.

                call UnGetMap(Me%ObjMap, Me%External_Var%OpenPoints3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTsunami  - ModuleHydrodynamic - ERR270'

                call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                          &
                                         Me%External_Var%LatitudeZ,                     &
                                         STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'Subroutine ConstructTsunami - ModuleHydrodynamic. ERR280.'

                call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                          &
                                         Me%External_Var%LongitudeZ,                    &
                                         STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'Subroutine ConstructTsunami - ModuleHydrodynamic. ERR290.'

            endif
        endif i2


    end subroutine ConstructTsunami

    !--------------------------------------------------------------------------

    subroutine ConstructHighLowTideOutput

        !Local-----------------------------------------------------------------
        real,       dimension(:,:), pointer     :: Bathymetry
        integer,    dimension(:,:), pointer     :: WaterPoints2D
        type (T_Time)                           :: Time1, Time2
        real                                    :: Value1, Value2
        integer                                 :: STAT_CALL, iflag, HDF5_CREATE
        logical                                 :: TimeCycle
        integer                                 :: ILB, IUB, JLB, JUB
        integer                                 :: FileNameLength
        character(len=5)                        :: Extension        

        !----------------------------------------------------------------------    
        
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB        
        
        call GetData(Me%HighLowTide%ON,                                                 &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'HIGH_LOW_TIDE_OUTPUT',                           &
                     Default        = .false.,                                          &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleHydrodynamic',                             &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR10'

i1:     if (Me%HighLowTide%ON) then        
            
             call GetData(Me%HighLowTide%FileRefGauge,                                  &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'REFERENCE_GAUGE_FILENAME',                   &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR40'
            if (iflag     == 0       ) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR50'  
            
             call GetData(Me%HighLowTide%DataColumn,                                    &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'REFERENCE_GAUGE_DATA_COLUMN',                &
                         SearchType     = FromFile,                                     &
                         Default        = 2,                                            &   
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR60'

             call GetData(Me%HighLowTide%BackwardDT,                                    &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'REFERENCE_GAUGE_BACKWARD_DT',                &
                         !-3h to reference gauge  
                         Default        = 10800.,                                       &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR70'

             call GetData(Me%HighLowTide%ForwardDT,                                     &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'REFERENCE_GAUGE_FORWARD_DT',                 &
                         !+3h to reference gauge  
                         Default        = 10800.,                                       &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleHydrodynamic',                         &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR80'   
            
            FileNameLength              = len_trim(Me%Files%OutPutFields) + 1
            Extension                   = trim(Me%Files%OutPutFields(FileNameLength-4:FileNameLength))
            Extension(5:5)              = "5"
            Me%HighLowTide%FilenameOut  = Me%Files%OutPutFields(1:FileNameLength-5)//"_HighLowTide"//trim(Extension)            
            
            
            !Gets File Access Code
            call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

            Me%HighLowTide%ObjHDF5 = 0            
            
            !Opens HDF File
            call ConstructHDF5 (HDF5ID     = Me%HighLowTide%ObjHDF5,                    &
                                FileName   = trim(Me%HighLowTide%FilenameOut),          &
                                Access     = HDF5_CREATE,                               &        
                                STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR90'     


            !Write the Horizontal Grid
            call WriteHorizontalGrid(HorizontalGridID   = Me%ObjHorizontalGrid,         &
                                     ObjHDF5            = Me%HighLowTide%ObjHDF5,       &
                                     WorkSize           = Me%WorkSize2D,                &
                                     STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR100'
            
            !Gets a pointer to Bathymetry
            call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR110'

            !Gets WaterPoints2D
            call GetWaterPoints2D   (Me%ObjMap, WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR120'


            !Sets limits for next write operations
            call HDF5SetLimits   (Me%HighLowTide%ObjHDF5, ILB, IUB, JLB, JUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR130'


            !Writes the Grid
            call HDF5WriteData   (Me%HighLowTide%ObjHDF5, "/Grid", "Bathymetry", "m",   &
                                  Array2D = Bathymetry,                                 &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR140'

            call HDF5WriteData   (Me%HighLowTide%ObjHDF5, "/Grid", "WaterPoints2D", "-",&
                                  Array2D = WaterPoints2D,                              &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR150'


            !Writes everything to disk
            call HDF5FlushMemory (Me%HighLowTide%ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR160'


            !Ungets the Bathymetry
            call UngetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR170'

            !Ungets the WaterPoints
            call UnGetHorizontalMap (Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR180'

            
            Me%HighLowTide%ObjTimeSerieRef = 0
                                                                                                                    
            call StartTimeSerieInput(TimeSerieID        = Me%HighLowTide%ObjTimeSerieRef,   &
                                     TimeSerieDataFile  = trim(Me%HighLowTide%FileRefGauge),&
                                     STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR190'
            
            call GetTimeSerieValue(TimeSerieID      = Me%HighLowTide%ObjTimeSerieRef,   &
                                   CurrentTime      = Me%CurrentTime,                   &        
                                   DataColumn       = Me%HighLowTide%DataColumn,        &
                                   Time1            = Time1,                            &
                                   Value1           = Value1,                           &
                                   Time2            = Time2,                            &
                                   Value2           = Value2,                           &
                                   TimeCycle        = TimeCycle,                        &    
                                   STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHighLowTideOutput - ModuleHydrodynamic - ERR200'
            
            Me%HighLowTide%RefGaugeTime = Time2
            
            if   (Value2 > Value1)    then
                Me%HighLowTide%HighTide = .true.
            else 
                Me%HighLowTide%HighTide = .false.
            endif
            
            
            Me%HighLowTide%StartWindow = Me%HighLowTide%RefGaugeTime - Me%HighLowTide%BackwardDT
            Me%HighLowTide%EndWindow   = Me%HighLowTide%RefGaugeTime + Me%HighLowTide%ForwardDT              
            
            Me%HighLowTide%NextOuput = 1

            allocate(Me%HighLowTide%SeaLevel(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))
            allocate(Me%HighLowTide%Instant (Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))
            
            if  (Me%HighLowTide%HighTide)    then                
                Me%HighLowTide%SeaLevel(:, :) =  FillValueReal
            else
                Me%HighLowTide%SeaLevel(:, :) = -FillValueReal
            endif

            Me%HighLowTide%Instant (:, :) = FillValueReal            
            
        endif i1

    end subroutine ConstructHighLowTideOutput        

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : ASCII data                                                                   !
    ! OutPut: Time                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Construct_HydrodynamicTime

        !Arguments-----------------------------------------------------------------


        !Local---------------------------------------------------------------------
        type (T_Time)   :: CurrentTime, EndTime, BeginTime
        integer         :: STAT_CALL

        !Begin---------------------------------------------------------------------

        call GetComputeCurrentTime(Me%ObjTime, CurrentTime, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Construct_HydrodynamicTime - ModuleHydrodynamic - ERR10'


        call GetComputeTimeLimits(Me%ObjTime, BeginTime = BeginTime, &
                                  EndTime = EndTime, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Construct_HydrodynamicTime - ModuleHydrodynamic - ERR20'


        Me%BeginTime   = BeginTime

        Me%CurrentTime = CurrentTime

        Me%EndTime     = EndTime


        ! Check if the simulation goes backward in time or forward in time (default mode)
        call GetBackTracking(Me%ObjTime, Me%External_Var%BackTracking, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Construct_HydrodynamicTime - ModuleHydrodynamic - ERR20'


    End Subroutine Construct_HydrodynamicTime

    !End-----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : ASCII data                                                                   !
    ! OutPut: Time                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Actualize_HydrodynamicTimeStep

        !Arguments-----------------------------------------------------------------




        !Local---------------------------------------------------------------------
        real            :: DT_Model
        integer         :: Num_Discretization, STAT_CALL, Evolution
        real            :: TimePeriod, DT_RunPeriod

        !Begin---------------------------------------------------------------------
        call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            stop 'Sub. Actualize_HydrodynamicTime - ModuleHydrodynamic - Error01'

        Evolution = Me%ComputeOptions%Evolution

cd1:    if (Evolution == Solve_Equations_) then

            ! Calculate the Atmospheric RAMP coef
            ! Coef(x) = ( Tanh ( ( 2 x / T - 1 ) * Pi ) + 1 ) / 2
            ! A funcao Coef(x) no intervalo [0 infinity[ vale Coef(0) = 0, Coef(T) = 1
            ! e Coef ( infinity ) = 1. E uma funcao tangente hiperbolica re-escalada.
            !
            if (Me%ComputeOptions%AtmosphereRAMP) then

                TimePeriod = Me%ComputeOptions%AtmospherePeriod

                DT_RunPeriod = Me%CurrentTime - Me%BeginTime

                TimePeriod = 2 * DT_RunPeriod / TimePeriod - 1

                TimePeriod = TimePeriod * Pi

                Me%ComputeOptions%AtmosphereCoef = 0.5 * ( tanh( TimePeriod ) + 1 )

            endif

            Num_Discretization      = Me%ComputeOptions%Num_Discretization

            if (Num_Discretization == Leendertse) then

                Me%Velocity%DT = DT_Model ! 6 equations - velocities compute every DT

            else if (Num_Discretization == Abbott) then

                Me%Velocity%DT = 2 * DT_Model    ! 4 equations - velocities compute every 2 * DT

            endif

            Me%WaterLevel%DT = DT_Model          ! In both numerical discretizations elevations are compute every DT

        else

            Me%WaterLevel%DT = DT_Model

            Me%Velocity%DT   = DT_Model

        endif cd1

    End Subroutine Actualize_HydrodynamicTimeStep

    !End-----------------------------------------------------------------------

    !--------------------------------------------------------------------------
    !Read the name of the files need to construct and modify
    ! the hydrodynamic properties

    subroutine Read_Hydrodynamic_Files_Name

        !Arguments-------------------------------------------------------------




        !External--------------------------------------------------------------

        integer :: STAT_CALL

        character(len = StringLength) :: Message, AuxChar
        character(len = PathLength)   :: RootPath

        logical :: exist

        !----------------------------------------------------------------------


        ! ---> ASCII file used to construct a new hydrodynamic
        Message   ='ASCII file used to construct a new hydrodynamic.'
        Message   = trim(Message)

        call ReadFileName('IN_DAD3D', Me%Files%ConstructData, &
                           Message = Message, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR02.'


        inquire(FILE   = Me%Files%ConstructData,                   &
                EXIST  = exist,                                                 &
                IOSTAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                            &
            stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR02a.'
        if (.NOT. exist)                                                        &
            stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR02b.'



        ! ---> File in HDF format where is written instant fields of hydrodynamic properties
        Message   ='Instant fields of hydrodynamic properties in HDF format.'
        Message   = trim(Message)

        call ReadFileName('OUT_DESF', Me%Files%OutPutFields,                            &
                           Message   = Message, TIME_END = Me%EndTime,                  &
                           Extension = 'hyt',                                           &
                           MPI_ID    = GetDDecompMPI_ID(Me%ObjHorizontalGrid),          &
                           DD_ON     = GetDDecompON    (Me%ObjHorizontalGrid),          &
                           STAT      = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR03.'



        ! ---> hydrodynamic properties final values in HDF format
        Message   ='Hydrodynamic properties final values in HDF format.'
        Message   = trim(Message)

        call ReadFileName('OUT_FIN', Me%Files%FinalHydrodynamic,                        &
                           Message   = Message, TIME_END = Me%EndTime,                  &
                           Extension = 'hyf',                                           &
                           MPI_ID    = GetDDecompMPI_ID(Me%ObjHorizontalGrid),          &
                           DD_ON     = GetDDecompON    (Me%ObjHorizontalGrid),          &
                           STAT      = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR04.'



        ! ---> Hydrodynamic properties initial values in HDF format
        Message   ='Hydrodynamic properties initial values in HDF format.'
        Message   = trim(Message)
        call ReadFileName('IN_CNDI', Me%Files%InitialHydrodynamic,                      &
                           Message   = Message, TIME_END = Me%BeginTime,                &
                           STAT      = STAT_CALL)

cd1 :   if      (STAT_CALL .EQ. FILE_NOT_FOUND_ERR_   ) then

            stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR06'

        else if (STAT_CALL .EQ. KEYWORD_NOT_FOUND_ERR_) then


!This message just confuses the user.
!
!            write(*,*)
!            write(*,*) 'Keyword for the inicial file not found in nomfich.dat. '
!            write(*,*) 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. WRN01'
!            write(*,*)

            call SetError(WARNING_, KEYWORD_, 'Keyword IN_CNDI not found - ModuleHydrodynamic', &
                          Screen = .false.)

        else if (STAT_CALL .EQ. SUCCESS_              ) then

            continue

        else

            write(*,*)
            write(*,*) 'Error calling ReadFileName. '
            stop       'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR05.'
        end if cd1

        ! ---> File where to store the energy evolution of the system
        Message   ='System Energy result file'
        Message   = trim(Message)



        call ReadFileName("ROOT_SRT", RootPath, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            call ReadFileName("ROOT", RootPath, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call ReadFileName("RAIZ", RootPath, STAT = STAT_CALL)
                stop 'Subroutine Read_Hydrodynamic_Files_Name - ModuleHydrodynamic. ERR06.'
            endif
        endif

        Me%Files%Energy = trim(adjustl(RootPath))//"TotalEnergy.dat"

        if (GetDDecompON    (Me%ObjHorizontalGrid)) then
            write(AuxChar,fmt='(i5)') GetDDecompMPI_ID(Me%ObjHorizontalGrid)
            Auxchar = "_"//trim(adjustl(Auxchar))//".MPI"
            Me%Files%Energy = trim(Me%Files%Energy) // Auxchar
        endif


        !----------------------------------------------------------------------

    end subroutine Read_Hydrodynamic_Files_Name

    !End--------------------------------------------------------------------------

    Subroutine Construct_Numerical_Options

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type(T_PropertyID) :: GenericID

        integer :: FromFile
        integer :: STAT_CALL, iflag, BarotropicRadia, SIMPLE_GEOG, GEOG, ICOORD_TIP

        logical :: Baroclinic, Continuous_Compute, Compute_Tide,                         &
                   WaterDischarges, Residual,                                            &
                   Coriolis,                                                             &
                   BoundaryBaroclinic, Energy, VolumeVariation,                          &
                   HorizontalAdvection, HorizontalDiffusion,                             &
                   BaroclinicRamp, VerticalAdvection,                                    &
                   VerticalDiffusion, NullBoundaryHorAdv,                                &
                   ComputeTidePotential,                                                 &
                   ComputeAtmPressure, ComputeSurfaceWaterFlux,                          &
                   Relaxation, Geost_Initialization,                                     &
                   InitialElevation, AtmosphereRAMP, Level_Bottom_Anomaly,               &
                   DefaultAux
        integer :: ComputeAtmPressureType

        real    :: UpStream_CenterDif
        real    :: ImplicitVertAdvection
        real    :: ImplicitVertDiffusion
        real    :: Num_Discretization
        real    :: MinLeavingVelocity, MinLeavingComponent
        real    :: InitialElevationValue, InitialVelocityU, InitialVelocityV
        real(8) :: EnteringWaveDirection

        real    :: Hmin_Chezy, Vmin_Chezy, Hmin_Advection

        real    :: InertialPeriods, AtmospherePeriod

        real    :: TideSlowStartCoef, SmoothInitialPeriod, DT_Model

        integer :: VelTangentialBoundary, VelNormalBoundary, ComputeWind

        integer :: ClientNumber, WorkKUB, AuxInt, DefaultFormat

        character(LEN = StringLength)  :: BeginBlock, EndBlock, String

        logical :: BlockFound

        !Begin-----------------------------------------------------------------


        call GetExtractType(FromFile = FromFile)

        WorkKUB = Me%WorkSize%KUB

        !<BeginKeyword>
            !Keyword          : BAROCLINIC
            !<BeginDescription>
               !
               ! Checks if the user pretends to compute the baroclinic pressure
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Baroclinic,                                                        &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'BAROCLINIC',                                         &
                     Default    = .false.,                                              &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR10')


        Me%ComputeOptions%Baroclinic = Baroclinic

        !<BeginKeyword>
            !Keyword          : CONTINUOUS
            !<BeginDescription>
               !
               ! Checks if the user pretends to continue a old run
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Continuous_Compute,                                                &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'CONTINUOUS',                                         &
                     Default    = .false.,                                              &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR20.')

        Me%ComputeOptions%Continuous = Continuous_Compute

#ifdef _USE_MPI

        DefaultFormat = HDF5_
#else

        DefaultFormat = Binary_

#endif

        !<BeginKeyword>
            !Keyword          : READ_CONTINUOUS_FORMAT
            !<BeginDescription>
               !
               ! Checks what format the user wants to use in reading hotstart files
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : HDF5_
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%ComputeOptions%ReadContinuousFormat,                            &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'READ_CONTINUOUS_FORMAT',                             &
                     Default    = HDF5_,                                                &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR23.')

        !<BeginKeyword>
            !Keyword          : WRITE_CONTINUOUS_FORMAT
            !<BeginDescription>
               !
               ! Checks what format the user wants to use in writting hotstart files
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : HDF5_
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%ComputeOptions%WriteContinuousFormat,                           &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'WRITE_CONTINUOUS_FORMAT',                            &
                     Default    = HDF5_,                                                &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR24.')


        !<BeginKeyword>
            !Keyword          : CONTINUOUS_FORMAT
            !<BeginDescription>
               !
               ! Checks what format the user wants to use in the hotstart
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : HDF5_
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%ComputeOptions%ContinuousFormat,                                &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'CONTINUOUS_FORMAT',                                  &
                     Default    = HDF5_,                                                &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR25.')

        if (iflag == 1) then
            Me%ComputeOptions%ReadContinuousFormat  = Me%ComputeOptions%ContinuousFormat
            Me%ComputeOptions%WriteContinuousFormat = Me%ComputeOptions%ContinuousFormat
        endif

        if (Me%ComputeOptions%ReadContinuousFormat /= Binary_ .and.                     &
            Me%ComputeOptions%ReadContinuousFormat /= HDF5_) then
            stop 'Construct_Numerical_Options - Hydrodynamic - ERR27.'
        endif

        if (Me%ComputeOptions%WriteContinuousFormat /= Binary_ .and.                     &
            Me%ComputeOptions%WriteContinuousFormat /= HDF5_) then
            stop 'Construct_Numerical_Options - Hydrodynamic - ERR28.'
        endif


        !<BeginKeyword>
            !Keyword          : TIDE
            !<BeginDescription>
               !
               ! Checks if the user pretends to impose a wave tide in the open boundary
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Compute_Tide,                                                      &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'TIDE',                                               &
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR30.')


        Me%ComputeOptions%Compute_Tide = Compute_Tide


        !<BeginKeyword>
            !Keyword          : ENTERING_WAVE
            !<BeginDescription>
               !
               ! Checks if the wave imposed in the boundary is entering in the domain or leaving it
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Me%ComputeOptions%ComputeEnteringWave,                             &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'ENTERING_WAVE',                                      &
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR40.')


        if (Compute_tide) Me%ComputeOptions%ComputeEnteringWave = .true.

        !<BeginKeyword>
            !Keyword          : RADIATION
            !<BeginDescription>
               !
               ! Checks if the user wants to imposed the Flather 1974 radiation boundary condition
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>


        call GetData(BarotropicRadia,                                                   &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'RADIATION',                                          &
                     default    = NoRadiation_,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR50.')


        Me%ComputeOptions%BarotropicRadia = BarotropicRadia




        if (BarotropicRadia == NoRadiation_) then

            Me%ComputeOptions%Imposed_BoundaryWave = .true.

        else

            Me%ComputeOptions%Imposed_BoundaryWave = .false.

        endif

ifRadia: if (BarotropicRadia == FlatherWindWave_) then

            !<BeginKeyword>
                !Keyword          : WAVE_DIRECTION
                !<BeginDescription>
                   !
                   ! The user with this keyword give a direction to a wave entering the domain
                   !
                !<EndDescription>
                !Type             : Real
                !Units            : Degrees
                !Default          : 0.
                !File keyword     : IN_DAD3D
                !Multiple Options : Do Not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(EnteringWaveDirection,                                         &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'WAVE_DIRECTION',                                 &
                         default    = dble(0.),                                         &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR60.')


            Me%ComputeOptions%EnteringWaveDirection =  (270 - EnteringWaveDirection) * Pi / 180.


        endif IfRadia

ifFla: if (BarotropicRadia == FlatherWindWave_ .or. BarotropicRadia == FlatherLocalSolution_) then


            !<BeginKeyword>
                !Keyword          : MIN_VELOCITY
                !<BeginDescription>
                   !
                   ! The minimum velocity in the open boundary below which the radiation is canceled
                   !
                !<EndDescription>
                !Type             : Real
                !Units            : m/s
                !Default          : 1e-6
                !File keyword     : IN_DAD3D
                !Multiple Options : Do Not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(MinLeavingVelocity,                                            &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'MIN_VELOCITY',                                   &
                         default    = 1e-6,                                             &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR70.' )





            Me%ComputeOptions%MinLeavingVelocity = MinLeavingVelocity


            !<BeginKeyword>
                !Keyword          : MIN_COMPONENT
                !<BeginDescription>
                   !
                   ! The minimum component of the radiative wave below which
                   ! the radiation process is canceled
                   !
                !<EndDescription>
                !Type             : Real
                !Units            : m/m
                !Default          : 1e-3
                !File keyword     : IN_DAD3D
                !Multiple Options : Do Not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(MinLeavingComponent,                                           &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'MIN_COMPONENT',                                  &
                         default    = 1e-3,                                             &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR80.')

            Me%ComputeOptions%MinLeavingComponent = MinLeavingComponent


        endif ifFla

        !<BeginKeyword>
            !Keyword          : WATER_DISCHARGES
            !<BeginDescription>
               !
               ! Check if the user want to water discharges
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(WaterDischarges,                                                   &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'WATER_DISCHARGES',                                   &
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic -ERR90.')

        Me%ComputeOptions%WaterDischarges = WaterDischarges

        !<BeginKeyword>
            !Keyword          : TIME_SERIE_DISCHARGE
            !<BeginDescription>
               !
               !Checks out if the user pretends to write a time serie with the discharge flows
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>

        if (Me%ComputeOptions%WaterDischarges) then

            call GetData(Me%Output%TimeSerieDischON,                              &
                         Me%ObjEnterData, iflag,                                  &
                         keyword    = 'TIME_SERIE_DISCHARGES',                    &
                         Default    = .false.,                                    &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR92.')

        endif


        !<BeginKeyword>
            !Keyword          : RESIDUAL
            !<BeginDescription>
               !
               ! Check if the user want to compute the residual flow
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Residual,                                                          &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'RESIDUAL',                                            &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR96.')

        Me%ComputeOptions%Residual = Residual

        call GetData(Me%ComputeOptions%RestartResidual,                                 &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'RESTART_RESIDUAL',                                   &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR97')

        !<BeginKeyword>
            !Keyword          : ENERGY
            !<BeginDescription>
               !
               ! Check if the user want to compute the potential and kinetic energy of the entire domain
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Energy,                                                             &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'ENERGY',                                              &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR100.')

        Me%ComputeOptions%Energy = Energy



        !<BeginKeyword>
            !Keyword          : UP_CENTER
            !<BeginDescription>
               !
               ! Check if the horizontal advection discretization
               ! is upstream or center differences
               ! By default advection is computed using a Upstream scheme
               !
            !<EndDescription>
            !Type             : Real (0,1)
            !Default          : 1
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (Center Difference), 1 (Upstream), >0 and <1 (hybrid)
            !Search Type      : From File
        !<EndKeyword>

        call GetData( UpStream_CenterDif,                                                &
                      Me%ObjEnterData, iflag,                               &
                      keyword    = 'UP_CENTER',                                          &
                      default    =  1.,                                                  &
                      SearchType =  FromFile,                                            &
                      ClientModule ='ModuleHydrodynamic',                                 &
                      STAT       =  STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic -ERR16.' )


        Me%ComputeOptions%UpStream_CenterDif = UpStream_CenterDif


        !<BeginKeyword>
            !Keyword          : IMPLICIT_VERTADVECTION
            !<BeginDescription>
               !
               ! Check if the vertical advection is implicit
               !
            !<EndDescription>
            !Type             : Real (0,1)
            !Default          : 1
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (explicit), 1 (implicit), >0 and <1 (hybrid)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(ImplicitVertAdvection,                                              &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'IMPLICIT_VERTADVECTION',                              &
                    !By default vertical advection is implicit
                     default    = 1.,                                                    &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR110.')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(ImplicitVertAdvection,                                          &
                         Me%ObjEnterData, iflag,                            &
                         keyword    = 'IMPLICIT_VERTCONVECTION',                         &
                        !By default vertical advection is implicit
                         default    = 1.,                                                &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR120.')


            if (iflag == 1)                                                              &
                call SetError (WARNING_, KEYWORD_,                                       &
                               'Change keyword IMPLICIT_VERTCONVECTION to IMPLICIT_VERTADVECTION; ModuleHydrodynamics')



        endif



        Me%ComputeOptions%ImplicitVertAdvection = ImplicitVertAdvection


        !<BeginKeyword>
            !Keyword          : IMPLICIT_VERTDIFFUSION
            !<BeginDescription>
               !
               ! Check if the vertical advection is implicit
               !
            !<EndDescription>
            !Type             : Real (0,1)
            !Default          : 1
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (explicit), 1 (implicit), >0 and <1 (hybrid)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ImplicitVertDiffusion,                                   &
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'IMPLICIT_VERTDIFFUSION',                   &
                    !By default vertical diffusion is computed implicit
                     Default    = 1.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR130.')

        Me%ComputeOptions%ImplicitVertDiffusion = ImplicitVertDiffusion

        !<BeginKeyword>
            !Keyword          : DISCRETIZATION
            !<BeginDescription>
               !
               ! Check what type of implicit discretization in time
               ! is choose for the global equations
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : 2
            !File keyword     : IN_DAD3D
            !Multiple Options : 2 (Leendertse Scheme - 6 equations per iteration), 1 (Abbott Scheme - 4 equations per iteration)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Num_Discretization,                    &
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'DISCRETIZATION',                           &
                    !By default is use the Leendertse Scheme (6 equations per iteration)
                     Default    = Leendertse,                                 &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR140.')


        Me%ComputeOptions%Num_Discretization = Num_Discretization

        !<BeginKeyword>
            !Keyword          : UPSTREAM
            !<BeginDescription>
               !
               ! Check what type of upstream scheme is used in the horizontal advection
               !
            !<EndDescription>
            !Type             : Character
            !Default          : Upwind
            !File keyword     : IN_DAD3D
            !Multiple Options : Upwind , Quick
            !Search Type      : From File
        !<EndKeyword>

        call GetData(string,                                                    &
                     Me%ObjEnterData,                              &
                     iflag,                                                     &
                     SearchType   = FromFile,                                   &
                     keyword      ='UPSTREAM',                                  &
                     ClientModule ='ModuleHydrodynamic',                        &
                     default      = Char_Upwind_Scheme,                         &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                              &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR150.')

        String = trim(adjustl(String))
case2 : select case(String)
            case(Char_Upwind_Scheme)

                Me%ComputeOptions%UpStream = Upwind_Scheme

                Me%HorAdvection%Coef1_Up =  0.0
                Me%HorAdvection%Coef2_Up =  1.0
                Me%HorAdvection%Coef3_Up =  0.0

            case(Char_Quick_Scheme )

                Me%ComputeOptions%UpStream = Quick_Scheme

                Me%HorAdvection%Coef1_Up = -1.0 / 8.0
                Me%HorAdvection%Coef2_Up =  6.0 / 8.0
                Me%HorAdvection%Coef3_Up =  3.0 / 8.0

            case default

                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR160.')
        end select case2


        !<BeginKeyword>
            !Keyword          : TIME_SERIE
            !<BeginDescription>
               !
               !Checks out if the user pretends to write a time serie
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Me%Output%TimeSerieON,                                   &
                     Me%ObjEnterData, iflag,                                  &
                     keyword    = 'TIME_SERIE',                               &
                     Default    = .false.,                                    &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR170.')


        !<BeginKeyword>
            !Keyword          : OUTPUT_PROFILE
            !<BeginDescription>
               !
               !Checks out if the user pretends to write a profile output
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Me%OutPut%ProfileON,                                     &
                     Me%ObjEnterData, iflag,                                  &
                     keyword    = 'OUTPUT_PROFILE',                           &
                     Default    = .false.,                                    &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR180.')



        !<BeginKeyword>
            !Keyword          : OUTPUT_WATER_LEVEL_UNITS
            !<BeginDescription>
               !
               !Checks the type of units for the water level output
               !
            !<EndDescription>
            !Type             : integer
            !Default          : meters_
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(AuxInt,                                                            &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'OUTPUT_WATER_LEVEL_UNITS',                           &
                     Default    = meters_,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR190.')

        if (AuxInt /= meters_ .and. AuxInt /= centimeters_)                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR200.')

        if      (AuxInt == meters_      ) then

            Me%OutPut%WaterLevelUnits = 1.

        else if (AuxInt ==  centimeters_) then

            Me%OutPut%WaterLevelUnits = 100.

        endif

        !<BeginKeyword>
            !Keyword          : OUTPUT_FLOOD_RISK
            !<BeginDescription>
               !
               !Checks if outputs related with flood risk are to be made
               !
            !<EndDescription>
            !Type             : integer
            !Default          : meters_
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Me%Output%FloodRisk,                                               &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'OUTPUT_FLOOD_RISK',                                  &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR205.')

        if(Me%Output%FloodRisk .and. Me%WorkSize%KUB > 1)then
            write(*,*)"OUTPUT_FLOOD_RISK is only available for depth integrated simulations (KUB = 1)"
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR206.')
        endif

        if(Me%Output%FloodRisk)then
            call ReadFileName("ROOT_SRT", Me%Output%FloodRiskRootPath, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR207.')

            !<BeginKeyword>
                !Keyword          : FLOOD_RISK_VEL_COEF
                !<BeginDescription>
                   !
                   !flood risk velocity coeficient
                   !
                !<EndDescription>
                !Type             : real
                !Default          : 0.5
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not Have
                !Search Type      : From File
            !<EndKeyword>
            call GetData(Me%Output%FloodRiskVelCoef,                                   &
                            Me%ObjEnterData, iflag,                                    &
                            keyword      = 'FLOOD_RISK_VEL_COEF',                      &
                            default      = 0.5,                                        &
                            SearchType   = FromFile,                                   &
                            ClientModule = 'ModuleHydrodynamic',                       &
                            STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options - Hydrodynamic - ERR208'

        endif



        !<BeginKeyword>
            !Keyword          : EVOLUTION
            !<BeginDescription>
               !
               !Checks out if the user pretends to actualize the hydrodynamic
               !properties computing the equations or reading them from a file
               !there is also the possibility of read the residual flow of the
               !last run and maintain the instant properties equal to the residual ones
               !The user can also say that the hydrodynamic properties have always null value
               !
            !<EndDescription>
            !Type             : Character
            !Default          : Solve_Equations
            !File keyword     : IN_DAD3D
            !Multiple Options : Solve_Equations, Read_File, No_hydrodynamic, Residual_hydrodynamic
            !Search Type      : From File
        !<EndKeyword>

        call GetData(string,                                                    &
                     Me%ObjEnterData,                                           &
                     iflag,                                                     &
                     SearchType   = FromFile,                                   &
                     keyword      ='EVOLUTION',                                 &
                     ClientModule ='ModuleHydrodynamic',                        &
                     !By default the model solve the momentum equations and the continuity equation
                     default      = Char_Solve_Equations,                       &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                              &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR210.')


        String = trim(adjustl(String))
case1 : select case(String)
            case(Char_Solve_Equations      )

                Me%ComputeOptions%Evolution = Solve_Equations_

            case(Char_Read_File            )

                Me%ComputeOptions%Evolution = Read_File_

            case(Char_No_hydrodynamic      )

                Me%ComputeOptions%Evolution = No_hydrodynamic_

            case(Char_Residual_hydrodynamic)

                Me%ComputeOptions%Evolution = Residual_hydrodynamic_

            case(Char_Run_Off              )

                Me%ComputeOptions%Evolution = Run_Off_

            case(Char_ImposedSolution      )

                Me%ComputeOptions%Evolution = ImposedSolution_

            case(Char_Vertical1D           )

                Me%ComputeOptions%Evolution = Vertical1D_

            case(Char_Harmonics            )

                Me%ComputeOptions%Evolution = Harmonics_
                Me%ComputeOptions%Compute_Tide = .true.

            case default

                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR220.')

        end select case1




        !<BeginKeyword>
            !Keyword          : CORIOLIS
            !<BeginDescription>
               !
               !Checks  if the user pretends to compute the coriolis force effect
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (compute coriolis) , .false.  (do not compute coriolis)
            !Search Type      : From File
        !<EndKeyword>
        call GetData(Coriolis,                                                &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'CORIOLIS',                                 &
                    !By default the model compute always the coriolis force
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR230.')


        Me%ComputeOptions%Coriolis = Coriolis

        !<BeginKeyword>
            !Keyword          : VOLUMEVARIATION
            !<BeginDescription>
               !
               !Checks  if the user pretends to compute the volume variation effect
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true.  , .false.
            !Search Type      : From File
        !<EndKeyword>

        call GetData(VolumeVariation,                                         &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'VOLUMEVARIATION',                          &
                    !By default the model compute always the volume variation effect
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR240.')

        Me%ComputeOptions%VolumeVariation = VolumeVariation



        !<BeginKeyword>
            !Keyword          : HORIZONTALADVECTION
            !<BeginDescription>
               !
               !Checks  if the user pretends to compute the horizontal advection effect
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true.  , .false.
            !Search Type      : From File
        !<EndKeyword>

        call GetData(HorizontalAdvection,                                                &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'HORIZONTALADVECTION',                                 &
                     !By default compute always the Horizontal Advection
                     Default    = .True.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR250.')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(HorizontalAdvection,                                            &
                         Me%ObjEnterData, iflag,                                         &
                         Keyword    = 'HORIZONTALCONVECTION',                            &
                         !By default compute always the Horizontal Advection
                         Default    = .True.,                                            &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR260.')



            if (iflag == 1)then
                call SetError (WARNING_, KEYWORD_,                                       &
                     'Change keyword HORIZONTALCONVECTION to HORIZONTALADVECTION; ModuleHydrodynamics')
            end if


        endif



        Me%ComputeOptions%HorizontalAdvection = HorizontalAdvection

        !<BeginKeyword>
            !Keyword          : HORIZONTALDIFFUSION
            !<BeginDescription>
               !
               !Checks  if the user pretends to compute the horizontal diffusion effect
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true.  , .false.
            !Search Type      : From File
        !<EndKeyword>

        call GetData(HorizontalDiffusion,                                     &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'HORIZONTALDIFFUSION',                      &
                     !By default compute always the Horizontal Diffusion
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR270.')


        Me%ComputeOptions%HorizontalDiffusion = HorizontalDiffusion

        !<BeginKeyword>
            !Keyword          : INITIAL_ELEVATION
            !<BeginDescription>
               !
               !Checks if the user wants to impose a initial elevation
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not Have
            !Search Type      : From File
        !<EndKeyword>


        call GetData(InitialElevation,                                                   &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'INITIAL_ELEVATION',                                   &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR280.')

        Me%ComputeOptions%InitialElevation = InitialElevation



        !<BeginKeyword>
            !Keyword          : INITIAL_ELEVATION_VALUE
            !<BeginDescription>
               !
               !The user define with this keyword the initial elevation value
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not Have
            !Search Type      : From File
        !<EndKeyword>


        call GetData(InitialElevationValue,                                   &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'INITIAL_ELEVATION_VALUE',                  &
                     !By default the initial elevation is zero
                     Default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR290')

        Me%WaterLevel%Default = InitialElevationValue

        !<BeginKeyword>
            !Keyword          : INITIAL_VEL_U
            !<BeginDescription>
               !
               !Checks  if the user pretends to impose a initial U (X) velocity
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(InitialVelocityU,                                        &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'INITIAL_VEL_U',                            &
                    !By default do not impose a initial U velocity
                     Default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR300')

        Me%Velocity%Horizontal%U%Default = InitialVelocityU

        !<BeginKeyword>
            !Keyword          : INITIAL_VEL_V
            !<BeginDescription>
               !
               !Checks  if the user pretends to impose a initial V (Y) velocity
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(InitialVelocityV,                                        &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'INITIAL_VEL_V',                            &
                    !By default do not impose a initial V velocity
                     Default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR310')

        Me%Velocity%Horizontal%V%Default = InitialVelocityV



cd21:   if (Baroclinic) then



            !<BeginKeyword>
                !Keyword          : BOUNDARYBAROCLINIC
                !<BeginDescription>
                   !
                   !Check if the user wants to compute the baroclinic force in the boundary faces
                   !
                !<EndDescription>
                !Type             : Logical
                !Default          : .true.
                !File keyword     : IN_DAD3D
                !Multiple Options : .true. (Yes), .false. (No)
                !Search Type      : From File
            !<EndKeyword>

            call GetData(BoundaryBaroclinic,                                      &
                         Me%ObjEnterData, iflag,                     &
                         Keyword    = 'BOUNDARYBAROCLINIC',                       &
                         !By default the model computes always the baroclinic force in the boundary
                         Default    = .true.,                                     &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR320')



            Me%ComputeOptions%BoundaryBaroclinic = BoundaryBaroclinic


            !<BeginKeyword>
                !Keyword          : RAMP
                !<BeginDescription>
                   !
                   !Check if the user wants to start with baroclinic
                   !force null and only after a specific period the total force is compute
                   !
                   !
                !<EndDescription>
                !Type             : Logical
                !Default          : .false.
                !File keyword     : IN_DAD3D
                !Multiple Options : .true. (Yes), .false. (No)
                !Search Type      : From File
            !<EndKeyword>

            call GetData(BaroclinicRamp,                                          &
                         Me%ObjEnterData, iflag,                     &
                        !BaroclinicRamp option by default is false
                         Keyword    = 'RAMP',                                     &
                         Default    = .false.,                                    &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR330')

            Me%ComputeOptions%BaroclinicRamp = BaroclinicRamp

            if (BaroclinicRamp) then

                !<BeginKeyword>
                    !Keyword          : INERTIAL_PERIODS
                    !<BeginDescription>
                       !
                       !The period after which the total effect of the baroclinic force is compute
                       !
                       !
                    !<EndDescription>
                    !Type             : Real
                    !Default          : 1
                    !File keyword     : IN_DAD3D
                    !Multiple Options : Do Not Have
                    !Search Type      : From File
                !<EndKeyword>

                call GetData(InertialPeriods,                                         &
                             Me%ObjEnterData, iflag,                                  &
                             Keyword    = 'INERTIAL_PERIODS',                         &
                             Default    = 1.,                                         &
                             SearchType = FromFile,                                   &
                             ClientModule ='ModuleHydrodynamic',                      &
                             STAT       = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                            &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR340')

                Me%ComputeOptions%InertialPeriods = InertialPeriods

                if (Me%ComputeOptions%Continuous) then

                  !<beginkeyword>
                  !Keyword      : RAMP_START
                  !Description  : This keyword is used to read the initial data Year Month Day Hour Minutes Seconds
                  !Default      : *
                  !File keyword :
                  !<endkeyword>
                   call GetData(Me%ComputeOptions%RAMP_BeginTime,                                                 &
                          Me%ObjEnterData,                                             &
                          iflag,                                                             &
                          keyword      = 'RAMP_START',                                            &
                          SearchType   = FromFile,                                           &
                          ClientModule ='ModuleHydrodynamic',                                &
                          STAT       = STAT_CALL)

                     if (STAT_CALL /= SUCCESS_)                                            &
                        call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR350')

                     if (iflag == 0) &
                        stop 'Define RAMP_START!!! Construct_Numerical_Options - Hydrodynamic - ERR360'
                  else

                    Me%ComputeOptions%RAMP_BeginTime = Me%BeginTime

                  endif

                !<BeginKeyword>
                    !Keyword          : RAMP_PERIOD
                    !<BeginDescription>
                       !
                       !The period after which the total effect of the baroclinic force is compute
                       !
                       !
                    !<EndDescription>
                    !Type             : Real
                    !Default          : 1
                    !File keyword     : IN_DAD3D
                    !Multiple Options : Do Not Have
                    !Search Type      : From File
                !<EndKeyword>

                call GetData(Me%ComputeOptions%RampPeriod,                            &
                             Me%ObjEnterData, iflag,                                  &
                             Keyword    = 'RAMP_PERIOD',                              &
                             Default    = FillValueReal,                              &
                             SearchType = FromFile,                                   &
                             ClientModule ='ModuleHydrodynamic',                      &
                             STAT       = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                            &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR345')

            endif


        endif cd21



        !<BeginKeyword>
            !Keyword          : VERTICALADVECTION
            !<BeginDescription>
               !
               !Checks  if the user pretends to compute the vertical advection effect
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true.  , .false.
            !Search Type      : From File
        !<EndKeyword>

        call GetData(VerticalAdvection,                                                  &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'VERTICALADVECTION',                                   &
                    !By default compute always the Vertical Advection
                     Default    = .True.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR380')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(VerticalAdvection,                                              &
                         Me%ObjEnterData, iflag,                                         &
                         Keyword    = 'VERTICALCONVECTION',                              &
                        !By default compute always the Vertical Advection
                         Default    = .True.,                                            &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR390')



            if (iflag == 1)then
                call SetError (WARNING_, KEYWORD_,                                   &
                     'Change keyword VERTICALCONVECTION to VERTICALADVECTION; ModuleHydrodynamics')
            end if


        endif




        Me%ComputeOptions%VerticalAdvection = VerticalAdvection


        !<BeginKeyword>
            !Keyword          : VERTICALDIFFUSION
            !<BeginDescription>
               !
               !Checks  if the user pretends to compute the vertical diffusion effect
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true.  , .false.
            !Search Type      : From File
        !<EndKeyword>


        call GetData(VerticalDiffusion,                                       &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword    = 'VERTICALDIFFUSION',                        &
                    !By default compute always the Vertical Diffusion
                     Default    = .True.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR400')

        Me%ComputeOptions%VerticalDiffusion = VerticalDiffusion


        !<BeginKeyword>
            !Keyword          : VELTANGENTIALBOUNDARY
            !<BeginDescription>
               !
               !Checks the velocities the user want to impose between two boundary points
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : 1
            !File keyword     : IN_DAD3D
            !Multiple Options : 1 (null value)  , 2 (null gradient)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(VelTangentialBoundary,                                   &
                     Me%ObjEnterData, iflag,                     &
                     Keyword    = 'VELTANGENTIALBOUNDARY',                    &
                    !By default impose a null velocity tangential to the boundary
                     Default    = NULL_GRADIENT,                              &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR410')


        if (VelTangentialBoundary /= NULL_VALUE    .and. &
            VelTangentialBoundary /= NULL_GRADIENT) then

            call SetError(FATAL_, KEYWORD_, 'Construct_Numerical_Options - Hydrodynamic - ERR420')

        endif

        Me%ComputeOptions%VelTangentialBoundary = VelTangentialBoundary


        !<BeginKeyword>
            !Keyword          : VELNORMALBOUNDARY
            !<BeginDescription>
               !
               !Checks the velocities the user want to impose in the exterior faces
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : 1
            !File keyword     : IN_DAD3D
            !Multiple Options : 1 (null value)  , 2 (null gradient)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(VelNormalBoundary,                                       &
                     Me%ObjEnterData, iflag,                     &
                    !By default is imposed a velocity in the exterior faces equal to the nearest compute face
                    !The exterior faces have in one side a boundary point and in another a exterior point
                    !The model don't compute advection and diffusion in the boundary points
                     Keyword    = 'VELNORMALBOUNDARY',                        &
                     Default    = NULL_GRADIENT,                              &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR430')


        if (VelNormalBoundary /= NULL_VALUE .and. &
            VelNormalBoundary /= NULL_GRADIENT) then

            call SetError(FATAL_, KEYWORD_, 'Construct_Numerical_Options - Hydrodynamic - ERR440')

        endif

        Me%ComputeOptions%VelNormalBoundary = VelNormalBoundary


        !<BeginKeyword>
            !Keyword          : NULL_BOUND_HORADV
            !<BeginDescription>
               !
               !Checks if the user want to assumed null horizontal advection in the open boundary
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Null Horizontal boundary advection), .false. (compute boundary advection)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(NullBoundaryHorAdv,                                                 &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'NULL_BOUND_HORADV',                                   &
                    !By default the model do not compute advection and diffusion in the boundary points
                     Default    = .true.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR450')


        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then


            call GetData(NullBoundaryHorAdv,                                             &
                         Me%ObjEnterData, iflag,                            &
                         Keyword    = 'NULL_BOUND_HORCONV',                              &
                        !By default the model do not compute advection and diffusion in the boundary points
                         Default    = .true.,                                            &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR460')


            if (iflag == 1)                                                              &
                call SetError (WARNING_, KEYWORD_,                                       &
                               'Change keyword NULL_BOUND_HORCONV to NULL_BOUND_HORADV; ModuleHydrodynamics')

        endif


        Me%ComputeOptions%NullBoundaryHorAdv = NullBoundaryHorAdv


        !<BeginKeyword>
            !Keyword          : TIDEPOTENTIAL
            !<BeginDescription>
               !
               !Checks if the user want to consider the effect of the potential tide
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ComputeTidePotential,                                               &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'TIDEPOTENTIAL',                                       &
                    !By default the tide potential is not compute
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR470')


        Me%TidePotential%Compute = ComputeTidePotential


        !<BeginKeyword>
            !Keyword          : ATM_RAMP
            !<BeginDescription>
               !
               !Checks if the the user wants to slowly activate the atmospheric forcing
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(AtmosphereRAMP,                                                    &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'ATM_RAMP',                                           &
                    !By default the Atmospheric RAMP is not computed
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR480')

        Me%ComputeOptions%AtmosphereRAMP = AtmosphereRAMP

        !<BeginKeyword>
            !Keyword          : ATM_PERIOD
            !<BeginDescription>
               !
               !The user specify the atmosphere smooth period
               !
            !<EndDescription>
            !Type             : real
            !Default          : 86400.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(AtmospherePeriod,                                                  &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'ATM_PERIOD',                                         &
                     Default    = 86400.,                                               &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR490')

        Me%ComputeOptions%AtmospherePeriod = AtmospherePeriod
        Me%ComputeOptions%AtmosphereCoef = 1.

        if (Me%ComputeOptions%AtmospherePeriod <= 0.)                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR500')

        !<BeginKeyword>
            !Keyword          : IMPOSE_INVERTED_BAROMETER
            !<BeginDescription>
               !
               !Check if the user wants to impose in the open boundary the inverted barometer approximation
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%InvertBarometer,                                 &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'IMPOSE_INVERTED_BAROMETER',                          &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR501')

        !<BeginKeyword>
            !Keyword          : INVERTED_BAROMETER_COEF
            !<BeginDescription>
               !
               !Calibration coefficent of the inverted barometer solution
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%InvertBaroCoef,                                  &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'INVERTED_BAROMETER_COEF',                            &
                     Default    = 1.,                                                   &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR5001')

        !<BeginKeyword>
            !Keyword          : INVERTED_BAROMETER_REF_ATM_PRESSURE
            !<BeginDescription>
               !
               !Reference atmospheric pressure to be used in the inverted barometer solution
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%AtmSeaLevelReference,                            &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'INVERTED_BAROMETER_REF_ATM_PRESSURE',                &
                     !    Parameter defined in the ModuleGlobalData
                     !    Reference atmospheric pressure at sea level in Pa
                     !    real,    parameter  :: AtmPressSeaLevelReference = 101325
                     Default    = AtmPressSeaLevelReference,                            &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR5002')


        if (Me%ComputeOptions%InvertBarometer) then
            Me%State%Surface = .true.

            !<BeginKeyword>
                !Keyword          : INVERTED_BAROMETER_CELLS
                !<BeginDescription>
                   !
                   !Check if the user wants to restrain to specific cells in the open boundary the inverted barometer approximation
                   !This can be usefull imposing the invert barometer approximation in specific boundaries.
                   !
                !<EndDescription>
                !Type             : logical
                !Default          : .false.
                !File keyword     : IN_DAD3D
                !Search Type      : From File
            !<EndKeyword>

            call GetData(Me%ComputeOptions%InvertBaromSomeBound,                            &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'INVERTED_BAROMETER_CELLS',                           &
                         Default    = .false.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR502')

            if (Me%ComputeOptions%InvertBaromSomeBound) then

                allocate(Me%ComputeOptions%InvertBarometerCells(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

                Me%ComputeOptions%InvertBarometerCells(:,:) = 0.

                BeginBlock = "<begin_InvertBarometerCells>"
                EndBlock   = "<end_InvertBarometerCells>"

                !Searches for InvertBarometerCells
                call ExtractBlockFromBuffer (Me%ObjEnterData, ClientNumber,                     &
                                             BeginBlock, EndBlock,                              &
                                             BlockFound, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR503'

                if (BlockFound) then

                    !Gets WaterPoints2D
                    call GetWaterPoints2D(Me%ObjHorizontalMap,                                  &
                                          Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                                  &
                        stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR504'

                    call ConstructPropertyID  (GenericID, Me%ObjEnterData, FromBlock)

                    call ConstructFillMatrix  (PropertyID           = GenericID,                    &
                                               EnterDataID          = Me%ObjEnterData,              &
                                               TimeID               = Me%ObjTime,                   &
                                               HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                               ExtractType          = FromBlock,                    &
                                               PointsToFill2D       = Me%External_Var%WaterPoints2D,&
                                               Matrix2D             = Me%ComputeOptions%InvertBarometerCells,&
                                               TypeZUV              = TypeZ_,                       &
                                               STAT                 = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR505'

                    !UnGets WaterPoints2D
                    call UnGetHorizontalMap(Me%ObjHorizontalMap,                                &
                                          Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                                  &
                        stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR506'

                    call KillFillMatrix(GenericID%ObjFillMatrix, STAT = STAT_CALL)

                    call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR507'

                    call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Numerical_Options  - ModuleHydrodynamic - ERR508'

                endif

            endif

        endif

        !<BeginKeyword>
            !Keyword          : WIND
            !<BeginDescription>
               !
               !Checks if the user want to consider the effect of the wind stress
               !By default the wind stress is not compute
               !
            !<EndDescription>
            !Type             : integer
            !Default          : 0 (No wind forcing)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No wind forcing), 1(wind forcing), 2(wind forcing with a smooth start)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ComputeWind,                                              &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'WIND',                                      &
                     Default    = NoWind_,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR510')

        Me%ComputeOptions%Wind = ComputeWind


        !<BeginKeyword>
            !Keyword          : WIND_SMOOTH_PERIOD
            !<BeginDescription>
               !
               !The user specify the wind smooth period
               !
            !<EndDescription>
            !Type             : real
            !Default          : 86400.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(SmoothInitialPeriod,                                      &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'WIND_SMOOTH_PERIOD',                        &
                     Default    = 86400.,                                      &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR520')

        Me%ComputeOptions%SmoothInitialPeriod = SmoothInitialPeriod

        if (Me%ComputeOptions%SmoothInitialPeriod <= 0.)          &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR530')

        if ( .not. Me%State%Surface .and. ComputeWind /= NoWind_) &
            Me%State%Surface = .true.

        !<BeginKeyword>
            !Keyword          : ATM_PRESSURE
            !<BeginDescription>
               !
               !Checks if the user wants to consider the effect of the Atmospheric Pressure
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(ComputeAtmPressure,                                       &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'ATM_PRESSURE',                              &
                    !By default the Atmospheric Pressure is not compute
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR540')

        Me%ComputeOptions%AtmPressure = ComputeAtmPressure

        if (Me%ComputeOptions%AtmPressure .or. Me%ComputeOptions%InvertBarometer) then
            !<BeginKeyword>
                !Keyword          : ATM_PRESSURE_TYPE
                !<BeginDescription>
                   !
                   !User selects which type of atmospheric pressure he wants to use:
                   ! 1 - Atmospheric Pressure,
                   ! 2 - Mean Sea Level Atmospheric Pressure
                   !
                !<EndDescription>
                !Type             : Logical
                !Default          : .false.
                !File keyword     : IN_DAD3D
                !Multiple Options : .true. (Yes), .false. (No)
                !Search Type      : From File
            !<EndKeyword>

            call GetData(ComputeAtmPressureType,                                        &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword    = 'ATM_PRESSURE_TYPE',                              &
                        !By default the user wants the Atmospheric Pressure type
                         Default    = 1,                                                &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR550')

            Me%ComputeOptions%AtmPressureType = ComputeAtmPressureType

        endif

        if (ComputeAtmPressure) Me%State%Surface = .true.

        !<BeginKeyword>
            !Keyword          : SURFACEWATERFLUX
            !<BeginDescription>
               !
               !Checks if the user want to consider the effect of precipitation and evaporation
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(ComputeSurfaceWaterFlux,                                  &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'SURFACEWATERFLUX',                          &
                     !By default the SurfaceWaterFlux is not compute
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR560')

        Me%ComputeOptions%SurfaceWaterFlux = ComputeSurfaceWaterFlux

        if (.not. Me%State%Surface) &
            Me%State%Surface = ComputeSurfaceWaterFlux


        !<BeginKeyword>
            !Keyword          : HMIN_CHEZY
            !<BeginDescription>
               !
               !Checks the minimum water column height below which the chezy coefficient is constant
               !By default Hmin_Chezy is equal to 10 cm
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.10
            !Units            : meters
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Hmin_Chezy,                                               &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'HMIN_CHEZY',                                &
                     Default    = 0.10,                                        &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR570')


        Me%External_Var%Hmin_Chezy = Hmin_Chezy

        !<BeginKeyword>
            !Keyword          : VMIN_CHEZY
            !<BeginDescription>
               !
               !Checks the minimum velocity (Vmin_Chezy) below which the chezy coefficient
               !is constant if the water column is smaller than Hmin_Chezy
               !By default Vmin_Chezy is equal to 0.10 m/s
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.10
            !Units            : m/s
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Vmin_Chezy,                                               &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'VMIN_CHEZY',                                &
                     Default    = 0.10,                                        &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                             &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR580')


        Me%External_Var%Vmin_Chezy = Vmin_Chezy



        !<BeginKeyword>
            !Keyword          : DATA_ASSIMILATION
            !<BeginDescription>
               !
               !Checks if the user want to impose a flow relaxation boundary condition
               !By default do not use flow relaxation boundary condition
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Relaxation,                                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'DATA_ASSIMILATION',                                  &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR590')

        Me%ComputeOptions%Relaxation = Relaxation

        !<BeginKeyword>
            !Keyword          : WATERLEVEL_MAX_MIN
            !<BeginDescription>
               !
               ! Check if the user wants to compute the maximum and the minimum
               ! water elevation map.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%WaterLevelMaxMin,                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'WATERLEVEL_MAX_MIN',                                 &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR596')


        !<BeginKeyword>
            !Keyword          : ALTIMETRIC_ASSIMILATION
            !<BeginDescription>
               !
               ! Check if the user wants to assimilate altimetry with Cooper-Haines
               ! method.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%AltimetryAssimilation%Yes,                                                         &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'ALTIMETRIC_ASSIMILATION',                             &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR591')

        !<BeginKeyword>
            !Keyword          : GEOST_INITIALIZATION
            !<BeginDescription>
               !
               !Check if the user wants to initialize the model with geostrophic
               !velocities computed with initial fields and elevations.
               !By default do not use geostrophic initialization.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Geost_Initialization,                                               &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'GEOST_INITIALIZATION',                                &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR592')

        Me%ComputeOptions%Geost_Initialization = Geost_Initialization

        if (Geost_Initialization .and. Me%ComputeOptions%Continuous)  then
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR593')
        endif

        !<BeginKeyword>
            !Keyword          : LEVEL_BOTTOM_ANOMALY
            !<BeginDescription>
               !
               !Check if the user wants to compute the change on bottom
               !pressure (converted in level anomaly). This keyword is used
               !if the user wants a time serie for compute admitance betwen
               !sea level anomaly and pressure bottom change.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Level_Bottom_Anomaly,                                               &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'LEVEL_BOTTOM_ANOMALY',                                &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR595')

        Me%ComputeOptions%Level_Bottom_Anomaly = Level_Bottom_Anomaly

#ifdef _USE_SEQASSIMILATION
        call GetData(Me%RunSeqAssimilation,                                              &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'SEQUENTIAL_ASSIMILATION',                             &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR610')

        if (Me%RunSeqAssimilation .and. Me%ComputeOptions%AltimetryAssimilation%Yes) then
            write(*,*)
            write(*,*) 'Sequential and altimetry assimilation cannot be used together.'
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR620')
        endif
#endif _USE_SEQASSIMILATION

        !<BeginKeyword>
            !Keyword          : RECORDING
            !<BeginDescription>
               !
               !Checks if the user wants to record the hydrodynamic properties in binary format
               !that can be used latter by the option 'Read_File' of the Keyword = EVOLUTION
               !By default the model do not record the flow properties
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%Recording,                          &
                     Me%ObjEnterData, iflag,                               &
                     Keyword    = 'RECORDING',                                          &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR630')


        !<BeginKeyword>
            !Keyword          : MOMENTUM_DISCHARGE
            !<BeginDescription>
               !
               !Checks if the user wants to do a discharge of momentum
               !By default the model do not have momentum discharges
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%MomentumDischarge,                   &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'MOMENTUM_DISCHARGE',                                  &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR640')


        !<BeginKeyword>
            !Keyword          : SLOWSTART
            !<BeginDescription>
               !
               !Imposed a specific period in seconds after which
               !the model consider the total imposed boundary wave
               !Along this period the wave amplitude is multiplie by
               !coefficiente that has linear evolution between 0 and 1.
               !By default this period is zero seconds
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0
            !Units            : seconds
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not
            !Search Type      : From File
        !<EndKeyword>


        !By default do not make a slow start TideSlowStartCoef = 0.
        call GetData(TideSlowStartCoef,                                       &
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'SLOWSTART',                                &
                     default    = 0.,                                         &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR650')


        Me%ComputeOptions%TideSlowStartCoef = TideSlowStartCoef

        !<BeginKeyword>
            !Keyword          : HMIN_ADVECTION
            !<BeginDescription>
               !
               !The user can impose a specific water column heigth below which the
               !horizontal advection is not compute
               !By default when the water column has less then 0.5 m the advection in not compute
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.5
            !Units            : meters
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not
            !Search Type      : From File
        !<EndKeyword>



        call GetData(Hmin_Advection,                                          &
                     Me%ObjEnterData, iflag,                     &
                     keyword    = 'HMIN_ADVECTION',                           &
                     default    = 0.50,                                       &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR660')

        ! If the new keyword is not find the model tries to read the old one.
        if (iflag == 0) then

            call GetData(Hmin_Advection,                                          &
                         Me%ObjEnterData, iflag,                     &
                         keyword    = 'HMIN_CONVECTION',                          &
                         default    = 0.50,                                       &
                         SearchType = FromFile,                                   &
                         ClientModule ='ModuleHydrodynamic',                      &
                         STAT       = STAT_CALL)


            if (STAT_CALL /= SUCCESS_)                                            &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR670')


            if (iflag == 1)                                                              &
                call SetError (WARNING_, KEYWORD_,                                       &
                               'Change keyword HMIN_CONVECTION to HMIN_ADVECTION; ModuleHydrodynamics')

        endif




        Me%ComputeOptions%Hmin_Advection = Hmin_Advection


        !<BeginKeyword>
            !Keyword          : LOCAL_DENSITY
            !<BeginDescription>
               !
               ! Check if the user want to devide the baroclinic pressure by the
               ! local density to compute. if this option is false is used the reference density
               !
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (false), 1 (true)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%LocalDensity,                          &
                     Me%ObjEnterData, iflag,                                  &
                     keyword    = 'LOCAL_DENSITY',                            &
                     default    = .true.,                                     &
                     SearchType = FromFile,                                   &
                     ClientModule ='ModuleHydrodynamic',                      &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR680')



        !<BeginKeyword>
            !Keyword          : CYCLIC_BOUNDARY
            !<BeginDescription>
               !
               ! Check if the user wants to impose a CYCLIC boundary condition
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .false. (without Cyclic boundary), .true. (with Cyclic boundary)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%CyclicBoundary%ON,                                               &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'CYCLIC_BOUNDARY',                                     &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)


        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR690')


        !<BeginKeyword>
            !Keyword          : CYCLIC_DIRECTION
            !<BeginDescription>
               !
               ! Check along which direction the user wants to impose a CYCLIC boundary condition
               !
               !
            !<EndDescription>
            !Type             : integer
            !Default          : DirectionXY_
            !File keyword     : IN_DAD3D
            !Multiple Options : DirectionXY_ (Directions X and Y), DirectionX_ (X direction), DirectionY_ (Y direction)
            !Search Type      : From File
        !<EndKeyword>



        if (Me%CyclicBoundary%ON) then

            call GetData(Me%CyclicBoundary%Direction,                                    &
                         Me%ObjEnterData, iflag,                                         &
                         keyword    = 'CYCLIC_DIRECTION',                                &
                         default    = DirectionXY_,                                      &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR700')

        endif

        !<BeginKeyword>
            !Keyword          : CONSERVATIVE_HOR_DIF
            !<BeginDescription>
               !
               ! Check if the user wants to compute the horizontal
               ! diffusion in a conservative way.
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%ConservativeHorDif,                  &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'CONSERVATIVE_HOR_DIF',                                &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR710')


        !<BeginKeyword>
            !Keyword          : BIHARMONIC
            !<BeginDescription>
               !
               ! Check if the user wants to compute the horizontal diffusion
               ! of momentum with a bi-harmonic formulation
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%BiHarmonic,                                      &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'BIHARMONIC',                                         &
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR720')

        !<BeginKeyword>
            !Keyword          : BIHARMONIC_COEF
            !<BeginDescription>
               !
               ! horizontal diffusion ocefficent used when the bi-harmonic option is on
               !
               !
            !<EndDescription>
            !Type             : real
            !Default          : 1e9
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        if (Me%ComputeOptions%BiHarmonic) then

            call GetData(Me%ComputeOptions%BiHarmonicCoef,                              &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'BIHARMONIC_COEF',                                &
                         default    = 1e9,                                              &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR730')
        endif

        !<BeginKeyword>
            !Keyword          : SUBMODEL
            !<BeginDescription>
               !
               ! Check if the user wants to run this model as a submodel
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%ON,                                        &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'SUBMODEL',                                            &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR740')

        !<BeginKeyword>
            !Keyword          : SUBMODEL_FATHER_HOT_START
            !<BeginDescription>
               !
               ! Check if the user wants to the submodel with a father hot start
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%FatherHotStart,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'SUBMODEL_FATHER_HOT_START',                          &
                     default    = .true.,                                               &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR745')



        !<BeginKeyword>
            !Keyword          : MISSING_NULL
            !<BeginDescription>
               !
               ! Check if the user wants to replace the missing values by zero
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%MissingNull,                               &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'MISSING_NULL',                                        &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR750')


        !<BeginKeyword>
            !Keyword          : SUBMODEL_EXTRAPOLATE
            !<BeginDescription>
               !
               ! Check if the user wants to extrapolate the father velocities and water levels
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%Extrapolate,                                           &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'SUBMODEL_EXTRAPOLATE',                               &
                     default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR750')



        !<BeginKeyword>
            !Keyword          : DEADZONE
            !<BeginDescription>
               !
               ! Check if the user wants to define a dead zone where the submodel do not
               ! look for information in the father model
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%DeadZone,                                  &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'DEADZONE',                                            &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR760')

        !<BeginKeyword>
            !Keyword          : DEADZONE_FILE
            !<BeginDescription>
               !
               ! file name where the dead zone is defined was polygon
               !
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%DeadZoneFile,                              &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'DEADZONE_FILE',                                       &
                     default    = '******.***',                                          &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR780')

        !Ang: New father-son 3D connection implementation: option of momentum conserv.
        !<BeginKeyword>
            !Keyword          : MOMENTUM_CONSERV
            !<BeginDescription>
               !
               !Checks if the user wants to maintain, in son, momentum by father
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not Have
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%SubModel%MomentConserv,                                          &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'MOMENTUM_CONSERV',                                    &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR790')

!Manuel MRV

        !<BeginKeyword>
            !Keyword          : BOTTOMVISC_LIM
            !<BeginDescription>
               !
               !Limitation of viscosity at the bottom due to semi-implicit discretization of shear stress on hydrodynamic
               ! equations.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. , .false.
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%BottomVisc_LIM,                      &
             Me%ObjEnterData, iflag,                                        &
             keyword    = 'BOTTOMVISC_LIM',                                              &
             Default    = .false.,                                                       &
             ClientModule ='ModuleHydrodynamic',                                         &
             STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR800')

        if (Me%ComputeOptions%BottomVisc_LIM) then

        !<BeginKeyword>
            !Keyword          : BOTTOMVISC_COEF
            !<BeginDescription>
               !
               ! Factor that multiplies diffusion number for imposing a maximum viscosity at bottom layer
               ! ( coefficient of turbulence transport between layers kbottom and kbottom +1, i.e. viscosity(kbottom+1) )
               ! Maximum viscosity = BottomVisc_MAX*dz*dz/2/dt/Viscosity(kbottom+1)
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 5.
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

            call GetData(Me%ComputeOptions%BottomViscCoef,                  &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'BOTTOMVISC_COEF',                                     &
                     default    = 5.,                                                    &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                   &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR810')

        endif

!EndManuel

        !<BeginKeyword>
            !Keyword          : BAROCLINIC_RADIATION
            !<BeginDescription>
               !
               ! Check if the user wants to radiate internal tides
               !
               !
            !<EndDescription>
            !Type             : integer
            !Default          : NoRadiation_
            !Options          : 0 - NoRadiation_, 1 - Horizontal_, 2 - Vertical_
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%BaroclinicRadia,                     &
                     Me%ObjEnterData, iflag,                                &
                     keyword    = 'BAROCLINIC_RADIATION',                                &
                     default    = NoRadiation_,                                          &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR820')


        !<BeginKeyword>
            !Keyword          : LOCAL_SOLUTION
            !<BeginDescription>
               !
               !Check what type o local (or reference) solution the user wants to use as a reference for the radiative and
               !relaxation boundary conditions
               !
               !
            !<EndDescription>
            !Type             : integer
            !Default          : NoRadiation_
            !Options          : 1 - NoLocalSolution_,      2 - Submodel_, 3 - AssimilationField_, 4 - Gauge_,
            !                   5 - AssimilaPlusSubModel_, 6 - GaugePlusSubModel_, 7 -AssimilaGaugeSubModel_, 8 - AssimilaGauge_
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%LocalSolution,                   &
                     Me%ObjEnterData, iflag,                            &
                     keyword    = 'LOCAL_SOLUTION',                                  &
                     default    = NoLocalSolution_,                                  &
                     SearchType = FromFile,                                          &
                     ClientModule ='ModuleHydrodynamic',                             &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR830')

        if (BarotropicRadia == FlatherLocalSolution_ .and.                              &
            (Me%ComputeOptions%LocalSolution == AssimilationField_ .or.                 &
             Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.              &
             Me%ComputeOptions%LocalSolution == GaugePlusSubModel_    .or.              &
             Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_ .or.             &
             Me%ComputeOptions%LocalSolution == AssimilaGauge_)) then


            !<BeginKeyword>
                !Keyword          : FLAHER_COLD_PERIOD
                !<BeginDescription>
                   !
                   !Periode along each the local solution defined in the assimilation module is slowly
                   !connected
                   !
                !<EndDescription>
                !Type             : real
                !Default          : 0.
                !File keyword     : IN_DAD3D
                !Search Type      : From File
            !<EndKeyword>


            call GetData(Me%ComputeOptions%FlatherColdPeriod,                           &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'FLATHER_COLD_PERIOD',                            &
                         default    = 0.,                                               &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR840')

            if (Me%ComputeOptions%FlatherColdPeriod > (Me%EndTime - Me%BeginTime))      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR850')


            !<BeginKeyword>
                !Keyword          : FLAHER_COLD_SEALEVEL
                !<BeginDescription>
                   !
                   !Average water level for SSH defined in the assimilation module
                   !
                !<EndDescription>
                !Type             : real
                !Default          : 0.
                !File keyword     : IN_DAD3D
                !Search Type      : From File
            !<EndKeyword>


            call GetData(Me%ComputeOptions%FlatherColdSeaLevel,                         &
                         Me%ObjEnterData, iflag,                                        &
                         keyword    = 'FLATHER_COLD_SEALEVEL',                          &
                         default    = 0.,                                               &
                         SearchType = FromFile,                                         &
                         ClientModule ='ModuleHydrodynamic',                            &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR860')


        endif

        !<BeginKeyword>
            !Keyword          : CORRECT_WATERLEVEL
            !<BeginDescription>
               !
               !check if the user wants to corrected the water level when it is lower than a
               !reference water level
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%CorrectWaterLevel,               &
                     Me%ObjEnterData, iflag,                            &
                     keyword    = 'CORRECT_WATERLEVEL',                              &
                     default    = .false.,                                           &
                     SearchType = FromFile,                                          &
                     ClientModule ='ModuleHydrodynamic',                             &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR870')

        !<BeginKeyword>
            !Keyword          : MIN_WATERLEVEL
            !<BeginDescription>
               !
               !reference level below which the water level is corrected.
               !
            !<EndDescription>
            !Type             : real
            !Default          : 0.
            !File keyword     : IN_DAD3D
            !Multiple Options :
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%WaterLevelMin,                   &
                     Me%ObjEnterData, iflag,                            &
                     keyword    = 'MIN_WATERLEVEL',                                  &
                     default    = 0.,                                                &
                     SearchType = FromFile,                                          &
                     ClientModule ='ModuleHydrodynamic',                             &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                   &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR880')


        !<BeginKeyword>
            !Keyword          : BOTTOMWATERFLUX
            !<BeginDescription>
               !
               !Checks if the user want to consider the effect of the soil infiltration or consolidation
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%BottomWaterFlux,                                 &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'BOTTOMWATERFLUX',                                    &
                     !By default the SurfaceWaterFlux is not compute
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR890')

        !<BeginKeyword>
            !Keyword          : SLIPPING_CONDITION
            !<BeginDescription>
               !
               !Checks if the user want to consider the slipping conditition for horizontal diffusion
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .true.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%SlippingCondition,         &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'SLIPPING_CONDITION',                        &
                     !By default the splipping condition is on
                     Default    = .true.,                                      &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR900')


        if (Me%TidePotential%Compute) then

            !<BeginKeyword>
                !Keyword          : POTENTIAL_ALGORITHM
                !<BeginDescription>
                   !
                   !
                   !
                !<EndDescription>
                !Type             : integer
                !Default          : .false.
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not have
                !Search Type      : FromFile
            !<EndKeyword>
            call GetData(Me%TidePotential%Algorithm,                            &
                         Me%ObjEnterData, iflag,                                &
                         keyword    = 'POTENTIAL_ALGORITHM',                                 &
                         default    = Lefevre,                                               &
                         SearchType = FromFile,                                              &
                         ClientModule ='ModuleHydrodynamic',                                 &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR910')

        endif

        !<BeginKeyword>
            !Keyword          : NONHYDROSTATIC
            !<BeginDescription>
               !
               !Checks if the user want to compute the effect of local vertical aceleration over the pressure field
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%NonHydrostatic%ON,                                     &
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'NONHYDROSTATIC',                            &
                     !By default the model is hydrostatic
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR920')


        !<BeginKeyword>
            !Keyword          : WATERCOLUMN2D
            !<BeginDescription>
               !
               !water column thickness below which the 3D proceesses are disconnected
               !
            !<EndDescription>
            !Type             : real
            !Default          : -9e+15
            !File keyword     : IN_DAD3D
            !Multiple Options :
            !Search Type      : From File
        !<EndKeyword>


        call GetData(Me%ComputeOptions%WaterColumn2D,             &
                     Me%ObjEnterData, iflag,                      &
                     Keyword    = 'WATERCOLUMN2D',                             &
                     !By default the model do not disconnect the 3D processes
                     Default    = FillValueReal,                               &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR930')

        !<BeginKeyword>
            !Keyword          : WAVE_STRESS
            !<BeginDescription>
               !
               !Checks if the user want to consider the effect of the waves stress
               !By default the waves stress is not compute
               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No wave stress)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No), 1(Yes)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%WaveStress%ON,                                                  &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'WAVE_STRESS',                                        &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR940')

        if (Me%WaveStress%ON) call InicWaveStressOptions

! Modified by Matthias DELPEY - 27/06/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 27/07/2011 - 24/11/2011
        call GetData(Me%ComputeOptions%WaveForcing3D,                                   &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'WAVE_FORCING_3D',                                    &
                     Default    = NoWave3D,                                             &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR940a')

        if (Me%WaveStress%ON .and.  Me%ComputeOptions%WaveForcing3D /= NoWave3D) then
            stop 'Construct_Numerical_Options - Hydrodynamic - ERR942'
        endif

        if (Me%ComputeOptions%WaveForcing3D == GLM) then
            write(*,*) 'INFO: use of glm2-RANS approach for 3D wave-current modelling'
        endif

        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            call GetData(Me%ComputeOptions%WaveForcing3D_Two,                  &
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'TWO_PARAM',                                 &
                     Default    = TauSurface,                                  &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                             &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR940b')

        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !<BeginKeyword>
            !Keyword          : OBSTACLE
            !<BeginDescription>
               !
               !Checks if the user want to parameteriza the influence of an
               !OBSTACLE in the flow, giving a determined drag coefficient
               !By default the OBSTACLE force is not compute
               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No OBSTACLE)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No OBSTACLE, 1(OBSTACLE parameterization)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%Obstacle,                                &
                     Me%ObjEnterData, iflag,                                    &
                     Keyword    = 'OBSTACLE',                                   &
                     Default    = .false.,                                      &
                     SearchType = FromFile,                                     &
                     ClientModule ='ModuleHydrodynamic',                        &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                              &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR950')


        !<BeginKeyword>
            !Keyword          : CENTRIFUGAL
            !<BeginDescription>
               !
               !Checks if the user want to consider the CENTRIFUGAL force
               !By default the CENTRIFUGAL force is not compute
               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No CENTRIFUGAL force)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No CENTRIFUGAL force), 1(CENTRIFUGAL force)
            !Search Type      : From File
        !<EndKeyword>

        call GetCoordTypeList(SIMPLE_GEOG  = SIMPLE_GEOG, GEOG = GEOG)

        call GetGridCoordType(Me%ObjHorizontalGrid, ICOORD_TIP, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR952')

        call GetCheckDistortion (Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%Distortion,                            &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR953')

        if (ICOORD_TIP == SIMPLE_GEOG .or. ICOORD_TIP == GEOG .or. Me%External_Var%Distortion) then
            DefaultAux = .true.
        else
            DefaultAux = .false.
        endif

        call GetData(Me%ComputeOptions%CentrifugalForce,                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'CENTRIFUGAL',                                        &
                     Default    = DefaultAux,                                           &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR960')


        if (Me%ComputeOptions%CentrifugalForce .or. Me%ComputeOptions%Coriolis) then

            Me%ComputeOptions%InertiaForces = .true.

        else

            Me%ComputeOptions%InertiaForces = .false.

        endif

        call GetData(Me%ComputeOptions%AdvectionMethodH,                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'ADV_METHOD_H',                                       &
                     Default    = UpwindOrder1,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR970')


        call GetData(Me%ComputeOptions%AdvectionMethodV,                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'ADV_METHOD_V',                                       &
                     Default    = UpwindOrder1,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR980')

        call GetData(Me%ComputeOptions%TVD_LimH,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'TVD_LIMIT_H',                                        &
                     Default    = Superbee,                                             &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR990')


        call GetData(Me%ComputeOptions%TVD_LimV,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'TVD_LIMIT_V',                                        &
                     Default    = Superbee,                                             &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1000')


        call GetData(Me%ComputeOptions%VolumeRelMax,                                    &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'VOLUME_RELATION_MAX',                                &
                     Default    = 1.3,                                                  &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1010')

        if (Me%ComputeOptions%AdvectionMethodH == UpwindOrder2 .or.                      &
            Me%ComputeOptions%AdvectionMethodH == UpwindOrder3 .or.                      &
            Me%ComputeOptions%AdvectionMethodH == P2_TVD) then
            Me%ComputeOptions%Upwind2H = .true.
        else
            Me%ComputeOptions%Upwind2H = .false.
        endif

        if (Me%ComputeOptions%AdvectionMethodV == UpwindOrder2 .or.                      &
            Me%ComputeOptions%AdvectionMethodV == UpwindOrder3 .or.                      &
            Me%ComputeOptions%AdvectionMethodV == P2_TVD) then
            Me%ComputeOptions%Upwind2V = .true.
        else
            Me%ComputeOptions%Upwind2V = .false.
        endif


        call GetData(Me%ComputeOptions%BaroclinicMethod,                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'BAROCLINIC_METHOD',                                  &
                     Default    = Leibniz,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1020.')

        call GetData(Me%ComputeOptions%BaroclinicPoliDegree,                            &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'BAROCLINIC_POLIDEGREE',                              &
                     Default    = 1,                                                    &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1030')

        call GetData(Me%NonHydroStatic%Residual,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'NH_RESIDUAL',                                        &
                     Default    = 1e-6,                                                 &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1040')

        call GetData(Me%NonHydroStatic%Maxit,                                           &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'NH_MAXIT',                                           &
                     Default    = 500,                                                  &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1050')

         call GetData(Me%NonHydroStatic%NormalizedResidual,                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'NH_NORMALIZED_RESIDUAL',                             &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1060')

        call GetData(Me%NonHydroStatic%AlphaLU,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'NH_ALPHA_LU',                                        &
                     Default    = 0.5,                                                  &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1080')

        if((Me%NonHydroStatic%AlphaLU<0.).or.(Me%NonHydroStatic%AlphaLU>1.0)) then
            Me%NonHydroStatic%AlphaLU = 0.5
        endif


        call GetData(Me%NonHydroStatic%PressureCorrection,                              &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'PRESSURE_CORRECTION',                                &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1082')

        call GetData(Me%NonHydroStatic%SurfBoundHydrostatic,                            &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'SURFACE_BOUNDARY_HYDROSTATIC',                       &
                     Default    = .true.,                                               &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1083')

        call GetData(Me%ComputeOptions%Vertical_AxiSymmetric_Model,            &
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'VERTICAL_AXISYMMETRIC',                     &
                     Default    = 0,                                           &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1090')

        if (Me%ComputeOptions%Vertical_AxiSymmetric_Model /= 0           .and.          &
            Me%ComputeOptions%Vertical_AxiSymmetric_Model /= DirectionX_ .and.          &
            Me%ComputeOptions%Vertical_AxiSymmetric_Model /= DirectionY_ ) then
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1100')
        endif

        if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionX_ .and. Me%WorkSize%IUB /= 3) &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1110')

        if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionY_ .and. Me%WorkSize%JUB /= 3) &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1120')


        call GetData(Me%ComputeOptions%XZFlow,                                 &
                     Me%ObjEnterData, iflag,                                   &
                     Keyword    = 'XZ_FLOW',                                   &
                     Default    = .false.,                                     &
                     SearchType = FromFile,                                    &
                     ClientModule ='ModuleHydrodynamic',                       &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1130')


        !<BeginKeyword>
            !Keyword          : SCRAPER
            !<BeginDescription>
               !
               !Checks if the user want to parameteriza the influence of an
               !SCRAPER in the flow, giving a determined a velocity of the scraper

               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No SCRAPER)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No SCRAPER, 1(SCRAPER parameterization)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%Scraper,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'SCRAPER',                                            &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1150')

        !<BeginKeyword>
            !Keyword          : SCRAPER_TIME_SCALE
            !<BeginDescription>
               !
               !Checks what is the time scale for computing the accelaration induced by scraper
               !in the flow

               !
            !<EndDescription>
            !Type             : real
            !Default          : 10*DT
            !File keyword     : IN_DAD3D
            !Search Type      : From File
        !<EndKeyword>

        call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = STAT_CALL)

        call GetData(Me%Scraper%TimeScale,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'SCRAPER_TIME_SCALE',                                 &
                     Default    = 10.*DT_Model,                                         &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1160')

        call GetData(Me%ThinWalls%ON,                                                   &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'THIN_WALLS',                                         &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1170')

        call GetData(Me%ComputeOptions%EmersionTime,                                    &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'COMPUTE_EMERSION_TIME',                              &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1180')



        !<BeginKeyword>
            !Keyword          : NULL_WATER_LEVEL_GRAD_I
            !<BeginDescription>
               !
               !Checks if the user want to assume null gradient in the I direction
               !by maritime structures
               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No null water level gradient)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No wave absortion, 1(with wave absortion)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%NullWaterLevelGradI,                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'NULL_WATER_LEVEL_GRAD_I',                            &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1200')

       !<BeginKeyword>
            !Keyword          : NULL_WATER_LEVEL_GRAD_J
            !<BeginDescription>
               !
               !Checks if the user want to assume null gradient in the J direction
               !by maritime structures
               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0 (No null water level gradient)
            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (No wave absortio)
        !<EndKeyword>

        call GetData(Me%ComputeOptions%NullWaterLevelGradJ,                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'NULL_WATER_LEVEL_GRAD_J',                            &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                     &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1210')


        call GetData(Me%ComputeOptions%TwoWay,                                      &
                    Me%ObjEnterData, iflag,                                            &
                    Keyword    = 'TWO_WAY',                                            &
                !By default the model is oneway for downscalling
                    Default    = .false.,                                              &
                    SearchType = FromFile,                                             &
                    ClientModule ='ModuleHydrodynamic',                                &
                    STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                     &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1220')

        if (Me%ComputeOptions%TwoWay) then

            if (Me%SubModel%ON) then

                !Period during which the two way is not computed
                call GetData(Me%ComputeOptions%TwoWayWaitPeriod,                               &
                            Me%ObjEnterData, iflag,                                            &
                            Keyword      = 'TWO_WAY_WAIT_PERIOD',                              &
                            Default      = 0.,                                                 &
                            SearchType   = FromFile,                                           &
                            ClientModule ='ModuleHydrodynamic',                                &
                            STAT         = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1221')

                if (Me%ComputeOptions%Continuous) then
                    Me%ComputeOptions%TwoWayWaitPeriod = 0.
                endif

                call GetData(Me%ComputeOptions%TwoWayTimeDecay,                                      &
                            Me%ObjEnterData, iflag,                                            &
                            Keyword      = 'TWO_WAY_TIME_DECAY',                               &
                            Default      = 3600.,                                              &
                            SearchType   = FromFile,                                           &
                            ClientModule ='ModuleHydrodynamic',                                &
                            STAT         = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1222')

                call GetData(Me%ComputeOptions%TwoWayIntMethod,                                      &
                            Me%ObjEnterData, iflag,                                            &
                            Keyword      = 'TWO_WAY_INT_METHOD',                               &
                            Default      = 1,                                                  &
                            SearchType   = FromFile,                                           &
                            ClientModule ='ModuleHydrodynamic',                                &
                            STAT         = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1223')

                if (Me%ComputeOptions%TwoWayIntMethod == 2) then

                    call GetData(Me%ComputeOptions%TwoWayIWDn,                                      &
                                Me%ObjEnterData, iflag,                                            &
                                Keyword      = 'TWO_WAY_IWD_POWER',                               &
                                Default      = 2,                                                  &
                                SearchType   = FromFile,                                           &
                                ClientModule ='ModuleHydrodynamic',                                &
                                STAT         = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_)                                                      &
                        call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1224')

                endif

                ! number of son cells to be ignored
                call GetData(Me%ComputeOptions%TwoWayNumIgnOBCells,                                  &
                            Me%ObjEnterData, iflag,                                            &
                            Keyword      = 'TWO_WAY_IGNORE_CELLS',                             &
                            Default      = 10,                                                 &
                            SearchType   = FromFile,                                           &
                            ClientModule ='ModuleHydrodynamic',                                &
                            STAT         = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1225')

                call GetData(Me%ComputeOptions%TwoWayWaterLevel,                                  &
                             Me%ObjEnterData, iflag,                                            &
                             Keyword      = 'TWO_WAY_WATERLEVEL',                             &
                             Default      = .false.,                                                 &
                             SearchType   = FromFile,                                           &
                             ClientModule ='ModuleHydrodynamic',                                &
                             STAT         = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1228')

            else
                write(*,*) 'Keyword TWO_WAY must ONLY be defined in son domains'
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1229')
            endif

        endif

        ! Increases the water level provided by the parent domain.
        if (Me%SubModel%ON) then
            call GetData(Me%Submodel%WaterLevelIncrease,                                   &
                        Me%ObjEnterData, iflag,                                            &
                        Keyword      = 'WATER_LEVEL_INCREASE ',                            &
                        Default      = 0.0,                                                &
                        SearchType   = FromFile,                                           &
                        ClientModule ='ModuleHydrodynamic',                                &
                        STAT         = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1260')
        endif


        !<BeginKeyword>
            !Keyword          : TIDE_STATE
            !<BeginDescription>
               !
               ! Check if the user wants to output the tide state
               ! water elevation map.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !Multiple Options : .true. (Yes), .false. (No)
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%ComputeOptions%TideStateON,                                     &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'TIDE_STATE_ON',                                      &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1220')


        !Keyword for activating the Turbine implementation => TURBINE  : 1
        call GetData(Me%ComputeOptions%Turbine,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'TURBINE',                            &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1220')
        
        call GetData(Me%ComputeOptions%GlobalOptimization,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'GLOBAL_OPT',                                         &
                     Default    = .false.,                                              &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1221')
        
        if (Me%ComputeOptions%GlobalOptimization) then
           
            call GetData(Me%ComputeOptions%InertiaForcesOpt,                                         &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_INERTIAFORCES_OPT',                                 &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1221')
        
            call GetData(Me%ComputeOptions%VelExpForcesOpt,                                         &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_VEL_EXP_FORCES',                                 &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1222')
        
            call GetData(Me%ComputeOptions%VerticalWaterFlowOpt,                                         &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_VERT_WATER_FLOW_OPT',                                 &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1223')

            call GetData(Me%ComputeOptions%CartesianVertVelocityOpt,                        &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_CARTESIAN_VERT_VELOCITY_OPT',                        &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1224')
            
            call GetData(Me%ComputeOptions%HorizontalAdvectionOpt,                        &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_ADVECTION_H',                        &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1225')
            
            call GetData(Me%ComputeOptions%VerticalAdvectionOpt,                        &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_ADVECTION_V',                        &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1226')
            
            call GetData(Me%ComputeOptions%HorizontalDiffusionOpt,                        &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_DIFFUSION_H',                        &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1227')
            
            call GetData(Me%ComputeOptions%VerticalDiffusionOpt,                        &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_DIFFUSION_V',                        &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1228')
            
            call GetData(Me%ComputeOptions%MatrixesOutputOpt,                        &
                         Me%ObjEnterData, iflag,                                            &
                         Keyword    = 'OPTIMIZE_MATRIXES_OUTPUT',                        &
                         Default    = .true.,                                              &
                         SearchType = FromFile,                                             &
                         ClientModule ='ModuleHydrodynamic',                                &
                         STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, 'Construct_Numerical_Options - Hydrodynamic - ERR1229')
            
        endif


    End Subroutine Construct_Numerical_Options

    !-----------------------------------------------------------------------

    subroutine OperationalModelDefaultOptions

        !Local-----------------------------------------------------------------
        real,   dimension(:,:), pointer     :: DUX, DVY
        real                                :: DX
        integer                             :: iflag, FromFile
        integer                             :: STAT_CALL
        integer                             :: i, j
        logical                             :: OperationalModel

        !----------------------------------------------------------------------

        call GetExtractType(FromFile = FromFile)

        call GetData(OperationalModel,                                                  &
                      Me%ObjEnterData, iflag,                                           &
                      keyword      = 'OPERATIONAL_MODEL_DEFAULT',                       &
                      default      = .false.,                                           &
                      SearchType   = FromFile,                                          &
                      ClientModule = 'ModuleHydrodynamic',                              &
                      STAT         = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) then
            stop "OperationalModelDefaultOptions - Hydrodynamic - ERR10"
        endif

        Me%ComputeOptions%AssimilaOneField = .false.

        if (OperationalModel) then

            call GetData(Me%ComputeOptions%AssimilaOneField,                            &
                          Me%ObjEnterData, iflag,                                       &
                          keyword      = 'ASSIMILA_ONE_FIELD',                          &
                          default      = .false.,                                       &
                          SearchType   = FromFile,                                      &
                          ClientModule = 'ModuleHydrodynamic',                          &
                          STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) then
                stop "OperationalModelDefaultOptions - Hydrodynamic - ERR20"
            endif


            !Advection of momentum
            !ADV_METHOD_H             : 4
            Me%ComputeOptions%AdvectionMethodH = P2_TVD
            !ADV_METHOD_V             : 4
            Me%ComputeOptions%AdvectionMethodV = P2_TVD

            Me%ComputeOptions%Upwind2H = .true.
            Me%ComputeOptions%Upwind2V = .true.

            if (Me%WorkSize%KUB > 1) then
                !Baroclinic force
                !BAROCLINIC               : 1
                Me%ComputeOptions%Baroclinic         = .true.
                Me%ComputeOptions%BoundaryBaroclinic = .true.
            else
                Me%ComputeOptions%Baroclinic         = .false.
                Me%ComputeOptions%BoundaryBaroclinic = .false.
            endif

            !Boundary relaxation flow
            !DATA_ASSIMILATION        : 1
            Me%ComputeOptions%Relaxation = .true.
            !BRFORCE                  : 1
            Me%Relaxation%Force          = .true.

            !Tide forcing
            !TIDE                     : 0
            Me%ComputeOptions%Compute_Tide  = .false.
            !TIDEPOTENTIAL            : 1
            Me%TidePotential%Compute        = .true.

            !Sea level boundary condition

            !RADIATION                 : 2
            Me%ComputeOptions%BarotropicRadia       = FlatherLocalSolution_
            !LOCAL_SOLUTION            : 3
            Me%ComputeOptions%LocalSolution         = AssimilationField_

            Me%ComputeOptions%MinLeavingVelocity    = 1e-6
            Me%ComputeOptions%MinLeavingComponent   = 1e-3

            Me%ComputeOptions%Imposed_BoundaryWave  = .false.


            !Atmospheric forcing
            Me%State%Surface = .true.

            !ATM_PRESSURE             : 1
            Me%ComputeOptions%AtmPressure = .true.
                    ! 1 - Atmospheric Pressure,
                    ! 2 - Mean Sea Level Atmospheric Pressure
            Me%ComputeOptions%AtmPressureType   = 1
            Me%ComputeOptions%AtmosphereCoef    = 1.



            !Cold vs Hot start
            if (Me%ComputeOptions%Continuous) then
                Me%ComputeOptions%BaroclinicRamp = .false.

                Me%ComputeOptions%AtmosphereRAMP =.false.
                !WIND                     : 1
                Me%ComputeOptions%Wind           = WithWind_

            else
                !RAMP                     : 1
                Me%ComputeOptions%BaroclinicRamp        = .true.
                !INERTIAL_PERIODS         : 3
                Me%ComputeOptions%InertialPeriods       = 3

                Me%ComputeOptions%RAMP_BeginTime        = Me%BeginTime

                !WIND                     : 2
                Me%ComputeOptions%Wind                  = InitialSmoothWind_
                !WIND_SMOOTH_PERIOD       : 172800
                Me%ComputeOptions%SmoothInitialPeriod   = 172800.
                !ATM_RAMP                 : 1
                Me%ComputeOptions%AtmosphereRAMP        =.true.
                !ATM_PERIOD               : 172800
                Me%ComputeOptions%AtmospherePeriod      = 172800.

                !FLATHER_COLD_PERIOD       : 172800
                Me%ComputeOptions%FlatherColdPeriod     = 172800.

                if (Me%ComputeOptions%FlatherColdPeriod > (Me%EndTime - Me%BeginTime)) then
                    stop "OperationalModelDefaultOptions - Hydrodynamic - ERR30"
                endif

            endif

            !If not define automatically connect the biharmonic filter
            !BIHARMONIC               : 1
            if (.not. Me%ComputeOptions%BiHarmonic) then

                Me%ComputeOptions%BiHarmonic        = .true.

                call GetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,         &
                                       DUX              = DUX,                          &
                                       DVY              = DVY,                          &
                                       STAT             = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) then
                    stop "OperationalModelDefaultOptions - Hydrodynamic - ERR50"
                endif

                !DX = max(DUX(1,1), DVY(1,1))

                DX = - FillValueReal

                do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                    !Find minimum spatial step
                    if (DUX(i,j) < DX .and. DUX(i,j) > 0) DX = DUX(i,j)
                    if (DVY(i,j) < DX .and. DVY(i,j) > 0) DX = DVY(i,j)
                enddo
                enddo

                !BIHARMONIC_COEF          : dx^3/10
                Me%ComputeOptions%BiHarmonicCoef    = DX**3/10.

                call UnGetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,       &
                                         Array            = DUX,                        &
                                         STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    stop "OperationalModelDefaultOptions - Hydrodynamic - ERR60"
                endif

                call UnGetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,       &
                                         Array            = DVY,                        &
                                         STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    stop "OperationalModelDefaultOptions - Hydrodynamic - ERR70"
                endif

            endif


        endif


    end subroutine OperationalModelDefaultOptions

    !--------------------------------------------------------------------------

    subroutine InicWaveStressOptions

        !Local-----------------------------------------------------------------
        integer, dimension(:,:), pointer    :: WaterPoints2D
        real                                :: maxvalue, minvalue
        integer                             :: ClientNumber, iflag, FromFile
        logical                             :: BlockFound
        type(T_PropertyID)                  :: ID
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------

        call GetExtractType(FromFile = FromFile)

        call GetData(Me%WaveStress%Dumping,                                             &
                      Me%ObjEnterData, iflag,                                           &
                      keyword      = 'WAVE_STRESS_DUMPING',                             &
                      default      = .false.,                                           &
                      SearchType   = FromFile,                                          &
                      ClientModule = 'ModuleHydrodynamic',                              &
                      STAT         = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop "InicWaveStressOptions - Hydrodynamic - ERR10"


dump:   if (Me%WaveStress%Dumping) then

            allocate (Me%WaveStress%DumpCoef(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB))

            Me%WaveStress%DumpCoef(:,:) = FillValueReal


            call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                      &
                                        relax_wave_stress_begin, relax_wave_stress_end,     &
                                        BlockFound, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop "InicWaveStressOptions - Hydrodynamic - ERR20"

found:      if(BlockFound) then

                !Gets WaterPoints2D
                call GetWaterPoints2D(Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'InicWaveStressOptions - Hydrodynamic - ERR30'

                call ConstructFillMatrix  (PropertyID           = ID,                               &
                                           EnterDataID          = Me%ObjEnterData,                  &
                                           TimeID               = Me%ObjTime,                       &
                                           HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                           ExtractType          = FromBlock,                        &
                                           PointsToFill2D       = WaterPoints2D,                    &
                                           Matrix2D             = Me%WaveStress%DumpCoef,           &
                                           TypeZUV              = TypeZ_,                           &
                                           STAT                 = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop "InicWaveStressOptions - Hydrodynamic - ERR40"

                call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop "InicWaveStressOptions - Hydrodynamic - ERR50"

                call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop "InicWaveStressOptions - Hydrodynamic - ERR60"

                call KillFillMatrix(ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop "InicWaveStressOptions - Hydrodynamic - ERR70"

                maxvalue = maxival(array = Me%WaveStress%DumpCoef, size2D = Me%WorkSize2D)
                if (maxvalue > 1.) stop "InicWaveStressOptions - Hydrodynamic - ERR80"

                minvalue = minival(array = Me%WaveStress%DumpCoef, size2D = Me%WorkSize2D)
                if (minvalue < 0.) stop "InicWaveStressOptions - Hydrodynamic - ERR90"

                !UnGets WaterPoints2D
                call UnGetHorizontalMap(Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'InicWaveStressOptions - Hydrodynamic - ERR100'

            else

                write(*,*) 'Need to define the block <begin_relax_wave_stress> / <end_relax_wave_stress>'
                stop 'InicWaveStressOptions - Hydrodynamic - ERR110'

            endif found

        endif dump

    end subroutine InicWaveStressOptions

    !End-----------------------------------------------------------------------


    Subroutine Construct_RadiaBaroclinic

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------

        integer :: FromFile
        integer :: status, iflag

        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB
        integer :: MaxNormX, MaxNormY
        integer :: MaxTangX, MaxTangY, i

        !Begin-----------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB



        call GetExtractType(FromFile = FromFile)


        call GetData(Me%VelBaroclinic%CelerityType,                                      &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'CELERITY_TYPE',                                       &
                     default    = Constant_,                                             &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR01')


        call GetData(Me%VelBaroclinic%InternalCelerity,                                  &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'INTERNAL_CELERITY',                                   &
                     default    = 2.,                                                    &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR02')

        call GetData(Me%VelBaroclinic%TRelaxIn,                                          &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'DECAY_IN',                                            &
                     default    = 86400.,                                                &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR03')


        call GetData(Me%VelBaroclinic%TRelaxOut,                                         &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'DECAY_OUT',                                           &
                     default    = 8640000.,                                              &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR04')


        call GetData(Me%VelBaroclinic%MinLeavingBaroclincVel,                            &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'MINVEL_BAROCLINIC',                                   &
                     default    = 1e-6,                                                  &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR05')

        call GetData(Me%VelBaroclinic%BaroclinicNormalRadiation,                         &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'NORMAL_BAROCLINIC',                                   &
                     default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR06')




        call GetData(Me%VelBaroclinic%BaroclinicOBCDiscret,                              &
                     Me%ObjEnterData, iflag,                                             &
                     keyword    = 'BAROCLINIC_OBC_DISCRET',                              &
                     default    = Implicit_,                                             &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR07')

        if (Me%VelBaroclinic%BaroclinicOBCDiscret == StoreWave_) then

            call GetData(Me%VelBaroclinic%DTWave,                                        &
                         Me%ObjEnterData, iflag,                                         &
                         keyword    = 'BAROCLINIC_WAVE_DT',                              &
                         default    = Me%Velocity%DT,                                    &
                         SearchType = FromFile,                                          &
                         ClientModule ='ModuleHydrodynamic',                             &
                         STAT       = status)

            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, KEYWORD_, 'Construct_RadiaBaroclinic - Hydrodynamic - ERR07a')

        endif


        allocate (Me%VelBaroclinic%W_New(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate (Me%VelBaroclinic%W_Old(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate (Me%VelBaroclinic%U%New(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate (Me%VelBaroclinic%U%Old(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate (Me%VelBaroclinic%V%New(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate (Me%VelBaroclinic%V%Old(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate (Me%VelBaroclinic%U2D  (ILB:IUB, JLB:JUB))
        allocate (Me%VelBaroclinic%V2D  (ILB:IUB, JLB:JUB))

        Me%VelBaroclinic%W_New(:,:,:) = FillValueReal
        Me%VelBaroclinic%W_Old(:,:,:) = FillValueReal
        Me%VelBaroclinic%U%New(:,:,:) = FillValueReal
        Me%VelBaroclinic%U%Old(:,:,:) = FillValueReal
        Me%VelBaroclinic%V%New(:,:,:) = FillValueReal
        Me%VelBaroclinic%V%Old(:,:,:) = FillValueReal
        Me%VelBaroclinic%U2D(:,:)     = 0.
        Me%VelBaroclinic%V2D(:,:)     = 0.

       !Auxiliar horizontal baroclinic velocity pointers
        nullify (Me%VelBaroclinic%UV%New)
        nullify (Me%VelBaroclinic%UV%Old)

        nullify (Me%VelBaroclinic%VU%New)
        nullify (Me%VelBaroclinic%VU%Old)

        nullify (Me%VelBaroclinic%UV2D)



        if (Me%VelBaroclinic%BaroclinicOBCDiscret == StoreWave_) then

            MaxTangX = (JUB - JLB    ) * 2 * (KUB - KLB + 1)
            MaxNormY = (JUB - JLB - 1) * 2 * (KUB - KLB + 1)

            MaxTangY = (IUB - ILB    ) * 2 * (KUB - KLB + 1)
            MaxNormX = (IUB - ILB - 1) * 2 * (KUB - KLB + 1)

            allocate(Me%VelBaroclinic%ImposedNormX(MaxNormX))
            do i = 1, MaxNormX
                nullify(Me%VelBaroclinic%ImposedNormX(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedNormX(i)%LastInstant)
            enddo

            allocate(Me%VelBaroclinic%ImposedNormY(MaxNormY))
            do i = 1, MaxNormY
                nullify(Me%VelBaroclinic%ImposedNormY(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedNormY(i)%LastInstant)
            enddo

            allocate(Me%VelBaroclinic%ImposedTangX(MaxTangX))
            do i = 1, MaxTangX
                nullify(Me%VelBaroclinic%ImposedTangX(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedTangX(i)%LastInstant)
            enddo


            allocate(Me%VelBaroclinic%ImposedTangY(MaxTangY))
            do i = 1, MaxTangY
                nullify(Me%VelBaroclinic%ImposedTangY(i)%FirstInstant)
                nullify(Me%VelBaroclinic%ImposedTangY(i)%LastInstant)
            enddo

        endif

    end subroutine Construct_RadiaBaroclinic

    !End--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine Verify_Numerical_Options

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------

        integer :: WorkKUB, WorkIUB, WorkJUB, WorkILB, WorkJLB, STAT_CALL
        real    :: Total_RunPeriod, InertialPeriods, RampPeriod

        !Begin-----------------------------------------------------------------


        WorkKUB = Me%WorkSize%KUB

        WorkIUB = Me%WorkSize%IUB
        WorkILB = Me%WorkSize%ILB

        WorkJUB = Me%WorkSize%JUB
        WorkJLB = Me%WorkSize%JLB


        if (Me%ComputeOptions%Baroclinic .and. WorkKUB == 1)                &
            call SetError(FATAL_, KEYWORD_, 'Inconsistency: mode baroclinic active in a 2D model - ERR01')



        if (Me%ComputeOptions%BarotropicRadia /= NoRadiation_ .and.         &
            Me%ComputeOptions%Imposed_BoundaryWave)                         &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR02.')

        if (Me%ComputeOptions%BarotropicRadia /= NoRadiation_ .and.         &
            Me%ComputeOptions%Compute_Tide)                                 &
            call SetError(WARNING_, KEYWORD_, 'The model is imposing in the open boundary tide together with radiation')

        !MRV A clamped condition or a BK condition should be imposed
        if (Me%ComputeOptions%BarotropicRadia == BlumbergKantha_ .and.      &
            Me%ComputeOptions%Imposed_BoundaryWave)                         &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR02.')


        if (Me%ComputeOptions%UpStream_CenterDif < 0 .or.                   &
            Me%ComputeOptions%UpStream_CenterDif > 1)                       &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR04.')

        !This variable must greather then 0 (total explicit) and smaller then 1 (total implicit)
        if (Me%ComputeOptions%ImplicitVertAdvection < 0 .or.               &
            Me%ComputeOptions%ImplicitVertAdvection > 1)                   &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR05.')

        !This variable must greather then 0 (total explicit) and smaller then 1 (total implicit)
        if (Me%ComputeOptions%ImplicitVertDiffusion < 0 .or.                &
            Me%ComputeOptions%ImplicitVertDiffusion > 1)                    &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR06.')

        !The model only know how to compute hydrodynamic using the Abbott scheme (time-split with 4 equations)
        ! or the Leendertse scheme (time-split with 6 equations)
        if (.not. (Me%ComputeOptions%Num_Discretization == Abbott .or.      &
                   Me%ComputeOptions%Num_Discretization == Leendertse))     &
            call SetError(FATAL_, KEYWORD_,  'Verify_Numerical_Options - Hydrodynamic - ERR07.')

        !The model only know how to compute horizontal advection using central differences or a
        !upstream scheme. There are only two upstream schemes implemented (first order Upwind and
        !second order Upwind that we call Quick). The true Quick scheme is more complex see Leonard, 1979 ????
        if (.not. (Me%ComputeOptions%UpStream == Upwind_Scheme .or.         &
                   Me%ComputeOptions%UpStream == Quick_Scheme))             &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR08.')


cd1:    if (Me%ComputeOptions%Baroclinic) then

cd2:        if (Me%ComputeOptions%BaroclinicRamp) then

                Total_RunPeriod = Me%EndTime - Me%BeginTime

                InertialPeriods = Me%ComputeOptions%InertialPeriods

                if (Me%ComputeOptions%RampPeriod > 0.) then
                    RampPeriod = Me%ComputeOptions%RampPeriod
                else
                    RampPeriod = 86400. * InertialPeriods
                endif

                if (Total_RunPeriod < RampPeriod )                                       &
                    call SetError (WARNING_, KEYWORD_, &
                                  'The RAMP option only work for bigger runs. Check RAMP_START in following files')


cd3:            if (Me%ComputeOptions%Continuous) then

                     call SetError(WARNING_, KEYWORD_, 'You are using the RAMP option with continuous calculus. Check RAMP_START')

                end if cd3

            end if cd2

        endif cd1

        if (Me%ComputeOptions%VelTangentialBoundary /= NULL_VALUE    .and.  &
            Me%ComputeOptions%VelTangentialBoundary /= NULL_GRADIENT)       &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR09.')

        if (Me%ComputeOptions%VelNormalBoundary /= NULL_VALUE .and.         &
            Me%ComputeOptions%VelNormalBoundary /= NULL_GRADIENT)           &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR10.')

        if (Me%ComputeOptions%Evolution /= Solve_Equations_       .and.     &
            Me%ComputeOptions%Evolution /= Read_File_             .and.     &
            Me%ComputeOptions%Evolution /= No_hydrodynamic_       .and.     &
            Me%ComputeOptions%Evolution /= Run_Off_               .and.     &
            Me%ComputeOptions%Evolution /= ImposedSolution_       .and.     &
            Me%ComputeOptions%Evolution /= Vertical1D_            .and.     &
            Me%ComputeOptions%Evolution /= Harmonics_             .and.     &
            Me%ComputeOptions%Evolution /= Residual_hydrodynamic_         ) &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR11.')

        if (Me%ComputeOptions%Evolution == Residual_hydrodynamic_ .and.     &
            .not. Me%ComputeOptions%Continuous )                            &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR12.')


        if (Me%ComputeOptions%Evolution == Residual_hydrodynamic_ .and.     &
            .not. Me%ComputeOptions%Residual)                               &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR13.')

       !Guillaume
       if ( Me%ComputeOptions%Evolution == Vertical1D_ ) then
       if (    Me%ComputeOptions%Obstacle                          .or.                 &
               Me%TidePotential%Compute                            .or.                 &
               Me%TidePotential%Compute                            .or.                 &
               Me%Relaxation%Force                                 .or.                 &
               Me%ComputeOptions%HorizontalAdvection               .or.                 &
               Me%ComputeOptions%HorizontalDiffusion               .or.                 &
               Me%ComputeOptions%VolumeVariation                   .or.                 &
               Me%ComputeOptions%MomentumDischarge) then

            call SetError(WARNING_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR13a.')
       endif
       endif

        if ((Me%ComputeOptions%Evolution == Read_File_             .or.                 &
             Me%ComputeOptions%Evolution == No_hydrodynamic_       .or.                 &
             Me%ComputeOptions%Evolution == Run_Off_               .or.                 &
             Me%ComputeOptions%Evolution == Harmonics_             .or.                 &
             Me%ComputeOptions%Evolution == ImposedSolution_      ).and.                &
             Me%ComputeOptions%Continuous)                                              &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR14.')


        if (Me%ComputeOptions%SurfaceWaterFlux .and.                                    &
            Me%ComputeOptions%Evolution == Read_File_)                                  &
            call SetError(FATAL_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - ERR18.')

!        if (Me%ComputeOptions%SurfaceWaterFlux .and.                           &
!            Me%ComputeOptions%Recording             )                       &
!            call SetError(FATAL_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - ERR19.')


        if (Me%ComputeOptions%TideSlowStartCoef > 0. .and.                              &
            .not. (Me%ComputeOptions%Compute_Tide    .or.                               &
                   Me%TidePotential%Compute    ))                                       &
            call SetError(FATAL_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - ERR20.')

        if (Me%ComputeOptions%TideSlowStartCoef > 0. .and.                              &
            Me%ComputeOptions%Continuous) then
                write(*,*) 'Hot Start is ON'
                write(*,*) 'SLOWSTART keyword present'
                write(*,*) 'SlowStart period is set to zero by default in all Hot Start'
                Me%ComputeOptions%TideSlowStartCoef = 0.
                call SetError(WARNING_, INTERNAL_, 'Verify_Numerical_Options - Hydrodynamic - WRN20a.')
        endif

        if (.not. Me%ComputeOptions%Compute_Tide .and.                                  &
                  Me%TidePotential%Compute )                                            &
            call SetError(WARNING_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - WRN21.')



!        if (Me%ComputeOptions%BarotropicRadia /= FlatherLocalSolution_ .and.&
!            Me%SubModel%ON)                                                 &
!            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR25.')

        if (Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_ .and.            &
            Me%ComputeOptions%LocalSolution   /= SubModel_             .and.            &
            Me%ComputeOptions%LocalSolution   /= AssimilaPlusSubModel_ .and.            &
            Me%ComputeOptions%LocalSolution   /= GaugePlusSubModel_    .and.            &
            Me%ComputeOptions%LocalSolution   /= AssimilaGaugeSubModel_.and.            &
            Me%SubModel%ON)                                                             &
            call SetError(WARNING_, KEYWORD_, 'The model is not using in the flather OBC the submodel as the local solution')


!        if (.not. Me%ComputeOptions%Imposed_BoundaryWave .and.              &
!            Me%SubModel%ON)                                                 &
!            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR26.')


        if (Me%ComputeOptions%BaroclinicRadia /= Horizontal_ .and.                      &
            Me%ComputeOptions%BaroclinicRadia /= Vertical_   .and.                      &
            Me%ComputeOptions%BaroclinicRadia /= NoRadiation_)                          &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR28.')

        if (Me%ComputeOptions%LocalSolution /= NoLocalSolution_      .and.              &
            Me%ComputeOptions%LocalSolution /= Submodel_             .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilationField_    .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilaPlusSubModel_ .and.              &
            Me%ComputeOptions%LocalSolution /= GaugePlusSubModel_    .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilaGaugeSubModel_.and.              &
            Me%ComputeOptions%LocalSolution /= Gauge_                .and.              &
            Me%ComputeOptions%LocalSolution /= AssimilaGauge_)                          &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR29.')

        if (.not. Me%SubModel%ON .and.                                                  &
            Me%ComputeOptions%LocalSolution == Submodel_                       )        &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR30.')

        if (Me%ComputeOptions%Wind /= NoWind_             .and.                         &
            Me%ComputeOptions%Wind /= WithWind_           .and.                         &
            Me%ComputeOptions%Wind /= InitialSmoothWind_)                               &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR31.')

        if (Me%ComputeOptions%Wind == InitialSmoothWind_  .and.                         &
            Me%ComputeOptions%Continuous )                                              &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR32.')

        call GetCheckDistortion (Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%Distortion,                            &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, 'Verify_Numerical_Options - Hydrodynamic - ERR62.')

        if (Me%External_Var%Distortion .and. .not. Me%ComputeOptions%CentrifugalForce) then
            write(*,*) 'The grid has a distortion but the centrifugal force is not actvie'
            write(*,*) 'Verify_Numerical_Options - Hydrodynamic - WARN62.'
        endif

        if (Me%ComputeOptions%ImplicitVertAdvection> 0.         .and.                   &
           (Me%ComputeOptions%AdvectionMethodV == UpwindOrder2  .or.                    &
            Me%ComputeOptions%AdvectionMethodV == UpwindOrder3)) then

            write(*,*) 'If the advection of momentum in the vertical is implicit'
            write(*,*) 'the advection method can not be a second or third order upwind'
            stop 'Verify_Numerical_Options - Hydrodynamic - ERR40.'

        endif

       if ((Me%ComputeOptions%Residual)                     .and.                       &
           (Me%ComputeOptions%Evolution /= Solve_Equations_ .and.                       &
            Me%ComputeOptions%Evolution /= ImposedSolution_)) then

            write(*,*) 'Unable to retrieve residuals if not solving equations.'
            write(*,*) 'Check either RESIDUAL or EVOLUTION keywords.'
            stop 'Verify_Numerical_Options - Hydrodynamic - ERR41.'

        endif

        if (Me%ComputeOptions%LocalSolution   == NoLocalSolution_      .and.            &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_ .and.            &
            Me%ComputeOptions%Relaxation) then
            write(*,*) 'NUDGING option ON '
            write(*,*) 'FLATHER RADIATION ON radiating over a null local solution'
            write(*,*) 'Verify_Numerical_Options - Hydrodynamic - ERR42.'
        endif

        if ((Me%ComputeOptions%LocalSolution == GaugePlusSubModel_ .or.                 &
             Me%ComputeOptions%LocalSolution ==  AssimilaGaugeSubModel_)   .and.        &
           (.not.(Me%ComputeOptions%Compute_Tide .or. Me%ComputeOptions%InvertBarometer) )) then
            write(*,*) 'To activate the local solution Gauge + SubModel'
            write(*,*) 'One of the options TIDE or INVERTBAROMETER must be on'
            write(*,*) 'Verify_Numerical_Options - Hydrodynamic - ERR60.'
        endif



    End Subroutine Verify_Numerical_Options

    !-----------------------------------------------------------------

    Subroutine ConstructBlumbergKantha

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        real, dimension(:), allocatable     :: AuxVector
        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: ILBWork, IUBWork, JLBWork, JUBWork
        integer                             :: STATUS

        integer                             :: ClientNumber
        integer                             :: FirstLine, LastLine
        integer                             :: Line, iflag, FromFile
        integer                             :: i ,j
        integer                             :: ii,jj

        Character(LEN = StringLength)       :: FileName
        Character(LEN = StringLength)       :: block_begin, block_end

        logical                             :: BlockFound

        !Begin Algorithm --------------------------------------------------------


        call GetExtractType( FromFile = FromFile)


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB



        IUBWork = Me%WorkSize%IUB
        ILBWork = Me%WorkSize%ILB
        JUBWork = Me%WorkSize%JUB
        JLBWork = Me%WorkSize%JLB

        allocate (Me%ComputeOptions%Tlag(ILB : IUB, JLB : JUB), STAT = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR10")

        Me%ComputeOptions%Tlag(ILBWork : IUBWork, JLBWork : JUBWork) = 1E-12

        !<BeginKeyword>
            !Keyword          : TLAG_FILE
            !<BeginDescription>
                ! The name file where are the relaxation times defined for the radiation boundary condition
            !<EndDescription>
            !Type             : Character
            !Default          : Do not have
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : From File
        !<EndKeyword>


        call GetData(FileName,    Me%ObjEnterData, iflag,                               &
                     SearchType = FromFile,                                             &
                     keyword    = 'TLAG_FILE',                                          &
                     default    = '******.***',                                         &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR20")

        if (iflag == 0) &
            call SetError (FATAL_, OUT_OF_MEM_, "ConstructBlumbergKantha - Hydrodynamic - ERR30")


        call ConstructEnterData(Me%ObjEnterData1, FileName, STAT = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR40")


        block_begin = '<TlagBegin>'
        block_begin = trim(block_begin)

        block_end   = '<TlagEnd>'
        block_end   = trim(block_end)


        call ExtractBlockFromBuffer(Me%ObjEnterData1, ClientNumber,                     &
                                    block_begin, block_end, BlockFound,                 &
                                    FirstLine, LastLine,                                &
                                    STAT = status)
        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR50")


cd43:   if (.NOT. BlockFound) then

            write(*,*)
            write(*,'(a)') 'Error reading file: ', FileName
            write(*,*)     '    Values should be detween labels:'
            write(*,*)     '        <TlagBegin>'
            write(*,*)     '            .'
            write(*,*)     '            .'
            write(*,*)     '            .'
            write(*,*)     '        <TlagEnd>'
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR60")

        end if cd43



        allocate (AuxVector(3), STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR70")



        do Line = FirstLine + 1, LastLine - 1        !Frank -start one line after firstline


            call GetData(AuxVector,                                                     &
                         Me%ObjEnterData1,                                              &
                         iflag, Buffer_Line  = Line, STAT = status)

            if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR80")

            if (iflag /= 3)                                                             &
                call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR90")


            i = int(AuxVector(1))
            j = int(AuxVector(2))

            if (Me%DDecomp%MasterOrSlave) then
                if (i>= Me%DDecomp%HaloMap%ILB .and. i<= Me%DDecomp%HaloMap%IUB+1) then
                    ii = i + 1 - Me%DDecomp%HaloMap%ILB
                else
                    cycle
                endif
                else
                ii = i
                if (ii < ILBWork .or. ii > IUBWork)                                     &
                    call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR100")

            endif

            if (Me%DDecomp%MasterOrSlave) then
                if (j>= Me%DDecomp%HaloMap%JLB .and. j<= Me%DDecomp%HaloMap%JUB+1) then
                    jj = j + 1 - Me%DDecomp%HaloMap%JLB
                else
                    cycle
                endif
            else
                jj = j
                if (jj < JLBWork .or. jj > JUBWork)                                     &
                    call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR110")
            endif

            Me%ComputeOptions%Tlag(ii, jj) = AuxVector(3)

            if(Me%ComputeOptions%Tlag(ii, jj) < Me%WaterLevel%DT )                      &
               Me%ComputeOptions%Tlag(ii, jj) = Me%WaterLevel%DT

        enddo

        deallocate (AuxVector, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR120")


        call Block_Unlock(Me%ObjEnterData1, ClientNumber, STAT = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR130")


        call KillEnterData(Me%ObjEnterData1, STAT = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructBlumbergKantha - Hydrodynamic - ERR140")

    End Subroutine ConstructBlumbergKantha


    Subroutine AllocateVariables

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------

        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB

        !integer :: ILBFather, IUBFather
        !integer :: JLBFather, JUBFather
        !integer :: KLBFather, KUBFather

        integer :: IJKLB, IJKUB, imin, imax

        integer :: STAT_CALL

        integer :: JImin, JImax

        !griflet
        type(T_Coef_Baroc), pointer :: LocalBaroc
        type(T_VECGW), pointer      :: VECGW
        integer                     :: p

        !Begin------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !Variables allocation
        allocate (Me%WaterLevel%New             (ILB:Pad(ILB, IUB), JLB:JUB         ))
        allocate (Me%WaterLevel%Old             (ILB:Pad(ILB, IUB), JLB:JUB         ))
        allocate (Me%WaterLevel%VolumeCreated   (ILB:Pad(ILB, IUB), JLB:JUB         ))
        if (Me%ComputeOptions%WaterLevelMaxMin) then
            allocate (Me%WaterLevel%Maxi            (ILB:Pad(ILB, IUB), JLB:JUB     ))
            allocate (Me%WaterLevel%Mini            (ILB:Pad(ILB, IUB), JLB:JUB     ))
        endif
        if (Me%ComputeOptions%TideStateON     ) then
            allocate (Me%WaterLevel%TideState       (ILB:Pad(ILB, IUB), JLB:JUB     ))
        endif

#ifdef _USE_PAGELOCKED
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%NewPtr, Me%Velocity%Horizontal%U%New, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%OldPtr, Me%Velocity%Horizontal%U%Old, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%NewPtr, Me%Velocity%Horizontal%V%New, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%OldPtr, Me%Velocity%Horizontal%V%Old, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Velocity%Vertical%CartesianPtr, Me%Velocity%Vertical%Cartesian, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate (Me%Velocity%Horizontal%U%New  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Velocity%Horizontal%U%Old  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Velocity%Horizontal%V%New  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Velocity%Horizontal%V%Old  (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Velocity%Vertical%Cartesian(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
#endif

        allocate (Me%Velocity%Vertical%Across   (ILB:IUB, JLB:JUB, KLB:KUB))

        allocate (Me%Velocity%BarotropicUc      (ILB:IUB, JLB:JUB         ))
        allocate (Me%Velocity%BarotropicVc      (ILB:IUB, JLB:JUB         ))

        ! guillaume
        if (Me%ComputeOptions%AltimetryAssimilation%Yes .or.                            &
            Me%ComputeOptions%Geost_Initialization) then
            Me%Geostroph%ON  = .true.
        endif

        if (Me%Geostroph%ON) then
            allocate (Me%Geostroph%U               (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Geostroph%V               (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Geostroph%AuxDesCentre    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Geostroph%PressGrad       (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Geostroph%U_barotropic    (ILB:Pad(ILB, IUB), JLB:JUB))
            allocate (Me%Geostroph%V_barotropic    (ILB:Pad(ILB, IUB), JLB:JUB))
            Me%Geostroph%U                      (:,:,:) = 0.
            Me%Geostroph%V                      (:,:,:) = 0.
            Me%Geostroph%AuxDesCentre           (:,:,:) = 0.
            Me%Geostroph%PressGrad              (:,:,:) = 0.
            Me%Geostroph%U_barotropic           (:,:)   = 0.
            Me%Geostroph%V_barotropic           (:,:)   = 0.
        endif

        Me%WaterLevel%New(:,:)                  = FillValueReal
        Me%WaterLevel%Old(:,:)                  = FillValueReal
        Me%WaterLevel%VolumeCreated(:,:)        = 0.

        if (Me%ComputeOptions%WaterLevelMaxMin) then
            Me%WaterLevel%Maxi(:,:)                 =  FillValueReal
            Me%WaterLevel%Mini(:,:)                 = -FillValueReal
        endif

        Me%Velocity%Horizontal%U%New  (:,:,:)     = FillValueReal
        Me%Velocity%Horizontal%U%Old  (:,:,:)     = FillValueReal
        Me%Velocity%Horizontal%V%New  (:,:,:)     = FillValueReal
        Me%Velocity%Horizontal%V%Old  (:,:,:)     = FillValueReal
        Me%Velocity%Vertical%Across   (:,:,:)     = FillValueReal
        Me%Velocity%Vertical%Cartesian(:,:,:)     = FillValueReal

        Me%Velocity%BarotropicUc      (:,:  )     = FillValueReal
        Me%Velocity%BarotropicVc      (:,:  )     = FillValueReal


        !Auxiliar horizontal velocity pointers
        nullify (Me%Velocity%Horizontal%UV%New)
        nullify (Me%Velocity%Horizontal%UV%Old)

        nullify (Me%Velocity%Horizontal%VU%New)
        nullify (Me%Velocity%Horizontal%VU%Old)

        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then

            allocate (Me%Velocity%Vertical%CartesianOld(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%PressureCorrect(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%PrevisionalQ(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%CCoef(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%NonHydrostatic%GCoef(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            Me%Velocity%Vertical%CartesianOld (:,:,:) = FillValueReal
            Me%NonHydrostatic%PressureCorrect (:,:,:) = FillValueReal
            Me%NonHydrostatic%PrevisionalQ(:, : ,:)   = FillValueReal

            allocate (Me%NonHydrostatic%VerticalSurfLayerOld(ILB:Pad(ILB, IUB), JLB:JUB))
            Me%NonHydrostatic%VerticalSurfLayerOld(:, :)   = FillValueReal

        endif



        allocate (Me%WaterFluxes%X          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%WaterFluxes%Y          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%WaterFluxes%Z          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%WaterFluxes%Discharges (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        if (Me%ComputeOptions%MomentumDischarge) then
            allocate (Me%WaterFluxes%DischargesVelU (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%WaterFluxes%DischargesVelV (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            Me%WaterFluxes%DischargesVelU(:,:,:) = 0.
            Me%WaterFluxes%DischargesVelV(:,:,:) = 0.
        endif

        Me%WaterFluxes%X         (:,:,:) = FillValueReal
        Me%WaterFluxes%Y         (:,:,:) = FillValueReal
        Me%WaterFluxes%Z         (:,:,:) = FillValueReal
        Me%WaterFluxes%Discharges(:,:,:) = FillValueReal

        !If compute Residual properties then must allocate residual variables
        nullify (Me%Residual%WaterLevel)

        nullify (Me%Residual%Velocity_U)
        nullify (Me%Residual%Velocity_V)

        nullify (Me%Residual%DWZ)

        nullify (Me%Residual%Vertical_Velocity)

        !Residual water fluxes
        nullify (Me%Residual%WaterFlux_X)
        nullify (Me%Residual%WaterFlux_Y)

        Me%Residual%ResidualTime = FillValueReal

cd1:    if (Me%ComputeOptions%Residual) then

            !Can be interesting to compute the average water level
            allocate (Me%Residual%WaterLevel        (ILB:Pad(ILB, IUB), JLB:JUB))
            allocate (Me%Residual%Velocity_U        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Residual%Velocity_V        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Residual%Vertical_Velocity (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Residual%WaterFlux_X       (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Residual%WaterFlux_Y       (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Residual%DWZ               (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))

            Me%Residual%WaterLevel          (:,:)   = FillValueReal
            Me%Residual%Velocity_U        (:,:,:)   = FillValueReal
            Me%Residual%Velocity_V        (:,:,:)   = FillValueReal
            Me%Residual%Vertical_Velocity (:,:,:)   = FillValueReal
            Me%Residual%WaterFlux_X       (:,:,:)   = FillValueReal
            Me%Residual%WaterFlux_Y       (:,:,:)   = FillValueReal
            Me%Residual%DWZ               (:,:,:)   = FillValueReal

        endif cd1


        !Forces
        allocate (Me%Forces%Rox3X                   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Forces%Rox3Y                   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))

        allocate (Me%Forces%Horizontal_Transport    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Forces%Inertial_Aceleration    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        allocate (Me%Forces%TidePotentialLevel      (ILB:Pad(ILB, IUB), JLB:JUB))

! Modified by Matthias DELPEY - 15/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 25/10/2011 - 25/11/2011
        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress)   then

            allocate (Me%Forces%Wave3DExplicit_Acceleration (ILB:IUB, JLB:JUB, KLB:KUB))

            Me%Forces%Wave3DExplicit_Acceleration(:,:,:)= 0.

        endif

        if (Me%ComputeOptions%WaveForcing3D == GLM)   then

            allocate (Me%Forces%Wave3DExplicit_Acceleration (ILB:IUB, JLB:JUB, KLB:KUB))

            allocate (Me%Forces%Wave3DExplicit_FPressureAccelU (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%Forces%Wave3DExplicit_FPressureAccelV (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%Forces%Wave3DExplicit_FPressureAccelUV (ILB:IUB, JLB:JUB, KLB:KUB))

            allocate (Me%Forces%Wave3DExplicit_FVortexAccelU (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%Forces%Wave3DExplicit_FVortexAccelV (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%Forces%Wave3DExplicit_FVortexAccelUV (ILB:IUB, JLB:JUB, KLB:KUB))
            ! allocate (Me%Forces%AdvectVelocity (ILB:IUB, JLB:JUB, KLB:KUB))

            allocate (Me%Forces%Wave3DExplicit_FBreakingAccelU (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%Forces%Wave3DExplicit_FBreakingAccelV (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%Forces%Wave3DExplicit_FBreakingAccelUV (ILB:IUB, JLB:JUB, KLB:KUB))

            Me%Forces%Wave3DExplicit_Acceleration       (:,:,:)= 0.

            Me%Forces%Wave3DExplicit_FPressureAccelU   (:,:,:)= 0.
            Me%Forces%Wave3DExplicit_FPressureAccelV   (:,:,:)= 0.
            Me%Forces%Wave3DExplicit_FPressureAccelUV  (:,:,:)= 0.

            Me%Forces%Wave3DExplicit_FVortexAccelU   (:,:,:)= 0.
            Me%Forces%Wave3DExplicit_FVortexAccelV   (:,:,:)= 0.
            Me%Forces%Wave3DExplicit_FVortexAccelUV  (:,:,:)= 0.
            ! Me%Forces%AdvectVelocity  (:,:,:)= 0.

            Me%Forces%Wave3DExplicit_FBreakingAccelU (:,:,:)= 0.
            Me%Forces%Wave3DExplicit_FBreakingAccelV (:,:,:)= 0.
            Me%Forces%Wave3DExplicit_FBreakingAccelUV(:,:,:)= 0.

        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if(Me%ComputeOptions%AltimetryAssimilation%Yes) then
            allocate (Me%Forces%Altim_Relax_Aceleration (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            Me%Forces%Altim_Relax_Aceleration(:,:,:)= 0.
        endif

        Me%Forces%Rox3X(:,:,:)                  = FillValueReal
        Me%Forces%Rox3Y(:,:,:)                  = FillValueReal
        Me%Forces%Horizontal_Transport(:,:,:)   = FillValueReal
        Me%Forces%Inertial_Aceleration(:,:,:)   = FillValueReal
        Me%Forces%TidePotentialLevel(:,:)       = FillValueReal

! Modified by Matthias DELPEY - 29/06/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 19/07/2011 - 27/07/2011 - 04/08/2011 - 19/08/2011 - 24/08/2011

        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then

            allocate (Me%WaveRad3D%WaveExpRadU  (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%WaveRad3D%WaveExpRadV  (ILB:IUB, JLB:JUB, KLB:KUB))

            Me%WaveRad3D%WaveExpRadU (:,:,:)  = 0.
            Me%WaveRad3D%WaveExpRadV (:,:,:)  = 0.

        endif


        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            ! Dimensions : analogie avec matrice Me%Velocity%Horizontal%U%New.
            ! Ne pas oublier qu'ici, IUB = Me%Size%IUB = Me%WorkSize%IUB + 1

            ! Allocate Stokes velocity fields
            allocate (Me%StokesVel%Horizontal%U%Old (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%StokesVel%Horizontal%U%New (ILB:IUB, JLB:JUB, KLB:KUB))

            allocate (Me%StokesVel%Horizontal%V%Old (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%StokesVel%Horizontal%V%New (ILB:IUB, JLB:JUB, KLB:KUB))

            allocate (Me%StokesVel%Vertical%Across (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%StokesVel%Vertical%Cartesian (ILB:IUB, JLB:JUB, KLB:KUB))

            allocate (Me%StokesVel%BottomStokesVertVel (ILB:IUB, JLB:JUB))

            Me%StokesVel%Horizontal%U%Old (:,:,:)        = 0.
            Me%StokesVel%Horizontal%U%New (:,:,:)        = 0.
            Me%StokesVel%Horizontal%V%Old (:,:,:)        = 0.
            Me%StokesVel%Horizontal%V%New (:,:,:)        = 0.

            Me%StokesVel%Vertical%Across (:,:,:)         = 0.
            Me%StokesVel%Vertical%Cartesian (:,:,:)      = 0.

            Me%StokesVel%BottomStokesVertVel (:,:)       = 0.

            ! Allocate Stokes water fluxes
            allocate (Me%StokesWaterFluxes%X          (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%StokesWaterFluxes%Y          (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (Me%StokesWaterFluxes%Z          (ILB:IUB, JLB:JUB, KLB:KUB))

            Me%StokesWaterFluxes%X         (:,:,:) = 0.
            Me%StokesWaterFluxes%Y         (:,:,:) = 0.
            Me%StokesWaterFluxes%Z         (:,:,:) = 0.

        endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        allocate (Me%Coef%D2%D                      (ILB:Pad(ILB, IUB), JLB:JUB))
        allocate (Me%Coef%D2%E                      (ILB:Pad(ILB, IUB), JLB:JUB))
        allocate (Me%Coef%D2%Eaux                   (ILB:Pad(ILB, IUB), JLB:JUB))
        allocate (Me%Coef%D2%F                      (ILB:Pad(ILB, IUB), JLB:JUB))
        allocate (Me%Coef%D2%Ti                     (ILB:Pad(ILB, IUB), JLB:JUB))
        allocate (Me%Coef%D2%TiAux                  (ILB:Pad(ILB, IUB), JLB:JUB))


        Me%Coef%D2%D(:,:)                       = FillValueReal
        Me%Coef%D2%E(:,:)                       = FillValueReal
        Me%Coef%D2%F(:,:)                       = FillValueReal
        Me%Coef%D2%Ti(:,:)                      = FillValueReal

        Me%Coef%D2%Eaux (:,:)                   = FillValueReal
        Me%Coef%D2%TiAux(:,:)                   = FillValueReal

        nullify (Me%Coef%D2%Rad  )
        nullify (Me%Coef%D2%TiRad)

cd2:    if (Me%ComputeOptions%BarotropicRadia == FlatherWindWave_ .or.      &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            allocate (Me%Coef%D2%Rad  (ILB:Pad(ILB, IUB), JLB:JUB))
            allocate (Me%Coef%D2%TiRad(ILB:Pad(ILB, IUB), JLB:JUB))

            Me%Coef%D2%Rad   = FillValueReal
            Me%Coef%D2%TiRad = FillValueReal
        endif cd2

#ifdef _USE_PAGELOCKED
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%DPtr, Me%Coef%D3%D, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%EPtr, Me%Coef%D3%E, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%FPtr, Me%Coef%D3%F, IUB + 1, JUB + 1, KUB + 1)
        call Alloc3DPageLocked(Me%ObjCuda, Me%Coef%D3%TiPtr, Me%Coef%D3%Ti, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate (Me%Coef%D3%D(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        allocate (Me%Coef%D3%E(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        allocate (Me%Coef%D3%F(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        allocate (Me%Coef%D3%Ti(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
#endif _USE_PAGELOCKED

        Me%Coef%D3%D = FillValueReal
        Me%Coef%D3%E = FillValueReal
        Me%Coef%D3%F = FillValueReal
        Me%Coef%D3%Ti = FillValueReal

        !Bottom boundary: these variables in the future must migrate to the module ModuleBottom
        allocate (Me%External_Var%ChezyZ    (ILB:Pad(ILB, IUB), JLB:JUB))
        allocate (Me%External_Var%ChezyVelUV(ILB:Pad(ILB, IUB), JLB:JUB))

        Me%External_Var%ChezyZ    (:,:) = 0.
        Me%External_Var%ChezyVelUV(:,:) = 0.

        IJKLB = MIN(ILB, JLB, KLB)
        IJKUB = MAX(IUB, JUB, KUB)

        allocate (Me%VECG_3D(IJKLB : IJKUB))
        allocate (Me%VECW_3D(IJKLB : IJKUB))

        Me%VECG_3D = FillValueReal
        Me%VECW_3D = FillValueReal


        JImin = MIN(ILB,JLB)
        JImax = MAX(IUB,JUB)

        allocate (Me%VECG_2D(JImin : JImax), STAT = STAT_CALL)
        allocate (Me%VECW_2D(JImin : JImax),    STAT = STAT_CALL)

        Me%VECG_2D = FillValueReal
        Me%VECW_2D = FillValueReal

        !griflet
        !griflet start
        !Me%MaxThreads=1
        !!$ Me%MaxThreads = omp_get_max_threads()

        Me%MaxThreads = openmp_num_threads

        allocate(Me%THOMAS)
        allocate(Me%THOMAS%COEF3)
        allocate(Me%THOMAS%VEC(1:Me%MaxThreads))

        allocate(Me%THOMAS2D)
        allocate(Me%THOMAS2D%COEF2)
        allocate(Me%THOMAS2D%VEC(1:Me%MaxThreads))

        allocate(Me%Coef%Baroc(1:Me%MaxThreads))

        do p=1,Me%MaxThreads

            LocalBaroc => Me%Coef%Baroc(p)

    cd3:    if (Me%ComputeOptions%Baroclinic) then

                allocate (LocalBaroc%Kleft       (KLB : KUB+1))
                allocate (LocalBaroc%Kright      (KLB : KUB+1))
                allocate (LocalBaroc%Depth_integ (KLB : KUB+1))
                allocate (LocalBaroc%Hcenter     (KLB : KUB+1))
                allocate (LocalBaroc%Hleft       (KLB : KUB+1))
                allocate (LocalBaroc%Hright      (KLB : KUB+1))
                allocate (LocalBaroc%HroLeft     (KLB : KUB+1))
                allocate (LocalBaroc%HroRight    (KLB : KUB+1))
                allocate (LocalBaroc%DensLeft    (KLB : KUB+1))
                allocate (LocalBaroc%DensRight   (KLB : KUB+1))

                LocalBaroc%Kleft         = FillValueInt
                LocalBaroc%Kright        = FillValueInt
                LocalBaroc%Depth_integ   = FillValueReal
                LocalBaroc%Hcenter       = FillValueReal
                LocalBaroc%Hleft         = FillValueReal
                LocalBaroc%Hright        = FillValueReal
                LocalBaroc%HroLeft       = FillValueReal
                LocalBaroc%HroRight      = FillValueReal
                LocalBaroc%DensLeft      = FillValueReal
                LocalBaroc%DensRight     = FillValueReal

            endif cd3

            VECGW => Me%THOMAS2D%VEC(p)

            allocate(VECGW%G(JImin:JImax))
            allocate(VECGW%W(JImin:JImax))

            VECGW => Me%THOMAS%VEC(p)

            allocate(VECGW%G(IJKLB:IJKUB))
            allocate(VECGW%W(IJKLB:IJKUB))

        enddo

        Me%THOMAS2D%COEF2%D => Me%Coef%D2%D
        Me%THOMAS2D%COEF2%F => Me%Coef%D2%F
        Me%THOMAS2D%TI => Me%Coef%D2%Ti
        Me%THOMAS2D%COEF2%E => Me%Coef%D2%E

        Me%THOMAS%COEF3%D => Me%Coef%D3%D
        Me%THOMAS%COEF3%F => Me%Coef%D3%F
        Me%THOMAS%Ti => Me%Coef%D3%Ti
        Me%THOMAS%COEF3%E => Me%Coef%D3%E

        !griflet: END

        if (Me%ComputeOptions%BarotropicRadia == BlumbergKantha_)           &
            call ConstructBlumbergKantha


        if (Me%ComputeOptions%BiHarmonic) then

            allocate (Me%ComputeOptions%BiHarmonicUX_VY(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%ComputeOptions%BiHarmonicUY_VX(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))

            Me%ComputeOptions%BiHarmonicUX_VY(:,:,:) = FillValueReal
            Me%ComputeOptions%BiHarmonicUY_VX(:,:,:) = FillValueReal


        endif

ic1:    if (Me%CyclicBoundary%ON) then

            imin = min (ILB, JLB, KLB)
            imax = max (IUB, JUB, KUB)

            allocate (Me%Coef%D1%a  (imin : imax))
            allocate (Me%Coef%D1%b  (imin : imax))
            allocate (Me%Coef%D1%bb (imin : imax))
            allocate (Me%Coef%D1%c  (imin : imax))
            allocate (Me%Coef%D1%r  (imin : imax))
            allocate (Me%Coef%D1%u  (imin : imax))
            allocate (Me%Coef%D1%x  (imin : imax))
            allocate (Me%Coef%D1%z  (imin : imax))
            allocate (Me%Coef%D1%gam(imin : imax))

            Me%Coef%D1%a(:)     = FillValueReal
            Me%Coef%D1%b(:)     = FillValueReal
            Me%Coef%D1%bb(:)    = FillValueReal
            Me%Coef%D1%c(:)     = FillValueReal
            Me%Coef%D1%r(:)     = FillValueReal
            Me%Coef%D1%u(:)     = FillValueReal
            Me%Coef%D1%x(:)     = FillValueReal
            Me%Coef%D1%z(:)     = FillValueReal
            Me%Coef%D1%gam(:)   = FillValueReal

        endif ic1

        if(Me%ComputeOptions%Obstacle)then

            allocate (Me%Drag%Coef                          (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%Forces%ObstacleDrag_Aceleration    (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))

            Me%Forces%ObstacleDrag_Aceleration(:,:,:) = 0.
            Me%Drag%Coef                      (:,:,:) = FillValueReal

        endif
        if(Me%ComputeOptions%Turbine) then
            allocate (Me%Forces%Turbine_Acceleration (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            Me%Forces%Turbine_Acceleration(:,:,:) = 0.
        endif
        if (Me%SubModel%ON) then

            nullify(Me%SubModel%Z)

            nullify(Me%SubModel%U_New )
            nullify(Me%SubModel%V_New )
            nullify(Me%SubModel%UV_New)

            nullify(Me%SubModel%U_Old )
            nullify(Me%SubModel%V_Old )
            nullify(Me%SubModel%UV_Old)


            nullify(Me%SubModel%DUZ_New )
            nullify(Me%SubModel%DVZ_New )

            nullify(Me%SubModel%DUZ_Old )
            nullify(Me%SubModel%DVZ_Old )
            nullify(Me%SubModel%DUVZ_Old)

            nullify(Me%SubModel%qX      )
            nullify(Me%SubModel%qY      )
            nullify(Me%SubModel%qXY     )
            nullify(Me%SubModel%qYX     )


            allocate (Me%SubModel%Z         (ILB:Pad(ILB, IUB), JLB:JUB))
            allocate (Me%SubModel%U_New     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DUZ_New   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%V_New     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DVZ_New   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%qX        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%qY        (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DUZ_Old   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%DVZ_Old   (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%U_Old     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
            allocate (Me%SubModel%V_Old     (ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))

            Me%SubModel%Z  (:,:  )          = FillValueReal
            Me%SubModel%U_New  (:,:,:)      = FillValueReal
            Me%SubModel%DUZ_New  (:,:,:)    = FillValueReal
            Me%SubModel%V_New(:,:,:)        = FillValueReal
            Me%SubModel%DVZ_New  (:,:,:)    = FillValueReal
            Me%SubModel%qX(:,:,:)           = FillValueReal
            Me%SubModel%qY(:,:,:)           = FillValueReal
            Me%SubModel%DUZ_Old(:,:,:)      = FillValueReal
            Me%SubModel%DVZ_Old(:,:,:)      = FillValueReal
            Me%SubModel%U_Old  (:,:,:)      = FillValueReal
            Me%SubModel%V_Old  (:,:,:)      = FillValueReal


        endif

        allocate(Me%Aux3DFlux(ILB:IUB, JLB:JUB, KLB:KUB))

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(FillValueReal))

        if(Me%ComputeOptions%EmersionTime)then

            allocate (Me%Emersion%EmersionTime  (ILB:Pad(ILB, IUB), JLB:JUB))
            allocate (Me%Emersion%ImmersionTime (ILB:Pad(ILB, IUB), JLB:JUB))

            Me%Emersion%EmersionTime (:,:)  = 0.0
            Me%Emersion%ImmersionTime(:,:)  = 0.0

            Me%Emersion%TotalSimulationTime = 0.0

        endif

        allocate (Me%FaceDensity(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB))
        Me%FaceDensity(:,:,:)  = SigmaDensityReference
      !----------------------------------------------------------------------

    end subroutine AllocateVariables

    !--------------------------------------------------------------------------
    !If needed the sub-modules responsible for the:
    !   - Turbulence
    !   - OpenBoundary
    !   - Discharges
    !   - Surface conditions
    !   - Bottom Conditions
    !will be construct in this subroutine

    subroutine Construct_Sub_Modules(DischargesID, AssimilationID)

        !Arguments-------------------------------------------------------------
        integer                         :: DischargesID
        integer                         :: AssimilationID

        !Local-----------------------------------------------------------------
        type (T_Lines),     pointer     :: LineX
        type (T_Polygon),   pointer     :: PolygonX, ModelDomainLimit
        type (T_XYZPoints), pointer     :: XYZPointsX
        character(len=StringLength)     :: DischargeName
        real                            :: CoordinateX, CoordinateY
        logical                         :: CoordinatesON, IgnoreOK
        logical                         :: WaterDischarges, ModelGOTM, ContinuousGOTM
        integer, dimension(:,:), pointer:: WaterPoints2D
        integer, dimension(:),   pointer:: VectorI, VectorJ, VectorK
        integer                         :: Id, Jd, Kd, dn, DischargesNumber, nC, aux, k
        integer                         :: SpatialEmission, nCells, DischVertical
        integer                         :: STAT_CALL
        real                            :: InterceptionRatio

        !----------------------------------------------------------------------


        WaterDischarges = Me%ComputeOptions%WaterDischarges

i1:     if (WaterDischarges) then

i2:          if (DischargesID == 0) then
                call Construct_Discharges(Me%ObjDischarges,                             &
                                          Me%ObjTime,                                   &
                                          STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR10'

                DischargesID = Me%ObjDischarges

                call GetDischargesNumber(Me%ObjDischarges, DischargesNumber, STAT  = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR20'

                !Gets WaterPoints2D
                call GetWaterPoints2D(Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR30'

                call GetGeometryKFloor(Me%ObjGeometry, Z = Me%External_Var%KFloor_Z, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                              &
                stop 'Construct_Sub_Modules - ModuleHydrodynamic - Failed to get Kfloor_Z.'

d1:             do dn = 1, DischargesNumber

                    if (IsUpscaling(Me%ObjDischarges, dn))then
                        if (UpscalingDischargeType(Me%ObjDischarges, dn) == UpscalingDischargeByVolume)then
                        !nothing to do
                        elseif (.NOT. Me%ComputeOptions%MomentumDischarge)then
                            write(*,*) 'If an upscaling discharge is set with method "momentum" , then keyword'
                            write(*,*) 'MOMENTUM_DISCHARGE must be active in module Hydrodynamic.dat'
                            stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR35'
                        endif
                        Me%ComputeOptions%UpscalingDischarge = .true.
                    endif


                    call GetDischargesGridLocalization(Me%ObjDischarges, dn,            &
                                                       DischVertical = DischVertical,   &
                                                       KGrid         = Kd,              &
                                                       CoordinateX   = CoordinateX,     &
                                                       CoordinateY   = CoordinateY,     &
                                                       CoordinatesON = CoordinatesON,   &
                                                       TimeX         = Me%CurrentTime,  &
                                                       STAT          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR40'

                    call GetDischargesIDName (Me%ObjDischarges, dn, DischargeName, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR50'

                    if (CoordinatesON) then
                        call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, Id, Jd, STAT = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                            stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR60'
                        endif

                        if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then

                            call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR70'

                            if (IgnoreOK) then
                                write(*,*) 'Discharge outside the domain - ',trim(DischargeName),' - ',trim(Me%ModelName)
                                cycle
                            else
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR80'
                            endif

                        endif

                        call CorrectsCellsDischarges(Me%ObjDischarges, dn, Id, Jd, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR90'
                    endif

                    call GetDischargeSpatialEmission(Me%ObjDischarges, dn, LineX, PolygonX, &
                                                     SpatialEmission,                   &
                                                     XYZPointsX = XYZPointsX,           &
                                                     STAT       = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR100'

i3:                 if (SpatialEmission == DischPoint_) then

                        call GetDischargesGridLocalization(Me%ObjDischarges, dn,            &
                                                           DischVertical = DischVertical,   &
                                                           Igrid         = Id,              &
                                                           JGrid         = Jd,              &
                                                           TimeX         = Me%CurrentTime,  &
                                                           STAT          = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR110'

                        if (WaterPoints2D(Id,Jd) /= WaterPoint) then
                            call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR120'

                            write(*,*) 'A discharge in an land cell I=',Id,' J=',Jd,'Model name=',trim(Me%ModelName)

                            if (IgnoreOK) then
                                write(*,*) 'Discharge in a land cell - ',trim(DischargeName),' - ',trim(Me%ModelName)
                                cycle
                            else
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR130'
                            endif
                        endif

                        !Allocation of Vectors I J and K- profile option for now only for upscaling
                        if (DischVertical == DischProfile_)then
                            if (IsUpscaling(Me%ObjDischarges, dn))then
                                nCells = Me%WorkSize%KUB - Me%External_Var%KFloor_Z(Id, Jd) + 1
                                allocate(VectorI(nCells), VectorJ(nCells), VectorK(nCells))
                                VectorJ(:) = Jd
                                VectorI(:) = Id
                            else
                                stop 'Discharge profile only implemented for upscaling'
                            endif

                        else
                            nCells    = 1
                            allocate(VectorI(nCells), VectorJ(nCells), VectorK(nCells))
                            VectorJ(nCells) = Jd
                            VectorI(nCells) = Id
                        endif

                    else i3

                        if (SpatialEmission == DischLine_) then
                            call GetCellZInterceptByLine(Me%ObjHorizontalGrid, LineX,       &
                                                         WaterPoints2D, VectorI, VectorJ,   &
                                                         VectorK, nCells, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR140'

                            if (nCells < 1) then

                                call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR150'

                                if (IgnoreOK) then
                                    write(*,*) 'Discharge line intercept 0 cells'
                                    cycle
                                else
                                    stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR160'
                                endif
                            else

                                if (Me%DDecomp%MasterOrSlave) then
                                    !Get model domain polygon
                                    call GetGridOutBorderPolygon(HorizontalGridID = Me%ObjHorizontalGrid, &
                                                                 Polygon          = ModelDomainLimit,     &
                                                                 STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR170'
                                    endif

                                    !Computes the % percentage of LineX intercepts model domain
                                    InterceptionRatio = PercentageLineInsidePolygon(LineX, ModelDomainLimit) / 100.
                                    !Set in Modules Discharges InterceptionRatio
                                    call SetDischargeInterceptionRatio(Me%ObjDischarges, dn, InterceptionRatio, &
                                                                       STAT = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR180'
                                    endif

                                    write(*,*) 'InterceptionRatio =',Me%DDecomp%MPI_ID, InterceptionRatio

                                    call UngetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                                             Polygon          = ModelDomainLimit,               &
                                                             STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR190'
                                    endif

                                endif

                            endif

                        endif


                        if (SpatialEmission == DischPolygon_) then
                            call GetCellZInterceptByPolygon(Me%ObjHorizontalGrid, PolygonX, &
                                                         WaterPoints2D, VectorI, VectorJ,   &
                                                         VectorK, nCells, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) then
                                stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR200'
                            endif

                            if (nCells < 1) then

                                call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR210'

                                if (IgnoreOK) then
                                    write(*,*) 'Discharge contains 0 center cells'
                                    write(*,*) 'Or the polygon is to small and is best to a discharge in a point or'
                                    write(*,*) 'the polygon not define properly'
                                else
                                    stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR220'
                                endif

                            else

                                if (Me%DDecomp%MasterOrSlave) then
                                    !Get model domain polygon
                                    call GetGridOutBorderPolygon(HorizontalGridID = Me%ObjHorizontalGrid, &
                                                                 Polygon          = ModelDomainLimit,     &
                                                                 STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR230'
                                    endif

                                    !Computes the % percentage of LineX intercepts model domain
                                    InterceptionRatio = PercentagePolygonInsidePolygon(PolygonX, ModelDomainLimit) / 100.
                                    !Set in Modules Discharges InterceptionRatio
                                    call SetDischargeInterceptionRatio(Me%ObjDischarges, dn, InterceptionRatio, &
                                                                       STAT = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR240'
                                    endif

                                    write(*,*) 'InterceptionRatio =',Me%DDecomp%MPI_ID, InterceptionRatio

                                    call UngetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                                             Polygon          = ModelDomainLimit,               &
                                                             STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR250'
                                    endif

                                endif


                            endif

                        endif

                        if (SpatialEmission == DischXYZPoints_) then
                            call GetCellZInterceptByXYZPoints(Me%ObjHorizontalGrid, XYZPointsX, &
                                                              VectorI, VectorJ, VectorK, nCells, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR260'

                            if (nCells < 1) then

                                call TryIgnoreDischarge(Me%ObjDischarges, dn, IgnoreOK, STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR27'

                                if (IgnoreOK) then
                                    write(*,*) 'Discharge contains probably 0 center cells'
                                else
                                    stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR280'
                                endif

                            else

                                if (Me%DDecomp%MasterOrSlave) then
                                    !Get model domain polygon
                                    call GetGridOutBorderPolygon(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                                                 Polygon          = ModelDomainLimit,               &
                                                                 STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR290'
                                    endif

                                    !Computes the % percentage of LineX intercepts model domain
                                    InterceptionRatio = PercentageXYZPointsInsidePolygon(XYZPointsX, ModelDomainLimit) / 100.
                                    !Set in Modules Discharges InterceptionRatio
                                    call SetDischargeInterceptionRatio(Me%ObjDischarges, dn, InterceptionRatio,     &
                                                                       STAT = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR300'
                                    endif

                                    write(*,*) 'InterceptionRatio =',Me%DDecomp%MPI_ID, InterceptionRatio

                                    call UngetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                                             Polygon          = ModelDomainLimit,               &
                                                             STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_)  then
                                        stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR310'
                                    endif

                                endif


                            endif

                        endif

                    endif i3

c1:                 select case (DischVertical)

                        case (DischLayer_)

                            VectorK(:) = Kd

                        case (DischDepth_)

                            write(*,*) "VERTICAL DISCHARGE option not active - Depth  =",DischDepth_
                            write(*,*) 'This option is not active'
                            stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR320'

                        case (DischBottom_)

n1:                         do nC =1, nCells

                                VectorK(nC) = Me%External_Var%Kfloor_Z(VectorI(nC), VectorJ(nC))

                            enddo n1

                        case (DischSurf_)

                            VectorK(:) = Me%WorkSize%KUB

                        case (DischUniform_)

                        case (DischProfile_)

                            !every index of Vector I and J is repeated n times, where n is KUB - Kfloor
                            !Only made for discharge point at this stage.
                            aux = 0

                            do k = Me%External_Var%KFloor_Z(VectorI(1), VectorJ(1)), Me%WorkSize%KUB
                                aux = aux + 1
                                VectorK(aux) = k
                            enddo

                        case default
                            write(*,*) "VERTICAL DISCHARGE option not known ", DischVertical

                            write(*,*) "The known options are : "," Bottom=",DischBottom_," Surface=",DischSurf_,&
                                                                  " Layer =",DischLayer_, " Depth  =",DischDepth_,&
                                                                  " Uniform=",DischUniform_
                            stop 'Construct_Sub_Modules - ModuleDischarges. ERR350'

                        end select c1


                    if (SpatialEmission /= DischPoint_) then
                        call SetLocationCellsZ (Me%ObjDischarges, dn, nCells, VectorI, VectorJ, VectorK, STAT= STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR360'

                    else

                        if (DischVertical == DischProfile_) then !Only for upscaling for now
                            call SetLocationCellsZ (Me%ObjDischarges, dn, nCells, VectorI, VectorJ, VectorK, STAT= STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Failed using SetLocationCellsZ for profile discharge'
                        endif

                        if (DischVertical == DischBottom_ .or. DischVertical == DischSurf_) then
                            call SetLayer (Me%ObjDischarges, dn, VectorK(nCells), STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR370'
                        endif
                        deallocate(VectorI, VectorJ, VectorK)
                    endif

                enddo d1

                call UnGetHorizontalMap(Me%ObjHorizontalMap, WaterPoints2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR380'

                call UnGetGeometry(Me%ObjGeometry, Me%External_Var%KFloor_Z, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                              &
                    stop 'Construct_Sub_Modules - ModuleHydrodynamic - Failed to unget Kfloor_Z'

            else  i2
                Me%ObjDischarges = AssociateInstance (mDISCHARGES_, DischargesID)
            endif i2

            if (Me%OutPut%TimeSerieDischON) then
                call Construct_Time_Serie_Discharge
            endif

        endif i1

i8:     if (Me%ComputeOptions%Relaxation .or. Me%ComputeOptions%AltimetryAssimilation%Yes) then

            if (AssimilationID == 0) then
                call StartAssimilation(Me%ObjAssimilation,                               &
                                       Me%ObjTime,                                       &
                                       Me%ObjGridData,                                   &
                                       Me%ObjHorizontalGrid,                             &
                                       Me%ObjHorizontalMap,                              &
                                       Me%ObjMap,                                        &
                                       Me%ObjGeometry,                                   &
                                       STAT = STAT_CALL)

                 if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR390'

                 AssimilationID = Me%ObjAssimilation
            else
                Me%ObjAssimilation = AssociateInstance (mASSIMILATION_, AssimilationID)
            endif

        endif i8


        call GetContinuousGOTM(Me%ObjTurbulence, ContinuousGOTM, ModelGOTM, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'Construct_Sub_Modules - Hydrodynamic - ERR400.')

i5:     if (ModelGOTM) then
i6:         if (Me%ComputeOptions%Continuous) then
i7:             if (.not. ContinuousGOTM)  then
                    write(*,*) 'Construct_Sub_Modules - Hydrodynamic - WARN01.'
                    write(*,*) 'Hydrodynamic - Continuous YES'
                    write(*,*) 'GOTM         - Continuous NO'
                    write(*,*) 'Press enter to procede OR controle break to stop the run'
                    read (*,*)
                endif i7
            endif i6

            if (.not.Me%ComputeOptions%Continuous) then
                if (ContinuousGOTM)                                                      &
                    call SetError(FATAL_, INTERNAL_, 'Construct_Sub_Modules - Hydrodynamic - ERR410.')
            endif
        endif i5


        !Opens the energy result file and allocates the buffer to store the data
        if (Me%ComputeOptions%Energy) &
            call ConstructEnergy

        if (Me%ComputeOptions%Relaxation) &
            call ConstructRelaxation


        !Allocates and initialise the variables necessary to compute
        !the tide potential
        if (Me%TidePotential%Compute)                                       &
            call ConstructTidePotential


        !Allocates and initialise the variables necessary to run this model as submodel
        if (Me%SubModel%ON)                                                 &
            call ConstructSubModel

        if (Me%ComputeOptions%Turbine)                                      &
            call ConstructTurbine(TurbineID = Me%ObjTurbine, HorizontalGridID = Me%ObjHorizontalGrid,   &
                                GeometryID = Me%ObjGeometry, TimeID = Me%ObjTime,OutPut= Me%OutPut%TurbineON, &
                                STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Sub_Modules - ModuleHydrodynamic - ERR420'

        call ConstructHydroStatistic


    end subroutine Construct_Sub_Modules
    !------------------------------------------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !>Checks if a discharge is of type "upscaling" and constructs it
    !>@param[in] FatherID, ObjHydrodynamicFather, SonID
    subroutine Set_Upscaling_Discharges(FatherID, ObjFather, SonID)
        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: FatherID, SonID
        type (T_Hydrodynamic), pointer, intent(IN)  :: ObjFather
        !Local-----------------------------------------------------------------
        integer                                     :: DischargeID, I, J, DischargesNumber, STAT_CALL
        integer                                     :: Task
        integer,  dimension(:,:), pointer           :: Connections, SonWaterPoints2D, FatherWaterPoints2D
        integer, dimension(:,:), pointer            :: IZ, JZ
        !----------------------------------------------------------------------

        Task = 1 !Flag to indicate that the code should only find the matrixes size for allocation

        call GetDischargesNumber(ObjFather%ObjDischarges, DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get number of discharges'
        call GetConnections(SonID, Connections_Z = Connections, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get Connections matrix'
        call GetWaterPoints2D(SonID, SonWaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get Son waterpoints'
        call GetWaterPoints2D(FatherID, FatherWaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get Father waterpoints'
        call GetHorizontalGrid (HorizontalGridID = SonID, ILinkZ = IZ, JLinkZ = JZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get ILinkZ or JLinkZ'

        do DischargeID = 1, DischargesNumber

            if (IsUpscaling(ObjFather%ObjDischarges, DischargeID))then

                call GetDischargesGridLocalization(ObjFather%ObjDischarges, DischargeID, Igrid = I, JGrid = J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get Discharge location'

                call ConstructUpscalingDischarges(SonID, I, J, Connections, SonWaterPoints2D, &
                                                  FatherWaterPoints2D, IZ, JZ, Task) !Managed by ModuleTwoWay
            endif

        enddo

        Task = 2 ! Allocate upscaling matrixes

        call ConstructUpscalingDischarges(SonID, I, J, Connections, SonWaterPoints2D, &
                                            FatherWaterPoints2D, IZ, JZ, Task) !Managed by ModuleTwoWay

        Task = 3 ! Fill connection matrixes

        do DischargeID = 1, DischargesNumber

            if (IsUpscaling(ObjFather%ObjDischarges, DischargeID))then

                call GetDischargesGridLocalization(ObjFather%ObjDischarges, DischargeID, Igrid = I, JGrid = J, &
                                                   STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to get Discharge location'

                call ConstructUpscalingDischarges(SonID, I, J, Connections, SonWaterPoints2D, &
                                                  FatherWaterPoints2D, IZ, JZ, Task) !Managed by ModuleTwoWay
            endif

        enddo

        call UnGetHorizontalGrid(SonID,    Connections,         STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to unget Connections matrix'
        call UnGetHorizontalMap (SonID,    SonWaterPoints2D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to unget SonWaterPoints2D'
        call UnGetHorizontalMap (FatherID, FatherWaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to unget FatherWaterPoints2D'
        call UngetHorizontalGrid(SonID,    IZ,                  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to unget ILinkZ'
        call UngetHorizontalGrid(SonID,    JZ,                  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Set_Upscaling_Discharges - Failed to unget JLinkZ'

    end subroutine Set_Upscaling_Discharges
    !------------------------------------------------------------------------------------------------------------------

#ifdef OVERLAP
    subroutine ConstructHydroOverlap


        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL, iflag

        !----------------------------------------------------------------------

        call GetData(Me%ComputeOptions%Overlap,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OVERLAP',                                        &
                     Default        = .false.,                                          &
                     SearchType     = FromFile,                                         &
                     ClientModule   ='ModuleWaterProperties',                           &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'ConstructHydroOverlap - ModuleHydrodynamic - ERR01'


    end subroutine ConstructHydroOverlap
#endif OVERLAP



    !End----------------------------------------------------------------------

!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------

!BOP
!
! !ROUTINE: ConstructHydroStatistic

! !INTERFACE:

    subroutine ConstructHydroStatistic

! !INPUT PARAMETERS:


! !DESCRIPTION:
!   This subroutine reads all the information needed to construct a statistic
!   object
!



! !REVISION HISTORY:
!  01Nov2002   Paulo Chambel  the ConstructHydroStatistic routine calls from
!                             the ModuleStatistic the routine ConstructStatistic


!EOP

!       Local ------------------------------------------------------------------------------
        integer                     :: Status
        integer                     :: iflag, FromFile, i

        !Begin----------------------------------------------------------------------------


        call GetExtractType     (FromFile = FromFile)

        !<BeginKeyword>
            !Keyword          : STATISTICS
            !<BeginDescription>
               !
               ! Checks out if the user pretends the statistics of the hydrodynamic properties
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Me%Statistics%ON,                                                  &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword      = 'STATISTICS',                                       &
                     Default      = .false.,                                            &
                     SearchType   =  FromFile,                                          &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT = Status)
        if (Status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR01')


        if (Me%Statistics%ON) then

            !<BeginKeyword>
                !Keyword          : STATISTICS_FILE
                !<BeginDescription>
                   !
                   ! The statistics definition file of the hydrodynamic properties
                   !
                !<EndDescription>
                !Type             : Character
                !Default          : Do not have
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not have
                !Search Type      : FromFile
            !<EndKeyword>
            call GetData(Me%Statistics%File,                                            &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword      = 'STATISTICS_FILE',                              &
                         SearchType   = FromFile,                                       &
                         ClientModule = 'ModuleHydrodynamic',                           &
                         STAT = Status)
            if (Status /= SUCCESS_ .or. iflag /= 1)                                     &
                call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR02')

            Me%Statistics%NProp = 4

            allocate(Me%Statistics%PropList(Me%Statistics%NProp))
            allocate(Me%Statistics%ID      (Me%Statistics%NProp))


            Me%Statistics%PropList(1) = VelocityU_
            Me%Statistics%PropList(2) = VelocityV_
            Me%Statistics%PropList(3) = VelocityW_
            Me%Statistics%PropList(4) = VelocityModulus_

            Me%Statistics%ID(:) = 0

            do i=1, Me%Statistics%NProp

                call ConstructStatistic (Me%Statistics%ID(i),                               &
                                         Me%ObjTime,                                        &
                                         Me%ObjHDF5,                                        &
                                         Me%Size,                                           &
                                         Me%WorkSize,                                       &
                                         Me%Statistics%File,                                &
                                         GetPropertyName (Me%Statistics%PropList(i)),       &
                                         STAT = Status)
                if (Status /= SUCCESS_)                                                     &
                    call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR04')
            enddo

        endif

        !<BeginKeyword>
            !Keyword          : STATISTICS_2D
            !<BeginDescription>
               !
               ! Checks out if the user pretends the statistics of the hydrodynamic properties
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : IN_DAD3D
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>
        call GetData(Me%Statistics2D%ON,                                                &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword      = 'STATISTICS_2D',                                    &
                     Default      = .false.,                                            &
                     SearchType   =  FromFile,                                          &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT = Status)
        if (Status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR01')

        if (Me%Statistics2D%ON) then

            !<BeginKeyword>
                !Keyword          : STATISTICS_FILE_2D
                !<BeginDescription>
                   !
                   ! The statistics definition file of the hydrodynamic properties
                   !
                !<EndDescription>
                !Type             : Character
                !Default          : Do not have
                !File keyword     : IN_DAD3D
                !Multiple Options : Do not have
                !Search Type      : FromFile
            !<EndKeyword>
            call GetData(Me%Statistics2D%File,                                          &
                 Me%ObjEnterData, iflag,                                                &
                 Keyword      = 'STATISTICS_FILE_2D',                                   &
                 SearchType   = FromFile,                                               &
                 ClientModule = 'ModuleHydrodynamic',                                   &
                 STAT = Status)
            if (Status /= SUCCESS_ .or. iflag /= 1)                                     &
                call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR07')

            Me%Statistics2D%NProp = 2

            allocate(Me%Statistics2D%PropList(Me%Statistics2D%NProp))

            Me%Statistics2D%PropList(1) = WaterLevel_
            Me%Statistics2D%PropList(2) = WaterColumn_

            allocate(Me%Statistics2D%ID      (Me%Statistics2D%NProp))
            Me%Statistics2D%ID(:) = 0


            do i=1, Me%Statistics2D%NProp

                call ConstructStatistic (Me%Statistics2D%ID(i),                             &
                                         Me%ObjTime,                                        &
                                         Me%ObjHDF5,                                        &
                                         Me%Size,                                           &
                                         Me%WorkSize,                                       &
                                         Me%Statistics2D%File,                              &
                                         GetPropertyName (Me%Statistics2D%PropList(i)),     &
                                         STAT = Status)
                if (Status /= SUCCESS_)                                                     &
                    call SetError(FATAL_, INTERNAL_, 'ConstructHydroStatistic - Hydrodynamic - ERR08')
            enddo
        endif


    end subroutine ConstructHydroStatistic

    !--------------------------------------------------------------------------




    !--------------------------------------------------------------------------

    subroutine StartOutputBoxFluxes

        !Arguments-------------------------------------------------------------



        !External--------------------------------------------------------------

        integer :: STAT_CALL
        integer :: iflag, FromFile
        integer :: ILB, IUB
        integer :: JLB, JUB
        integer :: KLB, KUB

        logical :: exist, opened
        character(len=StringLength), dimension(:),  pointer :: FluxesOutputList
        character(len=StringLength), dimension(:),  pointer :: ScalarOutputList

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'StartOutputBoxFluxes - ModuleHydrodynamic - ERR01'

        call GetExtractType  (FromFile = FromFile)

        !<BeginKeyword>
            !Keyword          : BOXFLUXES
            !<BeginDescription>
               !
               !The user can give the name of the file boxes definition
               !If this file exist then the model computes water fluxes between boxes
               !
            !<EndDescription>
            !Type             : Character
            !Default          : ******.***

            !File keyword     : IN_DAD3D
            !Multiple Options : Do not
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%Files%BoxFluxesFileName,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'BOXFLUXES',                                      &
                     Default        = '******.***',                                     &
                     SearchType     = FromFile,                                         &
                     ClientModule   ='ModuleHydrodynamic',                              &
                     STAT           = STAT_CALL)

        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Subroutine StartOutputBoxFluxes - ModuleHydrodynamic. ERR02.'

cd6 :   if (iflag .EQ. 1) then
            inquire(FILE = Me%Files%BoxFluxesFileName, EXIST = exist)
cd4 :       if (exist) then
                Me%State%BOXFLUXES = ACTIVE

                inquire(FILE = Me%Files%BoxFluxesFileName, OPENED  = opened)
cd5 :           if (opened) then
                    write(*,*    )
                    write(*,'(A)') 'BoxFluxesFileName = ', Me%Files%BoxFluxesFileName
                    write(*,*    ) 'Already opened.'
                    stop           'Subroutine StartOutputBoxFluxes; ModuleHydrodynamic. ERR04'
                end if cd5

                allocate(FluxesOutputList(1), ScalarOutputList(1))

                FluxesOutputList = Char_Water
                ScalarOutputList = Char_Water

                call StartBoxDif(BoxDifID         = Me%ObjBoxDif,                    &
                                 TimeID           = Me%ObjTime,                      &
                                 HorizontalGridID = Me%ObjHorizontalGrid,            &
                                 BoxesFilePath    = Me%Files%BoxFluxesFileName,      &
                                 FluxesOutputList = FluxesOutputList,                &
                                 ScalarOutputList = ScalarOutputList,                &
                                 WaterPoints3D    = Me%External_Var%WaterPoints3D,   &
                                 Size3D           = Me%Size,                         &
                                 WorkSize3D       = Me%WorkSize,                     &
                                 STAT             = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                         &
                    stop 'Subroutine StartOutputBoxFluxes - ModuleWaterProperties. ERR15.'

                deallocate(FluxesOutputList, ScalarOutputList)
                nullify   (FluxesOutputList, ScalarOutputList)

            else
                write(*,*)
                write(*,*)     'Error dont have the file box.'
                write(*,'(A)') 'BoxFileName = ', Me%Files%BoxFluxesFileName
                stop           'Subroutine StartOutputBoxFluxes; ModuleHydrodynamic. ERR03'
            end if cd4

        else
            Me%State%BOXFLUXES = IDLE
        end if cd6

        call UnGetMap (Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'StartOutputBoxFluxes - ModuleHydrodynamic - ERR99'


        !----------------------------------------------------------------------

    end subroutine StartOutputBoxFluxes

    !--------------------------------------------------------------------------
!-------------------------------------------------------------------------
!        IST/MARETEC, Marine Modelling Group, Mohid2000 modelling system
!-------------------------------------------------------------------------

!BOP
!
! !ROUTINE: Construct_OutPutTime

! !INTERFACE:

    subroutine Construct_OutPutTime

! !INPUT PARAMETERS:

! !DESCRIPTION:
!     This routine is a public one and is responsible for the definition
!     of the hydrodynamic output results


! !REVISION HISTORY:
!  20Nov2000   Paulo Chambel  the Construct_OutPutTime calls from
!                             the ModuleEnterData the routine GetOutPutTime



!EOP

!       Local ------------------------------------------------------------------------------
        integer                             :: STAT_CALL
        integer                             :: iflag, iW
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB

        !Begin----------------------------------------------------------------------------


        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime   = Me%CurrentTime,                              &
                           EndTime       = Me%EndTime,                                  &
                           keyword       = 'OUTPUT_TIME',                               &
                           SearchType    = FromFile,                                    &
                           OutPutsTime   = Me%OutPut%OutTime,                           &
                           OutPutsOn     = Me%OutPut%HDF5ON,                            &
                           OutPutsNumber = Me%OutPut%Number,                            &
                           STAT          = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR10')


        if (Me%OutPut%HDF5ON) then

            Me%OutPut%NextOutPut = 1

        else

            if(Me%OutPut%FloodRisk)then
                write(*,*)"Please activate HDF Hydrodynamic outputs in order to compute flood risk"
                call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR20')
            endif

        endif



        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime  = Me%CurrentTime,                               &
                           EndTime      = Me%EndTime,                                   &
                           keyword      = 'RESTART_FILE_OUTPUT_TIME',                   &
                           SearchType   = FromFile,                                     &
                           OutPutsTime  = Me%OutPut%RestartOutTime,                     &
                           OutPutsOn    = Me%OutPut%WriteRestartFile,                   &
                           STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR30')

        if(Me%OutPut%WriteRestartFile)then

            Me%OutPut%NextRestartOutput = 1

        end if

        !<BeginKeyword>
            !Keyword          : RESTART_FILE_OVERWRITE
            !<BeginDescription>
               !
               ! This option checks wether the restart file is to be overwritten or not
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%OutPut%RestartOverwrite,                                        &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'RESTART_FILE_OVERWRITE',                           &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "Construct_OutPutTime - Hydrodynamic - ERR40")


        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime  = Me%CurrentTime,                               &
                           EndTime      = Me%EndTime,                                   &
                           keyword      = 'SURFACE_OUTPUT_TIME',                        &
                           SearchType   = FromFile,                                     &
                           OutPutsTime  = Me%OutPut%SurfaceOutTime,                     &
                           OutPutsOn    = Me%OutPut%HDF5_Surface_ON,                    &
                           OutputsNumber= Me%OutPut%NumberSurfaceOutputs,               &
                           STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR50')

        if(Me%OutPut%HDF5_Surface_ON)then

            Me%OutPut%NextSurfaceOutput = 1

        end if

        call GetData(Me%OutPut%Faces,                                                   &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'OUTPUT_FACES',                                     &
                     Default      = .false.,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, 'Construct_OutPutTime - Hydrodynamic - ERR60')

        call GetOutPutTimeWindows(EnterDataID     = Me%ObjEnterData,                    &
                                  CurrentTime     = Me%CurrentTime,                     &
                                  EndTime         = Me%EndTime,                         &
                                  OutPutWindows   = Me%OutW%OutPutWindows,              &
                                  OutPutWindowsON = Me%OutW%OutPutWindowsON,            &
                                  WindowsNumber   = Me%OutW%WindowsNumber,              &
                                  STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR70')

         if(Me%OutW%OutPutWindowsON)then

            allocate(Me%OutW%ObjHDF5        (Me%OutW%WindowsNumber))
            allocate(Me%OutW%OriginalCorners(Me%OutW%WindowsNumber))


            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            do iW = 1, Me%OutW%WindowsNumber

                if (Me%DDecomp%MasterOrSlave) then

                    ILB = Me%DDecomp%Global%ILB
                    IUB = Me%DDecomp%Global%IUB
                    JLB = Me%DDecomp%Global%JLB
                    JUB = Me%DDecomp%Global%JUB

                else

                    ILB = Me%WorkSize%ILB
                    IUB = Me%WorkSize%IUB
                    JLB = Me%WorkSize%JLB
                    JUB = Me%WorkSize%JUB

                endif

                if (Me%OutW%OutPutWindows(iW)%KLB < KLB .or.                            &
                    Me%OutW%OutPutWindows(iW)%KUB > KUB .or.                            &
                    Me%OutW%OutPutWindows(iW)%KLB > KUB .or.                            &
                    Me%OutW%OutPutWindows(iW)%KUB < KLB) then
                    write(*,*) 'Cell layers out of the model domain for the output window number',iW
                    !stop 'Construct_OutPutTime - Hydrodynamic - ERR73'
                    write(*,*) 'All model layers will be assumed for the window output'
                    Me%OutW%OutPutWindows(iW)%KLB = KLB
                    Me%OutW%OutPutWindows(iW)%KUB = KUB

                endif

                if (Me%OutW%OutPutWindows(iW)%ILB < ILB .or.                            &
                    Me%OutW%OutPutWindows(iW)%IUB > IUB .or.                            &
                    Me%OutW%OutPutWindows(iW)%JLB < JLB .or.                            &
                    Me%OutW%OutPutWindows(iW)%JUB > JUB) then

                    write(*,*) 'cell corners out of the model domain for the output window number',iW
                    stop 'Construct_OutPutTime - Hydrodynamic - ERR75'

                endif

                Me%OutW%OutPutWindows%NextOutPut = 1

                Me%OutW%OriginalCorners(iW)%ILB = Me%OutW%OutPutWindows(iW)%ILB
                Me%OutW%OriginalCorners(iW)%IUB = Me%OutW%OutPutWindows(iW)%IUB
                Me%OutW%OriginalCorners(iW)%JLB = Me%OutW%OutPutWindows(iW)%JLB
                Me%OutW%OriginalCorners(iW)%JUB = Me%OutW%OutPutWindows(iW)%JUB

                Me%OutW%OutPutWindows(iW)%ON    = .true.

            enddo

        end if

        !<BeginKeyword>
            !Keyword          : SIMPLE_WINDOW_OUTPUT
            !<BeginDescription>
               !
               ! This option checks wether the end user wants to output only the basic properties in the window output
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%OutW%Simple,                                                    &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'SIMPLE_WINDOW_OUTPUT',                             &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "Construct_OutPutTime - Hydrodynamic - ERR80")


        !<BeginKeyword>
            !Keyword          : SIMPLE_OUTPUT
            !<BeginDescription>
               !
               ! This option checks wether the end user wants to output only the basic properties in the global output
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%OutPut%Simple,                                                  &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'SIMPLE_OUTPUT',                                    &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "Construct_OutPutTime - Hydrodynamic - ERR90")

        !Override to allow the output of fields associated with the option WaterLevelMaxMin
        if (Me%ComputeOptions%WaterLevelMaxMin) then
            Me%OutPut%Simple = .false.
        endif


        call GetData(Me%Output%Real4,                                                   &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'OUTPUT_HDF_REAL4',                                 &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "Construct_OutPutTime - Hydrodynamic - ERR100")


    end subroutine Construct_OutPutTime

    !----------------------------------------------------------------------------

    subroutine ConstructHydrodynamicProperties

        !Local----------------------------------------------------------------
        real,    dimension(:,:  ), pointer  :: Bathymetry
        integer, dimension(:,:,:), pointer  :: InitialComputeFacesU3D, InitialComputeFacesV3D
        real                                :: InteriorElevation
        real                                :: AverageBoundaryElevation
        real                                :: MinWaterColumn
        integer                             :: ILB, IUB
        integer                             :: JLB, JUB
        integer                             :: KLB, KUB
        integer                             :: i, j, k, STAT_CALL, Evolution
        integer                             :: InputStateEx

        !Begin----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB


        !The open boundary module must be initialised here because the OpenBoundary is
        !used in this subroutine to estimate the initial water level.
        call ConstructOpenBoundary(Me%ObjOpenBoundary,                                  &
                                   Me%ObjHorizontalGrid,                                &
                                   Me%ObjHorizontalMap,                                 &
                                   Me%ObjTime,                                          &
                                   Me%ComputeOptions%Compute_Tide,                      &
                                   Me%WaterLevel%Default,                               &
                                   Me%ComputeOptions%TideSlowStartCoef,                 &
                                   Me%ComputeOptions%InvertBarometer,                   &
                                   Me%ComputeOptions%InvertBaromSomeBound,              &
                                   Me%ComputeOptions%InvertBarometerCells,              &
                                   STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ConstructHydrodynamicProperties; ModuleHydrodynamic. ERR10.'

do1:    do  j=JLB, JUB
do2:    do  i=ILB, IUB

do3:        do  k=KLB, KUB
                !Explicit Forces
                Me%Forces%Horizontal_Transport          (i, j, k) = 0.
                Me%Forces%Inertial_Aceleration          (i, j, k) = 0.
                Me%Forces%Rox3X                         (i, j, k) = 0.
                Me%Forces%Rox3Y                         (i, j, k) = 0.
            enddo do3

            do  k=KLB, KUB+1
                !Vertical velocity
                Me%Velocity%Vertical%Across             (i, j, k) = 0.
                Me%Velocity%Vertical%Cartesian          (i, j, k) = 0.
                !NonHydrostatic
                if (Me%NonHydrostatic%ON) then
                    Me%Velocity%Vertical%CartesianOld   (i, j, k) = 0.
                    Me%NonHydrostatic%PressureCorrect   (i, j, k) = 0.
                    Me%NonHydrostatic%PrevisionalQ      (i, j, k) = 0.
                endif
            enddo

            if (Me%NonHydrostatic%ON) then
                Me%NonHydrostatic%VerticalSurfLayerOld(i, j) = 0.
            endif

            !Tide potential
            Me%Forces%TidePotentialLevel   (i, j) = 0.

        enddo do2
        enddo do1

cd1:    if (Me%ComputeOptions%Continuous) then

            call Read_Final_Hydrodynamic_File

        else cd1


cd2:        if (Me%ComputeOptions%Num_Discretization == Leendertse) then

                !By default the previous direction is X to alow the model start
                !the calculations in X direction when using the Leendertse Scheme
                Me%Direction%XY = DirectionX_
                Me%Direction%YX = DirectionY_

            else if (Me%ComputeOptions%Num_Discretization == Abbott) then cd2


                !By default the previous direction is Y to alow the model start
                !the calculations in X direction when using the Abbott Scheme
                Me%Direction%XY = DirectionY_
                Me%Direction%YX = DirectionX_


            endif cd2


            if      (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionX_) then

                Me%Direction%XY = DirectionX_
                Me%Direction%YX = DirectionY_

            else if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == DirectionY_) then

                Me%Direction%XY = DirectionY_
                Me%Direction%YX = DirectionX_

            endif

            !Gets Bathymetry
            call GetGridData(Me%ObjGridData, &
                               Bathymetry, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR20'


            call GetGeometryMinWaterColumn(Me%ObjGeometry, &
                                           MinWaterColumn, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR30'



            !Water elevation initialization
            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                &
                                     Me%CurrentTime,                                    &
                                     Me%External_Var%AtmosphericPressure,               &
                                     Me%ComputeOptions%AtmosphereCoef,                  &
                                     Me%ComputeOptions%InvertBaroCoef,                  &
                                     Me%ComputeOptions%AtmSeaLevelReference,            &
                                     STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR40'

            call GetAverageImposedElevation (Me%ObjOpenBoundary, &
                                             AverageBoundaryElevation, STAT =STAT_CALL )

            if (STAT_CALL /= SUCCESS_)                                        &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR50'


cd3:        if (Me%ComputeOptions%InitialElevation) then

                InteriorElevation = Me%WaterLevel%Default

            else  cd3

                InteriorElevation = AverageBoundaryElevation

            endif cd3

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR60'


do4:        do  j=JLB, JUB
do5:        do  i=ILB, IUB

cd4:            if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then

cd5:                if (InteriorElevation > (- Bathymetry(i, j) + MinWaterColumn)) then

                        Me%WaterLevel%New(i, j) =  InteriorElevation

                    else  cd5

                        !The next line is changed to avoid rounding erros.
                        !Frank Jan 2001
!                        Me%WaterLevel%New(i, j) =  - Bathymetry(i, j) + MinWaterColumn
                        Me%WaterLevel%New(i, j) =  - Bathymetry(i, j) + 0.999 * MinWaterColumn

                    endif cd5

                    Me%WaterLevel%Old(i, j) = Me%WaterLevel%New(i, j)

                endif cd4

            enddo do5
            enddo do4

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, &
                                  Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR70'


cd6:        if (Me%ComputeOptions%Residual) then

do8:            do  j=JLB, JUB
do9:            do  i=ILB, IUB

                    Me%Residual%WaterLevel(i, j) = Me%WaterLevel%New(i, j)

                enddo do9
                enddo do8

            endif cd6


            ! Z direction
do10:       do  k=KLB, KUB+1
do11:       do  j=JLB, JUB
do12:       do  i=ILB, IUB

                Me%WaterFluxes%Z(i, j, k) =    0.

                if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)  then

                    Me%VelBaroclinic%W_New   (i, j, k) =   0.
                    Me%VelBaroclinic%W_Old   (i, j, k) =   0.

                endif


cd7:            if (Me%ComputeOptions%Residual) then

                    !Vertical velocity
                    Me%Residual%Vertical_Velocity (i, j, k) = 0.

                endif cd7

            enddo do12
            enddo do11
            enddo do10

            if (Me%ComputeOptions%Residual) then
                !Number of iterations where residual properties was compute
                Me%Residual%ResidualTime    = 0
                !Residual Layer Thickness
                Me%Residual%DWZ(ILB:IUB, JLB:JUB, KLB:KUB) = 0.

            endif


            !X direction
do13:       do  k=KLB, KUB
do14:       do  j=JLB, JUB + 1
do15:       do  i=ILB, IUB

                !Horizontal Velocity
                Me%Velocity%Horizontal%U%New(i, j, k) =                     &
                    Me%Velocity%Horizontal%U%Default

                !Water fluxes D3
                Me%WaterFluxes%X(i, j, k)             =   0.

                if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)  then

                    Me%VelBaroclinic%U%New(i, j, k) =   0.
                    Me%VelBaroclinic%U%Old(i, j, k) =   0.

                endif



cd8:            if (Me%ComputeOptions%Residual) then


                    !Horizontal velocity
                    Me%Residual%Velocity_U(i, j, k)   =   0.

                    !Residual specific water fluxes
                    Me%Residual%WaterFlux_X(i, j, k)  =   0.

                endif cd8

            enddo do15
            enddo do14
            enddo do13


            ! Y direction
do16:       do  k=KLB, KUB
do17:       do  j=JLB, JUB
do18:       do  i=ILB, IUB + 1

                !Horizontal Velocity
                Me%Velocity%Horizontal%V%New(i, j, k) = Me%Velocity%Horizontal%V%Default



                !Water fluxes D3
                Me%WaterFluxes%Y(i, j, k)                =   0.

                if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)  then

                    Me%VelBaroclinic%V%New(i, j, k) =   0.
                    Me%VelBaroclinic%V%Old(i, j, k) =   0.

                endif


cd9:            if (Me%ComputeOptions%Residual) then

                    !Horizontal velocity
                    Me%Residual%Velocity_V (i, j, k)  =   0.

                    !Residual water fluxes
                    Me%Residual%WaterFlux_Y(i, j, k)  =   0.

                endif cd9

            enddo do18
            enddo do17
            enddo do16


            !Disposes pointer to the Bathymetry
            call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ConstructHydrodynamicProperties - ModuleHydrodynamic - ERR80'



        endif cd1




        !If the hydrodynamic is read from a file
        Evolution = Me%ComputeOptions%Evolution


cd10:   if (Evolution == Read_File_) then
            call GetHydrodynamicFileIOState(InputStateEx = InputStateEx)
            call StartHydrodynamicFile (Me%ObjHydrodynamicFileIn,                       &
                                        Me%ObjGridData,                                 &
                                        Me%ObjHorizontalGrid,                           &
                                        Me%ObjGeometry,                                 &
                                        Me%ObjMap,                                      &
                                        Me%ObjHorizontalMap,                            &
                                        Me%ObjTime,                                     &
                                        InputStateEx,                                   &
                                        InitialWaterLevel      =                        &
                                        Me%WaterLevel%New,                              &
                                        InitialWaterFluxX      =                        &
                                        Me%WaterFluxes%X,                               &
                                        InitialWaterFluxY      =                        &
                                        Me%WaterFluxes%Y,                               &
                                        InitialDischarges      =                        &
                                        Me%WaterFluxes%Discharges,                      &
                                        InitialComputeFacesU3D =                        &
                                        InitialComputeFacesU3D,                         &
                                        InitialComputeFacesV3D =                        &
                                        InitialComputeFacesV3D,                         &
                                        STAT = STAT_CALL)

             if (STAT_CALL /= SUCCESS_)                                                 &
                stop 'Subroutine ConstructHydrodynamicProperties - ModuleHydrodynamic. ERR90.'

             call SetComputesFaces3D(Me%ObjMap,                                         &
                                InitialComputeFacesU3D,                                 &
                                InitialComputeFacesV3D,                                 &
                                Me%CurrentTime,                                         &
                                STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ConstructHydrodynamicProperties - ModuleHydrodynamic. ERR100.'

            nullify(InitialComputeFacesU3D, InitialComputeFacesV3D)

        endif cd10

        if(Me%ComputeOptions%Obstacle)then

            call ConstructDragCoefficients

        end if

        if (Me%ComputeOptions%Scraper) then

            call ConstructScraper

        endif

        !------------------------------------------------------------------------

    end subroutine ConstructHydrodynamicProperties

    !----------------------------------------------------------------------------


    !----------------------------------------------------------------------------

    subroutine InitialReferenceWaterFluxes

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_X, WaterFlux_Y
        real,    dimension(:,:,:), pointer :: Velocity_U, Velocity_V, Area_U, Area_V

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:),   pointer :: KFloor_U, KFloor_V

        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, Grid, Evolution

        !--------------------------------------------------------------------------

        !If the hydrodynamic is read from a file
        Evolution = Me%ComputeOptions%Evolution


        !PCL
cd1:    if (.not. Me%ComputeOptions%Continuous .and.                        &
            .not. Evolution == Read_File_ .and. Me%Relaxation%Velocity )  then


            !To let the model take access to the Mapping and geometry variables
            call ReadLock_External_Modules


            !Begin - Shorten variables name
            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB
            KLB = Me%WorkSize%KLB


            WaterFlux_X      => Me%WaterFluxes%X
            WaterFlux_Y      => Me%WaterFluxes%Y

            Velocity_U       => Me%Velocity%Horizontal%U%New
            Velocity_V       => Me%Velocity%Horizontal%V%New

            ComputeFaces3D_U => Me%External_Var%ComputeFaces3D_U
            ComputeFaces3D_V => Me%External_Var%ComputeFaces3D_V

            KFloor_U         => Me%External_Var%KFloor_U
            KFloor_V         => Me%External_Var%KFloor_V

            Area_U           => Me%External_Var%Area_U
            Area_V           => Me%External_Var%Area_V


            !End - Shorten variables name

            call SetMatrixValue(WaterFlux_X, Me%WorkSize, dble(0.0))

        doj: do j = JLB, JUB
        doi: do i = ILB, IUB

        Cov1:   if (ComputeFaces3D_U(I, J, KUB) == Covered) then

                    Kbottom = KFloor_U(i, j)

        dok:        do  k = Kbottom, KUB

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_X(i, j, k) = Velocity_U(i, j, k) * &
                                                dble(Area_U(i, j, k))
                    enddo dok

                endif Cov1

            enddo doi
            enddo doj

            call SetMatrixValue(WaterFlux_Y, Me%WorkSize, dble(0.0))

        doj1: do j = JLB, JUB
        doi1: do i = ILB, IUB

        Cov2:   if (ComputeFaces3D_V(I, J, KUB) == Covered) then

                    Kbottom = KFloor_V(i, j)

        dok1:        do  k = Kbottom, KUB

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_Y(i, j, k) = Velocity_V(i, j, k) * &
                                                dble(Area_V(i, j, k))
                    enddo dok1

                endif Cov2

            enddo doi1
            enddo doj1

            !Nullify auxiliar variables
            nullify (WaterFlux_X)
            nullify (WaterFlux_Y)
            nullify (Velocity_U)
            nullify (Velocity_V)

            nullify (ComputeFaces3D_U)
            nullify (ComputeFaces3D_V)

            nullify (KFloor_U)
            nullify (KFloor_V)

            nullify (Area_U)
            nullify (Area_V)

            call ModifyWaterDischarges

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            !Unget the Mapping and geometry variables
            call ReadUnLock_External_Modules

        endif cd1


        !This is necessary because the Residual Vertical flux is not been compute
cd2:    if (Me%ComputeOptions%Evolution == Residual_hydrodynamic_ .or.      &
            Me%ComputeOptions%Evolution == No_hydrodynamic_) then

            !To let the model take access to the Mapping and geometry variables
            call ReadLock_External_Modules

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            !Unget the Mapping and geometry variables
            call ReadUnLock_External_Modules

        endif cd2


    end subroutine InitialReferenceWaterFluxes

    !----------------------------------------------------------------------------

    subroutine InitialHydrodynamicFileVel

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_X, WaterFlux_Y
        real,    dimension(:,:,:), pointer :: Velocity_U, Velocity_V, Area_U, Area_V

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:),   pointer :: KFloor_U, KFloor_V

        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, Evolution, Grid

        !--------------------------------------------------------------------------

        !If the hydrodynamic is read from a file
        Evolution = Me%ComputeOptions%Evolution

cd1:    if (Evolution == Read_File_) then

            !To let the model take access to the Mapping and geometry variables
            call ReadLock_External_Modules


            !Begin - Shorten variables name
            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB
            KLB = Me%WorkSize%KLB


            WaterFlux_X      => Me%WaterFluxes%X
            WaterFlux_Y      => Me%WaterFluxes%Y

            Velocity_U       => Me%Velocity%Horizontal%U%New
            Velocity_V       => Me%Velocity%Horizontal%V%New

            ComputeFaces3D_U => Me%External_Var%ComputeFaces3D_U
            ComputeFaces3D_V => Me%External_Var%ComputeFaces3D_V

            KFloor_U         => Me%External_Var%KFloor_U
            KFloor_V         => Me%External_Var%KFloor_V

            Area_U           => Me%External_Var%Area_U
            Area_V           => Me%External_Var%Area_V


            !End - Shorten variables name



            Velocity_U(:,:,:) = 0.

        doj: do j = JLB, JUB
        doi: do i = ILB, IUB

        Cov1:   if (ComputeFaces3D_U(I, J, KUB) == Covered) then

                    Kbottom = KFloor_U(i, j)

        dok:        do  k = Kbottom, KUB

                        ! [m/s]               = [m^3/s] / [m^2]
                        Velocity_U(i, j, k)   = real(WaterFlux_X(i, j, k) /              &
                                                dble(Area_U(i, j, k)))
                    enddo dok

                endif Cov1

            enddo doi
            enddo doj


            Velocity_V(:,:,:) = 0.

        doj1: do j = JLB, JUB
        doi1: do i = ILB, IUB

        Cov2:   if (ComputeFaces3D_V(I, J, KUB) == Covered) then

                    Kbottom = KFloor_V(i, j)

        dok1:        do  k = Kbottom, KUB

                        ! [m/s]               = [m^3/s] / [m^2]
                        Velocity_V(i, j, k)   = real(WaterFlux_Y(i, j, k) /              &
                                                dble(Area_V(i, j, k)))
                    enddo dok1

                endif Cov2

            enddo doi1
            enddo doj1

            !Nullify auxiliar variables
            nullify (WaterFlux_X)
            nullify (WaterFlux_Y)
            nullify (Velocity_U)
            nullify (Velocity_V)

            nullify (ComputeFaces3D_U)
            nullify (ComputeFaces3D_V)

            nullify (KFloor_U)
            nullify (KFloor_V)

            nullify (Area_U)
            nullify (Area_V)

            call ModifyWaterDischarges

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            !Unget the Mapping and geometry variables
            call ReadUnLock_External_Modules

        endif cd1


    end subroutine InitialHydrodynamicFileVel


    !----------------------------------------------------------------------------

    subroutine NewEqualsOld

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------

            Me%Velocity%Horizontal%U%Old(:,:,:) = Me%Velocity%Horizontal%U%New(:,:,:)
            Me%Velocity%Horizontal%V%Old(:,:,:) = Me%Velocity%Horizontal%V%New(:,:,:)

            Me%WaterLevel%Old(:,:)              = Me%WaterLevel%New(:,:)

    end subroutine NewEqualsOld

!-----------------------------------------------------------------------------

    subroutine Initial_Geometry( ExternalWaterLevel)

        !Arguments------------------------------------------------------------
        real, dimension(:,:), pointer, optional  :: ExternalWaterLevel

        !Local----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: WaterPoints3D
        real,    dimension(:,:  ), pointer  :: SurfaceElevation, Bathymetry
        real                                :: MinWaterColumn
        type(T_Time)                        :: CurrentTime
        logical                             :: Continuous_Compute
        integer                             :: STAT_CALL, i, j

        !Begin----------------------------------------------------------------

        CurrentTime = Me%CurrentTime

        call GetWaterPoints3D(Me%ObjMap, WaterPoints3D,                                 &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR10.'

        if (present(ExternalWaterLevel) .and. Me%WaterLevel%InitalizedByFile) then

            write(*,*) 'Sub. Initial_Geometry - ModuleHydrodynamic - WARN10.'
            write(*,*) 'When a water level field is define using a file it is assume that'
            write(*,*) 'the field define via file is more consistent from the one interpolated directly'
            write(*,*) 'from the father model'

        endif

        if (present(ExternalWaterLevel) .and. .not. Me%WaterLevel%InitalizedByFile) then

            SurfaceElevation   => ExternalWaterLevel

            !This is redundant in some cases but in the case of the Sea Surface High interpolate
            !directly from the Father model it avoid water columns with 0 meters of tickness

            !Gets Bathymetry
            call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR20.'

            call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR30.'

do4:        do  j=Me%WorkSize%JLB, Me%WorkSize%JUB
do5:        do  i=Me%WorkSize%ILB, Me%WorkSize%IUB

cd4:            if (WaterPoints3D(i, j, Me%WorkSize%KUB) == WaterPoint) then

cd5:                if (SurfaceElevation(i,j) < (- Bathymetry(i, j) + 0.999 * MinWaterColumn)) then
                        SurfaceElevation(i,j) =  - Bathymetry(i, j) + 0.999 * MinWaterColumn
                    endif cd5
                endif cd4
            enddo do5
            enddo do4

            !UnGets Bathymetry
            call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR40.'

        else

            SurfaceElevation   => Me%WaterLevel%New

        endif

        Continuous_Compute =  Me%ComputeOptions%Continuous

        !Compute new volume
        call ComputeInitialGeometry(Me%ObjGeometry, WaterPoints3D,                      &
                                    SurfaceElevation,                                   &
                                    ActualTime = Me%CurrentTime,                        &
                                    ContinuesCompute = Continuous_Compute,              &
                                    NonHydrostatic   = Me%NonHydrostatic%ON,            &
                                    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR50.'


        call UnGetMap(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. Initial_Geometry - ModuleHydrodynamic - ERR60.'


        !Update the moving boundary (boundary of the tidal areas covered)
        call UpdateComputeFaces3D(Me%ObjMap, SurfaceElevation,                          &
                                  CurrentTime, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'Subroutine Initial_Geometry - ModuleHydrodynamic. ERR70.'
        endif

        nullify(SurfaceElevation)

    end subroutine Initial_Geometry

    !End----------------------------------------------------------------------

    subroutine Open_HDF5_OutPut_File(iW)

        !Arguments-------------------------------------------------------------
        integer, optional                           :: iW

        !Local-----------------------------------------------------------------
        real, pointer, dimension(:, :)              :: Bathymetry
        integer, pointer, dimension(:, :, :)        :: WaterPoints3D
        type(T_Size2D)                              :: WorkSize2D, WorkSize2DAux, GlobalWorkSizeWindow
        character (Len = PathLength)                :: FileName
        character (Len = StringLength)              :: AuxChar
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE, ObjHDF5, i, n, j
        logical                                     :: SimpleOutPut, OutputOk

        !----------------------------------------------------------------------
        !Bounds

        OutputOk = .true.

        FileName = trim(Me%Files%OutPutFields)//"5"

        SimpleOutPut = .false.

        if (present(iW)) then

            WorkILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkIUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkJLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkJUB = Me%OutW%OutPutWindows(iW)%JUB

            WorkKLB = Me%OutW%OutPutWindows(iW)%KLB
            WorkKUB = Me%OutW%OutPutWindows(iW)%KUB

            WorkSize2D%ILB = WorkILB
            WorkSize2D%IUB = WorkIUB

            WorkSize2D%JLB = WorkJLB
            WorkSize2D%JUB = WorkJUB

            GlobalWorkSizeWindow         = WorkSize2D
            Me%OutW%OutPutWindows(iW)%ON = .true.

            if (Me%DDecomp%MasterOrSlave) then

                if (WindowIntersectDomain(Me%ObjHorizontalGrid, WorkSize2D)) then

                    WorkSize2DAux%ILB = WorkSize2D%ILB
                    WorkSize2DAux%IUB = WorkSize2D%IUB

                    WorkSize2DAux%JLB = WorkSize2D%JLB
                    WorkSize2DAux%JUB = WorkSize2D%JUB

                    WorkSize2D        = ReturnsIntersectionCorners(Me%ObjHorizontalGrid, WorkSize2DAux)

                    WorkILB           = WorkSize2D%ILB
                    WorkIUB           = WorkSize2D%IUB

                    WorkJLB           = WorkSize2D%JLB
                    WorkJUB           = WorkSize2D%JUB

                    Me%OutW%OutPutWindows(iW)%ILB = WorkSize2D%ILB
                    Me%OutW%OutPutWindows(iW)%IUB = WorkSize2D%IUB

                    Me%OutW%OutPutWindows(iW)%JLB = WorkSize2D%JLB
                    Me%OutW%OutPutWindows(iW)%JUB = WorkSize2D%JUB


                else

                    Me%OutW%OutPutWindows(iW)%ON = .false.
                    OutputOk                     = .false.
                endif
            endif

            write(AuxChar,fmt='(i5)') iW
            Auxchar           = "_w"//trim(adjustl(Auxchar))//".hdf5"
            n                 = len_trim(Auxchar)
            do j=1,len_trim(Filename)
                if(FileName(j:j+4)==".hdf5") then
                    i = j
                    exit
                endif
            enddo
            FileName(i:i+n-1) = trim(Auxchar)

            if (Me%OutW%Simple   ) SimpleOutPut = .true.

        else

            WorkILB = Me%WorkSize%ILB
            WorkIUB = Me%WorkSize%IUB

            WorkJLB = Me%WorkSize%JLB
            WorkJUB = Me%WorkSize%JUB

            WorkKLB = Me%WorkSize%KLB
            WorkKUB = Me%WorkSize%KUB

            WorkSize2D = Me%WorkSize2D

            if (Me%OutPut%Simple) SimpleOutPut = .true.


        endif

iStart: if (OutputOk) then

            !Gets a pointer to Bathymetry
            call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR10'

            !Gets WaterPoints3D
            call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR20'


            !Gets File Access Code
            call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

            ObjHDF5 = 0

            !Opens HDF File
            call ConstructHDF5      (ObjHDF5,                                               &
                                     trim(FileName),                                        &
                                     HDF5_CREATE, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR30'


            if (present(iW)) then

                Me%OutW%ObjHDF5(iW) = ObjHDF5

                !Write the Horizontal Grid
                call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5,                 &
                                         WorkSize                = WorkSize2D,          &
                                         WindowGrid              = .true.,              &
                                         GlobalWorkSizeWindow    = GlobalWorkSizeWindow,&
                                         STAT                    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR405'

            else

                Me%ObjHDF5          = ObjHDF5

                !Write the Horizontal Grid
                call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5,                 &
                                         WorkSize = WorkSize2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR410'

            endif



            !Sets limits for next write operations
            call HDF5SetLimits   (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                       &
                                  WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR420'


            !Writes the Grid
            call HDF5WriteData   (ObjHDF5, "/Grid", "Bathymetry", "m",                      &
                                  Array2D = Bathymetry,                                     &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR430'

            call HDF5WriteData   (ObjHDF5, "/Grid", "WaterPoints3D", "-",                   &
                                  Array3D = WaterPoints3D,                                  &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR440'


            !Writes everything to disk
            call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR460'


            !Ungets the Bathymetry
            call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR470'

            !Ungets the WaterPoints
            call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR480'

        endif iStart

        !----------------------------------------------------------------------

    end subroutine Open_HDF5_OutPut_File

    !--------------------------------------------------------------------------


    subroutine Open_Surface_HDF5_OutPut_File

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real, pointer, dimension(:, :)              :: Bathymetry
        integer, pointer, dimension(:, :, :)        :: WaterPoints3D
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE
        character(len=PathLength)                   :: SurfaceHDF5FileName
        integer                                     :: FileNameLength
        character(len=5)                            :: Extension         !.hdf5

        !----------------------------------------------------------------------

        !Bounds
        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        !Gets a pointer to Bathymetry
        call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR00'

        !Gets WaterPoints3D
        call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR10'

        FileNameLength      = len_trim(Me%Files%OutPutFields) + 1
        Extension           = trim(Me%Files%OutPutFields(FileNameLength-4:FileNameLength))
        Extension(5:5)      = "5"
        SurfaceHDF5FileName = Me%Files%OutPutFields(1:FileNameLength-5)//"_Surface"//trim(Extension)


        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        !Opens HDF File
        call ConstructHDF5      (Me%ObjSurfaceHDF5,                                     &
                                 trim(SurfaceHDF5FileName),                             &
                                 HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR20'

        !Write the Horizontal Grid
        call WriteHorizontalGrid(Me%ObjHorizontalGrid, Me%ObjSurfaceHDF5,               &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR30'

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjSurfaceHDF5, WorkILB, WorkIUB, WorkJLB,             &
                              WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR40'

        !Writes the Bathymetry
        call HDF5WriteData   (Me%ObjSurfaceHDF5, "/Grid", "Bathymetry", "m",            &
                              Array2D = Bathymetry,                                     &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR50'

        call HDF5WriteData   (Me%ObjSurfaceHDF5, "/Grid", "WaterPoints3D", "-",         &
                              Array3D = WaterPoints3D,                                  &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR60'

        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR80'

        !Ungets the Bathymetry
        call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR90'

        !Ungets the WaterPoints
        call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open_Surface_HDF5_OutPut_File - ModuleHydrodynamic - ERR100'

        !----------------------------------------------------------------------

    end subroutine Open_Surface_HDF5_OutPut_File

    !--------------------------------------------------------------------------

    subroutine Construct_Time_Serie

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        character(len=StringLength), dimension(:), pointer  :: PropertyList

        !Local-----------------------------------------------------------------
        real                                                :: CoordX, CoordY
        logical                                             :: CoordON, IgnoreOK
        integer                                             :: nProperties
        integer                                             :: STAT_CALL
        integer                                             :: iflag, dn, Id, Jd, TimeSerieNumber, i, j
        character(len=PathLength)                           :: TimeSerieLocationFile
        character(len=StringLength)                         :: TimeSerieName
        type (T_Polygon), pointer                           :: ModelDomainLimit

        !Begin-----------------------------------------------------------------


        call GetWaterPoints3D(Me%ObjMap,                                                &
                              Me%External_Var%WaterPoints3D,                            &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR10")

        nProperties = 7 !3 velocity components  (West-East, North-South, vertical), intensity, direction, elevation and open points

        !Allocates PropertyList
        allocate(PropertyList(nProperties), STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR20")

        !Fills up PropertyList
        PropertyList(1) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(2) = trim(GetPropertyName (VelocityV_      ))
        PropertyList(3) = trim(GetPropertyName (VelocityW_      ))
        PropertyList(4) = trim(GetPropertyName (VelocityModulus_))
        PropertyList(5) = trim(GetPropertyName (VelocityDirection_))
        PropertyList(6) = trim(GetPropertyName (WaterLevel_))
        PropertyList(7) = 'OpenPoint'

        do i=1,nProperties
            do j=1,len_trim(PropertyList(i))
                if (PropertyList(i)(j:j)==' ') PropertyList(i)(j:j)='_'
            enddo
        enddo

        call GetData(TimeSerieLocationFile,                                             &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie - Hydrodynamic - ERR30'

        call GetGridOutBorderPolygon(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                     Polygon          = ModelDomainLimit,               &
                                     STAT             = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie - Hydrodynamic - ERR35'

        !Constructs TimeSerie
        call StartTimeSerie(Me%ObjTimeSerie, Me%ObjTime,                                &
                            TimeSerieLocationFile,                                      &
                            PropertyList, "srh",                                        &
                            WaterPoints3D = Me%External_Var%WaterPoints3D,              &
                            ModelName     = Me%ModelName,                               &
                            ModelDomain   = ModelDomainLimit,                           &
                            STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR40")


        call UngetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,               &
                                 Polygon          = ModelDomainLimit,                   &
                                 STAT             = STAT_CALL)

        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie - Hydrodynamic - ERR45'


        !Deallocates PropertyList
        deallocate(PropertyList, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR50")

        !Corrects if necessary the cell of the time serie based in the time serie coordinates
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR60'

        do dn = 1, TimeSerieNumber

            call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR100'

            if (IgnoreOK) cycle

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                      CoordX   = CoordX,                                &
                                      CoordY   = CoordY,                                &
                                      CoordON  = CoordON,                               &
                                      STAT     = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR70'

            call GetTimeSerieName(Me%ObjTimeSerie, dn, TimeSerieName, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR80'

i1:         if (CoordON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordX, CoordY, Id, Jd, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                    stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR90'
                endif

              !  if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then

              !      call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
              !      if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR100'

              !      if (IgnoreOK) then
              !          write(*,*) 'Time Serie outside the domain - ',trim(TimeSerieName),' - ',trim(Me%ModelName)
              !          cycle
             !       else
             !           stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR110'
             !       endif

             !   endif


                call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn, Id, Jd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR120'

            endif i1


            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                      LocalizationI   = Id,                             &
                                      LocalizationJ   = Jd,                             &
                                      STAT     = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleHydrodynamic - ERR130'

            if (Me%External_Var%WaterPoints3D(Id, Jd, Me%WorkSize%KUB) /= WaterPoint) then

                 write(*,*) 'Time Serie in a land cell - ',trim(TimeSerieName),' - ',trim(Me%ModelName)

            endif


        enddo



        call UnGetMap(Me%ObjMap,                                                        &
                      Me%External_Var%WaterPoints3D,                                    &
                      STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie - Hydrodynamic - ERR140")


    end subroutine Construct_Time_Serie

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine Construct_Time_Serie_Discharge

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        character(len=StringLength), dimension(:), pointer  :: PropertyList

        !Local-----------------------------------------------------------------
        integer                                             :: nProperties
        integer                                             :: STAT_CALL
        integer                                             :: iflag, dis, i, j
        character(len=PathLength)                           :: TimeSerieLocationFile
        character(len=StringLength)                         :: Extension, DischargeName

        !Begin-----------------------------------------------------------------


        call GetDischargesNumber(Me%ObjDischarges, Me%OutPut%DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL/=SUCCESS_)stop 'Construct_Time_Serie_Discharge - ModuleHydrodynamic - ERR10'

        allocate(Me%OutPut%TimeSerieDischID(Me%OutPut%DischargesNumber))

        Me%OutPut%TimeSerieDischID(:) = 0

        nProperties = 4 !1 - flow, 2- Velocity U; 3 - Velocity V; 4 - Velocity W

        allocate(Me%OutPut%TimeSerieDischProp(1:Me%OutPut%DischargesNumber,1:nProperties))

        Me%OutPut%TimeSerieDischProp(:,:) = FillValueReal

        !Allocates PropertyList
        allocate(PropertyList(nProperties), STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, OUT_OF_MEM_, "Construct_Time_Serie_Discharge - Hydrodynamic - ERR20")

        !Fills up PropertyList
        PropertyList(1) = "water_flux"
        PropertyList(2) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(3) = trim(GetPropertyName (VelocityV_      ))
        PropertyList(4) = trim(GetPropertyName (VelocityW_      ))

        do i=1,nProperties
            do j=1,len_trim(PropertyList(i))
                if (PropertyList(i)(j:j)==' ') PropertyList(i)(j:j)='_'
            enddo
        enddo

       Extension       = '.fds'

       call GetData(TimeSerieLocationFile,                                              &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie_Discharge - Hydrodynamic - ERR30'

        do dis = 1, Me%OutPut%DischargesNumber

            call GetDischargesIDName (Me%ObjDischarges, dis, DischargeName, STAT = STAT_CALL)

            call StartTimeSerie(TimeSerieID         = Me%OutPut%TimeSerieDischID(dis),  &
                                ObjTime             = Me%ObjTime,                       &
                                TimeSerieDataFile   = TimeSerieLocationFile,            &
                                PropertyList        = PropertyList,                     &
                                Extension           = Extension,                        &
                                ResultFileName      = "hydro_"//trim(DischargeName),    &
                                STAT                = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie_Discharge - Hydrodynamic - ERR40'

        enddo
        !----------------------------------------------------------------------


    end subroutine Construct_Time_Serie_Discharge

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine Construct_Output_Profile

        !Local-----------------------------------------------------------------
        integer                                             :: STAT_CALL, iflag
        character(len=PathLength)                           :: TimeSerieLocationFile
        integer                                             :: nProperties
        character(len=StringLength), dimension(:,:), pointer:: PropertyList

        !----------------------------------------------------------------------

        call ReadLock_ModuleHorizontalMap

        call GetData(TimeSerieLocationFile,                                             &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleHydrodynamic',                               &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Output_Profile - ModuleWaterProperties - ERR01'

        nProperties = 5

        !Allocates PropertyList
        allocate(PropertyList(1:nProperties,1:2))

        PropertyList(1,1) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(2,1) = trim(GetPropertyName (VelocityV_      ))
        PropertyList(3,1) = trim(GetPropertyName (VelocityW_      ))
        PropertyList(4,1) = trim(GetPropertyName (VelocityModulus_))
        PropertyList(5,1) = "Direction"

        PropertyList(1,2) = "m/s"
        PropertyList(2,2) = "m/s"
        PropertyList(3,2) = "m/s"
        PropertyList(4,2) = "m/s"
        PropertyList(5,2) = ""

        call StartProfile  (ProfileID       = Me%ObjProfile,                            &
                            ObjTime         = Me%ObjTime,                               &
                            ProfileDataFile = trim(TimeSerieLocationFile),              &
                            WaterPoints2D   = Me%External_Var%WaterPoints2D,            &
                            KUB             = Me%WorkSize%KUB,                          &
                            nProperties     = nProperties,                              &
                            PropertyList    = PropertyList,                             &
                            ClientName      = "Hydrodynamic",                           &
                            STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Output_Profile - ModuleWaterProperties - ERR02'

        deallocate(PropertyList)

        call ReadUnLock_ModuleHorizontalMap

    end subroutine Construct_Output_Profile

    !--------------------------------------------------------------------------

    subroutine ConstructMatrixesOutput

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------

        !Bounds
        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !Horizontal Velocity
        if (Me%Output%Real4)then
            nullify  (Me%OutPut%AuxReal4)
            nullify  (Me%OutPut%Aux2DReal4)
        nullify  (Me%OutPut%CenterU   )
        nullify  (Me%OutPut%CenterV   )
        nullify  (Me%OutPut%ModulusH  )
        nullify  (Me%OutPut%CenterW   )
            nullify  (Me%OutPut%Aux2D)
        else
            nullify  (Me%OutPut%CenterU   )
            nullify  (Me%OutPut%CenterV   )
            nullify  (Me%OutPut%ModulusH  )
            nullify  (Me%OutPut%CenterW   )
            nullify  (Me%OutPut%Aux2D)
        endif
        nullify  (Me%OutPut%DirectionH)
        nullify  (Me%OutPut%Vorticity3D )
        nullify  (Me%OutPut%CenterUaux  )
        nullify  (Me%OutPut%CenterVaux  )
        nullify  (Me%OutPut%ModulusUVaux)
        nullify  (Me%OutPut%CenterWaux)
        nullify  (Me%OutPut%CenterUglm)
        nullify  (Me%OutPut%CenterVglm)
        nullify  (Me%OutPut%ModulusHglm)
        nullify  (Me%OutPut%CenterWglm)

        nullify  (Me%OutPut%CenterUstokes)
        nullify  (Me%OutPut%CenterVstokes)
        nullify  (Me%OutPut%ModulusHstokes)
        nullify  (Me%OutPut%CenterWstokes)

        nullify  (Me%OutPut%Wave3D_FBreakingAccelU)
        nullify  (Me%OutPut%Wave3D_FBreakingAccelV)

        nullify  (Me%OutPut%Wave3D_FVortexAccelU)
        nullify  (Me%OutPut%Wave3D_FVortexAccelV)

        nullify  (Me%OutPut%Wave3D_FPressureAccelU)
        nullify  (Me%OutPut%Wave3D_FPressureAccelV)

        if (Me%Output%Real4)then

            allocate(Me%OutPut%AuxReal4         (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%Aux2DReal4       (ILB:IUB, JLB:JUB         ),                &
                     Me%OutPut%CenterU          (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%CenterV          (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%ModulusH         (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%CenterW          (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%Aux2D            (ILB:IUB, JLB:JUB         ),                &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR01a'

        else
            allocate(Me%OutPut%CenterU          (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%CenterV          (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%ModulusH         (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%CenterW          (ILB:IUB, JLB:JUB, KLB:KUB),                &
                     Me%OutPut%Aux2D            (ILB:IUB, JLB:JUB         ),                &

                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR01b'
        endif


        allocate(Me%OutPut%DirectionH  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%Vorticity3D (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterUaux  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterVaux  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%ModulusUVaux(ILB:IUB, JLB:JUB, KLB:KUB),                     &
                 Me%OutPut%CenterWaux  (ILB:IUB, JLB:JUB, KLB:KUB),                     &
                Me%OutPut%CenterUglm     (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%CenterVglm     (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%ModulusHglm    (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%CenterWglm     (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%CenterUstokes  (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%CenterVstokes  (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%ModulusHstokes (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                Me%OutPut%CenterWstokes  (ILB:IUB, JLB:JUB, KLB:KUB),                   &
                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR10'


        if (Me%Output%Real4)then
            Me%OutPut%AuxReal4      (:,:,:) = 0.
            Me%OutPut%Aux2DReal4    (:,:  ) = 0.
        Me%OutPut%CenterU       (:,:,:) = 0.
        Me%OutPut%CenterV       (:,:,:) = 0.
        Me%OutPut%ModulusH      (:,:,:) = 0.
            Me%OutPut%CenterW       (:,:,:) = 0.
            Me%OutPut%Aux2D         (:,:  ) = 0.
        else
            Me%OutPut%CenterU       (:,:,:) = 0.
            Me%OutPut%CenterV       (:,:,:) = 0.
            Me%OutPut%ModulusH      (:,:,:) = 0.
            Me%OutPut%CenterW       (:,:,:) = 0.
            Me%OutPut%Aux2D         (:,:  ) = 0.
        endif

        Me%OutPut%DirectionH    (:,:,:) = 0.
        Me%OutPut%Vorticity3D   (:,:,:) = 0.
        Me%OutPut%CenterUaux    (:,:,:) = 0.
        Me%OutPut%CenterVaux    (:,:,:) = 0.
        Me%OutPut%ModulusUVaux  (:,:,:) = 0.
        Me%OutPut%CenterWaux    (:,:,:) = 0.

        Me%OutPut%CenterUglm    (:,:,:) = 0.
        Me%OutPut%CenterVglm    (:,:,:) = 0.
        Me%OutPut%ModulusHglm   (:,:,:) = 0.
        Me%OutPut%CenterWglm    (:,:,:) = 0.

        Me%OutPut%CenterUstokes (:,:,:) = 0.
        Me%OutPut%CenterVstokes (:,:,:) = 0.
        Me%OutPut%ModulusHstokes(:,:,:) = 0.
        Me%OutPut%CenterWstokes (:,:,:) = 0.

        if (Me%ComputeOptions%WaterLevelMaxMin) then

            nullify  (Me%OutPut%WaterLevelMax)
            nullify  (Me%OutPut%WaterLevelMin)
            nullify  (Me%OutPut%WaterLevelDif)

            allocate(Me%OutPut%WaterLevelMax (ILB:IUB, JLB:JUB       ),                 &
                     Me%OutPut%WaterLevelMin (ILB:IUB, JLB:JUB       ),                 &
                     Me%OutPut%WaterLevelDif (ILB:IUB, JLB:JUB       ),                 &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR20'

            Me%OutPut%WaterLevelMax (:,:  ) = 0.
            Me%OutPut%WaterLevelMin (:,:  ) = 0.
            Me%OutPut%WaterLevelDif (:,:  ) = 0.

        endif

        if(Me%OutPut%FloodRisk)then

            nullify  (Me%OutPut%MaxWaterColumn          )
            nullify  (Me%OutPut%VelocityAtMaxWaterColumn)
            nullify  (Me%OutPut%MaxFloodRisk            )

            nullify  (Me%OutPut%MaxVelocity             )
            nullify  (Me%OutPut%MaxWaterLevel           )
            nullify  (Me%OutPut%MapMax                  )
            nullify  (Me%OutPut%MapMin                  )


            allocate(Me%OutPut%MaxWaterColumn          (ILB:IUB, JLB:JUB),              &
                     Me%OutPut%VelocityAtMaxWaterColumn(ILB:IUB, JLB:JUB),              &
                     Me%OutPut%MaxFloodRisk            (ILB:IUB, JLB:JUB),              &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR30'

            Me%OutPut%MaxWaterColumn          (:,:) = -99.
            Me%OutPut%VelocityAtMaxWaterColumn(:,:) = -99.
            Me%OutPut%MaxFloodRisk            (:,:) = -99.

            allocate(Me%OutPut%MaxVelocity             (ILB:IUB, JLB:JUB),                     &
                     Me%OutPut%MaxWaterLevel           (ILB:IUB, JLB:JUB),                     &
                     Me%OutPut%MapMax                  (ILB:IUB, JLB:JUB),                     &
                     Me%OutPut%MapMin                  (ILB:IUB, JLB:JUB),                     &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMatrixesOutput - ModuleHydrodynamic - ERR40'

            Me%OutPut%MaxVelocity       (:,:) = -99
            Me%OutPut%MaxWaterLevel     (:,:) = -99
            Me%OutPut%MapMax            (:,:) = -99
            Me%OutPut%MapMin            (:,:) = -99

            call ReadLock_ModuleHorizontalMap

            call SetMatrixValue(Me%OutPut%MaxWaterColumn,           Me%WorkSize2D, 0., Me%External_Var%WaterPoints2D)
            call SetMatrixValue(Me%OutPut%VelocityAtMaxWaterColumn, Me%WorkSize2D, 0., Me%External_Var%WaterPoints2D)
            call SetMatrixValue(Me%OutPut%MaxFloodRisk,             Me%WorkSize2D, 0., Me%External_Var%WaterPoints2D)

            call SetMatrixValue(Me%OutPut%MaxVelocity,              Me%WorkSize2D,  0., Me%External_Var%WaterPoints2D)
            call SetMatrixValue(Me%OutPut%MaxWaterLevel,            Me%WorkSize2D,-80., Me%External_Var%WaterPoints2D)
            call SetMatrixValue(Me%OutPut%MapMax,                   Me%WorkSize2D,  0., Me%External_Var%WaterPoints2D)
            call SetMatrixValue(Me%OutPut%MapMin,                   Me%WorkSize2D,  1., Me%External_Var%WaterPoints2D)

            call ReadUnLock_ModuleHorizontalMap

        endif

        allocate  (Me%OutPut%Wave3D_FBreakingAccelU(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate  (Me%OutPut%Wave3D_FBreakingAccelV(ILB:IUB, JLB:JUB, KLB:KUB))

        allocate  (Me%OutPut%Wave3D_FVortexAccelU(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate  (Me%OutPut%Wave3D_FVortexAccelV(ILB:IUB, JLB:JUB, KLB:KUB))

        allocate  (Me%OutPut%Wave3D_FPressureAccelU(ILB:IUB, JLB:JUB, KLB:KUB))
        allocate  (Me%OutPut%Wave3D_FPressureAccelV(ILB:IUB, JLB:JUB, KLB:KUB))

        Me%OutPut%Wave3D_FBreakingAccelU (:,:,:) =0.
        Me%OutPut%Wave3D_FBreakingAccelV (:,:,:) =0.

        Me%OutPut%Wave3D_FVortexAccelU   (:,:,:) =0.
        Me%OutPut%Wave3D_FVortexAccelV   (:,:,:) =0.

        Me%OutPut%Wave3D_FPressureAccelU   (:,:,:) =0.
        Me%OutPut%Wave3D_FPressureAccelV   (:,:,:) =0.

    end subroutine ConstructMatrixesOutput

    !--------------------------------------------------------------------------

    subroutine ConstructEnergy

        !Local-----------------------------------------------------------------
        integer                             :: status
        integer, dimension(:), pointer      :: aux
        integer                             :: iflag
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB

        !----------------------------------------------------------------------

        !Bounds
        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        allocate (aux(6))

        call GetData(aux,                                                               &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'ENERGY_WINDOW',                                      &
                     Default    = FillValueInt,                                         &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = status)
        if (status /= SUCCESS_)                                                         &
            call SetError(FATAL_, KEYWORD_, 'ConstructEnergy - Hydrodynamic - ERR02')

        if   (iflag == 0) then

            Me%Energy%Window%ILB = Me%WorkSize%ILB
            Me%Energy%Window%IUB = Me%WorkSize%IUB

            Me%Energy%Window%JLB = Me%WorkSize%JLB
            Me%Energy%Window%JUB = Me%WorkSize%JUB

            Me%Energy%Window%KLB = Me%WorkSize%KLB
            Me%Energy%Window%KUB = Me%WorkSize%KUB


        else if (iflag == 6) then

            Me%Energy%Window%ILB = aux(1)
            Me%Energy%Window%IUB = aux(2)

            Me%Energy%Window%JLB = aux(3)
            Me%Energy%Window%JUB = aux(4)

            Me%Energy%Window%KLB = aux(5)
            Me%Energy%Window%KUB = aux(6)

        else

            call SetError(FATAL_, KEYWORD_, 'ConstructEnergy - Hydrodynamic - ERR03')

        endif

        deallocate (aux)


        call UnitsManager(Me%Energy%FileID, FileOpen, STAT = status)
        if (status /= SUCCESS_)     &
            call SetError(FATAL_, INTERNAL_, 'ConstructEnergy - Hydrodynamic - ERR05')

        open(unit = Me%Energy%FileID, file = Me%Files%Energy, &
             form = 'FORMATTED', status = 'UNKNOWN')

        !Inits the buffer count
        Me%Energy%BufferCount = 0


        !Allocates the buffer
        allocate(Me%Energy%SecondsBuffer         (1:EnergyBufferSize))
        allocate(Me%Energy%KineticBuffer         (1:EnergyBufferSize))
        allocate(Me%Energy%PotentialBuffer       (1:EnergyBufferSize))
        allocate(Me%Energy%VorticityBuffer       (1:EnergyBufferSize))
        allocate(Me%Energy%MassBuffer            (1:EnergyBufferSize))
        allocate(Me%Energy%VolumeBuffer          (1:EnergyBufferSize))
        allocate(Me%Energy%OpenVolumeBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%WaterLevelBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%BarotropicKEBuffer    (1:EnergyBufferSize))
        allocate(Me%Energy%BaroclinicKEBuffer    (1:EnergyBufferSize))
        allocate(Me%Energy%RelativeKEBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%RelativePEBuffer      (1:EnergyBufferSize))
        allocate(Me%Energy%VelMaxBuffer          (1:EnergyBufferSize))
        allocate(Me%Energy%VelMaxBaroclinicBuffer(1:EnergyBufferSize))


        allocate(Me%Energy%CenterU      (ILB:IUB,JLB:JUB,KLB:KUB))
        allocate(Me%Energy%CenterV      (ILB:IUB,JLB:JUB,KLB:KUB))
        allocate(Me%Energy%CenterW      (ILB:IUB,JLB:JUB,KLB:KUB))
        allocate(Me%Energy%BarotropicU  (ILB:IUB,JLB:JUB        ))
        allocate(Me%Energy%BarotropicV  (ILB:IUB,JLB:JUB        ))

        call GetData(Me%Energy%DtOut,                                                    &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType = FromFile,                                              &
                     keyword    = 'ENERGY_DT',                                           &
                     Default    = 600.,                                                  &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, KEYWORD_, 'ConstructEnergy - Hydrodynamic - ERR21')

        Me%Energy%NextOutPut = Me%BeginTime

    end subroutine ConstructEnergy


    !--------------------------------------------------------------------------

    Subroutine ConstructTidePotential

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer               :: ILB, IUB, JLB, JUB, NComp


        NComp = Me%TidePotential%ComponentsNumber


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB

        allocate (Me%TidePotential%Frequency(NComp))
        allocate (Me%TidePotential%Amplitude(NComp))
        allocate (Me%TidePotential%Arguments(NComp))
        allocate (Me%TidePotential%Beta     (NComp))
        allocate (Me%TidePotential%m        (NComp))
        allocate (Me%TidePotential%L        (0:2  ))

!
! ---> Compute
!
        !Load factor (Specie 0,2 Alpha = 0.953, Specie 1 (diurnal) Alpha = 0.940 (Kantha e Clayson, 2000)
        !Compromise value
        !Alpha = 0.95
        Me%TidePotential%Alpha = 0.95

        !Elasticity Factor (Table 6.1.1 Kantha and Clayson, 2000)
        Me%TidePotential%Beta (Ssa) = 0.693
        Me%TidePotential%Beta (Mm ) = 0.693
        Me%TidePotential%Beta (Mf ) = 0.693

        Me%TidePotential%Beta (K1 ) = 0.7364
        Me%TidePotential%Beta (O1 ) = 0.6950
        Me%TidePotential%Beta (P1 ) = 0.7059
        Me%TidePotential%Beta (Q1 ) = 0.6946

        Me%TidePotential%Beta (M2 ) = 0.693
        Me%TidePotential%Beta (S2 ) = 0.693
        Me%TidePotential%Beta (N2 ) = 0.693
        Me%TidePotential%Beta (K2 ) = 0.693

        Me%TidePotential%Beta (M3 ) = 0.693

        !Equilibrium tide amplitude (m) (Table 6.1.1 Kantha and Clayson, 2000)
        Me%TidePotential%Amplitude (Ssa) = 0.019542
        Me%TidePotential%Amplitude (Mm ) = 0.022191
        Me%TidePotential%Amplitude (Mf ) = 0.042017

        Me%TidePotential%Amplitude (K1 ) = 0.142408
        Me%TidePotential%Amplitude (O1 ) = 0.101266
        Me%TidePotential%Amplitude (P1 ) = 0.047129
        Me%TidePotential%Amplitude (Q1 ) = 0.019387

        Me%TidePotential%Amplitude (M2 ) = 0.244102
        Me%TidePotential%Amplitude (S2 ) = 0.113572
        Me%TidePotential%Amplitude (N2 ) = 0.046735
        Me%TidePotential%Amplitude (K2 ) = 0.030875

        Me%TidePotential%Amplitude (M3 ) = 0.003198

        !frequency in radianos./hr. (Table 6.1.1 Kantha and Clayson, 2000)
        Me%TidePotential%Frequency (Ssa) = 0.0821373  * Pi / 180.
        Me%TidePotential%Frequency (Mm ) = 0.5443747  * Pi / 180.
        Me%TidePotential%Frequency (Mf ) = 1.0980331  * Pi / 180.

        Me%TidePotential%Frequency (K1 ) = 15.0410686 * Pi / 180.
        Me%TidePotential%Frequency (O1 ) = 13.9430356 * Pi / 180.
        Me%TidePotential%Frequency (P1 ) = 14.9589314 * Pi / 180.
        Me%TidePotential%Frequency (Q1 ) = 13.3986609 * Pi / 180.

        Me%TidePotential%Frequency (M2 ) = 28.9841042 * Pi / 180.
        Me%TidePotential%Frequency (S2 ) = 30.0000000 * Pi / 180.
        Me%TidePotential%Frequency (N2 ) = 28.4397295 * Pi / 180.
        Me%TidePotential%Frequency (K2 ) = 30.0821373 * Pi / 180.

        Me%TidePotential%Frequency (M3 ) = 43.4761563 * Pi / 180.

        !griflet: changed values from 0,1,2 to 1,2,3. Added +1 (array index correction).
        !Species m
        Me%TidePotential%m(Ssa) = 1
        Me%TidePotential%m(Mm ) = 1
        Me%TidePotential%m(Mf ) = 1

        Me%TidePotential%m(K1 ) = 2
        Me%TidePotential%m(O1 ) = 2
        Me%TidePotential%m(P1 ) = 2
        Me%TidePotential%m(Q1 ) = 2

        Me%TidePotential%m(M2 ) = 3
        Me%TidePotential%m(S2 ) = 3
        Me%TidePotential%m(N2 ) = 3
        Me%TidePotential%m(K2 ) = 3

        Me%TidePotential%m(M3 ) = 4

        call SetDate(Me%TidePotential%TimeRef, 1900, 1, 1, 0, 0, 0)


    end subroutine ConstructTidePotential


    !--------------------------------------------------------------------------

    Subroutine ConstructSubModel

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer :: IC3D
        integer               :: ILB, IUB, JLB, JUB, KLB, KUB
        integer               :: STATUS
        integer               :: i, j, k

        !Begin-----------------------------------------------------------------



        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB
        KUB = Me%Size%KUB
        KLB = Me%Size%KLB

cd1:    if (Me%SubModel%DeadZone) then

            call GetWaterPoints3D(Me%ObjMap, Me%External_Var%WaterPoints3D, STAT = STATUS)
            if (STATUS .NE. SUCCESS_) stop 'ConstructSubModel - ModuleHydrodynamic - ERR01'

            allocate (Me%SubModel%DeadZonePoint(ILB:IUB, JLB:JUB, KLB:KUB))
            Me%SubModel%DeadZonePoint(:,:,:) = .false.

            call StartBoxDif(BoxDifID         = Me%SubModel%ObjBoxDif,           &
                             TimeID           = Me%ObjTime,                      &
                             HorizontalGridID = Me%ObjHorizontalGrid,            &
                             BoxesFilePath = Me%SubModel%DeadZoneFile,                   &
                             WaterPoints3D = Me%External_Var%WaterPoints3D,              &
                             Size3D        = Me%Size,                                    &
                             WorkSize3D    = Me%WorkSize,                                &
                             STAT          = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR02'

            call GetBoxes(Me%SubModel%ObjBoxDif, IC3D, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR03'

            do j = JLB, JUB
            do i = ILB, IUB
            do k = KLB, KUB

cd2 :           if (IC3D(i,j,k)>0) then

                    Me%SubModel%DeadZonePoint(i,j,k) = .true.

                end if cd2

            end do
            end do
            end do


            call UngetBoxDif(Me%SubModel%ObjBoxDif, IC3D, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR04'


            call KillBoxDif(Me%SubModel%ObjBoxDif, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR05'

            call UnGetMap(Me%ObjMap,Me%External_Var%WaterPoints3D, STAT = STATUS)
            if (STATUS /= SUCCESS_) stop 'ConstructSubModel - Hydrodynamic - ERR06'

        endif cd1


        Me%SubModel%Set = .false.

    end subroutine ConstructSubModel


    !-----------------------------------------------------------------
    Subroutine ConstructRelaxation

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------

        integer                          :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                          :: ILBWork, IUBWork, JLBWork, JUBWork, KLBWork, KUBWork
        integer                          :: STATUS

        integer                          :: iflag,fromfile


        IUB = Me%Size%IUB
        ILB = Me%Size%ILB
        JUB = Me%Size%JUB
        JLB = Me%Size%JLB
        KUB = Me%Size%KUB
        KLB = Me%Size%KLB


        IUBWork = Me%WorkSize%IUB
        ILBWork = Me%WorkSize%ILB
        JUBWork = Me%WorkSize%JUB
        JLBWork = Me%WorkSize%JLB
        KUBWork = Me%WorkSize%KUB
        KLBWork = Me%WorkSize%KLB



        call GetExtractType(FromFile = FromFile)

! ---> Compute
!

        !<BeginKeyword>
            !Keyword          : BOUNDARYFILE
            !<BeginDescription>
               !
               !The file name of 3D file where the relaxation coefficient are.
               !
            !<EndDescription>
            !Type             : Character
            !Default          : ******.***

            !File keyword     : IN_DAD3D
            !Multiple Options : Do not
            !Search Type      : From File
        !<EndKeyword>



!        call GetData(FileName, Me%ObjEnterData, iflag,                      &
!                     Keyword    = 'BOUNDARYFILE',                                        &
!                     Default    = '********.***',                                        &
!                     SearchType = FromFile,                                              &
!                     STAT       = status)

!        if (status /= SUCCESS_)                                                          &
!           call SetError(FATAL_, INTERNAL_, "ConstructDataAssimilation - Hydrodynamic - ERR02")

!        if (iflag == 0) &
!           call SetError(FATAL_, INTERNAL_, "ConstructDataAssimilation - Hydrodynamic - ERR03")

!        Me%DataAssimilation%BRfilename = FileName

        !<BeginKeyword>
            !Keyword          : BRCORIOLIS
            !<BeginDescription>
               !
               !Checks if the user wants to relax the coriolis force
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.

            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>

         call GetData(Me%Relaxation%coriolis,                         &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'BRCORIOLIS',                                          &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR04")


        !<BeginKeyword>
            !Keyword          : BRROX3
            !<BeginDescription>
               !
               !Checks if the user wants to relax the baroclinic force
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.

            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>


         call GetData(Me%Relaxation%rox3,                                               &
                      Me%ObjEnterData, iflag,                                           &
                      Keyword    = 'BRROX3',                                            &
                      Default    = .false.,                                             &
                      SearchType = FromFile,                                            &
                      ClientModule ='ModuleHydrodynamic',                               &
                      STAT       = status)

        if (status /= SUCCESS_)                                                         &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR05")


        !<BeginKeyword>
            !Keyword          : BRTRANSPORT
            !<BeginDescription>
               !
               !Checks if the user wants to relax the horizontal momentum transport
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.

            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>



        call GetData(Me%Relaxation%HorizAdv,                                &
                     Me%ObjEnterData, iflag,                                &
                     Keyword    = 'BRHORIZ_ADV',                                         &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleHydrodynamic',                                 &
                     STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR06")



! ---> Velocity field relaxation
!
        !<BeginKeyword>
            !Keyword          : BRVELOCITY
            !<BeginDescription>
               !
               !Checks if the user wants to relax the horizontal velocity
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.

            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>


         call GetData(Me%Relaxation%Velocity,                         &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'BRVELOCITY',                                            &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR14")



! ---> Water Level field relaxation
!
        !<BeginKeyword>
            !Keyword          : BRWATERLEVEL
            !<BeginDescription>
               !
               !Checks if the user wants to relax the water level
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.

            !File keyword     : IN_DAD3D
            !Multiple Options : 0 (.false.), 1 (.true.)
            !Search Type      : From File
        !<EndKeyword>


         call GetData(Me%Relaxation%WaterLevel,                             &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'BRWATERLEVEL',                                          &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR15")



         call GetData(Me%Relaxation%RefBoundWaterLevel,                     &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'REF_BOUND_WATERLEVEL',                                  &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR16")

        call GetData(Me%Relaxation%ReferenceVelocity,                       &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'RELAX_REF_VEL',                                         &
                      default = TotalVel_,                                               &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR16a")

        if (Me%Relaxation%ReferenceVelocity /= TotalVel_          .and.     &
            Me%Relaxation%ReferenceVelocity /= BarotrVel_         .and.     &
            Me%Relaxation%ReferenceVelocity /= BaroclVel_)                  &
            call SetError(FATAL_, KEYWORD_, 'ConstructRelaxation - Hydrodynamic - ERR31.')



         call GetData(Me%Relaxation%Force,                                  &
                      Me%ObjEnterData, iflag,                               &
                      keyword = 'BRFORCE',                                               &
                      default = .false.,                                                 &
                      SearchType = FromFile,                                             &
                      ClientModule ='ModuleHydrodynamic',                                &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR17")

        if (Me%Relaxation%Force .and. Me%Relaxation%Velocity) then

            call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR18")

        endif


        if (Me%Relaxation%Force) then

             call GetData(Me%Relaxation%BrFroceOnlyAssimil,                             &
                          Me%ObjEnterData, iflag,                                       &
                          keyword = 'BRFORCE_ONLY_ASSIMILA',                            &
                          default = .false.,                                            &
                          SearchType = FromFile,                                        &
                          ClientModule ='ModuleHydrodynamic',                           &
                          STAT       = status)

            if (status /= SUCCESS_)                                                     &
               call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR1800")

            !Forces
            allocate (Me%Forces%Relax_Aceleration(ILB:IUB, JLB:JUB, KLB:KUB), STAT = status)

            if (status /= SUCCESS_)                                                     &
               call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR19")

            Me%Forces%Relax_Aceleration(:,:,:) = FillValueReal


        endif


         call GetData(Me%Relaxation%Geometry,                                           &
                      Me%ObjEnterData, iflag,                                           &
                      keyword = 'BRGEOMETRY',                                           &
                      default = .false.,                                                &
                      SearchType = FromFile,                                            &
                      ClientModule ='ModuleHydrodynamic',                               &
                      STAT       = status)

        if (status /= SUCCESS_)                                                          &
           call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR200")

        if (Me%Relaxation%Geometry) then

            !Forces
            allocate (Me%Relaxation%DecayTimeGeo(ILB:IUB, JLB:JUB, KLB:KUB), STAT = status)

            if (status /= SUCCESS_)                                                          &
               call SetError(FATAL_, INTERNAL_, "ConstructRelaxation - Hydrodynamic - ERR210")

            Me%Relaxation%DecayTimeGeo(:,:,:) = FillValueReal


        endif


    end subroutine ConstructRelaxation

    !----------------------------------------------------------------------------

   !--------------------------------------------------------------------------

    !----------------------------------------------------------------------------

    subroutine CourantGH

        !Arguments---------------------------------------------------------------



        !External----------------------------------------------------------------

        integer :: STAT_CALL
        integer :: I_Courant, J_Courant

        real    :: DT
        real    :: Velocity

        !Local-------------------------------------------------------------------

        integer :: I, J
        integer :: IUB, ILB
        integer :: JUB, JLB

        real    :: Courant, Courant_temp
        real    :: DX

        real,    dimension(:,:), pointer :: WaterColumn

        !------------------------------------------------------------------------

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB


        call ReadLock_External_Modules

        call GetComputeTimeStep(Me%ObjTime, DT = DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'CourantGH - ModuleHydrodynamic - ERR01'


        WaterColumn => Me%External_Var%WaterColumn



        Courant = FillValueReal

        I_Courant = FillValueInt
        J_Courant = FillValueInt

do2 :   do J = JLB, JUB
do3 :   do I = ILB, IUB
cd1 :   if (Me%External_Var%WaterPoints2D(I,J) .EQ. 1) then
            if (WaterColumn(I,J) < 0.) WaterColumn(I,J) = 0.

            Velocity     = SQRT(WaterColumn(I,J) * Gravity)
            DX           = MIN(Me%External_Var%DXX(I,J), Me%External_Var%DYY(I,J))

            Courant_temp = F_Courant(Velocity = Velocity,                       &
                                     DT       = 2. * DT,                        &
                                     DX       = DX)

cd2 :       if (Courant .LT. Courant_temp) then
                I_Courant = I
                J_Courant = J

                Courant = Courant_temp
            end if cd2
        end if cd1
        end do do3
        end do do2



        call OutputCourant(Courant, I_Courant, J_Courant)


        call ReadUnLock_External_Modules


        nullify(WaterColumn)

        !------------------------------------------------------------------------

    end subroutine CourantGH

    !----------------------------------------------------------------------------



    !----------------------------------------------------------------------------

    function F_Courant(Velocity, DT, DX)
    real ::  F_Courant

        !Arguments---------------------------------------------------------------

        real, intent(IN) :: Velocity, DT, DX

        !------------------------------------------------------------------------

        F_Courant = Velocity * DT / DX

        !------------------------------------------------------------------------

    end function F_Courant

    !----------------------------------------------------------------------------

    subroutine OutputCourant(Courant, I, J)

        !Arguments---------------------------------------------------------------

        integer, intent(IN) :: I, J
        real,    intent(IN) :: Courant

        !------------------------------------------------------------------------

#ifndef _OUTPUT_OFF_
        write(*, *)"---------------------- HYDRODYNAMICS ---------------------"
        write(*, *)
        write(*, *)"Courant Number is : ", Courant
        write(*, *)"In Grid Cell[i,j] : ", i, j
        write(*, *)
#endif

        !------------------------------------------------------------------------

    end subroutine OutputCourant

    !----------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine PointToHydroState(HydrodynamicID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        !This is a compilation of points (one for each variable) for internal memory spaces

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Me%AuxPointer%WaterLevelNew => Me%WaterLevel%New

            Me%AuxPointer%VelocityUNew => Me%Velocity%Horizontal%U%New

            Me%AuxPointer%VelocityVNew => Me%Velocity%Horizontal%V%New

            Me%AuxPointer%VelocityUOld => Me%Velocity%Horizontal%U%Old

            Me%AuxPointer%VelocityVOld => Me%Velocity%Horizontal%V%Old

            Me%AuxPointer%VelVerticalCartesian => Me%Velocity%Vertical%Cartesian

            Me%AuxPointer%VelVerticalAcross => Me%Velocity%Vertical%Across

            Me%AuxPointer%WaterFluxX => Me%WaterFluxes%X

            Me%AuxPointer%WaterFluxY => Me%WaterFluxes%Y

            Me%AuxPointer%WaterFluxZ => Me%WaterFluxes%Z

            if (Me%SubModel%ON) then
                Me%AuxPointer%SubModelqX => Me%SubModel%qX

                Me%AuxPointer%SubModelqY => Me%SubModel%qY
            endif

            Me%AuxPointer%ChezyVelUV => Me%External_Var%ChezyVelUV

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))STAT = STAT_

    end subroutine PointToHydroState

    !--------------------------------------------------------------------------

    subroutine CopyWaterLevel(HydrodynamicID, Size2D, WaterLevel, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )                  :: HydrodynamicID
        type (T_Size2D)                                 :: Size2D
        real, dimension(:,:), pointer                   :: WaterLevel
        !integer, dimension(:, :), pointer               :: MapMatrix
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            !call Read_Lock(mHydrodynamic_, Me%InstanceID)

            call SetMatrixValue(Me%WaterLevel%New, Size2D, WaterLevel) !, MapMatrix)

            !call Read_UnLock?

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !------------------------------------------------------------------------

    end subroutine CopyWaterLevel

    !--------------------------------------------------------------------------

    subroutine CopyHorizontalVelocity(HydrodynamicID, Size3D, Velocity_U,       &
                                      Velocity_V, OldVelocity_U, OldVelocity_V, &
                                      STAT)

        !Arguments-------------------------------------------------------------
        integer,              intent(IN )           :: HydrodynamicID
        type (T_Size3D)                             :: Size3D
        real, dimension(:,:,:), pointer, optional   :: Velocity_U, Velocity_V
        real, dimension(:,:,:), pointer, optional   :: OldVelocity_U, OldVelocity_V
        !integer, dimension(:, :,:), pointer         :: MapMatrix
        integer, optional,    intent(OUT)           :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(Velocity_U)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%U%New, Size3D,       &
                                    Velocity_U) !, MapMatrix)

                !call Read_UnLock?
            end if cd2

cd3 :       if (present(Velocity_V)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%V%New, Size3D,       &
                                    Velocity_V) !, MapMatrix)

                !call Read_UnLock?
            end if cd3

cd4 :       if (present(OldVelocity_U)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Size3D,       &
                                    OldVelocity_U) !, MapMatrix)

                !call Read_UnLock?
            end if cd4

cd5 :       if (present(OldVelocity_V)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Size3D,       &
                                    OldVelocity_V) !, MapMatrix)

                !call Read_UnLock?
            end if cd5

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyHorizontalVelocity

    !--------------------------------------------------------------------------

    subroutine CopyVerticalVelocity(HydrodynamicID, Size3D, Velocity_W,         &
                                    Velocity_Across, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID
        type (T_Size3D)                             :: Size3D
        real, dimension(:,:,:), optional, pointer   :: Velocity_W
        real, dimension(:,:,:), optional, pointer   :: Velocity_Across
        !integer, dimension(:, :,:), pointer         :: MapMatrix
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if (present(Velocity_W     )) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Vertical%Cartesian, Size3D,     &
                Velocity_W) !, MapMatrix)

                !call Read_UnLock?
            endif

            if (present(Velocity_Across)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%Velocity%Vertical%Across, Size3D,        &
                Velocity_Across) !, MapMatrix)

                !call Read_UnLock?
            endif

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyVerticalVelocity

    !--------------------------------------------------------------------------

    subroutine CopyWaterFluxes(HydrodynamicID, Size3D, WaterFluxX, WaterFluxY,  &
                               WaterFluxZ, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN )    :: HydrodynamicID
        type (T_Size3D)                                 :: Size3D
        real(8), dimension(:,:,:), pointer, optional    :: WaterFluxX
        real(8), dimension(:,:,:), pointer, optional    :: WaterFluxY
        real(8), dimension(:,:,:), pointer, optional    :: WaterFluxZ
        !integer, dimension(:, :,:), pointer             :: MapMatrix
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(WaterFluxX)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%WaterFluxes%X, Size3D, WaterFluxX) !, MapMatrix)

                !call Read_UnLock?
            end if cd2


cd3 :       if (present(WaterFluxY)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%WaterFluxes%Y, Size3D, WaterFluxY) !, MapMatrix)

                !call Read_UnLock?
            end if cd3


cd4 :       if (present(WaterFluxZ)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%WaterFluxes%Z, Size3D, WaterFluxZ) !, MapMatrix)

                !call Read_UnLock?
            end if cd4

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyWaterFluxes

    !--------------------------------------------------------------------------

    subroutine CopySubModelFluxes(HydrodynamicID, Size3D, SubModelqX,           &
                                  SubModelqY, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN )    :: HydrodynamicID
        type (T_Size3D)                                 :: Size3D
        real(8), dimension(:,:,:), pointer, optional    :: SubModelqX
        real(8), dimension(:,:,:), pointer, optional    :: SubModelqY
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(SubModelqX)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%SubModel%qX, Size3D, SubModelqX)

                !call Read_UnLock?
            end if cd2


cd3 :       if (present(SubModelqY)) then
                !call Read_Lock(mHydrodynamic_, Me%InstanceID)

                call SetMatrixValue(Me%SubModel%qY, Size3D, SubModelqY)

                !call Read_UnLock?
            end if cd3

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopySubModelFluxes

    !--------------------------------------------------------------------------

    subroutine CopyChezyVelUV(HydrodynamicID, Size2D, ChezyVelUV, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN )    :: HydrodynamicID
        type (T_Size2D)                                 :: Size2D
        real,    dimension(:,:),   pointer              :: ChezyVelUV
        integer, optional, intent(OUT)                  :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            !call Read_Lock(mHydrodynamic_, Me%InstanceID)

            call SetMatrixValue(Me%External_Var%ChezyVelUV, Size2D, ChezyVelUV)

            !call Read_UnLock?

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyChezyVelUV

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELE

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    !--------------------------------------------------------------------------

    subroutine GetDirection(HydrodynamicID, ImplicitDirection,                           &
                            DirectionX, DirectionY, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        integer, optional, intent(OUT) :: ImplicitDirection
        integer, optional, intent(OUT) :: DirectionX, DirectionY
        integer, optional, intent(OUT) :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mHydrodynamic_, Me%InstanceID)


            if (present(DirectionX)) DirectionX = DirectionX_
            if (present(DirectionY)) DirectionY = DirectionY_

            if (present(ImplicitDirection))                                              &
                ImplicitDirection = Me%Direction%XY

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "GetDirection")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetDirection


    !--------------------------------------------------------------------------

    subroutine GetHydrodynamicSource(HydrodynamicID,                            &
                                     HydrodynamicSource,                        &
                                     Solve_Equations,                           &
                                     Read_File,                                 &
                                     No_hydrodynamic,                           &
                                     Residual_hydrodynamic,                     &
                                     Run_Off,                                   &
                                     ImposedSolution,                           &
                                     Vertical1D,                                &
                                     STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        integer,           intent(OUT) :: HydrodynamicSource
        integer, optional, intent(OUT) :: Solve_Equations, Read_File, No_hydrodynamic,  &
                                          Residual_hydrodynamic, Run_Off,               &
                                          ImposedSolution, Vertical1D
        integer, optional, intent(OUT) :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mHydrodynamic_, Me%InstanceID)


            if (present(Solve_Equations       )) Solve_Equations       = Solve_Equations_
            if (present(Read_File             )) Read_File             = Read_File_
            if (present(No_hydrodynamic       )) No_hydrodynamic       = No_hydrodynamic_
            if (present(Residual_hydrodynamic )) Residual_hydrodynamic = Residual_hydrodynamic_
            if (present(ImposedSolution       )) ImposedSolution       = ImposedSolution_
            if (present(Vertical1D            )) Vertical1D            = Vertical1D_
            if (present(Run_Off               )) Run_Off               = Run_Off_


            HydrodynamicSource = Me%ComputeOptions%Evolution

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "GetHydrodynamicSource")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetHydrodynamicSource
    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetWaterFluxes(HydrodynamicID, WaterFluxX, WaterFluxY, WaterFluxZ,        &
                              STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxX
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxY
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxZ

        integer, optional, intent(OUT) :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then


cd2 :       if (present(WaterFluxX)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                WaterFluxX => Me%WaterFluxes%X
            end if cd2


cd3 :       if (present(WaterFluxY)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                WaterFluxY => Me%WaterFluxes%Y
            end if cd3


cd4 :       if (present(WaterFluxZ)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                WaterFluxZ => Me%WaterFluxes%Z
            end if cd4


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterFluxes

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetDischargesFluxes(HydrodynamicID, Discharges, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: Discharges

        integer, optional, intent(OUT)               :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)

            Discharges => Me%WaterFluxes%Discharges

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetDischargesFluxes

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine GetWavesStressON(HydrodynamicID, WavesStressON, STAT)

        !Arguments-------------------------------------------------------------

        integer,           intent(IN ) :: HydrodynamicID
        logical                        :: WavesStressON
        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                           &
            (ready_ .EQ. READ_LOCK_ERR_)) then

! Modified by Matthias DELPEY - 01/07/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 27/07/2011
! WaveStressON is also set at .true. when using WAVE_STRESS : 0 and WAVE_FORCING_3D : 1 or 2
            ! WavesStressON = Me%WaveStress%ON
            WavesStressON =  (Me%WaveStress%ON                                      .or.&
                             (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress).or.&
                             (Me%ComputeOptions%WaveForcing3D == GLM)                       )
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                              &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWavesStressON

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetPointDischargesState(HydrodynamicID, DischargesON, STAT)

        !Arguments-------------------------------------------------------------

        integer,           intent(IN ) :: HydrodynamicID
        logical                        :: DischargesON
        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            DischargesON = Me%ComputeOptions%WaterDischarges

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetPointDischargesState

    !--------------------------------------------------------------------------




    !--------------------------------------------------------------------------

    subroutine GetHorizontalVelocity(HydrodynamicID, Velocity_U, Velocity_V, STAT)

        !Arguments-------------------------------------------------------------
        integer,              intent(IN )           :: HydrodynamicID
        real, dimension(:,:,:), pointer, optional   :: Velocity_U, Velocity_V
        integer, optional,    intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(Velocity_U)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_U => Me%Velocity%Horizontal%U%New
            end if cd2

cd3 :       if (present(Velocity_V)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_V => Me%Velocity%Horizontal%V%New
            end if cd3

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetHorizontalVelocity

    !--------------------------------------------------------------------------

 !--------------------------------------------------------------------------

    subroutine GetResidualVelocityON(HydrodynamicID, ResidualON, STAT)

        !Arguments-------------------------------------------------------------

        integer,           intent(IN ) :: HydrodynamicID
        logical                        :: ResidualON
        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            ResidualON = Me%ComputeOptions%Residual

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetResidualVelocityON

    !--------------------------------------------------------------------------

 !--------------------------------------------------------------------------

    subroutine GetResidualVelocityPeriod(HydrodynamicID, ResidualPeriod, STAT)

        !Arguments-------------------------------------------------------------

        integer,           intent(IN ) :: HydrodynamicID
        real                           :: ResidualPeriod
        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            ResidualPeriod = Me%Residual%ResidualTime

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetResidualVelocityPeriod

    !--------------------------------------------------------------------------

    subroutine GetResidualHorizontalVelocity(HydrodynamicID, VelocityResidual_U, VelocityResidual_V, STAT)

        !Arguments-------------------------------------------------------------
        integer,                        intent(IN ) :: HydrodynamicID
        real, dimension(:,:,:), pointer, optional   :: VelocityResidual_U, VelocityResidual_V
        integer, optional,              intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(VelocityResidual_U)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                VelocityResidual_U => Me%Residual%Velocity_U
            end if cd2

cd3 :       if (present(VelocityResidual_V)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                VelocityResidual_V => Me%Residual%Velocity_V
            end if cd3

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetResidualHorizontalVelocity

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetOldHorizontalVelocity(HydrodynamicID, OldVelocity_U, OldVelocity_V, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID
        real, dimension(:,:,:), pointer, optional   :: OldVelocity_U, OldVelocity_V
        integer, optional, intent(OUT)              :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

cd2 :       if (present(OldVelocity_U)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                OldVelocity_U => Me%Velocity%Horizontal%U%Old
            end if cd2

cd3 :       if (present(OldVelocity_V)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                OldVelocity_V => Me%Velocity%Horizontal%V%Old
            end if cd3

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetOldHorizontalVelocity

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetVelocityModulus(HydrodynamicID, VelocityModulus, STAT)

        !Arguments-------------------------------------------------------------
        integer,              intent(IN )           :: HydrodynamicID
        real, dimension(:,:,:), pointer, optional   :: VelocityModulus
        integer, optional,    intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if(.not. associated(Me%OutPut%ModulusH))then

                write(*,*)'Please activate Hydrodynamic outputs'
                call SetError(FATAL_, INTERNAL_, 'GetVelocityModulus - Hydrodynamic - ERR01')

            endif

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            VelocityModulus => Me%OutPut%ModulusH


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetVelocityModulus

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetVerticalVelocity(HydrodynamicID, Velocity_W, Velocity_Across, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID
        real, dimension(:,:,:), optional, pointer   :: Velocity_W
        real, dimension(:,:,:), optional, pointer   :: Velocity_Across

        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if (present(Velocity_W     )) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_W      => Me%Velocity%Vertical%Cartesian
            endif

            if (present(Velocity_Across)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                Velocity_Across => Me%Velocity%Vertical%Across
            endif

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))  STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetVerticalVelocity

    !--------------------------------------------------------------------------

    subroutine GetWaterLevel(HydrodynamicID, WaterLevel, WaterLevelOld, DT, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )           :: HydrodynamicID
        real, dimension(:,:), pointer            :: WaterLevel
        real, dimension(:,:), optional, pointer  :: WaterLevelOld
        real,    optional, intent(OUT)           :: DT
        integer, optional, intent(OUT)           :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            WaterLevel => Me%WaterLevel%New

            !this routine was changed (added if bellow) to be able to simulat exactly
            !the same tide conditions as in the standalone project for the population
            ! in the Balgzand Area
            if(present(WaterLevelOld))then
                WaterLevelOld => Me%WaterLevel%Old
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
            endif

            if (present(DT)) then
                DT = Me%WaterLevel%DT
            endif

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterLevel

    !--------------------------------------------------------------------------

    subroutine GetHydrodynamicAirOptions (HydrodynamicID,      &
                                          SurfaceWaterFluxYes, &
                                          WindYes,             &
                                          AtmPressureYes,      &
                                          MslpYes,             &
                                          STAT)
        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical                        :: SurfaceWaterFluxYes, WindYes, AtmPressureYes
        logical                        :: MslpYes               !Mean Sea Level Pressure
        integer, optional, intent(OUT) :: STAT
        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            SurfaceWaterFluxYes  = Me%ComputeOptions%SurfaceWaterFlux

            if (Me%ComputeOptions%AtmPressure .or. Me%ComputeOptions%InvertBarometer) then

case1 :         select case(Me%ComputeOptions%AtmPressureType)

                    !Use atmospheric pressure
                    case(1)

                        AtmPressureYes       = .true.
                        MslpYes              = .false.

                    !Use Mean Sea Level Pressure (MSLP)
                    case(2)

                        AtmPressureYes       = .false.
                        MslpYes              = .true.

                    !Same as case(1)
                    case default

                        AtmPressureYes       = .true.
                        MslpYes              = .false.

                end select case1

            endif

            if (Me%ComputeOptions%Wind == NoWind_) then
                WindYes = .false.
            else
                WindYes = .true.
            endif

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_


        !----------------------------------------------------------------------
    end subroutine GetHydrodynamicAirOptions

    !--------------------------------------------------------------------------

    subroutine GetChezy(HydrodynamicID, Chezy, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        real, dimension(:,:), pointer  :: Chezy
        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            Chezy => Me%External_Var%ChezyZ

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetChezy

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetHydroNeedsFather (HydrodynamicID, cdsubModel, STAT)
         !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical,           intent(OUT) :: cdsubModel
        integer, optional, intent(OUT) :: STAT


        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            cdsubModel = Me%SubModel%ON

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetHydroNeedsFather

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine GetHydroAltimAssim (AssimilationID, AltimetricAssimilation, STAT)

        !Arguments------------------------------------------------------------
        integer                                     :: AssimilationID
        logical,        intent(OUT)                 :: AltimetricAssimilation
        integer,       intent(OUT),   optional      :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(AssimilationID, ready_)

if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            AltimetricAssimilation = Me%ComputeOptions%AltimetryAssimilation%Yes

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetHydroAltimAssim

    !--------------------------------------------------------------------------


    subroutine GetVertical1D (HydrodynamicID, Vertical1D, STAT)
         !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical,           intent(OUT) :: Vertical1D
        integer, optional, intent(OUT) :: STAT


        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if (Me%ComputeOptions%Evolution == Vertical1D_) then

                Vertical1D = .true.

            else
                Vertical1D = .false.
            endif

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetVertical1D

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


    subroutine GetXZFlow (HydrodynamicID, XZFlow, STAT)
         !Arguments-------------------------------------------------------------
        integer,           intent(IN ) :: HydrodynamicID
        logical,           intent(OUT) :: XZFlow
        integer, optional, intent(OUT) :: STAT


        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            XZFlow = Me%ComputeOptions%XZFlow

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetXZFlow

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine GetHydroSeqAssimilation(HydrodynamicID, RunSeqAssimilation, STAT)

        !Arguments------------------------------------------------------------
        integer                                     :: HydrodynamicID
        logical                                     :: RunSeqAssimilation
        integer, intent(OUT), optional              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            RunSeqAssimilation = Me%RunSeqAssimilation

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetHydroSeqAssimilation

    !--------------------------------------------------------------------------

    subroutine GetCyclicBoundary(HydrodynamicID, CyclicBoundaryON,          &
                                 CyclicBoundaryDirection, STAT)

        !Arguments------------------------------------------------------------
        integer                                     :: HydrodynamicID
        logical                                     :: CyclicBoundaryON
        integer                                     :: CyclicBoundaryDirection
        integer, intent(OUT), optional              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

if1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            CyclicBoundaryON = Me%CyclicBoundary%ON
            CyclicBoundaryDirection = Me%CyclicBoundary%Direction

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if if1

        if (present(STAT)) STAT = STAT_

    end subroutine GetCyclicBoundary

    !--------------------------------------------------------------------------

    subroutine GetSubModelFluxes(HydrodynamicID, SubModelqX, SubModelqY, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: SubModelqX
        real(8), dimension(:,:,:), pointer, optional :: SubModelqY

        integer, optional, intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then


cd2 :       if (present(SubModelqX)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                SubModelqX => Me%SubModel%qX
            end if cd2

cd3 :       if (present(SubModelqY)) then
                call Read_Lock(mHydrodynamic_, Me%InstanceID)
                SubModelqY => Me%SubModel%qY
            end if cd3

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                  &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetSubModelFluxes

    !--------------------------------------------------------------------------

    subroutine GetChezyVelUV(HydrodynamicID, ChezyVelUV, STAT)

        !Arguments-------------------------------------------------------------
        integer,                         intent(IN ) :: HydrodynamicID
        real,    dimension(:,:),   pointer           :: ChezyVelUV
        integer, optional, intent(OUT)               :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                               &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mHydrodynamic_, Me%InstanceID)
            ChezyVelUV => Me%External_Var%ChezyVelUV

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                  &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetChezyVelUV

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic3Dreal4(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------

        integer,               intent(IN ) :: HydrodynamicID
        real(4), pointer, dimension(:,:,:) :: Array
        integer, optional,     intent(OUT) :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic3Dreal4")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic3Dreal4

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic2Dinteger(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )   :: HydrodynamicID
        integer, pointer, dimension(:,:) :: Array
        integer, optional, intent(OUT)   :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic2Dinteger")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic2Dinteger

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic2Dreal4(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )   :: HydrodynamicID
        real(4), pointer, dimension(:,:) :: Array
        integer, optional, intent(OUT)   :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic2Dreal4")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic2Dreal4

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic2Dreal8(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )   :: HydrodynamicID
        real(8), pointer, dimension(:,:) :: Array
        integer, optional, intent(OUT)   :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic2Dreal8")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic2Dreal8

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine UngetHydrodynamic3Dreal8(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------

        integer,               intent(IN ) :: HydrodynamicID
        real(8), pointer, dimension(:,:,:) :: Array
        integer, optional,    intent (OUT) :: STAT



        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic3Dreal8")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetHydrodynamic3Dreal8

    !--------------------------------------------------------------------------
    subroutine UngetHydrodynamic3Dinteger(HydrodynamicID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer,               intent(IN ) :: HydrodynamicID
        integer, pointer, dimension(:,:,:) :: Array
        integer, optional,    intent (OUT) :: STAT
        !External--------------------------------------------------------------
        integer :: ready_
        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mHydrodynamic_, Me%InstanceID, "UngetHydrodynamic3Dinteger")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

    !----------------------------------------------------------------------
    end subroutine UngetHydrodynamic3Dinteger

    !--------------------------------------------------------------------------
    subroutine SetHydrodynamicManning (HydrodynamicID, Manning, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        logical, intent(IN)             :: Manning
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_
        integer                         :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%Manning = Manning

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetHydrodynamicManning

    !--------------------------------------------------------------------------

    subroutine SetHydrodynamicChezy (HydrodynamicID, Chezy, ChezyCoef, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        logical, intent(IN)             :: Chezy
        real,    intent(IN)             :: ChezyCoef
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_
        integer                         :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%Chezy     = Chezy
            Me%External_Var%ChezyCoef = ChezyCoef

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetHydrodynamicChezy

    !--------------------------------------------------------------------------

    subroutine SetHydrodynamicRugosityMatrix (HydrodynamicID, RugosityMatrix, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        real, dimension(:, :), pointer  :: RugosityMatrix
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_
        integer                         :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%RugosityMatrix => RugosityMatrix

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetHydrodynamicRugosityMatrix

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    subroutine SetSurfaceWaterFlux(HydrodynamicID, SurfaceWaterFlux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: SurfaceWaterFlux
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%SurfaceWaterFlux       => SurfaceWaterFlux

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetSurfaceWaterFlux


    !--------------------------------------------------------------------------


    subroutine SetBottomWaterFlux(HydrodynamicID, BottomWaterFlux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real(8), pointer, dimension(:,:)            :: BottomWaterFlux
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%BottomWaterFlux       => BottomWaterFlux

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetBottomWaterFlux

    !--------------------------------------------------------------------------

    subroutine SetWindStress(HydrodynamicID, WindStress_X, WindStress_Y, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: WindStress_X
        real, pointer, dimension(:,:)               :: WindStress_Y
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%TauWindU       => WindStress_X
            Me%External_Var%TauWindV       => WindStress_Y

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetWindStress
    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    subroutine SetAtmosphericPressure(HydrodynamicID, AtmosphericPressure, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: AtmosphericPressure
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%AtmosphericPressure       => AtmosphericPressure

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetAtmosphericPressure

    !--------------------------------------------------------------------------
    subroutine SetWaveChezyVel(HydrodynamicID, WaveChezyVel, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, pointer, dimension(:,:)               :: WaveChezyVel
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%External_Var%WaveChezyVel  => WaveChezyVel

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetWaveChezyVel

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine SetWaterLevel(HydrodynamicID, WaterLevel, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, dimension(:,:), pointer               :: WaterLevel
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

        if (ready_ .EQ. IDLE_ERR_) then

            Me%WaterLevel%New => WaterLevel
            !CAUTION: WaterLevel is an external variable/memory space!

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetWaterLevel

    !--------------------------------------------------------------------------

    subroutine SetHorizontalVelocity(HydrodynamicID, Velocity_U, Velocity_V,    &
                                     OldVelocity_U, OldVelocity_V, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, dimension(:,:,:), pointer, optional   :: Velocity_U, Velocity_V
        real, dimension(:,:,:), pointer, optional   :: OldVelocity_U, OldVelocity_V
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(Velocity_U)) then
                Me%Velocity%Horizontal%U%New => Velocity_U
            end if cd2

cd3 :       if (present(Velocity_V)) then
                Me%Velocity%Horizontal%V%New => Velocity_V
            end if cd3

cd4 :       if (present(OldVelocity_U)) then
                Me%Velocity%Horizontal%U%Old => OldVelocity_U
            end if cd4

cd5 :       if (present(OldVelocity_V)) then
                Me%Velocity%Horizontal%V%Old => OldVelocity_V
            end if cd5
            !CAUTION: Velocity_U/Velocity_V is an external variable/memory space!

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine SetHorizontalVelocity

    !--------------------------------------------------------------------------

    subroutine SetVerticalVelocity(HydrodynamicID, Velocity_W, Velocity_Across, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        real, dimension(:,:,:), optional, pointer   :: Velocity_W
        real, dimension(:,:,:), optional, pointer   :: Velocity_Across
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(Velocity_W)) then
                Me%Velocity%Vertical%Cartesian => Velocity_W
            end if cd2

cd3 :       if (present(Velocity_Across)) then
                Me%Velocity%Vertical%Across => Velocity_Across
            end if cd3
            !CAUTION: Velocity_W/Velocity_Across is an external variable/memory space!

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine SetVerticalVelocity

    !--------------------------------------------------------------------------

    subroutine SetWaterFluxes(HydrodynamicID, WaterFluxX, WaterFluxY, WaterFluxZ, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxX
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxY
        real(8), dimension(:,:,:), pointer, optional :: WaterFluxZ
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(WaterFluxX)) then
                Me%WaterFluxes%X => WaterFluxX
            end if cd2

cd3 :       if (present(WaterFluxY)) then
                Me%WaterFluxes%Y => WaterFluxY
            end if cd3

cd4 :       if (present(WaterFluxZ)) then
                Me%WaterFluxes%Z => WaterFluxZ
            end if cd4
            !CAUTION: WaterFluxX/WaterFluxY/WaterFluxZ is an external variable/memory space!


            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine SetWaterFluxes

    !--------------------------------------------------------------------------

    subroutine SetSubModelFluxes(HydrodynamicID, SubModelqX, SubModelqY, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        real(8), dimension(:,:,:), pointer, optional :: SubModelqX
        real(8), dimension(:,:,:), pointer, optional :: SubModelqY
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

cd2 :       if (present(SubModelqX)) then
                Me%SubModel%qX => SubModelqX
            end if cd2

cd3 :       if (present(SubModelqY)) then
                Me%SubModel%qY => SubModelqY
            end if cd3
            !CAUTION: SubModelqX/SubModelqY is an external variable/memory space!

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine SetSubModelFluxes

    !--------------------------------------------------------------------------

    subroutine SetChezyVelUV(HydrodynamicID, ChezyVelUV, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        real,    dimension(:,:),   pointer           :: ChezyVelUV
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Me%External_Var%ChezyVelUV => ChezyVelUV
            !CAUTION: ChezyVelUV is an external variable/memory space!

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine SetChezyVelUV

    !--------------------------------------------------------------------------

    subroutine SetHydroVirtualRun(HydrodynamicID, VirtualRun, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        logical                                      :: VirtualRun
        integer, optional, intent(OUT)               :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%VirtualRun     = VirtualRun

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetHydroVirtualRun

    !--------------------------------------------------------------------------

    subroutine ReSetHydrodynamicProperties(HydrodynamicID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: HydrodynamicID
        integer,            optional, intent(OUT)    :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        !This is a compilation of sets (one for each variable) for internal memory spaces

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Me%WaterLevel%New => Me%AuxPointer%WaterLevelNew

            Me%Velocity%Horizontal%U%New => Me%AuxPointer%VelocityUNew

            Me%Velocity%Horizontal%V%New => Me%AuxPointer%VelocityVNew

            Me%Velocity%Horizontal%U%Old => Me%AuxPointer%VelocityUOld

            Me%Velocity%Horizontal%V%Old => Me%AuxPointer%VelocityVOld

            Me%Velocity%Vertical%Cartesian => Me%AuxPointer%VelVerticalCartesian

            Me%Velocity%Vertical%Across => Me%AuxPointer%VelVerticalAcross

            Me%WaterFluxes%X => Me%AuxPointer%WaterFluxX

            Me%WaterFluxes%Y => Me%AuxPointer%WaterFluxY

            Me%WaterFluxes%Z => Me%AuxPointer%WaterFluxZ

            if (Me%SubModel%ON) then
                Me%SubModel%qX => Me%AuxPointer%SubModelqX

                Me%SubModel%qY => Me%AuxPointer%SubModelqY
            endif

            Me%External_Var%ChezyVelUV => Me%AuxPointer%ChezyVelUV

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))STAT = STAT_

    end subroutine ReSetHydrodynamicProperties

    !--------------------------------------------------------------------------

#endif _USE_SEQASSIMILATION

    subroutine SetShearStressMethod (HydrodynamicID, ShearStressMethod, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        integer, intent(IN)             :: ShearStressMethod
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_
        integer                         :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%External_Var%ShearStressMethod     = ShearStressMethod

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetShearStressMethod

    !--------------------------------------------------------------------------

    subroutine SetWaveShearStress (HydrodynamicID, WaveShearStress, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: HydrodynamicID
        logical, intent(IN)             :: WaveShearStress
        integer, optional, intent(OUT)  :: STAT

        !Local-----------------------------------------------------------------
        integer                         :: ready_
        integer                         :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%ComputeOptions%WaveShearStress = WaveShearStress

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetWaveShearStress

    !----------------------------------------------------------------------



    !--------------------------------------------------------------------------


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MO

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!BOP
!
! !ROUTINE: Modify_Hydrodynamic

! !DESCRIPTION:
!     This routine is responsible for the evolution of flow properties:
!     velocities, water fluxes and water level.
!

! !REVISION HISTORY:
!  1Jan2000    Paulo Chambel  First experimental version.
!  22Nov2000   Paulo Chambel  Comments are introduce in the Protex format
!                             to produce a manual

!   !INTERFACE:

    subroutine Modify_Hydrodynamic(HydrodynamicID,                             &
                                   Density,                                    &
                                   SigmaDens,                                  &
                                   NewDT,                                      &
                                   STAT)


!   !INPUT PARAMETERS:
        integer, intent (IN )           :: HydrodynamicID
        real, dimension(:,:,:), pointer :: Density
        real, dimension(:,:,:), pointer :: SigmaDens
        type(T_NewDT),    intent (OUT)  :: NewDT

!   !OUTPUT PARAMETERS:

        integer, optional, intent (OUT) :: STAT

!EOP

        !External--------------------------------------------------------------

        integer :: ready_
        !Local-----------------------------------------------------------------

        integer :: STAT_, STAT_CALL
        logical :: VariableDT
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Modify_Hydrodynamic")


            !This hydrodynamic model do not has variable time step
            !NewDT    = FillValueReal


            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'Subroutine Modify_Hydrodynamic - ModuleHydrodynamic. ERR01.'

            !Read density values
            Me%External_Var%SigmaDens   => SigmaDens
            Me%External_Var%Density     => Density

            call Actualises_Hydrodynamic


            !Read Lock variables external variables
            !The modules responsible for this variables were
            !built outside the hydrodynamic module. This modules are
            !call External Modules
            call ReadLock_External_Modules


            call ReadLock_ModuleTurbulence
#ifndef _WAVES_

            if (Me%ObjWaves /=0) then
                call ReadLock_ModuleWaves
            endif
#endif
            call One_Iteration

            !Computes the energy extracted by the turbines
            if (Me%ComputeOptions%Turbine)                              &
            call ComputeTurbineEnergy(Me%ObjTurbine, Me%Velocity%DT)

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
            !(the following is not required when evoluting disturbed states in
            !sequential assimilation, i.e. VirtualRun = .true.)
#endif _USE_SEQASSIMILATION

            !Compute Water Fluxes
            call ComputeBoxesWaterFluxes

            !Compute Residual Flow Properties
            if (Me%ComputeOptions%Residual)                                 &
                call ComputeResidualFlowProperties

            !Calculates emersion and immersion times
            if (Me%ComputeOptions%EmersionTime)                             &
                call ComputeEmersionTime

            !Calculates the energy of the system - Frank Out 99
            if (Me%ComputeOptions%Energy)                                   &
                call ComputeSystemEnergy


            if (.not. associated(Me%Next))then

                    if (Me%ComputeOptions%TwoWay) then

                        call ComputeTwoWay(HydrodynamicID)

                    endif

            endif

            call Hydrodynamic_OutPut

            call WriteHighLowTideOutput

            !Records results to binary file
            if (Me%ComputeOptions%Recording) then

                call ModifyHydrodynamicFile(Me%ObjHydrodynamicFileOut,                           &
                                            WaterLevel       = Me%WaterLevel%New,                &
                                            WaterFluxX       = Me%WaterFluxes%X,                 &
                                            WaterFluxY       = Me%WaterFluxes%Y,                 &
                                            Discharges       = Me%WaterFluxes%Discharges,        &
                                            ComputeFacesU3D  = Me%External_Var%ComputeFaces3D_U, &
                                            ComputeFacesV3D  = Me%External_Var%ComputeFaces3D_V, &
                                            HydrodynamicTime = Me%CurrentTime,                   &
                                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) &
                    stop 'Subroutine Modify_Hydrodynamic - ModuleHydrodynamic. ERR02.'

            endif

            call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Modify_Hydrodynamic - ModuleHydrodynamic - ERR02a'

            if (VariableDT) then
                call CalcNewDT (NewDT)
            endif

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            !Output of the Turbulence variaveis
            call ReadUnLock_ModuleTurbulence
#ifndef _WAVES_

            if (Me%ObjWaves /=0) then
                call ReadUnLock_ModuleWaves
            endif
#endif
            !Read UnLock variables external variables
            !The modules responsible for this variables were
            !built outside the hydrodynamic module. This modules are
            !call External Modules
            call ReadUnLock_External_Modules

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
            !(the following is not required when evoluting disturbed states in
            !sequential assimilation, i.e. VirtualRun = .true.)
#endif _USE_SEQASSIMILATION

            Me%LastIteration = Me%CurrentTime

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            Me%FirstIteration = .false.

            call null_time    (Me%CurrentTime)

            if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Modify_Hydrodynamic")

            STAT_ = SUCCESS_
        else

            STAT_ = ready_

        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine Modify_Hydrodynamic

    !--------------------------------------------------------------------------

    subroutine CalcNewDT (NewDT)

        !Arguments-------------------------------------------------------------
        type(T_NewDT)                               :: NewDT

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k, status
        real(8)                                     :: TotalFlux
        real(8)                                     :: CourantDT, Courant, AuxDT
        real                                        :: DT_Model
        !$ integer                                     :: CHUNK, TID
        !$ type(T_NewDT)                               :: StoredDT
        !$ type(T_NewDT), dimension(Me%MaxThreads)     :: NewDTs
        !$ real(8), dimension(Me%MaxThreads)           :: CourantDTs

        !CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "CalcNewDT")

        NewDT%property = 'momentum'
        !$ StoredDT = NewDT

        !$OMP PARALLEL PRIVATE(i,j,k,TotalFlux,AuxDT,CourantDT,NewDT,TID)

        !$ TID = 1 + omp_get_thread_num()
        !$ NewDT = StoredDT

        !Test Frank.
        !Calculates new DT which guarantees a transport Courant < 1 for horizontal fluxes
        !Just consider Fluxes which leave cell
        CourantDT = -FillValueReal

        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%External_Var%WaterPoints3D(i, j, k) == WaterPoint) then

                !Verifies the horizontal condition
                TotalFlux   = 0.0

                if (Me%External_Var%ComputeFaces3D_U(i, j, k) == Compute .and. &
                    Me%WaterFluxes%X(i, j, k) < 0.0) then
                    TotalFlux = TotalFlux - Me%WaterFluxes%X(i, j, k)
                endif
                if (Me%External_Var%ComputeFaces3D_U(i, j+1, k) == Compute .and. &
                    Me%WaterFluxes%X(i, j+1, k) > 0.0) then
                    TotalFlux = TotalFlux + Me%WaterFluxes%X(i, j+1, k)
                endif
                if (Me%External_Var%ComputeFaces3D_V(i, j, k) == Compute .and. &
                    Me%WaterFluxes%Y(i, j, k) < 0.0) then
                    TotalFlux = TotalFlux - Me%WaterFluxes%Y(i, j, k)
                endif
                if (Me%External_Var%ComputeFaces3D_V(i+1, j, k) == Compute .and. &
                    Me%WaterFluxes%Y(i+1, j, k) > 0.0) then
                    TotalFlux = TotalFlux + Me%WaterFluxes%Y(i+1, j, k)
                endif

                if (Me%External_Var%ComputeFaces3D_W(i, j, k) == Compute .and. &
                    Me%WaterFluxes%Z(i, j, k) < 0.0) then
                    TotalFlux = TotalFlux - Me%WaterFluxes%Z(i, j, k+1)
                endif

                if (Me%External_Var%ComputeFaces3D_W(i, j, k+1) == Compute .and. &
                    Me%WaterFluxes%Z(i, j, k+1) > 0.0) then
                    TotalFlux = TotalFlux + Me%WaterFluxes%Z(i, j, k+1)
                endif

                if (Me%External_Var%OpenPoints3D (i, j, k) == OpenPoint) then
                    if (Me%WaterFluxes%Discharges(i, j, k)< 0) then
                        TotalFlux = TotalFlux - Me%WaterFluxes%Discharges(i, j, k)
                    endif
                endif


                if (TotalFlux > 0.0 .and. Me%External_Var%Volume_Z_New(i, j, k) > 0. ) then   !To avoid division by zero.
                    AuxDT = Me%External_Var%Volume_Z_New(i, j, k) / TotalFlux
                    if (AuxDT < CourantDT) then
                        CourantDT = AuxDT
                        NewDT%i = i; NewDT%j = j; NewDT%k = k
                    endif
                endif

            endif
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$ CourantDTs(TID) = CourantDT
        !$ NewDTs(TID) = NewDT

        !$OMP END PARALLEL

        !$ CourantDT = - FillValueReal
        !$ NewDT = StoredDT
        !$ do i = 1, Me%MaxThreads
        !$    if (CourantDTs(i) < CourantDT) then
        !$        CourantDT = CourantDTs(i)
        !$        NewDT = NewDTs(i)
        !$    endif
        !$ enddo

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "CalcNewDT")

        call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, 'CalcNewDT - ModuleHydrodynamic - ERR10')

        Courant = CourantDT / dble(DT_Model)

!        !If variation is over 60.0% shut down DT quickly
!        if     (Courant > 0.6) then
!            NewDT%DT = 0.5  * CourantDT
!        !If variation is over  40% shut down DT slowly
!        elseif (Courant > 0.4 .and. Courant <= .6) then
!            NewDT%DT = 0.8  * CourantDT
!        elseif (Courant > 0.2 .and. Courant <= .4) then
!            NewDT%DT = CourantDT
!        elseif (Courant <= 0.20) then
!            NewDT%DT = 1.2 * CourantDT
!        !Increase DT
!        endif

        !Previous formulation was decreasing dt if CourantDT was
        !higher than dt and let dt higher than CourantDT when it should
        !be cutted down.
        !If Courant is over 1 DTCourant is higher than ModelDT
        !use DTCourant because it is not expected problems
        if     (Courant > 1) then
            NewDT%DT = CourantDT
        !If Courant is over  50% shut down DT slowly
        elseif (Courant > 0.5 .and. Courant <= 1) then
            NewDT%DT = 0.75  * CourantDT
        !If Courant below 50%, CourantDT is lower than half ModelDT
        !shut down DT quickly
        elseif (Courant <= 0.50) then
            NewDT%DT = 0.5 * CourantDT
        endif


    end subroutine CalcNewDT

    !End--------------------------------------------------------------------------

    subroutine Statistics_OutPut ( CenterU, CenterV, CenterW, ModulusH, WaterLevel)

        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer                :: CenterU, CenterV, CenterW, ModulusH
        real,    dimension(:,:  ), pointer                :: WaterLevel

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer                :: Value3D
        real,    dimension(:,:  ), pointer                :: Value2D
        real,    dimension(:,:  ), pointer                :: Bathymetry
        integer                                           :: MethodStatistic, LayerDefinition
        integer                                           :: Depth, Layer, Value3DStatLayers,      &
                                                   LayersNumber, np, ln
        integer                                           :: ILB, IUB, JLB, JUB, STAT_CALL
        integer                                           :: status
        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB


        if (Me%Statistics%ON) then
            do np = 1, Me%Statistics%NProp

                if (Me%Statistics%PropList(np) == VelocityU_)then
                    Value3D => CenterU
                endif

                if (Me%Statistics%PropList(np) == VelocityV_)then
                    Value3D => CenterV
                endif

                if (Me%Statistics%PropList(np) == VelocityW_)then
                    Value3D => CenterW
                endif

                if (Me%Statistics%PropList(np) == VelocityModulus_)then
                    Value3D => ModulusH
                endif

                call GetStatisticMethod (Me%Statistics%ID(np), MethodStatistic, &
                                        STAT = status)

                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR01')

                call GetStatisticParameters (Me%Statistics%ID(np),          &
                                             Value3DStatLayers = Value3DStatLayers,      &
                                             Depth             = Depth,                  &
                                             Layer             = Layer,                  &
                                             STAT = status)

                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR02')


cd1:            if (MethodStatistic == Value3DStatLayers) then

!                    nullify(MLD_Surf)

                    !Gets Bathymetry
                    call GetGridData(Me%ObjGridData,                    &
                                       Bathymetry, STAT = status)

                    if (status /= SUCCESS_)                                              &
                        call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR03')


                    call GetStatisticLayersNumber(Me%Statistics%ID(np), LayersNumber, STAT = status)

                    if (status /= SUCCESS_)                                              &
                            call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR04')

                    do ln = 1, LayersNumber

                        call GetStatisticLayerDef(Me%Statistics%ID(np),     &
                                                  ln, LayerDefinition, STAT = status)

                        if (status /= SUCCESS_)                                          &
                            call SetError (FATAL_, INTERNAL_, 'OutPut_Statistics - ModuleHydrodynamic - ERR05')
                       !Statistic of properties values along the bottom
                        if (LayerDefinition == Layer) then

                            call AddStatisticLayers (StatisticID    = Me%Statistics%ID(np),         &
                                                     Value3D        = Value3D,                      &
                                                     WaterPoints3D  = Me%External_Var%WaterPoints3D,&
                                                     DZ3D           = Me%External_Var%DWZ,          &
                                                     LayerNumber    = ln,                           &
                                                     STAT= STAT_CALL)

                            if (STAT_CALL /= SUCCESS_)                                              &
                                call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR06')


                        !Statistic of properties values in the surface mixed layer
                        else if (LayerDefinition == Depth) then

                            call AddStatisticLayers (Me%Statistics%ID(np),                          &
                                                     Value3D       = Value3D,                       &
                                                     WaterPoints3D = Me%External_Var%WaterPoints3D, &
                                                     DZ3D          = Me%External_Var%DWZ,           &
                                                        LayerNumber   = ln,                            &
!                                                     LowerDepth    = MLD_Surf,                     &
                                                     STAT= status)

                            if (status /= SUCCESS_)                                              &
                                call SetError (FATAL_, INTERNAL_, 'OutPut_Statistics - ModuleWaterProperties - ERR07')

                        endif

                    enddo

                endif  cd1

                call ModifyStatistic (Me%Statistics%ID(np),                              &
                                      Value3D       = Value3D,                           &
                                      WaterPoints3D = Me%External_Var%WaterPoints3D,     &
                                      STAT          = status)
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR08')

            enddo

        endif

        if (Me%Statistics2D%ON) then

            do np = 1, Me%Statistics2D%NProp

                if (Me%Statistics2D%PropList(np) == WaterLevel_)           &
                    Value2D => WaterLevel

                if (Me%Statistics2D%PropList(np) == WaterColumn_)          &
                    Value2D => Me%External_Var%WaterColumn

                call GetStatisticMethod (Me%Statistics2D%ID(np), MethodStatistic, &
                                        STAT = status)

                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR09')

                call ModifyStatistic (Me%Statistics2D%ID(np),                              &
                                      Value2D       = Value2D,                           &
                                      WaterPoints2D = Me%External_Var%WaterPoints2D,     &
                                      STAT          = status)
                if (status /= SUCCESS_)                                                  &
                    call SetError (FATAL_, INTERNAL_, 'Statistics_OutPut - ModuleHydrodynamic - ERR10')

            enddo

        endif

    end subroutine Statistics_OutPut

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine SetHydroFather (HydrodynamicID, HydrodynamicFatherID, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HydrodynamicID, HydrodynamicFatherID
        logical,           intent(IN )              :: InitialField
        integer, optional, intent(OUT)              :: STAT


        !Local-----------------------------------------------------------------
        type (T_Hydrodynamic), pointer              :: ObjHydrodynamicFather
        integer                                     :: ready_, readyFather_
        integer                                     :: STAT_
        real                                        :: DT_Father
        real,    dimension(:,:,:), pointer          :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer          :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer          :: ZFather
        integer, dimension(:,:,:), pointer          :: Open3DFather
        integer, dimension(:,:,:), pointer          :: WetFaces_UFather
        integer, dimension(:,:,:), pointer          :: WetFaces_VFather
        integer, dimension(:,:,:), pointer          :: Faces3D_UFather
        integer, dimension(:,:,:), pointer          :: Faces3D_VFather
        real                                        :: DT_Son
        integer                                     :: status

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "SetHydroFather")

        STAT_ = UNKNOWN_

        call Ready      (HydrodynamicID, ready_)

        call ReadyFather(HydrodynamicFatherID, ObjHydrodynamicFather, readyFather_)

cd1 :   if (ready_ .EQ. IDLE_ERR_ .and. readyFather_ .EQ. IDLE_ERR_) then

            if(InitialField) then
                Me%FatherInstanceID = HydrodynamicFatherID

                call TestSubModelOptionsConsistence (ObjHydrodynamicFather%ComputeOptions%Continuous)
                call GetComputeTimeStep             (ObjHydrodynamicFather%ObjTime, DT_Father)

                if (Me%ComputeOptions%TwoWay)then
                    call AllocateTwoWayAux(HydrodynamicFatherID, HydrodynamicID)
                    if (ObjHydrodynamicFather%ComputeOptions%UpscalingDischarge)then
                        allocate(Me%Submodel%CopyU_New(ObjHydrodynamicFather%Size%ILB:ObjHydrodynamicFather%Size%IUB, &
                                 ObjHydrodynamicFather%Size%JLB:ObjHydrodynamicFather%Size%JUB, &
                                 ObjHydrodynamicFather%Size%KLB:ObjHydrodynamicFather%Size%KUB))
                        allocate(Me%Submodel%CopyV_New(ObjHydrodynamicFather%Size%ILB:ObjHydrodynamicFather%Size%IUB, &
                                 ObjHydrodynamicFather%Size%JLB:ObjHydrodynamicFather%Size%JUB, &
                                 ObjHydrodynamicFather%Size%KLB:ObjHydrodynamicFather%Size%KUB))
                        call Set_Upscaling_Discharges(HydrodynamicFatherID, ObjHydrodynamicFather, HydrodynamicID)
                    endif
                endif


                !Ang: new implementation
                Me%SubModel%FatherKLB = ObjHydrodynamicFather%WorkSize%KLB
                Me%SubModel%FatherKUB = ObjHydrodynamicFather%WorkSize%KUB

                call ConstructTimeInterpolation     (DT_Father)
            endif

            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_New)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_New)

            if (ObjHydrodynamicFather%LastIteration > Me%SubModel%NextTime &
                .or. InitialField) then

                call ReadLockFather(ObjHydrodynamicFather,                               &
                                    FluxXFather, FluxYFather,                            &
                                    Open3DFather, Faces3D_UFather, Faces3D_VFather,      &
                                    WetFaces_UFather, WetFaces_VFather,                  &
                                    UFather, VFather, ZFather, DUZFather, DVZFather)

                call ReadNextOrInitialField (UFather, VFather, DUZFather, DVZFather,     &
                                       FluxXFather, FluxYFather, ZFather, Open3DFather,  &
                                       Faces3D_UFather, Faces3D_VFather,                 &
                                       WetFaces_UFather, WetFaces_VFather, InitialField, &
                                       ObjHydrodynamicFather%ObjHorizontalGrid)

                !Unget Father information
                call ReadUnLockFather(ObjHydrodynamicFather,                             &
                                      FluxXFather, FluxYFather,                          &
                                      Open3DFather, Faces3D_UFather, Faces3D_VFather,    &
                                      WetFaces_UFather, WetFaces_VFather,                &
                                      UFather, VFather, ZFather, DUZFather, DVZFather)

                if (.not. InitialField) then

                    if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                &
                        (Me%SubModel%VertComunic == Father3DSon2D)) then

                        !Ang: new father-son implementation
                        call GetComputeTimeStep(Me%ObjTime, DT_Son, STAT = status)

                        if (status /= SUCCESS_)                                          &
                        call SetError(FATAL_, INTERNAL_,                                 &
                            "SetHydroFather; Hydrodynamic. ERR01")

                        !Get time for interpolation from aux variables
                        Me%SubModel%GetFatherTime = Me%SubModel%NextTime + DT_Son

                    endif

                    Me%SubModel%PreviousTime = Me%SubModel%NextTime
                    Me%SubModel%NextTime     = ObjHydrodynamicFather%LastIteration
                endif

            endif
            if      (Me%SubModel%VertComunic == FatherSonEqualDim) then
                call ActualizeSubModelValues(InitialField)

            else if (Me%SubModel%VertComunic == Father2DSon3D) then
                call ActualizeSon3DWithFather2D (InitialField)

            else if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                   &
                      (Me%SubModel%VertComunic == Father3DSon2D)) then
                !Ang: new implementation
                call ActualizeSon3DWithFather3D (InitialField)

            endif
!            if (Me%SubModel%DeadZone .and. InitialField  .and.           &
            if (InitialField  .and.                                                     &
                .not. Me%ComputeOptions%Continuous .and. Me%SubModel%FatherHotStart)                                      &
                call Initial_Geometry(Me%WaterLevel%New)

            STAT_ = SUCCESS_
        else cd1

            STAT_ = ready_

        end if cd1

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "SetHydroFather")

        if (present(STAT))  STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetHydroFather

    !--------------------------------------------------------------------------

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !>Gets logical variable TwoWay
    !>@param[in] HydrodynamicID, TwoWayOn, STAT
    subroutine GetModelHasTwoWay(HydrodynamicID, TwoWayOn, STAT)

        !Arguments-------------------------------------------------------------
        logical, intent(OUT)                        :: TwoWayOn
        integer                                     :: HydrodynamicID
        integer, optional                           :: STAT
        !Local-----------------------------------------------------------------
        integer                                     :: ready_, STAT_

        !-----------------------------------------------------------------------
        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            TwoWayOn = Me%ComputeOptions%TwoWay

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

    end subroutine GetModelHasTwoWay

    !-----------------------------------------------------------------------------
    subroutine TestSubModelOptionsConsistence(FatherContinuous)

        !Arguments-------------------------------------------------------------
        logical                                     :: FatherContinuous

        !Local-----------------------------------------------------------------
        logical                                     :: ModelGOTM, ContinuousGOTM
        integer                                     :: STAT_CALL

        !----------------------------------------------------------------------

        !Begin - Shorten variables name

        call GetContinuousGOTM(Me%ObjTurbulence, ContinuousGOTM, ModelGOTM, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError(FATAL_, INTERNAL_, 'TestSubModelOptionsConsistence - Hydrodynamic - ERR01.')


        if (FatherContinuous                      .and.                   &
           .not. Me%ComputeOptions%Continuous     .and.                   &
           .not. Me%ComputeOptions%BottomVisc_LIM .and.                   &
            ModelGOTM .and. .not. ContinuousGOTM) then

            write (*,*) 'In this case the submodel initial non-turbulent hydrodynamic properties'
            write (*,*) 'are initialised based in the father model but the turbulent properties are not.'
            write (*,*) 'In areas of strong velocities numerical instabilities mabe hObjen.'
            write (*,*) 'In this case the user is advised to use the option BOTTOMVISC_LIM.'
            write (*,*) 'See the user manual for more information about this option http://www.mohid.com.'

        endif

    end subroutine TestSubModelOptionsConsistence

    !--------------------------------------------------------------------------

    subroutine ActualizeSubModelValues (InitialField)

        !Arguments-------------------------------------------------------------
        logical,           intent(IN )     :: InitialField

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son, Bathymetry
        integer, dimension(:,:  ), pointer :: Boundary2DSon
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon
        integer, dimension(:,:,:), pointer :: Faces3D_VSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        real                               :: TimeCoef, MinWaterColumn
        integer                            :: status
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k
        logical                            :: ErrorOccured, DeadZoneSon
        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB


        if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime,                       &
                                       Me%CurrentTime, STAT = status)
            if (status /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR01")

            TimeCoef = (Me%CurrentTime       - Me%SubModel%PreviousTime) / &
                       (Me%SubModel%NextTime - Me%SubModel%PreviousTime)

            call null_Time(Me%CurrentTime)


        else

            TimeCoef = 1

        endif




        !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)
        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR02")



        call GetGeometryMinWaterColumn(Me%ObjGeometry, MinWaterColumn, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR03")



        call ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                     &
                         ImposedNormFacesUSon, ImposedNormFacesVSon,                     &
                         Water3DSon, Boundary2DSon,                                       &
                         Faces3D_USon, Faces3D_VSon,                                     &
                         DUZ_Son, DVZ_Son,                                               &
                         DXX_Son, DYY_Son)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ActualizeSubModelValues")

cd3:    if (InitialField) then

            ErrorOccured = .false.

            CHUNK = CHUNK_J(JLB, JUB + 1)

            !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon)

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif

!cd4:            if (((Faces3D_USon        (i, j, k) == Covered              .and.        &
!                      .not. Me%ComputeOptions%Continuous)   .or.         &

cd4:            if (( Faces3D_USon        (i, j, k) == Covered              .or.         &
                      ImposedTangFacesUSon(i, j, k) == Imposed              .or.         &
                      ImposedNormFacesUSon(i, j, k) == Imposed)             .and.        &
                      .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                    if (Me%SubModel%qX(i, j, k)  < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (ASMV1_OUT01)
                        write(*,*)'Point [i,j,k] not covered',i, j,k
                        ErrorOccured = .true.
                        !!!! $OMP END CRITICAL (ASMV1_OUT01)
#endif
                        if (Me%SubModel%MissingNull)                                    &
                            Me%SubModel%qX(i, j, k) = 0.
                    endif

                    if (.not. Me%ComputeOptions%Continuous)                             &
                        Me%WaterFluxes%X(i, j, k)               =                       &
                        Me%SubModel%qX (i, j, k) * DYY_Son(i, j)

                endif cd4

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP MASTER
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP END MASTER
            !$OMP BARRIER

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif

!cd5:            if (((Faces3D_VSon        (i, j, k) == Covered              .and.        &
!                      .not. Me%ComputeOptions%Continuous)   .or.         &
!                      ImposedTangFacesVSon(i, j, k) == Imposed              .or.         &
!                      ImposedNormFacesVSon(i, j, k) == Imposed)             .and.        &
!                      .not. DeadZoneSon) then

cd5:            if (( Faces3D_VSon        (i, j, k) == Covered              .or.         &
                      ImposedTangFacesVSon(i, j, k) == Imposed              .or.         &
                      ImposedNormFacesVSon(i, j, k) == Imposed)             .and.        &
                      .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then



                    if (Me%SubModel%qY  (i, j, k) < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (ASMV2_OUT02)
                        write(*,*)'Point [i,j,k] not covered',i, j,k
                        ErrorOccured = .true.
                        !!!! $OMP END CRITICAL (ASMV2_OUT02)
#endif
                        if (Me%SubModel%MissingNull)                     &
                            Me%SubModel%qY(i, j, k) = 0.
                    endif

                    if (.not. Me%ComputeOptions%Continuous)                             &
                        Me%WaterFluxes%Y(i, j, k)               =                       &
                        Me%SubModel%qY  (i, j, k) * DXX_Son(i, j)

                endif cd5

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo
            !$OMP END PARALLEL

            if (ErrorOccured .and. .not. Me%SubModel%MissingNull)        &
                call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR04")


        endif cd3

        CHUNK = CHUNK_J(JLB, JUB)

cd66:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous) .or. &
             Me%Relaxation%WaterLevel                               .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_)  then

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points)
                !are used to compute face areas where momentum fluxes are computed.
cd6:            if (Water3DSon(i, j, KUB) == WaterPoint .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)

                    if (Me%SubModel%Z(i, j) < (- Bathymetry(i, j) + 0.75 * MinWaterColumn)) then
                        Me%SubModel%Z(i, j) =  - Bathymetry(i, j) + 0.75 * MinWaterColumn
                    endif

                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then


                        if (.not.Me%SubModel%MissingNull) then
                            !!!! $OMP CRITICAL (ASMV3_ERR05)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR05")
                            !!!! $OMP END CRITICAL (ASMV3_ERR05)
                        endif

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%WaterLevel%New(i, j) = Me%SubModel%Z(i, j)


                endif cd6

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                                &
                call RemoveLowerSpikes (Me%WaterLevel%New, Water3DSon,                  &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB)

        else cd66

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points)
                !are used to compute face areas where momentum fluxes are computed.
cd67:           if (Boundary2DSon(i, j) == Boundary .and. Water3DSon(i, j, KUB) == WaterPoint  &
                   .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)

                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.)   then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantees that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 * MinWaterColumn

                        else
                            !!!! $OMP CRITICAL (ASMV4_ERR06)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR06")
                            !!!! $OMP END CRITICAL (ASMV4_ERR06)
                        endif
                    endif


                endif cd67

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                                &
                call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                      &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB, Boundary2DSon)



        endif cd66

        CHUNK = CHUNK_J(JLB, JUB + 1)
        !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon)

cd8:    if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. &
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif


cd7:            if (Faces3D_USon(i, j, k) == Covered .and. .not. DeadZoneSon) then

                    Me%SubModel%U_New(i, j, k)  =                            &
                            Me%SubModel%U_Next    (i, j, k) * TimeCoef  +    &
                            Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)


                    if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)   then

                        if (Me%SubModel%MissingNull) then
                            Me%SubModel%U_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV5_ERR07)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR07")
                            !!!! $OMP END CRITICAL (ASMV5_ERR07)
                        endif

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                        .and. Me%SubModel%FatherHotStart)                      &
                        Me%Velocity%Horizontal%U%New(i, j, k) =                &
                                   Me%SubModel%U_New(i, j, k)


                    Me%SubModel%DUZ_New(i, j, k)  =                          &
                            Me%SubModel%DUZ_Next    (i, j, k) * TimeCoef  +  &
                            Me%SubModel%DUZ_Previous(i, j, k) * (1 - TimeCoef)

                    if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then
                            Me%SubModel%DUZ_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV6_ERR08)
                            write(*,*) Me%ModelName
                            write(*,*) 'i, j, k'
                            write(*,*) i, j, k
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR08")
                            !!!! $OMP END CRITICAL (ASMV6_ERR08)
                        endif

                    endif

                endif cd7

            enddo
            enddo
            !$OMP END DO
            enddo

        endif cd8


        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB + 1
        do i = ILB, IUB

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

            else

                DeadZoneSon = .false.

            endif


cd77:       if ((ImposedTangFacesUSon(i, j, k) == Imposed  .or.                          &
                 ImposedNormFacesUSon(i, j, k) == Imposed) .and. .not. DeadZoneSon) then

                Me%SubModel%U_New(i, j, k)  =                            &
                        Me%SubModel%U_Next    (i, j, k) * TimeCoef  +    &
                        Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)

                if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then
                        Me%SubModel%U_New(i, j, k)  = 0.
                    else
                        write(*,*) Me%ModelName, Me%DDecomp%MPI_ID
                        write(*,*) 'i, j, k'
                        write(*,*) i, j, k
                        !!!! $OMP CRITICAL (ASMV7_ERR09)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR09")
                        !!!! $OMP END CRITICAL (ASMV7_ERR09)
                    endif
                endif


                if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                    .and. Me%SubModel%FatherHotStart)                      &
                    Me%Velocity%Horizontal%U%New(i, j, k) =                &
                               Me%SubModel%U_New(i, j, k)

                Me%SubModel%DUZ_New(i, j, k)  =                          &
                        Me%SubModel%DUZ_Next    (i, j, k) * TimeCoef  +  &
                        Me%SubModel%DUZ_Previous(i, j, k) * (1 - TimeCoef)

                if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then
                        Me%SubModel%DUZ_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV8_ERR10)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR10")
                        !!!! $OMP END CRITICAL (ASMV8_ERR10)
                    endif

                endif



            endif cd77

        enddo
        enddo
        !$OMP END DO
        enddo

        !$OMP MASTER
        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP END MASTER
        !$OMP BARRIER

cd10:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. &
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif


cd9:            if (Faces3D_VSon(i, j, k) == Covered .and. .not. DeadZoneSon) then


                    Me%SubModel%V_New(i, j, k)      =                        &
                            Me%SubModel%V_Next    (i, j, k) * TimeCoef  +    &
                            Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)

                    if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            Me%SubModel%V_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV9_ERR11)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR11")
                            !!!! $OMP END CRITICAL (ASMV9_ERR11)
                        endif
                    endif


                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%Velocity%Horizontal%V%New(i, j, k) =                &
                                   Me%SubModel%V_New(i, j, k)


                    Me%SubModel%DVZ_New(i, j, k)  =                          &
                            Me%SubModel%DVZ_Next    (i, j, k) * TimeCoef  +  &
                            Me%SubModel%DVZ_Previous(i, j, k) * (1 - TimeCoef)


                    if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                        Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then
                            Me%SubModel%DVZ_New(i, j, k)  = 0.
                        else
                            !!!! $OMP CRITICAL (ASMV10_ERR12)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR12")
                            !!!! $OMP END CRITICAL (ASMV10_ERR12)
                        endif

                    endif


                endif cd9


            enddo
            enddo
            !$OMP END DO
            enddo

        endif cd10


        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB + 1

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

            else

                DeadZoneSon = .false.

            endif


cd99:       if ((ImposedTangFacesVSon(i, j, k) == Imposed  .or.                          &
                 ImposedNormFacesVSon(i, j, k) == Imposed) .and. .not. DeadZoneSon) then


                Me%SubModel%V_New(i, j, k)      =                        &
                        Me%SubModel%V_Next    (i, j, k) * TimeCoef  +    &
                        Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)


                if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then
                        Me%SubModel%V_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV11_ERR13)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR13")
                        !!!! $OMP END CRITICAL (ASMV11_ERR13)
                    endif

                endif

                if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                    .and. Me%SubModel%FatherHotStart)                      &
                    Me%Velocity%Horizontal%V%New(i, j, k) =                &
                               Me%SubModel%V_New(i, j, k)

                Me%SubModel%DVZ_New(i, j, k)  =                          &
                        Me%SubModel%DVZ_Next    (i, j, k) * TimeCoef  +  &
                        Me%SubModel%DVZ_Previous(i, j, k) * (1 - TimeCoef)


                if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. .or.&
                    Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal / 2.)   then

                    if (Me%SubModel%MissingNull) then
                        Me%SubModel%DVZ_New(i, j, k)  = 0.
                    else
                        !!!! $OMP CRITICAL (ASMV12_ERR14)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR14")
                        !!!! $OMP END CRITICAL (ASMV12_ERR14)
                    endif

                endif

            endif cd99

        enddo
        enddo
        !$OMP END DO
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ActualizeSubModelValues")

        !This is only done for graphical reasons
        if (InitialField .and. .not. Me%ComputeOptions%Continuous .and. Me%SubModel%FatherHotStart) then

            !U corners
            Me%Velocity%Horizontal%U%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(ILB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JUB + 1, KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JUB + 1, KLB:KUB)


            !V corners
            Me%Velocity%Horizontal%V%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(ILB,JUB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JUB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JLB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JLB, KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JUB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JUB, KLB:KUB)


        endif

        Me%SubModel%Set      = .true.


        !UnGet son information
        call ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                   &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,                   &
                           Water3DSon, Boundary2DSon,                                     &
                           Faces3D_USon, Faces3D_VSon,                                   &
                           DUZ_Son, DVZ_Son,                                             &
                           DXX_Son, DYY_Son)


cd11:   if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            Me%WaterLevel%Old               (:,:  ) =                    &
                Me%WaterLevel%New           (:,:  )

            Me%Velocity%Horizontal%V%Old    (:,:,:) =                    &
                Me%Velocity%Horizontal%V%New(:,:,:)

            Me%Velocity%Horizontal%U%Old    (:,:,:) =                    &
                Me%Velocity%Horizontal%U%New(:,:,:)

            Me%SubModel%DUZ_Old(:,:,:)              =                    &
                Me%SubModel%DUZ_Next(:,:,:)

            Me%SubModel%DVZ_Old(:,:,:)              =                    &
                Me%SubModel%DVZ_Next(:,:,:)

        endif cd11

       !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSubModelValues; Hydrodynamic. ERR15")

    end subroutine ActualizeSubModelValues

    !--------------------------------------------------------------------------
    subroutine ActualizeSon3DWithFather2D (InitialField)

        !Arguments-------------------------------------------------------------
        logical,           intent(IN )  :: InitialField

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son, WaterColumnU, WaterColumnV, Bathymetry
        integer, dimension(:,:  ), pointer :: Boundary2DSon, KFloor_U, KFloor_V
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon
        integer, dimension(:,:,:), pointer :: Faces3D_VSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        real                               :: TimeCoef, RelativeThickness, MinWaterColumn
        integer                            :: status
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k, Kbottom, i_Thick, j_Thick
        logical                            :: ErrorOccured, DeadZoneSon, NullValue

        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------

        call GetGeometryWaterColumn(Me%ObjGeometry,                          &
                                    WaterColumnU= WaterColumnU, WaterColumnV= WaterColumnV,  &
                                    STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR01")


        call GetGeometryKFloor(Me%ObjGeometry,                           &
                               U = KFloor_U, V = KFloor_V, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR02")


       !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR03")


        call GetGeometryMinWaterColumn(Me%ObjGeometry,                   &
                                       MinWaterColumn, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR04")


        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime,                       &
                                       Me%CurrentTime, STAT = status)
            if (status /= SUCCESS_)                                                      &
                    call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR05")

            TimeCoef = (Me%CurrentTime       - Me%SubModel%PreviousTime) / &
                       (Me%SubModel%NextTime - Me%SubModel%PreviousTime)

            call null_Time(Me%CurrentTime)

        else

            TimeCoef = 1

        endif


        call ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                     &
                         ImposedNormFacesUSon, ImposedNormFacesVSon,                     &
                         Water3DSon, Boundary2DSon,                                       &
                         Faces3D_USon, Faces3D_VSon,                                     &
                         DUZ_Son, DVZ_Son,                                               &
                         DXX_Son, DYY_Son)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather2D")

cd3:    if (InitialField) then

            ErrorOccured = .false.
            CHUNK = CHUNK_J(JLB, JUB + 1)

            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon,NullValue,i_thick,j_thick) &
            !$OMP PRIVATE(Kbottom,k,RelativeThickness)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif


cd4:            if ((Faces3D_USon        (i, j, KUB) == Covered   .or.                   &
                     ImposedTangFacesUSon(i, j, KUB) == Imposed   .or.                   &
                     ImposedNormFacesUSon(i, j, KUB) == Imposed)  .and.                  &
                     .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                    NullValue = .false.

                    if (Me%SubModel%qX(i, j, KUB)  < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (AS3DWF2D1_OUT01)
                        write(*,*)'Point [i,j,k] not covered',i, j,KUB
                        !!!! $OMP END CRITICAL (AS3DWF2D1_OUT01)
#endif
                        ErrorOccured = .true.
                        if (Me%SubModel%MissingNull)                     &
                            NullValue = .true.

                    endif


                    if      (ImposedTangFacesUSon(i, j, KUB) == Imposed .or.             &
                             Faces3D_USon        (i, j, KUB) == Covered) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesUSon(i, j, KUB) == Imposed) then

                        i_thick = i

                        if      (j == JUB + 1) then

                            j_thick = j - 1

                        else if (j == JLB) then

                            j_thick = j + 1

                        else

                            j_thick = j + Faces3D_USon(i, j + 1, KUB) - Faces3D_USon(i, j - 1, KUB)

                        endif

                    endif

                    Kbottom = KFloor_U(i_thick, j_thick)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%qX  (i, j, k) = 0.

                        else

                            RelativeThickness = DUZ_Son(i_thick, j_thick, k) / WaterColumnU(i_thick, j_thick)

                            Me%SubModel%qX (i, j, k) =                       &
                                Me%SubModel%qX (i, j, KUB) * RelativeThickness

                        endif

                        if (.not. Me%ComputeOptions%Continuous)                         &
                            Me%WaterFluxes%X(i, j, k)               =                   &
                                Me%SubModel%qX (i, j, k  ) * DYY_Son(i, j)

                    enddo


                endif cd4

            enddo
            enddo
            !$OMP END DO

            !$OMP MASTER
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP END MASTER
            !$OMP BARRIER

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif


cd5:            if ((Faces3D_VSon        (i, j, KUB) == Covered   .or.                   &
                     ImposedTangFacesVSon(i, j, KUB) == Imposed   .or.                   &
                     ImposedNormFacesVSon(i, j, KUB) == Imposed)  .and.                  &
                     .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                    NullValue = .false.

                    if (Me%SubModel%qY  (i, j, KUB) < FillValueReal / 2.) then
#ifndef _USE_MPI
                        !!!! $OMP CRITICAL (AS3DWF2D2_OUT02)
                        write(*,*)'Point [i,j,k] not covered',i, j,KUB
                        !!!! $OMP END CRITICAL (AS3DWF2D2_OUT02)
#endif
                        ErrorOccured = .true.
                        if (Me%SubModel%MissingNull)                     &
                            NullValue = .true.
                    endif


                    if (ImposedTangFacesVSon(i, j, KUB) == Imposed .or.                  &
                        Faces3D_VSon        (i, j, KUB) == Covered ) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesVSon(i, j, KUB) == Imposed) then

                        if      (i == IUB + 1) then

                            i_thick = i - 1

                        else if (i == ILB) then

                            i_thick = i + 1

                        else

                            i_thick = i + Faces3D_VSon(i + 1, j, KUB) - Faces3D_VSon(i - 1, j, KUB)

                        endif

                        j_thick = j

                    endif

                    Kbottom = KFloor_V(i_thick, j_thick)


                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%qY  (i, j, k) = 0.

                        else

                            RelativeThickness = DVZ_Son(i_thick, j_thick, k) / WaterColumnV(i_thick, j_thick)

                            Me%SubModel%qY  (i, j, k) =                      &
                                Me%SubModel%qY  (i, j, KUB) * RelativeThickness

                        endif

                    enddo



                endif cd5

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (ErrorOccured .and. .not. Me%SubModel%MissingNull)        &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR06")

        endif cd3


cd66:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous) .or. &
             Me%Relaxation%WaterLevel                               .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_)  then
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points)
                !are used to compute face areas where momentum fluxes are computed.
cd6:            if (Water3DSon(i, j, KUB) == WaterPoint .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 * MinWaterColumn

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D3_ERR07)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR07")
                            !!!! $OMP END CRITICAL (AS3DWF2D3_ERR07)
                        endif

                    endif

!                    if (InitialField .and. .not. Me%ComputeOptions%Continuous) &
!                        Me%WaterLevel%New(i, j) =                              &
!                            Me%SubModel%Z(i, j)


                endif cd6

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
            if (Me%SubModel%MissingNull) then

                 call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                     &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB)
            endif

            if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                .and. Me%SubModel%FatherHotStart)                      &
                Me%WaterLevel%New(:, :) =                              &
                    Me%SubModel%Z(:, :)



        else cd66

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points)
                !are used to compute face areas where momentum fluxes are computed.
cd67:           if (Boundary2DSon(i, j) == Boundary .and. Water3DSon(i, j, KUB) == WaterPoint  &
                    .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                   &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +       &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.   &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 * MinWaterColumn

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D4_ERR08)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR08")
                            !!!! $OMP END CRITICAL (AS3DWF2D4_ERR08)
                        endif

                    endif

                endif cd67

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
            if (Me%SubModel%MissingNull)                                                &
                call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                      &
                                        Bathymetry, MinWaterColumn,                     &
                                        Me%SubModel%DeadZonePoint, Me%SubModel%DeadZone,&
                                        ILB, IUB, JLB, JUB, KUB, Boundary2DSon)


        endif cd66

        CHUNK = CHUNK_J(JLB, JUB + 1)
        !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon,NullValue,Kbottom) &
        !$OMP PRIVATE(RelativeThickness,i_thick,j_thick)

cd8:    if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. &
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif




cd7:            if (Faces3D_USon(i, j, KUB) == Covered  .and. .not. DeadZoneSon) then

                    NullValue = .false.

                    if (Me%SubModel%U_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%U_Previous(i, j, KUB) < FillValueReal / 2.)  then


                        if (Me%SubModel%MissingNull) then
                            NullValue = .true.
                        else
                            !!!! $OMP CRITICAL (AS3DWF2D5_ERR09)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR09")
                            !!!! $OMP END CRITICAL (AS3DWF2D5_ERR09)
                        endif

                    endif

                    Kbottom = KFloor_U(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%U_New(i, j, k)  =  0.


                        else


                            Me%SubModel%U_New(i, j, k)  =                                  &
                                     Me%SubModel%U_Next    (i, j, KUB) * TimeCoef  +       &
                                     Me%SubModel%U_Previous(i, j, KUB) * (1 - TimeCoef)


                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                           .and. Me%SubModel%FatherHotStart) &
                            Me%Velocity%Horizontal%U%New(i, j, k) = &
                                       Me%SubModel%U_New(i, j, k)


                    enddo

                    NullValue = .false.


                    if (Me%SubModel%DUZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%DUZ_Previous(i, j, KUB) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then

                            NullValue = .true.

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D6_ERR10)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR10")
                            !!!! $OMP END CRITICAL (AS3DWF2D6_ERR10)
                        endif

                    endif


                    Kbottom = KFloor_U(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%DUZ_New(i, j, k)  =  0.


                        else

                            RelativeThickness = DUZ_Son(i, j, k) / WaterColumnU(i, j)


                            Me%SubModel%DUZ_New(i, j, k)  =                                  &
                                    (Me%SubModel%DUZ_Next    (i, j, KUB) * TimeCoef        + &
                                     Me%SubModel%DUZ_Previous(i, j, KUB) * (1 - TimeCoef)) * &
                                     RelativeThickness

                        endif

                    enddo


                endif cd7

            enddo
            enddo
            !$OMP END DO

        endif cd8

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB + 1
        do i = ILB, IUB

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

            else

                DeadZoneSon = .false.

            endif


cd77:       if ((ImposedTangFacesUSon(i, j, KUB) == Imposed  .or.                         &
                 ImposedNormFacesUSon(i, j, KUB) == Imposed)  .and. .not. DeadZoneSon) then


                if (ImposedTangFacesUSon(i, j, KUB) == Imposed) then

                    i_thick = i
                    j_thick = j

                else if (ImposedNormFacesUSon(i, j, KUB) == Imposed) then

                    i_thick = i

                    if      (j == JUB + 1) then

                        j_thick = j - 1

                    else if (j == JLB) then

                        j_thick = j + 1

                    else

                        j_thick = j + Faces3D_USon(i, j + 1, KUB) - Faces3D_USon(i, j - 1, KUB)

                    endif

                endif

                NullValue = .false.

                if (Me%SubModel%U_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%U_Previous(i, j, KUB) < FillValueReal / 2.)    then

                    if (Me%SubModel%MissingNull) then

                        NullValue = .true.

                    else
                        !!!! $OMP CRITICAL (AS3DWF2D7_ERR11)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR11")
                        !!!! $OMP END CRITICAL (AS3DWF2D7_ERR11)
                    endif

                endif

                Kbottom = KFloor_U(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%U_New(i, j, k)  = 0.

                    else

                        Me%SubModel%U_New(i, j, k)  =                              &
                                 Me%SubModel%U_Next    (i, j, KUB) * TimeCoef  +   &
                                 Me%SubModel%U_Previous(i, j, KUB) * (1 - TimeCoef)

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%Velocity%Horizontal%U%New(i, j, k) =                &
                                   Me%SubModel%U_New(i, j, k)


                enddo

                NullValue = .false.

                if (Me%SubModel%DUZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%DUZ_Previous(i, j, KUB) < FillValueReal / 2.)    then

                    if (Me%SubModel%MissingNull) then

                        NullValue = .true.

                    else
                        !!!! $OMP CRITICAL (AS3DWF2D8_ERR12)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR12")
                        !!!! $OMP END CRITICAL (AS3DWF2D8_ERR12)
                    endif

                endif

                Kbottom = KFloor_U(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%DUZ_New(i, j, k) = 0.

                    else

                        RelativeThickness = DUZ_Son(i_thick, j_thick, k) / WaterColumnU(i_thick, j_thick)

                        Me%SubModel%DUZ_New(i, j, k)  =                                  &
                                (Me%SubModel%DUZ_Next    (i, j, KUB) * TimeCoef        + &
                                 Me%SubModel%DUZ_Previous(i, j, KUB) * (1 - TimeCoef)) * &
                                 RelativeThickness

                    endif


                enddo



            endif cd77

        enddo
        enddo
        !$OMP END DO

        !$OMP MASTER
        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP END MASTER

        !$OMP BARRIER
cd10:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)          .or. &
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or. &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif


cd9:            if (Faces3D_VSon(i, j, KUB) == Covered  .and. .not. DeadZoneSon) then

                    NullValue = .false.

                    if (Me%SubModel%V_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%V_Previous(i, j, KUB) < FillValueReal / 2.)  then

                        if (Me%SubModel%MissingNull) then

                            NullValue = .true.

                        else
                            !!!! $OMP CRITICAL (AS3DWF2D9_ERR13)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR13")
                            !!!! $OMP END CRITICAL (AS3DWF2D9_ERR13)
                        endif

                    endif


                    Kbottom = KFloor_V(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%V_New(i, j, k)      = 0.

                        else

                            Me%SubModel%V_New(i, j, k)      =                              &
                                     Me%SubModel%V_Next    (i, j, KUB) * TimeCoef        + &
                                     Me%SubModel%V_Previous(i, j, KUB) * (1 - TimeCoef)

                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                           .and. Me%SubModel%FatherHotStart)                       &
                            Me%Velocity%Horizontal%V%New(i, j, k) =                &
                                       Me%SubModel%V_New(i, j, k)

                    enddo

                    NullValue = .false.


                    if (Me%SubModel%DVZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                        Me%SubModel%DVZ_Previous(i, j, KUB) < FillValueReal / 2.)    then

                        if (Me%SubModel%MissingNull) then
                            NullValue = .true.
                        else
                            !!!! $OMP CRITICAL (AS3DWF2D10_ERR14)
                            call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR14")
                            !!!! $OMP END CRITICAL (AS3DWF2D10_ERR14)
                        endif

                    endif

                    Kbottom = KFloor_V(i, j)

                    do k = Kbottom, KUB

                        if (NullValue) then

                            Me%SubModel%DVZ_New(i, j, k) = 0.

                        else

                            RelativeThickness = DVZ_Son(i, j, k) / WaterColumnV(i, j)


                            Me%SubModel%DVZ_New(i, j, k)  =                                 &
                                    (Me%SubModel%DVZ_Next    (i, j, KUB) * TimeCoef       + &
                                     Me%SubModel%DVZ_Previous(i, j, KUB) * (1 - TimeCoef))* &
                                     RelativeThickness

                        endif


                    enddo


                endif cd9


            enddo
            enddo
            !$OMP END DO

        endif cd10

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB + 1

            if (Me%SubModel%DeadZone) then

                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

            else

                DeadZoneSon = .false.

            endif



cd99:       if ((ImposedTangFacesVSon(i, j, KUB) == Imposed  .or.                           &
                 ImposedNormFacesVSon(i, j, KUB) == Imposed) .and. .not. DeadZoneSon) then

                if (ImposedTangFacesVSon(i, j, KUB) == Imposed) then

                    i_thick = i
                    j_thick = j

                else if (ImposedNormFacesVSon(i, j, KUB) == Imposed) then

                    if      (i == IUB + 1) then

                        i_thick = i - 1

                    else if (i == ILB) then

                        i_thick = i + 1

                    else

                        i_thick = i + Faces3D_VSon(i + 1, j, KUB) - Faces3D_VSon(i - 1, j, KUB)

                    endif

                    j_thick = j

                endif

                NullValue = .false.

                if (Me%SubModel%V_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%V_Previous(i, j, KUB) < FillValueReal / 2.)  then

                    if (Me%SubModel%MissingNull) then
                        NullValue = .true.
                    else
                        !!!! $OMP CRITICAL (AS3DWF2D11_ERR15)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR15")
                        !!!! $OMP END CRITICAL (AS3DWF2D11_ERR15)
                    endif

                endif

                Kbottom = KFloor_V(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%V_New(i, j, k)      = 0.

                    else

                        Me%SubModel%V_New(i, j, k)      =                              &
                                 Me%SubModel%V_Next    (i, j, KUB) * TimeCoef        + &
                                 Me%SubModel%V_Previous(i, j, KUB) * (1 - TimeCoef)

                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous  &
                       .and. Me%SubModel%FatherHotStart)                       &
                        Me%Velocity%Horizontal%V%New(i, j, k) =                &
                                   Me%SubModel%V_New(i, j, k)


                enddo

                NullValue = .false.


                if (Me%SubModel%DVZ_Next    (i, j, KUB) < FillValueReal / 2. .or.&
                    Me%SubModel%DVZ_Previous(i, j, KUB) < FillValueReal / 2.) then

                    if (Me%SubModel%MissingNull) then
                        NullValue = .true.
                    else
                        !!!! $OMP CRITICAL (AS3DWF2D12_ERR16)
                        call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR16")
                        !!!! $OMP END CRITICAL (AS3DWF2D12_ERR16)
                    endif

                endif


                Kbottom = KFloor_V(i_thick, j_thick)

                do k = Kbottom, KUB

                    if (NullValue) then

                        Me%SubModel%DVZ_New(i, j, k)  = 0.

                    else


                        RelativeThickness = DVZ_Son(i_thick, j_thick, k) / WaterColumnV(i_thick, j_thick)


                        Me%SubModel%DVZ_New(i, j, k)  =                                  &
                                (Me%SubModel%DVZ_Next    (i, j, KUB) * TimeCoef        + &
                                 Me%SubModel%DVZ_Previous(i, j, KUB) * (1 - TimeCoef)) * &
                                RelativeThickness

                    endif

                enddo

            endif cd99

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL
        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather2D")

        !Tihs is only done for graphical reasons
        if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            !U corners
            Me%Velocity%Horizontal%U%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JLB    ,     KUB)

            Me%Velocity%Horizontal%U%New(ILB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (ILB,JUB + 1,     KUB)

            Me%Velocity%Horizontal%U%New(IUB,JLB    , KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JLB    ,     KUB)

            Me%Velocity%Horizontal%U%New(IUB,JUB + 1, KLB:KUB)   =       &
            Me%SubModel%U_New           (IUB,JUB + 1,     KUB)


            !V corners
            Me%Velocity%Horizontal%V%New(ILB,JLB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JLB    ,     KUB)

            Me%Velocity%Horizontal%V%New(ILB,JUB    , KLB:KUB)   =       &
            Me%SubModel%V_New           (ILB,JUB    ,     KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JLB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JLB,     KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JUB, KLB:KUB)   =       &
            Me%SubModel%V_New           (IUB + 1,JUB,     KUB)

        endif



        Me%SubModel%Set      = .true.

        !UnGet son information
        call ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,               &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,               &
                           Water3DSon, Boundary2DSon,                                 &
                           Faces3D_USon, Faces3D_VSon,                               &
                           DUZ_Son, DVZ_Son,                                         &
                           DXX_Son, DYY_Son)

cd11:   if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            Me%WaterLevel%Old               (:,:  ) =                &
                Me%WaterLevel%New           (:,:  )

            Me%Velocity%Horizontal%V%Old    (:,:,:) =                &
                Me%Velocity%Horizontal%V%New(:,:,:)

            Me%Velocity%Horizontal%U%Old    (:,:,:) =                &
                Me%Velocity%Horizontal%U%New(:,:,:)

            Me%SubModel%DUZ_Old(:,:,:)              =                &
                Me%SubModel%DUZ_Next(:,:,:)


            Me%SubModel%DVZ_Old(:,:,:)              =                &
                Me%SubModel%DVZ_Next(:,:,:)

        endif cd11

        call UnGetGeometry(Me%ObjGeometry,                               &
                           WaterColumnU, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR17")


        call UnGetGeometry(Me%ObjGeometry,                               &
                           WaterColumnV, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR18")


        call UnGetGeometry(Me%ObjGeometry,                               &
                           KFloor_U, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR19")


        call UnGetGeometry(Me%ObjGeometry,                               &
                           KFloor_V, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR20")


       !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                          &
                call SetError(FATAL_, INTERNAL_, "ActualizeSon3DWithFather2D; Hydrodynamic. ERR21")


    end subroutine ActualizeSon3DWithFather2D

    !--------------------------------------------------------------------------

    subroutine ActualizeSon3DWithFather3D (InitialField) !Ang: new implementation

        !Arguments-------------------------------------------------------------
        logical,           intent(IN )  :: InitialField

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son, WaterColumnU, WaterColumnV, Bathymetry
        integer, dimension(:,:  ), pointer :: Boundary2DSon, KFloor_U, KFloor_V
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon
        integer, dimension(:,:,:), pointer :: Faces3D_VSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        real                               :: TimeCoef, RelativeThickness, MinWaterColumn
        integer                            :: status
        integer                            :: KLBFather, KUBFather
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k, Kbottom, i_Thick, j_Thick
        logical                            :: ErrorOccured, DeadZoneSon, NullValue
        logical                            :: FoundBottom, FoundSurface
        integer                            :: kfather, kfatherinic, k2, k2father
        integer                            :: NDepths, Aux
        real                               :: TotalDUVZ_Son, ExcessDUVZ_Son, AuxDepth
        real                               :: AuxDUVZ_Son, AuxDUVZ_Father, SumDUVZ_Son
        real                               :: DeficitValue_Father, ExcessValue_Father
        real                               :: AuxDeficit, AuxSonDepth
        real(8)                            :: SonDepth
        real(8), dimension (:), pointer    :: Depths, Values
        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------


        call GetGeometryWaterColumn(Me%ObjGeometry,                                 &
                                    WaterColumnU= WaterColumnU,                     &
                                    WaterColumnV= WaterColumnV,                     &
                                    STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR01")

        call GetGeometryKFloor(Me%ObjGeometry,                                      &
                               U = KFloor_U, V = KFloor_V, STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR02")


       !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR03")


        call GetGeometryMinWaterColumn(Me%ObjGeometry,                              &
                                       MinWaterColumn, STAT = status)

        if (status /= SUCCESS_)                                                     &
                call SetError(FATAL_, INTERNAL_,                                    &
                          "ActualizeSon3DWithFather3D; Hydrodynamic. ERR04")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime,                                  &
                                       Me%CurrentTime, STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_,                                    &
                        "ActualizeSon3DWithFather3D; Hydrodynamic. ERR05")

            TimeCoef = (Me%CurrentTime       - Me%SubModel%PreviousTime) /          &
                       (Me%SubModel%NextTime - Me%SubModel%PreviousTime)

        else

            TimeCoef = 1

        endif

        !Ang: new father-son implementation
        !Get father layers
        KLBFather = Me%SubModel%FatherKLB
        KUBFather = Me%SubModel%FatherKUB

        !Get data for vertical interpolation father-son layers
        if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                    &
            Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime)         &
            .or. InitialField) then

            !allocate father depth values arrays
            allocate(Depths(KLBFather: KUBFather),STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR06")

            allocate(Values(KLBFather: KUBFather),STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR07")

        endif

        call ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                &
                         ImposedNormFacesUSon, ImposedNormFacesVSon,                &
                         Water3DSon, Boundary2DSon,                                 &
                         Faces3D_USon, Faces3D_VSon,                                &
                         DUZ_Son, DVZ_Son,                                          &
                         DXX_Son, DYY_Son)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather3D")

cd1:    if (InitialField) then

            ErrorOccured = .false.

            CHUNK = CHUNK_J(JLB, JUB + 1)

            !$OMP PARALLEL PRIVATE(i,j,k,kfatherinic,RelativeThickness,TotalDUVZ_Son, &
            !$OMP                   ExcessDUVZ_Son,ExcessValue_Father,DeadZoneSon,NullValue, &
            !$OMP                   i_thick,j_thick,Kbottom,AuxDUVZ_Son,kfather, &
            !$OMP                   AuxDUVZ_Father,k2,k2father, &
            !$OMP                   SumDUVZ_Son,DeficitValue_Father,AuxDeficit)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB + 1
            do i = ILB, IUB

                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0
                ExcessValue_Father = 0.0

do1:            do k = KUB, KLB, -1
                    !(in practice cycle goes only to local Kbottom)

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif

cd2:                if ((Faces3D_USon        (i, j, k) == Covered   .or.            &
                         ImposedTangFacesUSon(i, j, k) == Imposed   .or.            &
                         ImposedNormFacesUSon(i, j, k) == Imposed)  .and.           &
                         .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                        NullValue = .false.

                        if (Me%SubModel%Aux_qX(i, j, KUBFather)                     &
                        < FillValueReal / 2.) then
#ifndef _USE_MPI
                            write(*,*)'Point [i,j,k] not covered',i, j,k
#endif
                            ErrorOccured = .true.
                            if (Me%SubModel%MissingNull)                            &
                                NullValue = .true.

                        endif

                        if      (ImposedTangFacesUSon(i, j, k) == Imposed .or.      &
                                 Faces3D_USon        (i, j, k) == Covered) then

                            i_thick = i
                            j_thick = j

                        else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                            i_thick = i

                            if      (j == JUB + 1) then

                                j_thick = j - 1

                            else if (j == JLB) then

                                j_thick = j + 1

                            else

                                j_thick = j + Faces3D_USon(i, j + 1, k) -           &
                                          Faces3D_USon(i, j - 1, k)

                            endif

                        endif

                        Kbottom = KFloor_U(i_thick, j_thick)

                        !initialize variable
                        Me%SubModel%qX(i, j, k) = 0

                        if (.not. NullValue) then
                            !(father values exist for at least one (father) layer)

                            !DUZ is need for weighting
                            AuxDUVZ_Son = DUZ_Son(i_thick, j_thick, k)

do2:                        do kfather = kfatherinic, KLBFather, -1

                                !layers from surface to bottom

                                if ((Me%SubModel%Aux_qX(i, j, kfather)               &
                                    < FillValueReal / 2.) .or.                       &
                                    (Me%SubModel%Aux_DUZ(i, j, kfather)              &
                                    < FillValueReal / 2.)) then
                                    !if father values do not exist

                                    ErrorOccured = .true.
                                    if (Me%SubModel%MissingNull)                    &
                                        !son layers assumed null values
                                        exit do2
                                        !(should all layers be null if first is null?)

                                endif

                                AuxDUVZ_Father = Me%SubModel%Aux_DUZ(i, j, kfather)
                                !(since it is father and not exited loop (i,j) value
                                ! exists!)

                                if (AuxDUVZ_Son .le.                            &
                                    RelativeThickness*AuxDUVZ_Father) then

                                    !son layer inside father layer part
                                    RelativeThickness = AuxDUVZ_Son*            &
                                        RelativeThickness / AuxDUVZ_Father

                                    Me%SubModel%qX(i, j, k) =                   &
                                        Me%SubModel%qX(i, j, k) +               &
                                        Me%SubModel%Aux_qX(i, j, kfather)       &
                                        * RelativeThickness

                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        AuxDUVZ_Son

                                    if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                        AllmostZero) then
                                        !(AuxDUVZ_Son == AuxDUVZ_Father)

                                        !this father layer is already solved, solve next
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1

                                    else

                                        RelativeThickness = 1 - RelativeThickness

                                    endif

                                    AuxDUVZ_Son = 0.0

                                    exit do2

                                else

                                    !son layer includes father layer part
                                    Me%SubModel%qX(i, j, k) =                   &
                                        Me%SubModel%qX(i, j, k) +               &
                                        Me%SubModel%Aux_qX(i, j, kfather)       &
                                        * RelativeThickness

                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        RelativeThickness*AuxDUVZ_Father

                                    !get the remaing part of DUZ_Son
                                    AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                        RelativeThickness*AuxDUVZ_Father

                                    !seek in the next father layer
                                    kfatherinic = kfatherinic - 1
                                    RelativeThickness = 1

                                endif

                            enddo do2

                            !check if excess or deficit flux variable exists
                            if ((AuxDUVZ_Son /= 0.0) .and.                          &
                                (kfather == KLBFather)) then
                                !last son layer was not fulfilled by father values
                                !(all the next son layers are not fulfilled also)

                                if (Me%SubModel%MomentConserv) then

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KBottom) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DUZ_Son(i_thick, j_thick, k2)

                                        enddo

                                    endif

                                else

                                    if (k-1 .ge. KBottom) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            Me%SubModel%qX(i, j, k) = 0

                                        enddo

                                    endif

                                endif

                                exit do1

                            else if ((k == Kbottom) .and.                           &
                                ((RelativeThickness /= 1) .or.                      &
                                (kfather /= KLBFather)) .and.                       &
                                Me%SubModel%MomentConserv) then
                                !all son layers are fulfilled with father values
                                !but excedent father layer part exist

                                if (RelativeThickness /= 1)                         &
                                    ExcessValue_Father =                            &
                                    Me%SubModel%Aux_qX(i, j, kfather)*              &
                                    RelativeThickness

                                if (kfather - 1 .ge. KLBFather) then
                                    !add values of next father layers

do3:                                do k2father = kfather - 1, KLBFather, - 1
                                        !layers from surface to bottom

                                        if (Me%SubModel%Aux_qX(i, j, k2father)      &
                                            < FillValueReal / 2.) then

                                            exit do3

                                        else

                                            ExcessValue_Father = ExcessValue_Father &
                                                + Me%SubModel%Aux_qX(i, j, k2father)

                                        endif

                                    enddo do3

                                endif

                            endif

                        endif

                        if (.not. Me%ComputeOptions%Continuous)                         &
                            Me%WaterFluxes%X(i, j, k)               =                   &
                                Me%SubModel%qX (i, j, k) * DYY_Son(i, j)

                        if (k == KBottom) then

                            exit do1
                        endif

                    endif cd2

                enddo do1

                if (Me%SubModel%MomentConserv) then

                    if (ExcessDUVZ_Son /= 0.0) then
                        !Correct son layer values for the deficit of father values

                        SumDUVZ_Son = 0.0
                        DeficitValue_Father = 0.0

                        do k = KUB, KLB, -1
                        !(in practice cycle goes only to local Kbottom)

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd3:                        if ((Faces3D_USon        (i, j, k) == Covered   .or.    &
                             ImposedTangFacesUSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesUSon(i, j, k) == Imposed)  .and.       &
                             .not. DeadZoneSon .and. .not. Me%SubModel%HotStartData) then

                                if      (ImposedTangFacesUSon(i, j, k) == Imposed .or. &
                                         Faces3D_USon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                                    i_thick = i

                                    if      (j == JUB + 1) then

                                        j_thick = j - 1

                                    else if (j == JLB) then

                                        j_thick = j + 1

                                    else

                                        j_thick = j + Faces3D_USon(i, j + 1, k) -   &
                                                  Faces3D_USon(i, j - 1, k)

                                    endif

                                endif

                                Kbottom = KFloor_U(i_thick, j_thick)

                                SumDUVZ_Son = SumDUVZ_Son + DUZ_Son(i_thick, j_thick, k)

                                if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                    !layers having father value

                                    AuxDeficit = Me%SubModel%qX(i,j,k)*             &
                                        ExcessDUVZ_Son*DUZ_Son(i_thick, j_thick, k) &
                                        /TotalDUVZ_Son

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove flux variable from layer
                                    Me%SubModel%qX(i,j,k) = Me%SubModel%qX(i,j,k)   &
                                       - AuxDeficit

                                elseif (AuxDUVZ_Son /= 0.0) then
                                    !son layer partially with father value
                                    AuxDeficit = Me%SubModel%qX(i,j,k)*             &
                                        ExcessDUVZ_Son*(DUZ_Son(i_thick, j_thick, k) &
                                        - AuxDUVZ_Son)/TotalDUVZ_Son

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove and add
                                    Me%SubModel%qX(i,j,k) =                         &
                                        Me%SubModel%qX(i,j,k) - AuxDeficit +        &
                                        DeficitValue_Father*AuxDUVZ_Son/            &
                                        (WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                    AuxDUVZ_Son = 0.0
                                    !(layer completed)

                                else
                                    !fill son layer without father value

                                    !add collected value
                                    Me%SubModel%qX(i,j,k) = DeficitValue_Father*    &
                                        DUZ_Son(i_thick,j_thick,k)                  &
                                        /(WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                endif

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%X(i, j, k)               =           &
                                        Me%SubModel%qX (i, j, k) * DYY_Son(i, j)

                            endif cd3

                        enddo

                    elseif (ExcessValue_Father /= 0.0) then
                        !Correct son layer values for the excess of father values

                        do k = KUB, KLB, - 1
                            !layers from surface to bottom

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd4:                        if ((Faces3D_USon        (i, j, k) == Covered   .or.    &
                             ImposedTangFacesUSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesUSon(i, j, k) == Imposed)  .and.       &
                             .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                                if (ImposedTangFacesUSon(i, j, k) == Imposed .or.   &
                                         Faces3D_USon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                                    i_thick = i

                                    if      (j == JUB + 1) then

                                        j_thick = j - 1

                                    else if (j == JLB) then

                                        j_thick = j + 1

                                    else

                                        j_thick = j + Faces3D_USon(i, j + 1, k) -   &
                                                  Faces3D_USon(i, j - 1, k)

                                    endif

                                endif

                                Kbottom = KFloor_U(i_thick, j_thick)

                                Me%SubModel%qX(i,j,k) = Me%SubModel%qX(i,j,k) +     &
                                    ExcessValue_Father*DUZ_Son(i_thick, j_thick, k) &
                                    / WaterColumnU(i_thick, j_thick)

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%X(i, j, k)               =           &
                                        Me%SubModel%qX (i, j, k) * DYY_Son(i, j)

                            endif cd4

                        enddo

                    endif

                endif

            enddo
            enddo
            !$OMP END DO

            !$OMP MASTER
            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP END MASTER
            !$OMP BARRIER

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB + 1

                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0
                ExcessValue_Father = 0.0

do4:            do k = KUB, KLB, -1
                    !(in practice cycle goes only to local Kbottom)

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif

cd5:                if ((Faces3D_VSon        (i, j, k) == Covered   .or.            &
                         ImposedTangFacesVSon(i, j, k) == Imposed   .or.            &
                         ImposedNormFacesVSon(i, j, k) == Imposed)  .and.           &
                         .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                        NullValue = .false.

                        if (Me%SubModel%Aux_qY(i, j, KUBFather)                     &
                        < FillValueReal / 2.) then
#ifndef _USE_MPI
                            !!!! $OMP CRITICAL (AS3DWF3D1_OUT01)
                           write(*,*)'Point [i,j,k] not covered',i, j,k
                            !!!! $OMP END CRITICAL (AS3DWF3D1_OUT01)
#endif
                            ErrorOccured = .true.
                            if (Me%SubModel%MissingNull)                            &
                                NullValue = .true.

                        endif

                        if      (ImposedTangFacesVSon(i, j, k) == Imposed .or.      &
                                 Faces3D_VSon        (i, j, k) == Covered) then

                            i_thick = i
                            j_thick = j

                        else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                            if      (i == IUB + 1) then

                                i_thick = i - 1

                            else if (i == ILB) then

                                i_thick = i + 1

                            else

                                i_thick = i + Faces3D_VSon(i + 1, j, k) -           &
                                        Faces3D_VSon(i - 1, j, k)

                            endif

                            j_thick = j

                        endif

                        Kbottom = KFloor_V(i_thick, j_thick)

                        !initialize variable
                        Me%SubModel%qY(i, j, k) = 0

                        if (.not. NullValue) then
                            !(father values exist for at least one (father) layer)

                            !DVZ is needed for weighting
                            AuxDUVZ_Son = DVZ_Son(i_thick, j_thick, k)

do5:                        do kfather = kfatherinic, KLBFather, -1

                                !layers from surface to bottom

                                if ((Me%SubModel%Aux_qY(i, j, kfather)              &
                                    < FillValueReal / 2.) .or.                      &
                                    (Me%SubModel%Aux_DVZ(i, j, kfather)             &
                                    < FillValueReal / 2.)) then
                                    !if father values do not exist

                                    ErrorOccured = .true.
                                    if (Me%SubModel%MissingNull)                    &
                                        !son layers assumed null values
                                        exit do5
                                        !(should all layers be null if first is null?)

                                endif

                                AuxDUVZ_Father = Me%SubModel%Aux_DVZ(i, j, kfather)
                                !(since it is father and not exited loop (i,j) value
                                ! exists!)

                                if (AuxDUVZ_Son .le.                            &
                                    RelativeThickness*AuxDUVZ_Father) then

                                    !son layer inside father layer part
                                    RelativeThickness = AuxDUVZ_Son*            &
                                        RelativeThickness / AuxDUVZ_Father

                                    Me%SubModel%qY(i, j, k) =                   &
                                        Me%SubModel%qY(i, j, k) +               &
                                        Me%SubModel%Aux_qY(i, j, kfather)       &
                                        * RelativeThickness

                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        AuxDUVZ_Son

                                    if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                        AllmostZero) then
                                        !(AuxDUVZ_Son == AuxDUVZ_Father)

                                        !this father layer is already solved, solve next
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1

                                    else

                                        RelativeThickness = 1 - RelativeThickness

                                    endif

                                    AuxDUVZ_Son = 0.0

                                    exit do5

                                else

                                    !son layer includes father layer part
                                    Me%SubModel%qY(i, j, k) =                   &
                                        Me%SubModel%qY(i, j, k) +               &
                                        Me%SubModel%Aux_qY(i, j, kfather)       &
                                        * RelativeThickness

                                    TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                        RelativeThickness*AuxDUVZ_Father

                                    !get the remaing part of DVZ_Son
                                    AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                        RelativeThickness*AuxDUVZ_Father

                                    !seek in the next father layer
                                    kfatherinic = kfatherinic - 1
                                    RelativeThickness = 1

                                endif

                            enddo do5

                            !check if excess or deficit flux variable exists
                            if ((AuxDUVZ_Son /= 0.0) .and.                          &
                                (kfather == KLBFather)) then
                                !last son layer was not fulfilled by father values
                                !(all the next son layers are not fulfilled also)

                                if (Me%SubModel%MomentConserv) then

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KBottom) then
                                        !add DVZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DVZ_Son(i_thick, j_thick, k2)

                                        enddo

                                    endif

                                else

                                    if (k-1 .ge. KBottom) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KBottom, - 1
                                            !layers from surface to bottom

                                            Me%SubModel%qY(i, j, k) = 0

                                        enddo

                                    endif

                                endif

                                exit do4

                            else if ((k == Kbottom) .and.                           &
                                ((RelativeThickness /= 1) .or.                      &
                                (kfather /= KLBFather)) .and.                       &
                                Me%SubModel%MomentConserv) then
                                !all son layers are fulfilled with father values
                                !but excedent father layer part exist

                                if (RelativeThickness /= 1)                         &
                                ExcessValue_Father =                                &
                                    Me%SubModel%Aux_qY(i, j, kfather)*              &
                                    RelativeThickness

                                if (kfather - 1 .ge. KLBFather) then
                                    !add values of next father layers

do6:                                do k2father = kfather - 1, KLBFather, - 1
                                        !layers from surface to bottom

                                        if (Me%SubModel%Aux_qY(i, j, k2father)      &
                                            < FillValueReal / 2.) then

                                            exit do6

                                        else

                                            ExcessValue_Father = ExcessValue_Father &
                                                + Me%SubModel%Aux_qY(i, j, k2father)

                                        endif

                                    enddo do6

                                endif

                            endif

                        endif

                        if (.not. Me%ComputeOptions%Continuous)                         &
                            Me%WaterFluxes%Y(i, j, k)               =                   &
                                Me%SubModel%qY (i, j, k) * DXX_Son(i, j)

                        if (k == KBottom) then

                            exit do4
                        endif

                    endif cd5

                enddo do4

                if (Me%SubModel%MomentConserv) then

                    if (ExcessDUVZ_Son /= 0.0) then
                        !Correct son layer values for the deficit of father values

                        SumDUVZ_Son = 0.0
                        DeficitValue_Father = 0.0

                        do k = KUB, KLB, -1
                        !(in practice cycle goes only to local Kbottom)

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd6:                        if ((Faces3D_VSon (i, j, k) == Covered   .or.           &
                             ImposedTangFacesVSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesVSon(i, j, k) == Imposed)  .and.       &
                             .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                                if      (ImposedTangFacesVSon(i, j, k) == Imposed .or. &
                                         Faces3D_VSon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                                    if      (i == IUB + 1) then

                                        i_thick = i - 1

                                    else if (i == ILB) then

                                        i_thick = i + 1

                                    else

                                        i_thick = i + Faces3D_VSon(i + 1, j, k) -   &
                                                  Faces3D_VSon(i - 1, j, k)

                                    endif

                                    j_thick = j

                                endif

                                Kbottom = KFloor_V(i_thick, j_thick)

                                SumDUVZ_Son = SumDUVZ_Son + DVZ_Son(i_thick, j_thick, k)

                                if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                    !layers having father value

                                    AuxDeficit = Me%SubModel%qX(i,j,k)*             &
                                        ExcessDUVZ_Son*DVZ_Son(i_thick, j_thick, k) &
                                        /TotalDUVZ_Son

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove flux variable from layer
                                    Me%SubModel%qY(i,j,k) = Me%SubModel%qY(i,j,k)   &
                                       - AuxDeficit

                                elseif (AuxDUVZ_Son /= 0.0) then
                                    !son layer partially with father value
                                    AuxDeficit = Me%SubModel%qY(i,j,k)*             &
                                        ExcessDUVZ_Son*(DVZ_Son(i_thick, j_thick, k) &
                                        - AuxDUVZ_Son)/TotalDUVZ_Son

                                    !actualize the value of the father deficit
                                    DeficitValue_Father = DeficitValue_Father +     &
                                        AuxDeficit

                                    !remove and add
                                    Me%SubModel%qY(i,j,k) =                         &
                                        Me%SubModel%qY(i,j,k) - AuxDeficit +        &
                                        DeficitValue_Father*AuxDUVZ_Son/            &
                                        (WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                    AuxDUVZ_Son = 0.0
                                    !(layer completed)

                                else
                                    !fill son layer without father value

                                    !add collected value
                                    Me%SubModel%qY(i,j,k) = DeficitValue_Father*    &
                                        DVZ_Son(i_thick,j_thick,k)                  &
                                        /(WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                endif

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%Y(i, j, k)               =           &
                                        Me%SubModel%qY (i, j, k) * DXX_Son(i, j)

                            endif cd6

                        enddo

                    elseif (ExcessValue_Father /= 0.0) then
                        !Correct son layer values for the excess of father values

                        do k = KUB, KLB, - 1
                            !layers from surface to bottom

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd7:                        if ((Faces3D_VSon        (i, j, k) == Covered   .or.    &
                             ImposedTangFacesVSon(i, j, k) == Imposed   .or.        &
                             ImposedNormFacesVSon(i, j, k) == Imposed)  .and.       &
                             .not. DeadZoneSon  .and. .not. Me%SubModel%HotStartData) then

                                if      (ImposedTangFacesVSon(i, j, k) == Imposed .or. &
                                         Faces3D_VSon        (i, j, k) == Covered) then

                                    i_thick = i
                                    j_thick = j

                                else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                                    if      (i == IUB + 1) then

                                        i_thick = i - 1

                                    else if (i == ILB) then

                                        i_thick = i + 1

                                    else

                                        i_thick = i + Faces3D_VSon(i + 1, j, k) -   &
                                                  Faces3D_VSon(i - 1, j, k)

                                    endif

                                    j_thick = j

                                endif

                                Kbottom = KFloor_V(i_thick, j_thick)

                                Me%SubModel%qY(i,j,k) = Me%SubModel%qY(i,j,k) +     &
                                    ExcessValue_Father*DVZ_Son(i_thick, j_thick, k) &
                                    / WaterColumnV(i_thick, j_thick)

                                if (.not. Me%ComputeOptions%Continuous)                 &
                                    !recalculate the water fluxes
                                    Me%WaterFluxes%Y(i, j, k)               =           &
                                        Me%SubModel%qY (i, j, k) * DXX_Son(i, j)

                            endif cd7

                        enddo

                    endif

                endif

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (ErrorOccured .and. .not. Me%SubModel%MissingNull)                   &
                call SetError(FATAL_, INTERNAL_,                                    &
                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR08")

        endif cd1


cd8:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous) .or.             &
             Me%Relaxation%WaterLevel                               .or.            &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_)  then

             CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j,k,DeadZoneSon)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points)
                !are used to compute face areas where momentum fluxes are computed.
cd9:            if (Water3DSon(i, j, KUB) == WaterPoint .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                          &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +              &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.      &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            !Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 *      &
                                                   MinWaterColumn

                        else
                            !!!! $OMP CRITICAL (AS3DWF3D2_ERR09)
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR09")
                            !!!! $OMP END CRITICAL (AS3DWF3D2_ERR09)
                        endif

                    endif

                endif cd9

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull) then

                 call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                 &
                                        Bathymetry, MinWaterColumn,                 &
                                        Me%SubModel%DeadZonePoint,                  &
                                        Me%SubModel%DeadZone,                       &
                                        ILB, IUB, JLB, JUB, KUB)
            endif

            if (InitialField .and. .not. Me%ComputeOptions%Continuous               &
                .and. Me%SubModel%FatherHotStart)                                   &
                Me%WaterLevel%New(:, :) =                                           &
                    Me%SubModel%Z(:, :)


        else cd8

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,DeadZoneSon)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, KUB)

                else

                    DeadZoneSon = .false.

                endif

                !The test must be done for the water points because the water levels in the corner (no open points)
                !are used to compute face areas where momentum fluxes are computed.
cd10:           if (Boundary2DSon(i, j) == Boundary .and. Water3DSon(i, j, KUB)     &
                    == WaterPoint .and. .not. DeadZoneSon) then

                    Me%SubModel%Z(i, j)  =                                          &
                            Me%SubModel%Z_Next    (i, j) * TimeCoef  +              &
                            Me%SubModel%Z_Previous(i, j) * (1 - TimeCoef)


                    if (Me%SubModel%Z_Next    (i, j) < FillValueReal / 2. .or.      &
                        Me%SubModel%Z_Previous(i, j) < FillValueReal / 2.) then

                        if (Me%SubModel%MissingNull) then
                            !The cell is considered uncovered if WaterColumn < MinWaterColumn
                            !if WaterColumn < MinWaterColumn / 2 the model put WaterColumn = MinWaterColumn / 2 (creates water)
                            ! Using WaterColumn = 3/4MinWaterColumn garantes that the cell is uncovered but mass is not created
                            Me%SubModel%Z(i, j)  = - Bathymetry(i, j) + 0.75 *      &
                                                   MinWaterColumn

                        else
                            !!!! $OMP CRITICAL (AS3DWF3D3_ERR10)
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR10")
                            !!!! $OMP END CRITICAL (AS3DWF3D3_ERR10)
                        endif

                    endif

                endif cd10

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (Me%SubModel%MissingNull)                                            &
                call RemoveLowerSpikes (Me%SubModel%Z, Water3DSon,                  &
                                        Bathymetry, MinWaterColumn,                 &
                                        Me%SubModel%DeadZonePoint,                  &
                                        Me%SubModel%DeadZone,                       &
                                        ILB, IUB, JLB, JUB, KUB, Boundary2DSon)


        endif cd8

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ActualizeSon3DWithFather3D")

cd11:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)        .or.     &
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or.                   &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

             !ACanas: This subroutine following cycles were not parallelized
             !ACanas: because of function calls in cycle iterations
             !ACanas: which causes errors in results.

            do j = JLB, JUB + 1
            do i = ILB, IUB

                if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.             &
                     Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime) &
                    .or. InitialField) then
                    !Time to interpolate vertical layers father to son!

                    NullValue = .false.

                    !find the first father layer for interpolation
                    Aux = KLBFather
                    AuxDepth = 0.0

                    do kfather=KUBFather, KLBFather, -1
                        if ((Me%SubModel%Aux_U(i, j, kfather)                       &
                            < FillValueReal / 2.) .or.                              &
                            (Me%SubModel%Aux_DUZ(i, j, kfather)                     &
                            < FillValueReal / 2.)) then
                            Aux = kfather + 1
                           exit
                        else
                            Values(kfather) = Me%SubModel%Aux_U(i,j,kfather)
                            Depths(kfather) = AuxDepth +                            &
                                Me%SubModel%Aux_DUZ(i,j,kfather)/2
                            AuxDepth = AuxDepth + Me%SubModel%Aux_DUZ(i,j,kfather)
                        endif
                    enddo

                    if (Aux == KUBFather + 1) then

                        if (Me%SubModel%MissingNull) then
                            NullValue = .true.
                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR11")
                        endif
                    endif

                    !get number of father depths
                    NDepths = KUBFather - Aux + 1
                    AuxSonDepth = 0.0

                    !DUZ_Next calculation variables
                    !look father layer beginning at the topest layer
                    kfatherinic = KUBFather
                    RelativeThickness = 1.0

                    TotalDUVZ_Son = 0.0
                    ExcessDUVZ_Son = 0.0

                    SumDUVZ_Son = 0.0
                    DeficitValue_Father = 0.0

                endif

                Kbottom = KFloor_U(i, j)

do7:            do k = KUB, KLB, -1

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif

cd12:               if (Faces3D_USon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                        if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.   &
                            Me%SubModel%InterPolTime) .or.                          &
                            (.not. Me%SubModel%InterPolTime)                        &
                            .or. InitialField) .and. (.not. NullValue)) then
                            !Time to interpolate vertical layers father to son!

                            !(get U_Next from father)

                            !get son cell depth
                            SonDepth = AuxSonDepth + DUZ_Son(i, j, k)/2
                            AuxSonDepth = AuxSonDepth + DUZ_Son(i, j, k)

                            !interpolate father values as a profile
                            Me%SubModel%U_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)

                            if (InitialField)                                       &
                                Me%SubModel%U_Previous(i,j,k) =                     &
                                    Me%SubModel%U_Next(i,j,k)

                            if (.not. Me%SubModel%MomentConserv) then

                                !layer thicknesses are completely determined by son's
                                Me%SubModel%DUZ_Next(i, j, k) = DUZ_Son(i, j, k)

                            else

                                !initialize variable
                                Me%SubModel%DUZ_Next(i, j, k) = 0

                                !(father values exist for at least one layer)

                                !DUZ is need for weighting
                                AuxDUVZ_Son = DUZ_Son(i, j, k)

do8:                            do kfather = kfatherinic, KLBFather, -1
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DUZ(i, j, kfather)          &
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull) then
                                            !son layers assumed null values
                                            exit do8

                                        else
                                            call SetError(FATAL_, INTERNAL_,        &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR12")
                                        endif

                                    endif

                                    AuxDUVZ_Father = Me%SubModel%Aux_DUZ(i,j,kfather)

                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son

                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1

                                        else

                                            RelativeThickness = 1 - RelativeThickness

                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do8

                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaining part of DUZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1

                                    endif

                                enddo do8

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DUZ_Son(i, j, k2)

                                        enddo

                                    endif

                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist

                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DUZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

do9:                                    do k2father = kfather - 1, KLBFather, - 1
                                            !layers from surface to bottom

                                            if (Me%SubModel%Aux_DUZ(i, j,k2father)  &
                                                < FillValueReal / 2.) then

                                                exit do9

                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DUZ(i, j, k2father)

                                            endif

                                        enddo do9

                                    endif

                                endif

                            endif

                            if (InitialField) then

                                Me%SubModel%DUZ_Previous(i,j,k) =                   &
                                    Me%SubModel%DUZ_Next(i,j,k)

                            endif

                        endif

                        !Time interpolation of variables (performed always!)
                        !(for velocity)
                        if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or. &
                            Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)  then

                            if (Me%SubModel%MissingNull) then

                                Me%SubModel%U_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR13")
                            endif

                        else

                            Me%SubModel%U_New(i, j, k)  =                           &
                                Me%SubModel%U_Next    (i, j, k) * TimeCoef  +       &
                                Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)

                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous   &
                           .and. Me%SubModel%FatherHotStart)                        &
                            Me%Velocity%Horizontal%U%New(i, j, k) =                 &
                                       Me%SubModel%U_New(i, j, k)

                        !(for DUZ it may be provisory)
                        if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2.  &
                            .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal  &
                            / 2.) then

                            if (Me%SubModel%MissingNull) then

                                Me%SubModel%DUZ_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR14")
                            endif

                        else

                            Me%SubModel%DUZ_New(i, j, k)  =                         &
                                     Me%SubModel%DUZ_Next    (i, j, k) *            &
                                     TimeCoef +                                     &
                                     Me%SubModel%DUZ_Previous(i, j, k) *            &
                                     (1 - TimeCoef)

                        endif

                    endif cd12

                    if (k == Kbottom) exit do7

                enddo do7

                if (Me%SubModel%MomentConserv) then
                    !Check if correction is needed

                    if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do21:                   do k = KUB, KLB, -1

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd13:                       if (Faces3D_USon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                                if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) &
                                    .and. Me%SubModel%InterPolTime) .or.            &
                                    (.not. Me%SubModel%InterPolTime)                &
                                    .or. InitialField) .and. (.not. NullValue)) then
                                    !Check if layer values from father need to be corrected
                                    !(capitalizing on the DO cycle)

                                    if (ExcessDUVZ_Son /= 0.0) then
                                        !Correct son layer values for the deficit of father values

                                        SumDUVZ_Son = SumDUVZ_Son + DUZ_Son(i, j, k)

                                        if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                            !layers having father value

                                            AuxDeficit = Me%SubModel%DUZ_Next(i,j,k)* &
                                                ExcessDUVZ_Son*DUZ_Son(i, j, k)     &
                                                /TotalDUVZ_Son

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove flux variable from layer
                                            Me%SubModel%DUZ_Next(i,j,k) =           &
                                                            Me%SubModel%DUZ_Next(i,j,k) &
                                                            - AuxDeficit

                                        elseif (AuxDUVZ_Son /= 0.0) then
                                            !son layer partially with father value
                                            AuxDeficit = Me%SubModel%DUZ_next(i,j,k)* &
                                                ExcessDUVZ_Son*(DUZ_Son(i, j, k)    &
                                                - AuxDUVZ_Son)/TotalDUVZ_Son

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove and add
                                            Me%SubModel%DUZ_Next(i,j,k) =           &
                                                Me%SubModel%DUZ_Next(i,j,k) - AuxDeficit + &
                                                DeficitValue_Father*AuxDUVZ_Son/    &
                                                (WaterColumnU(i, j) - TotalDUVZ_Son)

                                            AuxDUVZ_Son = 0.0
                                            !(layer completed)

                                        else
                                            !fill son layer without father value

                                            !add collected value
                                            Me%SubModel%DUZ_Next(i,j,k) =           &
                                                DeficitValue_Father*                &
                                                DUZ_Son(i,j,k)                      &
                                                /(WaterColumnU(i, j) - TotalDUVZ_Son)

                                        endif

                                    elseif (ExcessValue_Father /= 0.0) then
                                        !Correct son layer values for the excess of father values

                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                            Me%SubModel%DUZ_Next(i,j,k) +           &
                                            ExcessValue_Father*DUZ_Son(i, j, k)/    &
                                            WaterColumnU(i, j)

                                    endif

                                    if (InitialField) then

                                        Me%SubModel%DUZ_Previous(i,j,k) =           &
                                                              Me%SubModel%DUZ_Next(i,j,k)

                                    endif


                                endif

                                if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. &
                                    .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal &
                                    / 2.) then

                                    if (Me%SubModel%MissingNull) then

                                        Me%SubModel%DUZ_New(i, j, k)  =  0.

                                    else
                                        call SetError(FATAL_, INTERNAL_,            &
                                        "ActualizeSon3DWithFather3D; Hydrodynamic. ERR15")
                                    endif

                                else

                                    Me%SubModel%DUZ_New(i, j, k)  =                 &
                                             Me%SubModel%DUZ_Next    (i, j, k) *    &
                                             TimeCoef +                             &
                                             Me%SubModel%DUZ_Previous(i, j, k) *    &
                                             (1 - TimeCoef)

                                endif

                            endif cd13

                            if (k == Kbottom) exit do21

                        enddo do21

                    endif

                endif

            enddo
            enddo

        endif cd11

        do j = JLB, JUB + 1
        do i = ILB, IUB

            if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                &
                Me%SubModel%InterPolTime) .or.                                      &
                (.not. Me%SubModel%InterPolTime)   .or. InitialField) then
                !Time to interpolate vertical layers father to son!

                !U_Next calculation variables
                AuxSonDepth = 0.0

                !DUZ_Next calculation variables
                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0

                SumDUVZ_Son = 0.0
                DeficitValue_Father = 0.0

            endif

do10:       do k = KUB, KLB, -1

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif

cd14:           if ((ImposedTangFacesUSon(i, j, k) == Imposed  .or.                 &
                 ImposedNormFacesUSon(i, j, k) == Imposed)  .and.                   &
                 .not. DeadZoneSon) then

                    if (ImposedTangFacesUSon(i, j, k) == Imposed) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                        i_thick = i

                        if      (j == JUB + 1) then

                            j_thick = j - 1

                        else if (j == JLB) then

                            j_thick = j + 1

                        else

                            j_thick = j + Faces3D_USon(i, j + 1, k) -               &
                                      Faces3D_USon(i, j - 1, k)

                        endif

                    endif

                    if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.        &
                        Me%SubModel%InterPolTime) .or.                              &
                        (.not. Me%SubModel%InterPolTime) .or. InitialField) then
                        !Time to interpolate vertical layers father to son!

                        NullValue = .false.

                        !find the first father layer for interpolation
                        Aux = KLBFather
                        AuxDepth = 0.0

                        do kfather=KUBFather, KLBFather, -1
                            if ((Me%SubModel%Aux_U(i, j, kfather)                   &
                                < FillValueReal / 2.) .or.                          &
                                (Me%SubModel%Aux_DUZ(i, j, kfather)                 &
                                < FillValueReal / 2.)) then
                                Aux = kfather + 1
                               exit
                            else
                                Values(kfather) = Me%SubModel%Aux_U(i,j,kfather)
                                Depths(kfather) = AuxDepth +                        &
                                    Me%SubModel%Aux_DUZ(i, j,kfather)/2
                                AuxDepth = AuxDepth +                               &
                                    Me%SubModel%Aux_DUZ(i, j,kfather)
                                !(since it is father (i,j) value exists!)
                            endif
                        enddo

                        if (Aux == KUBFather + 1) then

                            if (Me%SubModel%MissingNull) then
                                NullValue = .true.
                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR16")
                            endif
                        endif

                        if (.not. NullValue) then
                        !(father values exist for at least one layer)

                            !get number of father depths
                            NDepths = KUBFather - Aux + 1

                            !Time to interpolate vertical layers father to son!
                            !(get U_Next from father)

                            !get son cell depth
                            SonDepth = AuxSonDepth + DUZ_Son(i_thick, j_thick, k)/2
                            AuxSonDepth = AuxSonDepth + DUZ_Son(i_thick, j_thick, k)

                            !interpolate father values as a profile
                            Me%SubModel%U_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)

                            if (InitialField)                                       &
                                Me%SubModel%U_Previous(i,j,k) =                     &
                                    Me%SubModel%U_Next(i,j,k)

                            if (.not. Me%SubModel%MomentConserv) then

                                Me%SubModel%DUZ_Next(i, j, k) = DUZ_Son(i_thick,    &
                                                                j_thick, k)
                                !(has to be used i_thick, j_thick because i,j dont exist)

                            else

                                !Time to interpolate vertical layers father to son!
                                !(get DUZ/DVZ from father)
                                !initialize variable
                                Me%SubModel%DUZ_Next(i, j, k) = 0

                                !DUZ is need for weighting
                                AuxDUVZ_Son = DUZ_Son(i_thick, j_thick, k)

do11:                           do kfather = kfatherinic, KLBFather, -1
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DUZ(i, j,kfather)           &
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull)                &
                                            !son layers assumed null values
                                            exit do11

                                    endif

                                    AuxDUVZ_Father =                                &
                                        Me%SubModel%Aux_DUZ(i, j, kfather)
                                    !(since not exited from loop (i,j) value exists!)

                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son

                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1

                                        else

                                            RelativeThickness = 1 - RelativeThickness

                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do11

                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DUZ_Next(i, j, k) =             &
                                            Me%SubModel%DUZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DUZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaing part of DUZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1
                                    endif
                                enddo do11

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DUZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DUZ_Son(i_thick, j_thick, k2)
                                        enddo
                                    endif
                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist

                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DUZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

do12:                                   do k2father = kfather - 1, KLBFather, - 1
                                            !layers from surface to bottom

                                            if (Me%SubModel%Aux_DUZ(i, j,k2father)  &
                                                < FillValueReal / 2.) then

                                                exit do12
                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DUZ(i, j, k2father)
                                            endif

                                        enddo do12
                                    endif
                                endif
                            endif

                            if (InitialField) then

                                Me%SubModel%DUZ_Previous(i,j,k) =                   &
                                                    Me%SubModel%DUZ_Next(i,j,k)
                            endif
                        endif
                    endif

                    Kbottom = KFloor_U(i_thick, j_thick)

                    !Time interpolation of variables (performed always!)
                    !(here just for velocity)
                    if (Me%SubModel%U_Next    (i, j, k) < FillValueReal / 2. .or.   &
                        Me%SubModel%U_Previous(i, j, k) < FillValueReal / 2.)  then

                        if (Me%SubModel%MissingNull) then

                            Me%SubModel%U_New(i, j, k)  =  0.

                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR17")
                        endif
                    else

                        Me%SubModel%U_New(i, j, k)  =                               &
                            Me%SubModel%U_Next    (i, j, k) * TimeCoef  +           &
                            Me%SubModel%U_Previous(i, j, k) * (1 - TimeCoef)
                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous       &
                        .and. Me%SubModel%FatherHotStart)                           &
                        Me%Velocity%Horizontal%U%New(i, j, k) =                     &
                                   Me%SubModel%U_New(i, j, k)

                    !(for DUZ)
                    if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2.      &
                        .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal      &
                        / 2.) then

                        if (Me%SubModel%MissingNull) then

                            Me%SubModel%DUZ_New(i, j, k)  =  0.

                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR18")
                        endif
                    else

                        Me%SubModel%DUZ_New(i, j, k)  =                             &
                                 Me%SubModel%DUZ_Next    (i, j, k) *                &
                                 TimeCoef +                                         &
                                 Me%SubModel%DUZ_Previous(i, j, k) *                &
                                 (1 - TimeCoef)
                    endif
                endif cd14

                if (k == Kbottom) exit do10
            enddo do10


            if (Me%SubModel%MomentConserv) then

                if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do22:               do k = KUB, KLB, -1

                        if (Me%SubModel%DeadZone) then

                            DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)
                        else

                            DeadZoneSon = .false.
                        endif

cd15:                   if ((ImposedTangFacesUSon(i, j, k) == Imposed  .or.         &
                         ImposedNormFacesUSon(i, j, k) == Imposed)  .and.           &
                         .not. DeadZoneSon) then

                            if (ImposedTangFacesUSon(i, j, k) == Imposed) then

                                i_thick = i
                                j_thick = j

                            else if (ImposedNormFacesUSon(i, j, k) == Imposed) then

                                i_thick = i

                                if      (j == JUB + 1) then

                                    j_thick = j - 1

                                else if (j == JLB) then

                                    j_thick = j + 1

                                else

                                    j_thick = j + Faces3D_USon(i, j + 1, k) -       &
                                              Faces3D_USon(i, j - 1, k)

                                endif
                            endif

                            Kbottom = KFloor_U(i_thick, j_thick)

                            if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) .and. &
                                Me%SubModel%InterPolTime) .or.                       &
                                (.not. Me%SubModel%InterPolTime) .or. InitialField)  &
                                .and. (.not. NullValue)) then
                                !Check if layer values from father need to be corrected
                                !(capitalizing on the DO cycle)

                                if (ExcessDUVZ_Son /= 0.0) then
                                    !Correct son layer values for the deficit of father values

                                    SumDUVZ_Son = SumDUVZ_Son + DUZ_Son(i_thick, j_thick, k)

                                    if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                        !layers having father value

                                        AuxDeficit = Me%SubModel%DUZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*DUZ_Son(i_thick, j_thick, k) &
                                            /TotalDUVZ_Son

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove flux variable from layer
                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                                        Me%SubModel%DUZ_Next(i,j,k) &
                                                        - AuxDeficit

                                    elseif (AuxDUVZ_Son /= 0.0) then
                                        !son layer partially with father value
                                        AuxDeficit = Me%SubModel%DUZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*(DUZ_Son(i_thick, j_thick, k) &
                                            - AuxDUVZ_Son)/TotalDUVZ_Son

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove and add
                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                            Me%SubModel%DUZ_Next(i,j,k) - AuxDeficit + &
                                            DeficitValue_Father*AuxDUVZ_Son/        &
                                            (WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                        AuxDUVZ_Son = 0.0
                                        !(layer completed)

                                    else
                                        !fill son layer without father value

                                        !add collected value
                                        Me%SubModel%DUZ_Next(i,j,k) =               &
                                            DeficitValue_Father*                    &
                                            DUZ_Son(i_thick, j_thick,k)             &
                                            /(WaterColumnU(i_thick, j_thick) - TotalDUVZ_Son)

                                    endif

                                elseif (ExcessValue_Father /= 0.0) then
                                    !Correct son layer values for the excess of father values

                                    Me%SubModel%DUZ_Next(i,j,k) =                   &
                                        Me%SubModel%DUZ_Next(i,j,k) +               &
                                        ExcessValue_Father*DUZ_Son(i_thick, j_thick,k)/ &
                                        WaterColumnU(i_thick, j_thick)

                                endif

                                if (InitialField) then

                                    Me%SubModel%DUZ_Previous(i,j,k) =               &
                                                            Me%SubModel%DUZ_Next(i,j,k)

                                endif

                            endif

                            !Time interpolation of variables (performed always!)
                            !(here just for DUZ/DVZ)

                            if (Me%SubModel%DUZ_Next    (i, j, k) < FillValueReal / 2. &
                                .or. Me%SubModel%DUZ_Previous(i, j, k) < FillValueReal &
                                / 2.) then

                                if (Me%SubModel%MissingNull) then

                                    Me%SubModel%DUZ_New(i, j, k)  =  0.

                                else
                                    call SetError(FATAL_, INTERNAL_,                &
                                         "ActualizeSon3DWithFather3D; Hydrodynamic. ERR19")
                                endif

                            else

                                Me%SubModel%DUZ_New(i, j, k)  =                     &
                                         Me%SubModel%DUZ_Next    (i, j, k) *        &
                                         TimeCoef +                                 &
                                         Me%SubModel%DUZ_Previous(i, j, k) *        &
                                         (1 - TimeCoef)

                            endif

                        endif cd15

                        if (k == Kbottom) exit do22

                    enddo do22

                endif

            endif

        enddo
        enddo

cd16:   if ((InitialField .and. .not. Me%ComputeOptions%Continuous)        .or.     &
             Me%Relaxation%Force .or. Me%Relaxation%Velocity .or.                   &
             Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            do j = JLB, JUB
            do i = ILB, IUB + 1

                if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.            &
                    Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime) &
                    .or. InitialField) then
                    !Time to interpolate vertical layers father to son!

                    NullValue = .false.

                    !find the first father layer for interpolation
                    Aux = KLBFather
                    AuxDepth = 0.0

                    do kfather=KUBFather, KLBFather, -1
                        if ((Me%SubModel%Aux_V(i, j, kfather)                       &
                            < FillValueReal / 2.) .or.                              &
                            (Me%SubModel%Aux_DVZ(i, j, kfather)                     &
                            < FillValueReal / 2.)) then
                            Aux = kfather + 1
                           exit
                        else
                            Values(kfather) = Me%SubModel%Aux_V(i,j,kfather)
                            Depths(kfather) = AuxDepth +                            &
                                Me%SubModel%Aux_DVZ(i,j,kfather)/2
                            AuxDepth = AuxDepth + Me%SubModel%Aux_DVZ(i,j,kfather)
                        endif
                    enddo

                    if (Aux == KUBFather + 1) then

                        if (Me%SubModel%MissingNull) then
                            NullValue = .true.
                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                "ActualizeSon3DWithFather3D; Hydrodynamic. ERR20")
                        endif
                    endif

                    !get number of father depths
                    NDepths = KUBFather - Aux + 1
                    AuxSonDepth = 0.0

                    !DUZ_Next calculation variables
                    !look father layer beginning at the topest layer
                    kfatherinic = KUBFather
                    RelativeThickness = 1.0

                    TotalDUVZ_Son = 0.0
                    ExcessDUVZ_Son = 0.0

                    SumDUVZ_Son = 0.0
                    DeficitValue_Father = 0.0

                endif

                Kbottom = KFloor_V(i, j)

do13:           do k = KUB, KLB, -1

                    if (Me%SubModel%DeadZone) then

                        DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                    else

                        DeadZoneSon = .false.

                    endif

cd17:               if (Faces3D_VSon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                        if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.   &
                            Me%SubModel%InterPolTime) .or.                          &
                            (.not. Me%SubModel%InterPolTime)                        &
                            .or. InitialField) .and. (.not. NullValue)) then
                            !Time to interpolate vertical layers father to son!
                            !(get V_Next from father)

                            !get son cell depth
                            SonDepth = AuxSonDepth + DVZ_Son(i, j, k)/2
                            AuxSonDepth = AuxSonDepth + DVZ_Son(i, j, k)

                            !interpolate father values as a profile
                            Me%SubModel%V_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)

                            if (InitialField)                                       &
                                Me%SubModel%V_Previous(i,j,k) =                     &
                                    Me%SubModel%V_Next(i,j,k)

                            if (.not. Me%SubModel%MomentConserv) then

                                Me%SubModel%DVZ_Next(i, j, k) = DVZ_Son(i, j, k)

                            else

                                !initialize variable
                                Me%SubModel%DVZ_Next(i, j, k) = 0

                                !(father values exist for at least one layer)

                                !DVZ is need for weighting
                                AuxDUVZ_Son = DVZ_Son(i, j, k)

do14:                           do kfather = kfatherinic, KLBFather, -1
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DVZ(i, j, kfather)          &
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull) then
                                            !son layers assumed null values
                                            exit do14

                                        else
                                            call SetError(FATAL_, INTERNAL_,        &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR21")
                                        endif

                                    endif

                                    AuxDUVZ_Father = Me%SubModel%Aux_DVZ(i,j,kfather)

                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son

                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1

                                        else

                                            RelativeThickness = 1 - RelativeThickness

                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do14

                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaing part of DUZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1

                                    endif

                                enddo do14

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DVZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DVZ_Son(i, j, k2)

                                        enddo

                                    endif

                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist

                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DVZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

do15:                                   do k2father = kfather - 1, KLBFather, - 1
                                            !layers from surface to bottom

                                            if (Me%SubModel%Aux_DVZ(i, j,k2father)  &
                                                < FillValueReal / 2.) then

                                                exit do15

                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DVZ(i, j, k2father)

                                            endif

                                        enddo do15

                                    endif

                                endif

                            endif

                            if (InitialField) then

                                Me%SubModel%DVZ_Previous(i,j,k) =                   &
                                                        Me%SubModel%DVZ_Next(i,j,k)
                            endif
                        endif

                        !Time interpolation of variables (performed always!)
                        !(in this place just for velocity)
                        if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or. &
                            Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.)  then

                            if (Me%SubModel%MissingNull) then

                                Me%SubModel%V_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR22")
                            endif

                        else

                            Me%SubModel%V_New(i, j, k)  =                           &
                                Me%SubModel%V_Next    (i, j, k) * TimeCoef  +       &
                                Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)

                        endif

                        if (InitialField .and. .not. Me%ComputeOptions%Continuous   &
                            .and. Me%SubModel%FatherHotStart)                       &
                            Me%Velocity%Horizontal%V%New(i, j, k) =                 &
                                       Me%SubModel%V_New(i, j, k)

                        !(for DVZ)
                        if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2.  &
                            .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal  &
                            / 2.) then

                            if (Me%SubModel%MissingNull) then

                                Me%SubModel%DVZ_New(i, j, k)  =  0.

                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR23")
                            endif
                        else

                            Me%SubModel%DVZ_New(i, j, k)  =                         &
                                     Me%SubModel%DVZ_Next    (i, j, k) *            &
                                     TimeCoef +                                     &
                                     Me%SubModel%DVZ_Previous(i, j, k) *            &
                                     (1 - TimeCoef)

                        endif
                    endif cd17

                    if (k == Kbottom) exit do13

                enddo do13

                if (Me%SubModel%MomentConserv) then
                !Time interpolation of variables (performed always!)
                !(this place for DUZ/DVZ)

                    if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do23:                   do k = KUB, KLB, -1 !!!!do16?

                            if (Me%SubModel%DeadZone) then

                                DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                            else

                                DeadZoneSon = .false.

                            endif

cd18:                       if (Faces3D_VSon(i, j, k) == Covered  .and. .not. DeadZoneSon) then

                                if ((((Me%CurrentTime == Me%SubModel%GetFatherTime) &
                                    .and. Me%SubModel%InterPolTime) .or.            &
                                    (.not. Me%SubModel%InterPolTime)                &
                                    .or. InitialField) .and. (.not. NullValue)) then
                                    !Check if layer values from father need to be corrected
                                    !(capitalizing on the DO cycle)

                                    if (ExcessDUVZ_Son /= 0.0) then
                                        !Correct son layer values for the deficit of father values

                                        SumDUVZ_Son = SumDUVZ_Son + DVZ_Son(i, j, k)

                                        if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                            !layers having father value

                                            AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)* &
                                                ExcessDUVZ_Son*DVZ_Son(i, j, k)     &
                                                /TotalDUVZ_Son

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove flux variable from layer
                                            Me%SubModel%DVZ_Next(i,j,k) =           &
                                                            Me%SubModel%DVZ_Next(i,j,k) &
                                                            - AuxDeficit

                                        elseif (AuxDUVZ_Son /= 0.0) then
                                            !son layer partially with father value
                                            AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)* &
                                                ExcessDUVZ_Son*(DVZ_Son(i, j, k)    &
                                                - AuxDUVZ_Son)/TotalDUVZ_Son

                                            !actualize the value of the father deficit
                                            DeficitValue_Father = DeficitValue_Father + &
                                                AuxDeficit

                                            !remove and add
                                            Me%SubModel%DVZ_Next(i,j,k) =           &
                                                Me%SubModel%DVZ_Next(i,j,k) - AuxDeficit + &
                                                DeficitValue_Father*AuxDUVZ_Son/    &
                                                (WaterColumnV(i, j) - TotalDUVZ_Son)

                                            AuxDUVZ_Son = 0.0
                                            !(layer completed)

                                        else
                                            !fill son layer without father value

                                            !add collected value
                                            Me%SubModel%DVZ_Next(i,j,k) =           &
                                                DeficitValue_Father*                &
                                                DVZ_Son(i,j,k)                      &
                                                /(WaterColumnV(i, j) - TotalDUVZ_Son)

                                        endif

                                    elseif (ExcessValue_Father /= 0.0) then
                                        !Correct son layer values for the excess of father values

                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                            Me%SubModel%DVZ_Next(i,j,k) +           &
                                            ExcessValue_Father*DVZ_Son(i, j, k)/    &
                                            WaterColumnV(i, j)

                                    endif

                                    if (InitialField) then

                                        Me%SubModel%DVZ_Previous(i,j,k) =           &
                                            Me%SubModel%DVZ_Next(i,j,k)

                                    endif

                                endif

                                if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. &
                                    .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal &
                                    / 2.) then

                                    if (Me%SubModel%MissingNull) then

                                        Me%SubModel%DVZ_New(i, j, k)  =  0.

                                    else
                                        call SetError(FATAL_, INTERNAL_,            &
                                             "ActualizeSon3DWithFather3D; Hydrodynamic. ERR24")
                                    endif

                                else

                                    Me%SubModel%DVZ_New(i, j, k)  =                 &
                                             Me%SubModel%DVZ_Next    (i, j, k) *    &
                                             TimeCoef +                             &
                                             Me%SubModel%DVZ_Previous(i, j, k) *    &
                                             (1 - TimeCoef)

                                endif

                            endif cd18

                            if (k == Kbottom) exit do23

                        enddo do23

                    endif

                endif

            enddo
            enddo

        endif cd16

        do j = JLB, JUB
        do i = ILB, IUB + 1

            if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                &
                Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime)     &
                .or. InitialField) then
                !Time to interpolate vertical layers father to son!

                !V_Next calculation variables
                AuxSonDepth = 0.0

                !DVZ_Next calculation variables
                !look father layer beginning at the topest layer
                kfatherinic = KUBFather
                RelativeThickness = 1.0

                TotalDUVZ_Son = 0.0
                ExcessDUVZ_Son = 0.0

                SumDUVZ_Son = 0.0
                DeficitValue_Father = 0.0

            endif

do16:       do k = KUB, KLB, -1 !!!!do17?

                if (Me%SubModel%DeadZone) then

                    DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                else

                    DeadZoneSon = .false.

                endif

cd19:           if ((ImposedTangFacesVSon(i, j, k) == Imposed  .or.                 &
                 ImposedNormFacesVSon(i, j, k) == Imposed)  .and.                   &
                 .not. DeadZoneSon) then

                    if (ImposedTangFacesVSon(i, j, k) == Imposed) then

                        i_thick = i
                        j_thick = j

                    else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                        if      (i == IUB + 1) then

                            i_thick = i - 1

                        else if (i == ILB) then

                            i_thick = i + 1

                        else

                            i_thick = i + Faces3D_VSon(i + 1, j, k) -               &
                                        Faces3D_VSon(i - 1, j, k)

                        endif

                        j_thick = j

                    endif

                    if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.        &
                        Me%SubModel%InterPolTime) .or.                              &
                        (.not. Me%SubModel%InterPolTime) .or. InitialField) then
                        !Time to interpolate vertical layers father to son!

                        NullValue = .false.

                        !find the first father layer for interpolation
                        Aux = KLBFather
                        AuxDepth = 0.0

                        do kfather=KUBFather, KLBFather, -1
                            if ((Me%SubModel%Aux_V(i, j, kfather)                   &
                                < FillValueReal / 2.) .or.                          &
                                (Me%SubModel%Aux_DVZ(i, j, kfather)                 &
                                < FillValueReal / 2.)) then
                                Aux = kfather + 1
                               exit
                            else
                                Values(kfather) = Me%SubModel%Aux_V(i,j,kfather)
                                Depths(kfather) = AuxDepth +                        &
                                    Me%SubModel%Aux_DVZ(i, j, kfather)/2
                                AuxDepth = AuxDepth +                               &
                                    Me%SubModel%Aux_DVZ(i, j, kfather)
                                !(value (i,j) from father exists!)
                            endif
                        enddo

                        if (Aux == KUBFather + 1) then

                            if (Me%SubModel%MissingNull) then
                                NullValue = .true.
                            else
                                call SetError(FATAL_, INTERNAL_,                    &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR25")
                            endif
                        endif

                        if (.not. NullValue) then
                        !(father values exist for at least one layer)

                            !get number of father depths
                            NDepths = KUBFather - Aux + 1

                            !Time to interpolate vertical layers father to son!
                            !(get U_Next from father)

                            !get son cell depth
                            SonDepth = AuxSonDepth + DVZ_Son(i_thick, j_thick, k)/2
                            AuxSonDepth = AuxSonDepth + DVZ_Son(i_thick, j_thick, k)

                            !interpolate father values as a profile
                            Me%SubModel%V_Next(i,j,k) =                             &
                                            InterpolateProfileR8(SonDepth,          &
                                            NDepths, Depths(Aux:KUBFather),         &
                                            Values(Aux:KUBFather),                  &
                                            FoundBottom, FoundSurface)

                            if (InitialField)                                       &
                                Me%SubModel%V_Previous(i,j,k) =                     &
                                    Me%SubModel%V_Next(i,j,k)

                            if (.not. Me%SubModel%MomentConserv) then

                                Me%SubModel%DVZ_Next(i, j, k) = DVZ_Son(i_thick,    &
                                                                j_thick, k)
                                !(has to be i_thick and j_thick because i, j dont exist)

                            else

                                !Time to interpolate vertical layers father to son!
                                !(get DUZ/DVZ from father)
                                !initialize variable
                                Me%SubModel%DVZ_Next(i, j, k) = 0

                                !DVZ is need for weighting
                                AuxDUVZ_Son = DVZ_Son(i_thick, j_thick, k)

    do17:                       do kfather = kfatherinic, KLBFather, -1 !!!! do18?
                                    !(layers from surface to bottom)

                                    if (Me%SubModel%Aux_DVZ(i, j, kfather)          &
                                        < FillValueReal / 2.) then
                                        !if father values do not exist

                                        if (Me%SubModel%MissingNull)                &
                                            !son layers assumed null values
                                            exit do17

                                    endif

                                    AuxDUVZ_Father =                                &
                                        Me%SubModel%Aux_DVZ(i, j, kfather)
                                    !(since not exited from loop (i,j) value exists!)

                                    if (AuxDUVZ_Son .le.                            &
                                        RelativeThickness*AuxDUVZ_Father) then

                                        !son layer inside father layer part
                                        RelativeThickness = AuxDUVZ_Son*            &
                                            RelativeThickness / AuxDUVZ_Father

                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            AuxDUVZ_Son

                                        if (Abs(AuxDUVZ_Son - AuxDUVZ_Father) .lt.  &
                                            AllmostZero) then
                                            !(AuxDUVZ_Son == AuxDUVZ_Father)

                                            !this father layer is already solved, solve next
                                            kfatherinic = kfatherinic -1
                                            RelativeThickness = 1
                                        else

                                            RelativeThickness = 1 - RelativeThickness
                                        endif

                                        AuxDUVZ_Son = 0.0

                                        exit do17
                                    else

                                        !son layer includes father layer part
                                        Me%SubModel%DVZ_Next(i, j, k) =             &
                                            Me%SubModel%DVZ_Next(i, j, k) +         &
                                            Me%SubModel%Aux_DVZ(i, j, kfather)      &
                                            * RelativeThickness

                                        TotalDUVZ_Son  = TotalDUVZ_Son +            &
                                            RelativeThickness*AuxDUVZ_Father

                                        !get the remaing part of DVZ_Son
                                        AuxDUVZ_Son = AuxDUVZ_Son -                 &
                                            RelativeThickness*AuxDUVZ_Father

                                        !seek in the next father layer
                                        kfatherinic = kfatherinic - 1
                                        RelativeThickness = 1
                                    endif
                                enddo do17

                                !check if excess or deficit flux variable exists
                                if ((AuxDUVZ_Son /= 0.0) .and.                      &
                                    (kfather == KLBFather)) then
                                    !last son layer was not fulfilled by father values
                                    !(all the next son layers are not fulfilled also)

                                    ExcessDUVZ_Son = AuxDUVZ_Son

                                    if (k-1 .ge. KLB) then
                                        !add DVZ of next son layers

                                        do k2 = k-1, KLB, -1
                                            !layers from surface to bottom

                                            ExcessDUVZ_Son = ExcessDUVZ_Son +       &
                                                DVZ_Son(i_thick, j_thick, k2)
                                        enddo
                                    endif
                                else if ((k == Kbottom) .and.                       &
                                    ((RelativeThickness /= 1) .or.                  &
                                    (kfather /= KLBFather))) then
                                    !all son layers are fulfilled with father values
                                    !but excedent father layer part exist

                                    if (RelativeThickness /= 1)                     &
                                        ExcessValue_Father =                        &
                                                Me%SubModel%Aux_DVZ(i, j, kfather)* &
                                                RelativeThickness

                                    if (kfather - 1 .ge. KLBFather) then
                                        !add values of next father layers

    do18:                               do k2father = kfather - 1, KLBFather, - 1 !do19
                                            !layers from surface to bottom

                                            if (Me%SubModel%Aux_DVZ(i, j,k2father)  &
                                                < FillValueReal / 2.) then

                                                exit do18
                                            else

                                                ExcessValue_Father =                &
                                                ExcessValue_Father                  &
                                                + Me%SubModel%Aux_DVZ(i, j, k2father)
                                            endif
                                        enddo do18
                                    endif
                                endif
                            endif

                            if (InitialField) then

                                Me%SubModel%DVZ_Previous(i,j,k) =                   &
                                    Me%SubModel%DVZ_Next(i,j,k)
                            endif
                        endif
                    endif

                    Kbottom = KFloor_V(i_thick, j_thick)

                    !Time interpolation of variables (performed always!)
                    !(here just for velocity)
                    if (Me%SubModel%V_Next    (i, j, k) < FillValueReal / 2. .or.   &
                        Me%SubModel%V_Previous(i, j, k) < FillValueReal / 2.)  then

                        if (Me%SubModel%MissingNull) then

                            Me%SubModel%V_New(i, j, k)  =  0.

                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR26")
                        endif
                    else

                        Me%SubModel%V_New(i, j, k)  =                               &
                            Me%SubModel%V_Next    (i, j, k) * TimeCoef  +           &
                            Me%SubModel%V_Previous(i, j, k) * (1 - TimeCoef)
                    endif

                    if (InitialField .and. .not. Me%ComputeOptions%Continuous       &
                        .and. Me%SubModel%FatherHotStart)                           &
                        Me%Velocity%Horizontal%V%New(i, j, k) =                     &
                                   Me%SubModel%V_New(i, j, k)

                    !(for DVZ)
                    if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2.      &
                        .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal      &
                        / 2.) then

                        if (Me%SubModel%MissingNull) then

                            Me%SubModel%DVZ_New(i, j, k)  =  0.
                        else
                            call SetError(FATAL_, INTERNAL_,                        &
                                 "ActualizeSon3DWithFather3D; Hydrodynamic. ERR27")
                        endif
                    else

                        Me%SubModel%DVZ_New(i, j, k)  =                             &
                                 Me%SubModel%DVZ_Next    (i, j, k) *                &
                                 TimeCoef +                                         &
                                 Me%SubModel%DVZ_Previous(i, j, k) *                &
                                 (1 - TimeCoef)
                    endif
                endif cd19

                if (k == Kbottom) exit do16
            enddo do16

            if (Me%SubModel%MomentConserv) then

                if ((ExcessDUVZ_Son /= 0.0) .or. (ExcessValue_Father /= 0.0)) then

do24:               do k = KUB, KLB, -1

                        if (Me%SubModel%DeadZone) then

                            DeadZoneSon = Me%SubModel%DeadZonePoint(i, j, k)

                        else

                            DeadZoneSon = .false.

                        endif

cd20:                   if ((ImposedTangFacesVSon(i, j, k) == Imposed  .or.         &
                         ImposedNormFacesVSon(i, j, k) == Imposed)  .and.           &
                         .not. DeadZoneSon) then

                            if (ImposedTangFacesVSon(i, j, k) == Imposed) then

                                i_thick = i
                                j_thick = j

                            else if (ImposedNormFacesVSon(i, j, k) == Imposed) then

                                if      (i == IUB + 1) then

                                    i_thick = i - 1

                                else if (i == ILB) then

                                    i_thick = i + 1

                                else

                                    i_thick = i + Faces3D_VSon(i + 1, j, k) -       &
                                              Faces3D_VSon(i - 1, j, k)

                                endif

                                j_thick = j

                            endif

                            Kbottom = KFloor_V(i_thick, j_thick)

                            if ((((Me%CurrentTime == Me%SubModel%GetFatherTime)     &
                                .and. Me%SubModel%InterPolTime) .or.                &
                                (.not. Me%SubModel%InterPolTime) .or. InitialField) &
                                .and. (.not. NullValue)) then
                                !Check if layer values from father need to be corrected
                                !(capitalizing on the DO cycle)

                                if (ExcessDUVZ_Son /= 0.0) then
                                    !Correct son layer values for the deficit of father values

                                    SumDUVZ_Son = SumDUVZ_Son + DVZ_Son(i_thick, j_thick, k)

                                    if (SumDUVZ_Son .le. TotalDUVZ_Son) then
                                        !layers having father value

                                        AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*DVZ_Son(i_thick, j_thick, k) &
                                            /TotalDUVZ_Son

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove flux variable from layer
                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                                        Me%SubModel%DVZ_Next(i,j,k) &
                                                        - AuxDeficit

                                    elseif (AuxDUVZ_Son /= 0.0) then
                                        !son layer partially with father value
                                        AuxDeficit = Me%SubModel%DVZ_Next(i,j,k)*   &
                                            ExcessDUVZ_Son*(DVZ_Son(i_thick, j_thick, k) &
                                            - AuxDUVZ_Son)/TotalDUVZ_Son

                                        !actualize the value of the father deficit
                                        DeficitValue_Father = DeficitValue_Father + &
                                            AuxDeficit

                                        !remove and add
                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                            Me%SubModel%DVZ_Next(i,j,k) - AuxDeficit + &
                                            DeficitValue_Father*AuxDUVZ_Son/        &
                                            (WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                        AuxDUVZ_Son = 0.0
                                        !(layer completed)

                                    else
                                        !fill son layer without father value

                                        !add collected value
                                        Me%SubModel%DVZ_Next(i,j,k) =               &
                                            DeficitValue_Father*                    &
                                            DVZ_Son(i_thick, j_thick,k)             &
                                            /(WaterColumnV(i_thick, j_thick) - TotalDUVZ_Son)

                                    endif

                                elseif (ExcessValue_Father /= 0.0) then
                                    !Correct son layer values for the excess of father values

                                    Me%SubModel%DVZ_Next(i,j,k) =                   &
                                        Me%SubModel%DVZ_Next(i,j,k) +               &
                                        ExcessValue_Father*DVZ_Son(i_thick, j_thick,k)/ &
                                        WaterColumnV(i_thick, j_thick)

                                endif

                                if (InitialField) then

                                    Me%SubModel%DVZ_Previous(i,j,k) =               &
                                        Me%SubModel%DVZ_Next(i,j,k)

                                endif

                            endif

                            !Time interpolation of variables (performed always!)
                            !(here just for DUZ/DVZ)

                            if (Me%SubModel%DVZ_Next    (i, j, k) < FillValueReal / 2. &
                                .or. Me%SubModel%DVZ_Previous(i, j, k) < FillValueReal &
                                / 2.) then

                                if (Me%SubModel%MissingNull) then

                                    Me%SubModel%DVZ_New(i, j, k)  =  0.

                                else
                                    call SetError(FATAL_, INTERNAL_,                &
                                         "ActualizeSon3DWithFather3D; Hydrodynamic. ERR28")
                                endif

                            else

                                Me%SubModel%DVZ_New(i, j, k)  =                     &
                                         Me%SubModel%DVZ_Next    (i, j, k) *        &
                                         TimeCoef +                                 &
                                         Me%SubModel%DVZ_Previous(i, j, k) *        &
                                         (1 - TimeCoef)

                            endif

                        endif cd20

                        if (k == Kbottom) exit do24

                    enddo do24

                endif

            endif

        enddo
        enddo

        !This is only done for graphical reasons
        if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            !U corners
            Me%Velocity%Horizontal%U%New(ILB,JLB    , KLB:KUB)   =                  &
            Me%SubModel%U_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(ILB,JUB + 1, KLB:KUB)   =                  &
            Me%SubModel%U_New           (ILB,JUB + 1, KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JLB    , KLB:KUB)   =                  &
            Me%SubModel%U_New           (IUB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%U%New(IUB,JUB + 1, KLB:KUB)   =                  &
            Me%SubModel%U_New           (IUB,JUB + 1, KLB:KUB)


            !V corners
            Me%Velocity%Horizontal%V%New(ILB,JLB    , KLB:KUB)   =                  &
            Me%SubModel%V_New           (ILB,JLB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(ILB,JUB    , KLB:KUB)   =                  &
            Me%SubModel%V_New           (ILB,JUB    , KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JLB, KLB:KUB)   =                  &
            Me%SubModel%V_New           (IUB + 1,JLB, KLB:KUB)

            Me%Velocity%Horizontal%V%New(IUB + 1,JUB, KLB:KUB)   =                  &
            Me%SubModel%V_New           (IUB + 1,JUB, KLB:KUB)

        endif

        Me%SubModel%Set      = .true.

        !UnGet son information
        call ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,              &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,              &
                           Water3DSon, Boundary2DSon,                               &
                           Faces3D_USon, Faces3D_VSon,                              &
                           DUZ_Son, DVZ_Son,                                        &
                           DXX_Son, DYY_Son)

cd21:   if (InitialField .and. .not. Me%ComputeOptions%Continuous) then

            call SetMatrixValue(Me%WaterLevel%Old, Me%Size2D, Me%WaterLevel%New)
            call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Me%Size,              &
                                 Me%Velocity%Horizontal%V%New)
            call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Me%Size,              &
                                 Me%Velocity%Horizontal%U%New)
            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_Next)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_Next)

            !Me%WaterLevel%Old               (:,:  ) =                               &
                !Me%WaterLevel%New           (:,:  )

            !Me%Velocity%Horizontal%V%Old    (:,:,:) =                               &
                !Me%Velocity%Horizontal%V%New(:,:,:)

            !Me%Velocity%Horizontal%U%Old    (:,:,:) =                               &
                !Me%Velocity%Horizontal%U%New(:,:,:)

            !Me%SubModel%DUZ_Old(:,:,:)              =                               &
                !Me%SubModel%DUZ_Next(:,:,:)

            !Me%SubModel%DVZ_Old(:,:,:)              =                               &
                !Me%SubModel%DVZ_Next(:,:,:)

        endif cd21


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           WaterColumnU, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                    "ActualizeSon3DWithFather3D; Hydrodynamic. ERR29")


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           WaterColumnV, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR30")


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           KFloor_U, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR31")


        call UnGetGeometry(Me%ObjGeometry,                                          &
                           KFloor_V, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR32")

        !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_,                    &
                                     "ActualizeSon3DWithFather3D; Hydrodynamic. ERR33")

        !Deallocates values and depths used to interpolate velocities
        if (((Me%CurrentTime == Me%SubModel%GetFatherTime) .and.                    &
            Me%SubModel%InterPolTime) .or. (.not. Me%SubModel%InterPolTime)         &
            .or. InitialField) then

            deallocate(Depths)
            deallocate(Values)

            if (Me%SubModel%InterPolTime .and. .not. InitialField) then

                call null_Time(Me%CurrentTime)

            endif

        endif

    end subroutine ActualizeSon3DWithFather3D

    !--------------------------------------------------------------------------

    subroutine RemoveLowerSpikes (Values2D, WaterPoints, Bathymetry, MinWaterColumn,   &
                                  DeadZonePoints, DeadZoneON, ILB, IUB, JLB, JUB, KUB, &
                                  BoundaryPoints)

    !Arguments-----------------------------------------------------------------
    real,    dimension(:,:  ), pointer            :: Values2D, Bathymetry
    integer, dimension(:,:,:), pointer            :: WaterPoints
    logical, dimension(:,:,:), pointer            :: DeadZonePoints
    integer, dimension(:,:  ), pointer, optional  :: BoundaryPoints
    real                                          :: MinWaterColumn
    integer                                       :: ILB, IUB, JLB, JUB, KUB
    logical                                       :: DeadZoneON
    !Local---------------------------------------------------------------------
    integer                                       :: i, j, Counter, ComputePoint
    real                                          :: Average, Deviation, Dif
    logical                                       :: BoundaryON
    integer                                       :: CHUNK

    !Begin---------------------------------------------------------------------

        if (present(BoundaryPoints)) then
            BoundaryON = .true.
        else
            BoundaryON = .false.
        endif

        Average   = 0.
        Deviation = 0.
        Counter   = 0

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "RemoveLowerSpikes")

        !ACanas(2010): Parallelization of next two cycles removed as REDUCTION clause
        !ACanas(2010): causes rounding errors which cannot certified.

        ! !! $OMP PARALLEL SHARED(Average,Counter) PRIVATE(i,j,ComputePoint)
        !Compute Averages
        ! !! $OMP DO SCHEDULE(DYNAMIC, CHUNK) REDUCTION(+ : Average,Counter)
        do j= JLB, JUB
        do i= ILB, IUB

            ComputePoint = WaterPoints(i,j,KUB)
            if (BoundaryON) ComputePoint = ComputePoint * BoundaryPoints(i, j)
            if (DeadZoneON) then
                if (DeadZonePoints(i, j, KUB)) ComputePoint = 0
            endif
            !The uncovered points are not use to compute the average and the standard deviation
            if (Values2D(i, j) < -Bathymetry(i,j) + MinWaterColumn) &
                ComputePoint = 0

            if (ComputePoint == 1) then
                Counter = Counter + 1
                Average = Average + Values2D(i, j)

            endif

        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        if (Counter > 0) then
            Average = Average / real (Counter)
        endif

        ! !! $OMP PARALLEL SHARED(Deviation) PRIVATE(i,j,ComputePoint)
        !Standard Deviation
        ! !! $OMP DO SCHEDULE(DYNAMIC, CHUNK) REDUCTION(+ : Deviation)
        do j= JLB, JUB
        do i= ILB, IUB

            ComputePoint = WaterPoints(i,j,KUB)
            if (BoundaryON) ComputePoint = ComputePoint * BoundaryPoints(i, j)
            if (DeadZoneON) then
                if (DeadZonePoints(i, j, KUB)) ComputePoint = 0
            endif

            !The uncovered points are not use to compute the average and the standard deviation
            if (Values2D(i, j) < -Bathymetry(i,j) + MinWaterColumn) &
                ComputePoint = 0

            if (ComputePoint == 1) then

                Deviation = Deviation + abs(Values2D(i, j) - Average)

            endif

        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        if (Counter > 0) then
            Deviation = Deviation / real (Counter)
        endif

        !$OMP PARALLEL PRIVATE(i,j,ComputePoint,Dif)
        !Remove lower Spikes
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j= JLB, JUB
        do i= ILB, IUB

            ComputePoint = WaterPoints(i,j,KUB)
            if (BoundaryON) ComputePoint = ComputePoint * BoundaryPoints(i, j)
            if (DeadZoneON) then
                if (DeadZonePoints(i, j, KUB)) ComputePoint = 0
            endif

            if (ComputePoint == 1) then

                Dif = Values2D(i, j) - Average

                if (Dif < 0 .and. abs(Dif) > 100. * Deviation) Values2D(i, j) = Average

            endif

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "RemoveLowerSpikes")

    end subroutine RemoveLowerSpikes

    !--------------------------------------------------------------------------

    subroutine ReadNextOrInitialField (UFather, VFather, DUZFather, DVZFather,           &
                                       FluxXFather, FluxYFather, ZFather, Open3DFather,  &
                                       Faces3D_UFather, Faces3D_VFather,                 &
                                       WetFaces_UFather, WetFaces_VFather, InitialField, &
                                       FatherHorizontalGrid)

        !Arguments-------------------------------------------------------------
        real,    dimension(:,:,:), pointer          :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer          :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer          :: ZFather
        integer, dimension(:,:,:), pointer          :: Open3DFather
        integer, dimension(:,:,:), pointer          :: Open3DSon, Compute3DUSon, Compute3DVSon
        integer, dimension(:,:,:), pointer          :: Faces3D_UFather
        integer, dimension(:,:,:), pointer          :: Faces3D_VFather
        integer, dimension(:,:,:), pointer          :: WetFaces_UFather
        integer, dimension(:,:,:), pointer          :: WetFaces_VFather
        logical,           intent(IN )              :: InitialField
        integer                                     :: FatherHorizontalGrid

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer          :: Null_Mapping
        integer                                     :: ComputeZ, ComputeU, ComputeV
        integer                                     :: status
        integer                                     :: ILBSon, IUBSon, JLBSon, JUBSon, KLBSon, KUBSon
        integer                                     :: KLBFather, KUBFather

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ReadNextOrInitialField")

        KUBSon    = Me%WorkSize%KUB
        KLBSon    = Me%WorkSize%KLB

        !Ang: new implementation father-son 3D connection
        KUBFather = Me%SubModel%FatherKUB
        KLBFather = Me%SubModel%FatherKLB

        ILBson    = Me%WorkSize%ILB
        IUBson    = Me%WorkSize%IUB
        JLBson    = Me%WorkSize%JLB
        JUBson    = Me%WorkSize%JUB

        nullify(Null_Mapping)

        call GetComputeZUV(HorizontalGridID = Me%ObjHorizontalGrid,                     &
                           ComputeZ         = ComputeZ,                                 &
                           ComputeU         = ComputeU,                                 &
                           ComputeV         = ComputeV,                                 &
                           STAT             = status)
        if (status /= SUCCESS_)                                                         &
            call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR10")

cd1:    if (Me%SubModel%InterPolTime .and. .not. InitialField) then

            call SetMatrixValue(Me%SubModel%Z_Previous, Me%Size2D, Me%SubModel%Z_Next)
            call SetMatrixValue(Me%SubModel%U_Previous, Me%Size, Me%SubModel%U_Next)
            call SetMatrixValue(Me%SubModel%V_Previous, Me%Size, Me%SubModel%V_Next)
            call SetMatrixValue(Me%SubModel%DUZ_Previous, Me%Size, Me%SubModel%DUZ_Next)
            call SetMatrixValue(Me%SubModel%DVZ_Previous, Me%Size, Me%SubModel%DVZ_Next)

        endif cd1

        call InterpolRegularGrid   (Me%ObjHorizontalGrid,                           &
                                    FatherHorizontalGrid,                           &
                                    ZFather, Me%SubModel%Z_Next,                    &
                                    ComputeFather = Open3DFather,                   &
                                    Compute       = ComputeZ,                       &
                                    KUBFather     = KUBFather,                      &
                                    STAT          = status)

        if (status /= SUCCESS_)                                                     &
            call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR40")

        if (Me%SubModel%WaterLevelIncrease /= 0.0) then
            call AddSubmodelWaterLevel
        endif


        if (Me%SubModel%Extrapolate) then

            call GetOpenPoints3D(Me%ObjMap, Open3DSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR30"

            call ExtraPol2DNearestCell (ILBson, IUBson, JLBson, JUBson, KUBson, Open3DSon, Me%SubModel%Z_Next)

            call UnGetMap(Me%ObjMap, Open3DSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR320"

        endif

        if (InitialField  .and. .not. Me%ComputeOptions%Continuous)                 &
            call Initial_Geometry(Me%SubModel%Z_Next)

            !The geometry is construct using the filed interpolated from the Father Water Level
            !The Mapping is also actualized by this subroutine

        if (Me%SubModel%Extrapolate) then

            call GetComputeFaces3D(Me%ObjMap, ComputeFacesU3D = Compute3DUSon, ComputeFacesV3D = Compute3DVSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR20"

        endif

        !Ang: new implementation
        if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                       &
            (Me%SubModel%VertComunic == Father3DSon2D)) then

cd2:        if (InitialField) then  !.and. .not. Me%ComputeOptions%Continuous) then

                !Father values stored in aux variables with same vertical grid
                !(but horizontal grid as son's)
                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxXFather, Me%SubModel%Aux_qX,        &
                                            WetFaces_UFather, ComputeU,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)
                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR50")


                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxYFather, Me%SubModel%Aux_qY,        &
                                            WetFaces_VFather, ComputeV,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)

                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR60")

                if (Me%SubModel%Extrapolate) then

                    call ExtraPol3DNearestCell_8(ILBson, IUBson, JLBson, JUBson + 1,     &
                                                KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_qX)

                    call ExtraPol3DNearestCell_8(ILBson, IUBson + 1 , JLBson, JUBson,    &
                                                KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_qY)

                endif


            endif cd2

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    UFather, Me%SubModel%Aux_U,                     &
                                    WetFaces_UFather, ComputeU,                     &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR70")


            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    DUZFather, Me%SubModel%Aux_DUZ,                 &
                                    Faces3D_UFather, ComputeU,                      &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR06")

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    VFather, Me%SubModel%Aux_V,                     &
                                    WetFaces_VFather, ComputeV,                     &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR07")



            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                    FatherHorizontalGrid,                           &
                                    DVZFather, Me%SubModel%Aux_DVZ,                 &
                                    Faces3D_VFather, ComputeV,                      &
                                    KLBFather, KUBFather, KUBSon,                   &
                                    STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR08")

            if (Me%SubModel%Extrapolate) then

                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_U)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    &
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_V)

                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_DUZ)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    &
                                            KLBFather, KUBFather, Null_Mapping, Me%SubModel%Aux_DVZ)

            endif


       else

cd3:        if (InitialField .and. .not. Me%SubModel%HotStartData) then  !.and. .not. Me%ComputeOptions%Continuous) then

                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxXFather, Me%SubModel%qX,            &
                                            WetFaces_UFather, ComputeU,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)
                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR09")


                call InterpolRegularGrid   (Me%ObjHorizontalGrid,                   &
                                            FatherHorizontalGrid,                   &
                                            FluxYFather, Me%SubModel%qY,            &
                                            WetFaces_VFather, ComputeV,             &
                                            KLBFather, KUBFather, KUBSon,           &
                                            FluxType = .true., STAT = status)

                if (status /= SUCCESS_)                                             &
                    call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR10")

                if (Me%SubModel%Extrapolate) then


                    call ExtraPol3DNearestCell_8(ILBson, IUBson, JLBson, JUBson + 1,     &
                                                KLBson, KUBson, Compute3DUSon, Me%SubModel%qX)


                    call ExtraPol3DNearestCell_8(ILBson, IUBson + 1 , JLBson, JUBson,    &
                                                KLBson, KUBson, Compute3DVSon, Me%SubModel%qY)

                endif

            endif cd3

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        UFather, Me%SubModel%U_Next,                &
                                        WetFaces_UFather, ComputeU,                 &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR11")

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        DUZFather, Me%SubModel%DUZ_Next,            &
                                        Faces3D_UFather, ComputeU,                  &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR12")

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        VFather, Me%SubModel%V_Next,                &
                                        WetFaces_VFather, ComputeV,                 &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR13")

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,                       &
                                        FatherHorizontalGrid,                       &
                                        DVZFather, Me%SubModel%DVZ_Next,            &
                                        Faces3D_VFather, ComputeV,                  &
                                        KLBFather, KUBFather, KUBSon,               &
                                        STAT = status)
            if (status /= SUCCESS_)                                                 &
                call SetError(FATAL_, INTERNAL_, "ReadNextOrInitialField; Hydrodynamic. ERR14")

            if (Me%SubModel%Extrapolate) then


                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBson, KUBson, Compute3DUSon, Me%SubModel%U_Next)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    &
                                            KLBson, KUBson, Compute3DVSon, Me%SubModel%V_Next)

                call ExtraPol3DNearestCell(ILBson, IUBson, JLBson, JUBson + 1,     &
                                            KLBson, KUBson, Compute3DUSon, Me%SubModel%DUZ_Next)

                call ExtraPol3DNearestCell(ILBson, IUBson + 1 , JLBson, JUBson,    &
                                            KLBson, KUBson, Compute3DVSon, Me%SubModel%DVZ_Next)

            endif
        endif

cd12:   if (Me%SubModel%InterPolTime .and. InitialField) then

            call SetMatrixValue(Me%SubModel%Z_Previous, Me%Size2D, Me%SubModel%Z_Next)

            !Me%SubModel%Z_Previous  (:,:  ) = Me%SubModel%Z_Next  (:,:)

            if ((Me%SubModel%VertComunic /= FatherSonDifDim) .or.                   &
                (Me%SubModel%VertComunic /= Father3DSon2D)) then

                call SetMatrixValue(Me%SubModel%U_Previous, Me%Size,               &
                                     Me%SubModel%U_Next)
                call SetMatrixValue(Me%SubModel%V_Previous, Me%Size,               &
                                     Me%SubModel%V_Next)
                call SetMatrixValue(Me%SubModel%DUZ_Previous, Me%Size,             &
                                     Me%SubModel%DUZ_Next)
                call SetMatrixValue(Me%SubModel%DVZ_Previous, Me%Size,             &
                                     Me%SubModel%DVZ_Next)

                !Me%SubModel%U_Previous  (:,:,:) = Me%SubModel%U_Next  (:,:,:)
                !Me%SubModel%V_Previous  (:,:,:) = Me%SubModel%V_Next  (:,:,:)
                !Me%SubModel%DUZ_Previous(:,:,:) = Me%SubModel%DUZ_Next(:,:,:)
                !Me%SubModel%DVZ_Previous(:,:,:) = Me%SubModel%DVZ_Next(:,:,:)

            endif

        endif cd12

        if (Me%SubModel%Extrapolate) then

            call UnGetMap(Me%ObjMap, Compute3DUSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR300"

            call UnGetMap(Me%ObjMap, Compute3DVSon, STAT = status)
            if (status /= SUCCESS_) stop "ReadNextOrInitialField - Hydrodynamic - ERR310"

        endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ReadNextOrInitialField")

    end subroutine ReadNextOrInitialField

    !--------------------------------------------------------------------------
    subroutine AddSubmodelWaterLevel
    !Arguments-------------------------------------------------------------
    integer                         :: i, j, STAT_CALL

        call GetWaterPoints2D(Me%ObjHorizontalMap, &
                              Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
        stop 'AddSubmodelWaterLevel - ModuleHydrodynamic - ERR01'

        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                    Me%Submodel%Z_Next(i, j) = Me%Submodel%Z_Next(i, j) + Me%Submodel%WaterLevelIncrease * &
                    (Me%External_Var%WaterPoints2D(i, j))
        enddo
        enddo

        call UnGetHorizontalMap(Me%ObjHorizontalMap, &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'AddSubmodelWaterLevel - ModuleHydrodynamic - ERR02'

    end subroutine AddSubmodelWaterLevel

    !---------------------------------------------------------------------------

    subroutine ReadLockFather(ObjHydrodynamicFather,                                     &
                              FluxXFather, FluxYFather,                                  &
                              Open3DFather, Faces3D_UFather, Faces3D_VFather,            &
                              WetFaces_UFather, WetFaces_VFather,                        &
                              UFather, VFather, ZFather, DUZFather, DVZFather)

        !Arguments-------------------------------------------------------------
        type(T_Hydrodynamic),   pointer    :: ObjHydrodynamicFather
        real,    dimension(:,:,:), pointer :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer :: ZFather
        integer, dimension(:,:,:), pointer :: Open3DFather
        integer, dimension(:,:,:), pointer :: Faces3D_UFather
        integer, dimension(:,:,:), pointer :: Faces3D_VFather
        integer, dimension(:,:,:), pointer :: WetFaces_UFather
        integer, dimension(:,:,:), pointer :: WetFaces_VFather


        !Local---------------------------------------------------------------------
        integer :: status


        !----------------------------------------------------------------------

        call GetOpenPoints3D(ObjHydrodynamicFather%ObjMap, Open3DFather, STAT = status)
        if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR01")

        call GetComputeFaces3D(ObjHydrodynamicFather%ObjMap,                             &
                               ComputeFacesU3D = Faces3D_UFather,                        &
                               ComputeFacesV3D = Faces3D_VFather,                        &
                               STAT= status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR02")

        call GetWetFaces(ObjHydrodynamicFather%ObjMap,                                   &
                               WetFaceU = WetFaces_UFather,                              &
                               WetFaceV = WetFaces_VFather,                              &
                               STAT= status)
        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR03")

        call GetGeometryDistances(ObjHydrodynamicFather%ObjGeometry, DUZ =  DUZFather,   &
                                  DVZ =  DVZFather, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadLockFather; Hydrodynamic. ERR04")

        UFather     => ObjHydrodynamicFather%Velocity%Horizontal%U%New
        VFather     => ObjHydrodynamicFather%Velocity%Horizontal%V%New
        ZFather     => ObjHydrodynamicFather%WaterLevel%New
        FluxXFather => ObjHydrodynamicFather%WaterFluxes%X
        FluxYFather => ObjHydrodynamicFather%WaterFluxes%Y


    end subroutine ReadLockFather

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ReadUnLockFather(ObjHydrodynamicFather,                                   &
                                FluxXFather, FluxYFather,                                &
                                Open3DFather, Faces3D_UFather, Faces3D_VFather,          &
                                WetFaces_UFather, WetFaces_VFather,                      &
                                UFather, VFather, ZFather, DUZFather, DVZFather)

        !Arguments-------------------------------------------------------------
        type(T_Hydrodynamic),   pointer    :: ObjHydrodynamicFather
        real,    dimension(:,:,:), pointer :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer :: ZFather
        integer, dimension(:,:,:), pointer :: Open3DFather
        integer, dimension(:,:,:), pointer :: Faces3D_UFather
        integer, dimension(:,:,:), pointer :: Faces3D_VFather
        integer, dimension(:,:,:), pointer :: WetFaces_UFather
        integer, dimension(:,:,:), pointer :: WetFaces_VFather


        !Local---------------------------------------------------------------------
        integer :: status



        !----------------------------------------------------------------------

        call UnGetGeometry(ObjHydrodynamicFather%ObjGeometry, DUZFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR01"

        call UnGetGeometry(ObjHydrodynamicFather%ObjGeometry, DVZFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR02"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, Open3DFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR03"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, Faces3D_UFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR04"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, Faces3D_VFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR05"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, WetFaces_UFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR06"

        call UnGetMap(ObjHydrodynamicFather%ObjMap, WetFaces_VFather, STAT = status)
        if (status /= SUCCESS_) stop "ReadUnLockFather - Hydrodynamic - ERR07"

        nullify(UFather)
        nullify(VFather)
        nullify(ZFather)
        nullify(FluxXFather)
        nullify(FluxYFather)

    end subroutine ReadUnLockFather

    !--------------------------------------------------------------------------

    subroutine ReadLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                   &
                           ImposedNormFacesUSon, ImposedNormFacesVSon,                   &
                           Water3DSon, Boundary2DSon,                                     &
                           Faces3D_USon, Faces3D_VSon,                                   &
                           DUZ_Son, DVZ_Son,                                             &
                           DXX_Son, DYY_Son)

        !Arguments-------------------------------------------------------------
        integer, dimension(:,:  ), pointer :: Boundary2DSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon, Faces3D_VSon
        real   , dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son


        !Local---------------------------------------------------------------------
        integer                             :: status


        !Module Horizontal Grid
        call GetHorizontalGrid(Me%ObjHorizontalGrid, DXX = DXX_Son, DYY = DYY_Son,       &
                               STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR01"

        !Module - ModuleHorizontalMap
        call GetImposedTangentialFaces(Me%ObjMap, ImposedTangFacesUSon,                  &
                                       ImposedTangFacesVSon, STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR02"

        call GetImposedNormalFaces(Me%ObjMap, ImposedNormFacesUSon, ImposedNormFacesVSon,&
                                   STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR03"


        call GetGeometryDistances(Me%ObjGeometry, DUZ =  DUZ_Son, DVZ =  DVZ_Son,        &
                                  STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR04"

        call GetWaterPoints3D(Me%ObjMap, Water3DSon, STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR05"

        call GetBoundaries(Me%ObjHorizontalMap, Boundary2DSon, STAT = status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR06"

        call GetComputeFaces3D(Me%ObjMap,                                                &
                               ComputeFacesU3D = Faces3D_USon,                           &
                               ComputeFacesV3D = Faces3D_VSon,                           &
                               STAT= status)
        if (status /= SUCCESS_) stop "ReadLockSon - Hydrodynamic - ERR07"

    end subroutine ReadLockSon

    !--------------------------------------------------------------------------

    subroutine ReadUnLockSon(ImposedTangFacesUSon, ImposedTangFacesVSon,                 &
                             ImposedNormFacesUSon, ImposedNormFacesVSon,                 &
                             Water3DSon, Boundary2DSon,                                   &
                             Faces3D_USon, Faces3D_VSon,                                 &
                             DUZ_Son, DVZ_Son,                                           &
                             DXX_Son, DYY_Son)

        !Arguments-------------------------------------------------------------
        integer, dimension(:,:  ), pointer :: Boundary2DSon
        integer, dimension(:,:,:), pointer :: ImposedTangFacesUSon, ImposedTangFacesVSon
        integer, dimension(:,:,:), pointer :: ImposedNormFacesUSon, ImposedNormFacesVSon
        integer, dimension(:,:,:), pointer :: Water3DSon
        integer, dimension(:,:,:), pointer :: Faces3D_USon, Faces3D_VSon
        real   , dimension(:,:,:), pointer :: DUZ_Son, DVZ_Son
        real,    dimension(:,:  ), pointer :: DXX_Son, DYY_Son


        !Local---------------------------------------------------------------------
        integer :: status
        !----------------------------------------------------------------------

        !Get son information

        call UnGetMap(Me%ObjMap, ImposedTangFacesUSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR01")


        call UnGetMap(Me%ObjMap, ImposedTangFacesVSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR02")


        call UnGetMap(Me%ObjMap, ImposedNormFacesUSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR03")


        call UnGetMap(Me%ObjMap, ImposedNormFacesVSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR04")


        call UnGetGeometry(Me%ObjGeometry, DUZ_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR07")


        call UnGetGeometry(Me%ObjGeometry, DVZ_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR08")



        call UnGetMap(Me%ObjMap, Water3DSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR09")

        call UnGetHorizontalMap(Me%ObjHorizontalMap, Boundary2DSon, STAT = STATUS)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR09a")

        call UnGetMap(Me%ObjMap, Faces3D_USon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR10")

        call UnGetMap(Me%ObjMap, Faces3D_VSon, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR11")


        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, DXX_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR12")

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                   &
                                 DYY_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ReadUnLockSon; Hydrodynamic. ERR13")


    end subroutine ReadUnLockSon

    !--------------------------------------------------------------------------

    subroutine ConstructTimeInterpolation(DT_Father)

        !Arguments-------------------------------------------------------------
        real                                        :: DT_Father

        !Local---------------------------------------------------------------------
        real                                        :: DT_Son, Aux1, Aux2
        integer                                     :: status
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: FatherLayers, SonLayers
        integer                                     :: FatherKLB, FatherKUB

        !----------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB       = Me%Size%IUB
        ILB       = Me%Size%ILB
        JUB       = Me%Size%JUB
        JLB       = Me%Size%JLB
        KUB       = Me%Size%KUB
        KLB       = Me%Size%KLB

        !Ang: new implementation
        FatherKLB = Me%SubModel%FatherKLB
        FatherKUB = Me%SubModel%FatherKUB

        FatherLayers = FatherKUB       - FatherKLB       + 1
        SonLayers    = Me%WorkSize%KUB - Me%WorkSize%KLB + 1

        call GetComputeTimeStep(Me%ObjTime, DT_Son, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "ConstructTimeInterpolation; Hydrodynamic. ERR01")

cd1:    if      (DT_Son <  DT_Father) then

            Aux1 = DT_Father / DT_Son
            Aux2 = real(int (Aux1))

            if (Aux1 /= Aux2)                                                            &
                call SetError(FATAL_, INTERNAL_, "ConstructTimeInterpolation; Hydrodynamic. ERR02")


            Me%SubModel%InterpolTime  = .true.

        else if (DT_Son == DT_Father) then cd1

            Me%SubModel%InterpolTime  = .false.

        else  cd1

            call SetError(FATAL_, INTERNAL_, "ConstructTimeInterpolation; Hydrodynamic. ERR03")

        endif cd1

        call Null_Time(Me%SubModel%PreviousTime)
        Me%SubModel%NextTime = Me%BeginTime


        if      ((FatherLayers == 1) .and. (SonLayers >  1)) then

            Me%SubModel%VertComunic = Father2DSon3D

        else if ((FatherLayers >  1) .and. (SonLayers == 1)) then

            Me%SubModel%VertComunic = Father3DSon2D

            !Ang: new implementation
            !Allocate auxiliary variables for father-son connection
            nullify(Me%SubModel%Aux_qX)
            nullify(Me%SubModel%Aux_qY)
            nullify(Me%SubModel%Aux_U)
            nullify(Me%SubModel%Aux_V)
            nullify(Me%SubModel%Aux_DUZ)
            nullify(Me%SubModel%Aux_DVZ)

            allocate(Me%SubModel%Aux_qX (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR04")
            Me%SubModel%Aux_qX (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_qY (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR05")
            Me%SubModel%Aux_qY (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_U  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR06")
            Me%SubModel%Aux_U (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_V  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR07")
            Me%SubModel%Aux_V (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DUZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR08")
            Me%SubModel%Aux_DUZ (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DVZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR09")
            Me%SubModel%Aux_DVZ (:,:,:) = FillValueReal

            call Null_Time(Me%SubModel%GetFatherTime)

        else if (FatherLayers         ==  SonLayers) then

            Me%SubModel%VertComunic = FatherSonEqualDim

        else

            Me%SubModel%VertComunic = FatherSonDifDim

            !Ang: new implementation
            !Allocate auxiliary variables for father-son connection
            nullify(Me%SubModel%Aux_qX)
            nullify(Me%SubModel%Aux_qY)
            nullify(Me%SubModel%Aux_U)
            nullify(Me%SubModel%Aux_V)
            nullify(Me%SubModel%Aux_DUZ)
            nullify(Me%SubModel%Aux_DVZ)

            allocate(Me%SubModel%Aux_qX (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR10")
            Me%SubModel%Aux_qX (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_qY (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR11")
            Me%SubModel%Aux_qY (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_U  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR12")
            Me%SubModel%Aux_U (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_V  (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR13")
            Me%SubModel%Aux_V (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DUZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR14")
            Me%SubModel%Aux_DUZ (:,:,:) = FillValueReal

            allocate(Me%SubModel%Aux_DVZ(ILB:IUB, JLB:JUB, FatherKLB:FatherKUB),         &
                     STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR15")
            Me%SubModel%Aux_DVZ (:,:,:) = FillValueReal

            call Null_Time(Me%SubModel%GetFatherTime)

        endif

cd2:    if (Me%SubModel%InterpolTime) then

            allocate (Me%SubModel%Z_Previous(ILB:IUB, JLB:JUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR16")

            Me%SubModel%Z_Previous (:,:  ) = FillValueReal

            allocate (Me%SubModel%Z_Next(ILB:IUB, JLB:JUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR17")

            Me%SubModel%Z_Next (:,:  ) = FillValueReal

            allocate (Me%SubModel%U_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR18")

            Me%SubModel%U_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%U_Next(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR19")

            Me%SubModel%U_Next      (:,:,:) = FillValueReal


            allocate (Me%SubModel%V_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR20")

            Me%SubModel%V_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%V_Next    (ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR21")

            Me%SubModel%V_Next      (:,:,:) = FillValueReal


            allocate (Me%SubModel%DUZ_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR22")

            Me%SubModel%DUZ_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%DUZ_Next(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR23")

            Me%SubModel%DUZ_Next      (:,:,:) = FillValueReal


            allocate (Me%SubModel%DVZ_Previous(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR24")

            Me%SubModel%DVZ_Previous  (:,:,:) = FillValueReal

            allocate (Me%SubModel%DVZ_Next    (ILB:IUB, JLB:JUB, KLB:KUB), STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - Hydrodynamic - ERR25")

            Me%SubModel%DVZ_Next      (:,:,:) = FillValueReal

        else

            Me%SubModel%Z_Previous   => Me%SubModel%Z
            Me%SubModel%Z_Next       => Me%SubModel%Z

            Me%SubModel%U_Previous   => Me%SubModel%U_New
            Me%SubModel%U_Next       => Me%SubModel%U_New

            Me%SubModel%V_Previous   => Me%SubModel%V_New
            Me%SubModel%V_Next       => Me%SubModel%V_New

            Me%SubModel%DUZ_Previous => Me%SubModel%DUZ_New
            Me%SubModel%DUZ_Next     => Me%SubModel%DUZ_New

            Me%SubModel%DVZ_Previous => Me%SubModel%DVZ_New
            Me%SubModel%DVZ_Next     => Me%SubModel%DVZ_New

        endif cd2

    end subroutine ConstructTimeInterpolation


    Subroutine Actualises_Hydrodynamic


        !Arguments-------------------------------------------------------------------


        !Local
        integer :: Num_Discretization, Previous_Direction



        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Actualises_Hydrodynamic")

        call SetMatrixValue(Me%WaterLevel%Old, Me%Size2D, Me%WaterLevel%New)

        Num_Discretization = Me%ComputeOptions%Num_Discretization


cd2:    if (Num_Discretization == Abbott) then

            Previous_Direction = Me%Direction%XY

cd3:        if (Previous_Direction == DirectionY_) then

                call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Me%Size, Me%Velocity%Horizontal%U%New)

                if (Me%SubModel%ON)then
                    call SetMatrixValue(Me%SubModel%U_Old, Me%Size, Me%SubModel%U_New)
                endif

            elseif (Previous_Direction == DirectionX_) then cd3

                call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Me%Size, Me%Velocity%Horizontal%V%New)

                if (Me%SubModel%ON)then
                    call SetMatrixValue(Me%SubModel%V_Old, Me%Size, Me%SubModel%V_New)
                endif

            else

                Stop 'Sub. Actualises_Hydrodynamic - ModuleHydrodynamic - Err02.'

            endif cd3


        else if (Num_Discretization == Leendertse) then cd2

            call SetMatrixValue(Me%Velocity%Horizontal%U%Old, Me%Size, Me%Velocity%Horizontal%U%New)
            call SetMatrixValue(Me%Velocity%Horizontal%V%Old, Me%Size, Me%Velocity%Horizontal%V%New)


                if (Me%ComputeOptions%WaveForcing3D == GLM) then
                    call SetMatrixValue(Me%StokesVel%Horizontal%U%Old, Me%Size, Me%StokesVel%Horizontal%U%New)
                    call SetMatrixValue(Me%StokesVel%Horizontal%V%Old, Me%Size, Me%StokesVel%Horizontal%V%New)
                endif



            if (Me%SubModel%ON)   then

                call SetMatrixValue(Me%SubModel%U_Old, Me%Size, Me%SubModel%U_New)
                call SetMatrixValue(Me%SubModel%V_Old, Me%Size, Me%SubModel%V_New)


            endif


        else cd2

            Stop 'Sub. Actualises_Hydrodynamic - ModuleHydrodynamic - Err03.'

        endif cd2

        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then
            call SetMatrixValue(Me%Velocity%Vertical%CartesianOld, Me%Size,             &
                                Me%Velocity%Vertical%Cartesian)
        endif

        !Actualize Generic 4D
        if (Me%Generic4D%ON)                                                            &
            Me%Generic4D%CurrentValue = TimeSerieValue(Me%Generic4D%ObjTimeSerie,       &
                                                       Me%CurrentTime,                  &
                                                       Me%Generic4D%TimeSerieColumn)

        if (Me%ThinWalls%ON) then
            call ModifyThinWallsMapping
        endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Actualises_Hydrodynamic")

    End Subroutine Actualises_Hydrodynamic


    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine One_Iteration


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        real, dimension(:,:), pointer               :: GaugeElevation, GaugeVelocity
        integer                                     :: Evolution, Grid
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB, k
        integer                                     :: STAT_CALL



        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "One_Iteration")


        call Actualize_HydrodynamicTimeStep

        !Initialize bottom boundary (Chezy coefficient is computed for the first time)
        if (Me%FirstIteration) then

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
#endif _USE_SEQASSIMILATION

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            call MaintainDirection
            call Bottom_Boundary
        endif


        Evolution = Me%ComputeOptions%Evolution

cd1:    if (Evolution == Solve_Equations_) then

            call MomentumMassConservation

#ifdef _USE_SEQASSIMILATION
            !(change direction to assure that only real runs change direction)
            if (Me%VirtualRun) call ChangeDirection
#endif _USE_SEQASSIMILATION

        else if (Evolution == Read_File_) then  cd1

            call ReadHydrodynamicFile

            call Bottom_Boundary

        else if (Evolution == No_hydrodynamic_ .or. Evolution == Residual_hydrodynamic_) then cd1

            !Don't make any hydrodynamic actualization
            !Update only the Geometry because the water properties evolution
            !verifies always if the geometry is actualized
            call New_Geometry

            call Bottom_Boundary

        else if (Evolution == ImposedSolution_) then cd1

            !use always the most recent data. Not centered in time always forward in time
            Me%WaterFluxes%New_Old = 1.

            call ReadImposedSolution

            !In this subroutine model verifies if the level is below a critical level and
            !if this is the case water level is set equal to the critical level.
            call WaterLevelCorrection

            !Update the moving boundary (boundary of the tidal areas covered)
            call UpdateComputeFaces3D(Me%ObjMap, Me%WaterLevel%New,                     &
                                      Me%CurrentTime, STAT = STAT_CALL)

            call Modify_HorizontalWaterFlow

            call ChangeDirection

            call Modify_HorizontalWaterFlow

            !Grid = Fix
            !First prediction of the vertical fluxes and velocity for a fixed geometry
            !This is only important when one of the domains as vertical "Lagrangian" coordinate

            Grid = Fix

            call New_VerticalHydrodynamic( Grid)

            call New_Geometry

            !Grid = Variable
            !the vertical water flux is compute with the effect of variable volume
            Grid = Variable

            call New_VerticalHydrodynamic( Grid)

            call Bottom_Boundary

#ifdef _USE_SEQASSIMILATION
            !(change direction to assure that only real runs change direction)
            if (Me%VirtualRun) call ChangeDirection
#endif _USE_SEQASSIMILATION

        else if (Evolution == Harmonics_)  then cd1

            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            call Modify_AllDomain(Me%ObjOpenBoundary, Me%CurrentTime)

            call GetImposedElevation(Me%ObjOpenBoundary, GaugeElevation)

            Me%WaterLevel%New(:,:) = GaugeElevation(:,:)

            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeElevation)

            call GetImposedVelocity(Me%ObjOpenBoundary, GaugeVelocity, DirectionX_)

            do k=KLB,KUB
                Me%Velocity%Horizontal%U%New(ILB:IUB,JLB:JUB,k) = GaugeVelocity(ILB:IUB,JLB:JUB)
            enddo

            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeVelocity)

            call GetImposedVelocity(Me%ObjOpenBoundary, GaugeVelocity, DirectionY_)

            do k=KLB,KUB
                Me%Velocity%Horizontal%V%New(ILB:IUB,JLB:JUB,k) = GaugeVelocity(ILB:IUB,JLB:JUB)
            enddo

            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeVelocity)

            call New_Geometry

            !call Bottom_Boundary



        else if (Evolution == Vertical1D_) then cd1
        !Guillaume
            call AssociateDirectionX
            
            if(Me%ComputeOptions%LocalDensity) then
                call FaceDensityUpdate
            else
                call SetMatrixValue( Me%FaceDensity, Me%Size, SigmaDensityReference)
            endif
            
            call Bottom_Boundary
            call Explicit_Forces
            call Compute_Velocity(PressureBackwardInTime = .true.)
            call AssociateDirectionY
            
            if(Me%ComputeOptions%LocalDensity) then
                call FaceDensityUpdate
            else
                call SetMatrixValue( Me%FaceDensity, Me%Size, SigmaDensityReference)
            endif
            
            call Bottom_Boundary
            call Explicit_Forces
            call Compute_Velocity(PressureBackwardInTime = .true.)

        else cd1

            Stop 'Sub. One_Iteration - ModuleHydrodynamic - Err04'

        endif cd1

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "One_Iteration")

    End Subroutine One_Iteration

    !End------------------------------------------------------------

    Subroutine ReadImposedSolution

        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        logical                                     :: RotateX, RotateY
        integer                                     :: STAT_CALL

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ReadImposedSolution")

        call ReadImposedSolutionRef  (RotateX, RotateY)
        call ReadImposedSolutionAstro(RotateX, RotateY)

        call RotateVectorFieldToGrid(HorizontalGridID  = Me%ObjHorizontalGrid,           &
                                     VectorInX         = Me%Velocity%Horizontal%U%New,   &
                                     VectorInY         = Me%Velocity%Horizontal%V%New,   &
                                     VectorOutX        = Me%Velocity%Horizontal%U%New,   &
                                     VectorOutY        = Me%Velocity%Horizontal%V%New,   &
                                     WaterPoints3D     = Me%External_Var%WaterPoints3D,  &
                                     RotateX           = RotateX,                        &
                                     RotateY           = RotateY,                        &
                                     KLB               = Me%WorkSize%KLB,                &
                                     KUB               = Me%WorkSize%KUB,                &
                                     STAT              = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolution - ModuleHydrodynamic - ERR10'

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ReadImposedSolution")

    end subroutine ReadImposedSolution

    !End------------------------------------------------------------

    Subroutine ReadImposedSolutionRef(RotateX, RotateY)

        !Arguments-------------------------------------------------------------------
        logical,    intent(OUT)                     :: RotateX, RotateY


        !Local----------------------------------------------------------------------
        real,    dimension(:,:,:), pointer          :: Matrix3D
        integer, dimension(:,:,:), pointer          :: PointsToFill3D
        integer                                     :: STAT_CALL, i, j, k

        integer                                     :: CHUNK

        !Begin----------------------------------------------------------------------

        if (Me%WaterLevel%ID%SolutionFromFile) then
            call ModifyFillMatrix (FillMatrixID   = Me%WaterLevel%ID%ObjFillMatrix, &
                                   Matrix2D       = Me%WaterLevel%New,              &
                                   PointsToFill2D = Me%External_Var%WaterPoints2D,  &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionRef - ModuleHydrodynamic - ERR10'

            Me%WaterLevel%New (:,:) = Me%WaterLevel%New (:,:) / Me%OutPut%WaterLevelUnits

        endif



        if (Me%ComputeOptions%TideStateON) then
            if (Me%WaterLevel%TideStateID%SolutionFromFile) then
                call ModifyFillMatrix (FillMatrixID   = Me%WaterLevel%TideStateID%ObjFillMatrix, &
                                       Matrix2D       = Me%WaterLevel%TideState,        &
                                       PointsToFill2D = Me%External_Var%WaterPoints2D,  &
                                       STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionRef - ModuleHydrodynamic - ERR15'
            endif
        endif


        RotateX = .false.
        RotateY = .false.

        if (Me%Velocity%Horizontal%U%ID%SolutionFromFile) then

            if      (Me%Velocity%Horizontal%U%InTypeZUV == TypeU_) then

                PointsToFill3D => Me%External_Var%ComputeFaces3D_U
                Matrix3D       => Me%Velocity%Horizontal%U%New

            else if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%WaterPoints3D

                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))

                Matrix3D(:,:,:) = FillValueReal

            endif

            call ModifyFillMatrix (FillMatrixID   = Me%Velocity%Horizontal%U%ID%ObjFillMatrix, &
                                   Matrix3D       = Matrix3D,                                  &
                                   PointsToFill3D = PointsToFill3D,                            &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionRef - ModuleHydrodynamic - ERR20'


            if (Me%Velocity%Horizontal%U%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%U%New(:,:,:) = 0.

                CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

                !$OMP PARALLEL PRIVATE(i,j,k)

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                    if (PointsToFill3D(i,j-1,k) == OpenPoint .and.                      &
                        PointsToFill3D(i,j  ,k) == OpenPoint) then
                        Me%Velocity%Horizontal%U%New(i,j,k) = (Matrix3D(i,j-1,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                !$OMP END DO NOWAIT
                enddo

                !$OMP END PARALLEL

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)


            RotateX = .true.

        endif

        if (Me%Velocity%Horizontal%V%ID%SolutionFromFile) then

            if      (Me%Velocity%Horizontal%V%InTypeZUV == TypeV_) then

                PointsToFill3D => Me%External_Var%ComputeFaces3D_V
                Matrix3D       => Me%Velocity%Horizontal%V%New

            else if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                PointsToFill3D => Me%External_Var%WaterPoints3D
                allocate (Matrix3D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))

                Matrix3D(:,:,:) = FillValueReal

            endif

            call ModifyFillMatrix (FillMatrixID   = Me%Velocity%Horizontal%V%ID%ObjFillMatrix, &
                                   Matrix3D       = Matrix3D,                                  &
                                   PointsToFill3D = PointsToFill3D,                            &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionRef - ModuleHydrodynamic - ERR30'

            if (Me%Velocity%Horizontal%V%InTypeZUV == TypeZ_) then

                Me%Velocity%Horizontal%V%New(:,:,:) = 0.

                CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

                !$OMP PARALLEL PRIVATE(i,j,k)

                do k = Me%WorkSize%KLB,Me%WorkSize%KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = Me%WorkSize%JLB,Me%WorkSize%JUB
                do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                    if (PointsToFill3D(i-1,j,k) == OpenPoint .and.                  &
                        PointsToFill3D(i  ,j,k) == OpenPoint) then
                        Me%Velocity%Horizontal%V%New(i,j,k) = (Matrix3D(i-1,j,k) + Matrix3D(i,j,k)) / 2.
                    endif

                enddo
                enddo
                !$OMP END DO NOWAIT
                enddo

                !$OMP END PARALLEL

                deallocate(Matrix3D)

            endif

            nullify   (PointsToFill3D)
            nullify   (Matrix3D)

            RotateY = .true.
        endif



    end subroutine ReadImposedSolutionRef

    !End------------------------------------------------------------

    Subroutine ReadImposedSolutionAstro(RotateX, RotateY)

        !Arguments-------------------------------------------------------------------
        logical,    intent(INOUT)                   :: RotateX, RotateY


        !Local----------------------------------------------------------------------
        real,    dimension(:,:  ), pointer          :: Matrix2D
        integer, dimension(:,:,:), pointer          :: PointsToFill3D
        integer                                     :: STAT_CALL, i, j, k

        integer                                     :: CHUNK

        !Begin----------------------------------------------------------------------

        if (Me%WaterLevel%ID_Astro%SolutionFromFile) then

            if (.not. Me%WaterLevel%ID%SolutionFromFile) then
                Me%WaterLevel%New(:,:) = 0
            endif

            allocate (Matrix2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

            Matrix2D(:,:) = 0.

            call ModifyFillMatrix (FillMatrixID   = Me%WaterLevel%ID_Astro%ObjFillMatrix,   &
                                    Matrix2D       = Matrix2D,                               &
                                    PointsToFill2D = Me%External_Var%WaterPoints2D,          &
                                    STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionAstro - ModuleHydrodynamic - ERR10'

            Matrix2D (:,:) = Matrix2D (:,:) / Me%OutPut%WaterLevelUnits


            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = Me%WorkSize%JLB,Me%WorkSize%JUB
            do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                if (Me%External_Var%WaterPoints2D(i,j) == WaterPoint) then
                    Me%WaterLevel%New(i, j) = Me%WaterLevel%New(i, j) + Matrix2D(i,j)
                endif

            enddo
            enddo
            !$OMP END DO NOWAIT
            !$OMP END PARALLEL


        endif


        if (Me%Velocity%Horizontal%U%ID_Astro%SolutionFromFile) then

            if (.not.associated(Matrix2D)) then
                allocate (Matrix2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))
            endif

            Matrix2D(:,:) = FillValueReal

            if (.not. Me%Velocity%Horizontal%U%ID%SolutionFromFile) then
                Me%Velocity%Horizontal%U%New(:,:,:) = 0.
            endif


            call ModifyFillMatrix (FillMatrixID   = Me%Velocity%Horizontal%U%ID_Astro%ObjFillMatrix,&
                                   Matrix2D       = Matrix2D,                                   &
                                   PointsToFill2D = Me%External_Var%WaterPoints2D,              &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionAstro - ModuleHydrodynamic - ERR20'


            PointsToFill3D => Me%External_Var%WaterPoints3D

            CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

            !$OMP PARALLEL PRIVATE(i,j,k)

            do k = Me%WorkSize%KLB,Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = Me%WorkSize%JLB,Me%WorkSize%JUB
            do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                if (PointsToFill3D(i,j-1,k) == WaterPoint .and.                      &
                    PointsToFill3D(i,j  ,k) == WaterPoint) then
                    Me%Velocity%Horizontal%U%New(i,j,k) = Me%Velocity%Horizontal%U%New(i,j,k) + &
                                                          (Matrix2D(i,j-1) + Matrix2D(i,j)) / 2.
                endif

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP END PARALLEL

            nullify   (PointsToFill3D)


            RotateX = .true.

        endif

        if (Me%Velocity%Horizontal%V%ID_Astro%SolutionFromFile) then

            if (.not.associated(Matrix2D)) then
                allocate (Matrix2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))
            endif

            Matrix2D(:,:) = FillValueReal

            if (.not. Me%Velocity%Horizontal%V%ID%SolutionFromFile) then
                Me%Velocity%Horizontal%V%New(:,:,:) = 0.
            endif

            call ModifyFillMatrix (FillMatrixID   = Me%Velocity%Horizontal%V%ID_Astro%ObjFillMatrix, &
                                   Matrix2D       = Matrix2D,                                  &
                                   PointsToFill2D = Me%External_Var%WaterPoints2D,             &
                                   STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  Stop 'ReadImposedSolutionAstro - ModuleHydrodynamic - ERR30'


            PointsToFill3D => Me%External_Var%WaterPoints3D

            CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

            !$OMP PARALLEL PRIVATE(i,j,k)

            do k = Me%WorkSize%KLB,Me%WorkSize%KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = Me%WorkSize%JLB,Me%WorkSize%JUB
            do i = Me%WorkSize%ILB,Me%WorkSize%IUB

                if (PointsToFill3D(i-1,j,k) == OpenPoint .and.                  &
                    PointsToFill3D(i  ,j,k) == OpenPoint) then
                    Me%Velocity%Horizontal%V%New(i,j,k) = Me%Velocity%Horizontal%V%New(i,j,k) + &
                                                         (Matrix2D(i-1,j) + Matrix2D(i,j)) / 2.
                endif

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP END PARALLEL

            nullify   (PointsToFill3D)

            RotateY = .true.
        endif

        if (associated(Matrix2D)) then
            deallocate (Matrix2D)
        endif


    end subroutine ReadImposedSolutionAstro

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (03/1)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine MomentumMassConservation

        !Arguments-------------------------------------------------------------------


        !Local----------------------------------------------------------------------

        integer                             :: Num_Discretization, Grid
        integer                             :: kbottomU, kbottomV
        integer                             :: ILB, IUB, JLB, JUB, WorkKUB, i, j, k
        integer                             :: STAT_CALL
        real                                :: Depth
        integer                             :: CHUNK

        !Begin----------------------------------------------------------------------

        if (Me%FirstIteration .and. Me%ComputeOptions%Geost_Initialization) then

            call ComputeGeostrophicVelocity(Me%WaterLevel%New,                          &
                                            Me%External_Var%SigmaDens)

            if (Me%ComputeOptions%LocalSolution == AssimilationField_ .or.              &
                Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.           &
                Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_ .or.          &
                Me%ComputeOptions%LocalSolution == AssimilaGauge_) then

                ! Compute batotropic part of geostrophic velocitiy

                ILB = Me%Size%ILB
                IUB = Me%Size%IUB
                JLB = Me%Size%JLB
                JUB = Me%Size%JUB

                WorkKUB = Me%WorkSize%KUB

                CHUNK = CHUNK_J(JLB, JUB)

                if (MonitorPerformance) then
                    call StartWatch ("ModuleHydrodynamic", "MomentumMassConservation")
                endif

                !$OMP PARALLEL PRIVATE(i,j,k,kbottomU,Depth,kbottomV)

                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_U (i ,j ,WorkKUB) == WaterPoint)  &
                    then
                        kbottomU = Me%External_Var%KFloor_U(i, j)

                        Depth = 0.
                        do k = WorkKUB, kbottomU, -1
                            Me%Geostroph%U_barotropic(i, j)=                            &
                                                      Me%Geostroph%U_barotropic(i, j)   &
                                                      +Me%Geostroph%U(i, j, k)*         &
                                                      Me%External_Var%DUZ(i, j, k)
                            Depth = Depth + Me%External_Var%DUZ(i, j, k)
                        enddo
                            Me%Geostroph%U_barotropic(i, j) =                           &
                                                  Me%Geostroph%U_barotropic(i, j)/ Depth
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT

                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_V (i ,j ,WorkKUB) == WaterPoint)  &
                    then
                        kbottomV = Me%External_Var%KFloor_V(i, j)

                        Depth = 0.
                        do k = WorkKUB, kbottomV, -1
                            Me%Geostroph%V_barotropic(i, j)=                            &
                                                    Me%Geostroph%V_barotropic(i, j)     &
                                                    +Me%Geostroph%V(i, j, k)*           &
                                                    Me%External_Var%DVZ(i, j, k)
                            Depth = Depth + Me%External_Var%DVZ(i, j, k)
                        enddo
                            Me%Geostroph%V_barotropic(i, j) =                           &
                                                 Me%Geostroph%V_barotropic(i, j) / Depth
                    endif
                enddo
                enddo
                !$OMP END DO

                !$OMP MASTER
                !Fetch the reference barotropic velocity field
                !call GetAssimilationField(Me%ObjAssimilation,                           &
                !                     ID      = BarotropicVelocityU_,                    &
                !                     Field2D = Me%Geostroph%Reference_U_barotropic,     &
                !                     STAT    = STAT_CALL)
                !if (STAT_CALL /= SUCCESS_)                                              &
                !    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR010'

                !call GetAssimilationField(Me%ObjAssimilation,                           &
                !                     ID      = BarotropicVelocityV_,                    &
                !                     Field2D = Me%Geostroph%Reference_V_barotropic,     &
                !                     STAT    = STAT_CALL)
                !if (STAT_CALL /= SUCCESS_)                                              &
                !    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR020'

                !It is important to read vector fields in agreggated way to allow the
                !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
                call GetAssimilationVectorField                                     &
                                     (AssimilationID    = Me%ObjAssimilation,       &
                                      VectorX_ID        = BarotropicVelocityU_,     &
                                      VectorY_ID        = BarotropicVelocityV_,     &
                                      VectorX_2D        = Me%Geostroph%Reference_U_barotropic, &
                                      VectorY_2D        = Me%Geostroph%Reference_V_barotropic, &
                                      STAT              = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR020'

                !Fetch the nudging coefficient for barotropic velocity
                call GetAssimilationCoef(Me%ObjAssimilation,                            &
                                     ID      = BarotropicVelocityU_,                    &
                                     CoefField2D = Me%Geostroph%Coef_U_barotropic,      &
                                     STAT            = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR030'

                call GetAssimilationCoef(Me%ObjAssimilation,                            &
                                     ID      = BarotropicVelocityV_,                    &
                                     CoefField2D = Me%Geostroph%Coef_V_barotropic,      &
                                     STAT            = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR040'
                !$OMP END MASTER
                !$OMP BARRIER

                !Initialize velocity with barotropic correction
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_U (i ,j ,WorkKUB) == WaterPoint)  &
                    then
                        kbottomU = Me%External_Var%KFloor_U(i, j)
                        do k = kbottomU, WorkKUB
                        Me%Velocity%Horizontal%U%New (i,j,k) = Me%Geostroph%U(i,j,k) +  &
                                           Me%Geostroph%Coef_U_barotropic (i,j) *       &
                                           (Me%Geostroph%Reference_U_barotropic (i,j)   &
                                           - Me%Geostroph%U_barotropic(i, j))
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT

                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%External_Var%ComputeFaces3D_V (i ,j ,WorkKUB) == WaterPoint)  &
                    then
                        kbottomV = Me%External_Var%KFloor_V(i, j)
                        do k = kbottomV, WorkKUB
                        Me%Velocity%Horizontal%V%New (i,j,k) = Me%Geostroph%V(i,j,k) +  &
                                           Me%Geostroph%Coef_V_barotropic (i,j) *       &
                                           (Me%Geostroph%Reference_V_barotropic (i,j)   &
                                           - Me%Geostroph%V_barotropic(i, j))
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

                if (MonitorPerformance) then
                    call StopWatch ("ModuleHydrodynamic", "MomentumMassConservation")
                endif

                Me%Velocity%Horizontal%U%Old (:,:,:) = Me%Velocity%Horizontal%U%New (:,:,:)
                Me%Velocity%Horizontal%V%Old (:,:,:) = Me%Velocity%Horizontal%V%New (:,:,:)

! Modified by Matthias DELPEY - 19/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                if (Me%ComputeOptions%WaveForcing3D == GLM) then

                    Me%StokesVel%Horizontal%U%Old (:,:,:) =  Me%StokesVel%Horizontal%U%New (:,:,:)
                    Me%StokesVel%Horizontal%V%Old (:,:,:) =  Me%StokesVel%Horizontal%V%New (:,:,:)

                endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


                !Unfetch the reference variables
                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Reference_U_barotropic,                &
                                    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR050'

                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Reference_V_barotropic,                &
                                    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR060'

                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Coef_U_barotropic,                     &
                                    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR070'

                call UnGetAssimilation( Me%ObjAssimilation,                             &
                                    Me%Geostroph%Coef_V_barotropic,                     &
                                    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'MomentumMassConservation - ModuleHydrodynamic - ERR080'


            else

            !Initialize velocity without barotropic correction

            Me%Velocity%Horizontal%U%New (:,:,:) = Me%Geostroph%U(:,:,:)
            Me%Velocity%Horizontal%V%New (:,:,:) = Me%Geostroph%V(:,:,:)
            Me%Velocity%Horizontal%U%Old (:,:,:) = Me%Velocity%Horizontal%U%New (:,:,:)
            Me%Velocity%Horizontal%V%Old (:,:,:) = Me%Velocity%Horizontal%V%New (:,:,:)

! Modified by Matthias DELPEY - 19/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                if (Me%ComputeOptions%WaveForcing3D == GLM) then

                    Me%StokesVel%Horizontal%U%Old (:,:,:) =  Me%StokesVel%Horizontal%U%New (:,:,:)
                    Me%StokesVel%Horizontal%V%Old (:,:,:) =  Me%StokesVel%Horizontal%V%New (:,:,:)

                endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


            endif


        endif


        call ModifyWaterDischarges

        Num_Discretization = Me%ComputeOptions%Num_Discretization

i1:     if (Me%ComputeOptions%Vertical_AxiSymmetric_Model == 0) then

cd2:        if      (Num_Discretization == Abbott    ) then

                call Abbott_Scheme

            else if (Num_Discretization == Leendertse) then cd2

                call Leendertse_Scheme

            else cd2

                Stop 'Sub. MomentumMassConservation - ModuleHydrodynamic - Err01.'

            endif cd2

        else i1

            call Implicit_1DScheme

        endif i1


        !NonHydrostatic
        if (Me%NonHydrostatic%ON) then

            call VerticalMomentum

            call NonHydroStaticCorrection

            call Modify_HorizontalWaterFlow

            call NullifyAuxiliarPointers

        endif

        !Grid = Fix
        !First prediction of the vertical fluxes and velocity for a fixed geometry
        !This is only important when one of the domains as vertical "Lagrangian" coordinate

        Grid = Fix

        call New_VerticalHydrodynamic( Grid)

        call New_Geometry

        !Grid = Variable
        !the vertical water flux is compute with the effect of variable volume
        Grid = Variable

        call New_VerticalHydrodynamic( Grid)

    End Subroutine MomentumMassConservation
    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Vertical Momentum
    !
    ! Calculates the vertical velocity by resolving the momentum equation in z direction.
    ! The routine computes a tri-diagonal system - that is coefficients and independent
    ! term - that is then solved using the Thomas algorithm.
    !
    ! 1) Pressure correction
    ! 2) Diffusion
    ! 3) Advection
    ! 4) Boundary Condition
    ! 5) Solve by Thomas Algorithm
    !
    ! ----------------------------
    !
    ! author : Hernani Theias
    ! last modified  : 06/2004
    ! e-mail : hernanitheias@netcabo.pt
    !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine VerticalMomentum
        !Local--------------------------------------------------
         real(8),    dimension(:,:,:), pointer  :: eCoef !coefficients
         real,    dimension(:,:,:), pointer     :: dCoef, fCoef, tiCoef !coefficients
         real,    dimension(:,:,:), pointer     :: PressureCorrect
         integer                                :: iub, ilb, jub, jlb, kub, klb
         integer                                :: i, j, k     !counters
         real(8),    dimension(:,:,:), pointer  :: fx, fy, fz
         real,       dimension(:,:,:), pointer  :: dz
         real,       dimension(:,:), pointer    :: dx, dy
         real                                   :: axy, az, kv
         real(8)                                :: aux, VolumeOld, VolumeNew, VolVar
         ! integer                                :: CHUNK

        !Begin---------------------------------------------------
        !----Shorten names
        iub = Me%WorkSize%IUB
        ilb = Me%WorkSize%ILB
        jub = Me%WorkSize%JUB
        jlb = Me%WorkSize%JLB
        kub = Me%WorkSize%KUB
        klb = Me%WorkSize%KLB
        dCoef => Me%Coef%D3%D
        eCoef => Me%Coef%D3%E
        fCoef => Me%Coef%D3%F
        tiCoef => Me%Coef%D3%Ti
        !----Initialize values
        dCoef(:,:,:) = 0.0
        eCoef(:,:,:) = 1.0
        fCoef(:,:,:) = 0.0
        tiCoef(:,:,:) = 0.0 !do not put FillValueReal here, please. Not healthy.

        PressureCorrect         => Me%NonHydrostatic%PressureCorrect

        ! CHUNK = CHUNK_J(jlb,jub)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        !----Non-Hydrostatic correction, explicit part

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "VerticalMomentum")

        ! !! $OMP PARALLEL PRIVATE(i,j,k)
        do k = klb, kub
        ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = jlb, jub
        do i = ilb, iub
            if(Me%External_Var%ComputeFaces3D_W(i, j, k) == Compute) then
                VolumeOld = (Me%External_Var%Volume_Z_Old(i, j, k) + Me%External_Var%Volume_Z_Old(i, j, k-1)) / 2.
                VolumeNew = Me%External_Var%Volume_W     (i, j, k)
                ![-]      = [m3]/[m3]
                VolVar    = VolumeOld / VolumeNew
                ![m/s]          =   [m/s] * [-]
                tiCoef(i, j, k) =   Me%Velocity%Vertical%CartesianOld(i, j, k) * VolVar
            endif
        enddo !do i
        enddo !do j
        ! !! $OMP END DO
        enddo !do k
        ! !! $OMP END PARALLEL

        !if (Me%NonHydroStatic%PressureCorrection) then

            ! !! $OMP PARALLEL PRIVATE(i,j,k)
        !    do k = klb, kub
            ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        !    do j = jlb, jub
        !    do i = ilb, iub
        !        if(Me%External_Var%ComputeFaces3D_W(i, j, k) == Compute) then
                    ![m/s]          =   [m/s]           + [m^2/s^2] / [m]
        !            TiCoef(i, j, k) =   tiCoef(i, j, k) + (PressureCorrect(i, j, k-1) -         &
        !                                                  PressureCorrect(i     , j    , k))/   &
        !                                                  Me%External_Var%DZZ(i, j, k-1)
        !        endif
        !    enddo !do i
        !    enddo !do j
            ! !! $OMP END DO
        !    enddo !do k
            ! !! $OMP END PARALLEL

        !endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "VerticalMomentum")

        !----Allocate...
        allocate(fx(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        allocate(fy(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        allocate(fz(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        allocate(dx(ilb-1:iub+1,jlb-1:jub+1))
        allocate(dy(ilb-1:iub+1,jlb-1:jub+1))
        allocate(dz(ilb-1:iub+1,jlb-1:jub+1,klb-1:kub+1))
        fx(:,:,:) = FillValueReal
        fy(:,:,:) = FillValueReal
        fz(:,:,:) = FillValueReal
        dx(:,:  ) = FillValueReal
        dy(:,:  ) = FillValueReal
        dz(:,:,:) = FillValueReal
        !----Calculate Diffusive Fluxes
        do j = jlb, jub
        do i = ilb, iub
            az = Me%External_Var%DXX(i,j) * Me%External_Var%DYY(i,j)
            do k = klb, kub
                !X
                if((Me%External_Var%WaterPoints3D(i,j  ,k  )==OpenPoint).and.           &
                   (Me%External_Var%WaterPoints3D(i,j-1,k  )==OpenPoint).and.           &
                   (Me%External_Var%WaterPoints3D(i,j  ,k-1)==OpenPoint).and.           &
                   (Me%External_Var%WaterPoints3D(i,j-1,k-1)==OpenPoint)) then
                    axy = Me%External_Var%DUZ(i,j,k) * Me%External_Var%DYY(i,j)
                    kv = interpolate3D(Me%External_Var%Visc_H_Center,                   &
                                       Me%External_Var%DUX, Me%External_Var%DVY,        &
                                       Me%External_Var%DWZ, i, j, k, 0, -1, -1)
                    fx(i,j,k) = kv * axy
                else
                    fx(i,j,k) = 0.0
                endif

                dx(i,j) = Me%External_Var%DZX(i,j-1)

                !Y
                if((Me%External_Var%WaterPoints3D(i,j,k)==OpenPoint).and.         &
                   (Me%External_Var%WaterPoints3D(i-1,j,k)==OpenPoint).and.       &
                   (Me%External_Var%WaterPoints3D(i,j,k-1)==OpenPoint).and.       &
                   (Me%External_Var%WaterPoints3D(i-1,j,k-1)==OpenPoint)) then
                    axy = Me%External_Var%DVZ(i,j,k) * Me%External_Var%DXX(i,j)
                    kv = interpolate3D(Me%External_Var%Visc_H_Center,            &
                                       Me%External_Var%DUX, Me%External_Var%DVY, &
                                       Me%External_Var%DWZ, i, j, k, -1, 0, -1)
                    fy(i,j,k) = kv * axy
                else
                    fy(i,j,k) = 0.0
                endif

                dy(i,j) = Me%External_Var%DZY(i,j-1)

                !Z
                if((Me%External_Var%ComputeFaces3D_W(i,j,k)==Compute).and. &
                   (Me%External_Var%ComputeFaces3D_W(i,j,k-1)==Compute)) then
                    kv = ( Me%External_Var%Vertical_Viscosity(i, j, k-1) +              &
                           Me%External_Var%Vertical_Viscosity(i, j, k  ) ) / 2.
                    fz(i,j,k) = kv * az
                else
                    fz(i,j,k) = 0.0
                endif

                dz(i,j,k) = Me%External_Var%DWZ(i,j,k)

            enddo !do k
        enddo !do i
        enddo !do j
        !----Diffusion
         call ComputeDiffusion3D (ilb, iub, jlb, jub, klb, kub,                         &
                dx, dy, dz,                                                             &
                Me%External_Var%ComputeFaces3D_W,                                       &
                fx, fy, fz,                                                             &
                Me%WaterLevel%DT, Me%Velocity%Vertical%Cartesian,                       &
                Me%External_Var%Volume_W,                                               &
                Ticoef, Ecoef, DCoef, Fcoef,                                            &
                0.,                                                                     &
                0.,                                                                     &
                Me%ComputeOptions%ImplicitVertDiffusion,                                &
                Me%ComputeOptions%HorizontalDiffusion,                                  &
                Me%ComputeOptions%HorizontalDiffusion,                                  &
                Me%ComputeOptions%VerticalDiffusion)
        !----Interpolate Fluxes to W-Grid
        do k = klb, kub
        do j = jlb, jub + 1
        do i = ilb, iub + 1
!            fx(i,j,k) = interpolate3D(Me%WaterFluxes%X,                                &
!                                   Me%External_Var%DUX, Me%External_Var%DVY,           &
!                                   Me%External_Var%DWZ, i, j, k, 0, 0, -1)

            aux = Me%External_Var%DUZ(i, j, k-1) /(Me%External_Var%DUZ(i, j, k-1) + Me%External_Var%DUZ(i, j, k))

            fx(i,j,k) =             Me%External_Var%ComputeFaces3D_U(i,j,k  ) * Me%WaterFluxes%X(i,j,k  ) * aux
            fx(i,j,k) = fx(i,j,k) + Me%External_Var%ComputeFaces3D_U(i,j,k-1) * Me%WaterFluxes%X(i,j,k-1) * (1.-aux)

!            fy(i,j,k) = interpolate3D(Me%WaterFluxes%Y,                                &
!                                   Me%External_Var%DUX, Me%External_Var%DVY,           &
!                                   Me%External_Var%DWZ, i, j, k, 0, 0, -1)

            aux = Me%External_Var%DVZ(i, j, k-1) /(Me%External_Var%DVZ(i, j, k-1) + Me%External_Var%DVZ(i, j, k))

            fy(i,j,k) =             Me%External_Var%ComputeFaces3D_V(i,j,k  ) * Me%WaterFluxes%Y(i,j,k  ) * aux
            fy(i,j,k) = fy(i,j,k) + Me%External_Var%ComputeFaces3D_V(i,j,k-1) * Me%WaterFluxes%Y(i,j,k-1) * (1.-aux)

            !fz(i,j,k) = interpolate3D(Me%WaterFluxes%Z,                                &
            !                       Me%External_Var%DUX, Me%External_Var%DVY,           &
            !                       Me%External_Var%DWZ, i, j, k, 0, 0, -1)

            fz(i,j,k) =             Me%External_Var%ComputeFaces3D_W(i,j,k  ) * Me%WaterFluxes%Z(i,j,k  ) * 0.5
            fz(i,j,k) = fz(i,j,k) + Me%External_Var%ComputeFaces3D_W(i,j,k-1) * Me%WaterFluxes%Z(i,j,k-1) * 0.5

        enddo !do k
        enddo !do i
        enddo !do j
        !----Advection
        call ComputeAdvection3D(ilb, iub, jlb, jub, klb, kub,                           &
                    dx, dy, dz,                                                         &
                    Me%External_Var%ComputeFaces3D_W,                                   &
                    fx, fy, fz,                                                         &
                    Me%WaterLevel%DT, Me%Velocity%Vertical%Cartesian,                   &
                    Me%External_Var%Volume_W,                                           &
                    Ticoef, Ecoef, DCoef, Fcoef,                                        &
                    0.0,                                                                &
                    0.0,                                                                &
                    Me%ComputeOptions%ImplicitVertAdvection,                            &
                    Me%ComputeOptions%HorizontalAdvection,                              &
                    Me%ComputeOptions%HorizontalAdvection,                              &
                    Me%ComputeOptions%VerticalAdvection,                                &
                    Me%ComputeOptions%AdvectionMethodH,                                 &
                    Me%ComputeOptions%AdvectionMethodV,                                 &
                    Me%ComputeOptions%TVD_LimH,                                         &
                    Me%ComputeOptions%TVD_LimV,                                         &
                    Me%ComputeOptions%VolumeRelMax,                                     &
                    Me%ComputeOptions%Upwind2H,                                         &
                    Me%ComputeOptions%Upwind2V)

        !Compute the momentum discharge
        if (Me%ComputeOptions%MomentumDischarge)                            &
            call ModifyMomentumDischargeVert

       !----Boundary condition
        call VerticalMomentumBoundary

        !Adds a force that relax the velocity field to a reference field
        if (Me%Relaxation%Force)                                                &
            call ModifyRelaxAcelerationVert

        !----Solve
        call THOMASZ(ilb, iub, jlb, jub, klb, kub, Me%THOMAS,       &
                      Me%Velocity%Vertical%Cartesian                &
#ifdef _ENABLE_CUDA
        ! Use CUDA to solve the Thomas algorithm, ID of ModuleCuda is needed
                         , Me%ObjCuda,                              &
                         .FALSE.                                    &
#endif _ENABLE_CUDA
                         )

        !null gradient in the open boundary.
        call NullGradProp3D_W(Me%Velocity%Vertical%Cartesian)


        !----DeAllocate...
        deallocate(fx)
        deallocate(fy)
        deallocate(fz)
        deallocate(dx)
        deallocate(dy)
        deallocate(dz)
    End Subroutine VerticalMomentum
    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Vertical Momentum Boundary Condition
    !
    ! ----------------------------
    !
    ! author : Hernani Theias
    ! last modified  : 06/2004
    ! e-mail : hernanitheias@netcabo.pt
    !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine VerticalMomentumBoundary
        !Arguments-------------------------------------------------------------------
        real,    dimension(:,:,:), pointer     :: ti, s, n
        real(8), dimension(:,:,:), pointer     :: p
        integer                                :: ilb, iub, jlb, jub, k_up !bounds
        integer,    dimension(:,:), pointer    :: k_bottom
        !Local----------------------------------------------------------------------
        integer                                 :: i, j !counters
        ! integer                                 :: CHUNK

        !Begin----------------------------------------------------------------------
        ilb = Me%WorkSize%ILB
        iub = Me%WorkSize%IUB
        jlb = Me%WorkSize%JLB
        jub = Me%WorkSize%JUB
        K_UP = Me%WorkSize%KUB + 1

        nullify(ti, s, p, n)

        ti => Me%Coef%D3%TI
        s  => Me%Coef%D3%D
        p  => Me%Coef%D3%E
        n  => Me%Coef%D3%F
        k_bottom => Me%External_Var%KFloor_Z

        ! CHUNK = CHUNK_I(ilb,iub)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")

        ! !! $OMP PARALLEL PRIVATE(i,j,k)
        do i = ilb, iub
        do j = jlb, jub
        !--------Impose w_bottom = 0.0
            if(k_bottom(i,j)>0) then
                ti(i, j, k_bottom(i,j)) = 0.0
                s (i, j, k_bottom(i,j)) = 0.0
                p (i, j, k_bottom(i,j)) = 1.0
                n (i, j, k_bottom(i,j)) = 0.0
            endif
        !--------Impose w_up = d(eta)/dt
            ti(i, j, k_up) =  (Me%WaterLevel%New(i, j) - Me%WaterLevel%Old(i, j)) &
                             / Me%WaterLevel%DT
            s (i, j, k_up) = 0.0
            p (i, j, k_up) = 1.0
            n (i, j, k_up) = 0.0
        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        nullify(ti, s, p, n)

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")

    endsubroutine VerticalMomentumBoundary
    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Vertical Open Boundary Condition
    !
    ! ----------------------------
    !
    ! author : Paulo Leitao
    ! last modified  : 03/2014
    ! e-mail : paulo.chambel@hidromod.com
    !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NullGradProp3D_W_R4(Prop)
        !Local----------------------------------------------------------------------
        integer                                :: ilb, iub, jlb, jub, k_up, klb, k_bottom, k_first !bounds
        real(4),    dimension(:,:,:), pointer  :: Prop
        integer                                :: i, j, k, iy, jx !counters
        ! integer                                 :: CHUNK

        !Begin----------------------------------------------------------------------
        ilb = Me%WorkSize%ILB
        iub = Me%WorkSize%IUB
        jlb = Me%WorkSize%JLB
        jub = Me%WorkSize%JUB
        k_up= Me%WorkSize%KUB + 1
        klb = Me%WorkSize%KLB

        ! CHUNK = CHUNK_I(ilb,iub)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")

        !explicit horizontal null gradient

        ! !! $OMP PARALLEL PRIVATE(i,j,k,count)
        do i = ilb, iub
        do j = jlb, jub
            if  (Me%External_Var%BoundaryPoints(i, j) == Boundary) then
                !initalization
                k_bottom = Me%External_Var%KFloor_Z(i,j)
                do k= k_bottom, k_up
                    Prop(i, j, k) = 0.
                enddo

                iy      = i
                jx      = j
                k_first = k_bottom

                !null gradient horizontal open boundary condition
                if       (Me%External_Var%BoundaryFacesU(i,j  ) == Boundary) then

                    iy      = i
                    jx      = j - 1
                    k_first = Me%External_Var%KFloor_U(i,j)

                else if  (Me%External_Var%BoundaryFacesU(i,j+1) == Boundary) then

                    iy      = i
                    jx      = j + 1
                    k_first = Me%External_Var%KFloor_U(i,j + 1)

                else if  (Me%External_Var%BoundaryFacesV(i,j  ) == Boundary) then

                    iy      = i - 1
                    jx      = j
                    k_first = Me%External_Var%KFloor_V(i,j)

                else if  (Me%External_Var%BoundaryFacesV(i+1,j) == Boundary) then

                    iy      = i + 1
                    jx      = j
                    k_first = Me%External_Var%KFloor_V(i + 1, j)

                endif

                do k= k_first, k_up
                    Prop(i, j, k) = Prop(iy, jx, k)
                enddo

            endif
        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")

    endsubroutine NullGradProp3D_W_R4
    !End----------------------------------------------------------------------

    Subroutine NullGradProp3D_W_R8(Prop)
        !Local----------------------------------------------------------------------
        integer                                :: ilb, iub, jlb, jub, k_up, klb, k_bottom, k_first, KUB !bounds
        real(8),    dimension(:,:,:), pointer  :: Prop
        integer                                :: i, j, k, iy, jx !counters
        ! integer                                 :: CHUNK

        !Begin----------------------------------------------------------------------
        ilb = Me%WorkSize%ILB
        iub = Me%WorkSize%IUB
        jlb = Me%WorkSize%JLB
        jub = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB
        k_up= Me%WorkSize%KUB + 1
        klb = Me%WorkSize%KLB

        ! CHUNK = CHUNK_I(ilb,iub)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")

        !explicit horizontal null gradient

        ! !! $OMP PARALLEL PRIVATE(i,j,k,count)
        do i = ilb, iub
        do j = jlb, jub
            if  (Me%External_Var%BoundaryPoints(i, j) == Boundary) then
                !initalization
                k_bottom = Me%External_Var%KFloor_Z(i,j)
                do k= k_bottom, k_up
                    Prop(i, j, k) = 0.
                enddo

                k_first = k_bottom
                iy      = i
                jx      = j

                !null gradient horizontal open boundary condition
                if       (Me%External_Var%BoundaryFacesU(i,j  ) == Boundary) then

                    iy      = i
                    jx      = j - 1
                    k_first = Me%External_Var%KFloor_U(i,j)

                else if  (Me%External_Var%BoundaryFacesU(i,j+1) == Boundary) then

                    iy      = i
                    jx      = j + 1
                    k_first = Me%External_Var%KFloor_U(i,j + 1)

                else if  (Me%External_Var%BoundaryFacesV(i,j  ) == Boundary) then

                    iy      = i - 1
                    jx      = j
                    k_first = Me%External_Var%KFloor_V(i,j)

                else if  (Me%External_Var%BoundaryFacesV(i+1,j) == Boundary) then

                    iy      = i + 1
                    jx      = j
                    k_first = Me%External_Var%KFloor_V(i + 1, j)

                !corners
                else
                    !North
                    if     (Me%External_Var%OpenPoints3D(i+1, j, KUB) == OpenPoint) then
                        iy = i+1
                        jx = j
                    !South
                    elseif (Me%External_Var%OpenPoints3D(i-1, j, KUB) == OpenPoint) then
                        iy = i-1
                        jx = j
                    !East
                    elseif (Me%External_Var%OpenPoints3D(i, j+1, KUB) == OpenPoint) then
                        iy = i
                        jx = j+1
                    !West
                    elseif (Me%External_Var%OpenPoints3D(i, j-1, KUB) == OpenPoint) then
                        iy = i
                        jx = j-1
                    !SW
                    elseif (Me%External_Var%OpenPoints3D(i-1, j-1, KUB) == OpenPoint) then
                        iy = i-1
                        jx = j-1
                    !NE
                    elseif (Me%External_Var%OpenPoints3D(i+1, j+1, KUB) == OpenPoint) then
                        iy = i+1
                        jx = j+1
                    !SE
                    elseif (Me%External_Var%OpenPoints3D(i-1, j+1, KUB) == OpenPoint) then
                        iy = i-1
                        jx = j+1
                    !NW
                    elseif (Me%External_Var%OpenPoints3D(i+1, j-1, KUB) == OpenPoint) then
                        iy = i+1
                        jx = j-1
                    endif

                    k_first = Me%External_Var%KFloor_Z(iy, jx)

                endif

                do k= k_first, k_up
                    Prop(i, j, k) = Prop(iy, jx, k)
                enddo

            endif
        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "VerticalMomentumBoundary")

    endsubroutine NullGradProp3D_W_R8
    !End----------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! Non-HydroStatic Correction
    ! --------------------------
    !
    ! This routine calculates pressure correction due to non-hydrostatic effects.
    ! It gives a correction that is then applied to velocity and water level.
    ! This procedure is based on an article by V. Casulli and P. Zanolli
    ! "Semi-Implicit Numerical Modeling of Nonhydrostatic Free-Surface Flows for
    ! environmental problems" applied to Mohid.
    ! This correction is calculated via a set of equations that yields a
    ! linear system of equations.
    ! The resulting pentadiagonal system is solved using either:
    ! i)    Pre-Conditionned Conjugate Gradient Method
    ! ii)   Stone's Method (LU decomposition for sparse matrices)
    ! iii)  LiSolve
    ! Values of matrix coefficient for the system are stored in 'p', 'e', 'w', 'n', 's'
    ! vectors, 'p' being the diagonal. 'q' is the independent term.
    ! The solution of the system is stored in 'pc', which is previsional pressure correction.
    ! There is no correction on w. The continuity equation is used to to determine it, so
    ! model is conservative.
    !
    ! ----------------------------
    !
    ! author : Hernani Theias
    ! last modified  : 06/2004
    ! e-mail : hernanitheias@netcabo.pt
    !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroStaticCorrection
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real,    dimension (:,:,:), pointer  :: DecayTimeW
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        real,    dimension (:,:,:), pointer  :: pc        ! previsional pressure correction
        integer                              :: di, dj    ! index change due to calculation direction
        real                                 :: dt        ! time step
        real                                 :: az        ! cell face area in Z direction
        real(8)                              :: aux, Aux1, Aux2       ! auxiliary coefficient
        real(8)                              :: fluxZ     ! flux in Z-dir for the upper (free surface) cell
        real                                 :: pcl       ! local value for pressure correction
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KLB, KUB !bounds
        integer                              :: status
        ! integer                              :: CHUNK

        !External_Var - Grid
        integer, dimension (:,:  ), pointer  :: KFloorZ   ! bottom layer
        real,    dimension (:,:  ), pointer  :: DUX, DVY, DZX_ZY, DZY_ZX, WaterColumn
        real,    dimension (:,:,:), pointer  :: Area_UV, DWZ, DUZ_VZ, SZZ
        real(8), dimension (:,:,:), pointer  :: Volume_UV, Volume_W

        !External_Var - Mapping
        integer, dimension (:,:,:), pointer  :: ComputeFaces3D_UV
        integer, dimension (:,:,:), pointer  :: ComputeFaces3D_VU
        integer, dimension (:,:,:), pointer  :: OpenPoints3D
        integer, dimension (:,:,:), pointer  :: ComputeFaces3D_W

        !Fluxes
        real(8), dimension (:,:,:), pointer  :: Fluxes_XY, Fluxes_YX
        !Velocity
        real,    dimension (:,:,:), pointer  :: Vertical_Cartesian
        real,    dimension (:,:,:), pointer  :: UV_New, VU_New
        !Water level
        real,    dimension (:,:  ), pointer  :: WaterLevel_Old
        real,    dimension (:,:  ), pointer  :: WaterLevel_New
        !non-hydrostatic
        real,    dimension (:,:,:), pointer  :: PressureCorrect
        real,    dimension (:,:  ), pointer  :: VerticalSurfLayerOld


        real                                 :: SZZaux, pcf

        !Begin----------------------------------------------------------------------


        !----Shorten variables names
        w => Me%NonHydroStatic%CCoef
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        e => Me%NonHydroStatic%GCoef
        q => Me%Coef%D3%TI
        pc => Me%NonHydroStatic%PrevisionalQ
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB
        dt = Me%WaterLevel%DT

        !External_Var - Grid
        KFloorZ             => Me%External_Var%KFloor_Z
        DUX                 => Me%External_Var%DUX
        DVY                 => Me%External_Var%DVY
        Area_UV             => Me%External_Var%Area_UV
        Volume_UV           => Me%External_Var%Volume_UV
        Volume_W            => Me%External_Var%Volume_W
        DZX_ZY              => Me%External_Var%DZX_ZY
        DZY_ZX              => Me%External_Var%DZY_ZX
        DUZ_VZ              => Me%External_Var%DUZ_VZ
        DWZ                 => Me%External_Var%DWZ
        SZZ                 => Me%External_Var%SZZ
        WaterColumn         => Me%External_Var%WaterColumn


        !External_Var - Mapping
        ComputeFaces3D_UV   => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU   => Me%External_Var%ComputeFaces3D_VU
        OpenPoints3D        => Me%External_Var%OpenPoints3D
        ComputeFaces3D_W    => Me%External_Var%ComputeFaces3D_W

        !Fluxes
        Fluxes_XY           => Me%WaterFluxes%XY
        Fluxes_YX           => Me%WaterFluxes%YX

        !Velocity
        Vertical_Cartesian  => Me%Velocity%Vertical%Cartesian
        UV_New              => Me%Velocity%Horizontal%UV%New
        VU_New              => Me%Velocity%Horizontal%VU%New

        !Water level
        WaterLevel_Old      => Me%WaterLevel%Old
        WaterLevel_New      => Me%WaterLevel%New
        !non-hydrostatic
        PressureCorrect     => Me%NonHydroStatic%PressureCorrect
        VerticalSurfLayerOld=> Me%NonHydrostatic%VerticalSurfLayerOld

        !Numerics
        di = Me%Direction%di
        dj = Me%Direction%dj


        if (Me%Relaxation%Force) then

            call GetAssimilationCoef (Me%ObjAssimilation,                               &
                                      ID              = VelocityW_,                     &
                                      CoefField3D     = DecayTimeW,                     &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                         &
                call SetError (FATAL_, INTERNAL_, "NonHydroStaticCorrection - Hydrodynamic - ERR10")

        endif




        !----Initialize coefficient matrices

        call SetMatrixValue(n, Me%WorkSize,      0.0 )
        call SetMatrixValue(s, Me%WorkSize,      0.0 )
        call SetMatrixValue(w, Me%WorkSize,      0.0 )
        call SetMatrixValue(e, Me%WorkSize,      0.0 )
        call SetMatrixValue(p, Me%WorkSize, dble(0.0))
        call SetMatrixValue(q, Me%WorkSize,      0.0 )

        n(:,:,:) = 0.0
        s(:,:,:) = 0.0
        w(:,:,:) = 0.0
        e(:,:,:) = 0.0
        p(:,:,:) = 0.0
        q(:,:,:) = 0.0

        !----Calculate matrix coefficient and independent term of the system
        do i = ILB, IUB
        do j = JLB, JUB
        !--------Calculate z-area of cell
            az = DUX(i,j) * DVY(i,j)
            do k = KLB, KUB
i1:             if (OpenPoints3D(i, j, k) == OpenPoint) then !cell must not be calculated

            !-------------Fluxes in the implicit direction
                    if (ComputeFaces3D_UV(i, j, k) == Compute) then
                        ![s*m] = [s*m^4/m^3]
                        aux = dt * Area_UV(i, j, k) ** 2 / Volume_UV(i, j, k)

                        if (k == KUB .and. .not. Me%NonHydroStatic%SurfBoundHydrostatic) then
                            ![s*m]  = [s*m] * [m)/[m]
                            SZZaux = - SZZ(i, j, k  ) + SZZ(i - di, j - dj, k  )
                            SZZaux = - SZZ(i, j, k-1) + SZZ(i - di, j - dj, k-1) + SZZaux
                            aux1 = aux * 0.5 *  SZZaux/ DUZ_VZ(i, j, k)
                            aux  = aux  * 0.5
                            aux1 = aux1 * 0.5
                        else
                            aux1 = 0.
                        endif

                        ![s*m]
                        p(i     , j     , k) = p(i     , j     , k) + aux + aux1
                        s(i     , j     , k) = s(i     , j     , k) - aux + aux1
                        ![m3/s]              =  [m3/s] + [m3/s]
                        q(i     , j     , k) = q(i     , j     , k) + Fluxes_XY(i, j, k)

                        p(i - di, j - dj, k) = p(i - di, j - dj, k) + aux - aux1
                        n(i - di, j - dj, k) = n(i - di, j - dj, k) - aux - aux1
                        q(i - di, j - dj, k) = q(i - di, j - dj, k) - Fluxes_XY(i, j, k)
                    endif
            !-------------Fluxes in the explicit direction
                    if (ComputeFaces3D_VU(i, j, k) == Compute) then
                        q(i     , j     , k) = q(i     , j     , k) + Fluxes_YX(i, j, k)
                        q(i - dj, j - di, k) = q(i - dj, j - di, k) - Fluxes_YX(i, j, k) !note here di and dj are switched
                    endif

                    !------------Fluxes in Z direction

                    ![s*m]        = ![s] * [m^4] / [m^3]
                    aux            = dt * az ** 2 / Volume_W(i, j, k)

                    if (ComputeFaces3D_W (i, j, k) == Compute) then

                        if (associated(DecayTimeW)) then
                            if (DecayTimeW(i,j,k)< 1000) aux = 0.01 * aux
                        endif

                        ![m3/s]        = ![m^2] * [m/s]
                        fluxZ          = az * Vertical_Cartesian(i, j, k)

                        p(i, j, k) = p(i, j, k    ) +  aux
                        w(i, j, k) = w(i, j, k    ) -  aux
                        ![m3/s]    = [m3/s] + []*[m3/s] + [ ]* [m^2] * [m/s]
                        q(i, j, k) = q(i, j, k    ) + fluxZ

                        p(i, j, k - 1) = p(i, j, k - 1) + aux
                        e(i, j, k - 1) = e(i, j, k - 1) - aux
                        q(i, j, k - 1) = q(i, j, k - 1) - fluxZ

                    endif

            !----------------Free-Surface Layer - boundary condition (pressure correction = 0)
                    if (k == KUB) then

                        if (Me%NonHydroStatic%SurfBoundHydrostatic) then
                            ![m3/s]    = [m3/s]         + [m]/[s]*[m^2]
                            q(i, j, k) = q(i, j, k    ) + (WaterLevel_Old(i, j) - WaterLevel_New(i, j)) / dt * az
                            ![s*m]     = [s*m]          + [m^2]/[m/s^2]/[s]
                            p(i, j, k) = p(i, j, k    ) + az / Gravity / dt
                        else
                            ![s*m]     = [s*m]          + [m/s] * [m^2]
                            q(i, j, k) = q(i, j, k    ) - VerticalSurfLayerOld(i, j) * az

                            ![s*m]     = [s*m]          + [m^2] * [s] / [m]
                            p(i, j, k) = p(i, j, k    ) + az * 2. * dt / DWZ(i, j, k)
                        endif

                    endif

                endif i1
            enddo ! do k
            enddo ! do j
        enddo ! do i

        !
        !if (Me%NonHydroStatic%SZZGrad) then
        !    call SZZGradients
        !endif

        !----In case of no implicit correction the correction is assumed equal to zero
        do i = ILB-1, IUB+1
        do j = JLB-1, JUB+1
        do k = KLB-1, KUB+1
            if (p(i,j,k) == 0. .or. OpenPoints3D(i, j, k) /= OpenPoint) then
                p(i,j,k) = 1.
                n(i,j,k) = 0.
                s(i,j,k) = 0.
                e(i,j,k) = 0.
                w(i,j,k) = 0.
                q(i,j,k) = 0.
            endif
        enddo ! do k
        enddo ! do j
        enddo ! do i
        !
        !----Boundary Condition - Before Solving System

        if (Me%ComputeOptions%WaterDischarges) call NonHydroDischarges

        call NonHydroOpenBoundary(InTime = Implicit_)

        if (KUB > 1) then

            call BICGSTAB2D(pc, p, s, n, w, e, q,               &
                              ilb, iub, jlb, jub, klb, kub,     &
                              dj,                               &
                              Me%NonHydroStatic%MaxIt,          &
                              Me%NonHydroStatic%Residual,       &
                              OpenPoints3D,                     &
                              Me%NonHydroStatic%AlphaLU,        &
                              Me%NonHydroStatic%NormalizedResidual)
        else

           call THOMAS_2D_NonHydroCorrection(p, s, n, q, pc)

        endif

        call NonHydroOpenBoundary(InTime = Explicit_)

        !
        !----Solve the syste
        !
        !----Correction (of velocity and water level accordingly to 'pc')
        !
        ! CHUNK = CHUNK_J(JLB, JUB)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroStaticCorrection")




        ! !! $OMP PARALLEL PRIVATE(i,j,k,az,pc1)
        ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            ![m^2] = [m]*[m]
            az = DUX(i,j) * DVY(i,j)
            do k = KLB,KUB
        !------------Correct NH pressure correction (itself!)
                if (Me%NonHydroStatic%SurfBoundHydrostatic) then
                    PressureCorrect(i,j,k) = pc(i, j, k)  - pc(i, j, KUB)
                else
                    PressureCorrect(i,j,k) = pc(i, j, k)
                endif
            enddo !do k
        enddo !do i
        enddo !do j
        ! !!$OMP END DO
        ! !!$OMP END PARALLEL


        if (Me%NonHydroStatic%SurfBoundHydrostatic) then

            ! !! $OMP PARALLEL PRIVATE(i,j,k,az,pc1)
            ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
                ![m^2] = [m]*[m]
                az = DUX(i,j) * DVY(i,j)
            !--------Correct water level
                if(OpenPoints3D  (i, j, KUB) == OpenPoint) then
                    ![m]= [m^2/s^2]     / [m/s^2]
                    pcl = pc(i, j, KUB) / Gravity
                    ![m]                   = [m]'+ [m]
                    WaterLevel_New(i,j) = WaterLevel_New(i,j) + pcl
                end if
            enddo !do i
            enddo !do j
            ! !!$OMP END DO
            ! !!$OMP END PARALLEL

        endif

        ! !!$OMP PARALLEL PRIVATE(i,j,k,pcl)
        ! !!$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            do k = KLB,KUB
        !------------Correct UV - only the direction taken implicit is corrected
                if(ComputeFaces3D_UV(i,j,k) == Compute) then

                    pcl = pc(i - di, j - dj, k) - pc(i     , j     , k)

                    ![m/s]        = [s] * [m^2/^s] / [m]
                    Aux           =  dt * pcl / DZX_ZY(i-di, j-dj)



                    if (.not. Me%NonHydroStatic%SurfBoundHydrostatic) then
                        if (k == KUB) then
                            pcf =  (pc(i - di, j - dj, k) + pc(i, j, k)) / 2.
                            ![m/s] = [m/s] + [s] * [m^2/s^2] / [m] * [m/m]
                            SZZaux = (- SZZ(i - di, j - dj, k)   + SZZ(i, j, k))
                            SZZaux = (- SZZ(i - di, j - dj, k-1) + SZZ(i, j, k-1)) + SZZaux

                            Aux =  Aux + dt * pcf / DUZ_VZ(i, j, k) *  SZZaux / DZX_ZY(i-di,j-dj)

                            Aux  = Aux * 0.5
                        endif
                    endif

                    ![m/s]        =  [m/s] + [m/s]
                    UV_New(i,j,k) =  UV_New(i,j,k) + Aux

                    if (.not. Me%NonHydroStatic%SurfBoundHydrostatic) then
                        ![m]                     = [m/s] * [s] * [m^2] / [m^2]
                        Aux1                      = Aux * dt * Area_UV(i,j,k) / (DUX(i   ,j   ) * DVY(i   ,j   ))
                        Aux2                      = Aux * dt * Area_UV(i,j,k) / (DUX(i-di,j-dj) * DVY(i-di,j-dj))
                        WaterLevel_New(i   ,j   ) = WaterLevel_New(i   ,j   ) + Aux1
                        WaterLevel_New(i-di,j-dj) = WaterLevel_New(i-di,j-dj) - Aux2
                    endif
                endif
            enddo !do k
        enddo !do i
        enddo !do j
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        if (.not. Me%NonHydroStatic%SurfBoundHydrostatic) then
            do j = JLB, JUB
            do i = ILB, IUB
                if(OpenPoints3D(i,j,KUB) == OpenPoint) then
                    VerticalSurfLayerOld(i, j) = VerticalSurfLayerOld(i, j) + 2 * dt * pc(i, j, KUB)/DWZ(i, j, KUB)
                    !VerticalSurfLayerOld(i, j) = (WaterLevel_New(i,j)-WaterLevel_Old(i,j))/dt
                endif
            enddo !do i
            enddo !do j
        endif

        if (Me%Relaxation%Force) then

            call UnGetAssimilation (Me%ObjAssimilation, DecayTimeW,  status)

        endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroStaticCorrection")

        !----restore values on p (avoid divisions by zero at later stages of calculation)
        call SetMatrixValue(p, Me%WorkSize, dble(1.0))

        nullify (w, s, p, n, e, q, pc)

        !External_Var - Grid
        nullify (DUX, DVY, Area_UV, Volume_UV, Volume_W, DZX_ZY, DZY_ZX, KFloorZ, DUZ_VZ, DWZ, SZZ)
        nullify (WaterColumn)

        !External_Var - Mapping
        nullify (ComputeFaces3D_UV, ComputeFaces3D_VU, OpenPoints3D, ComputeFaces3D_W)

        !Fluxes
        nullify (Fluxes_XY, Fluxes_YX)
        !Velocity
        nullify (Vertical_Cartesian, UV_New, VU_New)
        !Water level
        nullify (WaterLevel_Old, WaterLevel_New)
        !Non-hydrostatic
        nullify (PressureCorrect     )
        nullify (VerticalSurfLayerOld)

    End Subroutine NonHydroStaticCorrection
    !End------------------------------------------------------------

    Subroutine SZZGradients
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: s,n,w,e   ! coefficient matrix (non-diagonals elements)
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        integer                              :: di, dj    ! index change due to calculation direction
        real                                 :: dt        ! time step
        real                                 :: az        ! cell face area in Z direction
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KLB, KUB !bounds
        ! integer                              :: CHUNK

        !External_Var - Grid
        integer, dimension (:,:  ), pointer  :: KFloorZ   ! bottom layer
        real,    dimension (:,:  ), pointer  :: DUX, DVY, DZX_ZY, DZX, DZY
        real,    dimension (:,:,:), pointer  :: SZZ, DWZ

        !External_Var - Mapping
        integer, dimension (:,:,:), pointer  :: OpenPoints3D

        !Fluxes
        !Velocity
        real,    dimension (:,:,:), pointer  :: UV_New, U_New, V_New
        !Water level
        real,    dimension (:,:  ), pointer  :: WaterLevel_New
        !Aux Variables
        integer                              :: kbottom, OpL, OpU, Op1, Op2, Op3, Op4
        real(8)                              :: DWZt, Uface, Uup, Vface, Vup, FL, FU, Ulow, Vlow
        real(8)                              :: dzdx1, dzdx2, dzdx, dzdy1, dzdy2, dzdy, azdt
        real(8)                              :: n1, n2, n3

        !Begin----------------------------------------------------------------------

        !----Shorten variables names
        w => Me%NonHydroStatic%CCoef
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        e => Me%NonHydroStatic%GCoef
        q => Me%Coef%D3%TI
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB
        dt = Me%WaterLevel%DT

        !External_Var - Grid
        KFloorZ             => Me%External_Var%KFloor_Z
        DUX                 => Me%External_Var%DUX
        DVY                 => Me%External_Var%DVY
        DZX_ZY              => Me%External_Var%DZX_ZY
        DZX                 => Me%External_Var%DZX
        DZY                 => Me%External_Var%DZY
        SZZ                 => Me%External_Var%SZZ
        DWZ                 => Me%External_Var%DWZ

        !External_Var - Mapping
        OpenPoints3D        => Me%External_Var%OpenPoints3D

        UV_New              => Me%Velocity%Horizontal%UV%New
        U_New               => Me%Velocity%Horizontal%U%New
        V_New               => Me%Velocity%Horizontal%V%New

        !Water level
        WaterLevel_New      => Me%WaterLevel%New
        !non-hydrostatic
        !Numerics
        di = Me%Direction%di
        dj = Me%Direction%dj



        !----Calculate matrix coefficient and independent term of the system
        do i = ILB, IUB
        do j = JLB, JUB
        !--------Calculate z-area of cell

            az      = DUX(i,j) * DVY(i,j)
            Kbottom = KFloorZ(i, j)

            azdt    = az * dt

            do k = KLB-1, KUB
                if (OpenPoints3D(i, j, k) == OpenPoint .or. OpenPoints3D(i, j, k+1) == OpenPoint) then !cell must not be calculated

                    !dzdx
                    if (OpenPoints3D(i,j-1,k) == 1 .or. OpenPoints3D(i,j-1,k+1)==1) then
                        Op1 = 1
                    else
                        Op1 = 0
                    endif
                    if (OpenPoints3D(i,j+1,k) == 1 .or. OpenPoints3D(i,j+1,k+1)==1) then
                        Op2 = 1
                    else
                        Op2 = 0
                    endif


                    if ((Op1+Op2)>0) then
                        !if (k==KUB) then
                        !    n1 = WaterLevel_New(i,j-1)
                        !    n2 = WaterLevel_New(i,j  )
                        !    n3 = WaterLevel_New(i,j+1)
                        !else
                            n1 = - SZZ(i,j-1,k)
                            n2 = - SZZ(i,j  ,k)
                            n3 = - SZZ(i,j+1,k)
                        !endif

                        dzdx1 = (n2 - n1)/DZX(i,j-1)
                        dzdx2 = (n3 - n2)/DZX(i,j  )
                        dzdx  = (dzdx1*Op1 + dzdx2*Op2)/(Op1+Op2)
                    else
                        dzdx1 = 0.
                        dzdx2 = 0.
                        dzdx  = 0.
                    endif

                    !dzdy
                    if (OpenPoints3D(i-1,j,k) == 1 .or. OpenPoints3D(i-1,j,k+1)==1) then
                        Op3 = 1
                    else
                        Op3 = 0
                    endif
                    if (OpenPoints3D(i+1,j,k) == 1 .or. OpenPoints3D(i+1,j,k+1)==1) then
                        Op4 = 1
                    else
                        Op4 = 0

                    endif

                    if ((Op3+Op4)>0) then
                        if (k==KUB) then
                            n1 = WaterLevel_New(i-1,j)
                            n2 = WaterLevel_New(i,  j)
                            n3 = WaterLevel_New(i+1,j)
                        else
                            n1 = - SZZ(i-1,j,k)
                            n2 = - SZZ(i  ,j,k)
                            n3 = - SZZ(i+1,j,k)
                        endif

                        dzdy1   = (n2 - n1)/DZY(i-1,j)
                        dzdy2   = (n3 - n2)/DZY(i  ,j)
                        dzdy    = (dzdy1*Op3 + dzdy2*Op4)/(Op3+Op4)

                    else
                        dzdy1   = 0.
                        dzdy2   = 0.
                        dzdy    = 0.
                    endif

                    !u* and v* discretization
                    Uup     = (U_new(i,j,k+1) + U_new(i,j+1,k+1)) / 2.
                    ULow    = (U_new(i,j,k  ) + U_new(i,j+1,k  )) / 2.
                    Vup     = (V_new(i,j,k+1) + V_new(i+1,j,k+1)) / 2.
                    VLow    = (V_new(i,j,k  ) + V_new(i+1,j,k  )) / 2.

                    OpU     = OpenPoints3D(i,j,k+1)
                    OpL     = OpenPoints3D(i,j,k  )

                    If (OpU == 1 .and. OpL == 1) then
                        DWZt    = (DWZ(i,j,k+1)+ DWZ(i,j,k))
                        Uface   = (DWZ(i,j,k+1)*ULow+ DWZ(i,j,k)*Uup)/DWZt
                        Vface   = (DWZ(i,j,k+1)*VLow+ DWZ(i,j,k)*Vup)/DWZt
                        FL      = 2 * DWZ(i,j,k+1) / DWZt
                        FU      = 2 * DWZ(i,j,k  ) / DWZt
                    else if (OpU==1) then
                        !Surface
                        Uface = Uup; Vface = Vup; FL = 0; FU = 1;
                    else if (OpL==1) then
                        !bottom
                        Uface = Ulow; Vface = Vlow; FL = 1; FU = 0;
                    endif

                    !U explicit contribution to FluxZ
                    ![m3/s]    = [m3/s] + [m^2] * [m/s] * [ ]
                    q(i,j,k+1) = q(i,j,k+1) + az * (Uface*dzdx) * FU
                    q(i,j,k  ) = q(i,j,k  ) - az * (Uface*dzdx) * FL

                    !V explicit contribution to FluxZ
                    ![m3/s]    = [m3/s] + [m^2] * [m/s] * [ ]
                    q(i,j,k+1) = q(i,j,k+1) + az * (Vface*dzdy) * FU
                    q(i,j,k  ) = q(i,j,k  ) - az * (Vface*dzdy) * FL

                endif
            enddo ! do k
            enddo ! do j
        enddo ! do i

!        if (KUB == 1) then
!            if (dj == 1) then
!                dzdxy1 = dzdx1
!                dzdxy2 = dzdx2
!                dzdxy  = dzdx
!            else
!                dzdxy1 = dzdy1
!                dzdxy2 = dzdy2
!                dzdxy  = dzdy
!            endif

!                    if (k==KUB) then
!                        if (OpenPoints3D(i-di,j-dj,k) == 1) then
!                            s(i,j,KUB)     = s(i,j,KUB)     -  azdt * dzdxy1 / DZX_ZY(i-di,j-dj) / 2.
!                            p(i,j,KUB)     = p(i,j,KUB)     +  azdt * dzdxy1 / DZX_ZY(i-di,j-dj) / 2.
!                        endif
!                        if (OpenPoints3D(i+di,j+dj,k) == 1) then
!                            p(i,j,KUB)     = p(i,j,KUB)     -  azdt * dzdxy2 / DZX_ZY(i,j) / 2.
!                            n(i,j,KUB)     = n(i,j,KUB)     +  azdt * dzdxy2 / DZX_ZY(i,j) / 2.
!                        endif
!                    endif

!                    if (k == kbottom-1) then
!                        if (OpenPoints3D(i-di,j-dj,kbottom) == 1) then
!                           ![
                            !s(i,j,kbottom) = s(i,j,kbottom) +  azdt * dzdxy1 / DZX_ZY(i-di,j-dj) / 2.
                            !p(i,j,kbottom) = p(i,j,kbottom) -  azdt * dzdxy1 / DZX_ZY(i-di,j-dj) / 2.
!                            p(i,j,kbottom) = p(i,j,kbottom) - azdt * dzdxy / Watercolumn_Z(i,j) /
!                        endif
!                        if (OpenPoints3D(i+di,j+dj,kbottom) == 1) then
!                            p(i,j,kbottom) = p(i,j,kbottom) +  azdt * dzdxy2 / DZX_ZY(i,j) / 2.
!                            n(i,j,kbottom) = n(i,j,kbottom) -  azdt * dzdxy2 / DZX_ZY(i,j) / 2.
!                        endif
!                    endif



        nullify (s, p, n, q,w,e)

        !External_Var - Grid
        nullify (DUX, DVY, DZX_ZY, DZX, DZY, KFloorZ, SZZ, DWZ)

        !External_Var - Mapping
        nullify (OpenPoints3D)

        !Velocity
        nullify (UV_New, U_New, V_New)
        !Water level
        nullify (WaterLevel_New)

    End Subroutine SZZGradients

!End------------------------------------------------------------


    Subroutine THOMAS_2D_NonHydroCorrection(p, s, n, q, pc)
        !Arguments------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: s ,n      ! coefficient matrix (non-diagonals elements)
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        real,    dimension (:,:,:), pointer  :: pc        ! result

        !Local----------------------------------------------------------------------
        real,    dimension (:,:),   pointer  :: s2D ,n2D  ! coefficient matrix (non-diagonals elements)
        real(8), dimension (:,:),   pointer  :: p2D       ! coefficient matrix (diagonal elements)
        real,    dimension (:,:),   pointer  :: q2D       ! independdent term
        real,    dimension (:,:),   pointer  :: pc2D      ! result

        integer                              :: di, dj    ! index change due to calculation direction
        integer                              :: ILB, IUB, JLB, JUB !bounds
        integer                              :: IJmin, IJmax, JImin, JImax
        integer                              :: STAT_CALL

        !Begin----------------------------------------------------------------------

        !----Shorten variables names

        allocate(s2D (Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB),                 &
                 n2D (Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB),                 &
                 pc2D(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB),                 &
                 p2D (Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB),                 &
                 q2D (Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB

        di = Me%Direction%di
        dj = Me%Direction%dj

        s2D (:,:) = s (:,:,1)
        p2D (:,:) = p (:,:,1)
        n2D (:,:) = n (:,:,1)
        q2D (:,:) = q (:,:,1)


if1:    if (Me%DDecomp%MasterOrSlave) then

#ifdef _USE_MPI

            call THOMAS_DDecompHorizGrid(HorizontalGridID    = Me%ObjHorizontalGrid,    &
                                         DCoef_2D            = s2D,                     &
                                         FCoef_2D            = n2D,                     &
                                         TiCoef_2D           = q2D,                     &
                                         ECoef_2D            = p2D,                     &
                                         Results_2D          = pc2D,                    &
                                         di                  = Me%Direction%di,         &
                                         dj                  = Me%Direction%dj,         &
                                         STAT                = STAT_CALL)

#else

            STAT_CALL = SUCCESS_

#endif _USE_MPI

            if (STAT_CALL /= SUCCESS_) then
                stop 'THOMAS_2D_NonHydroCorrection - ModuleHydrodynamic - ERR10'
            endif

        else if1


            IJmin = ILB * dj + JLB * di
            IJmax = IUB * dj + JUB * di

            JImin = ILB * di + JLB * dj
            JImax = IUB * di + JUB * dj

            call THOMAS_2D(IJmin, IJmax, JImin, JImax, di, dj, s2D, p2D,                &
                           n2D, q2D, pc2D, Me%VECG_2D, Me%VECW_2D)

        endif if1

        pc(:,:,1) = pc2D(:,:)

        deallocate(s2D, p2D, n2D, q2D, pc2D)

    End Subroutine THOMAS_2D_NonHydroCorrection

     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! NonHydroOpenBoundary (null gradient)
    !
    ! ----------------------------
    !
    ! author : Hernani Theias
    ! last modified  : 06/2004
    ! e-mail : hernanitheias@netcabo.pt                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroOpenBoundary(InTime)
        !Arguments------------------------------------------------------------------
        integer, intent(IN)                  :: InTime
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q, pc     ! independdent term
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KUB ! bounds
        ! integer                              :: CHUNK

        !Begin----------------------------------------------------------------------
        !----Shorten variables names
        s   => Me%Coef%D3%D
        p   => Me%Coef%D3%E
        n   => Me%Coef%D3%F
        q   => Me%Coef%D3%TI
        w   => Me%NonHydroStatic%CCoef
        e   => Me%NonHydroStatic%GCoef
        pc  => Me%NonHydroStatic%PrevisionalQ

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB


        !Null gradient
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroOpenBoundary")

        ! !! $OMP PARALLEL PRIVATE(i,j,k)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        do i = ILB, IUB
        do j = JLB, JUB
            !Y boundary faces
!Y1:         if (Me%External_Var%BoundaryFacesV(i, j) == Boundary) then

Y1:         if  (Me%External_Var%BoundaryFacesV  (i, j     )  == Boundary     .and.                     &
                 Me%External_Var%ComputeFaces3D_V(i, j, KUB)  == Covered      .and.                     &
                (Me%External_Var%BoundaryPoints  (i,  j)      == Not_Boundary .or.                      &
                 Me%External_Var%BoundaryPoints  (i-1,j)      == Not_Boundary)) then

                ! !! $OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_V(i, j), KUB)
                ! !! $OMP END MASTER
                ! !! $OMP BARRIER

                ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_V(i, j), KUB

                    if      (Me%External_Var%BoundaryPoints(i-1, j) == Boundary) then

                        if ((Me%External_Var%ComputeFaces3D_U(i-1, j  , KUB)  == Covered    .or.    &
                             Me%External_Var%ComputeFaces3D_U(i-1, j+1, KUB)  == Covered)   .and.   &
                             Me%Direction%XY == DirectionX_) then
                             cycle
                        endif

                        if (InTime == Implicit_) then

                            if      (Me%Direction%XY == DirectionY_) then
                                e(i-1, j, k) =  0.
                                w(i-1, j, k) =  0.
                                p(i-1, j, k) =  1.
                                s(i-1, j, k) =  0.
                                n(i-1, j, k) = -1.
                                q(i-1, j, k) =  0.
                            elseif  (Me%Direction%XY == DirectionX_) then

                                e(i-1, j, k) = 0.
                                w(i-1, j, k) = 0.
                                p(i-1, j, k) = 1.
                                s(i-1, j, k) = 0.
                                n(i-1, j, k) = 0.
                                q(i-1, j, k) = pc(i-1, j, k)
                            endif

                        elseif (InTime == Explicit_) then

                            if  (Me%Direction%XY == DirectionX_) then
                                pc(i-1, j, k) = pc(i, j, k)
                            endif

                        endif

                    else if (Me%External_Var%BoundaryPoints(i, j) == Boundary) then


                        if ((Me%External_Var%ComputeFaces3D_U(i  , j  , KUB)  == Covered    .or.    &
                             Me%External_Var%ComputeFaces3D_U(i  , j+1, KUB)  == Covered)   .and.   &
                             Me%Direction%XY == DirectionX_) then
                             cycle
                        endif

                        if (InTime == Implicit_) then

                            if      (Me%Direction%XY == DirectionY_) then
                                e(i, j, k) =  0.
                                w(i, j, k) =  0.
                                p(i, j, k) =  1.
                                s(i, j, k) = -1.
                                n(i, j, k) =  0.
                                q(i, j, k) =  0.
                            elseif  (Me%Direction%XY == DirectionX_) then

                                e(i, j, k) = 0.
                                w(i, j, k) = 0.
                                p(i, j, k) = 1
                                s(i, j, k) = 0.
                                n(i, j, k) = 0.
                                q(i, j, k) = pc(i, j, k)
                            endif

                        elseif (InTime == Explicit_) then

                            if  (Me%Direction%XY == DirectionX_) then
                                pc(i, j, k) = pc(i-1, j, k)
                            endif

                        endif

                    endif

                enddo ! do k
                ! !! $OMP END DO
            endif Y1

            !X boundary faces
!X1:         if (Me%External_Var%BoundaryFacesU(i, j) == Boundary) then

X1:         if  (Me%External_Var%BoundaryFacesU  (i, j     )  == Boundary     .and.                     &
                 Me%External_Var%ComputeFaces3D_U(i, j, KUB)  == Covered      .and.                     &
                (Me%External_Var%BoundaryPoints  (i,  j  )    == Not_Boundary .or.                      &
                 Me%External_Var%BoundaryPoints  (i,  j-1)    == Not_Boundary)) then


                ! !! $OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_U(i, j), KUB)
                ! !! $OMP END MASTER
                ! !! $OMP BARRIER

                ! !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_U(i, j), KUB

                    if      (Me%External_Var%BoundaryPoints(i, j - 1) == Boundary) then

                        if ((Me%External_Var%ComputeFaces3D_V(i  , j-1, KUB)  == Covered    .or.    &
                             Me%External_Var%ComputeFaces3D_V(i+1, j-1, KUB)  == Covered)   .and.   &
                             Me%Direction%XY == DirectionY_) then
                             cycle
                        endif

                        if (InTime == Implicit_) then

                            if      (Me%Direction%XY == DirectionX_) then
                                e(i, j-1, k) =  0.
                                w(i, j-1, k) =  0.
                                p(i, j-1, k) =  1.
                                s(i, j-1, k) =  0.
                                n(i, j-1, k) = -1.
                                q(i, j-1, k) =  0.
                            elseif  (Me%Direction%XY == DirectionY_) then

                                e(i, j-1, k) = 0.
                                w(i, j-1, k) = 0.
                                p(i, j-1, k) = 1.
                                s(i, j-1, k) = 0.
                                n(i, j-1, k) = 0.
                                q(i, j-1, k) = pc(i, j-1, k)
                            endif

                        elseif (InTime == Explicit_) then

                            if  (Me%Direction%XY == DirectionY_) then
                                pc(i, j-1, k) = pc(i, j, k)
                            endif

                        endif

                    else if (Me%External_Var%BoundaryPoints(i, j) == Boundary) then


                        if ((Me%External_Var%ComputeFaces3D_V(i  , j  , KUB)  == Covered    .or.    &
                             Me%External_Var%ComputeFaces3D_V(i+1, j  , KUB)  == Covered)   .and.   &
                             Me%Direction%XY == DirectionY_) then
                             cycle
                        endif

                        if (InTime == Implicit_) then

                            if      (Me%Direction%XY == DirectionX_) then
                                e(i, j, k) =  0.
                                w(i, j, k) =  0.
                                p(i, j, k) =  1.
                                s(i, j, k) = -1.
                                n(i, j, k) =  0.
                                q(i, j, k) =  0.
                            elseif  (Me%Direction%XY == DirectionY_) then
                                e(i, j, k) = 0.
                                w(i, j, k) = 0.
                                p(i, j, k) = 1.
                                s(i, j, k) = 0.
                                n(i, j, k) = 0.
                                q(i, j, k) = pc(i, j, k)
                            endif

                        elseif (InTime == Explicit_) then

                            if  (Me%Direction%XY == DirectionY_) then
                                pc(i, j, k) = pc(i, j-1, k)
                            endif

                        endif

                    endif

                enddo ! do k
                ! !! $OMP END DO

            endif X1
        enddo ! do j
        enddo ! do i
        ! !! $OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroOpenBoundary")

        nullify(p)
        nullify(q)
        nullify(e)
        nullify(w)
        nullify(s)
        nullify(n)
        nullify(pc)
    end subroutine NonHydroOpenBoundary
    !End------------------------------------------------------------
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! NonHydroDischarges ()
    !
    ! ----------------------------
    !
    ! author : Paulo Leitao
    ! last modified  : 04/2012
    ! e-mail : paulo.chambel@hidromod.com
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine NonHydroDischarges()
        !Local----------------------------------------------------------------------
        real,    dimension (:,:,:), pointer  :: e,w,s,n   ! coefficient matrix (non-diagonals elements)
        real,    dimension (:,:,:), pointer  :: pc        ! previsional pressure correction
        real(8), dimension (:,:,:), pointer  :: p         ! coefficient matrix (diagonal elements)
        real,    dimension (:,:,:), pointer  :: q         ! independdent term
        integer                              :: i, j, k   ! counters
        integer                              :: ILB, IUB, JLB, JUB, KUB ! bounds
        ! integer                              :: CHUNK

        !Begin----------------------------------------------------------------------
        !----Shorten variables names
        s => Me%Coef%D3%D
        p => Me%Coef%D3%E
        n => Me%Coef%D3%F
        q => Me%Coef%D3%TI
        w => Me%NonHydroStatic%CCoef
        e => Me%NonHydroStatic%GCoef
        pc => Me%NonHydroStatic%PrevisionalQ

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "NonHydroWallBoundary")

        ! !!$OMP PARALLEL PRIVATE(i,j,k,nb)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        !-------------Discharges

        do i = ILB, IUB
        do j = JLB, JUB
            !check all open points
X1:         if (Me%External_Var%OpenPoints3D(i, j,KUB) == OpenPoint) then

                ! !!$OMP MASTER
                ! CHUNK = CHUNK_K(Me%External_Var%KFloor_V(i, j), KUB)
                ! !!$OMP END MASTER
                ! !!$OMP BARRIER

                ! !!$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = Me%External_Var%KFloor_Z(i, j), KUB

                    q(i, j, k) = q(i, j, k) + Me%WaterFluxes%Discharges(i, j, k)

                    !if the flow is positive and the discharge velocity was defined the pressure correction is imposed
!                    if (Me%WaterFluxes%Discharges(i, j, k) > 0. .and. Me%ComputeOptions%MomentumDischarge) then

!                        q(i, j, k) = 0.5* (Me%WaterFluxes%DischargesVelU(i, j, k)**2 + Me%WaterFluxes%DischargesVelV(i, j, k)**2)

!                        e(i, j, k) =  0.
!                        w(i, j, k) =  0.
!                        p(i, j, k) =  1.
!                        s(i, j, k) =  0.
!                        n(i, j, k) =  0.

!                    endif

                enddo ! do k
                ! !!$OMP END DO

            endif X1
        enddo ! do j
        enddo ! do i
        ! !!$OMP END PARALLEL

        !if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "NonHydroDischarges")

        nullify(p)
        nullify(pc)
        nullify(q)
        nullify(e)
        nullify(w)
        nullify(s)
        nullify(n)
    end subroutine NonHydroDischarges
    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !
    ! ComputeCartesianNH
    !
    ! ----------------------------
    !
    ! This routine calculates the vertical velocity based divergence equation :
    ! div(V) = 0
    ! The vertical velocity is given by the flux balance at each cell and assuming
    ! that at bottom w = 0, so we can calculate w from bottom to top.
    ! This routine is only used in non-hydrostatic calculations, to match the numerical
    ! scheme followed.
    !
    ! ----------------------------
    !
    ! author : Hernani Theias
    ! last modified  : 06/2004
    ! e-mail : hernanitheias@netcabo.pt
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ComputeCartesianNH
        !Local----------------------------------------------------------------------
        integer                              :: i, j, k   ! counters
        integer                              :: kbottom   ! cell index at bottom
        real(8)                              :: az        ! cell horizontal area
        real(8)                              :: df        ! horizontal flux balance
        real(8)                              :: db        ! velocity of the lower cell
        real(8)                              :: discharge ! discharge flux
        integer                              :: kub       ! upper cell index
        ! integer                              :: CHUNK

        !Begin----------------------------------------------------------------------

        ! CHUNK = CHUNK_I(Me%WorkSize%ILB, Me%WorkSize%IUB)
        !ACanas(2010): Parallelization for the non hydrostatic case wasn't tested
        !ACanas(2010): because a working configuration was not provided.

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeCartesianNH")

        ! !! $OMP PARALLEL PRIVATE(i,j,k,kbottom,kub,az,df,discharge)
        ! !! $OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            if(Me%External_Var%OpenPoints3d(i,j, Me%WorkSize%KUB) == OpenPoint) then
                kbottom = Me%External_Var%KFloor_Z(i,j)
                if((Me%ComputeOptions%Compute_Tide).and. &
                   (Me%External_Var%BoundaryPoints(i, j)==Boundary)) then
                    kub = Me%WorkSize%KUB
                else
                    kub = Me%WorkSize%KUB + 1
                endif
                Me%Velocity%Vertical%Cartesian(i,j,kbottom) = 0.
                az = Me%External_Var%DUX(i,j) * Me%External_Var%DVY(i,j)
                do k = kbottom + 1, kub
                    discharge = 0.
                    if(Me%ComputeOptions%WaterDischarges) &
                        discharge = Me%WaterFluxes%Discharges(i, j, k-1)
                    df =   Me%WaterFluxes%X(i    , j    , k - 1)                        &
                         - Me%WaterFluxes%X(i    , j + 1, k - 1)                        &
                         + Me%WaterFluxes%Y(i    , j    , k - 1)                        &
                         - Me%WaterFluxes%Y(i + 1, j    , k - 1)                        &
                         + discharge
                    !dw = Me%Velocity%Vertical%CartesianOld(i,j,k-1) - Me%Velocity%Vertical%CartesianOld(i,j,k)
                    db = Me%Velocity%Vertical%Cartesian   (i,j,k - 1)
                    Me%Velocity%Vertical%Cartesian(i,j,k) =  db + df / az
                enddo
            endif
        enddo
        enddo
        ! !! $OMP END DO
        ! !! $OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeCartesianNH")

        !null gradient in the open boundary.
        call NullGradProp3D_W(Me%Velocity%Vertical%Cartesian)

        if (Me%CyclicBoundary%ON) then !in case of cyclic boundary
            call CyclicBoundVertical (Vector = Me%Velocity%Vertical%Cartesian)
        endif

    End Subroutine ComputeCartesianNH
    !End------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadHydrodynamicFile


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: WaterLevel
        real(8), dimension(:,:,:), pointer :: WaterFluxX, WaterFluxY, Discharges
        integer, dimension(:,:,:), pointer :: ComputeFaces3DU, ComputeFaces3DV

        integer :: STAT_CALL


        !Begin----------------------------------------------------------------------


        !Reads new Instant
        call ModifyHydrodynamicFile(Me%ObjHydrodynamicFileIn, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR01'


        !Gets actual WaterLevel
        call GetFileWaterLevel(Me%ObjHydrodynamicFileIn, WaterLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR02'


        !Actualizes Hydrodynamic
        Me%WaterLevel%New = WaterLevel


        !With the new WaterLevel, recalculate Geometry
        !Notice: This wont work if the coordinate is of the type Lagrangian
        call New_Geometry


        !Gets Horizontal Fluxes from file
        call GetFileFluxes(Me%ObjHydrodynamicFileIn,                        &
                           WaterFluxX = WaterFluxX,                                      &
                           WaterFluxY = WaterFluxY,                                      &
                           Discharges = Discharges,                                      &
                           STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR03'

        call SetMatrixValue(Me%WaterFluxes%X,          Me%Size, WaterFluxX)
        call SetMatrixValue(Me%WaterFluxes%Y,          Me%Size, WaterFluxY)
        call SetMatrixValue(Me%WaterFluxes%Discharges, Me%Size, Discharges)

        !Calculates horizontal velocities, given the fluxes
        call Compute_VelocityFromFluxes


        !Gets the Mapping from the file
        call GetFileMapping(Me%ObjHydrodynamicFileIn,                       &
                            ComputeFaces3DU,                                             &
                            ComputeFaces3DV,                                             &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR04'


        !Modifies Mapping, acording to the one in the file
        call ReadUnLock_ModuleMap
        call SetComputesFaces3D(Me%ObjMap,                                  &
                                ComputeFaces3DU,                                         &
                                ComputeFaces3DV,                                         &
                                Me%CurrentTime,                             &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR05'
        call ReadLock_ModuleMap


        !Calculates the vertical hydrodynamic
        call New_VerticalHydrodynamic( Grid = Variable)

        !WaterLevel
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    WaterLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR06'


        !WaterFluxX
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    WaterFluxX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR07'

        !WaterFluxY
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    WaterFluxY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR08'

        !Discharges
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    Discharges, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR09'

        !ComputeFaces3DU
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    ComputeFaces3DU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR10'

        !ComputeFaces3DV
        call UnGetHydrodynamicFile (Me%ObjHydrodynamicFileIn,               &
                                    ComputeFaces3DU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'ReadHydrodynamicFile - ModuleHydrodynamic - ERR11'


    end subroutine ReadHydrodynamicFile

    !End----------------------------------------------------------------------


    subroutine New_Geometry

        !Arguments------------------------------------------------------------

        !Local----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: WaterPoints3D, OpenPoints3D
        real,    dimension(:,:  ), pointer  :: SurfaceElevation
        real,    dimension(:,:,:), pointer  :: Velocity_Z, DecayTime
        real                                :: DT_WaterLevel
        real                                :: ColdPeriod, ColdOrder, DT_RunPeriod, CoefCold
        integer                             :: i, j, k, kbottom, STAT_CALL
        integer                             :: CHUNK

        !Begin----------------------------------------------------------------

        WaterPoints3D    => Me%External_Var%WaterPoints3D

        OpenPoints3D       => Me%External_Var%OpenPoints3D

        SurfaceElevation => Me%WaterLevel%New

        Velocity_Z       => Me%Velocity%Vertical%Across

        DT_WaterLevel    =  Me%WaterLevel%DT

        if (Me%Relaxation%Geometry) then

            call GetAssimilationCoef (Me%ObjAssimilation,                               &
                                      ID              = VerticalZ_,                     &
                                      CoefField3D     = DecayTime,                      &
                                      ColdRelaxPeriod = ColdPeriod,                     &
                                      ColdOrder       = ColdOrder,                      &
                                      STAT            = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                 stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR10'


            DT_RunPeriod = Me%CurrentTime - Me%BeginTime

            if (ColdPeriod > (Me%EndTime - Me%BeginTime))                               &
                stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR20'

            if (ColdPeriod > 0. .and. Me%ComputeOptions%Continuous) then
                write(*,*) 'ColdRelaxPeriod is ON in a HOT START '
                write(*,*) 'Remove from Assimilation_x.dat the keyword COLD_RELAX_PERIOD'
                stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR30'
            endif

cd4:        if (ColdPeriod <= DT_RunPeriod) then
                CoefCold = 1
            else  cd4
                CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
                if (CoefCold < 1.e-32) CoefCold = 1.e-32
            endif cd4

            CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "New_Geometry")
            endif

            !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            kbottom = Me%External_Var%KFloor_Z(i, j)

                if (WaterPoints3D(i, j, Me%WorkSize%KUB) == WaterPoint) then
                    do k = kbottom, Me%WorkSize%KUB
                        Me%Relaxation%DecayTimeGeo(i, j, k) = CoefCold * DecayTime(i, j, k)
                    enddo
                endif

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "New_Geometry")
            endif

        endif



        !call ReadUnLock_ModuleHorizontalGrid


        !call ReadUnLock_ModuleHorizontalMap


        !call ReadUnLock_ModuleGeometry


        call ReadUnLock_External_Modules

        if (Me%Relaxation%Geometry) then

            !Compute new volume
            call ComputeVerticalGeometry(Me%ObjGeometry, WaterPoints3D,                     &
                                         SurfaceElevation, Me%CurrentTime,                  &
                                         Velocity_Z, DT_WaterLevel,                         &
                                         DecayTime = DecayTime, OpenPoints3D = OpenPoints3D,   &
                                         STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                      &
                 stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR30'
        else

            call ComputeVerticalGeometry(Me%ObjGeometry, WaterPoints3D,                     &
                                         SurfaceElevation, Me%CurrentTime,                  &
                                         Velocity_Z, DT_WaterLevel,                         &
                                         OpenPoints3D = OpenPoints3D, stat = stat_call)

            if (STAT_CALL /= SUCCESS_)                                                      &
                 stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR40'

        endif

        !Nullify auxliar pointers
        nullify(SurfaceElevation, WaterPoints3D, Velocity_Z)


!        call ReadUnLock_ModuleMap


        !Update the moving boundary  (boundary of the tidal areas covered)
!        call UpdateComputeFaces3D(Me%ObjMap, &
!             Me%CurrentTime, STAT = STAT_CALL)

!        if (STAT_CALL /= SUCCESS_)                                           &
!            stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR02.'


        call ReadLock_External_Modules

        if (Me%Relaxation%Geometry) then

            call UnGetAssimilation   (Me%ObjAssimilation,                               &
                                      DecayTime,                                        &
                                      STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine New_Geometry - ModuleHydrodynamic. ERR50'


        endif




    end subroutine New_Geometry

    !End----------------------------------------------------------------------

    subroutine New_VerticalHydrodynamic( Grid)

        !Arguments------------------------------------------------------------

        integer                          :: Grid

        !Local----------------------------------------------------------------
        integer                          :: STAT_CALL
        !Begin----------------------------------------------------------------

        !Grid = Fix = 1
        !First prediction of the vertical fluxes and velocity for a fixed geometry
        !This is only important when one of the domains as vertical "Lagrangian" coordinate

        !Grid = Variable = 2
        !the vertical water flux is compute with the effect of variable volume
        if (Me%ComputeOptions%VerticalWaterFlowOpt) then   
            call Modify_VerticalWaterFlow (Grid) !Joao Sobrinho
        else
            call Modify_VerticalWaterFlow2 (Grid)
        endif

        call Filter_3D_Fluxes

        ! Modified by Matthias DELPEY - 24/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            ! Computation of the vertical stokes drift component at the bottom
            call Compute_BottomStokesVertVel

            ! Computation of the vertical stokes drift component at every depth
            call Compute_StokesCartVertVel

        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !Joao Sobrinho
        call Compute_VerticalVelocity

        if(Me%NonHydroStatic%ON) then
            call ComputeCartesianNH
           !null gradient in the open boundary.
            call NullGradProp3D_W(Me%WaterFluxes%Z)
        else
            if (Me%ComputeOptions%WaveForcing3D /= GLM) then
                if (Me%ComputeOptions%CartesianVertVelocityOpt)then
                    call ComputeCartesianVertVelocity(Grid = Grid) !Joao Sobrinho
                else
                    call ComputeCartesianVertVelocity_Waves(Grid = Grid)
                endif
                
            else
                call ComputeCartesianVertVelocity_Waves(Grid = Grid)
            endif

            call Boundary_VerticalFlow (Grid)
        endif

        if (Me%CyclicBoundary%ON) then

            call CyclicBoundVertical (VectorD = Me%WaterFluxes%Z)

        endif

        STAT_CALL = SUCCESS_

#if _USE_MPI
        if (Me%WorkSize%KUB > 1) then
            !if domain decomposition is On exchanges vertical velocity along the domains boundaries
            !call ReceiveSendVelocity3DMPI(Property3D = Me%Velocity%Vertical%Across)
            call ReceiveSendProperitiesMPI(HorizontalGridID = Me%ObjHorizontalGrid,     &
                                           Property3D       = Me%Velocity%Vertical%Across,   &
                                           KLB              = Me%WorkSize%KLB,          &
                                           KUB              = Me%WorkSize%KUB,          &
                                           STAT             = STAT_CALL)
        endif
#else

        STAT_CALL = SUCCESS_

#endif _USE_MPI

        if (STAT_CALL /= SUCCESS_) then
            stop 'New_VerticalHydrodynamic - ModuleHydrodynamic - ERR10'
        endif


    end subroutine New_VerticalHydrodynamic

    !End----------------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Leendertse_Scheme

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------

        !Begin----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Leendertse_Scheme")

        call MaintainDirection

        call Explicit_Forces

        call Compute_Velocity(PressureBackwardInTime = .true.)
        ! Water Flux must be consistent with the water level equation
        Me%WaterFluxes%New_Old = 0.

        call Modify_HorizontalWaterFlow


        !Same direction of the water level direction

        call ChangeDirection

        call Bottom_Boundary

        call Explicit_Forces

        call Compute_WaterLevel

        call Compute_Velocity(PressureBackwardInTime = .false.)

        ! Water Flux must be consistent with the water level equation
        Me%WaterFluxes%New_Old = 1.

        call Modify_HorizontalWaterFlow

!        !Modify the Background velocity if the boundary relaxation scheme is ON
!        if (Me%Relaxation%Velocity)                                  &
!            call ModifyBackgroundVelocity

        if (.not. Me%NonHydrostatic%ON) call NullifyAuxiliarPointers

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Leendertse_Scheme")

    End Subroutine Leendertse_Scheme

    !End------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Abbott_Scheme

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Abbott_Scheme")

        call ChangeDirection

        call Bottom_Boundary

        call Explicit_Forces

        call Compute_WaterLevel

        call Compute_Velocity(PressureBackwardInTime = .false.)

        ! Water Flux must be consistent with the water level equation
        Me%WaterFluxes%New_Old = 0.5

        call Modify_HorizontalWaterFlow


!        !Modify the Background velocity if the boundary relaxation scheme is ON
!        if (Me%Relaxation%Velocity)                                  &
!            call ModifyBackgroundVelocity

        if (.not. Me%NonHydrostatic%ON) call NullifyAuxiliarPointers


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Abbott_Scheme")


    End Subroutine Abbott_Scheme

    !End---------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (2006/1)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Implicit_1DScheme

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Implicit_1DScheme")

        call MaintainDirection

        call Bottom_Boundary

        call Explicit_Forces

        call Compute_WaterLevel

        call Compute_Velocity(PressureBackwardInTime = .false.)


        ! Water Flux must be consistent with the water level equation
        Me%WaterFluxes%New_Old = 1.

        call Modify_HorizontalWaterFlow

        if (.not. Me%NonHydrostatic%ON) call NullifyAuxiliarPointers


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Implicit_1DScheme")


    End Subroutine Implicit_1DScheme

    !End---------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  ChangeDirection

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        integer :: Previous_Direction

        !Begin----------------------------------------------------------------

        Previous_Direction = Me%Direction%XY

        if (Previous_Direction == DirectionX_) then

             call AssociateDirectionY

        else if (Previous_Direction == DirectionY_) then

             call AssociateDirectionX

        endif

        if(Me%ComputeOptions%LocalDensity) then
            call FaceDensityUpdate
        else
            call SetMatrixValue( Me%FaceDensity, Me%Size, SigmaDensityReference)
        endif

    End Subroutine  ChangeDirection

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  MaintainDirection

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        integer :: Previous_Direction

        !Begin----------------------------------------------------------------

        Previous_Direction = Me%Direction%XY

        if (Previous_Direction == DirectionX_) then

             call AssociateDirectionX

        else if (Previous_Direction == DirectionY_) then

             call AssociateDirectionY

        endif

        if(Me%ComputeOptions%LocalDensity) then
            call FaceDensityUpdate
        else
            call SetMatrixValue( Me%FaceDensity, Me%Size, SigmaDensityReference)
        endif

    End Subroutine  MaintainDirection

    !End------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  AssociateDirectionY

        !Arguments------------------------------------------------------------



        !Begin----------------------------------------------------------------
         nullify(Me%External_Var%ComputeFaces3D_UV)
         nullify(Me%External_Var%ComputeFaces3D_VU)
         Me%Direction%XY   =  DirectionY_
         Me%Direction%YX   =  DirectionX_
         Me%Direction%di   =  1
         Me%Direction%dj   =  0

         !Baroclinic
         Me%Forces%Rox3XY  => Me%Forces%Rox3Y

         !Flow
         Me%Velocity%Horizontal%UV%Old  => &
         Me%Velocity%Horizontal%V%Old

         Me%Velocity%Horizontal%UV%New  => &
         Me%Velocity%Horizontal%V%New


         Me%Velocity%Horizontal%VU%Old  => &
         Me%Velocity%Horizontal%U%Old

         Me%Velocity%Horizontal%VU%New  => &
         Me%Velocity%Horizontal%U%New

         if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then

             Me%VelBaroclinic%UV%Old  => &
             Me%VelBaroclinic%V%Old

             Me%VelBaroclinic%UV%New  => &
             Me%VelBaroclinic%V%New


             Me%VelBaroclinic%VU%Old  => &
             Me%VelBaroclinic%U%Old

             Me%VelBaroclinic%VU%New  => &
             Me%VelBaroclinic%U%New

             Me%VelBaroclinic%ImposedNormXY  => &
             Me%VelBaroclinic%ImposedNormY

             Me%VelBaroclinic%ImposedTangXY  => &
             Me%VelBaroclinic%ImposedTangY

             Me%VelBaroclinic%UV2D  => &
             Me%VelBaroclinic%V2D


         endif


         Me%WaterFluxes%XY              => &
         Me%WaterFluxes%Y

         Me%WaterFluxes%YX              => &
         Me%WaterFluxes%X

         if (Me%ComputeOptions%MomentumDischarge) then
            Me%WaterFluxes%DischargesVelUV => &
            Me%WaterFluxes%DischargesVelV
         endif

         !3D geometry
         Me%External_Var%Volume_UV => &
         Me%External_Var%Volume_V

         Me%External_Var%Area_UV   => &
         Me%External_Var%Area_V

         Me%External_Var%Area_VU   => &
         Me%External_Var%Area_U

         Me%External_Var%KFloor_UV => &
         Me%External_Var%KFloor_V

         Me%External_Var%KFloor_VU => &
         Me%External_Var%KFloor_U

         Me%External_Var%WaterColumnUV => &
         Me%External_Var%WaterColumnV

         Me%External_Var%WaterColumnVU => &
         Me%External_Var%WaterColumnU

         Me%External_Var%DUZ_VZ        => &
         Me%External_Var%DVZ

         !Horizontal grid
         Me%External_Var%DZX_ZY    => &
         Me%External_Var%DZY

         Me%External_Var%DZY_ZX    => &
         Me%External_Var%DZX

         Me%External_Var%DXX_YY    => &
         Me%External_Var%DYY

         Me%External_Var%DUX_VY    => &
         Me%External_Var%DVY

         Me%External_Var%DVY_UX    => &
         Me%External_Var%DUX

         Me%External_Var%DYY_XX    => &
         Me%External_Var%DXX

         !3D Mapping
         Me%External_Var%ComputeFaces3D_UV   => &
         Me%External_Var%ComputeFaces3D_V

         Me%External_Var%ComputeFaces3D_VU   => &
         Me%External_Var%ComputeFaces3D_U

         Me%External_Var%LandBoundaryFacesUV => &
         Me%External_Var%LandBoundaryFacesV

         Me%External_Var%LandBoundaryFacesVU => &
         Me%External_Var%LandBoundaryFacesU

!         Me%External_Var%UnCoveredFaces3D_UV   => &
!         Me%External_Var%UnCoveredFaces3D_V



         Me%External_Var%BoundaryFacesUV     => &
         Me%External_Var%BoundaryFacesV


         Me%External_Var%BoundaryFacesVU     => &
         Me%External_Var%BoundaryFacesU

         Me%External_Var%ImposedTangentialFacesUV  => &
         Me%External_Var%ImposedTangentialFacesV

         Me%External_Var%ImposedTangentialFacesVU  => &
         Me%External_Var%ImposedTangentialFacesU


         Me%External_Var%ImposedNormalFacesUV  => &
         Me%External_Var%ImposedNormalFacesV


         !Wind
         if (Me%ComputeOptions%Wind /= NoWind_) &
            Me%External_Var%TauWind_UV       => &
            Me%External_Var%TauWindV

         !if (Me%Relaxation%Velocity)         then

            !Me%Relaxation%ReferenceVelUV  => &
            !Me%Relaxation%ReferenceVelV

            !Me%Relaxation%BackgroundVelUV  => &
            !Me%Relaxation%BackgroundVelV

         !endif

        if (Me%SubModel%ON)   then

            Me%SubModel%UV_New   => Me%SubModel%V_New
            Me%SubModel%UV_Old   => Me%SubModel%V_Old
            Me%SubModel%DUVZ_Old => Me%SubModel%DVZ_Old
            Me%SubModel%qXY      => Me%SubModel%qY
            Me%SubModel%qYX      => Me%SubModel%qX

        endif


         !Waves
         if (Me%WaveStress%ON) then
            Me%External_Var%TauWaves_UV => Me%External_Var%TauWavesV
         endif

! Modified by Matthias DELPEY - 05/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 19/08/2011 - 24/08/2011 - 08/09/2011 - 25/10/2011 - 25/11/2011
        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then
            Me%External_Var%TauWaves_UV => Me%External_Var%TauWavesV
            Me%WaveRad3D%WaveExpRadUV   => Me%WaveRad3D%WaveExpRadV
        endif

        if (Me%ComputeOptions%WaveForcing3D == GLM) then
            ! Velocities
            Me%StokesVel%Horizontal%UV%Old => Me%StokesVel%Horizontal%V%Old
            Me%StokesVel%Horizontal%UV%New => Me%StokesVel%Horizontal%V%New

            Me%StokesVel%Horizontal%VU%Old => Me%StokesVel%Horizontal%U%Old
            Me%StokesVel%Horizontal%VU%New => Me%StokesVel%Horizontal%U%New

            ! Water fluxes
            Me%StokesWaterFluxes%XY        => Me%StokesWaterFluxes%Y
            Me%StokesWaterFluxes%YX        => Me%StokesWaterFluxes%X

            ! Surface QDM flux
            Me%External_Var%AtmToWaveMomentum_UV => Me%External_Var%AtmToWaveMomentumV
            Me%External_Var%WaveToOceanMomentum_UV => Me%External_Var%WaveToOceanMomentumV

            ! Forces output variables
            Me%Forces%Wave3DExplicit_FPressureAccelUV => Me%Forces%Wave3DExplicit_FPressureAccelV
            Me%Forces%Wave3DExplicit_FVortexAccelUV => Me%Forces%Wave3DExplicit_FVortexAccelV
            Me%Forces%Wave3DExplicit_FBreakingAccelUV => Me%Forces%Wave3DExplicit_FBreakingAccelV

         endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if( Me%Geostroph%ON)  then
            Me%Geostroph%UV  => Me%Geostroph%V
            Me%Geostroph%VU  => Me%Geostroph%U
        endif


    End Subroutine  AssociateDirectionY

    !End------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  AssociateDirectionX

        !Arguments------------------------------------------------------------




        !Begin----------------------------------------------------------------
         nullify(Me%External_Var%ComputeFaces3D_UV)
         nullify(Me%External_Var%ComputeFaces3D_VU)
         Me%Direction%XY   =  DirectionX_
         Me%Direction%YX   =  DirectionY_
         Me%Direction%di   =  0
         Me%Direction%dj   =  1

         !Baroclinic
         Me%Forces%Rox3XY  => Me%Forces%Rox3X

         !Flow
         Me%Velocity%Horizontal%UV%Old  => &
         Me%Velocity%Horizontal%U%Old

         Me%Velocity%Horizontal%UV%New  => &
         Me%Velocity%Horizontal%U%New


         Me%Velocity%Horizontal%VU%Old  => &
         Me%Velocity%Horizontal%V%Old

         Me%Velocity%Horizontal%VU%New  => &
         Me%Velocity%Horizontal%V%New

         if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then

             Me%VelBaroclinic%UV%Old  => &
             Me%VelBaroclinic%U%Old

             Me%VelBaroclinic%UV%New  => &
             Me%VelBaroclinic%U%New


             Me%VelBaroclinic%VU%Old  => &
             Me%VelBaroclinic%V%Old

             Me%VelBaroclinic%VU%New  => &
             Me%VelBaroclinic%V%New


             Me%VelBaroclinic%ImposedNormXY  => &
             Me%VelBaroclinic%ImposedNormX

             Me%VelBaroclinic%ImposedTangXY  => &
             Me%VelBaroclinic%ImposedTangX

             Me%VelBaroclinic%UV2D  => &
             Me%VelBaroclinic%U2D


         endif

         Me%WaterFluxes%XY              => &
         Me%WaterFluxes%X

         Me%WaterFluxes%YX              => &
         Me%WaterFluxes%Y

         if (Me%ComputeOptions%MomentumDischarge) then
            Me%WaterFluxes%DischargesVelUV => &
            Me%WaterFluxes%DischargesVelU
         endif


         !3D Geometry
         Me%External_Var%Volume_UV => &
         Me%External_Var%Volume_U

         Me%External_Var%Area_UV   => &
         Me%External_Var%Area_U

         Me%External_Var%Area_VU   => &
         Me%External_Var%Area_V

         Me%External_Var%WaterColumnUV => &
         Me%External_Var%WaterColumnU

         Me%External_Var%WaterColumnVU => &
         Me%External_Var%WaterColumnV

         Me%External_Var%DUZ_VZ        => &
         Me%External_Var%DUZ


         Me%External_Var%KFloor_UV => &
         Me%External_Var%KFloor_U

         Me%External_Var%KFloor_VU => &
         Me%External_Var%KFloor_V

         !Horizontal Grid
         Me%External_Var%DZX_ZY    => &
         Me%External_Var%DZX

         Me%External_Var%DZY_ZX    => &
         Me%External_Var%DZY


         Me%External_Var%DXX_YY    => &
         Me%External_Var%DXX

         Me%External_Var%DUX_VY    => &
         Me%External_Var%DUX

         Me%External_Var%DVY_UX    => &
         Me%External_Var%DVY

         Me%External_Var%DYY_XX    => &
         Me%External_Var%DYY


         !3D Mapping
         Me%External_Var%ComputeFaces3D_UV   => &
         Me%External_Var%ComputeFaces3D_U

         Me%External_Var%ComputeFaces3D_VU   => &
         Me%External_Var%ComputeFaces3D_V

         Me%External_Var%LandBoundaryFacesUV => &
         Me%External_Var%LandBoundaryFacesU

         Me%External_Var%LandBoundaryFacesVU => &
         Me%External_Var%LandBoundaryFacesV

!         Me%External_Var%UnCoveredFaces3D_UV   => &
!         Me%External_Var%UnCoveredFaces3D_U

         !Horizontal Mapping

         Me%External_Var%BoundaryFacesUV     => &
         Me%External_Var%BoundaryFacesU

         Me%External_Var%BoundaryFacesVU     => &
         Me%External_Var%BoundaryFacesV


         Me%External_Var%ImposedTangentialFacesUV  => &
         Me%External_Var%ImposedTangentialFacesU

         Me%External_Var%ImposedTangentialFacesVU  => &
         Me%External_Var%ImposedTangentialFacesV

         Me%External_Var%ImposedNormalFacesUV      => &
         Me%External_Var%ImposedNormalFacesU


         !Wind
         if (Me%ComputeOptions%Wind /= NoWind_) &
            Me%External_Var%TauWind_UV       => &
            Me%External_Var%TauWindU


!         if (Me%Relaxation%Velocity)         then

!            Me%Relaxation%ReferenceVelUV  => &
!            Me%Relaxation%ReferenceVelU

!            Me%Relaxation%BackgroundVelUV  => &
!            Me%Relaxation%BackgroundVelU

!         endif

        if (Me%SubModel%ON)   then

            Me%SubModel%UV_New   => Me%SubModel%U_New
            Me%SubModel%UV_Old   => Me%SubModel%U_Old
            Me%SubModel%DUVZ_Old => Me%SubModel%DUZ_Old
            Me%SubModel%qXY      => Me%SubModel%qX
            Me%SubModel%qYX      => Me%SubModel%qY

        endif


        !Waves
        if (Me%WaveStress%ON) then
            Me%External_Var%TauWaves_UV => Me%External_Var%TauWavesU
        endif

! Modified by Matthias DELPEY - 05/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 19/08/2011 - 24/08/2011 - 08/09/2011 - 30/10/2011 - 25/11/2011
         if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then
            Me%External_Var%TauWaves_UV        => Me%External_Var%TauWavesU
            Me%WaveRad3D%WaveExpRadUV          => Me%WaveRad3D%WaveExpRadU
         endif

         if (Me%ComputeOptions%WaveForcing3D == GLM) then
            ! Velocities
            Me%StokesVel%Horizontal%UV%Old => Me%StokesVel%Horizontal%U%Old
            Me%StokesVel%Horizontal%UV%New => Me%StokesVel%Horizontal%U%New

            Me%StokesVel%Horizontal%VU%Old => Me%StokesVel%Horizontal%V%Old
            Me%StokesVel%Horizontal%VU%New => Me%StokesVel%Horizontal%V%New

            ! Water fluxes
            Me%StokesWaterFluxes%XY        => Me%StokesWaterFluxes%X
            Me%StokesWaterFluxes%YX        => Me%StokesWaterFluxes%Y

            ! Surface QDM flux
            Me%External_Var%AtmToWaveMomentum_UV => Me%External_Var%AtmToWaveMomentumU
            Me%External_Var%WaveToOceanMomentum_UV => Me%External_Var%WaveToOceanMomentumU

            ! Forces output variables
            Me%Forces%Wave3DExplicit_FPressureAccelUV => Me%Forces%Wave3DExplicit_FPressureAccelU
            Me%Forces%Wave3DExplicit_FVortexAccelUV => Me%Forces%Wave3DExplicit_FVortexAccelU
            Me%Forces%Wave3DExplicit_FBreakingAccelUV => Me%Forces%Wave3DExplicit_FBreakingAccelU

         endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if( Me%Geostroph%ON)  then
            Me%Geostroph%UV  => Me%Geostroph%U
            Me%Geostroph%VU  => Me%Geostroph%V
        endif

    End Subroutine  AssociateDirectionX

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Direction                                                                    !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine  NullifyAuxiliarPointers

        !Arguments------------------------------------------------------------




        !Begin----------------------------------------------------------------


         nullify(Me%Forces%Rox3XY)

         !Flow
         nullify(Me%Velocity%Horizontal%UV%Old)

         nullify(Me%Velocity%Horizontal%UV%New)

         nullify(Me%Velocity%Horizontal%VU%Old)

         nullify(Me%Velocity%Horizontal%VU%New)

         nullify(Me%WaterFluxes%XY)

         nullify(Me%WaterFluxes%YX)

         nullify(Me%WaterFluxes%DischargesVelUV)

         !3D Geometry
         nullify(Me%External_Var%Volume_UV)

         nullify(Me%External_Var%Area_UV)

         nullify(Me%External_Var%Area_VU)

         nullify(Me%External_Var%KFloor_UV)

         nullify(Me%External_Var%KFloor_VU)

         nullify(Me%External_Var%WaterColumnUV)

         nullify(Me%External_Var%WaterColumnVU)

         !Horizontal Grid
         nullify(Me%External_Var%DZX_ZY)

         nullify(Me%External_Var%DZY_ZX)

         nullify(Me%External_Var%DXX_YY)

         nullify(Me%External_Var%DUX_VY)

         nullify(Me%External_Var%DVY_UX)

         nullify(Me%External_Var%DYY_XX)


         !3D Mapping
         nullify(Me%External_Var%ComputeFaces3D_UV)

         nullify(Me%External_Var%ComputeFaces3D_VU)

         nullify(Me%External_Var%LandBoundaryFacesUV)

!         nullify(Me%External_Var%UnCoveredFaces3D_UV)

         !Horizontal Mapping

         nullify(Me%External_Var%BoundaryFacesUV)

         nullify(Me%External_Var%BoundaryFacesVU)

         !Wind
         if (Me%ComputeOptions%Wind /= NoWind_) &
            nullify(Me%External_Var%TauWind_UV)


         !Reference velocities
!         if (Me%Relaxation%Velocity)         then

!            nullify(Me%Relaxation%ReferenceVelUV)

!            nullify(Me%Relaxation%BackgroundVelUV)

!         endif


         !Waves
         if (Me%WaveStress%ON) then
            nullify(Me%External_Var%TauWaves_UV)
        endif

! Modified by Matthias DELPEY - 05/08/20111 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 08/09/20111 - 30/10/2011 - 25/11/2011

        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then
            nullify(Me%External_Var%TauWaves_UV)
            nullify(Me%WaveRad3D%WaveExpRadUV)
        endif

        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            ! Horizontal velocities
            nullify(Me%StokesVel%Horizontal%UV%New)
            nullify(Me%StokesVel%Horizontal%UV%Old)
            nullify(Me%StokesVel%Horizontal%VU%New)
            nullify(Me%StokesVel%Horizontal%VU%Old)

            ! Water fluxes
            nullify(Me%StokesWaterFluxes%XY)
            nullify(Me%StokesWaterFluxes%YX)

            ! Surface momentum fluxes
            nullify(Me%External_Var%AtmToWaveMomentum_UV)
            nullify(Me%External_Var%WaveToOceanMomentum_UV)

            ! Wave induced forces accelerations
            nullify(Me%Forces%Wave3DExplicit_FPressureAccelUV)
            nullify(Me%Forces%Wave3DExplicit_FVortexAccelUV)
            nullify(Me%Forces%Wave3DExplicit_FBreakingAccelUV)

        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    End Subroutine  NullifyAuxiliarPointers

    !End------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of all the explicit forces ( Baroclinic and      !
    !  barotropic water pressure, Coriolis, Atmospheric pressure,                          !
    !  Horizontal transport - covection + diffusion)                                       !
    !  in the velocity evolution                                                           !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping, Forces                                              !
    ! OutPut: TiCoef_3D                                                                      !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Compute_Velocity(PressureBackwardInTime)

        !Variables Categories
            !Geometry  : WaterLevel_New, DUX_VY, DZX_ZY
            !WaterProp : Density
            !Forces    : Inertial_Aceleration, Horizontal_Transport, ROX3, AtmPressure
            !Time      : DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_3D


        !Variables Direction Dependent
            !DUX_VY, DZX_ZY, ComputeFaces3D_UV, KFloor_UV, Direction


        !Arguments------------------------------------------------------------
        logical                             :: PressureBackwardInTime

        !Local----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer  :: ECoef_3D
        real,    dimension(:,:,:), pointer  :: DCoef_3D, FCoef_3D, TiCoef_3D, &
                                               Velocity_UV_Old, Velocity_UV_New
        integer, dimension(:,:,:), pointer  :: ComputeFaces3D_UV, LandBoundaryFacesUV, &
                                               WaterPoints3D

        integer                             :: IJmin, IJmax, JImin, JImax, di, dj

        integer                             :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB

        integer                             :: FaceAdjacentToWater, Coef

        logical                             :: UseOptimizedRoutine

        integer                             :: CHUNK

        integer                             :: STAT_CALL
        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di          =  Me%Direction%di
        dj          =  Me%Direction%dj


        DCoef_3D  => Me%Coef%D3%D
        ECoef_3D  => Me%Coef%D3%E
        FCoef_3D  => Me%Coef%D3%F
        TiCoef_3D => Me%Coef%D3%Ti

        ComputeFaces3D_UV   => Me%External_Var%ComputeFaces3D_UV
        LandBoundaryFacesUV => Me%External_Var%LandBoundaryFacesUV

        Velocity_UV_Old => Me%Velocity%Horizontal%UV%Old
        Velocity_UV_New => Me%Velocity%Horizontal%UV%New

        WaterPoints3D   => Me%External_Var%WaterPoints3D


        !End   - Shorten variables name

        call SetMatrixValue(DCoef_3D,  Me%Size,      0.0       )
        call SetMatrixValue(ECoef_3D,  Me%Size, dble(1.0)      )
        call SetMatrixValue(FCoef_3D,  Me%Size,      0.0       )
        call SetMatrixValue(TICoef_3D, Me%Size, Velocity_UV_Old)

        if (Me%ComputeOptions%VelExpForcesOpt) then
            call Velocity_ExplicitForces(PressureBackwardInTime)
        else
            call Velocity_ExplicitForces2(PressureBackwardInTime)
        endif

        call VelVerticalDiffusionBoundaries


        if (KUB > 1) then

            if (Me%ComputeOptions%VerticalDiffusion)  then
                if (Me%ComputeOptions%VerticalDiffusionOpt) then
                    call Velocity_VerticalDiffusion2!Joao sobrinho
                else
                    call Velocity_VerticalDiffusion!Joao sobrinho
                endif
            endif
            
            UseOptimizedRoutine = .false.

            if (Me%ComputeOptions%VerticalAdvection) then
                if (Me%ComputeOptions%AdvectionMethodV == P2_TVD) then
                    if (Me%ComputeOptions%TVD_LimV == SuperBee)then
                        UseOptimizedRoutine = .true.
                    endif
                endif
                
                if (.NOT. Me%ComputeOptions%VerticalAdvectionOpt) UseOptimizedRoutine = .false.
                
                if (UseOptimizedRoutine) then
                    call Velocity_VerticalAdvection2!Joao Sobrinho
                else
                    call Velocity_VerticalAdvection
                endif
            endif
        endif

        if (Me%WaveStress%ON) then

            call Velocity_WaveStress

        endif

! Modified by Matthias DELPEY - 29/06/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 06/07/2011 - 27/07/2011 - 04/08/2011

        if (Me%ComputeOptions%WaveForcing3D == GLM    .or. &
            Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then

            call Velocity_WaveForces3D

        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        CHUNK = CHUNK_J(JLB,JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Compute_Velocity")

        !$OMP PARALLEL PRIVATE(i,j,k,Coef,FaceAdjacentToWater)

        do  k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB
            ! Large values (FillReal_Value) in non covered faces
            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * ComputeFaces3D_UV(i, j, k) +     &
                                  (1. - ComputeFaces3D_UV(i, j, k)) * FillValueReal

            ! Land boundary condition - velocity zero in faces that
            ! have water in one side and land in another
            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * (1. - LandBoundaryFacesUV(i, j, k))

            ! UnCovered faces condition - velocity zero in faces that
            ! are uncovered
            !The UncoveredFaces disapaered from the module map

!            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * (1. - UnCoveredFacesUV(i, j, k))

            Coef = WaterPoints3D(i, j, k) + WaterPoints3D(i-di, j-dj, k)

            if (Coef > 0) Coef = 1

            FaceAdjacentToWater = (1. - ComputeFaces3D_UV(i, j, k)) * Coef

            TiCoef_3D (i, j, k) = TiCoef_3D (i, j, k) * (1 - FaceAdjacentToWater)


        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Compute_Velocity")

cd2D:   if (KUB == 1) then !If the model is 2D then the implicit direction is in the horizontal

            IJmin = ILB * dj + JLB * di
            IJmax = IUB * dj + JUB * di

            JImin = ILB * di + JLB * dj
            JImax = IUB * di + JUB * dj


            !griflet: olds call
            !call THOMAS_3D(IJmin, IJmax, JImin, JImax, KLB, KUB, di, dj,                 &
            !               DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D, Velocity_UV_New,     &
            !               Me%VECG_3D, Me%VECW_3D)
            !griflet: new call
            call THOMAS_3D(IJmin, IJmax, JImin, JImax, KLB, KUB, di, dj,                &
                           Me%THOMAS, Velocity_UV_New                                   &
#ifdef _ENABLE_CUDA
                           , Me%ObjCuda,                                                &
                           .FALSE.                                                      &
#endif _ENABLE_CUDA
                           )
        else cd2D ! The implicit direction is in the vertical


            ! Vertical direction implicit
            !griflet: old call
            !call THOMASZ(ILB, IUB, JLB, JUB, KLB, KUB, DCoef_3D, ECoef_3D,               &
            !             FCoef_3D, TiCoef_3D, Velocity_UV_New,                           &
            !             Me%VECG_3D, Me%VECW_3D)
            !griflet: new call

            ! Use CUDA to solve the Thomas algorithm, ID of ModuleCuda is needed
            ! Save results while computing velocity in X direction
!            call THOMASZ(ILB, IUB, JLB, JUB, KLB, KUB, Me%THOMAS, Velocity_UV_New &
!#ifdef _ENABLE_CUDA
!                         , Me%ObjCuda,                                                  &
!                         .FALSE.                                                        &
!#endif _ENABLE_CUDA
!                        )

            call THOMASZ_NewType2(ILB, IUB, JLB, JUB, KLB, KUB, Me%THOMAS, Velocity_UV_New, &
                                  Me%External_Var%WaterPoints3D  &
#ifdef _ENABLE_CUDA
                         , Me%ObjCuda,                                                  &
                         .FALSE.                                                        &
#endif _ENABLE_CUDA
                        )

        endif cd2D

        call InstantMixingSmallDepths

! Modified by Matthias DELPEY - 14/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if (Me%ComputeOptions%WaveForcing3D == GLM) then
            ! This subroutine set Velocity at land boundary to -(Stokes drift velocity) in case of use of GLM
            ! approach (WAVE_FORCING_3D : 2)
            call Velocity_LandBoundaryGLM
        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        call Velocity_OpenBoundary

        if (Me%CyclicBoundary%ON)  then

            if (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectNormal    ( Vector = Velocity_UV_New)
            endif

            if (Me%CyclicBoundary%Direction == Me%Direction%YX .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectTangential( Vector = Velocity_UV_New)
            endif

        endif


        !PCL
        if (Me%Relaxation%Velocity) call VelocityRelaxation

        call ComputeBarotropicVelocity

        STAT_CALL = SUCCESS_

#if _USE_MPI
        !if domain decomposition is On exchanges velocities along the domains boundaries
        !call ReceiveSendVelocity3DMPI(Property3D = Velocity_UV_New, Vector = .true.)
        call ReceiveSendProperitiesMPI(HorizontalGridID = Me%ObjHorizontalGrid,     &
                                       Property3D       = Velocity_UV_New,          &
                                       KLB              = Me%WorkSize%KLB,          &
                                       KUB              = Me%WorkSize%KUB,          &
                                       di               = Me%Direction%di,          &
                                       dj               = Me%Direction%dj,          &
                                       STAT             = STAT_CALL)
#endif _USE_MPI

        if (STAT_CALL /= SUCCESS_) stop 'Compute_Velocity - ModuleHydrodynamic - ERR10'

        !Nullify auxiliar variables
        nullify (DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D)

        nullify (WaterPoints3D, LandBoundaryFacesUV)

        nullify (Velocity_UV_Old, Velocity_UV_New)

    end Subroutine Compute_Velocity

    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine computes the barotropic velocity for the Z points (cell center)     !
    !                                                                                      !
    ! Input : Flow, Geometry                                                               !
    ! OutPut: BarotropicUc, BarotropicVc                                                   !
    ! Author: Paulo Leitao (02/2018)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine ComputeBarotropicVelocity

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real,    dimension(:, :, :), pointer        :: DWZ
        real,    dimension(:, :, :), pointer        :: Velocity_U, Velocity_V
        real,    dimension(:, :   ), pointer        :: WaterColumn
        real,    dimension(:, :   ), pointer        :: Vel2D_U, Vel2D_V
        integer, dimension(:, :, :), pointer        :: OpenPoints3D
        integer, dimension(:, :   ), pointer        :: KFloor_Z
        integer                                     :: ILB, IUB, i
        integer                                     :: JLB, JUB, j
        integer                                     :: Kbottom, KUB, k
        integer                                     :: CHUNK

        !Begin-----------------------------------------------------------------
        ILB                  =  Me%WorkSize%ILB
        IUB                  =  Me%WorkSize%IUB
        JLB                  =  Me%WorkSize%JLB
        JUB                  =  Me%WorkSize%JUB
        KUB                  =  Me%WorkSize%KUB

        Velocity_U           => Me%Velocity%Horizontal%U%New
        Velocity_V           => Me%Velocity%Horizontal%V%New

        Vel2D_U              => Me%Velocity%BarotropicUc
        Vel2D_V              => Me%Velocity%BarotropicVc

        DWZ                  => Me%External_Var%DWZ
        OpenPoints3D         => Me%External_Var%OpenPoints3D
        WaterColumn          => Me%External_Var%WaterColumn
        KFloor_Z             => Me%External_Var%KFloor_Z

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ComputeBarotropicVelocity")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            if (OpenPoints3D(i, j, KUB) == OpenPoint) then

                Kbottom = KFloor_Z(i, j)

                Vel2D_U(i, j) = 0.
                Vel2D_V(i, j) = 0.

                do  k = Kbottom, KUB
                    Vel2D_U(i, j) = Vel2D_U(i, j) + (Velocity_U(i,j,k) + Velocity_U(i,j+1,k))/2.*DWZ(i,j,k)
                    Vel2D_V(i, j) = Vel2D_V(i, j) + (Velocity_V(i,j,k) + Velocity_V(i+1,j,k))/2.*DWZ(i,j,k)
                enddo
                if (WaterColumn(i, j) > 0.) then
                    Vel2D_U(i, j) = Vel2D_U(i, j) / WaterColumn(i, j)
                    Vel2D_V(i, j) = Vel2D_V(i, j) / WaterColumn(i, j)
                else
                    Vel2D_U(i, j) = 0.
                    Vel2D_V(i, j) = 0.
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ComputeBarotropicVelocity")
        endif

        nullify(Velocity_U   )
        nullify(Velocity_V   )
        nullify(Vel2D_U      )
        nullify(Vel2D_V      )
        nullify(DWZ          )
        nullify(OpenPoints3D )
        nullify(WaterColumn  )
        nullify(KFloor_Z     )


    end subroutine ComputeBarotropicVelocity

    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine mixes instantaniously the watercolumn in small depths               !
    !                                                                                      !
    ! Input : Flow, Geometry                                                               !
    ! OutPut: VelocityU, V                                                                 !
    ! Author: Frank (00/10)                                                                !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine InstantMixingSmallDepths

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real,    dimension(:, :, :), pointer        :: Area_UV
        real,    dimension(:, :, :), pointer        :: Velocity_UV_New
        real,    dimension(:, :   ), pointer        :: WaterColumnUV
        integer, dimension(:, :, :), pointer        :: ComputeFaces3D_UV
        integer, dimension(:, :   ), pointer        :: KFloor_UV
        real(8)                                     :: TotalArea, TotalFlux
        real                                        :: WaterColumn2D
        integer                                     :: ILB, IUB, i
        integer                                     :: JLB, JUB, j
        integer                                     :: Kbottom, KUB, k
        integer                                     :: CHUNK

        !Begin-----------------------------------------------------------------
        ILB                  =  Me%WorkSize%ILB
        IUB                  =  Me%WorkSize%IUB
        JLB                  =  Me%WorkSize%JLB
        JUB                  =  Me%WorkSize%JUB
        KUB                  =  Me%WorkSize%KUB
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New
        Area_UV              => Me%External_Var%Area_UV
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        WaterColumnUV        => Me%External_Var%WaterColumnUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "InstantMixingSmallDepths")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,TotalArea,TotalFlux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doi:    do j=JLB, JUB
doj:    do i=ILB, IUB


cd1:        if (ComputeFaces3D_UV(i, j, KUB) == Covered  .and.                           &
                WaterColumnUV(i, j) <= WaterColumn2D) then

                Kbottom = KFloor_UV(i, j)

                TotalArea = 0.
                TotalFlux = 0.

dok1:           do  k = Kbottom, KUB

                    TotalArea = TotalArea + dble(Area_UV        (i, j, k))
                    TotalFlux = TotalFlux + dble(Area_UV        (i, j, k)) *             &
                                            dble(Velocity_UV_New(i, j, k))

                enddo dok1

                Velocity_UV_New(i, j, Kbottom:KUB) = real(TotalFlux/TotalArea)

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "InstantMixingSmallDepths")
        endif

        nullify(Velocity_UV_New  )
        nullify(Area_UV          )
        nullify(ComputeFaces3D_UV)
        nullify(WaterColumnUV    )
        nullify(KFloor_UV        )

    end subroutine InstantMixingSmallDepths

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal velocity from the horizontal fluxes.         !
    !                                                                                      !
    ! Input : Flow, Geometry                                                               !
    ! OutPut: VelocityU, V                                                                 !
    ! Author: Frank (00/10)                                                                !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine Compute_VelocityFromFluxes

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k
        integer                                     :: CHUNK

        !Begin-----------------------------------------------------------------

        CHUNK = CHUNK_J(Me%WorkSize%JLB,Me%WorkSize%JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Compute_VelocityFromFluxes")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k)

        !openMP here
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB + 1
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            Me%Velocity%Horizontal%U%New(i, j, k) = Me%WaterFluxes%X(i, j, k) / Me%External_Var%Area_U(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !openMP here
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB + 1
            Me%Velocity%Horizontal%V%New(i, j, k) = Me%WaterFluxes%Y(i, j, k) / Me%External_Var%Area_V(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Compute_VelocityFromFluxes")
        endif

    end subroutine Compute_VelocityFromFluxes



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This suborutine compute the water level elevation                                    !
    !                                                                                      !
    ! Input : Geomtry, Flow, Mapping, Time steps                                           !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Compute_WaterLevel

        !Variables Categories
            !Geometry  : Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY
            !Flow      : Velocity_UV_Old, Velocity_VU_New, Velocity_VU_Old, Vert_Viscosity
            !WaterProp : Density
            !Boundary  : AtmPressure, Chezy
            !Forces    : Horizontal_Transport, Rox3,
            !Time      : DT_Elevation, DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D

        !Variables Direction Dependent
           !Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY
           !Velocity_UV_Old, Velocity_VU_New, Velocity_VU_Old, ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------

        real(8), dimension(:,:),   pointer  :: ECoef_2D, ECoef_2D_Aux
        real,    dimension(:,:),   pointer  :: DCoef_2D, FCoef_2D, TiCoef_2D,  &
                                               WaterLevel_Old, WaterLevel_New, &
                                               RadCoef_2D, TiRadCoef_2D, TiCoef_2D_Aux

        real,    dimension(:,:),   pointer  :: WaterLevel_Max, WaterLevel_Min

        integer                             :: IUB, ILB, JUB, JLB
        integer                             :: IJmin, IJmax, JImin, JImax
        integer                             :: di, dj, DirectionXY

        !Begin----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Compute_WaterLevel")

        !Begin - Shorten variables name

        DirectionXY =  Me%Direction%XY


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        di          =  Me%Direction%di
        dj          =  Me%Direction%dj

        DCoef_2D  => Me%Coef%D2%D
        ECoef_2D  => Me%Coef%D2%E
        FCoef_2D  => Me%Coef%D2%F
        TiCoef_2D => Me%Coef%D2%Ti

        ECoef_2D_Aux    => Me%Coef%D2%Eaux
        TiCoef_2D_Aux   => Me%Coef%D2%Tiaux

        RadCoef_2D   => Me%Coef%D2%Rad
        TiRadCoef_2D => Me%Coef%D2%TiRad

        WaterLevel_Old => Me%WaterLevel%Old
        WaterLevel_New => Me%WaterLevel%New

        if (Me%ComputeOptions%WaterLevelMaxMin) then
            WaterLevel_Max => Me%WaterLevel%Maxi
            WaterLevel_Min => Me%WaterLevel%Mini
        endif

        !End   - Shorten variables name

        !Begin - Compute

        call SetMatrixValue(DCoef_2D,   Me%WorkSize2D,           0.0 )
        call SetMatrixValue(ECoef_2D,   Me%WorkSize2D,      dble(1.0))
        call SetMatrixValue(FCoef_2D,   Me%WorkSize2D,           0.0 )
        call SetMatrixValue(TiCoef_2D,  Me%WorkSize2D, WaterLevel_Old)

cd1:    if (Me%ComputeOptions%BarotropicRadia == FlatherWindWave_ .or.      &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            call SetMatrixValue(RadCoef_2D,    Me%WorkSize2D, 0.0)
            call SetMatrixValue(TiRadCoef_2D,  Me%WorkSize2D, 0.0)

        end if cd1

        !Implicit bottom friction
        call WaterLevel_BottomFriction
        call WaterLevel_BarotropicPressure
        call WaterLevel_ExplicitForces
        call WaterLevel_WaterFluxes
        call WaterLevelDischarges
        call WaterLevel_OpenBoundary

        IJmin = ILB * dj + JLB * di
        IJmax = IUB * dj + JUB * di

        JImin = ILB * di + JLB * dj
        JImax = IUB * di + JUB * dj

        if (.not. Me%CyclicBoundary%ON .or.                                              &
                 (Me%CyclicBoundary%ON .and. Me%CyclicBoundary%Direction == Me%Direction%YX))  then


            if (Me%DDecomp%ON) then
                call THOMAS_2D_DDecomp
            else
                !griflet: old call
                call THOMAS_2D(IJmin, IJmax, JImin, JImax, di, dj, DCoef_2D, ECoef_2D,       &
                               FCoef_2D, TiCoef_2D, WaterLevel_New,                          &
                               Me%VECG_2D, Me%VECW_2D)
                !griflet: new call
                !call THOMAS_2D(IJmin, IJmax, JImin, JImax, di, dj, Me%THOMAS2D, WaterLevel_New, Me%ModelName)
            endif
        else

            call WaterLevel_CyclicBoundary

        endif

        if (Me%Tsunami%ON) then
            if (Me%Tsunami%Fault%T0 <= Me%CurrentTime) then
                call WaterLevel_Tsunami
                Me%Tsunami%ON = .false.
            endif
        endif

        if (Me%Relaxation%WaterLevel)                                                   &
            call WaterLevelRelaxation

        ! aqui relaxa-se o nivel com altimetria
        if (Me%ComputeOptions%AltimetryAssimilation%Yes)                                &
            call WaterLevelRelaxationAltimetry

        !In this subroutine model verifies if the level is below a critical level and
        !if this is the case water level is set equal to the critical level.
        call WaterLevelCorrection

        if (Me%ComputeOptions%WaterLevelMaxMin)                                         &
            call WaterLevelMaxMin(WaterLevel_Max, WaterLevel_Min)

        !Nullify auxiliar variables
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D)

        nullify(ECoef_2D_Aux, TiCoef_2D_Aux)

        nullify (WaterLevel_Old, WaterLevel_New)


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Compute_WaterLevel")

   end Subroutine Compute_WaterLevel

!------------------------------------------------------------------------------

!.....BASED ON OKADA'S PAPER (1985)
!.....CREATED BY XIAOMING WANG (JUN 2003)
!----------------------------------------------------------------------
    subroutine Dip_Slip (X2,Y1,Y2,DP,DD,F)

        !Arguments----------------------------------------------------------------------
        real,   intent(IN) :: X2,Y1,Y2,DP,DD
        real,   intent(OUT):: F

        !Local--------------------------------------------------------------------------
        real    :: SN, CS, P, Q, D_BAR, R, XX, A5

        !Begin--------------------------------------------------------------------------

        SN      = SIN(DP)
        CS      = COS(DP)

        P       = X2*CS + DD*SN
        Q       = X2*SN - DD*CS
        D_BAR   = Y2*SN - Q*CS;
        R       = SQRT(Y1**2 + Y2**2 + Q**2)
        XX      = SQRT(Y1**2 + Q**2)
        A5      = 0.5*2/CS*ATAN((Y2*(XX+Q*CS)+XX*(R+XX)*SN)/Y1/(R+XX)/CS)
        F       = -(D_BAR*Q/R/(R+Y1) + SN*ATAN(Y1*Y2/Q/R)- A5*SN*CS)/2/3.14159

    end subroutine Dip_Slip
!----------------------------------------------------------------------

!.....USED FOR OKADA'S MODEL (CREATED BY XIAOMING WANG IN JUN 2003)
!NOTE:
!     #. UPDATED ON FEB04 2009 (XIAOMING WANG, GNS)

    subroutine Strike_Slip (X2,Y1,Y2,DP,DD,F)

        !Arguments----------------------------------------------------------------------
        real,   intent(IN) :: X2,Y1,Y2,DP,DD
        real,   intent(OUT):: F

        !Local--------------------------------------------------------------------------
        real    :: SN, CS, P, Q, D_BAR, R, XX, TMP1, TMP2, A4

        !Begin--------------------------------------------------------------------------

        SN = SIN(DP)
        CS = COS(DP)
        P = X2*CS + DD*SN
        Q = X2*SN - DD*CS
        D_BAR = Y2*SN - Q*CS
        R = SQRT(Y1**2 + Y2**2 + Q**2)
        XX = SQRT(Y1**2 + Q**2)
        TMP1 = R+D_BAR
        TMP2 = R+Y2
        IF (TMP1 .LE. AlmostZero) TMP1 = AlmostZero
        IF (TMP2 .LE. AlmostZero) TMP2 = AlmostZero
        A4 = 0.5*1/CS*(LOG(TMP1) - SN*LOG(TMP2))
        F = -(D_BAR*Q/R/(R+Y2) + Q*SN/(R+Y2) + A4*SN)/2/3.14159

    end subroutine Strike_Slip


!......................................................................
!DESCRIPTION:
!     # MAPPING A POINT ON THE ELLIPSOID SURFACE ONTO A PLANE;
!     # OBLIQUE STEREOGRAPHIC PROJECTION IS ADOPTED
!INPUT:
!     LATIN: LATITUDE IN DEGREES
!     LONIN: LONGITUDE IN DEGREES
!     LAT0: LATITUDE OF TANGENTIAL POINT IN DEGREES (E.G., EPICENTER)
!     LON0: LONGITUDE OF TANGENTIAL POINT IN DEGREES (E.G., EPICENTER)
!OUTPUT:
!     X: X COORDINATE/EASTING IN METERS RELATIVE TO ORIGIN (I.E., LON0)
!     Y: Y COORDINATE/NORTHING IN METERS RELATIVE TO ORIGIN (I.E., LAT0)
!REFERENCES:
!      #. SNYDER, J.P. (1987). MAP PROJECTIONS - A WORKING MANUAL.
!                          USGS PROFESSIONAL PAPER 1395
!     #. ELLIPSOIDAL DATUM: WGS84
!WORKING NOTES:
!     CREATED ON DEC18 2008 (XIAOMING WANG, GNS)
!     UPDATED ON JAN02 2009 (XIAOMING WANG, GNS)
!----------------------------------------------------------------------

!----------------------------------------------------------------------
    subroutine STEREO_PROJECTION (X,Y,LONIN,LATIN,LON0,LAT0)

        !Arguments----------------------------------------------------------------------
        real,   intent(OUT) :: X,Y
        real,   intent(IN)  :: LONIN,LATIN,LON0,LAT0

        !Local--------------------------------------------------------------------------
        real                :: POLE
        real                :: LAT,LON,LT0,LN0,CS,SN,CS0,SN0,TMP,TMP0
        real                :: A,B,K0,E,ES,N,C,R,S1,S2,W1,W2,SA,SB,BETA,XI,LM,XI0,LM0,F2
        real                :: RHO0, NU0, SN_XI0, W
        !COMMON /CONS/ ELMAX,GRAV,PI,R_EARTH,GX,EPS,ZERO,ONE,NUM_GRID,    &
        !            NUM_FLT,V_LIMIT,RAD_DEG,RAD_MIN

        !Begin--------------------------------------------------------------------------

        !AVOID SINGULARITY AT POLES
        POLE = PI/2.0 - AlmostZero
        ! CONVERT DEGREE TO RADIAN
        LAT = LATIN*RAD_DEG
        LON = LONIN*RAD_DEG
        LT0 = LAT0*RAD_DEG
        LN0 = LON0*RAD_DEG
        IF (LAT .GT.  POLE) LAT =  POLE
        IF (LAT .LT. -POLE) LAT = -POLE
        IF (LT0 .GT.  POLE) LT0 =  POLE
        IF (LT0 .LT. -POLE) LT0 = -POLE

        CS  = COS(LAT)
        SN  = SIN(LAT)
        CS0 = COS(LT0)
        SN0 = SIN(LT0)

        ! PARAMETERS
        A  = 6378137.0000           ! ELLIPSOIDAL SEMI-MAJOR AXIS
        B  = 6356752.3142           ! ELLIPSOIDAL SEMI-MINOR AXIS
        !F  = 0.00335281067183       ! FLATTENING, F = (A-B)/A
        E  = 0.08181919092891       ! ECCENTRICITY, E = SQRT(2.0*F-F**2)
        F2 = 0.00669438000426       ! F2 = E**2
        ES = 0.00673949675659       ! 2ND ECCENTRICITY, ES = E**2/(1-E**2)

        K0 = 0.9996                 ! SCALE FACTOR

        TMP  = SQRT(1.0-F2*SN**2)
        TMP0 = SQRT(1.0-F2*SN0**2)
        RHO0 = A*(1.0-F2)/TMP0**3
        NU0  = A/TMP0
        R    = SQRT(RHO0*NU0)
        N    = SQRT(1.0+F2*CS0**4/(1.0-F2))

        S1      = (1.0+SN0)/(1.0-SN0)
        S2      = (1.0-E*SN0)/(1.0+E*SN0)
        W1      = (S1*S2**E)**N
        SN_XI0  = (W1-1.0)/(W1+1.0)
        C       = (N+SN0)*(1.0-SN_XI0)/(N-SN0)/(1.0+SN_XI0)

        W2 = C*W1
        SA = (1.0+SN)/(1.0-SN)
        SB = (1.0-E*SN)/(1.0+E*SN)
        W  = C*(SA*SB**E)**N

        XI0 = ASIN((W2-1.0)/(W2+1.0))
        LM0 = LN0

        LM = N*(LON-LM0)+LM0
        XI = ASIN((W-1.0)/(W+1.0))

        BETA = 1.0 + SIN(XI)*SIN(XI0) + COS(XI)*COS(XI0)*COS(LM-LM0)

        Y = 2.0*R*K0*(SIN(XI)*COS(XI0) - COS(XI)*SIN(XI0)*COS(LM-LM0))/BETA
        X = 2.0*R*K0*COS(XI)*SIN(LM-LM0)/BETA

    end subroutine STEREO_PROJECTION

!......................................................................
!DESCRIPTION:
!     #. CALCULATE SEAFLOOR DEFORMATION VIA OKADA'S MODEL (1985);
!     #. STEREOGRAPHIC PROJECTION IS IMPLEMENTED TO CREATE MORE
!         ACCURATE MAPPING BETWEEN THE EARTH SURFACE AND THE PLANE USED
!         IN OKADA (1985)
!INPUT:
!      #. FAULT PARAMETERS;
!OUTPUT:
!      #. SEAFLOOR DEFORMATION;
!NOTES:
!     #. CREATED ON JUN ?? 2003 (XIAOMING WANG, CORNELL UNIVERSITY)
!     #. UPDATED ON DEC 18, 2008 (XIAOMING WANG, GNS)
!      #. UPDATED ON FEB 03 2009 (XIAOMING WANG, GNS)
!         1. ADD DETECTION ON NAN/INF
!      #. UPDATED ON FEB 16 2009 (XIAOMING WANG, GNS)
!         1. ADD AN OPTION TO SELECT THE FOCUS LOCATION
!----------------------------------------------------------------------
    subroutine FaultOkada1985

        !Local--------------------------------------------------------------------------

        integer     :: ILB, IUB, JLB, JUB, KUB, i, j

        !COMMON /CONS/ ELMAX,GRAV,PI,R_EARTH,GX,ONE,NUM_GRID,    &
        !                NUM_FLT,V_LIMIT,RAD_DEG,RAD_MIN

        real        :: ANG_L, ANG_R, ANG_T, HALFL
        real        :: HH, DEL_X, DEL_Y, H1, H2
        real        :: DS, DD, SN, CS, X_SHIFT, Y_SHIFT
        real        :: LONIN, LATIN, LON0, LAT0
        real        :: US, F1, F2, F3, F4
        real        :: UD, G1, G2, G3, G4
        real        :: X1, X2, X3, P

        !Begin--------------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB


        ANG_L = RAD_DEG*Me%Tsunami%Fault%DL
        ANG_R = RAD_DEG*Me%Tsunami%Fault%RD
        ANG_T = RAD_DEG*Me%Tsunami%Fault%TH
        HALFL = 0.5*Me%Tsunami%Fault%L
        !.....CALCULATE FOCAL DEPTH USED FOR OKADA'S MODEL
        HH = Me%Tsunami%Fault%HH+0.5*Me%Tsunami%Fault%W*SIN(ANG_L)
        !.....DISPLACEMENT DUE TO DIFFERENT EPICENTER DEFINITION
        !      EPICENTER IS DEFINED AT THE CENTER OF FAULT PLANE
        DEL_X = 0.5*Me%Tsunami%Fault%W*COS(ANG_L)*COS(ANG_T)
        DEL_Y = 0.5*Me%Tsunami%Fault%W*COS(ANG_L)*SIN(ANG_T)

        H1 = HH/SIN(ANG_L)
        H2 = HH/SIN(ANG_L)+Me%Tsunami%Fault%W

        DS = Me%Tsunami%Fault%D*COS(ANG_R)
        DD = Me%Tsunami%Fault%D*SIN(ANG_R)

        SN = SIN(ANG_L)
        CS = COS(ANG_L)

        X_SHIFT = 0.0
        Y_SHIFT = 0.0

        LON0    = Me%Tsunami%Fault%X0
        LAT0    = Me%Tsunami%Fault%Y0

        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%External_Var%OpenPoints3D(i, j, KUB) == OpenPoint) then

                LONIN = Me%External_Var%LongitudeZ(i, j)
                LATIN = Me%External_Var%LatitudeZ (i, j)

                call STEREO_PROJECTION(X_SHIFT, Y_SHIFT, LONIN, LATIN, LON0, LAT0)

                X_SHIFT = X_SHIFT - DEL_X
                Y_SHIFT = Y_SHIFT + DEL_Y

                X1      = X_SHIFT*SIN(ANG_T)+Y_SHIFT*COS(ANG_T)
                X2      = X_SHIFT*COS(ANG_T)-Y_SHIFT*SIN(ANG_T)
                X2      = -X2
                X3      = 0.0
                P       = X2*CS+HH*SN

                CALL Strike_Slip (X2,X1+HALFL,P                   ,ANG_L,HH,F1)
                CALL Strike_Slip (X2,X1+HALFL,P-Me%Tsunami%Fault%W,ANG_L,HH,F2)
                CALL Strike_Slip (X2,X1-HALFL,P                   ,ANG_L,HH,F3)
                CALL Strike_Slip (X2,X1-HALFL,P-Me%Tsunami%Fault%W,ANG_L,HH,F4)

                CALL Dip_Slip    (X2,X1+HALFL,P                   ,ANG_L,HH,G1)
                CALL Dip_Slip    (X2,X1+HALFL,P-Me%Tsunami%Fault%W,ANG_L,HH,G2)
                CALL Dip_Slip    (X2,X1-HALFL,P                   ,ANG_L,HH,G3)
                CALL Dip_Slip    (X2,X1-HALFL,P-Me%Tsunami%Fault%W,ANG_L,HH,G4)

                US = (F1-F2-F3+F4)*DS
                UD = (G1-G2-G3+G4)*DD

                if (abs(US)>100.) then
                    write(*,*) 'I, J, US', I, J, US
                    stop 'FaultOkada1985 - ModuleHydrodynamic - ERR10'
                endif

                if (abs(UD)>100.) then
                    write(*,*) 'I, J, UD', I, J, UD
                    stop 'FaultOkada1985 - ModuleHydrodynamic - ERR20'
                endif

                if (abs(US) < 1e-5) US = 0.
                if (abs(UD) < 1e-5) UD = 0.

                !Water level actualization
                Me%WaterLevel%New(i, j) = Me%WaterLevel%New(i, j) + (US + UD) * Me%Tsunami%Fault%Amplification

            endif
        enddo
        enddo

        !      WRITE (*,*) 'SUBROUTINE OKADA HAS BEEN CALLED'

    end subroutine FaultOkada1985

!----------------------------------------------------------------------
    subroutine FaultInputFile

        !Local--------------------------------------------------------------------------
        real,   dimension(:,:), pointer :: Tsunami2D
        integer                         :: ILB, IUB, JLB, JUB, KUB, i, j, STAT_CALL

        !Begin--------------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        call GetGridData(GridDataID   = Me%Tsunami%Fault%ObjGridData,                   &
                         GridData2D   = Tsunami2D,                                      &
                         STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'FaultInputFile - ModuleHydrodynamic - ERR10'

        do j = JLB, JUB
        do i = ILB, IUB
            if (Me%External_Var%OpenPoints3D(i, j, KUB) == OpenPoint) then
                !Water level actualization
                Me%WaterLevel%New(i, j) = Me%WaterLevel%New(i, j) + Tsunami2D(i, j) * Me%Tsunami%Fault%Amplification
            endif
        enddo
        enddo

        call UnGetGridData(GridDataID   = Me%Tsunami%Fault%ObjGridData,                 &
                           Array        = Tsunami2D,                                    &
                           STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'FaultInputFile - ModuleHydrodynamic - ERR20'

        call KillGridData(GridDataID    = Me%Tsunami%Fault%ObjGridData,                 &
                           STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'FaultInputFile - ModuleHydrodynamic - ERR30'

    end subroutine FaultInputFile

    !-----------------------------------------------------------------------------------

    subroutine WaterLevel_Tsunami

    if      (Me%Tsunami%Fault%InputMethod == FaultFile_     ) then
        call FaultInputFile
    elseif  (Me%Tsunami%Fault%InputMethod == FaultOkada1985_) then
        call FaultOkada1985
    endif

    end subroutine WaterLevel_Tsunami

    !-----------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine computes the thomaz 2D in parallel following a                       !
    ! domain decomposition approach                                                        !
    !                                                                                      !
    ! Input : Coefficients of the  linear system equation                                  !
    ! OutPut: Water level                                                                  !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine THOMAS_2D_DDecomp

#ifdef _USE_MPI

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------
        integer                          :: IUB, ILB, JUB, JLB
        integer                          :: IJmin, IJmax
        integer                          :: JImin, JImax
        integer                          :: di,    dj
        integer                          :: STAT_CALL


        !Begin---------------------------------------------------------------

        di          =  Me%Direction%di
        dj          =  Me%Direction%dj

if1:    if (Me%DDecomp%MasterOrSlave) then
!
            call THOMAS_DDecompHorizGrid(HorizontalGridID    = Me%ObjHorizontalGrid,    &
                                         DCoef_2D            = Me%Coef%D2%D,            &
                                         FCoef_2D            = Me%Coef%D2%F,            &
                                         TiCoef_2D           = Me%Coef%D2%Ti,           &
                                         ECoef_2D            = Me%Coef%D2%E,            &
                                         Results_2D          = Me%WaterLevel%New,       &
                                         di                  = Me%Direction%di,         &
                                         dj                  = Me%Direction%dj,         &
                                         STAT                = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'THOMAS_2D_DDecomp - ModuleHydrodynamic - ERR10'
            endif

        else if1

            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB

            IJmin = ILB * dj + JLB * di
            IJmax = IUB * dj + JUB * di

            JImin = ILB * di + JLB * dj
            JImax = IUB * di + JUB * dj

            call THOMAS_2D(IJmin, IJmax, JImin, JImax, di, dj, Me%THOMAS2D, Me%WaterLevel%New, Me%ModelName)

        endif if1

#endif _USE_MPI

    end subroutine THOMAS_2D_DDecomp

    !------------------------------------------------------------------------------

#ifdef _USE_MPI

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine aggregates in one global domain the thomas                           !
    ! coefficients of all domains                                                          !
    !                                                                                      !
    ! Input : Coefficients of the linear system equation for each domain                   !
    ! OutPut: Coefficients of the linear system equation for the global domain             !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine AggregatesThomasCoefs


        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: D, F, Ti
        real(8), dimension(:,:), pointer :: E

        integer                          :: STAT_CALL, IUB, ILB, JUB, JLB
        integer                          :: di,    dj, i

        integer                          :: Source, Destination
        integer                          :: iSize
        integer, save                    :: Precision
        integer                          :: status(MPI_STATUS_SIZE)

        type(T_Size2D)                   :: Inner, Mapping


        !Begin---------------------------------------------------------------

        IUB = Me%DDecomp%Global%IUB
        ILB = Me%DDecomp%Global%ILB
        JUB = Me%DDecomp%Global%JUB
        JLB = Me%DDecomp%Global%JLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        if (Me%DDecomp%Master) then

            call CopyThomasCoefs(D = Me%Coef%D2%D, E  = Me%Coef%D2%E,                   &
                                 F = Me%Coef%D2%F, Ti = Me%Coef%D2%Ti,                  &
                                 Inner   = Me%DDecomp%Inner,                &
                                 Mapping = Me%DDecomp%Mapping)

            do i=1, Me%DDecomp%Nslaves

                Inner   = Me%DDecomp%Slaves_Inner  (i)

                Mapping = Me%DDecomp%Slaves_Mapping(i)

                allocate(D (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                allocate(E (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                allocate(F (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
                allocate(Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))

                iSize     = (Inner%IUB-Inner%ILB+1) * (Inner%JUB-Inner%JLB+1)

                Precision = MPIKind(D)

                Source    =  Me%DDecomp%Slaves_MPI_ID(i)

                call MPI_Recv (D(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20001, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

                call MPI_Recv (F(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20002, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

                call MPI_Recv (Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20003, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

                Precision = MPI_DOUBLE_PRECISION

                call MPI_Recv (E(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                               Source, 20004, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

                call CopyThomasCoefs(D = D, E  = E, F = F, Ti = Ti, Inner = Inner, Mapping = Mapping)

                deallocate(D )
                deallocate(E )
                deallocate(F )
                deallocate(Ti)

                nullify(D)
                nullify(E)
                nullify(F)
                nullify(Ti)

            enddo

        else

            Inner       = Me%DDecomp%Inner

            allocate(D (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
            allocate(E (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
            allocate(F (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))
            allocate(Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB))


            D   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%D   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            E   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%E   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            F   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%F   (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)
            Ti  (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB) = Me%Coef%D2%Ti  (Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB)

            iSize       = (Inner%IUB-Inner%ILB+1) * (Inner%JUB-Inner%JLB+1)
            Precision   = MPIKind(D)
            Destination = Me%DDecomp%Master_MPI_ID

            call MPI_Send (D(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20001, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

            call MPI_Send (F(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20002, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

            call MPI_Send (Ti(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20003, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

            Precision = MPI_DOUBLE_PRECISION

            call MPI_Send (E(Inner%ILB:Inner%IUB, Inner%JLB:Inner%JUB), iSize, Precision,   &
                           Destination, 20004, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AggregatesThomasCoefs - ModuleHydrodynamic - ERR10'

            deallocate(D )
            deallocate(E )
            deallocate(F )
            deallocate(Ti)

            nullify(D)
            nullify(E)
            nullify(F)
            nullify(Ti)


        endif



    end subroutine AggregatesThomasCoefs

    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine broadcast for each domain the thomas algorithm results               !
    ! (new water level)                                                                    !
    !                                                                                      !
    ! Input : water level for the global domain                                            !
    ! OutPut: water level for each domain                                                  !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine BroadcastThomasResult()


        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: WL

        integer                          :: STAT_CALL, IUB, ILB, JUB, JLB
        integer                          :: di,    dj, i

        integer                          :: Source, Destination
        integer                          :: iSize
        integer, save                    :: Precision
        integer                          :: status(MPI_STATUS_SIZE)

        type(T_Size2D)                   :: WorkSize, HaloMap


        !Begin---------------------------------------------------------------

        IUB = Me%DDecomp%Global%IUB
        ILB = Me%DDecomp%Global%ILB
        JUB = Me%DDecomp%Global%JUB
        JLB = Me%DDecomp%Global%JLB

        di  =  Me%Direction%di
        dj  =  Me%Direction%dj

        if (Me%DDecomp%Master) then

            WorkSize = Me%WorkSize2D
            HaloMap  = Me%DDecomp%HaloMap

            Me%WaterLevel%New(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB) =   &
                Me%DDecomp%WaterLevel_New(HaloMap%ILB:HaloMap%IUB,          &
                                                      HaloMap%JLB:HaloMap%JUB)

            do i=1, Me%DDecomp%Nslaves

                WorkSize =  Me%DDecomp%Slaves_Size   (i)
                HaloMap  =  Me%DDecomp%Slaves_HaloMap(i)

                allocate(WL (WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB))

                WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB) =               &
                    Me%DDecomp%WaterLevel_New(HaloMap%ILB:HaloMap%IUB, HaloMap%JLB:HaloMap%JUB)

                iSize       = (WorkSize%IUB-WorkSize%ILB+1) * (WorkSize%JUB-WorkSize%JLB+1)

                Precision   = MPIKind(WL)

                Destination =  Me%DDecomp%Slaves_MPI_ID(i)

                call MPI_Send (WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB), iSize, Precision,   &
                               Destination, 20006, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'BroadcastThomasResult - ModuleHydrodynamic - ERR10'

                deallocate(WL)
                nullify   (WL)

            enddo

        else
            WorkSize    = Me%WorkSize2D

            allocate(WL (WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB))


            iSize       = (WorkSize%IUB-WorkSize%ILB+1) * (WorkSize%JUB-WorkSize%JLB+1)
            Precision   = MPIKind(WL)
            Source      = Me%DDecomp%Master_MPI_ID

            call MPI_Recv (WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB), iSize, Precision,   &
                           Source, 20006, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BroadcastThomasResult - ModuleHydrodynamic - ERR20'

            Me%WaterLevel%New(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB) = &
                WL(WorkSize%ILB:WorkSize%IUB, WorkSize%JLB:WorkSize%JUB)

            deallocate(WL )
            nullify   (WL)

        endif


    end subroutine BroadcastThomasResult

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine copys  the thomas coefficients from one domain to the global one     !
    !                                                                                      !
    ! Input : Coefficients of the linear system equation for each domain                   !
    ! OutPut: Coefficients of the linear system equation for the global domain             !
    ! Author: Paulo Chambel (2013/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine CopyThomasCoefs(D, F, Ti, E, Inner, Mapping)


        !Arguments------------------------------------------------------------
        real,    dimension(:,:), pointer :: D, F, Ti
        real(8), dimension(:,:), pointer :: E
        type (T_Size2D)                  :: Inner, Mapping

        !Local---------------------------------------------------------------
        real,    dimension(:,:), pointer :: DCoef_2D, FCoef_2D, TiCoef_2D
        real(8), dimension(:,:), pointer :: ECoef_2D


        !Begin---------------------------------------------------------------

        nullify(DCoef_2D )
        nullify(ECoef_2D )
        nullify(FCoef_2D )
        nullify(TiCoef_2D)

        DCoef_2D  => Me%DDecomp%Coef%D
        ECoef_2D  => Me%DDecomp%Coef%E
        FCoef_2D  => Me%DDecomp%Coef%F
        TiCoef_2D => Me%DDecomp%Coef%Ti


        Dcoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                    &
               D(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )

        Ecoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                    &
               E(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )


        Fcoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                    &
               F(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )

        Ticoef_2D(Mapping%ILB:Mapping%IUB, Mapping%JLB:Mapping%JUB) =                   &
               Ti(Inner%ILB  :Inner%IUB  , Inner%JLB  :Inner%JUB  )

        nullify(DCoef_2D )
        nullify(ECoef_2D )
        nullify(FCoef_2D )
        nullify(TiCoef_2D)

    end subroutine CopyThomasCoefs

#endif _USE_MPI


#if _USE_MPI
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine exchange velocities between decompose domains                        !
    ! coefficients of all domains                                                          !
    !                                                                                      !
    ! Input : Velocity%UV%New halo region                                                  !
    ! OutPut: Velocity%UV%New halo region - boundary domains                               !
    ! Author: Paulo Chambel (2013/11)                                                      !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine ReceiveSendVelocity3DMPI(Property3D, Vector)

        !Arguments------------------------------------------------------------

        real   , dimension(:,:,:), pointer :: Property3D
        logical                            :: Vector


        !Local---------------------------------------------------------------
        integer                            :: STAT_CALL, IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: IUB_R, ILB_R, JUB_R, JLB_R
        integer                            :: IUB_S, ILB_S, JUB_S, JLB_S
        integer                            :: di,    dj
        integer                            :: Halo_Points, Bandwidth
        integer                            :: DomainA, DomainB, ifd, Direction

        integer                            :: Source, Destination
        integer                            :: iSize
        integer, save                      :: Precision
        integer                            :: status(MPI_STATUS_SIZE)


        !Begin---------------------------------------------------------------

idd:    if (Me%DDecomp%MasterOrSlave) then


            call GetDDecompParameters(HorizontalGridID = Me%ObjHorizontalGrid,          &
                                      Interfaces       = Me%DDecomp%Interfaces,         &
                                      STAT             = STAT_CALL)


            Halo_Points = Me%DDecomp%Halo_Points


            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB
            KLB = Me%WorkSize%KLB

            if (Vector) then

                di  =  Me%Direction%di
                dj  =  Me%Direction%dj

            else

                di  =  0
                dj  =  0

            endif

            Precision   = MPIKind(Property3D)

    difd:   do ifd = 1, Me%DDecomp%NInterfaces

                DomainA   = Me%DDecomp%Interfaces(ifd,1)
                DomainB   = Me%DDecomp%Interfaces(ifd,2)
                Direction = Me%DDecomp%Interfaces(ifd,3)

    iSN:        if (Direction == SouthNorth_) then

                    !Then North border communication
    iN:             if (Me%DDecomp%MPI_ID == DomainA) then

                        Bandwidth   = Halo_Points + di
                        iSize       = Bandwidth * (JUB-JLB+1) * (KUB-KLB+1)
                        Source      = DomainB
                        Destination = Source

                        IUB_R = IUB                 + di
                        ILB_R = IUB_R - Bandwidth   + 1
                        IUB_S = ILB_R +        di   - 1
                        ILB_S = IUB_S - Bandwidth   + 1

                        !Receive
                        call MPI_Recv (Property3D(ILB_R:IUB_R, JLB:JUB, KLB:KUB), iSize, Precision,      &
                                       Source, 80001, MPI_COMM_WORLD, status, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR10'

                        !Send
                        call MPI_Send (Property3D(ILB_S:IUB_S, JLB:JUB, KLB:KUB), iSize, Precision,      &
                                       Destination, 80002, MPI_COMM_WORLD, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR20'

                    endif iN

                    !Then South border communication
    iS:             if (Me%DDecomp%MPI_ID == DomainB) then

                        Bandwidth   = Halo_Points + di
                        iSize       = Bandwidth * (JUB-JLB+1) * (KUB-KLB+1)
                        Source      = DomainA
                        Destination = Source

                        ILB_R = ILB
                        IUB_R = ILB_R + Bandwidth - 1
                        ILB_S = IUB_R        - di + 1
                        IUB_S = ILB_S + Bandwidth - 1

                        !Send
                        call MPI_Send (Property3D(ILB_S:IUB_S, JLB:JUB, KLB:KUB), iSize, Precision,      &
                                       Destination, 80001, MPI_COMM_WORLD, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR30'

                        !Receive
                        call MPI_Recv (Property3D(ILB_R:IUB_R, JLB:JUB, KLB:KUB), iSize, Precision,      &
                                       Source, 80002, MPI_COMM_WORLD, status, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR40'

                    endif iS

                endif iSN

    iWE:        if (Direction == WestEast_) then

                    !Then East border communication
    iE:             if (Me%DDecomp%MPI_ID == DomainA) then

                        Bandwidth   = Halo_Points + dj
                        iSize       = Bandwidth * (IUB-ILB+1) * (KUB-KLB+1)
                        Source      = DomainB
                        Destination = Source

                        !Receive
                        JUB_R = JUB                 + dj
                        JLB_R = JUB_R - Bandwidth   + 1
                        JUB_S = JLB_R +        dj   - 1
                        JLB_S = JUB_S - Bandwidth   + 1

                        call MPI_Recv (Property3D(ILB:IUB, JLB_R:JUB_R, KLB:KUB), iSize, Precision,      &
                                       Source, 80005, MPI_COMM_WORLD, status, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR50'

                        !Send
                        call MPI_Send (Property3D(ILB:IUB, JLB_S:JUB_S, KLB:KUB), iSize, Precision,      &
                                       Destination, 80006, MPI_COMM_WORLD, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR60'

                    endif iE

                    !Then West border communication
    iW:             if (Me%DDecomp%MPI_ID == DomainB) then

                        Bandwidth   = Halo_Points + dj
                        iSize       = Bandwidth * (IUB-ILB+1) * (KUB-KLB+1)
                        Source      = DomainA
                        Destination = Source

                        !Receive
                        JLB_R = JLB
                        JUB_R = JLB_R + Bandwidth - 1
                        JLB_S = JUB_R        - dj + 1
                        JUB_S = JLB_S + Bandwidth - 1

                        !Send
                        call MPI_Send (Property3D(ILB:IUB, JLB_S:JUB_S, KLB:KUB), iSize, Precision,      &
                                       Destination, 80005, MPI_COMM_WORLD, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR70'

                        call MPI_Recv (Property3D(ILB:IUB, JLB_R:JUB_R, KLB:KUB), iSize, Precision,      &
                                       Source, 80006, MPI_COMM_WORLD, status, STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR80'

                    endif iW

                endif iWE

            enddo difd

            call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%DDecomp%Interfaces, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReceiveSendVelocity3DMPI - ModuleHydrodynamic - ERR100'

        endif idd


    end subroutine ReceiveSendVelocity3DMPI

#endif _USE_MPI

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !In this subroutine model verifies if the level is below a critical level              !
    !This is critical level is a warning that says below this level there is a very        !
    !big probability of negative volumes                                                   !
    !To avoid this problem the water level is corrected and put equal to this              !
    !critical                                                                              !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevelCorrection

        !Arguments--------------------------------------------------------------


        !External---------------------------------------------------------------

!        character(LEN = StringLength) :: string

!        integer :: WARNING_, INTERNAL_

        !Local------------------------------------------------------------------

        integer                             :: i, j, STAT_CALL
!        integer                             :: M
        integer                             :: IUB, ILB, JUB, JLB, KUB
        integer, pointer, dimension (:,:)   :: WaterPoints2D

        real,    dimension(:,:), pointer    :: WaterLevel_New, Bathymetry, VolumeCreated, &
                                               DUX, DVY
        real                                :: MinWaterColumn, WaterLevelMin, dh

        logical                             :: CorrectWaterLevel, BathymEvolution

        integer                             :: CHUNK

        !Begin------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        WaterLevel_New    => Me%WaterLevel%New
        WaterPoints2D     => Me%External_Var%WaterPoints2D
        VolumeCreated     => Me%WaterLevel%VolumeCreated

        DUX            => Me%External_Var%DUX
        DVY            => Me%External_Var%DVY

        WaterLevelMin     =  Me%ComputeOptions%WaterLevelMin
        CorrectWaterLevel =  Me%ComputeOptions%CorrectWaterLevel

        !End   - Shorten variables name

       !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR01'

        call GetGeometryMinWaterColumn(Me%ObjGeometry, &
                                       MinWaterColumn, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR02'

        call GetGridDataEvolution(Me%ObjGridData, BathymEvolution, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR04'

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevelCorrection")
        endif

        !$OMP PARALLEL PRIVATE(i,j,dh)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  j = JLB, JUB
do2:    do  i = ILB, IUB

cd1:        if (WaterPoints2D(i, j) == OpenPoint) then

                !By defaul this first correction is always made because the water level can not
                !be located below the bottom

cd2:            if (WaterLevel_New(i, j) < (- Bathymetry(i, j) + MinWaterColumn / 2.)) then

                    dh = (- WaterLevel_New(i, j) - Bathymetry(i, j) + MinWaterColumn / 2.)

                    VolumeCreated (i, j) = VolumeCreated(i, j)  + dh * DUX(i, j) * DVY(i, j)

                    WaterLevel_New(i, j) = - Bathymetry(i, j) + MinWaterColumn / 2.

                endif cd2

                !This second correction is optional and is used when the user wants to
                !define a reference level below which the water level is corrected.
cd3:            if (CorrectWaterLevel .and. WaterLevel_New(i, j) < (WaterLevelMin + MinWaterColumn / 2.)) then

                    WaterLevel_New(i, j) = WaterLevelMin + MinWaterColumn / 2.

                endif cd3

                !If BathymEvolution is turned on, the water level in eroded non-covered cells is updated
                !to avoid high gradients when cells become covered
cd4:            if (BathymEvolution) then

cd5:                if (Me%External_Var%OpenPoints3D(i, j, KUB) .ne. OpenPoint .and. Bathymetry(i, j) < 0. .and. &
                        (WaterLevel_New(i, j) + Bathymetry(i, j)) > MinWaterColumn) then

                        WaterLevel_New(i, j) = - Bathymetry(i, j) + MinWaterColumn

                    endif cd5
                endif cd4

            endif cd1

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevelCorrection")
        endif

       !UnGets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'WaterLevelCorrection - ModuleHydrodynamic - ERR03'

        nullify (WaterLevel_New, VolumeCreated, DUX, DVY)
        nullify (WaterPoints2D )

        !----------------------------------------------------------------------

    End Subroutine WaterLevelCorrection

    !--------------------------------------------------------------------------


    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine computes the maximum and the minimum water elevation of each cell    !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level Max and Min values                                               !
    ! Author: Guillaume Riflet (2010/9)                                                    !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevelMaxMin(WaterLevel_Max, WaterLevel_Min)

        !Arguments--------------------------------------------------------------
        real, dimension(:,:), pointer       :: WaterLevel_Max, WaterLevel_Min

        !External---------------------------------------------------------------

        !Local------------------------------------------------------------------

        integer                             :: i, j
        integer                             :: IUB, ILB, JUB, JLB, KUB
        integer, pointer, dimension (:,:,:) :: OpenPoints3D

        real,    dimension(:,:), pointer    :: WaterLevel_New

        integer                             :: CHUNK

        !Begin------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        WaterLevel_New    => Me%WaterLevel%New
        OpenPoints3D      => Me%External_Var%OpenPoints3D

        !End   - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevelMaxMin")
        endif

        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  j = JLB, JUB
do2:    do  i = ILB, IUB

cd1:        if (OpenPoints3D(i, j, KUB) == OpenPoint) then

                !Do we have a new record water level?
                if (WaterLevel_Max(i,j) < WaterLevel_New(i,j)) then
                    WaterLevel_Max(i,j) = WaterLevel_New(i,j)
                end if

                !Do we have a new minimum water level?
                if (WaterLevel_Min(i,j) > WaterLevel_New(i,j)) then
                    WaterLevel_Min(i,j) = WaterLevel_New(i,j)
                end if

            endif cd1

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevelMaxMin")
        endif

        nullify (WaterLevel_New)
        nullify (OpenPoints3D )

        !----------------------------------------------------------------------

    End Subroutine WaterLevelMaxMin

    !--------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the water level in the open boundary                         !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_OpenBoundary

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        integer :: i, j
        integer, pointer, dimension (:,:,:) :: WaterPoints3D

        real,    dimension(:,:), pointer    :: TiCoef_2D
        logical                             :: Imposed_BoundaryWave

        integer                             :: IUB, ILB, JUB, JLB, KUB, BarotropicRadia

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        TiCoef_2D     => Me%Coef%D2%Ti
        WaterPoints3D => Me%External_Var%WaterPoints3D

        Imposed_BoundaryWave =  Me%ComputeOptions%Imposed_BoundaryWave
        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia


        !End   - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_OpenBoundary")
        endif

        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

            !A large negative water level (FillReal_Value) is imposed in non waterpoints
            TiCoef_2D(i, j) = TiCoef_2D(i, j) * WaterPoints3D(i, j, KUB) + &
                               (1. - WaterPoints3D(i, j, KUB)) * FillValueReal

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_OpenBoundary")
        endif

        if (Imposed_BoundaryWave) then

            call WaterLevel_ImposedWave

        else if (BarotropicRadia == FlatherWindWave_) then

            !Compute radiation in the boundary faces with implicit flux
            call WaterLevel_FlatherWindWave    (                                              &
                                       WaterFlux_XY      = Me%WaterFluxes%XY,                 &
                                       WaterFlux_YX      = Me%WaterFluxes%YX,                 &
                                       WaterColumnUV     = Me%External_Var%WaterColumnUV,     &
                                       DUX_VY            = Me%External_Var%DUX_VY,            &
                                       DVY_UX            = Me%External_Var%DVY_UX,            &
                                       DYY_XX            = Me%External_Var%DYY_XX,            &
                                       ComputeFaces3D_UV = Me%External_Var%ComputeFaces3D_UV, &
                                       ComputeFaces3D_VU = Me%External_Var%ComputeFaces3D_VU, &
                                       BoundaryFacesUV   = Me%External_Var%BoundaryFacesUV,   &
                                       Kfloor_UV         = Me%External_Var%Kfloor_UV,         &
                                       Kfloor_VU         = Me%External_Var%Kfloor_VU,         &
                                       di                = Me%Direction%di,                   &
                                       dj                = Me%Direction%dj,                   &
                                       DirectionXY       = Me%Direction%XY,                   &
                                       ImplicitFaces     = .true.)

        else if  (BarotropicRadia == FlatherLocalSolution_) then

            call WaterLevel_FlatherLocalSolution

        else if (BarotropicRadia  == BlumbergKantha_      ) then !MRV

            call WaterLevel_BlumbergKantha

        endif

        if (Me%ComputeOptions%NullWaterLevelGradJ .or.                                  &
            Me%ComputeOptions%NullWaterLevelGradI) then
            call WaterLevel_NullGrad
        endif


        !Nullify auxiliar variables
        nullify (TiCoef_2D)
        nullify (WaterPoints3D)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_OpenBoundary

    !--------------------------------------------------------------------------

    subroutine WaterLevel_NullGrad

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:), pointer    :: TiCoef_2D, DCoef_2D, FCoef_2D
        real(8), dimension(:,:), pointer    :: ECoef_2D
        integer, dimension(:,:), pointer    :: BoundaryFacesU, BoundaryFacesV
        integer, dimension(:,:), pointer    :: BoundaryPoints

        integer                             :: IUB, ILB, JUB, JLB
        integer                             :: i, j, ib, jb, ii, ji, db

        !Begin----------------------------------------------------------------


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        DCoef_2D          => Me%Coef%D2%D
        ECoef_2D          => Me%Coef%D2%E
        FCoef_2D          => Me%Coef%D2%F
        TiCoef_2D         => Me%Coef%D2%Ti

        BoundaryFacesU    => Me%External_Var%BoundaryFacesU
        BoundaryFacesV    => Me%External_Var%BoundaryFacesV
        BoundaryPoints    => Me%External_Var%BoundaryPoints

        if(Me%ComputeOptions%NullWaterLevelGradI) then
dj1:        do  j = JLB, JUB
di1:        do  i = ILB, IUB

cd1:            if  (BoundaryFacesU(i, j) == Boundary) then

                    if  (BoundaryPoints(i, j) == Boundary) then
                        ib = i
                        jb = j
                        ii = i
                        ji = j-1
                        db = 1
                    else
                        ib = i
                        jb = j-1
                        ii = i
                        ji = j
                        db = 0
                    endif

                    !DCoef_2D  (ib, jb) = 0.
                    !ECoef_2D  (ib, jb) = 1.
                    !FCoef_2D  (ib, jb) = 0.
                    !TiCoef_2D (ib, jb) = 0.

                    if (Me%Direction%XY == DirectionX_) then
                        if (db == 0) then
                            !ECoef_2D  (ib, jb) = Dcoef_2D(ii, ji)

                            DCoef_2D  (ib, jb) = 0.
                            ECoef_2D  (ib, jb) = 1.
                            FCoef_2D  (ib, jb) = -1.
                            TiCoef_2D (ib, jb) = 0.
                        else
                            !ECoef_2D  (ib, jb) = Fcoef_2D(ii, ji)

                            DCoef_2D  (ib, jb) = -1.
                            ECoef_2D  (ib, jb) = 1.
                            FCoef_2D  (ib, jb) = 0.
                            TiCoef_2D (ib, jb) = 0.
                        endif
                    else
                        !TiCoef_2D (ib, jb) = TiCoef_2D (ii, ji)
                        DCoef_2D  (ib, jb) = 0.
                        ECoef_2D  (ib, jb) = 1.
                        FCoef_2D  (ib, jb) = 0.
                        TiCoef_2D (ib, jb) = TiCoef_2D (ii, ji)
                    endif

                endif cd1

            enddo di1
            enddo dj1
        endif

        if(Me%ComputeOptions%NullWaterLevelGradJ) then
dj2:        do  j = JLB, JUB
di2:        do  i = ILB, IUB

cd2:            if  (BoundaryFacesV(i, j) == Boundary) then

                    if  (BoundaryPoints(i, j) == Boundary) then
                        ib = i
                        jb = j
                        ii = i-1
                        ji = j
                        db = 1
                    else
                        ib = i-1
                        jb = j
                        ii = i
                        ji = j
                        db = 0
                    endif

                    !DCoef_2D  (ib, jb) = 0.
                    !ECoef_2D  (ib, jb) = 1.
                    !FCoef_2D  (ib, jb) = 0.
                    !TiCoef_2D (ib, jb) = 0.

                    !if (Me%Direction%XY == DirectionX_) then
                    if (Me%Direction%XY == DirectionY_) then
                        if (db == 0) then
                            !ECoef_2D  (ib, jb) = Dcoef_2D(ii, ji)

                            DCoef_2D  (ib, jb) = 0.
                            ECoef_2D  (ib, jb) = 1.
                            FCoef_2D  (ib, jb) = -1.
                            TiCoef_2D (ib, jb) = 0.
                        else
                            !ECoef_2D  (ib, jb) = Fcoef_2D(ii, ji)

                            DCoef_2D  (ib, jb) = -1.
                            ECoef_2D  (ib, jb) = 1.
                            FCoef_2D  (ib, jb) = 0.
                            TiCoef_2D (ib, jb) = 0.
                        endif
                    else
                        !TiCoef_2D (ib, jb) = TiCoef_2D (ii, ji)
                        DCoef_2D  (ib, jb) = 0.
                        ECoef_2D  (ib, jb) = 1.
                        FCoef_2D  (ib, jb) = 0.
                        TiCoef_2D (ib, jb) = TiCoef_2D (ii, ji)
                    endif

                endif cd2

            enddo di2
            enddo dj2
        endif

        nullify(DCoef_2D )
        nullify(ECoef_2D )
        nullify(FCoef_2D )
        nullify(TiCoef_2D)

        nullify(BoundaryFacesU)
        nullify(BoundaryFacesV)
        nullify(BoundaryPoints)


    end subroutine WaterLevel_NullGrad


    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a specific wave in the open boundary                         !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_ImposedWave

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        integer :: i, j, STAT_CALL

        integer, pointer, dimension (:,:)   :: BoundaryPoints

        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D, &
                                               ImposedElevation
        integer                             :: IUB, ILB, JUB, JLB

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        DCoef_2D  => Me%Coef%D2%D
        ECoef_2D  => Me%Coef%D2%E
        FCoef_2D  => Me%Coef%D2%F
        TiCoef_2D => Me%Coef%D2%Ti

        BoundaryPoints   => Me%External_Var%BoundaryPoints

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_ImposedWave")
        endif

cd4:    if (.not. Me%SubModel%ON                    .and.                               &
            .not. Me%ComputeOptions%Compute_Tide    .and.                               &
            .not. Me%ComputeOptions%InvertBarometer) then

            ImposedElevation => Me%WaterLevel%New

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do  j = JLB, JUB
            do  i = ILB, IUB

               !The water level values imposed in the open boundary points are maintained
                TiCoef_2D(i, j) = TiCoef_2D(i, j) * (1. - BoundaryPoints(i, j)) +            &
                                  ImposedElevation(i, j) * BoundaryPoints(i, j)

                DCoef_2D(i, j)  = DCoef_2D(i, j)  * (1. - BoundaryPoints(i, j))

                ECoef_2D(i, j)  = ECoef_2D(i, j)  * (1. - BoundaryPoints(i, j)) +            &
                                  1. * BoundaryPoints(i, j)

                FCoef_2D(i, j)  = FCoef_2D(i, j)  * (1. - BoundaryPoints(i, j))

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL


            nullify(ImposedElevation)

        else  cd4

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do  j = JLB, JUB
            do  i = ILB, IUB

               !The water level values imposed in the open boundary are set to zero
                TiCoef_2D(i, j) = TiCoef_2D(i, j) * (1. - BoundaryPoints(i, j))

                DCoef_2D(i, j)  = DCoef_2D(i, j)  * (1. - BoundaryPoints(i, j))

                ECoef_2D(i, j)  = ECoef_2D(i, j)  * (1. - BoundaryPoints(i, j)) +            &
                                  1. * BoundaryPoints(i, j)

                FCoef_2D(i, j)  = FCoef_2D(i, j)  * (1. - BoundaryPoints(i, j))

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL


        endif cd4


cd1:    if (Me%SubModel%ON) then

            ImposedElevation => Me%SubModel%Z

cd3:        if (.not. Me%SubModel%Set) then

                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR01a.'

            endif cd3

            CHUNK = CHUNK_J(JLB, JUB)


            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do  j = JLB, JUB
            do  i = ILB, IUB

               !The water level values imposed in the open boundary points are equal to the father model
                TiCoef_2D(i, j) = TiCoef_2D(i, j) + ImposedElevation(i, j) * BoundaryPoints(i, j)

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd1

cd2:    if (Me%ComputeOptions%Compute_Tide .or. Me%ComputeOptions%InvertBarometer) then


            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                &
                                     Me%CurrentTime,                                    &
                                     Me%External_Var%AtmosphericPressure,               &
                                     Me%ComputeOptions%AtmosphereCoef,                  &
                                     Me%ComputeOptions%InvertBaroCoef,                  &
                                     Me%ComputeOptions%AtmSeaLevelReference,            &
                                     STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR01.'


            call GetImposedElevation(Me%ObjOpenBoundary,                &
                                  ImposedElevation, STAT = STAT_CALL)


            if (STAT_CALL /= SUCCESS_) &
                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR03.'

            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do  j = JLB, JUB
            do  i = ILB, IUB

               !The water level values imposed in the open boundary points are equal to the water level computed in the OpenBoundary module
                TiCoef_2D(i, j) = TiCoef_2D(i, j) + ImposedElevation(i, j) * BoundaryPoints(i, j)


            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedElevation, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                Stop 'Sub. WaterLevel_ImposedWave - ModuleHydrodynamic - ERR04.'

        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_ImposedWave")
        endif


        !Nullify auxiliar variables
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D)
        nullify (BoundaryPoints)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_ImposedWave


    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for the water level               !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_CyclicBoundary

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        integer :: i, j

        integer, pointer, dimension (:,:)   :: BoundaryPoints

        real(8), dimension(:,:),   pointer  :: ECoef_2D
        real,    dimension(:,:),   pointer  :: DCoef_2D, FCoef_2D, TiCoef_2D, WaterLevel_New
        real(8), dimension(:),     pointer  :: b, bb, gam
        real,    dimension(:),     pointer  :: a, c, r, x, u, z

        real                                :: alpha,beta

        integer                             :: IUB, ILB, JUB, JLB !, status

        !AT integer                                :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        BoundaryPoints   => Me%External_Var%BoundaryPoints
        WaterLevel_New   => Me%WaterLevel%New

        DCoef_2D  => Me%Coef%D2%D
        ECoef_2D  => Me%Coef%D2%E
        FCoef_2D  => Me%Coef%D2%F
        TiCoef_2D => Me%Coef%D2%Ti

        a  => Me%Coef%D1%a
        b  => Me%Coef%D1%b
        bb => Me%Coef%D1%bb
        c  => Me%Coef%D1%c
        r  => Me%Coef%D1%r
        u  => Me%Coef%D1%u
        x  => Me%Coef%D1%x
        z  => Me%Coef%D1%z
        gam=> Me%Coef%D1%gam

        a  (:) = 0
        b  (:) = 0
        bb (:) = 0
        c  (:) = 0
        r  (:) = 0
        u  (:) = 0
        x  (:) = 0
        z  (:) = 0
        gam(:) = 0


        !End   - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_CyclicBoundary")
        endif

XY:     if (Me%Direction%XY == DirectionY_) then

            !AT CHUNK = CHUNK_J(JLB + 1, JUB - 1)

            !AT !! $OMP PARALLEL PRIVATE(j,beta,alpha) &
            !AT !! $OMP FIRSTPRIVATE(a,b,bb,c,r,u,x,z,gam)
            !AT !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:        do  j = JLB + 1, JUB - 1

cd2:            if   (BoundaryPoints(ILB, j) == Boundary .and. BoundaryPoints(IUB, j) == Boundary) then

                    !beta                  = DCoef_2D (IUB-1, j)
                    !alpha                 = FCoef_2D (ILB+1, j)

                    beta                  = DCoef_2D (ILB+1, j)
                    alpha                 = FCoef_2D (IUB-1, j)


                    DCoef_2D (ILB + 1, j) = 0.
                    FCoef_2D (IUB - 1, j) = 0.

                    a(ILB : IUB)      = DCoef_2D  (ILB:IUB, j)
                    b(ILB : IUB)      = ECoef_2D  (ILB:IUB, j)
                    c(ILB : IUB)      = FCoef_2D  (ILB:IUB, j)
                    r(ILB : IUB)      = TiCoef_2D (ILB:IUB, j)

                    call Tridag_cyclic(a, b, c, alpha, beta, r, x, gam, bb, u, z, ILB + 1, IUB - 1)

                    x(ILB) = x(IUB - 1)
                    x(IUB) = x(ILB + 1)


                else if (BoundaryPoints(ILB, j) /= Boundary .or. BoundaryPoints(IUB, j) /= Boundary ) then

                    a(ILB : IUB)      = DCoef_2D  (ILB:IUB, j)
                    b(ILB : IUB)      = ECoef_2D  (ILB:IUB, j)
                    c(ILB : IUB)      = FCoef_2D  (ILB:IUB, j)
                    r(ILB : IUB)      = TiCoef_2D (ILB:IUB, j)

                    call tridag(a,b,c,r,x,gam, ILB + 1, IUB - 1)

                    if (Me%CyclicBoundary%Direction == DirectionY_ .or. &
                        Me%CyclicBoundary%Direction == DirectionXY_) then

                        if (BoundaryPoints(ILB, j) == Boundary) x(ILB) = x(IUB - 1)
                        if (BoundaryPoints(IUB, j) == Boundary) x(IUB) = x(ILB + 1)

                    endif

                endif cd2

                WaterLevel_New(ILB:IUB, j) = x(ILB:IUB)


            enddo do1
            !AT !! $OMP END DO
            !AT !! $OMP END PARALLEL

            if (Me%CyclicBoundary%Direction == DirectionX_ .or. &
                Me%CyclicBoundary%Direction == DirectionXY_) then

                WaterLevel_New(ILB:IUB, JLB) = WaterLevel_New(ILB:IUB, JUB - 1)
                WaterLevel_New(ILB:IUB, JUB) = WaterLevel_New(ILB:IUB, JLB + 1)

            endif


        else if (Me%Direction%XY == DirectionX_) then XY

            !AT CHUNK = CHUNK_I(ILB + 1, IUB - 1)

            !AT !! $OMP PARALLEL PRIVATE(i,beta,alpha)
            !AT !! $OMP FIRSTPRIVATE(a,b,bb,c,r,u,x,z,gam)
            !AT !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2:        do  i = ILB + 1, IUB - 1

cd3:            if   (BoundaryPoints(i, JLB) == Boundary .and. BoundaryPoints(i, JUB) == Boundary) then

                    !beta                  = DCoef_2D (i, JUB-1)
                    !alpha                 = FCoef_2D (i, JLB+1)

                    beta                  = DCoef_2D (i, JLB+1)
                    alpha                 = FCoef_2D (i, JUB-1)

                    DCoef_2D (i, JLB + 1) = 0.
                    FCoef_2D (i, JUB - 1) = 0.

                    a(JLB : JUB)      = DCoef_2D  (i, JLB:JUB)
                    b(JLB : JUB)      = ECoef_2D  (i, JLB:JUB)
                    c(JLB : JUB)      = FCoef_2D  (i, JLB:JUB)
                    r(JLB : JUB)      = TiCoef_2D (i, JLB:JUB)


                    call Tridag_cyclic(a, b, c, alpha, beta, r, x, gam, bb, u, z, JLB + 1, JUB - 1)

                    x(JLB) = x(JUB - 1)
                    x(JUB) = x(JLB + 1)

                else if (BoundaryPoints(i, JLB) /= Boundary .or. BoundaryPoints(i, JUB) /= Boundary ) then cd3

                    a(JLB : JUB)      = DCoef_2D  (i, JLB:JUB)
                    b(JLB : JUB)      = ECoef_2D  (i, JLB:JUB)
                    c(JLB : JUB)      = FCoef_2D  (i, JLB:JUB)
                    r(JLB : JUB)      = TiCoef_2D (i, JLB:JUB)

                    call tridag(a,b,c,r,x,gam, JLB + 1, JUB - 1)

                    if (Me%CyclicBoundary%Direction == DirectionX_ .or. &
                        Me%CyclicBoundary%Direction == DirectionXY_) then

                        if (BoundaryPoints(i, JLB) == Boundary) x(JLB) = x(JUB - 1)
                        if (BoundaryPoints(i, JUB) == Boundary) x(JUB) = x(JLB + 1)

                    endif

                endif cd3

                WaterLevel_New(i, JLB:JUB) = x(JLB:JUB)


            enddo do2
            !AT !! $OMP END DO
            !AT !! $OMP END PARALLEL

            if (Me%CyclicBoundary%Direction == DirectionY_ .or. &
                Me%CyclicBoundary%Direction == DirectionXY_) then

                WaterLevel_New(ILB, JLB:JUB) = WaterLevel_New(IUB-1, JLB:JUB)
                WaterLevel_New(IUB, JLB:JUB) = WaterLevel_New(ILB+1, JLB:JUB)

            endif

        endif XY

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_CyclicBoundary")
        endif

        !Nullify auxiliar variables
        nullify (ECoef_2D, DCoef_2D, FCoef_2D, TiCoef_2D, BoundaryPoints, WaterLevel_New)

        nullify (a, b, bb, c, r, u, x, z, gam)


        !----------------------------------------------------------------------

    End Subroutine WaterLevel_CyclicBoundary


    subroutine CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux, AuxExplicit, DT_AreaCell1,                      &
                             DT_AreaCell2, I, J, iSouth, jWest,                          &
                             Dcoef_2D, ECoef_2D, ECoef_2D_Aux, FCoef_2D, AuxImplicit, Direction)

        !Arguments------------------------------------------------------------
        real,    dimension(:,:),             pointer  :: TiCoef_2D, TiCoef_2D_Aux
        real   , intent (IN)                          :: AuxExplicit,                    &
                                                         DT_AreaCell1, DT_AreaCell2
        integer, intent (IN)                          :: I, J, iSouth, jWest


        real(8), dimension(:,:),   optional, pointer  :: ECoef_2D, ECoef_2D_Aux
        real,    dimension(:,:),   optional, pointer  :: DCoef_2D, FCoef_2D
        real   , intent (IN),      optional           :: AuxImplicit
        integer, intent (IN),      optional           :: Direction
        !Local---------------------------------------------------------------------


        integer, pointer, dimension (:,:)   :: BoundaryPoints

        integer                             :: IUB, ILB, JUB, JLB, I_Down, J_Down
        integer                             :: Direction_
        logical                             :: ComputeFace

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        BoundaryPoints   => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name

        ComputeFace = .true.
        I_Down      = iSouth
        J_Down      = jWest

        if (Present(Direction)) then

            Direction_ = Direction

        else

            Direction_ = Me%Direction%XY

        endif


ixy:    if (Direction_ == DirectionY_ ) then

iby:        if   (BoundaryPoints(ILB, j) == Boundary .and. BoundaryPoints(IUB, j) == Boundary &
                  .and. (I ==ILB + 1 .or. I== IUB)) then

                if (I == ILB + 1) then

                    I_Down = IUB - 1

                endif

                if (I == IUB) then

                    ComputeFace = .false.

                endif

            endif iby

        else if (Direction_ == DirectionX_) then ixy


ibx:        if   (BoundaryPoints(i, JLB) == Boundary .and. BoundaryPoints(i, JUB) == Boundary &
                  .and. (J ==JLB + 1 .or. J == JUB)) then

                if (J == JLB + 1) then

                    J_Down = JUB - 1

                endif

                if (J == JUB) then

                    ComputeFace = .false.

                endif

            endif ibx

        endif ixy

        if (ComputeFace) then


            !Compute the coeficients of linear system equations for the I,J Z cell
            ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
            if (present(DCoef_2D))                                                       &
                DCoef_2D(I,J)         = DCoef_2D(I,J)  - AuxImplicit * DT_AreaCell2

            ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
            if (present(ECoef_2D))                                                       &
                ECoef_2D (I,J)        = ECoef_2D(I,J)  + AuxImplicit * DT_AreaCell2

            ![m]                   = [m]         + [m^3/s] * [s/m^2]
            TiCoef_2D(I,J)            = TiCoef_2D(I,J) + AuxExplicit * DT_AreaCell2

            !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

            ![ ]                   = [ ]                     + [m^2/s] * [s/m^2]
            if (present(FCoef_2D))                                                       &
                FCoef_2D(I_Down, J_Down) = FCoef_2D(I_Down, J_Down)  - AuxImplicit * DT_AreaCell1

            ![ ]                   = [ ]                     + [m^2/s] * [s/m^2]
            if (present(ECoef_2D_Aux))                                                       &
                ECoef_2D_Aux(I_Down, J_Down) = AuxImplicit * DT_AreaCell1

            ![m]                   = [m]                     + [m^3/s] * [s/m^2]
            TiCoef_2D_Aux(I_Down, J_Down)    = - AuxExplicit * DT_AreaCell1

        endif

        !Nullify auxiliar variables
        nullify (BoundaryPoints)


        !----------------------------------------------------------------------

    End Subroutine CyclicCoef2D



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for a vectorial property          !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine CyclicBoundVectNormal ( Vector, VectorD)

        !Arguments------------------------------------------------------------

        real,    dimension (:,:,:), pointer, optional :: Vector
        real(8), dimension (:,:,:), pointer, optional :: VectorD

        !Local---------------------------------------------------------------------
        integer, dimension (:,:  ), pointer :: BoundaryPoints
        integer                             :: IUB, ILB, JUB, JLB, KLB, KUB
        integer                             :: i, j, k

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB

        BoundaryPoints => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name


        !Normal boundary faces --------------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CyclicBoundVectNormal")
        endif

cd1:    if (Me%Direction%XY == DirectionX_) then

            CHUNK = CHUNK_I(ILB, IUB)

            !$OMP PARALLEL PRIVATE(i,k)
do1:        do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2:        do i = ILB, IUB

                if (BoundaryPoints(i, JUB) == Boundary .or.                              &
                    BoundaryPoints(i, JLB) == Boundary) then

                    if (present(Vector )) Vector  (i, JUB + 1, k) = Vector (i, JLB + 2, k)
                    if (present(VectorD)) VectorD (i, JUB + 1, k) = VectorD(i, JLB + 2, k)


                    if (present(Vector )) Vector  (i, JLB, k) = Vector (i, JUB - 1, k)
                    if (present(VectorD)) VectorD (i, JLB, k) = VectorD(i, JUB - 1, k)


                    if (present(Vector )) Vector  (i, JUB, k) = Vector (i, JLB + 1, k)
                    if (present(VectorD)) VectorD (i, JUB, k) = VectorD(i, JLB + 1, k)

                endif

            enddo do2
            !$OMP END DO NOWAIT
            enddo do1
            !$OMP END PARALLEL


        endif cd1


cd2:    if (Me%Direction%XY == DirectionY_) then

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(j,k)
do3:        do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do4:        do j = JLB, JUB

                if (BoundaryPoints(IUB, j) == Boundary .or.                              &
                    BoundaryPoints(ILB, j) == Boundary) then
                    if (present(Vector )) Vector  (IUB+1, j, k) = Vector (ILB + 2, j, k)
                    if (present(VectorD)) VectorD (IUB+1, j, k) = VectorD(ILB + 2, j, k)


                    if (present(Vector )) Vector  (ILB  , j, k) = Vector (IUB - 1, j, k)
                    if (present(VectorD)) VectorD (ILB  , j, k) = VectorD(IUB - 1, j, k)

                    if (present(Vector )) Vector  (IUB  , j, k) = Vector (ILB + 1, j, k)
                    if (present(VectorD)) VectorD (IUB  , j, k) = VectorD(ILB + 1, j, k)

                endif

            enddo do4
            !$OMP END DO NOWAIT
            enddo do3
            !$OMP END PARALLEL

        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CyclicBoundVectNormal")
        endif

        nullify(BoundaryPoints)


        !----------------------------------------------------------------------

    End Subroutine CyclicBoundVectNormal

    !--------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for a vectorial property          !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine CyclicBoundVectTangential ( Vector, VectorD)

        !Arguments------------------------------------------------------------

        real,    dimension (:,:,:), pointer, optional :: Vector
        real(8), dimension (:,:,:), pointer, optional :: VectorD

        !Local---------------------------------------------------------------------
        integer, dimension (:,:  ), pointer :: BoundaryPoints
        integer                             :: IUB, ILB, JUB, JLB, KLB, KUB
        integer                             :: i, j, k

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB

        BoundaryPoints => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name

        !Tangential boundary faces --------------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CyclicBoundVectTangential")
        endif

cd1:    if (Me%Direction%XY == DirectionY_) then

            CHUNK = CHUNK_I(ILB, IUB)
            !$OMP PARALLEL PRIVATE(i,k)

do1:        do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do2:        do i = ILB, IUB

                if (BoundaryPoints(i, JUB) == Boundary) then

                    if (present(Vector )) Vector  (i, JUB, k) = Vector (i, JLB + 1, k)
                    if (present(VectorD)) VectorD (i, JUB, k) = VectorD(i, JLB + 1, k)

                endif

                if (BoundaryPoints(i, JLB) == Boundary) then

                    if (present(Vector )) Vector  (i, JLB, k) = Vector (i, JUB - 1, k)
                    if (present(VectorD)) VectorD (i, JLB, k) = VectorD(i, JUB - 1, k)

                endif

            enddo do2
            !$OMP END DO NOWAIT
            enddo do1
            !$OMP END PARALLEL

        endif cd1


cd2:    if (Me%Direction%XY == DirectionX_) then

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(j,k)
do3:        do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do4:        do j = JLB, JUB

                if (BoundaryPoints(IUB, j) == Boundary) then
                    if (present(Vector )) Vector  (IUB, j, k) = Vector (ILB + 1, j, k)
                    if (present(VectorD)) VectorD (IUB, j, k) = VectorD(ILB + 1, j, k)
                endif

                if (BoundaryPoints(ILB, j) == Boundary) then
                    if (present(Vector )) Vector  (ILB, j, k) = Vector (IUB - 1, j, k)
                    if (present(VectorD)) VectorD (ILB, j, k) = VectorD(IUB - 1, j, k)
                endif

            enddo do4
            !$OMP END DO NOWAIT
            enddo do3
            !$OMP END PARALLEL

        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CyclicBoundVectTangential")
        endif

        nullify(BoundaryPoints)

        !----------------------------------------------------------------------

    End Subroutine CyclicBoundVectTangential

    !--------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine imposed a Cyclic boundary condition for vertical velocity or flux    !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine CyclicBoundVertical (Vector, VectorD)

        !Arguments------------------------------------------------------------

        real,    dimension (:,:,:), pointer, optional :: Vector
        real(8), dimension (:,:,:), pointer, optional :: VectorD

        !Local---------------------------------------------------------------------
        integer, dimension (:,:  ), pointer :: BoundaryPoints
        integer                             :: IUB, ILB, JUB, JLB, KLB, KUB
        integer                             :: i, j, k

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB

        BoundaryPoints => Me%External_Var%BoundaryPoints

        !End   - Shorten variables name

        !Tangential boundary faces --------------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CyclicBoundVertical")
        endif

f1:     if (Me%CyclicBoundary%Direction == DirectionX_ .or. &
            Me%CyclicBoundary%Direction == DirectionXY_)  then

            CHUNK = CHUNK_I(ILB, IUB)

            !$OMP PARALLEL PRIVATE(i,k)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do1:        do i = ILB, IUB

                if (BoundaryPoints(i, JUB) == Boundary) then

do2:               do k = KLB, KUB + 1

                        if (present(Vector )) Vector  (i, JUB, k) = Vector (i, JLB + 1, k)
                        if (present(VectorD)) VectorD (i, JUB, k) = VectorD(i, JLB + 1, k)

                    enddo do2

                endif

                if (BoundaryPoints(i, JLB) == Boundary) then

do3:                do k = KLB, KUB + 1

                        if (present(Vector )) Vector  (i, JLB, k) = Vector (i, JUB - 1, k)
                        if (present(VectorD)) VectorD (i, JLB, k) = VectorD(i, JUB - 1, k)

                    enddo do3

                endif

            enddo do1
            !$OMP END DO
            !$OMP END PARALLEL

        endif f1


f2:     if (Me%CyclicBoundary%Direction == DirectionY_ .or. &
            Me%CyclicBoundary%Direction == DirectionXY_)  then

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(j,k)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do4:        do j = JLB, JUB

                if (BoundaryPoints(IUB, j) == Boundary) then

do5:                do k = KLB, KUB + 1

                        if (present(Vector )) Vector  (IUB, j, k) = Vector (ILB + 1, j, k)
                        if (present(VectorD)) VectorD (IUB, j, k) = VectorD(ILB + 1, j, k)

                    enddo do5

                endif

                if (BoundaryPoints(ILB, j) == Boundary) then

do6:               do k = KLB, KUB + 1

                        if (present(Vector )) Vector  (ILB, j, k) = Vector (IUB - 1, j, k)
                        if (present(VectorD)) VectorD (ILB, j, k) = VectorD(IUB - 1, j, k)

                    enddo do6

                endif

            enddo do4
            !$OMP END DO
            !$OMP END PARALLEL

        endif f2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CyclicBoundVertical")
        endif

        nullify(BoundaryPoints)

        !----------------------------------------------------------------------

    End Subroutine CyclicBoundVertical

    !--------------------------------------------------------------------------




    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the Sommerfeld radition condition for the open boundary      !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_FlatherWindWave   ( WaterFlux_XY, WaterFlux_YX,               &
                                     WaterColumnUV, DUX_VY, DVY_UX, DYY_XX,             &
                                     ComputeFaces3D_UV, ComputeFaces3D_VU,              &
                                     BoundaryFacesUV, kfloor_UV, kfloor_VU,             &
                                     di, dj, DirectionXY, ImplicitFaces)

        !Arguments------------------------------------------------------------

        real(8), dimension (:,:,:), pointer :: WaterFlux_XY, WaterFlux_YX
        real,    dimension (:,:  ), pointer :: WaterColumnUV, DUX_VY, DVY_UX, DYY_XX
        integer, dimension (:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension (:,:  ), pointer :: BoundaryFacesUV, Kfloor_UV, kfloor_VU
        integer                             :: di, dj, DirectionXY
        logical                             :: ImplicitFaces


        !Local---------------------------------------------------------------------
        integer                             :: i, j, k
        integer, pointer, dimension (:,:)   :: BoundaryPoints


        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D,         &
                                               ImposedElevation,                      &
                                               ImposedVelocity,                       &
                                               WaterLevel_New, BoundaryReferenceLevel,&
                                               RadCoef_2D, TiRadCoef_2D, WaterLevel_Old


        real,    dimension(:,:,:), pointer  :: SZZ

        real,    dimension(:,:  ), pointer  :: WaveCelerityField, Bathymetry

        real                                :: WaveDirection, AverageValue


        real                                :: D1, D2, E1, E2, E3, E4, E5, F1,  &
                                               F2, T1, T2, T3, T4, A_Aux, B_Aux,&
                                               HT_boundary, Wave_Celerity,      &
                                               DT_Elevation, WaveEntering,      &
                                               OldWaveEntering, ReferenceLevel

        real(8)                             :: FluxXY_L, FluxYX_L, FluxMod_L,   &
                                               FluxXY_E, FluxYX_E,              &
                                               FluxXY_T, FluxYX_T,              &
                                               Flux_WestSouth, Flux_EastNorth,  &
                                               Flux_SouthWest, Flux_NorthEast,  &
                                               XY_Component_L, XY_Component_E,  &
                                               XY_Component_Cart_E,             &
                                               YX_Component_Cart_E,             &
                                               WaterFluxBoundary,               &
                                               LeavingVelocity

        real                                :: CellRotationX, EnteringWaveDirection, WaveCellDir


        real                                :: MinLeavingComponent,  MinLeavingVelocity


        integer                             :: IUB, ILB, JUB, JLB, KUB,         &
                                               i1, i2, i3, i4, j1, j2, j3, j4,  &
                                               db, kbottom,                     &
                                               ib, jb, i_int, j_int


        logical                             :: Compute_Tide

        integer                             :: status

        integer                             :: DirX, DirY, DirBound

        integer                             :: CHUNK

        real                                :: dx1, dx2, dx3, AbsorbCoef


        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DT_Elevation  =  Me%WaterLevel%DT

        DCoef_2D      => Me%Coef%D2%D
        ECoef_2D      => Me%Coef%D2%E
        FCoef_2D      => Me%Coef%D2%F
        TiCoef_2D     => Me%Coef%D2%Ti

        RadCoef_2D    => Me%Coef%D2%Rad
        TiRadCoef_2D  => Me%Coef%D2%TiRad

        SZZ                  => Me%External_Var%SZZ

        !Geometry
!        WaterColumnUV        => Me%External_Var%WaterColumnUV
!        DUX_VY               => Me%External_Var%DUX_VY
!        DVY_UX               => Me%External_Var%DVY_UX
!        DYY_XX               => Me%External_Var%DYY_XX

!        kfloor_UV            => Me%External_Var%kfloor_UV
!        kfloor_VU            => Me%External_Var%kfloor_VU



        !Flow
!        WaterFlux_XY    => Me%WaterFluxes%XY
!        WaterFlux_YX    => Me%WaterFluxes%YX
        WaterLevel_New  => Me%WaterLevel%New
        WaterLevel_Old  => Me%WaterLevel%Old


!        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        BoundaryPoints    => Me%External_Var%BoundaryPoints

!        ComputeFaces3D_UV =>  Me%External_Var%ComputeFaces3D_UV
!        ComputeFaces3D_VU =>  Me%External_Var%ComputeFaces3D_VU

        EnteringWaveDirection =  Me%ComputeOptions%EnteringWaveDirection

        MinLeavingComponent   =  Me%ComputeOptions%MinLeavingComponent
        MinLeavingVelocity    =  Me%ComputeOptions%MinLeavingVelocity


        Compute_Tide          = Me%ComputeOptions%Compute_Tide

        call GetOpenBoundParameter(Me%ObjOpenBoundary, DirectionX = DirX,           &
                                                       DirectionY = DirY, STAT= status)

        if (status /= SUCCESS_)                                                     &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR003")

        if      (DirectionXY == DirectionX_) then

            DirBound = DirX

        else if (DirectionXY == DirectionY_) then

            DirBound = DirY

        endif


        !End   - Shorten variables name

        !Gets Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR005")

cd0:    if (Me%ComputeOptions%LocalSolution == Gauge_) then


            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                &
                                     Me%CurrentTime,                                    &
                                     Me%External_Var%AtmosphericPressure,               &
                                     Me%ComputeOptions%AtmosphereCoef,                  &
                                     Me%ComputeOptions%InvertBaroCoef,                  &
                                     Me%ComputeOptions%AtmSeaLevelReference,            &
                                     STAT        = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR10")


            call GetImposedElevation(Me%ObjOpenBoundary,                        &
                                      ImposedElevation, STAT = status)


            if (status /= SUCCESS_)                                                          &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR20")

            call GetOpenBoundParameter(Me%ObjOpenBoundary, DirectionX = DirX,   &
                                                                        DirectionY = DirY, STAT= status)

            if (status /= SUCCESS_)                                                          &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR30")



            call GetImposedVelocity   (Me%ObjOpenBoundary, ImposedVelocity,     &
                                       DirBound, STAT= status)

            if (status /= SUCCESS_)                                                          &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR40")

            !PCL

    cd23:   if (Me%Relaxation%RefBoundWaterLevel) then

                call GetAssimilationField(Me%ObjAssimilation,                           &
                                          ID              = WaterLevel_,                &
                                          Field2D         = BoundaryReferenceLevel,     &
                                          STAT            = status)

                if (status /= SUCCESS_)                                                      &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR50")


            else   cd23

                call GetBoundaryReferenceLevel(Me%ObjOpenBoundary,              &
                                               BoundaryReferenceLevel, STAT = status)

                if (status /= SUCCESS_)                                                      &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR60")


            endif cd23

        elseif (Me%ComputeOptions%LocalSolution == AssimilationField_) then cd0


            call GetAssimilationField(Me%ObjAssimilation,                           &
                                      ID              = WaterLevel_,                &
                                      Field2D         = ImposedElevation,           &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR70")


            if (.not.associated(ImposedVelocity)) then
                allocate(ImposedVelocity(ILB:IUB,JLB:JUB))
            endif

            ImposedVelocity(:,:)        = 0.

            if (.not.associated(BoundaryReferenceLevel)) then
                allocate(BoundaryReferenceLevel(ILB:IUB,JLB:JUB))
            endif
            BoundaryReferenceLevel(:,:) = 0.

        else  cd0

            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR80")

        endif cd0

        if  (Me%WindWaves%CelerityType == AnalyticWaves_) then

            if (Me%ComputeOptions%LocalSolution == AssimilationField_) then

                call GetWaveCelerityField(AssimilationID = Me%ObjAssimilation,          &
                                          ID              = WaterLevel_,                &
                                          WaveCelerity    = WaveCelerityField,          &
                                          WaveDirection   = WaveDirection,              &
                                          AverageValue    = AverageValue,               &
                                          STAT            = status)

                if (status /= SUCCESS_)                                                 &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR90")

                EnteringWaveDirection  = WaveDirection

                BoundaryReferenceLevel(:,:) = AverageValue

            else

                write(*,*) 'Define the analytic celerity in assimilation_x.dat for property WaterLevel_'
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR100")

            endif


        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "WaterLevel_FlatherWindWave")

        !$OMP PARALLEL PRIVATE(i,j,kbottom,HT_Boundary,db,i1,i2,i3,i4,j1,j2,j3,j4,Flux_WestSouth)   &
        !$OMP PRIVATE(Flux_EastNorth,Flux_SouthWest,Flux_NorthEast,ib,jb,ReferenceLevel)            &
        !$OMP PRIVATE(WaveEntering,OldWaveEntering,i_int,j_int,Wave_Celerity,XY_Component_Cart_E)   &
        !$OMP PRIVATE(YX_Component_Cart_E,FluxXY_E,FluxYX_E,FluxXY_T,FluxYX_T,FluxXY_L,FluxYX_L)    &
        !$OMP PRIVATE(FluxMod_L,LeavingVelocity,XY_Component_L,XY_Component_E)                      &
        !$OMP PRIVATE(WaveCellDir, EnteringWaveDirection, CellRotationX)                             &
        !$OMP PRIVATE(A_aux,T3,B_aux,D1,D2,E1,E2,E3,E4,F1,F2,T1,T2,T4)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB


!            !In this way if in a boundary point the elevation is not change
!            !due to the radiation condition then
!            !the old elevation is maintain
cd9:        if (BoundaryPoints(i, j) == Boundary) then

                TiCoef_2D(i, j) = WaterLevel_New(i, j)

                DCoef_2D (i, j) = 0.

                ECoef_2D (i, j) = 1.

                FCoef_2D (i, j) = 0.

            endif cd9

cd1:        if  (BoundaryFacesUV  (i, j     )  == Boundary     .and.                     &
                 ComputeFaces3D_UV(i, j, KUB)  == Covered      .and.                     &
                (BoundaryPoints   (i, j)       == Not_Boundary .or.                      &
                 BoundaryPoints   (i-di, j-dj) == Not_Boundary)) then


                kbottom = kfloor_UV(i, j)

               ![m] = [m^2]/[m]
                HT_boundary = WaterColumnUV(i, j)


                !Direction - Leaving wave
                if (BoundaryPoints(i, j) == Boundary) then

                    !West or South cell is interior and
                    !the East or North cell is boundary
                    db = 1

                    i1 = i - di
                    i2 = i
                    i3 = i - di
                    i4 = i + dj - di
                    j1 = j - dj
                    j2 = j
                    j3 = j - dj
                    j4 = j - dj + di


                else

                    !West or South cell is boundary and
                    !the East or North cell is interior
                    db = 0

                    i1 = i
                    i2 = i + di
                    i3 = i
                    i4 = i + dj
                    j1 = j
                    j2 = j + dj
                    j3 = j
                    j4 = j + di


                endif


                !Boundary cell
                !X direction (di=0,dj=1) - boundary West  cell (db=0) => (ib,jb)=(i, j-1)
                !X direction (di=0,dj=1) - boundary East  cell (db=1) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - boundary South cell (db=0) => (ib,jb)=(i-1, j)
                !Y direction (di=1,dj=0) - boundary North cell (db=1) => (ib,jb)=(i, j)

                ib    = i - di * (1 - db)
                jb    = j - dj * (1 - db)

                !Interior cell next to a boundary face
                !X direction (di=0,dj=1) - Interior East  cell (db=0) => (ib,jb)=(i, j)
                !X direction (di=0,dj=1) - Interior West  cell (db=1) => (ib,jb)=(i, j-1)
                !Y direction (di=1,dj=0) - Interior North cell (db=0) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - Interior South cell (db=1) => (ib,jb)=(i-1, j)

                i_int = i - di * db
                j_int = j - dj * db


                !total West or South face water flux
                Flux_WestSouth      = 0.

cd2:            if (ComputeFaces3D_UV(i1, j1, KUB) == Covered) then

                    kbottom = kfloor_UV(i1, j1)

                    do  k = kbottom, KUB

                        Flux_WestSouth = Flux_WestSouth + WaterFlux_XY(i1, j1, k)

                    enddo

                endif cd2


                !total East or North face water flux
                Flux_EastNorth      = 0.

cd3:            if (ComputeFaces3D_UV(i2, j2, KUB) == Covered) then

                    kbottom = kfloor_UV(i2, j2)

                    do  k = kbottom, KUB

                        Flux_EastNorth = Flux_EastNorth + WaterFlux_XY(i2, j2, k)

                    enddo

                endif cd3


                !total South or West face water flux
                Flux_SouthWest      = 0.

cd4:            if (ComputeFaces3D_VU(i3, j3, KUB) == Covered) then

                    kbottom = kfloor_VU(i3, j3)

                    do  k = kbottom, KUB

                        Flux_SouthWest = Flux_SouthWest + WaterFlux_YX(i3, j3, k)

                    enddo

                endif cd4


                !total North or East face water flux

                Flux_NorthEast      = 0.

cd5:            if (ComputeFaces3D_VU(i4, j4, KUB) == Covered) then

                    kbottom = kfloor_VU(i4, j4)

                    do  k = kbottom, KUB

                        Flux_NorthEast = Flux_NorthEast + WaterFlux_YX(i4, j4, k)

                    enddo

                endif cd5

                dx1 = DUX_VY(i_int, j_int)
                dx2 = DUX_VY(ib,    jb   )
                dx3 = dx1 + dx2

                !boundary condition is done for the cell face so the water level
                !need to be interpolated form the cell centers to the boundary face
                ReferenceLevel = (BoundaryReferenceLevel(ib,    jb   ) * dx1 +            &
                                  BoundaryReferenceLevel(i_int, j_int) * dx2 ) / dx3


                WaveEntering   = (ImposedElevation(ib,    jb   ) * dx1 +            &
                                  ImposedElevation(i_int, j_int) * dx2 ) / dx3

                WaveEntering   = WaveEntering - ReferenceLevel

                !The local solution Gauge_ only have data for water level boundary cell
                !Gauge_ local solution does not provide a water level field like the assimilation and submodel local solutions
                !This problem need to be solved in the future.
                if (Me%ComputeOptions%LocalSolution == Gauge_) then
                    WaveEntering = ImposedElevation(ib, jb) - ReferenceLevel
                endif


                !The wave Celerity compute in the boundary face
                ![m/s] = [m/s^2*m]^.5 = [m/s]

                if      (Me%WindWaves%CelerityType == LongWaves_) then

                    Wave_Celerity = sqrt(Gravity * HT_Boundary)

                elseif  (Me%WindWaves%CelerityType == Constant_ ) then

                    Wave_Celerity = Me%WindWaves%CelerityConstant

                elseif  (Me%WindWaves%CelerityType == AnalyticWaves_) then


                    Wave_Celerity = (WaveCelerityField(ib,    jb   ) * dx1 +            &
                                     WaveCelerityField(i_int, j_int) * dx2 ) / dx3

                endif

               !If was defined a entering wave then
cd15:           if (Me%ComputeOptions%ComputeEnteringWave) then

                    call GetCellRotation(Me%ObjHorizontalGrid, ib, jb, CellRotationX, STAT = status)

                    if (status /= SUCCESS_) then
                        call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR95")
                    endif

                    WaveCellDir = EnteringWaveDirection - CellRotationX

                    !Direction - Entering wave - Cartesian referencial
                    XY_Component_Cart_E  = real(dj) * cos(WaveCellDir) +                &
                                           real(di) * sin(WaveCellDir)
                    YX_Component_Cart_E  = real(dj) * sin(WaveCellDir) +                &
                                           real(di) * cos(WaveCellDir)
                                           !
                    if (abs(XY_Component_Cart_E) < MinLeavingComponent) then
                        XY_Component_Cart_E = 0.
                        if (YX_Component_Cart_E > 0) then
                            YX_Component_Cart_E =  1.
                        else
                            YX_Component_Cart_E = -1.
                        endif
                    endif
                    if (abs(YX_Component_Cart_E) < MinLeavingComponent) then
                        YX_Component_Cart_E = 0.
                        if (XY_Component_Cart_E > 0) then
                            XY_Component_Cart_E =  1.
                        else
                            XY_Component_Cart_E = -1.
                        endif
                    endif
!

                    !If the flow of the entering wave is going from the inside the domain to the
                    !outside then the entering flow is consider be zero

                    if ((XY_Component_Cart_E <= 0 .and. db == 0) .or.  &  !West or South cell boundary
                        (XY_Component_Cart_E >= 0 .and. db == 1)) then    !East or North cell boundary

                        XY_Component_Cart_E  = 0.

                        WaveEntering         = 0.
                        OldWaveEntering      = 0.

                    endif


                    !Flow - Entering wave - Cartesian referencial. In necessary to compute
                    !the entering fluxes in cartesian referencial to be consistent witht the
                    !total fluxes

                    ![m^3/s] = [m] * [m/s] * [ ] * [m]
                    FluxXY_E = WaveEntering * Wave_Celerity *  &
                               XY_Component_Cart_E * DVY_UX(i, j)

                    ![m^3/s] = [m] * [m/s] * [ ] * [m]
                    FluxYX_E = WaveEntering * Wave_Celerity *  &
                               YX_Component_Cart_E * DUX_VY(i, j)

                else cd15

                    XY_Component_Cart_E  = 0.

                    WaveEntering         = 0.
                    OldWaveEntering      = 0.

                    FluxXY_E  = 0.
                    FluxYX_E  = 0.

                endif cd15

                !Land boundary = No entering wave
                if ((Bathymetry(ib-di,jb-dj) <= -60.)     .or.                           &
                    (Bathymetry(ib+di,jb+dj) <= -60.)     .or.                           &
                    (Bathymetry(ib-dj,jb-di) <= -60.)     .or.                           &
                    (Bathymetry(ib+dj,jb+di) <= -60.))   then

                    XY_Component_Cart_E  = 0.

                    WaveEntering         = 0.
                    OldWaveEntering      = 0.

                    FluxXY_E  = 0.
                    FluxYX_E  = 0.

                endif

                !The leaving wave direction is compute in the center of the
                !first interior cell
                FluxXY_T = (Flux_WestSouth + Flux_EastNorth) / 2.


                FluxYX_T = (Flux_SouthWest + Flux_NorthEast) / 2.


                !Flow - Leaving wave - Cartesian referencial
                FluxXY_L = FluxXY_T - FluxXY_E
                FluxYX_L = FluxYX_T - FluxYX_E

                !FluxMod_L = pythag (FluxXY_L, FluxYX_L)
                FluxMod_L = (FluxXY_L**2.+FluxYX_L**2.)**0.5

                LeavingVelocity   = abs(FluxXY_T) / DYY_XX(i, j) / HT_Boundary

                if (LeavingVelocity < MinLeavingVelocity .and. abs(FluxXY_E) < 1.e-16)    then

                    !Null gradient
                    ECoef_2D (ib, jb) = 1
                    TiCoef_2D(ib, jb) = 0

                    !west and south boundary
                    if      (db == 0) then
                        DCoef_2D (ib, jb) = 0.
                        FCoef_2D (ib, jb) = -1.
                    !East and North boundary
                    elseif  (db == 1) then
                        DCoef_2D (ib, jb) = -1.
                        FCoef_2D (ib, jb) = 0.
                    else
                        stop "WaterLevel_FlatherWindWave - Hydrodynamic - ERR110"
                    endif

                    !ends do cycle
                    cycle

                else

                    LeavingVelocity   = FluxMod_L / DYY_XX(i, j) / HT_Boundary

                    if (LeavingVelocity > MinLeavingVelocity) then
                        XY_Component_L = abs(FluxXY_L) / FluxMod_L
                    else
                        XY_Component_L = 1.
                    endif

                endif
                !If the flow of the leaving wave is going from inside the domain to the
                !outside then the flow must be positive in the oposite condition it must
                !be negative
                if (db == 0) then  !West or South cell boundary
                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_E  = + abs(XY_Component_Cart_E)

                    XY_Component_L  = - abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_WestSouth


                else if (db == 1) then !East or North cell boundary

                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_E  = - abs(XY_Component_Cart_E)

                    XY_Component_L  = + abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_EastNorth


                endif


                if (abs(XY_Component_L)  > 1. )  then
                    !!!! $OMP CRITICAL (WLFWW1_STOP01)
                    Stop 'XY_Component_L = 1'
                    !!!! $OMP END CRITICAL (WLFWW1_STOP01)
                endif

                AbsorbCoef = 1.

                !Test absorption boundaries
                ! -65   80%
                ! -70   60%
                ! -75   50%
                ! -80   40%
                ! -85   10%
                if     (Bathymetry(ib-1,jb) == -65. .or. Bathymetry(ib+1,jb) == -65. .or. &
                        Bathymetry(ib,jb-1) == -65. .or. Bathymetry(ib,jb+1) == -65. ) then
                    AbsorbCoef = 0.8
                elseif (Bathymetry(ib-1,jb) == -70. .or. Bathymetry(ib+1,jb) == -70. .or. &
                        Bathymetry(ib,jb-1) == -70. .or. Bathymetry(ib,jb+1) == -70. ) then
                    AbsorbCoef = 0.6
                elseif (Bathymetry(ib-1,jb) == -75. .or. Bathymetry(ib+1,jb) == -75. .or. &
                        Bathymetry(ib,jb-1) == -75. .or. Bathymetry(ib,jb+1) == -75. ) then
                    AbsorbCoef = 0.5
                elseif (Bathymetry(ib-1,jb) == -80. .or. Bathymetry(ib+1,jb) == -80. .or. &
                        Bathymetry(ib,jb-1) == -80. .or. Bathymetry(ib,jb+1) == -80. ) then
                    AbsorbCoef = 0.4
                elseif (Bathymetry(ib-1,jb) == -85. .or. Bathymetry(ib+1,jb) == -85. .or. &
                        Bathymetry(ib,jb-1) == -85. .or. Bathymetry(ib,jb+1) == -85. ) then
                    AbsorbCoef = 0.1
                elseif (Bathymetry(ib-1,jb) == -89. .or. Bathymetry(ib+1,jb) == -89. .or. &
                        Bathymetry(ib,jb-1) == -89. .or. Bathymetry(ib,jb+1) == -89. ) then
                    AbsorbCoef = 0.0
                endif

                !Absorption
                XY_Component_L  = XY_Component_L * AbsorbCoeF

                if (ImplicitFaces) then


                    ![s^-1] = [m^2/s] / [m] / [m]
                    A_aux     = RadCoef_2D    (I, J) / DYY_XX(i, j) / HT_Boundary

                    ![m/s]    = [m^3/s] / [m] / [m]
                    T3        = TiRadCoef_2D(I, J) / DYY_XX(i, j) / HT_Boundary


                else

                    ![s^-1]   = [m^2/s] / [m] / [m]
                    A_aux     = 0.

                    ![m/s]    = [m^3/s] / [m] / [m]
                    T3        = WaterFluxBoundary / DYY_XX(i, j) / HT_Boundary


                endif


                ![m/s]    = [m/s] - [m/s] * [-]
                T3            = T3 - ImposedVelocity(ib, jb) * XY_Component_Cart_E


                ![1/(m*s)] = [m/s] * [ ] / [m] / [m]
                B_aux =  + Wave_Celerity * XY_Component_L   &
                           / (DUX_VY(i - di, j - dj) + DUX_VY(i, j)) / HT_Boundary


                ![s^-1]   = [ ] * [s^-1]
                D1        = - db * A_aux

                ![s^-1]   = [ ] * [1/(m*s)] * [m]
                D2        = + db * B_aux * DUX_VY(i, j)

                ![s^-1]   = [ ] * [s^-1]
                E1        = + db * A_Aux
                ![s^-1]   = [ ] * [1/(m*s)] * [m]
                E2        = + db * B_aux * DUX_VY(i - di, j - dj)

                ![s^-1]   = [ ] * [s^-1]
                E3        = - (1 - db) * A_aux
                ![s^-1]   = [ ] * [1/(m*s)] * [m]
                E4        = + (1 - db) * B_aux * DUX_VY(i, j)

                ![s^-1]   = [ ] * [s^-1]
                F1        = + (1 - db) * A_aux
                ![s^-1]   = [ ] * [1/(m*s)] * [m]
                F2        = + (1 - db) * B_aux * DUX_VY(i - di, j - dj)

                ! [s^-1] = ([m/s] / [m] )
                T1        = - Wave_Celerity * XY_Component_E / HT_Boundary

                ! [s^-1] = ([m/s] / [m] )
                T2        = + Wave_Celerity * XY_Component_L / HT_Boundary

                ! [m/s] = ([m] * [s^-1] + [m/s] + [m] * [s^-1]
                T4        = WaveEntering * T1 + T3 + (WaveEntering + ReferenceLevel) * T2

                E5        = E1 + E2 + E3 + E4

cd7:            if (ImplicitFaces) then

                    DCoef_2D (ib, jb) = D1 + D2

                    ECoef_2D (ib, jb) = E5

                    FCoef_2D (ib, jb) = F1 + F2

                    TiCoef_2D(ib, jb) = T4

                else cd7

                    if (abs(E5)>0.) then
                        WaterLevel_new(ib, jb) = (T4 - (D2 + F2)* WaterLevel_new(i_int, j_int)) / E5
                    endif
                endif cd7



            endif cd1

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "WaterLevel_FlatherWindWave")


cd21:   if (Me%ComputeOptions%LocalSolution == Gauge_) then

            call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedElevation, STAT = status)
            if (status /= SUCCESS_) &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR120")

            call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedVelocity, STAT = status)
            if (status /= SUCCESS_)                                                          &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR130")



            if (Me%Relaxation%RefBoundWaterLevel) then

                call UnGetAssimilation(Me%ObjAssimilation,                      &
                                        BoundaryReferenceLevel, STAT = status)

                if (status /= SUCCESS_)                                                      &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR140")


            else

                call UnGetOpenBoundary(Me%ObjOpenBoundary, BoundaryReferenceLevel, STAT = status)

                if (status /= SUCCESS_)                                                      &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR150")


            endif


        elseif (Me%ComputeOptions%LocalSolution == AssimilationField_) then cd21


            call UnGetAssimilation(Me%ObjAssimilation,                      &
                                    ImposedElevation, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR160")

        endif cd21

        if  (Me%WindWaves%CelerityType == AnalyticWaves_) then

            call UnGetAssimilation(Me%ObjAssimilation,                      &
                                    WaveCelerityField, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR170")


        endif

        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherWindWave - Hydrodynamic - ERR180")

        !Nullify auxiliar variables

        !Linear system equation
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D, RadCoef_2D, TiRadCoef_2D)

        !Mapping
        nullify (BoundaryPoints)

        !Geometry
        nullify(SZZ)

        !Hydrodynamic
        nullify(WaterLevel_New)
        nullify(WaterLevel_Old)

        if (associated(ImposedVelocity)) then
            deallocate(ImposedVelocity)
        endif


        if (associated(BoundaryReferenceLevel)) then
            deallocate(BoundaryReferenceLevel)
        endif

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_FlatherWindWave

    !--------------------------------------------------------------------------


      !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the Sommerfeld radition condition for the open boundary      !
    !                                                                                      !
    ! Input : Mapping                                                                      !
    ! OutPut: Water Level in the open boundary                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_FlatherLocalSolution

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        type T_Matrix3D
            real,    dimension(:,:,:), pointer :: LocalVel3D_X , LocalVel3D_Y
        end type T_Matrix3D

        type T_Matrix2D
            real,    dimension(:,:),   pointer :: AssimilaWaterLevel
            real,    dimension(:,:),   pointer :: LocalVel2D_X, LocalVel2D_Y
        end type T_Matrix2D

        type (T_Matrix3D), dimension(:), pointer :: List3D
        type (T_Matrix2D), dimension(:), pointer :: List2D

        real(8), dimension (:,:,:), pointer :: WaterFlux_XY, WaterFlux_YX,              &
                                               LocalFlux3D_XY, LocalFlux3D_YX
        !real,    dimension (:,:,:), pointer :: LocalVel3D_X , LocalVel3D_Y
        real,    dimension (:,:  ), pointer :: LocalVel2D_XY, LocalVel2D_YX,            &
                                               LocalVel2D_X , LocalVel2D_Y,             &
                                               AssimilaWaterLevel
        real,    dimension (:,:  ), pointer :: WaterColumnUV, DUX_VY, DYY_XX, DXX_YY

        integer, dimension (:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension (:,:  ), pointer :: BoundaryFacesUV, kfloor_UV, kfloor_VU
        integer                             :: di, dj
        integer                             :: i, j, k
        integer, pointer, dimension (:,:)   :: BoundaryPoints


        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D,            &
                                               WaterLevel_New,  GaugeWaterLevel,         &
                                               SubModelWaterLevel,                       &
                                               RadCoef_2D, TiRadCoef_2D, Bathymetry
        real,    dimension(:,:,:), pointer  :: SZZ

        real                                :: D1, D2, E1, E2, E3, E4, F1, F2,           &
                                               T1, T3, T4, A_Aux, B_Aux,                 &
                                               HT_boundary, Wave_Celerity,               &
                                               DT_Elevation, LocalWave, DT_RunPeriod, SlowCoef

        real(8)                             :: FluxXY_L, FluxYX_L, FluxMod_L,            &
                                               FluxXY_E, FluxYX_E,                       &
                                               FluxXY_T, FluxYX_T,                       &
                                               Flux_WestSouth, Flux_EastNorth,           &
                                               Flux_SouthWest, Flux_NorthEast,           &
                                               LocalFlux_WestSouth, LocalFlux_EastNorth, &
                                               LocalFlux_SouthWest, LocalFlux_NorthEast, &
                                               XY_Component_L,                           &
                                               WaterFluxBoundary, LocalBoundaryFlux,     &
                                               LeavingVelocity, Aux1, Aux2

        real                                :: MinLeavingComponent,  MinLeavingVelocity, LocalWLa, LocalWLb

        integer                             :: IUB, ILB, JUB, JLB, KUB,         &
                                               i1, i2, i3, i4, j1, j2, j3, j4,  &
                                               db, kbottom,                     &
                                               ib, jb, i_int, j_int

        real,    dimension(:,:  ), pointer  :: WaveCelerityField

        real                                :: WaveDirection

        integer                             :: status

        integer                             :: DirX, DirY, DirBoundXY, DirBoundYX

        logical                             :: LocalSolution, LocalAssimila, LocalSubModel, LocalGauge


        integer                             :: CHUNK

! Modified by Matthias DELPEY - 22/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 29/11/2011
        real,    dimension(:,:  ), pointer  :: WaveInducedPressureJ
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        real                                :: dx1, dx2, dx3

        integer                             :: iL, NFieldsSSH, NFieldsUV2D, NFieldsUV3D

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        DT_Elevation  =  Me%WaterLevel%DT

        DCoef_2D          => Me%Coef%D2%D
        ECoef_2D          => Me%Coef%D2%E
        FCoef_2D          => Me%Coef%D2%F
        TiCoef_2D         => Me%Coef%D2%Ti

        RadCoef_2D        => Me%Coef%D2%Rad
        TiRadCoef_2D      => Me%Coef%D2%TiRad

        SZZ               => Me%External_Var%SZZ

        WaterLevel_New    => Me%WaterLevel%New

        WaterFlux_XY      => Me%WaterFluxes%XY
        WaterFlux_YX      => Me%WaterFluxes%YX

        WaterColumnUV     => Me%External_Var%WaterColumnUV
        DUX_VY            => Me%External_Var%DUX_VY
        DYY_XX            => Me%External_Var%DYY_XX
        DXX_YY            => Me%External_Var%DXX_YY
        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU => Me%External_Var%ComputeFaces3D_VU
        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        Kfloor_UV         => Me%External_Var%Kfloor_UV
        Kfloor_VU         => Me%External_Var%Kfloor_VU

        BoundaryPoints    => Me%External_Var%BoundaryPoints


        MinLeavingComponent   =  Me%ComputeOptions%MinLeavingComponent
        MinLeavingVelocity    =  Me%ComputeOptions%MinLeavingVelocity

! Modified by Matthias DELPEY - 22/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 29/11/2011
        WaveInducedPressureJ  => Me%External_Var%WaveInducedPressureJ
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !End   - Shorten variables name

        LocalSolution = .true.

        LocalAssimila = .false.

        LocalGauge    = .false.

        LocalSubModel = .false.


        !Gets Bathymetry
        call GetGridData(Me%ObjGridData,                                                &
                           Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR010")


cd0:    if (Me%ComputeOptions%LocalSolution == Gauge_             .or.                  &
            Me%ComputeOptions%LocalSolution == GaugePlusSubModel_ .or.                  &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_ .or.              &
            Me%ComputeOptions%LocalSolution == AssimilaGauge_) then


            call Modify_OpenBoundary(Me%ObjOpenBoundary,                                &
                                     Me%CurrentTime,                                    &
                                     Me%External_Var%AtmosphericPressure,               &
                                     Me%ComputeOptions%AtmosphereCoef,                  &
                                     Me%ComputeOptions%InvertBaroCoef,                  &
                                     Me%ComputeOptions%AtmSeaLevelReference,            &
                                     STAT        = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR020")


            call GetImposedElevation(Me%ObjOpenBoundary,                                &
                                      GaugeWaterLevel, STAT = status)


            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR030")



            call GetOpenBoundParameter(Me%ObjOpenBoundary, DirectionX = DirX,           &
                                                           DirectionY = DirY, STAT= status)

            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR040")


            if      (Me%Direction%XY == DirectionX_) then

                DirBoundXY = DirX
                DirBoundYX = DirY


            else if (Me%Direction%XY == DirectionY_) then

                DirBoundXY = DirY
                DirBoundYX = DirX

            endif

            LocalGauge = .true.

        endif cd0


ifa:    if (Me%ComputeOptions%LocalSolution == AssimilationField_ .or.                  &
            Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.               &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubModel_ .or.              &
            Me%ComputeOptions%LocalSolution == AssimilaGauge_) then

            call GetNumberOfFields(AssimilationID  = Me%ObjAssimilation,                &
                                   ID              = WaterLevel_,                       &
                                   NumberOfFields  = NFieldsSSH,                        &
                                   STAT            = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR050")

            if (Me%ComputeOptions%AssimilaOneField) then
                NFieldsSSH = 1
            endif

            allocate(List3D(NFieldsSSH))
            allocate(List2D(NFieldsSSH))

            nullify (LocalVel2D_X, LocalVel2D_Y, AssimilaWaterLevel)
            allocate(LocalVel2D_X      (Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB))
            allocate(LocalVel2D_Y      (Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB))
            allocate(AssimilaWaterLevel(Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB))

            LocalVel2D_X      (:,:) = 0.
            LocalVel2D_Y      (:,:) = 0.
            AssimilaWaterLevel(:,:) = 0.

diL:        do iL =1, NFieldsSSH

                !call GetAssimilationList(WaterLevel = PropertyID)
                call GetAssimilationField(Me%ObjAssimilation,                           &
                                          ID      = WaterLevel_,                        &
                                          N_Field = iL ,                                &
                                          Field2D = List2D(iL)%AssimilaWaterLevel,      &
                                          STAT    = status)

                if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR060")

                    do  j = JLB, JUB
                    do  i = ILB, IUB
    i55:                if (Me%External_Var%OpenPoints3D(i, j, KUB) == Covered) then
                            AssimilaWaterLevel(i, j) = AssimilaWaterLevel(i, j) + List2D(iL)%AssimilaWaterLevel(i, j)
                        endif i55
                    enddo
                    enddo

            enddo diL

            call GetNumberOfFields(AssimilationID  = Me%ObjAssimilation,                &
                                   ID              = BarotropicVelocityU_,              &
                                   NumberOfFields  = NFieldsUV2D,                       &
                                   STAT            = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR070")

            if (Me%ComputeOptions%AssimilaOneField) then
                NFieldsUV2D = 0
            endif


            call GetNumberOfFields(AssimilationID  = Me%ObjAssimilation,            &
                                    ID              = VelocityU_,                    &
                                    NumberOfFields  = NFieldsUV3D,                   &
                                    STAT            = status)
            if (status /= SUCCESS_)                                                 &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR080") 

            if (Me%ComputeOptions%AssimilaOneField) then
                NFieldsUV3D = 1
            endif

            if (NFieldsUV3D + NFieldsUV2D /= NFieldsSSH) then
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR090")
            endif


diL2:       do iL =1, NFieldsUV2D

                !It is important to read vector fields in agreggated way to allow the
                !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
                call GetAssimilationVectorField                                         &
                                        (AssimilationID    = Me%ObjAssimilation,        &
                                         VectorX_ID        = BarotropicVelocityU_,      &
                                         VectorY_ID        = BarotropicVelocityV_,      &
                                         N_Field           = iL ,                       &
                                         VectorX_2D        = List2D(iL)%LocalVel2D_X,   &
                                         VectorY_2D        = List2D(iL)%LocalVel2D_Y,   &
                                         STAT              = status)

                if (status /= SUCCESS_) then
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR100")
                endif

                do  j = JLB, JUB
                do  i = ILB, IUB
i34:                if (Me%External_Var%ComputeFaces3D_U(i, j, KUB) == Covered) then
                        LocalVel2D_X(i, j) = LocalVel2D_X(i, j) +  List2D(iL)%LocalVel2D_X(i, j)
                    endif i34
                enddo
                enddo

                do  j = JLB, JUB
                do  i = ILB, IUB
i35:                if (Me%External_Var%ComputeFaces3D_V(i, j, KUB) == Covered) then
                        LocalVel2D_Y(i, j) = LocalVel2D_Y(i, j) + List2D(iL)%LocalVel2D_Y(i, j)
                    endif i35
                enddo
                enddo

            enddo diL2

diL3:       do iL =1, NFieldsUV3D

                !It is important to read vector fields in agreggated way to allow the
                !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
                call GetAssimilationVectorField                                         &
                                        (AssimilationID    = Me%ObjAssimilation,        &
                                        VectorX_ID        = VelocityU_,                 &
                                        VectorY_ID        = VelocityV_,                 &
                                        N_Field           = iL ,                        &
                                        VectorX_3D        = List3D(iL)%LocalVel3D_X,    &
                                        VectorY_3D        = List3D(iL)%LocalVel3D_Y,    &
                                        STAT              = status)
                if (status /= SUCCESS_) then
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR110")
                endif


                do  j = JLB, JUB
                do  i = ILB, IUB
i94:                if (Me%External_Var%ComputeFaces3D_U(i, j, KUB) == Covered) then
                        kbottom = Me%External_Var%kfloor_U(i, j)
                        do  k = kbottom, KUB
                            LocalVel2D_X(i, j) = LocalVel2D_X(i, j) + List3D(iL)%LocalVel3D_X(i, j, k) * &
                                                    Me%External_Var%DUZ(i, j, k) / Me%External_Var%WaterColumnU(i, j)
                        enddo
                    endif i94
                enddo
                enddo

                do  j = JLB, JUB
                do  i = ILB, IUB
i95:                if (Me%External_Var%ComputeFaces3D_V(i, j, KUB) == Covered) then
                        kbottom = Me%External_Var%kfloor_V(i, j)
                        do  k = kbottom, KUB
                            LocalVel2D_Y(i, j) = LocalVel2D_Y(i, j) + List3D(iL)%LocalVel3D_Y(i, j, k) * &
                                                    Me%External_Var%DVZ(i, j, k) / Me%External_Var%WaterColumnV(i, j)
                        enddo
                    endif i95
                enddo
                enddo

            enddo diL3


            DT_RunPeriod = Me%CurrentTime - Me%BeginTime

            SlowCoef = 1.

            if (Me%ComputeOptions%FlatherColdPeriod > DT_RunPeriod) then
                SlowCoef = (DT_RunPeriod / Me%ComputeOptions%FlatherColdPeriod)
            endif

            if      (Me%Direction%XY == DirectionX_) then

                LocalVel2D_XY => LocalVel2D_X
                LocalVel2D_YX => LocalVel2D_Y

            else if (Me%Direction%XY == DirectionY_) then

                LocalVel2D_XY => LocalVel2D_Y
                LocalVel2D_YX => LocalVel2D_X

            endif

            LocalAssimila = .true.


        endif ifa

ifb:    if  (Me%ComputeOptions%LocalSolution == SubModel_            .or.               &
             Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_.or.               &
             Me%ComputeOptions%LocalSolution == GaugePlusSubModel_   .or.               &
             Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_) then


            SubModelWaterLevel => Me%SubModel%Z

            LocalFlux3D_XY     => Me%SubModel%qXY

            LocalFlux3D_YX     => Me%SubModel%qYX


            LocalSubModel = .true.

        endif ifb

ifc:    if  (Me%ComputeOptions%LocalSolution == NoLocalSolution_) then

            LocalSolution = .false.

        endif ifc

        if  (Me%WindWaves%CelerityType == AnalyticWaves_) then

            if (Me%ComputeOptions%LocalSolution == AssimilationField_) then

                call GetWaveCelerityField(AssimilationID = Me%ObjAssimilation,          &
                                          ID              = WaterLevel_,                &
                                          WaveCelerity    = WaveCelerityField,          &
                                          WaveDirection   = WaveDirection,              &
                                          STAT            = status)

                if (status /= SUCCESS_) then
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR120")
                endif

            else

                write(*,*) 'Define the analytic celerity in assimilation_x.dat for property WaterLevel_'
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR130")

            endif


        endif


        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_FlatherLocalSolution")
        endif

        !$OMP PARALLEL PRIVATE(i,j,kbottom,HT_boundary,db,i1,i2,i3,i4,j1,j2,j3,j4,ib) &
        !$OMP PRIVATE(jb,i_int,j_int,Aux1,Flux_WestSouth,LocalFlux_WestSouth,Aux2) &
        !$OMP PRIVATE(Flux_EastNorth,LocalFlux_EastNorth,Flux_SouthWest) &
        !$OMP PRIVATE(LocalFlux_SouthWest,Flux_NorthEast,LocalFlux_NorthEast) &
        !$OMP PRIVATE(Wave_Celerity,FluxXY_E,FluxYX_E,LocalWLa,LocalWLb,LocalWave) &
        !$OMP PRIVATE(FluxXY_T,FluxYX_T,FluxXY_L,FluxYX_L,FluxMod_L,LeavingVelocity) &
        !$OMP PRIVATE(XY_Component_L,WaterFluxBoundary,LocalBoundaryFlux,A_aux,T3) &
        !$OMP PRIVATE(B_aux,D1,D2,E1,E2,E3,E4,F1,F2,T1,T4) &
        !$OMP PRIVATE(dx1,dx2,dx3)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB


            !In this way if in a boundary point the elevation is not change
            !due to the radiation condition then
            !the old elevation is maintain
cd9:        if (BoundaryPoints(i, j) == Boundary) then

                TiCoef_2D(i, j) = WaterLevel_New(i, j)

                DCoef_2D (i, j) = 0.

                ECoef_2D (i, j) = 1.

                FCoef_2D (i, j) = 0.


            endif cd9

cd1:        if  (BoundaryFacesUV  (i, j     )  == Boundary     .and.                     &
                 ComputeFaces3D_UV(i, j, KUB)  == Covered      .and.                     &
                (BoundaryPoints   (i, j)       == Not_Boundary .or.                      &
                 BoundaryPoints   (i-di, j-dj) == Not_Boundary)) then


                kbottom = kfloor_UV(i, j)

               ![m] = [m^2]/[m]
                HT_boundary = WaterColumnUV(i, j)


                !Direction - Leaving wave
                if (BoundaryPoints(i, j) == Boundary) then

                    !West or South cell is interior and
                    !the East or North cell is boundary
                    db = 1

                    i1 = i - di
                    i2 = i
                    i3 = i - di
                    i4 = i + dj - di
                    j1 = j - dj
                    j2 = j
                    j3 = j - dj
                    j4 = j - dj + di


                else

                    !West or South cell is boundary and
                    !the East or North cell is interior
                    db = 0

                    i1 = i
                    i2 = i + di
                    i3 = i
                    i4 = i + dj
                    j1 = j
                    j2 = j + dj
                    j3 = j
                    j4 = j + di


                endif


                !Boundary cell
                !X direction (di=0,dj=1) - boundary West  cell (db=0) => (ib,jb)=(i, j-1)
                !X direction (di=0,dj=1) - boundary East  cell (db=1) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - boundary South cell (db=0) => (ib,jb)=(i-1, j)
                !Y direction (di=1,dj=0) - boundary North cell (db=1) => (ib,jb)=(i, j)

                ib    = i - di * (1 - db)
                jb    = j - dj * (1 - db)

                !Interior cell next to a boundary face
                !X direction (di=0,dj=1) - Interior East  cell (db=0) => (ib,jb)=(i, j)
                !X direction (di=0,dj=1) - Interior West  cell (db=1) => (ib,jb)=(i, j-1)
                !Y direction (di=1,dj=0) - Interior North cell (db=0) => (ib,jb)=(i, j)
                !Y direction (di=1,dj=0) - Interior South cell (db=1) => (ib,jb)=(i-1, j)

                i_int = i - di * db
                j_int = j - dj * db


                if (LocalSolution) then

                    if (LocalAssimila) then

                        Aux1 = dble(Bathymetry(i_int, j_int) + SlowCoef * AssimilaWaterLevel(i_int, j_int))

                        if (Me%ComputeOptions%LocalSolution == AssimilationField_) then
                            Aux1 = Aux1 + dble((1. - SlowCoef) * WaterLevel_New(i_int, j_int))
                        endif

                    else

                        Aux1 = FillValueReal

                    endif


                else

                    Aux1 = 0.

                endif


                !total West or South face water flux
                Flux_WestSouth      = 0.
                LocalFlux_WestSouth = 0.

cd2:            if (ComputeFaces3D_UV(i1, j1, KUB) == Covered) then

                    Aux2 = dble(DYY_XX(i1, j1))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_WestSouth = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_XY(i1, j1))

                    kbottom = kfloor_UV(i1, j1)

                    do  k = kbottom, KUB

                        Flux_WestSouth = Flux_WestSouth + WaterFlux_XY(i1, j1, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_WestSouth = LocalFlux_WestSouth + LocalFlux3D_XY(i1, j1, k) * Aux2

                    enddo


                endif cd2


                !total East or North face water flux
                Flux_EastNorth      = 0.
                LocalFlux_EastNorth = 0

cd3:            if (ComputeFaces3D_UV(i2, j2, KUB) == Covered) then

                    Aux2 = dble(DYY_XX(i2, j2))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_EastNorth = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_XY(i2, j2))

                    kbottom = kfloor_UV(i2, j2)

                    do  k = kbottom, KUB

                        Flux_EastNorth = Flux_EastNorth + WaterFlux_XY(i2, j2, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_EastNorth = LocalFlux_EastNorth + LocalFlux3D_XY(i2, j2, k) * Aux2

                    enddo

                endif cd3


                !total South or West face water flux
                Flux_SouthWest      = 0.
                LocalFlux_SouthWest = 0.

cd4:            if (ComputeFaces3D_VU(i3, j3, KUB) == Covered) then

                    Aux2  = dble(DXX_YY(i3, j3))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_SouthWest = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_YX(i3, j3))

                    kbottom = kfloor_VU(i3, j3)

                    do  k = kbottom, KUB

                        Flux_SouthWest = Flux_SouthWest + WaterFlux_YX(i3, j3, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_SouthWest = LocalFlux_SouthWest + LocalFlux3D_YX(i3, j3, k) * Aux2

                    enddo

                endif cd4


                !total North or East face water flux

                Flux_NorthEast      = 0.
                LocalFlux_NorthEast = 0.

cd5:            if (ComputeFaces3D_VU(i4, j4, KUB) == Covered) then

                    Aux2 = dble(DXX_YY(i4, j4))

                    if (LocalSolution .and. LocalAssimila)                              &
                        LocalFlux_NorthEast = Aux1 * Aux2 * dble(SlowCoef * LocalVel2D_YX(i4, j4))

                    kbottom = kfloor_VU(i4, j4)

                    do  k = kbottom, KUB

                        Flux_NorthEast = Flux_NorthEast + WaterFlux_YX(i4, j4, k)

                        if (LocalSolution .and. LocalSubModel)                          &
                            LocalFlux_NorthEast = LocalFlux_NorthEast + LocalFlux3D_YX(i4, j4, k) * Aux2

                    enddo

                endif cd5

                !The wave Celerity compute in the boundary face
                ![m/s] = [m/s^2*m]^.5 = [m/s]
                if      (Me%WindWaves%CelerityType == LongWaves_) then

                    Wave_Celerity = sqrt(Gravity * HT_Boundary)

                elseif  (Me%WindWaves%CelerityType == Constant_ ) then

                    Wave_Celerity = Me%WindWaves%CelerityConstant

                elseif  (Me%WindWaves%CelerityType == AnalyticWaves_) then

                    dx1 = DUX_VY(i_int, j_int)
                    dx2 = DUX_VY(ib,    jb   )
                    dx3 = dx1 + dx2

                    Wave_Celerity = (WaveCelerityField(ib,    jb   ) * dx1 +            &
                                     WaveCelerityField(i_int, j_int) * dx2 ) / dx3

                endif


                !If was defined a entering wave then
cd15:           if (LocalSolution) then

                    FluxXY_E = (LocalFlux_WestSouth + LocalFlux_EastNorth) / 2.
                    FluxYX_E = (LocalFlux_SouthWest + LocalFlux_NorthEast) / 2.

                    LocalWLa = 0.
                    LocalWLb = 0.

                    if (LocalGauge) then
                        LocalWLa = LocalWLa + GaugeWaterLevel(ib   , jb   )
                        LocalWLb = LocalWLb + GaugeWaterLevel(i_int, j_int)
                    endif

                    if (LocalSubModel) then
                        LocalWLa = LocalWLa + SubModelWaterLevel(ib   , jb   )
                        LocalWLb = LocalWLb + SubModelWaterLevel(i_int, j_int)
                    endif

                    if (LocalAssimila) then
                        LocalWLa = LocalWLa +       SlowCoef  * AssimilaWaterLevel(ib   , jb   )
                        LocalWLb = LocalWLb +       SlowCoef  * AssimilaWaterLevel(i_int, j_int)

                        if (Me%ComputeOptions%LocalSolution == AssimilationField_) then
                            LocalWLa = LocalWLa + (1. - SlowCoef) * WaterLevel_New    (ib   , jb   )
                            LocalWLb = LocalWLb + (1. - SlowCoef) * WaterLevel_New    (i_int, j_int)
                        endif

                    endif


                    LocalWave = (LocalWLa * DUX_VY(i_int, j_int) +  &
                                 LocalWLb * DUX_VY(ib   , jb   ))/  &
                                (DUX_VY(i_int, j_int) + DUX_VY(ib   , jb))

                else cd15

                    LocalWave = 0.

                    FluxXY_E  = 0.
                    FluxYX_E  = 0.

! Modified by Matthias DELPEY - 22/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 29/11/2011
                    if (Me%ComputeOptions%WaveForcing3D == GLM) then

                        ! The total exterior flux (quasi-eulerian + stokes) is null
                        ! (keeping in mind that the variable WaterFlux_X,Y stands for the total
                        ! waterflux in the option WAVE_FORCING_3D: 2)
                        FluxXY_E = 0.
                        FluxYX_E = 0.

                        !LocalWLa = 0.
                        !LocalWLb = 0.

                        ! The exterior waterlevel is equal to -Jext/g, and we assume that the J gradient is continuous
                        ! through the open boundary, so that dJext/dx = dJ/dx.
                        LocalWLa = - WaveInducedPressureJ(ib   , jb   ) / Gravity
                        LocalWLb = - WaveInducedPressureJ(i_int, j_int) / Gravity

                        LocalWave = (LocalWLa * DUX_VY(i_int, j_int) +  &
                                     LocalWLb * DUX_VY(ib   , jb   ))/  &
                                    (DUX_VY(i_int, j_int) + DUX_VY(ib   , jb))

                    endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


                endif cd15


                !The leaving wave direction is compute in the center of the
                !first interior cell
                FluxXY_T = (Flux_WestSouth + Flux_EastNorth) / 2.
                FluxYX_T = (Flux_SouthWest + Flux_NorthEast) / 2.


                !Flow - Leaving wave - Cartesian referencial
                FluxXY_L = FluxXY_T - FluxXY_E
                FluxYX_L = FluxYX_T - FluxYX_E

                FluxMod_L = pythag (FluxXY_L, FluxYX_L)

                LeavingVelocity   = FluxMod_L / DYY_XX(i, j) / HT_Boundary

                if (LeavingVelocity < MinLeavingVelocity)    then

                    XY_Component_L = 1.

                else

                    XY_Component_L = abs(FluxXY_L) / FluxMod_L

                endif
                !If the flow of the leaving wave is going from inside the domain to the
                !outside then the flow must be positive in the oposite condition it must
                !be negative
                if (db == 0) then  !West or South cell boundary
                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_L  = - abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_WestSouth

                    LocalBoundaryFlux = LocalFlux_WestSouth


                else if (db == 1) then !East or North cell boundary

                    ![ ] = [m^3/s] / [m^3/s]
                    XY_Component_L  = + abs(XY_Component_L)

                    !The total OLD water flux in the boundary face
                    WaterFluxBoundary = Flux_EastNorth

                    LocalBoundaryFlux = LocalFlux_EastNorth

                endif


                if (abs(XY_Component_L)  > 1. )   Stop 'XY_Component_L = 1'

                ![s^-1] = [m^2/s] / [m] / [m]
                A_aux = RadCoef_2D(I, J) / DYY_XX(i, j) / HT_Boundary

                ![m^3/s]    = [m^3/s]
                T3        = + TiRadCoef_2D(I, J)

                ![m/s]    = [m^3/s]
                T3            = (T3 - LocalBoundaryFlux) / DYY_XX(i, j) / HT_Boundary



                ![m^-1*s^-1] = [m/s] * [ ] * [ ] / [m] / [m]
                B_aux =  Wave_Celerity * XY_Component_L  &
                           / (DUX_VY(i - di, j - dj) + DUX_VY(i, j)) / HT_Boundary


                ![s^-1]   = [ ] * [s^-1] + [m^-1*s^-1] * [m]
                D1        = - db * A_aux
                D2        = + db * B_aux * DUX_VY(i, j)

                E1        = + db * A_Aux
                E2        = + db * B_aux * DUX_VY(i - di, j - dj)
                E3        = - (1 - db) * A_aux
                E4        = + (1 - db) * B_aux * DUX_VY(i, j)

                F1        = + (1 - db) * A_aux
                F2        = + (1 - db) * B_aux * DUX_VY(i - di, j - dj)

                ! [m/s] = ([m] * [m/s] / [m] )
                T1        = + LocalWave * Wave_Celerity * XY_Component_L / HT_Boundary


                T4        =  T1 + T3


                DCoef_2D (ib, jb) = D1 + D2

                ECoef_2D (ib, jb) = E1 + E2 + E3 + E4

                FCoef_2D (ib, jb) = F1 + F2

                TiCoef_2D(ib, jb) = T4


            endif cd1

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_FlatherLocalSolution")
        endif

        !Gets Bathymetry
        call UnGetGridData(Me%ObjGridData, Bathymetry, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR140")



cd24:   if (Me%ComputeOptions%LocalSolution == Gauge_             .or.                  &
            Me%ComputeOptions%LocalSolution == GaugePlusSubmodel_ .or.                  &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_ .or.              &
            Me%ComputeOptions%LocalSolution == AssimilaGauge_) then

            call UnGetOpenBoundary(Me%ObjOpenBoundary, GaugeWaterLevel, STAT = status)
            if (status /= SUCCESS_) &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR150")


        endif cd24



cd25:   if (Me%ComputeOptions%LocalSolution == AssimilationField_    .or.               &
            Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_ .or.               &
            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_.or.               &
            Me%ComputeOptions%LocalSolution == AssimilaGauge_) then

diL4:       do iL =1, NFieldsSSH

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        List2D(iL)%AssimilaWaterLevel, STAT = status)

                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR160")

            enddo diL4

diL5:       do iL =1, NFieldsUV2D

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        List2D(iL)%LocalVel2D_X, STAT = status)
                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR170")

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        List2D(iL)%LocalVel2D_Y, STAT = status)
                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR180")

            enddo diL5

diL6:       do iL =1, NFieldsUV3D

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        List3D(iL)%LocalVel3D_X, STAT = status)
                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR190")

                call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                        List3D(iL)%LocalVel3D_Y, STAT = status)
                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR160")

            enddo DiL6

            if (associated(LocalVel2D_X      )) deallocate(LocalVel2D_X      )
            if (associated(LocalVel2D_Y      )) deallocate(LocalVel2D_Y      )
            if (associated(AssimilaWaterLevel)) deallocate(AssimilaWaterLevel)

            deallocate(List2D)
            deallocate(List3D)


        endif cd25


        if  (Me%WindWaves%CelerityType == AnalyticWaves_) then

            call UnGetAssimilation(Me%ObjAssimilation,                                  &
                                    WaveCelerityField, STAT = status)

            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR170")

        endif


        !Nullify auxiliar variables

        !Linear system equation
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D, RadCoef_2D, TiRadCoef_2D)

        !Mapping
        nullify(BoundaryPoints   )
        nullify(ComputeFaces3D_UV)
        nullify(ComputeFaces3D_VU)
        nullify(BoundaryFacesUV  )
        nullify(Kfloor_UV        )
        nullify(Kfloor_VU        )


        !Geometry
        nullify(SZZ              )
        nullify(WaterColumnUV    )
        nullify(DUX_VY           )
        nullify(DXX_YY           )
        nullify(DYY_XX           )
        nullify(Bathymetry       )


        !Hydrodynamic
        nullify(WaterLevel_New   )

        nullify(WaterFlux_XY     )
        nullify(WaterFlux_YX     )

        nullify(LocalFlux3D_XY)
        nullify(LocalFlux3D_YX)

        nullify(SubModelWaterLevel)

        nullify(LocalVel2D_XY)
        nullify(LocalVel2D_YX)


        nullify(LocalVel2D_X )
        nullify(LocalVel2D_Y )

! Modified by Matthias DELPEY - 21/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        nullify(WaveInducedPressureJ)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_FlatherLocalSolution

    !--------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                        !
    ! This subroutine computes the implicit Blumberg and Kantha condition for elevation at OB !
    ! This condition is a combination of clamped and radiation conditions                    !
    !                                                                                        !
    ! Input : Mapping                                                                        !
    ! OutPut: Water Level at the open boundary                                               !
    ! Author: Manuel Ruiz Villarreal and Paulo Chambel, 2001                                 !
    !                                                                                        !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_BlumbergKantha

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        integer                             :: i, j, STAT_CALL, STAT
        integer, pointer, dimension (:,:)   :: BoundaryPoints, BoundaryFacesV, BoundaryFacesU, BoundaryFacesUV

        real(8), dimension(:,:), pointer    :: ECoef_2D
        real,    dimension(:,:), pointer    :: DCoef_2D, FCoef_2D, TiCoef_2D,         &
                                               ImposedElevation, WaterLevel_Old

        real,    dimension(:,:), pointer    :: DZX, DZY

        real,    dimension(:,:), pointer    :: Tlag

        real                                :: HT_boundary, DT_Elevation,                &
                                               Wave_Celerity, CoefRelax, DZX_ZY, CelAdim

        integer                             :: IUB, ILB, JUB, JLB, KUB, db
        integer                             :: di,dj, i_normal, j_normal

        integer                             :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DT_Elevation  =  Me%WaterLevel%DT

        DCoef_2D      => Me%Coef%D2%D
        ECoef_2D      => Me%Coef%D2%E
        FCoef_2D      => Me%Coef%D2%F
        TiCoef_2D     => Me%Coef%D2%Ti

        !Geometry
        DZX               => Me%External_Var%DZX
        DZY               => Me%External_Var%DZY

        !Map
        BoundaryFacesU   => Me%External_Var%BoundaryFacesU
        BoundaryFacesV   => Me%External_Var%BoundaryFacesV
        BoundaryFacesUV  => Me%External_Var%BoundaryFacesUV
        BoundaryPoints   => Me%External_Var%BoundaryPoints

        WaterLevel_Old   => Me%WaterLevel%Old
        Tlag             => Me%ComputeOptions%Tlag

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End   - Shorten variables name


        call Modify_OpenBoundary(Me%ObjOpenBoundary,                                    &
                                 Me%CurrentTime,                                        &
                                 Me%External_Var%AtmosphericPressure,                   &
                                 Me%ComputeOptions%AtmosphereCoef,                      &
                                 Me%ComputeOptions%InvertBaroCoef,                      &
                                 Me%ComputeOptions%AtmSeaLevelReference,                &
                                 STAT        = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            Stop 'Sub. WaterLevel_BlumbergKantha - ModuleHydrodynamic - ERR01.'


        call GetImposedElevation(Me%ObjOpenBoundary, &
                                  ImposedElevation, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. WaterLevel_BlumbergKantha - ModuleHydrodynamic - ERR02.'

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "WaterLevel_BlumbergKantha")
        endif

        !$OMP PARALLEL PRIVATE(i,j,db, i_normal, j_normal, DZX_ZY, HT_Boundary)  &
        !$OMP PRIVATE(Wave_Celerity, CoefRelax, CelAdim, STAT)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

cd1:        if (BoundaryPoints(i, j) == Boundary) then

                !Depending on where boundaryfaces are found:
                ! - db= 0, interior point contributes to DCoef; db= 1, interior point contributes to FCoef
                ! - The sign of the normal direction to the boundary
                ! - If the normal direction is X or Y. DZX(i-1,j) == Distance between elevation points i-1,j and i,j
                ! - The depth at the boundary face i,j, needed for computing wave_celerity
                ! In the case of generalised boundaries (i.e. boundary points with several open boundary faces),
                ! the first boundaryface found determines everything. For this purpose we use STAT
                ! Also for avoiding to impose elevation from BK in the explicit direction


                STAT = Unknown_

                !
                if (BoundaryFacesU(i,j) == Boundary) then

                   db = 0

                   i_normal =  0
                   j_normal = -1

                   DZX_ZY = DZX(i,j-1)

                   !Wave Celerity is computed at the boundary face
                   HT_boundary = Me%External_Var%WaterColumnU(i, j)

                   STAT = SUCCESS_

                end if

                if ((BoundaryFacesU(i,j+1) == Boundary).and.(STAT /= SUCCESS_)) then

                   db = 1

                   i_normal = 0
                   j_normal = 1

                   DZX_ZY = DZX(i,j)

                   !Wave Celerity is computed at the boundary face
                   HT_boundary = Me%External_Var%WaterColumnU(i, j+1)


                   STAT = SUCCESS_

                end if

                if ((BoundaryFacesV(i,j) == Boundary).and.(STAT /= SUCCESS_)) then

                   db = 0

                   i_normal = -1
                   j_normal = 0

                   DZX_ZY = DZY(i-1,j)

                   !Wave Celerity is computed at the boundary face
                   HT_boundary = Me%External_Var%WaterColumnV(i, j)

                   STAT = SUCCESS_

                end if

                if ((BoundaryFacesV(i+1,j) == Boundary).and.(STAT /= SUCCESS_) ) then

                   db = 1

                   i_normal = 1
                   j_normal = 0

                   DZX_ZY = DZY(i,j)

                   !Wave Celerity is computed at the boundary face
                   HT_boundary = Me%External_Var%WaterColumnV(i+1, j)


                   STAT = SUCCESS_

                end if

                if (STAT == SUCCESS_) then

                    ! Wave celerity of a barotropic wave
                    ![m/s] = [m/s^2*m]^.5 = [m/s]
                    Wave_Celerity     = sqrt (Gravity * HT_Boundary)

                    CoefRelax         = DT_Elevation / Tlag(i, j)

                    CelAdim           = DT_Elevation * Wave_Celerity / DZX_ZY

                    if ((BoundaryFacesUV(i   ,j   ) == Boundary) .or.                    &
                        (BoundaryFacesUV(i+di,j+dj) == Boundary) ) then

                        !Note that the BK condition is discretized implicitly (but only in the implicit direction)!
                        TiCoef_2D(i, j)   = WaterLevel_Old(i,j) + ImposedElevation(i, j) * CoefRelax

                        ECoef_2D (i, j)   = 1. + CoefRelax + CelAdim

                        DCoef_2D (i, j)   = (-1) * (1-db)  * CelAdim

                        FCoef_2D (i, j)   = (-1) *    db   * CelAdim

                    else

                        TiCoef_2D(i, j)   = (1 - CelAdim)  * WaterLevel_Old  (i,         j)             + &
                                               CoefRelax   * ImposedElevation(i         ,j)             + &
                                         (1-db)  * CelAdim * WaterLevel_Old  (i+i_normal,j+j_normal)    + &
                                          db     * CelAdim * WaterLevel_Old  (i+i_normal,j+j_normal)

                        DCoef_2D (i, j)   = 0.

                        ECoef_2D (i, j)   = 1. + CoefRelax

                        FCoef_2D (i, j)   = 0.

                    end if


                else ! The boundary point has no faces with interior points

                  TiCoef_2D(i, j) = ImposedElevation(i, j)

                  DCoef_2D (i, j) = 0.

                  ECoef_2D (i, j) = 1.

                  FCoef_2D (i, j) = 0.

                end if

            endif cd1

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_BlumbergKantha")
        endif

        call UnGetOpenBoundary(Me%ObjOpenBoundary, ImposedElevation, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. WaterLevel_BlumbergKantha - ModuleHydrodynamic - ERR05.'

        !Nullify auxiliar variables

        !Linear system equation
        nullify (DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D)

        !Mapping
        nullify (BoundaryPoints, BoundaryFacesUV)

        !Geometry
        nullify(DZY, DZX)

        !Flow
        nullify(ImposedElevation, WaterLevel_Old)

        nullify (Tlag)

        !----------------------------------------------------------------------

    End Subroutine WaterLevel_BlumbergKantha

      !------------------------------------------------------------------------------


    FUNCTION spythag(a,b)
        REAL(4) :: a,b,spythag
        REAL(4) :: absa,absb

        absa = abs(a)
        absb = abs(b)
        if(absa.gt.absb)then
            spythag=absa*sqrt(1.+(absb/absa)**2)
        else
            if(absb.eq.0.)then
                spythag=0.
            else
                spythag=absb*sqrt(1.+(absa/absb)**2)
            endif
        endif
    END FUNCTION spythag


    FUNCTION dpythag(a,b)

        REAL(8) :: a,b,dpythag
        REAL(8) :: absa,absb

        absa = abs(a)
        absb = abs(b)
        if(absa.gt.absb)then
            dpythag=absa*sqrt(1.+(absb/absa)**2)
        else
            if(absb.eq.0.)then
                dpythag=0.
            else
                dpythag=absb*sqrt(1.+(absa/absb)**2)
            endif
        endif
    END FUNCTION dpythag

! Modified by Matthias DELPEY - 14/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_LandBoundaryGLM

        !--------------------------------------------------------------------------
        ! Impose a horizontal velocity in the land faces equal to minus the Stokes drift velocity.
        ! This ensures a zero total mass flux through land boundaries.
        ! This is only needed to compute the horizontal velocity in faces adjecent to land and
        ! uncovered faces (with same definition as in Compute_Velocity)

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real, pointer, dimension(:,:,:)        :: Velocity_UV_New, StokesVel_UV_New

        integer, pointer, dimension(:,:,:)     :: LandBoundaryFacesUV, ComputeFaces3D_UV, OpenPoints3D !WaterPoints3D

        integer                                :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB, di, dj

        integer                                :: FaceAdjacentToWater, Coef

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di =  Me%Direction%di
        dj =  Me%Direction%dj

        LandBoundaryFacesUV => Me%External_Var%LandBoundaryFacesUV
        ComputeFaces3D_UV   => Me%External_Var%ComputeFaces3D_UV
        ! WaterPoints3D       => Me%External_Var%WaterPoints3D
        OpenPoints3D       => Me%External_Var%OpenPoints3D

        Velocity_UV_New     => Me%Velocity%Horizontal%UV%New

        StokesVel_UV_New     => Me%StokesVel%Horizontal%UV%New

        !End - Shorten variables name


        do  k = KLB, KUB
        do  j = JLB, JUB
        do  i = ILB, IUB

            ! Land boundary condition (next to a non waterpoint cell)
            ! Nul normal component of total velocity i.e.  = -Us
            Velocity_UV_New (i, j, k) = Velocity_UV_New (i, j, k) * (1. - LandBoundaryFacesUV(i, j, k))   &
                                      - StokesVel_UV_New (i, j, k) * LandBoundaryFacesUV(i, j, k)


            ! UnCovered faces condition (next to a cell that is a waterpoint but uncovered at this time step)
            ! Nul normal component of total velocity i.e.  = -Us
            Coef = OpenPoints3D(i, j, k) + OpenPoints3D(i-di, j-dj, k)
            ! Coef = WaterPoints3D(i, j, k) + WaterPoints3D(i-di, j-dj, k)

            if (Coef > 0) Coef = 1

            FaceAdjacentToWater = (1. - ComputeFaces3D_UV(i, j, k)) * Coef


            Velocity_UV_New (i, j, k) = Velocity_UV_New (i, j, k) * (1 - FaceAdjacentToWater)             &
                                      - StokesVel_UV_New (i, j, k) * FaceAdjacentToWater


        enddo
        enddo
        enddo

        ! nullify(Velocity_V_New)

        nullify(Velocity_UV_New)
        nullify(StokesVel_UV_New)

        nullify(LandBoundaryFacesUV)
        nullify(ComputeFaces3D_UV)
        ! nullify(WaterPoints3D)
        nullify(OpenPoints3D)


    EndSubroutine Velocity_LandBoundaryGLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces equal to the closes covered face
    ! This is only needed to compute the velocity modulus in faces adjecent to the
    ! exterior zone
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)
    ! Last modification MRV 2001: Possible separation of OB conditions for barotropic and baroclinic
    !                              components of velocity

    Subroutine Velocity_OpenBoundary


        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real, pointer, dimension(:,:,:) :: Velocity_UV_New


        !Begin - Shorten variables name


        !Begin-----------------------------------------------------------------

        Velocity_UV_New   => Me%Velocity%Horizontal%UV%New

        if( Me%ComputeOptions%BaroclinicRadia == Horizontal_) then

           call Compute_BaroclinicHorVelocity

        end if

        !PCL - temporary
cdsub: if (Me%SubModel%ON                                           .and.               &
           Me%ComputeOptions%LocalSolution /= AssimilaPlusSubModel_ .and.               &
           Me%ComputeOptions%LocalSolution /= AssimilationField_    .and.               &
           Me%ComputeOptions%LocalSolution /= AssimilaGaugeSubModel_.and.               &
           Me%ComputeOptions%LocalSolution /= AssimilaGauge_) then

            call VelSubModelNormalOB       ( Velocity_UV_New)


            call VelSubModelTangentialOB   ( Velocity_UV_New)

        else cdsub

!PCL
!            if( Me%ComputeOptions%BaroclinicRadia == Horizontal_ ) then

!                call VelNormalRadiaOpenBoundary    ( Velocity_UV_New,    &
!                                                    Me%VelBaroclinic%UV%New,&
!                                                    Me%VelBaroclinic%UV2D)



!                call VelTangentialRadiaOpenBoundary( Velocity_UV_New,    &
!                                                    Me%VelBaroclinic%UV%New,&
!                                                    Me%VelBaroclinic%UV2D)

!            else

                call VelNormalOpenBoundary     ( Velocity_UV_New)


                call VelTangentialOpenBoundary ( Velocity_UV_New)

!PCL
!            endif


        endif cdsub


        call MaskNonUsedFaces ( Velocity_UV_New)

        nullify(Velocity_UV_New)

    end Subroutine Velocity_OpenBoundary

    !------------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces equal to the sum
    ! of baroclinic component compute using a radiation equation plus
    ! a barotropic component equal to zero (option : NULL_VALUE ) or equal
    ! to the adjcent compute face barotropic component (option : NULL_GRADIENT)
    !
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)

    Subroutine VelTangentialRadiaOpenBoundary ( Velocity_UV_New,         &
                                               BaroclinicUV, BarotropicUV)


        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New, BaroclinicUV
        real,    dimension(:,:  ), pointer :: BarotropicUV

        !Local-----------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: SZZ
        real,    dimension(:,:  ), pointer :: DUX_VY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: BoundaryPoints, KFloor_UV

        real                               :: Coef, Aux
        real                               :: DT_Velocity
        integer                            :: VelTangentialBoundary
        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        BoundaryPoints           => Me%External_Var%BoundaryPoints

        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV         => Me%External_Var%KFloor_UV

        DUX_VY            => Me%External_Var%DUX_VY
        SZZ               => Me%External_Var%SZZ

        DT_Velocity           = Me%Velocity%DT

        VelTangentialBoundary =  Me%ComputeOptions%VelTangentialBoundary


        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name



cd1:    if (VelTangentialBoundary == NULL_VALUE) then


            dok: do k = KLB, KUB
            doj: do j = JLB, JUB
            doi: do i = ILB, IUB

                if (ImposedTangentialFacesUV(i, j, k) == Imposed) then

                    Velocity_UV_New(i, j, k)   = BaroclinicUV(i, j, k)

                endif

            enddo doi
            enddo doj
            enddo dok


        else if (VelTangentialBoundary == NULL_GRADIENT) then cd1

            dok1: do k = KLB, KUB
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB


cd2:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then


                    Aux = ComputeFaces3D_UV(i + dj, j + di, k) *  &
                          ComputeFaces3D_UV(i - dj, j - di, k)

                    if (Aux == 1) then ! both faces are compute points
                        Coef = 0.5 ! average between the two velocities
                    else
                        Coef = 1.
                    endif

               !In the exterior faces the
                !velocity is imposed equal to the nearst compute face
                    Velocity_UV_New(i, j, k) = Coef                                * &
                                           (BarotropicUV     (i + dj, j + di   )   * &
                                            ComputeFaces3D_UV(i + dj, j + di, k)   + &
                                            BarotropicUV     (i - dj, j - di   )   * &
                                            ComputeFaces3D_UV(i - dj, j - di, k))  + &
                                            BaroclinicUV(i, j, k)

                endif cd2

            enddo doi1
            enddo doj1
            enddo dok1


        endif cd1

        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV       )
        nullify(ImposedTangentialFacesUV)
        nullify(BoundaryPoints          )
        nullify(KFloor_UV)

        nullify(DUX_VY)
        nullify(SZZ)



    end Subroutine VelTangentialRadiaOpenBoundary



    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces (faces normal to the open boundary)
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)

    Subroutine VelNormalRadiaOpenBoundary ( Velocity_UV_New,             &
                                           BaroclinicUV, BarotropicUV)


        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New, BaroclinicUV
        real,    dimension(:,:  ), pointer :: BarotropicUV

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV


        real                               :: Vel_Right, Vel_Left

        integer                            :: VelNormalBoundary, imax, jmax, imin, jmin

        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB


        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV


        VelNormalBoundary =  Me%ComputeOptions%VelNormalBoundary

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End   - Shorten variables name


        !--------------------------------------------------------------------------


cd1:    if (VelNormalBoundary == NULL_VALUE) then

            dok: do k = KLB, KUB
            doj: do j = JLB, JUB + dj
            doi: do i = ILB, IUB + di

                if (ImposedNormalFacesUV(i, j, k) == Imposed) then

                    !In the exterior faces the
                    !velocity is imposed equal to zero
                    Velocity_UV_New(i, j, k)   = BaroclinicUV(i, j, k)

                endif

            enddo doi
            enddo doj
            enddo dok

        else if (VelNormalBoundary == NULL_GRADIENT) then  cd1

            dok1: do k = KLB, KUB
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB

cd2:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then


                     Vel_Left  = BarotropicUV     (i - di, j - dj)      *  &
                                 ComputeFaces3D_UV(i - di, j - dj, k)

                     Vel_Right = BarotropicUV     (i + di, j + dj   )   *  &
                                 ComputeFaces3D_UV(i + di, j + dj, k)

                    !In the exterior faces the
                    !the barotropic velocity component is imposed equal to the nearest computed face
                    Velocity_UV_New(i, j, k)   =  Vel_Left + Vel_Right
                    !the baroclinic velocity component compute using a radiation equation is add
                    Velocity_UV_New(i, j, k)   =  Velocity_UV_New(i, j, k) + BaroclinicUV(i, j, k)

                endif  cd2

            enddo doi1
            enddo doj1
            enddo dok1

            !This is to avoid the error : arrays out of bounds

            imin = di * (IUB + di) + dj * ILB
            imax = di * (IUB + di) + dj * IUB

            jmin = dj * (JUB + dj) + di * JLB
            jmax = dj * (JUB + dj) + di * JUB

            dok2: do k = KLB, KUB
            doi2: do i= imin, imax
            doj2: do j= jmin, jmax

cd3:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then

                         Vel_Left  = Velocity_UV_New  (i - di, j - dj, k) * &
                                     ComputeFaces3D_UV(i - di, j - dj, k)

                        !In the exterior faces the
                        !velocity is imposed equal to the nearest computed face
                        Velocity_UV_New(i, j, k)   =  Vel_Left


                endif  cd3

            enddo doj2
            enddo doi2
            enddo dok2

        endif cd1


        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV)
        nullify(ImposedNormalFacesUV)

    end Subroutine VelNormalRadiaOpenBoundary

    !------------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces (faces normal to the open boundary)
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)

    Subroutine MaskNonUsedFaces (Velocity_UV_New)


        !Arguments-------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_New

        !Local-----------------------------------------------------------------
        integer, dimension(:,:  ), pointer :: BoundaryPoints, BoundaryFacesUV, ExteriorFacesUV
        integer                            :: I, J, K, di, dj
        integer                            :: status

        !Begin----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "MaskNonUsedFaces")

        !Begin - Shorten variables name
        BoundaryFacesUV => Me%External_Var%BoundaryFacesUV
        BoundaryPoints  => Me%External_Var%BoundaryPoints

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End   - Shorten variables name

cd0:    if      (Me%Direction%XY == DirectionX_) then

            call GetExteriorBoundaryFaces(Me%ObjHorizontalMap,              &
                                          BoundaryPointsFaceU = ExteriorFacesUV, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, "MaskNonUsedFaces; Hydrodynamic. ERR01")

        else if (Me%Direction%XY == DirectionY_) then cd0

            call GetExteriorBoundaryFaces(Me%ObjHorizontalMap,              &
                                      BoundaryPointsFaceV = ExteriorFacesUV, STAT = status)

            if (status /= SUCCESS_)                                                      &
                call SetError(FATAL_, INTERNAL_, "MaskNonUsedFaces; Hydrodynamic. ERR02")

        endif cd0

        !--------------------------------------------------------------------------

        !$OMP PARALLEL PRIVATE(i,j,k)
doj:    do j = Me%WorkSize%JLB, Me%WorkSize%JUB
doi:    do i = Me%WorkSize%ILB, Me%WorkSize%IUB

cd1:        if (BoundaryPoints(i, j) == Boundary) then


cd2:            if(BoundaryFacesUV(i     , j     ) == Not_Boundary .and.                 &
                   BoundaryFacesUV(i + di, j + dj) == Not_Boundary) then

cd3:                if (ExteriorFacesUV(i, j) == Exterior) then

                       !$OMP DO SCHEDULE(DYNAMIC,CHUNKK)
                       do k = Me%WorkSize%KLB,  Me%WorkSize%KUB
                            Velocity_UV_New(i, j, k) = Velocity_UV_New(i + di, j + dj, k)
                       enddo
                       !$OMP END DO

                    else if (ExteriorFacesUV(i + di, j + dj) == Exterior) then cd3

                        !$OMP DO SCHEDULE(DYNAMIC,CHUNKK)
                        do k = Me%WorkSize%KLB,  Me%WorkSize%KUB
                            Velocity_UV_New(i + di, j + dj, k) = Velocity_UV_New(i, j, k)
                        enddo
                        !$OMP END DO

                    endif cd3

                endif cd2

            endif cd1

        enddo doi
        enddo doj
        !$OMP END PARALLEL


        call UnGetHorizontalMap (Me%ObjHorizontalMap,                       &
                                 ExteriorFacesUV, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError(FATAL_, INTERNAL_, "MaskNonUsedFaces; Hydrodynamic. ERR03")


        !Nullify auxiliar pointers
        nullify(BoundaryFacesUV)
        nullify(BoundaryPoints )

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "MaskNonUsedFaces")

    end Subroutine MaskNonUsedFaces

    !------------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces (faces normal to the open boundary)
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)

    Subroutine VelNormalOpenBoundary ( Velocity_UV_New)


        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New

        !Local-----------------------------------------------------------------

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV


        real                               :: Vel_Right, Vel_Left

        integer                            :: VelNormalBoundary, imax, jmax, imin, jmin

        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

! Modified by Matthias DELPEY - 02/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        real,    dimension(:,:,:), pointer :: StokesVel_UV_New
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV


        VelNormalBoundary =  Me%ComputeOptions%VelNormalBoundary

        di  = Me%Direction%di
        dj  = Me%Direction%dj

! Modified by Matthias DELPEY - 02/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        StokesVel_UV_New  =>  Me%StokesVel%Horizontal%UV%New
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



        !End   - Shorten variables name


        !--------------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "VelNormalOpenBoundary")
        endif

cd1:    if (VelNormalBoundary == NULL_VALUE) then

            CHUNK = CHUNK_J(JLB, JUB + dj)

            !$OMP PARALLEL PRIVATE(i,j,k)
            dok: do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj: do j = JLB, JUB + dj
            doi: do i = ILB, IUB + di

! Modified by Matthias DELPEY - 02/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!In the exterior faces the
                !!velocity is imposed equal to zero
                !Velocity_UV_New(i, j, k)   = Velocity_UV_New(i, j, k)         * &
                !                             (1. - ImposedNormalFacesUV(i, j, k))

                if (Me%ComputeOptions%WaveForcing3D /= GLM) then
                    !In the exterior faces the
                    !velocity is imposed equal to zero
                    Velocity_UV_New(i, j, k)   = Velocity_UV_New(i, j, k)         * &
                                                 (1. - ImposedNormalFacesUV(i, j, k))

                else
                    if (ImposedNormalFacesUV(i, j, k) == 1) then
                        ! Impose the nul value for the sum of the Stokes Drift and the quasi-eulerian velocity
                        Velocity_UV_New(i, j, k)   = - StokesVel_UV_New(i, j, k) * ImposedNormalFacesUV(i, j, k)
                    endif

                endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            enddo doi
            enddo doj
            !$OMP END DO NOWAIT
            enddo dok
            !$OMP END PARALLEL

        else if (VelNormalBoundary == NULL_GRADIENT) then  cd1

            CHUNK = CHUNK_K(KLB, KUB)

            !$OMP PARALLEL PRIVATE(i,j,k,Vel_Left,Vel_Right)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            dok1: do k = KLB, KUB
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB

cd2:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then


                     Vel_Left  = Velocity_UV_New  (i - di, j - dj, k)   *  &
                                 ComputeFaces3D_UV(i - di, j - dj, k)

                     Vel_Right = Velocity_UV_New  (i + di, j + dj, k)   *  &
                                 ComputeFaces3D_UV(i + di, j + dj, k)

                    !In the exterior faces the
                    !velocity is imposed equal to the nearest computed face
                    Velocity_UV_New(i, j, k)   =  Vel_Left + Vel_Right

                endif  cd2

            enddo doi1
            enddo doj1
            enddo dok1
            !$OMP END DO NOWAIT

            !$OMP MASTER
            !This is to avoid the error : arrays out of bounds

            imin = di * (IUB + di) + dj * ILB
            imax = di * (IUB + di) + dj * IUB

            jmin = dj * (JUB + dj) + di * JLB
            jmax = dj * (JUB + dj) + di * JUB
            !$OMP END MASTER
            !$OMP BARRIER

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            dok2: do k = KLB, KUB
            doi2: do i= imin, imax
            doj2: do j= jmin, jmax

cd3:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then

                         Vel_Left  = Velocity_UV_New  (i - di, j - dj, k) * &
                                     ComputeFaces3D_UV(i - di, j - dj, k)

                        !In the exterior faces the
                        !velocity is imposed equal to the nearest computed face
                        Velocity_UV_New(i, j, k)   =  Vel_Left


                endif  cd3

            enddo doj2
            enddo doi2
            enddo dok2
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd1

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "VelNormalOpenBoundary")
        endif

        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV)
        nullify(ImposedNormalFacesUV)

    end Subroutine VelNormalOpenBoundary

    !------------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces equal to the closes covered face
    ! This is only needed to compute the velocity modulus in faces adjecent to the
    ! exterior zone
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)

    Subroutine VelTangentialOpenBoundary ( Velocity_UV_New)


        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New

        !Local-----------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: SZZ
        real,    dimension(:,:  ), pointer :: DUX_VY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: BoundaryPoints, KFloor_UV

        real                               :: Coef, Aux
        real                               :: DT_Velocity
        integer                            :: VelTangentialBoundary
        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

! Modified by Matthias DELPEY - 02/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        real,    dimension(:,:,:), pointer :: StokesVel_UV_New
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        BoundaryPoints           => Me%External_Var%BoundaryPoints

        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV         => Me%External_Var%KFloor_UV

        DUX_VY            => Me%External_Var%DUX_VY
        SZZ               => Me%External_Var%SZZ

        DT_Velocity           = Me%Velocity%DT

        VelTangentialBoundary =  Me%ComputeOptions%VelTangentialBoundary

! Modified by Matthias DELPEY - 02/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        StokesVel_UV_New  =>  Me%StokesVel%Horizontal%UV%New
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "VelTangentialOpenBoundary")
        endif

cd1:    if (VelTangentialBoundary == NULL_VALUE) then

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j,k)

            dok: do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj: do j = JLB, JUB
            doi: do i = ILB, IUB

                !iSouth  = i - di
                !jWest   = j - dj



! Modified by Matthias DELPEY - 02/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!In the faces that have boundary points in both sides
                !!velocity is imposed equal to zero
                !Velocity_UV_New(i, j, k)   = Velocity_UV_New(i, j, k)         *          &
                !                             (1- ImposedTangentialFacesUV(i, j, k))
!!                                             (1. - BoundaryPoints(i, j)       *          &
!!                                             BoundaryPoints(iSouth, jWest))

                if (Me%ComputeOptions%WaveForcing3D /= GLM) then
                    !In the faces that have boundary points in both sides
                    !velocity is imposed equal to zero
                    Velocity_UV_New(i, j, k)   = Velocity_UV_New(i, j, k)         *          &
                                                 (1- ImposedTangentialFacesUV(i, j, k))
                else

                    if (ImposedTangentialFacesUV(i, j, k) == Imposed) then
                        Velocity_UV_New(i, j, k)   = - StokesVel_UV_New(i, j, k) * ImposedTangentialFacesUV(i, j, k)
                    endif

                endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            enddo doi
            enddo doj
            !$OMP END DO
            enddo dok
            !$OMP END PARALLEL

        else if (VelTangentialBoundary == NULL_GRADIENT) then cd1

            CHUNK = CHUNK_K(KLB, KUB)

            !$OMP PARALLEL PRIVATE(i,j,k,Aux,Coef)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            dok1: do k = KLB, KUB
            doj1: do j = JLB, JUB
            doi1: do i = ILB, IUB

!                iSouth  = i - di
!                jWest   = j - dj

!cd2:            if (BoundaryPoints(i      , j     ) == Boundary .and. &
!                    BoundaryPoints(iSouth, jWest) == Boundary) then

cd2:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then


                    Aux = ComputeFaces3D_UV(i + dj, j + di, k) *  &
                          ComputeFaces3D_UV(i - dj, j - di, k)

                    if (Aux == 1) then ! both faces are compute points
                        Coef = 0.5 ! average between the two velocities
                    else
                        Coef = 1.
                    endif

               !In the exterior faces the
                !velocity is imposed equal to the nearst compute face
                    Velocity_UV_New(i, j, k) = Coef                                * &
                                           (Velocity_UV_New  (i + dj, j + di, k)   * &
                                            ComputeFaces3D_UV(i + dj, j + di, k)   + &
                                            Velocity_UV_New  (i - dj, j - di, k)   * &
                                            ComputeFaces3D_UV(i - dj, j - di, k))

                endif cd2

            enddo doi1
            enddo doj1
            enddo dok1
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd1

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "VelTangentialOpenBoundary")
        endif

        !Nullify auxiliar pointers
        nullify(ComputeFaces3D_UV       )
        nullify(ImposedTangentialFacesUV)
        nullify(BoundaryPoints          )
        nullify(KFloor_UV)

        nullify(DUX_VY)
        nullify(SZZ)

        nullify(StokesVel_UV_New)

    end Subroutine VelTangentialOpenBoundary


    !--------------------------------------------------------------------------
    ! Impose a horizontal velocity in the exterior faces
    !
    ! Input : Flow, Mapping
    ! OutPut: Velocity
    ! Author: Paulo Chambel (99/6)

    Subroutine VelSubModelNormalOB ( Velocity_UV_New)



        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New

        !Local-----------------------------------------------------------------

        integer, dimension(:,:,:), pointer :: ImposedNormalFacesUV

        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name



        !--------------------------------------------------------------------------

cd5:     if (Me%SubModel%Set) then

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "VelSubModelNormalOB")
            endif

            CHUNK = CHUNK_J(JLB, JUB + dj)
            !$OMP PARALLEL PRIVATE(i,j,k)
            dok2: do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj2: do j = JLB, JUB + dj
            doi2: do i = ILB, IUB + di

                !The faces that are exterior are put equal to the father model

cd4:            if (Me%External_Var%ImposedNormalFacesUV(i, j, k) == Imposed) then

                    Velocity_UV_New(i, j, k)   =  Me%SubModel%UV_New(i, j, k)

                endif cd4

            enddo doi2
            enddo doj2
            !$OMP END DO NOWAIT
            enddo dok2
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "VelSubModelNormalOB")
            endif

        else cd5

            call SetError (FATAL_, INTERNAL_, "VelSubModelNormalOB - Hydrodynamic - ERR01")


        endif cd5



        !Nullify auxiliar pointers
        nullify(ImposedNormalFacesUV)

    end Subroutine VelSubModelNormalOB

    !------------------------------------------------------------------------------
    !------------------------------------------------------------------------------

    ! Author: Paulo Chambel (99/6)

    Subroutine VelSubModelTangentialOB ( Velocity_UV_New)


        !Arguments-------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_New

        !Local-----------------------------------------------------------------

        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV

        integer                            :: I, J, K, di, dj
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name


        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB


        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV


        di  = Me%Direction%di
        dj  = Me%Direction%dj


        !End   - Shorten variables name



        !--------------------------------------------------------------------------

cd5:     if (Me%SubModel%Set) then

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "VelSubModelTangentialOB")
            endif

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j,k)
            dok2: do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            doj2: do j = JLB, JUB
            doi2: do i = ILB, IUB

                !In the faces that have boundary points in both sides
                !velocity is imposed equal to the father velocity

cd4:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then

                    Velocity_UV_New(i, j, k)   =  Me%SubModel%UV_New(i, j, k)

                endif cd4

            enddo doi2
            enddo doj2
            !$OMP END DO NOWAIT
            enddo dok2
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "VelSubModelTangentialOB")
            endif

        else cd5

            call SetError (FATAL_, INTERNAL_, "VelSubModelTangentialOB - Hydrodynamic - ERR01")


        endif cd5



        !Nullify auxiliar pointers
        nullify(ImposedTangentialFacesUV)




    end Subroutine VelSubModelTangentialOB

    !------------------------------------------------------------------------------

           !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Computes barotropic velocities by vertically integrating velocities                  !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Barotropic velocities                                                        !
    ! Author: Manuel Ruiz Villarreal (01/4)                                                !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine Compute_BaroclinicHorVelocity

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY
        real,    dimension(:,:,:), pointer :: Baroclinic_UV_New, Baroclinic_UV_Old,      &
                                              Velocity_UV_New, Area_UV, DWZ, Baroclinic_VU_New
        real,    dimension(:,:  ), pointer :: WaterColumnUV, WaterColumnZ, DYY_XX,       &
                                              DUX_VY, BarotropicUV
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV,   &
                                              ImposedTangentialFacesUV

        real                               :: DT_Velocity, WaveCelerityX, InternalCelerity
        real                               :: VelNormal, VelTang, VelMod, NormalDirection, TangDirection, LimitMax
        real(8)                            :: BarotropicVelocity

        integer                            :: I, J, K, kbottom, di, dj, ib , jb
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB,              &
                                              IUBSize, ILBSize, JUBSize, JLBSize

        integer                            :: i0, j0, i1, j1, i2, j2, i3, j3, i4, j4

        integer                            :: NP, NT

        logical                            :: EastNorthBoundary, ConstantCelerity, ExplDiscrt

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        IUBSize = Me%Size%IUB
        ILBSize = Me%Size%ILB
        JUBSize = Me%Size%JUB
        JLBSize = Me%Size%JLB


        DT_Velocity  = Me%Velocity%DT

        NP = 1
        NT = 1

        if (Me%VelBaroclinic%BaroclinicOBCDiscret  == Explicit_) then

            ExplDiscrt = .true.

        else

            ExplDiscrt = .false.

        endif

        WaterColumnUV            => Me%External_Var%WaterColumnUV
        WaterColumnZ             => Me%External_Var%WaterColumn
        DWZ                      => Me%External_Var%DWZ
        Area_UV                  => Me%External_Var%Area_UV
        DYY_XX                   => Me%External_Var%DYY_XX
        DUX_VY                   => Me%External_Var%DUX_VY

        !Flow
        WaterFlux_XY             => Me%WaterFluxes%XY
        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV     => Me%External_Var%ImposedNormalFacesUV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        Baroclinic_UV_New        => Me%VelBaroclinic%UV%New
        Baroclinic_VU_New        => Me%VelBaroclinic%VU%New
        Baroclinic_UV_Old        => Me%VelBaroclinic%UV%Old
        BarotropicUV             => Me%VelBaroclinic%UV2D

        Velocity_UV_New          => Me%Velocity%Horizontal%UV%New


        !End - Shorten


        di                = Me%Direction%di
        dj                = Me%Direction%dj

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Compute_BaroclinicHorVelocity")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,BarotropicVelocity)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        !Baroclinic velocities are computed in every point of the domain.
        !In principle, it only needs to be computed at boundaryfaces if we don't want to do output of barotropic velocities
        doj1: do j = JLB, JUB
        doi1: do i = ILB, IUB


          !Compute internal baroclinic velocity
cd1:      if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

              kbottom            = Me%External_Var%kfloor_UV(i, j)

              BarotropicVelocity = 0.

              do  k = kbottom, KUB
                  ![m^3/s]           = [m^3/s] + [m/s] * [m^2]
                  BarotropicVelocity = BarotropicVelocity + dble(Velocity_UV_New(i, j, k)) * &
                                                            dble(Area_UV(i, j, k))

              enddo

              BarotropicVelocity = BarotropicVelocity / dble(WaterColumnUV(i,j)) / dble(DYY_XX (i,j))

              BarotropicUV(i, j) = real(BarotropicVelocity)

              do  k = kbottom, KUB

                  Baroclinic_UV_Old (i, j, k) = Baroclinic_UV_New (i, j, k)

                  Baroclinic_UV_New (i, j, k) = Velocity_UV_New(i, j, k) - BarotropicUV(i, j)


              enddo


           endif cd1

        end do doi1
        end do doj1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Compute_BaroclinicHorVelocity")
        endif

doj2:   do j = JLB, JUB + dj
doi2:   do i = ILB, IUB + di


dok2:       do k = KLB, KUB
cd2:            if (ImposedNormalFacesUV(i, j, k) == Imposed) then


                    if (ComputeFaces3D_UV(i - di, j - dj, k) == Covered) then

                        ib  = i - di
                        jb  = j - dj

                        EastNorthBoundary = .true.

                        i0  = i -     di
                        j0  = j -     dj

                        i1  = i - 2 * di
                        j1  = j - 2 * dj

                        i2  = i - 2 * di + dj
                        j2  = j - 2 * dj + di

                        i3  = i - 2 * di
                        j3  = j - 2 * dj




                    else if (ComputeFaces3D_UV(i + di, j + dj, k) == Covered) then

                        ib  = i
                        jb  = j
                        EastNorthBoundary = .false.

                        i0  = i + di
                        j0  = j + dj

                        i1  = i + 2 * di
                        j1  = j + 2 * dj

                        i2  = i + di + dj
                        j2  = j + dj + di

                        i3  = i + di
                        j3  = j + dj


                    else

                        call SetError (FATAL_, INTERNAL_, "Compute_BaroclinicHorVelocity - Hydrodynamic - ERR01")

                    endif

                    ConstantCelerity = .false.

                    if (Me%VelBaroclinic%CelerityType /= Orlanski_) then

                        ConstantCelerity = .true.

                        if (Me%VelBaroclinic%CelerityType == Constant_) then

                            InternalCelerity = Me%VelBaroclinic%InternalCelerity &
                                               * DT_Velocity / DUX_VY(ib, jb)

                        else if (Me%VelBaroclinic%CelerityType == OeyAndChen_) then

                            InternalCelerity = sqrt(1e-3 * Gravity * WaterColumnUV(i0, j0)) &
                                               * DT_Velocity / DUX_VY(ib, jb)

                        endif


                        VelNormal        = (Baroclinic_UV_New(i0, j0, k) + Baroclinic_UV_New(i1, j1, k)) / 2.
                        VelTang          = (Baroclinic_VU_New(i2, j2, k) + Baroclinic_VU_New(i3, j3, k)) / 2.
                        VelMod           = sqrt(VelNormal ** 2 + VelTang ** 2)

                        if (VelMod < Me%VelBaroclinic%MinLeavingBaroclincVel) then

                            NormalDirection  = 1.
                            TangDirection    = 0.

                        else

                            NormalDirection  = abs (VelNormal) / VelMod
                            TangDirection    = abs (VelTang  ) / VelMod

                            if (EastNorthBoundary) then

                                if ((VelTang * VelNormal) < 0) TangDirection = - TangDirection

                            else

                                if ((VelTang * VelNormal) > 0) TangDirection = - TangDirection

                            endif

                        endif

                    else

                        !Maximum internal velocity allowed (MaxInternalCelerity = 10 m/s)
                        LimitMax = MaxInternalCelerity * DT_Velocity / DUX_VY(ib, jb)

                    endif

                    if (Me%VelBaroclinic%BaroclinicOBCDiscret  == StoreWave_) then

                        !PCL begin

                        WaveCelerityX = NormalDirection * InternalCelerity

                        call BoundaryInstantList (Me%VelBaroclinic%ImposedNormXY(NP), &
                                                  Me%CurrentTime, Baroclinic_UV_New,  &
                                                  Baroclinic_UV_Old, DT_Velocity,                  &
                                                  Me%VelBaroclinic%DTWave,            &
                                                  WaveCelerityX, i, j, k, i0, j0)

                        NP = NP + 1

                        !PCL end

                    else

                        call OrlanskiCelerity2D(NewField          = Baroclinic_UV_New,       &
                                                OldField          = Baroclinic_UV_Old,       &
                                                ComputePoints     = ComputeFaces3D_UV,       &
                                                Imin              = ILBSize,                 &
                                                Imax              = IUBSize,                 &
                                                Jmin              = JLBSize,                 &
                                                Jmax              = JUBSize,                 &
                                                di                = di,                      &
                                                dj                = dj,                      &
                                                i                 =  i,                      &
                                                j                 =  j,                      &
                                                k                 =  k,                      &
                                                EastNorthBoundary = EastNorthBoundary,       &
                                                DT                = DT_Velocity,           &
                                                LimitMax          = LimitMax,                &
                                                TrelaxIn          = Me%VelBaroclinic%TRelaxIn,          &
                                                TrelaxOut         = Me%VelBaroclinic%TRelaxOut,        &
                                                InternalCelerity  = InternalCelerity,        &
                                                WaveDirectionX    = NormalDirection,         &
                                                WaveDirectionY    = TangDirection,           &
                                                ConstantCelerity  = ConstantCelerity,        &
                                                NormalRadiation   = Me%VelBaroclinic%BaroclinicNormalRadiation,   &
                                                Explicit          = ExplDiscrt,              &
                                                WaveCelerityX     = WaveCelerityX)

                    endif



                endif cd2

cd3:            if (ImposedTangentialFacesUV(i, j, k) == Imposed) then


                    if (ComputeFaces3D_UV(i - dj, j - di, k) == Covered) then

                        EastNorthBoundary = .true.

                        i0  = i -     dj
                        j0  = j -     di

                        i1  = i -     di
                        j1  = j -     dj

                        i2  = i
                        j2  = j

                        i3  = i - di - dj
                        j3  = j - dj - di

                        i4  = i - dj
                        j4  = j - di



                    else if (ComputeFaces3D_UV(i + dj, j + di, k) == Covered) then


                        EastNorthBoundary = .false.

                        i0  = i + dj
                        j0  = j + di

                        i1  = i + dj
                        j1  = j + di

                        i2  = i - di + dj
                        j2  = j - dj + di

                        i3  = i + 2 * dj
                        j3  = j + 2 * di

                        i4  = i - di + 2 * dj
                        j4  = j - dj + 2 * di

                    else

!                       call SetError (FATAL_, INTERNAL_, "Compute_BaroclinicHorVelocity - Hydrodynamic - ERR02")
                        Cycle


                    endif

                    ConstantCelerity = .false.

                    if (Me%VelBaroclinic%CelerityType /= Orlanski_) then

                        ConstantCelerity = .true.

                        if (Me%VelBaroclinic%CelerityType == Constant_) then

                            InternalCelerity = Me%VelBaroclinic%InternalCelerity &
                                               * DT_Velocity / (DYY_XX(i, j) + DYY_XX(i0, j0)) * 2.

                        else if (Me%VelBaroclinic%CelerityType == OeyAndChen_) then

                            InternalCelerity = sqrt(1e-3 * Gravity * WaterColumnUV(i0, j0)) &
                                               * DT_Velocity / (DYY_XX(i, j) + DYY_XX(i0, j0)) * 2.

                        endif



                        VelNormal        = (Baroclinic_VU_New(i1, j1, k) + Baroclinic_VU_New(i2, j2, k) + &
                                            Baroclinic_VU_New(i3, j3, k) + Baroclinic_VU_New(i4, j4, k)) / 4.
                        VelTang          =  Baroclinic_UV_New(i0, j0, k)
                        VelMod           = sqrt(VelNormal ** 2 + VelTang ** 2)

                        if (VelMod < Me%VelBaroclinic%MinLeavingBaroclincVel) then

                            NormalDirection  = 1.
                            TangDirection    = 0.

                        else

                            NormalDirection  = abs (VelNormal) / VelMod
                            TangDirection    = abs (VelTang  ) / VelMod

                            if (EastNorthBoundary) then

                                if ((VelTang * VelNormal) < 0) TangDirection = - TangDirection

                            else

                                if ((VelTang * VelNormal) > 0) TangDirection = - TangDirection

                            endif

                        endif

                    else

                        !Maximum internal velocity allowed (MaxInternalCelerity = 10 m/s)
                        LimitMax = MaxInternalCelerity * DT_Velocity / (DYY_XX(i, j) + DYY_XX(i0, j0)) * 2.

                    endif

                    if (Me%VelBaroclinic%BaroclinicOBCDiscret  == StoreWave_) then

                        !PCL begin
                        WaveCelerityX = NormalDirection * InternalCelerity

                        call BoundaryInstantList (Me%VelBaroclinic%ImposedTangXY(NT), &
                                                  Me%CurrentTime, Baroclinic_UV_New,  &
                                                  Baroclinic_UV_Old, DT_Velocity,                  &
                                                  Me%VelBaroclinic%DTWave,            &
                                                  WaveCelerityX, i, j, k, i0, j0)

                        NT = NT + 1

                        !PCL end

                    else

                        call OrlanskiCelerity2D(NewField          = Baroclinic_UV_New,       &
                                                OldField          = Baroclinic_UV_Old,       &
                                                ComputePoints     = ComputeFaces3D_UV,       &
                                                Imin              = ILBSize,                 &
                                                Imax              = IUBSize,                 &
                                                Jmin              = JLBSize,                 &
                                                Jmax              = JUBSize,                 &
                                                di                = dj,                      &
                                                dj                = di,                      &
                                                i                 =  i,                      &
                                                j                 =  j,                      &
                                                k                 =  k,                      &
                                                EastNorthBoundary = EastNorthBoundary,       &
                                                DT                = DT_Velocity,             &
                                                LimitMax          = LimitMax,                &
                                                TrelaxIn          = Me%VelBaroclinic%TRelaxIn,          &
                                                TrelaxOut         = Me%VelBaroclinic%TRelaxOut,        &
                                                InternalCelerity  = InternalCelerity,        &
                                                WaveDirectionX    = NormalDirection,         &
                                                WaveDirectionY    = TangDirection,           &
                                                ConstantCelerity  = ConstantCelerity,        &
                                                NormalRadiation   = Me%VelBaroclinic%BaroclinicNormalRadiation, &
                                                Explicit          = ExplDiscrt,              &
                                                WaveCelerityX     = WaveCelerityX)

                    endif

                endif cd3


            end do dok2



        end do doi2
        end do doj2

        nullify (WaterFlux_XY            )
        nullify (WaterColumnUV           )
        nullify (Area_UV                 )
        nullify (DYY_XX                  )
        nullify (DUX_VY                  )
        nullify (ComputeFaces3D_UV       )
        nullify (ImposedNormalFacesUV    )
        nullify (ImposedTangentialFacesUV)
        nullify (Baroclinic_UV_New       )
        nullify (Baroclinic_VU_New       )
        nullify (Baroclinic_UV_Old       )
        nullify (Velocity_UV_New         )
        nullify (WaterColumnZ            )
        nullify (DWZ                     )
        nullify (BarotropicUV            )


    end subroutine Compute_BaroclinicHorVelocity


    Subroutine BoundaryInstantList (ImposedXY, CurrentTime, Prop_New, Prop_Old, DT_Prop, &
                                    DTWave, WaveCelerityX, i, j, k, ib, jb)


        !Arguments----------------------------------------------------------------------------
        type (T_Imposed)                :: ImposedXY
        type (T_Time)                   :: CurrentTime
        real, dimension(:,:,:), pointer :: Prop_New, Prop_Old
        real                            :: DT_Prop, DTWave, WaveCelerityX
        integer                         :: i, j, k, ib, jb

        !Local--------------------------------------------------------------------------------
        type (T_InstantBound), pointer  :: InstantXY, AuxXY
        type (T_Time)                   :: NextInstant, NewInstant
        real(8)                         :: DT1, DT2
        integer                         :: status
        logical                         :: Found

        !Begin--------------------------------------------------------------------------------


        !Add Instant

cd1:    if (abs(WaveCelerityX) < 1e-4) then

            NewInstant  = CurrentTime  + DT_Prop / 1e-4

        else  cd1

            NewInstant  = CurrentTime  + DT_Prop / WaveCelerityX

        endif cd1

cd2:    if (associated(ImposedXY%FirstInstant)) then

            NextInstant = ImposedXY%LastInstant%TimeB + DTWave

        else  cd2

            call null_time(NextInstant)

        endif cd2

        nullify (InstantXY)

        allocate(InstantXY, STAT = status)

        if (status /= SUCCESS_)                                                      &
            call SetError (FATAL_, INTERNAL_, "BoundaryInstantList - Hydrodynamic - ERR01")

        nullify (InstantXY%Next)
        nullify (InstantXY%Prev)

        InstantXY%TimeB    = NewInstant
        InstantXY%BaroclVel= Prop_New(ib, jb, k)

cd3:    if (.not.associated(ImposedXY%FirstInstant)) then
            ImposedXY%Number           =  1
            ImposedXY%FirstInstant     => InstantXY
            ImposedXY%LastInstant      => InstantXY
        else  cd3

cd4:        if (.not.associated(ImposedXY%FirstInstant%Next)) then

cd5:            if (NewInstant >= NextInstant) then

                    InstantXY%Prev             => ImposedXY%LastInstant
                    ImposedXY%LastInstant%Next => InstantXY
                    ImposedXY%LastInstant      => InstantXY
                    ImposedXY%Number           =  ImposedXY%Number + 1

                endif cd5

            else  cd4

cd6:            if (NewInstant >= NextInstant) then

                    InstantXY%Prev             => ImposedXY%LastInstant
                    ImposedXY%LastInstant%Next => InstantXY
                    ImposedXY%LastInstant      => InstantXY
                    ImposedXY%Number           =  ImposedXY%Number + 1

                else  cd6

                    AuxXY => ImposedXY%FirstInstant

                    Found = .false.

                    do While(associated(AuxXY) .and. associated(AuxXY%Next))

                        if (AuxXY%TimeB <= CurrentTime .and. AuxXY%Next%TimeB >= CurrentTime) then
                            if ((CurrentTime      - AuxXY%TimeB) >  DTWave) Found = .true.
                            if ((AuxXY%Next%TimeB - CurrentTime) >  DTWave) Found = .true.
                            exit

                        endif

                        AuxXY => AuxXY%Next

                    enddo

                    if (Found) then

                        InstantXY%Prev        => AuxXY
                        InstantXY%Next        => AuxXY%Next
                        AuxXY%Next            => InstantXY
                        ImposedXY%Number      =  ImposedXY%Number + 1

                    endif

                endif cd6

            endif  cd4

        endif cd3

        !Delete obsolete instants

        nullify(InstantXY)

        nullify(AuxXY)

        if (associated(ImposedXY%FirstInstant%Next)) then

            do while (ImposedXY%FirstInstant%Next%TimeB < CurrentTime)

                AuxXY                  => ImposedXY%FirstInstant
                ImposedXY%FirstInstant => ImposedXY%FirstInstant%Next
                ImposedXY%Number       =  ImposedXY%Number - 1

                deallocate (AuxXY, STAT = status)

                if (status /= SUCCESS_)                                                      &
                    call SetError (FATAL_, INTERNAL_, "BoundaryInstantList - Hydrodynamic - ERR02")

                nullify(AuxXY)

            enddo

        endif

        nullify(AuxXY)

        AuxXY => ImposedXY%FirstInstant

        Found = .false.

        do While(associated(AuxXY) .and. associated(AuxXY%Next))

            if (AuxXY%TimeB <= CurrentTime .and. AuxXY%Next%TimeB >= CurrentTime) then

                Found = .true.
                exit

            endif


            AuxXY => AuxXY%Next

        enddo

        if (Found) then

            DT1 = AuxXY%Next%TimeB - CurrentTime
            DT2 = CurrentTime      - AuxXY%TimeB

            Prop_Old(i, j, k) =  Prop_New(i, j, k)

            Prop_New(i, j, k) = (real(DT1) * AuxXY%BaroclVel + real(DT2) * AuxXY%Next%BaroclVel) /       &
                                 real(DT1 + DT2)

        else

            Prop_New(i, j, k) = 0.

        endif

        nullify(AuxXY)

    end subroutine BoundaryInstantList



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Actualizes variables needed to impose boundary conditions                            !
    ! at the bottom and at the surface                                                     !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Chezy                                                                        !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Bottom_Boundary


        !Arguments-----------------------------------------------------------------

         !Categories
            !Bottom    : Chezy, Rugosity, HMIN_ATR
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : KFloor_Z


        !Arguments------------------------------------------------------------


        !Local-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Bottom_Boundary")

       !Bottom boundary
        call Modify_ChezyZ

        call Modify_ChezyVelUV


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Bottom_Boundary")

    !------------------------------------------------------------------------------

    End Subroutine Bottom_Boundary

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the Chezy bottom friction coeficient                                         !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Chezy                                                                        !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_ChezyZ

        !Variables Categories
            !Geometry  : DWZ
            !Bottom    : Chezy, Rugosity, HMIN_ATR
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : KFloor_Z

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DWZ
        real,    dimension(:,:),   pointer :: ChezyZ, RugosityMatrix
        integer, dimension(:,:,:), pointer :: WaterPoints3D
        integer, dimension(:,:),   pointer :: KFloor_Z
        real                               :: AuxZ, Hmin_Chezy, EP, WallDistance, Rugosity
        logical                            :: Manning

        integer                            :: IUB, ILB, JUB, JLB, KUB
        integer                            :: I, J, kbottom

        real                               :: U, V, VelMod_Z, Ubw, Abw

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        Hmin_Chezy     =  Me%External_Var%Hmin_Chezy

        Manning        =  Me%External_Var%Manning

        RugosityMatrix => Me%External_Var%RugosityMatrix

        ChezyZ         => Me%External_Var%ChezyZ

        KFloor_Z       => Me%External_Var%KFloor_Z

        WaterPoints3D  => Me%External_Var%WaterPoints3D
        DWZ            => Me%External_Var%DWZ

        !End - Shorten variables name


        if (KUB > 1 .and. Manning) then

            call SetError (FATAL_, INTERNAL_, "Modify_ChezyZ - Hydrodynamic - ERR03")

        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_ChezyZ")
        endif

        !$OMP PARALLEL PRIVATE(i,j,AuxZ,Kbottom,EP,Rugosity,WallDistance)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do  j = JLB, JUB
doi:    do  i = ILB, IUB

cd2:        if (WaterPoints3D(i, j, KUB) == WaterPoint) then
                ! For a non water point Kfloor_Z = -999999
                Kbottom     = KFloor_Z(i, j)

                AUXZ        = MAX(DWZ(I, J, Kbottom), Hmin_Chezy)

                EP          = 1./3.


cd0:            if (Me%External_Var%Chezy) then

                    ChezyZ(i, j) = Me%External_Var%ChezyCoef

                else cd0

                    Rugosity    = RugosityMatrix(i, j)

cd1:                if (Rugosity == 0.) then

                        ChezyZ(i, j) = 0.

                    else cd1

cd3:                    if (Manning) then

                             ![]          =  [m/s2] *   [m-1/3 * s]**2         / [m1/3]
                             ChezyZ(i, j) = Gravity * Rugosity**2 / AUXZ**EP

                         else cd3

                            if(Me%External_Var%ShearStressMethod == 1) then
                                !To avoid wall distance values lower than rugosity
                                WallDistance = AuxZ/2. + Rugosity

                                if (WallDistance <= Rugosity) then
                                    !!!! $OMP CRITICAL (MCZ1_ERR04)
                                    call SetError (FATAL_, INTERNAL_, "Modify_ChezyZ - Hydrodynamic - ERR04")
                                    !!!! $OMP END CRITICAL (MCZ1_ERR04)
                                endif

                                ! [] = [] / log ([m]/[m])
                                ChezyZ(i, j) = (Const_VonKarman / LOG(WallDistance / Rugosity))**2.

                            elseif (Me%External_Var%ShearStressMethod == 2) then

                                V = (Me%Velocity%Horizontal%V%New(i+1,j,kbottom)+Me%Velocity%Horizontal%V%New(i,j,  kbottom))/2.
                                U = (Me%Velocity%Horizontal%U%New(i,  j,kbottom)+Me%Velocity%Horizontal%U%New(i,j+1,kbottom))/2.

                                VelMod_Z = sqrt(U*U+V*V)

                                if (Me%ComputeOptions%WaveShearStress) then

                                    Ubw = Me%External_Var%Ubw(i,j)
                                    Abw = Me%External_Var%Abw(i,j)

                                    ChezyZ(i, j) = CDM ( AuxZ, Rugosity, VelMod_Z, Ubw, Abw)
                                else
                                    ChezyZ(i, j) = CDM ( AuxZ, Rugosity, VelMod_Z)
                                endif

                            endif


                         endif cd3

                    endif cd1

                endif cd0

            endif cd2

        enddo doi
        enddo doj
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_ChezyZ")
        endif

        !Nullify auxiliar variables
        nullify (KFloor_Z)
        nullify (DWZ)
        nullify (ChezyZ)
        nullify (WaterPoints3D)
        nullify (RugosityMatrix)

    end Subroutine Modify_ChezyZ

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the Chezy bottom friction coeficient                                         !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Chezy                                                                        !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_ChezyVelUV

        !Variables Categories
            !Bottom    : ChezyVelUV, Rugosity, HMIN_ATR
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : KFloor_Z

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:,:), pointer :: DUZ_VZ, Velocity_UV_New, Velocity_VU_New
        real,    dimension(:,:),   pointer :: ChezyVelUV, RugosityMatrix, DUX_VY,        &
                                              DYY_XX, DZX_ZY, DXX_YY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real                               :: AuxZ, Hmin_Chezy, EP, WallDistance,        &
                                              Rugosity, Vmin_Chezy, Chezy, DT_Z,         &
                                              VelMod_UV, DT_Velocity !, ChezyWave
        logical                            :: Manning

        integer                            :: iSouth, jWest, di, dj, i_North, j_East
        integer                            :: IUB, ILB, JUB, JLB, KUB
        integer                            :: I, J, kbottom
        real                               :: Ubw, Abw

        !$ integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB


        di                = Me%Direction%di
        dj                = Me%Direction%dj

        Hmin_Chezy        =  Me%External_Var%Hmin_Chezy

        Vmin_Chezy        =  Me%External_Var%Vmin_Chezy

        Manning           =  Me%External_Var%Manning

        DT_Velocity       =  Me%Velocity%DT

        RugosityMatrix    => Me%External_Var%RugosityMatrix

        KFloor_UV         => Me%External_Var%KFloor_UV
        Volume_UV         => Me%External_Var%Volume_UV

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        DUZ_VZ            => Me%External_Var%DUZ_VZ
        DUX_VY            => Me%External_Var%DUX_VY
        DXX_YY            => Me%External_Var%DXX_YY
        DYY_XX            => Me%External_Var%DYY_XX
        DZX_ZY            => Me%External_Var%DZX_ZY

        Velocity_UV_New   => Me%Velocity%Horizontal%UV%New
        Velocity_VU_New   => Me%Velocity%Horizontal%VU%New

        !End - Shorten variables name


        if (KUB > 1 .and. Manning) then

            call SetError (FATAL_, INTERNAL_, "Modify_ChezyVelUV - Hydrodynamic - ERR03")

        endif

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( AuxZ, EP, WallDistance,         &
        !$OMP                   Rugosity, Chezy, DT_Z,          &
        !$OMP                   VelMod_UV,                      &
        !$OMP                   iSouth, jWest, i_North, j_East,    &
        !$OMP                   I, J, kbottom, ChezyVelUV)

        ChezyVelUV        => Me%External_Var%ChezyVelUV

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do  j = JLB, JUB
doi:    do  i = ILB, IUB

cd2:        if (ComputeFaces3D_UV(i, j, KUB) == Covered) then
                ! For a non water point Kfloor_UV = -999999
                Kbottom     = KFloor_UV(i, j)

                iSouth     = i - di
                jWest      = j - dj
                ! This values (i_North and j_east) can only be use to compute the velocity modulus in a face
                i_North = i + dj
                j_East  = j + di

                ![s/m]                    = [s] / [m^3] * [m] * [m]
                DT_Z                      = DT_Velocity / Volume_UV(i, j, Kbottom)     &
                                            * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

                VelMod_UV                 = Face_Velocity_Modulus(                     &
                                            Velocity_VU_New(I_North, jWest, kbottom),  &
                                            Velocity_VU_New(I_North, J_East, kbottom), &
                                            Velocity_VU_New(iSouth, jWest, kbottom),   &
                                            Velocity_VU_New(iSouth, J_East, kbottom),  &
                                            DXX_YY(I_North, jWest),                    &
                                            DXX_YY(I_North, J_East),                   &
                                            DXX_YY(iSouth, jWest),                     &
                                            DXX_YY(iSouth, J_East),                    &
                                            Velocity_UV_New(I,J,kbottom))


cd0:            if (Me%External_Var%Chezy) then

                    Chezy = Me%External_Var%ChezyCoef

                else cd0

cd4:                if (abs(Velocity_UV_New(i, j, Kbottom)) < Vmin_Chezy) then

                        AUXZ        = MAX(DUZ_VZ(i, j, Kbottom), Hmin_Chezy)

                    else  cd4

                        AUXZ        = MAX(DUZ_VZ(i, j, Kbottom), 0.1*Hmin_Chezy)

                    endif cd4

                    EP          = 1./3.



                    Rugosity = (RugosityMatrix(i      , j     ) * DUX_VY(iSouth, jWest) +  &
                                RugosityMatrix(iSouth, jWest) * DUX_VY(i      , j     ))/  &
                               (DUX_VY        (iSouth, jWest) + DUX_VY(i      , j     ))

cd1:                if (Rugosity <= 0.) then

                        Chezy = 0.

                    else cd1

cd3:                   if (Manning) then

                            ![]         =  [m/s2] * [m-1/3 * s]**2/ [m1/3]
                            Chezy = Gravity * Rugosity**2 / AUXZ**EP

                        else cd3

                            if(Me%External_Var%ShearStressMethod == 1) then

                                !To avoid wall distance values lower than rugosity
                                WallDistance = AuxZ/2. + Rugosity

                                if (WallDistance > Rugosity) then

                                    ! [] = [] / log ([m]/[m])
                                    Chezy = (Const_VonKarman / LOG(WallDistance / Rugosity))**2.
                                else
                                    Chezy = 0.
                                endif

                            elseif (Me%External_Var%ShearStressMethod == 2) then


                                if (Me%WaveStress%ON                                      .or. &
                                    Me%ComputeOptions%WaveForcing3D == ExpRadiationStress .or. &
                                    Me%ComputeOptions%WaveForcing3D == GLM                     ) then

                                    Ubw = Me%External_Var%Ubw(i,j)
                                    Abw = Me%External_Var%Abw(i,j)

                                    Chezy = CDM ( AuxZ, Rugosity, VelMod_UV, Ubw, Abw)
                                else
                                    Chezy = CDM ( AuxZ, Rugosity, VelMod_UV)
                                endif
                            endif

                        endif cd3

                    endif cd1

                endif cd0

                ![]              = []       [s/m] * [m/s]
                !ChezyVelUV(i, j) = Chezy  * DT_Z * VelMod_UV

                !To avoid chezyUV null. This way the bottom shear stress is not null when the water cover for the first time
                !an uncovered cell. Need to be double check is schematic models

                if (.not. Me%FirstIteration .and. .not. Me%ComputeOptions%Continuous) then
                    if (VelMod_UV == 0.) VelMod_UV = 0.1
                endif

                ChezyVelUV(i, j) = Chezy  * DT_Z * VelMod_UV


!                if (Me%WaveStress%ON) then

!                    ChezyWave = Face_Interpolation(Me%External_Var%WaveChezyVel(i, j), &
!                                                   Me%External_Var%WaveChezyVel(iSouth, jWest), &
!                                                   DUX_VY(I, J), DUX_VY(iSouth, jWest))

                    ![]       = [m/s] * [s/m]
!                    ChezyWave = ChezyWave * DT_Z

!                    ChezyVelUV(i, j) = ChezyVelUV(i, j) + ChezyWave

!                endif

            else  cd2

                ChezyVelUV(i, j) = FillValueReal

            endif cd2

        enddo doi
        enddo doj
        !$OMP END DO NOWAIT

        !$OMP END PARALLEL

        !Nullify auxiliar variables
        nullify (KFloor_UV         )
        nullify (DUZ_VZ            )
        nullify (DUX_VY            )
        nullify (DUZ_VZ            )
        nullify (DUX_VY            )
        nullify (DXX_YY            )
        nullify (DYY_XX            )
        nullify (DZX_ZY            )
        nullify (ChezyVelUV        )
        nullify (ComputeFaces3D_UV )
        nullify (RugosityMatrix    )
        nullify (Velocity_UV_New   )
        nullify (Velocity_VU_New   )
        nullify (Volume_UV         )

    end Subroutine Modify_ChezyVelUV

    !------------------------------------------------------------------------------

    real function CDM (AuxZ, Z0, UC, Ubw, Abw)

        !Arguments-----------------------------------------------------------------
        real                                    :: AuxZ, Z0, UC
        real, intent(IN), optional              :: Ubw, Abw

        !Local---------------------------------------------------------------------
        real    ::  REC, REW, FWS, FWR, as, ar, T1, T2, T3, A1, A2
        real    ::  CDS, CDR, CDMS, CDMR

        !Begin----------------------------------------------------------------

        if (AuxZ < Z0*Exp(1.001)) AuxZ = Z0*Exp(1.001)
        CDR = 0.
        if(Z0 > 0.) CDR=(0.40/(log(AuxZ/Z0)-1.))**2

        REC=UC*AuxZ/WaterCinematicVisc
        CDS = 0.
        if(UC > 1e-6) CDS=0.0001615*EXP(6.*REC**(-0.08))

        CDM=MAX(CDR,CDS)

        if (present(Ubw)) then

            if(UC.gt.1e-6 .and. Ubw.gt.1e-6 .and. Abw.gt.1e-6)then !combined wave and current flow

                REW=Ubw*Abw/WaterCinematicVisc
                FWS=0.0521*REW**(-0.187)
                FWR=1.39*(Abw/Z0)**(-0.52)

                !Rough-turbulent wave-plus-current shear-stress
                ar=0.24
                T1=MAX(ar*(FWR/2)**0.5*(Abw/Z0),12.)
                T2=AuxZ/(T1*Z0)
                T3=(CDR**2+(FWR/2)**2*(Ubw/UC)**4)**(1./4)
                A1=T3*(LOG(T2)-1)/(2*LOG(T1))
                A2=0.40*T3/LOG(T1)
                if (A1<0) A1 = 0
                if (A2<0) A2 = 0
                CDMR=((A1**2+A2)**0.5-A1)**2

                !Smooth-turbulent wave-plus-current shear-stress
                as=0.24
                T1=9*as*REW*(FWS/2)**0.5*(CDS**2*(UC/Ubw)**4+(FWS/2)**2)**(1./4)
                T2=(REC/REW)*(Ubw/UC)*1/as*(2/FWS)**0.5
                T3=(CDS**2+(FWS/2)**2*(Ubw/UC)**4)**(1./4)
                A1=T3*(LOG(T2)-1)/(2*LOG(T1))
                A2=0.40*T3/LOG(T1)
                if (A1<0) A1 = 0
                if (A2<0) A2 = 0
                CDMS=((A1**2+A2)**0.5-A1)**2

                CDM = MAX(CDMR, CDMS)

            endif
        endif

    end function CDM


    !------------------------------------------------------------------------------

    !Compute all the variables common to the velocities and elevation computing
    Subroutine Explicit_Forces

        !Variables Categories
        ! Geometry   : Volume_Z, Area_VU, DWZ, DZX_ZY, DXX_YY, DUX_VY, DYY_XX, Coriolis_Freq
        ! Flow       : Visc_H_Center, Visc_H_Corner, Velocity_UV, Velocity_VU_Old,
        !              WaterFlux_XY, WaterFlux_YX
        ! Forces     : Rox3, Horizontal_Transport, Inertial_Aceleration
        ! WaterProp  : Density
        ! Options    : Baroclinic, UpStream_CenterDif, UpStream, Direction
        ! Mapping    : KFloor_UV, ComputeFaces3D_UV
        ! Domain     : ILB, IUB, JLB, JUB, KLB, KUB

        !Variables direction dependent:
        !  Velocity_UV, Velocity_VU_Old, WaterFlux_XY, WaterFlux_YX,
        !  Area_VU, DZX_ZY, DXX_YY, DUX_VY, DYY_XX, KFloor_UV, ComputeFaces3D_UV


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Explicit_Forces")



        !Inertial aceleration
        if (Me%ComputeOptions%InertiaForces) then
            if (Me%ComputeOptions%InertiaForcesOpt)then
                call Modify_InertiaForces!Joao Sobrinho
            else
                call Modify_InertiaForces2
            endif
        endif
        

        !Obstacle drag
        if (Me%ComputeOptions%Obstacle)                                         &
            call Modify_ObstacleDrag

        if (Me%ComputeOptions%Turbine)                                          &
            call ModifyTurbine(Me%ObjTurbine, Me%Velocity%Horizontal%U%New,     &
                               Me%Velocity%Horizontal%V%New,                    &
                               Me%Velocity%Horizontal%UV%New,                   &
                               Me%External_Var%Volume_UV,                       &
                               Me%External_Var%KFloor_UV,                       &
                               Me%External_Var%Density)

        !Effect of a scraper in a settling tank
        if (Me%ComputeOptions%Scraper)                                          &
            call Modify_ScraperEffect

        !Controlling the flow adding dissipation if a thinwall is open
        if (Me%ThinWalls%ON) then
            call ModifyThinWallsDissipation
        endif

        !Adds a force that relax the velocity field to a reference field
        if (Me%Relaxation%Force)                                                &
            call ModifyRelaxAceleration

        !Baroclinic density gradient integral
        if (Me%ComputeOptions%Baroclinic)                                      &
            call Modify_ROX3  (Me%External_Var%SigmaDens, Me%Forces%Rox3XY)

        !griflet: still needs to be parallelized
        call Modify_Horizontal_Transport

! Modified by Matthias DELPEY - 15/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress  .or.   &
            Me%ComputeOptions%WaveForcing3D == GLM    ) then
            call Modify_WaveForces3D
        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        !Compute the tide potential as a tide elevation
        !griflet: tide potential still needs to be correctly parallelized
        if (Me%TidePotential%Compute)                                           &
            call ModifyTidePotential

        !Adds a force that relax the velocity field to Geostrophic velocity from
        !Altimetric Assimilation
        if( Me%ComputeOptions%AltimetryAssimilation%flag .and.                                  &
            Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute)            &
            call ModifyAltimAceleration

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Explicit_Forces")

    End Subroutine Explicit_Forces

    !End-----------------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the total horizontal inertia =                              !
    !  Hor. Advection + Hor. Diffusion + Coriolis Force                                    !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Horizontal_Transport


        !Variables Categories-----------------------------------------------------------------

        !Categories
           !Geometry  : Volume_Z, Area_VU, DYY_XX, DUX_VY
           !Flow      : Velocity_UV_Old, Velocity_VU_Old, WaterFlux_XY, WaterFlux_YX,
           !            Visc_H_Center, Visc_H_Corner
           !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction



        !Variables Direction Dependent
           !Area_VU, DYY_XX, DUX_VY
           !Velocity_UV_Old, Velocity_VU_Old, WaterFlux_XY, WaterFlux_YX,
           !Visc_H_Center, Visc_H_Corner
           !ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments--------------------------------------------------------------------------


        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:,:), pointer :: Aux_UX_VY, Aux_UY_VX, Velocity_UV_Old
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, LandBoundaryFacesUV

        integer                            :: I, J, K

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK

        !--------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        LandBoundaryFacesUV  => Me%External_Var%LandBoundaryFacesUV
        !End - Shorten variables name

        call SetMatrixValue(Horizontal_Transport, Me%WorkSize, dble(0.0))

cd1:    if (Me%ComputeOptions%HorizontalAdvection) then

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 19/08/2011
            if (Me%ComputeOptions%WaveForcing3D == GLM) then

                ! Stokes drift computation from input surface Stokes drift spectrum
                call Compute_StokesDriftVelocity

            endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            if (Me%ComputeOptions%HorizontalAdvectionOpt) then
                call Modify_Advection_UY_VX2 !Joao Sobrinho

                call Modify_Advection_UX_VY2 !Joao Sobrinho     
            else
                call Modify_Advection_UY_VX

                call Modify_Advection_UX_VY
            endif
            
            !call Modify_Advection_UX_VY_Old

            if (.not. Me%CyclicBoundary%ON .or.                             &
                     (Me%CyclicBoundary%ON .and.                            &
                      Me%CyclicBoundary%Direction == Me%Direction%YX))      &
                call Modify_Advection_Bound

            call AdvectionInSmallDepths

            if (Me%Relaxation%HorizAdv)                                     &
                call ModifyRelaxHorizAdv


        endif cd1


cd2:    if (Me%ComputeOptions%HorizontalDiffusion) then
            !Biharmonic filter is able to dissipate the high frequency variabiliy (1dx,4dx and 6dx)
            !without dissipating energy associated with the big spatial scales

cd3:        if (Me%ComputeOptions%BiHarmonic) then

                !If the BiHarmonic option is true then is compute the laplacian
                !of the velocity in the velocity direction (Aux_UX_VY) and perpendiculary
                !to the velocity (Aux_UX_VY),

                Me%ComputeOptions%BiHarmonicUX_VY(:,:,:) = 0

                Me%ComputeOptions%BiHarmonicUY_VX(:,:,:) = 0

                Aux_UX_VY => Me%ComputeOptions%BiHarmonicUX_VY

                Aux_UY_VX => Me%ComputeOptions%BiHarmonicUY_VX

                call LaplacianXY( Velocity_UV_Old, Aux_UX_VY)

                !For Aux_UX_VY are admitted the same normal open
                !boundary conditions of the velocities
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicBoundVectNormal  (Aux_UX_VY)

                else

                    call VelNormalOpenBoundary  (Aux_UX_VY)

                endif

                call LaplacianYX( Velocity_UV_Old, Aux_UY_VX)

                !For Aux_UY_VX are admitted the same tangential open
                !boundary conditions of the velocities
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%YX .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicBoundVectTangential   (Aux_UY_VX)

                else

                    call VelTangentialOpenBoundary   (Aux_UY_VX)

                endif

                if (Me%ComputeOptions%HorizontalDiffusionOpt) then
                    call Modify_Diffusion_UY_VX2  ( Aux_UY_VX, Biharmonic = .true.) !Joao Sobrinho

                    call Modify_Diffusion_UX_VY2  ( Aux_UX_VY, Biharmonic = .true.) !Joao Sobrinho
                else
                    call Modify_Diffusion_UY_VX  ( Aux_UY_VX, Biharmonic = .true.)

                    call Modify_Diffusion_UX_VY  ( Aux_UX_VY, Biharmonic = .true.)
                endif

cd44:           if (Me%SubModel%ON) then

                    call ModifyDiffSub_UY_VX ( Aux_UY_VX, Biharmonic = .true.)

                    call ModifyDiffSub_UX_VY ( Aux_UX_VY, Biharmonic = .true.)

                endif cd44


                nullify(Aux_UX_VY)
                nullify(Aux_UY_VX)

            endif cd3
            !Turbulent diffusion
            Aux_UY_VX => Me%Velocity%Horizontal%UV%Old

            Aux_UX_VY => Me%Velocity%Horizontal%UV%Old
            
            if (Me%ComputeOptions%HorizontalDiffusionOpt) then
                
                call Modify_Diffusion_UY_VX2  ( Aux_UY_VX, Biharmonic = .false.) !Joao Sobrinho

                call Modify_Diffusion_UX_VY2  ( Aux_UX_VY, Biharmonic = .false.) !Joao Sobrinho
            else
                call Modify_Diffusion_UY_VX  ( Aux_UY_VX, Biharmonic = .false.)

                call Modify_Diffusion_UX_VY  ( Aux_UX_VY, Biharmonic = .false.)  
            endif
            
cd4:        if (Me%SubModel%ON) then

                call ModifyDiffSub_UY_VX ( Aux_UY_VX, Biharmonic = .false.)

                call ModifyDiffSub_UX_VY ( Aux_UX_VY, Biharmonic = .false.)

            endif cd4


            nullify(Aux_UX_VY)
            nullify(Aux_UY_VX)

        endif cd2


        if (Me%ComputeOptions%VolumeVariation)                              &
            call ModifyVolumeVariation

        !Compute the momentum discharge
        if (Me%ComputeOptions%MomentumDischarge)                            &
            call ModifyMomentumDischarge

        !$ CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Horizontal_Transport")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k)
        do  k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

            ! Large values (FillReal_Value) in non covered faces
            Horizontal_Transport (i, j, k) = Horizontal_Transport (i, j, k)    * &
                                             ComputeFaces3D_UV(i, j, k)        + &
                                             (1. - ComputeFaces3D_UV(i, j, k)) * &
                                             FillValueReal

            ! Land boundary condition - horizontal transport zero in faces that
            ! have water in one side and land in another
            Horizontal_Transport (i, j, k) = Horizontal_Transport (i, j, k) * &
                                             (1. - LandBoundaryFacesUV(i, j, k))

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Horizontal_Transport")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (ComputeFaces3D_UV   )
        nullify (LandBoundaryFacesUV )
        nullify (Velocity_UV_Old     )


    end Subroutine Modify_Horizontal_Transport

    !------------------------------------------------------------------------------
    Subroutine Modify_Advection_Bound

        !Arguments--------------------------------------------------------------------------


        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        integer, dimension(:,:),   pointer :: BoundaryFacesUV
        integer                            :: I, J, K
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: CHUNK

        !--------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV


cd1:    if (Me%Submodel%ON) then

            call Modify_UX_VY_SubModel

            call Modify_UY_VX_SubModel

        else cd1

            call Modify_UX_VY_Boundary

            call Modify_UY_VX_Boundary

cd2:        if (Me%ComputeOptions%NullBoundaryHorAdv) then

                CHUNK = CHUNK_J(JLB, JUB)

                if (MonitorPerformance) then
                    call StartWatch ("ModuleHydrodynamic", "Modify_Advection_Bound")
                endif

                !$OMP PARALLEL PRIVATE(i,j,k)
do4 :           do  k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do5 :           do  j = JLB, JUB
do6 :           do  i = ILB, IUB
                    !Horizontal Advection null in the boundary faces
                    Horizontal_Transport (i, j, k) = Horizontal_Transport (i, j, k) * &
                                                     (1. - BoundaryFacesUV(i, j))

                end do do6
                end do do5
                !$OMP END DO
                end do do4
                !$OMP END PARALLEL

                if (MonitorPerformance) then
                    call StopWatch ("ModuleHydrodynamic", "Modify_Advection_Bound")
                endif

            endif cd2

            nullify(Horizontal_Transport)
            nullify(BoundaryFacesUV     )


        endif cd1



    end Subroutine Modify_Advection_Bound

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal advection with the same direction of the    !
    !  velocity. For the U velocity compute the advection with the X direction            !
    !  for the V velocity compute the advection with the Y direction                      !
    !                                                                                      !
    ! Input : Flow, Mapping,                                                               !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Advection_UX_VY


        !Variables Categories----------------------------------------------------------------
        ! Flow     : WaterFlux_XY (Horizontal water fluxes), Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Options  : UpStream_CenterDif (1-Upwind and 0-Centered differences),ImplicitVertAdvection (1 - implict, 0 - explicit)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)
        ! OutPut   : Horizontal_Transport

        !Variables direction dependent:
        !Velocity_UV_Old, WaterFlux_XY, Horizontal_Transport, ComputeFaces3D_UV, Direction, KFloor_UV


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real,    dimension(:,:),   pointer :: DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4

        real(8)                            :: FaceFlux_WestSouth

        integer                            :: di, dj, i, j, k

        integer                            :: iSouth, jWest, i_North, j_East, iSouth2, &
                                              jWest2, iSouth3, jWest3

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        logical                            :: ComputeFlux, NearBoundary

        !$ integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        WaterFlux_XY         => Me%WaterFluxes%XY
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name


        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY")
        endif

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
        !and you'll be fine.
        !$OMP PARALLEL PRIVATE( i,j,k, &
        !$OMP                   iSouth,jWest,j_East,i_North,jWest2,iSouth2,jWest3,iSouth3, &
        !$OMP                   ComputeFlux, FaceFlux_WestSouth, &
        !$OMP                   NearBoundary,Vel4,du4, &
        !$OMP                   V4,CFace)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    dok: do k=KLB, KUB
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North = i +   di
            j_East  = j +   dj
            iSouth2 = i - 2*di
            jWest2  = j - 2*dj
            iSouth3 = i - 3*di
            jWest3  = j - 3*dj


            ComputeFlux = .false.

            !Momentum normal flux is always compute if at least one of adjacent faces is a face to compute
            if (ComputeFaces3D_UV(i     ,  j    ,  k) == Covered .or.                     &
                ComputeFaces3D_UV(iSouth,  jWest,  k) == Covered) ComputeFlux = .true.


            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_)) then

                if ((ComputeFaces3D_UV   (i     , j    , KUB) == Covered .and.           &
                     ImposedNormalFacesUV(iSouth, jWest, KUB) == Imposed).or.            &
                    (ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered .and.           &
                     ImposedNormalFacesUV(i     , j    , KUB) == Imposed)) ComputeFlux = .true.

            endif

cd0:        if (ComputeFlux) then

                FaceFlux_WestSouth = (WaterFlux_XY(iSouth, jWest, k) + &
                                        WaterFlux_XY(i, j, k))/2.            ![m^3/s]

                NearBoundary = .false.


                Vel4(1) = Velocity_UV_Old(iSouth2, jWest2, k);
                Vel4(2) = Velocity_UV_Old(iSouth,  jWest,  k);
                Vel4(3) = Velocity_UV_Old(i,       j,      k);
                Vel4(4) = Velocity_UV_Old(i_North, j_East, k);


                if (FaceFlux_WestSouth > 0) then
                    if (ComputeFaces3D_UV(iSouth2, jWest2, k) /= Compute) then
                        NearBoundary = .true.
                        du4(1) = FillValueReal;
                    else
                        du4(1) = DZX_ZY(iSouth3, jWest3);
                    endif
                else
                    if (ComputeFaces3D_UV(i_North,  j_East,  k) /= Compute) NearBoundary = .true.
                endif

                du4(2) = DZX_ZY(iSouth2, jWest2);
                du4(3) = DZX_ZY(iSouth,  jWest );
                du4(4) = DZX_ZY(i,       j     );


                !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                V4   (1) = Volume_UV  (iSouth2, jWest2, k);
                V4   (2) = Volume_UV  (iSouth,  jWest,  k);
                V4   (3) = Volume_UV  (i,       j,      k);
                V4   (4) = Volume_UV  (i_North, j_East, k);

                call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                            FaceFlux_WestSouth,                       &
                                            Me%ComputeOptions%VolumeRelMax,           &
                                            Me%ComputeOptions%AdvectionMethodH,       &
                                            Me%ComputeOptions%TVD_LimH,               &
                                            NearBoundary,                             &
                                            Me%ComputeOptions%Upwind2H, CFace)

                Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                    Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                    FaceFlux_WestSouth ![m/s*m^3/s]


                Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) +  Me%Aux3DFlux(i, j, k)

            endif cd0

    enddo doj
    enddo doi
    enddo dok
        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            Horizontal_Transport(iSouth, jWest, k) = Horizontal_Transport(iSouth, jWest, k) - Me%Aux3DFlux(i, j, k)

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        nullify (Velocity_UV_Old     )
        nullify (ComputeFaces3D_UV   )
        nullify (KFloor_UV           )
        nullify (ImposedNormalFacesUV)

        nullify (DZX_ZY              )
        nullify (Volume_UV           )


    End Subroutine Modify_Advection_UX_VY

    Subroutine Modify_Advection_UX_VY2


        !Variables Categories----------------------------------------------------------------
        ! Flow     : WaterFlux_XY (Horizontal water fluxes), Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Options  : UpStream_CenterDif (1-Upwind and 0-Centered differences),ImplicitVertAdvection (1 - implict, 0 - explicit)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)
        ! OutPut   : Horizontal_Transport

        !Variables direction dependent:
        !Velocity_UV_Old, WaterFlux_XY, Horizontal_Transport, ComputeFaces3D_UV, Direction, KFloor_UV


        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real,    dimension(:,:),   pointer :: DZX_ZY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
        real(8)                            :: FaceFlux_WestSouth
        integer                            :: di, dj, i, j, k
        integer                            :: iSouth, jWest, i_North, j_East, iSouth2, &
                                              jWest2, iSouth3, jWest3
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        logical                            :: ComputeFlux, NearBoundary, GoforOptimized

        !$ integer                            :: CHUNK

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        WaterFlux_XY         => Me%WaterFluxes%XY
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End - Shorten variables name
         GoforOptimized = .false.
        if ( .not. Me%CyclicBoundary%ON) then
            if (Me%ComputeOptions%AdvectionMethodH == P2_TVD) then
                if (Me%ComputeOptions%TVD_LimH == SuperBee) then
                    GoforOptimized = .true.
                endif
            endif
        endif

        if (GoforOptimized) then

            call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

            if (Me%Direction%di == 1) then
                call Modify_Advection_UX_VY_Y (Me%External_Var%ComputeFaces3D_V,                                &
                                               Me%External_Var%DZY, Me%External_Var%Volume_V, Me%WaterFluxes%Y, &
                                               Me%Forces%Horizontal_Transport, Me%Velocity%Horizontal%V%Old)
            else
                call Modify_Advection_UX_VY_X (Me%External_Var%ComputeFaces3D_U,                                &
                                               Me%External_Var%DZX, Me%External_Var%Volume_U, Me%WaterFluxes%X, &
                                               Me%Forces%Horizontal_Transport, Me%Velocity%Horizontal%U%Old)
            endif

        else

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY")
            endif

            call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

            !$ CHUNK = CHUNK_J(JLB,JUB)

            !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
            !and you'll be fine.
            !$OMP PARALLEL PRIVATE( i,j,k, &
            !$OMP                   iSouth,jWest,j_East,i_North,jWest2,iSouth2,jWest3,iSouth3, &
            !$OMP                   ComputeFlux, FaceFlux_WestSouth, &
            !$OMP                   NearBoundary,Vel4,du4, &
            !$OMP                   V4,CFace)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        dok: do k=KLB, KUB
        doi: do j=JLB, JUB
        doj: do i=ILB, IUB

                iSouth  = i -   di
                jWest   = j -   dj
                i_North = i +   di
                j_East  = j +   dj
                iSouth2 = i - 2*di
                jWest2  = j - 2*dj
                iSouth3 = i - 3*di
                jWest3  = j - 3*dj


                ComputeFlux = .false.

                !Momentum normal flux is always compute if at least one of adjacent faces is a face to compute
                if (ComputeFaces3D_UV(i     ,  j    ,  k) == Covered .or.                     &
                    ComputeFaces3D_UV(iSouth,  jWest,  k) == Covered) ComputeFlux = .true.


                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    if ((ComputeFaces3D_UV   (i     , j    , KUB) == Covered .and.           &
                         ImposedNormalFacesUV(iSouth, jWest, KUB) == Imposed).or.            &
                        (ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered .and.           &
                         ImposedNormalFacesUV(i     , j    , KUB) == Imposed)) ComputeFlux = .true.

                endif

    cd0:        if (ComputeFlux) then

                    FaceFlux_WestSouth = (WaterFlux_XY(iSouth, jWest, k) + &
                                            WaterFlux_XY(i, j, k))/2.            ![m^3/s]

                    NearBoundary = .false.


                    Vel4(1) = Velocity_UV_Old(iSouth2, jWest2, k);
                    Vel4(2) = Velocity_UV_Old(iSouth,  jWest,  k);
                    Vel4(3) = Velocity_UV_Old(i,       j,      k);
                    Vel4(4) = Velocity_UV_Old(i_North, j_East, k);


                    if (FaceFlux_WestSouth > 0) then
                        if (ComputeFaces3D_UV(iSouth2, jWest2, k) /= Compute) then
                            NearBoundary = .true.
                            du4(1) = FillValueReal;
                        else
                            du4(1) = DZX_ZY(iSouth3, jWest3);
                        endif
                    else
                        if (ComputeFaces3D_UV(i_North,  j_East,  k) /= Compute) NearBoundary = .true.
                    endif

                    du4(2) = DZX_ZY(iSouth2, jWest2);
                    du4(3) = DZX_ZY(iSouth,  jWest );
                    du4(4) = DZX_ZY(i,       j     );


                    !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                    V4   (1) = Volume_UV  (iSouth2, jWest2, k);
                    V4   (2) = Volume_UV  (iSouth,  jWest,  k);
                    V4   (3) = Volume_UV  (i,       j,      k);
                    V4   (4) = Volume_UV  (i_North, j_East, k);

                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                                FaceFlux_WestSouth,                       &
                                                Me%ComputeOptions%VolumeRelMax,           &
                                                Me%ComputeOptions%AdvectionMethodH,       &
                                                Me%ComputeOptions%TVD_LimH,               &
                                                NearBoundary,                             &
                                                Me%ComputeOptions%Upwind2H, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        FaceFlux_WestSouth ![m/s*m^3/s]


                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) +  Me%Aux3DFlux(i, j, k)

                endif cd0

        enddo doj
        enddo doi
        enddo dok
            !$OMP END DO

            do k=KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB

                iSouth  = i -   di
                jWest   = j -   dj

                Horizontal_Transport(iSouth, jWest, k) = Horizontal_Transport(iSouth, jWest, k) - Me%Aux3DFlux(i, j, k)

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY")
            endif

        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        nullify (Velocity_UV_Old     )
        nullify (ComputeFaces3D_UV   )
        nullify (KFloor_UV           )
        nullify (ImposedNormalFacesUV)

        nullify (DZX_ZY              )
        nullify (Volume_UV           )

    End Subroutine Modify_Advection_UX_VY2

    !End------------------------------------------------------------------------

    subroutine Modify_Advection_UX_VY_Y(ComputeFaces3D_V, DZY, Volume_V, WaterFlux_Y, &
        Horizontal_Transport, Velocity_V_Old)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: Horizontal_Transport
        real(8), dimension(:,:,:), pointer, intent(IN)    :: WaterFlux_Y, Volume_V
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_V_Old
        real,    dimension(:,:),   pointer, intent(IN)    :: DZY
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_V
        !Local---------------------------------------------------------------------
        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
        real(8)                            :: FaceFlux_WestSouth
        integer                            :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !End - Shorten variables name

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, FaceFlux_WestSouth,Vel4,du4, V4,CFace)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k=KLB, KUB
        do j=JLB, JUB
        do i=ILB, IUB
            !Momentum normal flux is always compute if at least one of adjacent faces is a face to compute
            if (ComputeFaces3D_V(i, j, k) == 1 .or. ComputeFaces3D_V(i-1, j,k) == 1) then

                FaceFlux_WestSouth = (WaterFlux_Y(i-1, j, k) + WaterFlux_Y(i, j, k))/2. ![m^3/s]

                if  ((FaceFlux_WestSouth > 0) .and. (ComputeFaces3D_V(i-2, j, k) == 0)) then
                    !NearBoundary = .true. CFace(2) = 1
                    Me%Aux3DFlux(i, j, k) = dble(Velocity_V_Old(i-1, j, k)) * FaceFlux_WestSouth ![m/s*m^3/s]
                    du4(1) = FillValueReal
                elseif ((FaceFlux_WestSouth <= 0) .and. (ComputeFaces3D_V(i+1,  j,  k) == 0)) then
                    !NearBoundary = .true. CFace(3) = 1
                    Me%Aux3DFlux(i, j, k) = dble(Velocity_V_Old(i  , j, k)) * FaceFlux_WestSouth ![m/s*m^3/s]
                elseif ((FaceFlux_WestSouth <= 0) .and. (ComputeFaces3D_V(i-2,  j,  k) == 0)) then

                    !Use du4(1) obtained from previous iteration
                    du4(2) = DZY     (i-2,j  ) ; du4(3) = DZY     (i-1,j  ); du4(4) = DZY(i, j);
                    V4 (2) = Volume_V(i-1,j,k) ; V4 (3) = Volume_V(i  ,j,k);

                    Vel4(1) = Velocity_V_Old(i-2, j, k); Vel4(2) = Velocity_V_Old(i-1, j, k);
                    Vel4(3) = Velocity_V_Old(i  , j, k); Vel4(4) = Velocity_V_Old(i+1, j, k);

                    call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT, FaceFlux_WestSouth, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *   &
                                            FaceFlux_WestSouth ![m/s*m^3/s]
                else

                    du4(1) = DZY(i-3, j) ; du4(2) = DZY(i-2, j)      ; du4(3) = DZY(i-1, j)     ; du4(4) = DZY(i, j);
                                           V4 (2) = Volume_V(i-1,j,k); V4 (3) = Volume_V(i ,j,k);

                    Vel4(1) = Velocity_V_Old(i-2, j, k); Vel4(2) = Velocity_V_Old(i-1, j, k);
                    Vel4(3) = Velocity_V_Old(i  , j, k); Vel4(4) = Velocity_V_Old(i+1, j, k);

                    call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT, FaceFlux_WestSouth, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *   &
                                            FaceFlux_WestSouth ![m/s*m^3/s]
                endif
                Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
            endif
        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        !$ CHUNK = CHUNK_K(KLB,KUB)
        !$OMP PARALLEL PRIVATE(i,j,k)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k=KLB, KUB
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i-1, j, k) = Horizontal_Transport(i-1, j, k) - Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine Modify_Advection_UX_VY_Y

    !End ----------------------------------------------------------------------

    subroutine Modify_Advection_UX_VY_X(ComputeFaces3D_U, DZX, Volume_U, WaterFlux_X, &
        Horizontal_Transport, Velocity_U_Old)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: Horizontal_Transport
        real(8), dimension(:,:,:), pointer, intent(IN)    :: WaterFlux_X, Volume_U
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_U_Old
        real,    dimension(:,:),   pointer, intent(IN)    :: DZX
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U
        !Local---------------------------------------------------------------------
        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
        real(8)                            :: FaceFlux_WestSouth
        integer                            :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !End - Shorten variables name

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, FaceFlux_WestSouth,Vel4,du4, V4,CFace)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k=KLB, KUB
        do j=JLB, JUB
        do i=ILB, IUB

            !Momentum normal flux is always compute if at least one of adjacent faces is a face to compute
            if (ComputeFaces3D_U(i, j, k) == 1 .or. ComputeFaces3D_U(i, j-1,k) == 1) then

                FaceFlux_WestSouth = (WaterFlux_X(i, j-1, k) + WaterFlux_X(i, j, k))/2. ![m^3/s]

                if  ((FaceFlux_WestSouth > 0) .and. (ComputeFaces3D_U(i, j-2, k) /= Compute)) then
                    !NearBoundary = .true. CFace(2) = 1
                    Me%Aux3DFlux(i, j, k) = dble(Velocity_U_Old(i, j-1, k)) * FaceFlux_WestSouth ![m/s*m^3/s]
                    du4(1) = FillValueReal
                elseif ((FaceFlux_WestSouth <= 0) .and. (ComputeFaces3D_U(i,  j+1,  k) /= Compute)) then
                    !NearBoundary = .true. CFace(3) = 1
                    Me%Aux3DFlux(i, j, k) = dble(Velocity_U_Old(i, j  , k)) * FaceFlux_WestSouth ![m/s*m^3/s]
                elseif ((FaceFlux_WestSouth <= 0) .and. (ComputeFaces3D_U(i,  j-2,  k) /= Compute)) then

                    du4(2) = DZX(i, j-2); du4(3) = DZX(i, j-1); du4(4) = DZX(i, j  );

                    V4 (2) = Volume_U (i, j-1,  k);
                    V4 (3) = Volume_U (i, j  ,  k);

                    Vel4(1) = Velocity_U_Old(i, j-2, k); Vel4(2) = Velocity_U_Old(i, j-1, k);
                    Vel4(3) = Velocity_U_Old(i, j  , k); Vel4(4) = Velocity_U_Old(i, j+1, k);

                    call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT, FaceFlux_WestSouth, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *     &
                                        FaceFlux_WestSouth ![m/s*m^3/s]
                else
                    du4(1) = DZX(i, j-3); du4(2) = DZX(i, j-2); du4(3) = DZX(i, j-1); du4(4) = DZX(i, j  );

                    V4 (2) = Volume_U (i, j-1,  k);
                    V4 (3) = Volume_U (i, j  ,  k);

                    Vel4(1) = Velocity_U_Old(i, j-2, k); Vel4(2) = Velocity_U_Old(i, j-1, k);
                    Vel4(3) = Velocity_U_Old(i, j  , k); Vel4(4) = Velocity_U_Old(i, j+1, k);

                    call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT, FaceFlux_WestSouth, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *     &
                                        FaceFlux_WestSouth ![m/s*m^3/s]
                endif
                Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
            endif
        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        !$ CHUNK = CHUNK_K(KLB,KUB)
        !$OMP PARALLEL PRIVATE(i,j,k)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k=KLB, KUB
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i, j-1, k) = Horizontal_Transport(i, j-1, k) - Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine Modify_Advection_UX_VY_X

    !End ----------------------------------------------------------------------

    Subroutine Modify_Advection_UX_VY_old


        !Variables Categories----------------------------------------------------------------
        ! Flow     : WaterFlux_XY (Horizontal water fluxes), Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Options  : UpStream_CenterDif (1-Upwind and 0-Centered differences),ImplicitVertAdvection (1 - implict, 0 - explicit)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)
        ! OutPut   : Horizontal_Transport

        !Variables direction dependent:
        !Velocity_UV_Old, WaterFlux_XY, Horizontal_Transport, ComputeFaces3D_UV, Direction, KFloor_UV


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real,    dimension(:,:),   pointer :: DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4

!        real                               :: UpStream_CenterDif, Aux

!        real                               :: Coef1_Up, Coef2_Up, Coef3_Up, Coef_Centered

        real(8)                            :: FaceFlux_WestSouth !, MomentumFlux

!        real                               :: Coef1_WestSouth, Coef2_WestSouth, Coef3_WestSouth, Coef4_WestSouth

 !       real                               :: Cell1_FaceWestSouth, Cell2_FaceWestSouth, Cell3_FaceWestSouth, Cell4_FaceWestSouth

 !       real                               :: Cell_1, Cell_2, Cell_3, Cell_4

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East, iSouth2, &
                                              jWest2, iSouth3, jWest3

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        logical                            :: ComputeFlux, NearBoundary

        !$ integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

!        UpStream_CenterDif   =  Me%ComputeOptions%UpStream_CenterDif

!        Coef1_Up             =  Me%HorAdvection%Coef1_Up
!        Coef2_Up             =  Me%HorAdvection%Coef2_Up
!        Coef3_Up             =  Me%HorAdvection%Coef3_Up

        WaterFlux_XY         => Me%WaterFluxes%XY
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name

        !Centered difference coefficient equal for both faces (West/South = East/North)
!        Coef_Centered = 0.5

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY_Old")
        endif

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
        !and you'll be fine.
        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth,jWest,j_East,i_North,jWest2,iSouth2,jWest3,iSouth3, &
        !$OMP                   ComputeFlux, FaceFlux_WestSouth, &
        !$OMP                   NearBoundary,Vel4,du4, &
        !$OMP                   V4,CFace)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North = i +   di
            j_East  = j +   dj
            iSouth2 = i - 2*di
            jWest2  = j - 2*dj
            iSouth3 = i - 3*di
            jWest3  = j - 3*dj


            ComputeFlux = .false.


            if (ComputeFaces3D_UV(i     ,  j    ,  KUB) == Covered .and.                 &
                ComputeFaces3D_UV(iSouth,  jWest,  KUB) == Covered ) ComputeFlux = .true.



            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_)) then

                if ((ComputeFaces3D_UV   (i     , j    , KUB) == Covered .and.           &
                     ImposedNormalFacesUV(iSouth, jWest, KUB) == Imposed).or.            &
                    (ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered .and.           &
                     ImposedNormalFacesUV(i     , j    , KUB) == Imposed)) ComputeFlux = .true.

            endif

cd0:        if (ComputeFlux) then


                Kbottom = max(KFloor_UV(i, j), KFloor_UV(iSouth, jWest))

        dok1:   do k = Kbottom, KUB

                    FaceFlux_WestSouth = (WaterFlux_XY(iSouth, jWest, k) + &
                                         WaterFlux_XY(i, j, k))/2.            ![m^3/s]

                    NearBoundary = .false.


                    Vel4(1) = Velocity_UV_Old(iSouth2, jWest2, k);
                    Vel4(2) = Velocity_UV_Old(iSouth,  jWest,  k);
                    Vel4(3) = Velocity_UV_Old(i,       j,      k);
                    Vel4(4) = Velocity_UV_Old(i_North, j_East, k);


                    if (FaceFlux_WestSouth > 0) then
                        if (ComputeFaces3D_UV(iSouth2, jWest2, k) /= Compute) then
                            NearBoundary = .true.
                            du4(1) = FillValueReal;
                        else
                            du4(1) = DZX_ZY(iSouth3, jWest3);
                        endif
                    else
                        if (ComputeFaces3D_UV(i_North,  j_East,  k) /= Compute) NearBoundary = .true.
                    endif

                    du4(2) = DZX_ZY(iSouth2, jWest2);
                    du4(3) = DZX_ZY(iSouth,  jWest );
                    du4(4) = DZX_ZY(i,       j     );


                    !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                    V4   (1) = Volume_UV  (iSouth2, jWest2, k);
                    V4   (2) = Volume_UV  (iSouth,  jWest,  k);
                    V4   (3) = Volume_UV  (i,       j,      k);
                    V4   (4) = Volume_UV  (i_North, j_East, k);

                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                              FaceFlux_WestSouth,                       &
                                              Me%ComputeOptions%VolumeRelMax,           &
                                              Me%ComputeOptions%AdvectionMethodH,       &
                                              Me%ComputeOptions%TVD_LimH,               &
                                              NearBoundary,                             &
                                              Me%ComputeOptions%Upwind2H, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        FaceFlux_WestSouth ![m/s*m^3/s]


                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) +  Me%Aux3DFlux(i, j, k)

                enddo dok1

            endif cd0

        enddo doj
    enddo doi

        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            Horizontal_Transport(iSouth, jWest, k) = Horizontal_Transport(iSouth, jWest, k) - Me%Aux3DFlux(i, j, k)

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UX_VY_Old")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        nullify (Velocity_UV_Old     )
        nullify (ComputeFaces3D_UV   )
        nullify (KFloor_UV           )
        nullify (ImposedNormalFacesUV)

        nullify (DZX_ZY              )
        nullify (Volume_UV           )


    End Subroutine Modify_Advection_UX_VY_old


    !End ----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal advection with the perpendicular direction  !
    !  in the horizontal plane of the velocity. For the U velocity compute the             !
    !  advection with the Y direction for the V velocity compute the advection with the  !
    !  X direction                                                                         !
    !                                                                                      !
    ! Input : Flow, Mapping, Geometry, Time steps                                          !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Advection_UY_VX



        !Variables categories
        ! Geometry : DYY_XX  (U or V Control Volume width)
        ! Flow     : WaterFlux_YX (Water flux perpendicular to the velocity direction), Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Options  : UpStream_CenterDif (1-Upwind and 0-Centered differences), ImplicitVertAdvection (1-implict, 0- explicit)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)
        ! OutPut   : Horizontal_Transport

        !Arguments dependent from the direction:
        ! DYY_XX, Velocity_UV_Old, Horizontal_Transport, WaterFlux_YX, ComputeFaces3D_UV,
        ! Direction, Kfloor_UV, WaterFlux_YX


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_YX, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        !real                               :: UpStream_CenterDif, Aux

!        real                               :: Coef1_Up, Coef2_Up, Coef3_Up, Coef2_Centered_SW, &
!                                              Coef3_Centered_SW

        real(8)                            :: FaceFlux_SouthWest !,MomentumFlux

!        real                               :: Coef1_SouthWest, Coef2_SouthWest, Coef3_SouthWest, Coef4_SouthWest

!        real                               :: Cell1_FaceSouthWest, Cell2_FaceSouthWest, Cell3_FaceSouthWest, Cell4_FaceSouthWest

!        real                               :: Cell_1, Cell_2, Cell_3, Cell_4

        integer                            :: di, dj, i, j, k, Kbottom
        integer                            :: iSouth, jWest, i_West, j_South, i_East, j_North, &
                                              i_West2, j_South2

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        logical                            :: NotBoundary, FaceLeftOK, FaceRightOK, NearBoundary

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4

        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

!        UpStream_CenterDif   =  Me%ComputeOptions%UpStream_CenterDif

!        Coef1_Up             =  Me%HorAdvection%Coef1_Up
!        Coef2_Up             =  Me%HorAdvection%Coef2_Up
!        Coef3_Up             =  Me%HorAdvection%Coef3_Up

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        BoundaryFacesUV          => Me%External_Var%BoundaryFacesUV
        KFloor_UV                => Me%External_Var%KFloor_UV
        DYY_XX                   => Me%External_Var%DYY_XX


        !End - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UY_VX")
        endif

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
        !and you'll be fine.
        !ACanas(2010): Parallelization is commented because overheads are
        !ACanas(2010): found very large due to cycle is inner and in index k.
        !ACanas(2010): Since MOHID Water typical applications have horizontal
        !ACanas(2010): grid much larger than vertical grid it is not
        !ACanas(2010): expected that performance could improve in other
        !Acanas(2010): applications than the one used for test.

        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth,jWest,i_West,j_South,i_East,j_North,i_West2,j_South2, &
        !$OMP                   NotBoundary, FaceRightOK, FaceLeftOK, FaceFlux_SouthWest, &
        !$OMP                   NearBoundary,Vel4,du4, &
        !$OMP                   V4,CFace)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do j=JLB, JUB
doi:    do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            i_West   = i -   dj
            j_South  = j -   di

            i_East   = i +   dj
            j_North  = j +   di

            i_West2  = i - 2*dj
            j_South2 = j - 2*di

cd1:        if (BoundaryFacesUV  (i     , j      ) == Not_Boundary .and.                 &
                BoundaryFacesUV  (i_West, j_South) == Not_Boundary) then

                NotBoundary = .true.

            else  cd1

                NotBoundary = .false.

            endif cd1

            !When the boundary is Cyclic the momentum advection flux is also compute for the boundary faces
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_)) NotBoundary = .true.

cd2:        if (ComputeFaces3D_UV       (i, j, KUB) == Covered .or.                      &
                ImposedTangentialFacesUV(i, j, KUB) == Imposed) then

                FaceRightOK = .true.

            else  cd2

                FaceRightOK = .false.

            endif cd2

cd3:        if (ComputeFaces3D_UV       (i_West, j_South, KUB) == Covered .or.           &
                ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                FaceLeftOK = .true.

            else  cd3

                FaceLeftOK = .false.

            endif cd3

cd4:       if (NotBoundary .and. FaceRightOK .and. FaceLeftOK) then

                Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

dok1:           do k = Kbottom, KUB

                    !South or West Face
                    FaceFlux_SouthWest = (WaterFlux_YX(iSouth  , jWest, k) + &
                                          WaterFlux_YX(i, j, k))/2.

                    NearBoundary = .false.


                    if (FaceFlux_SouthWest > 0) then
                        if (ComputeFaces3D_UV(i_West2, j_South2, k) /= Compute) NearBoundary = .true.
                    else
                        if (ComputeFaces3D_UV(i_East,  j_North,  k) /= Compute) NearBoundary = .true.
                    endif

                    Vel4(1) = Velocity_UV_Old(i_West2, j_South2, k);
                    Vel4(2) = Velocity_UV_Old(i_West, j_South,   k);
                    Vel4(3) = Velocity_UV_Old(i     , j,         k);
                    Vel4(4) = Velocity_UV_Old(i_East, j_North,   k);

                    du4(1) = DYY_XX(i_West2, j_South2)
                    du4(2) = DYY_XX(i_West, j_South  )
                    du4(3) = DYY_XX(i     , j        )
                    du4(4) = DYY_XX(i_East, j_North  )

                    !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                    V4   (1) = Volume_UV  (i_West2, j_South2, k);
                    V4   (2) = Volume_UV  (i_West, j_South,   k);
                    V4   (3) = Volume_UV  (i     , j,         k);
                    V4   (4) = Volume_UV  (i_East, j_North,   k);

                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                              FaceFlux_SouthWest,                       &
                                              Me%ComputeOptions%VolumeRelMax,           &
                                              Me%ComputeOptions%AdvectionMethodH,       &
                                              Me%ComputeOptions%TVD_LimH,               &
                                              NearBoundary,                             &
                                              Me%ComputeOptions%Upwind2H, CFace)

                    Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        FaceFlux_SouthWest ![m/s*m^3/s]


                    Horizontal_Transport(i, j, k)           = Horizontal_Transport(i, j, k) + &
                                                              Me%Aux3DFlux(i, j, k)


                enddo dok1
            endif cd4

        enddo doi
        enddo doj
        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            i_West   = i -   dj
            j_South  = j -   di

            Horizontal_Transport(i_West, j_South, k)= Horizontal_Transport(i_West, j_South, k) - &
                                                      Me%Aux3DFlux(i, j, k)

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UY_VX")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_YX            )
        nullify (Horizontal_Transport    )
        nullify (Velocity_UV_Old         )
        nullify (ComputeFaces3D_UV       )
        nullify (ImposedTangentialFacesUV)
        nullify (KFloor_UV               )
        nullify (DYY_XX                  )
        nullify (BoundaryFacesUV         )
        nullify (Volume_UV           )



    End Subroutine Modify_Advection_UY_VX

        !End ----------------------------------------------------------------------

    Subroutine Modify_Advection_UY_VX2

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_YX, Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real,    dimension(:,:),   pointer :: DYY_XX
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV
        real(8)                            :: FaceFlux_SouthWest
        integer                            :: di, dj, i, j, k, Kbottom
        integer                            :: iSouth, jWest, i_West, j_South, i_East, j_North, &
                                              i_West2, j_South2
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        logical                            :: NotBoundary, FaceLeftOK, FaceRightOK, NearBoundary, GoforOptimized
        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4

        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        BoundaryFacesUV          => Me%External_Var%BoundaryFacesUV
        KFloor_UV                => Me%External_Var%KFloor_UV
        DYY_XX                   => Me%External_Var%DYY_XX

        !End - Shorten variables name

        GoforOptimized = .false.
        if ( .not. Me%CyclicBoundary%ON) then
            if (Me%ComputeOptions%AdvectionMethodH == P2_TVD) then
                if (Me%ComputeOptions%TVD_LimH == SuperBee) then
                    GoforOptimized = .true.
                endif
            endif
        endif

        if (GoforOptimized) then

            call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

            if (Me%Direction%di == 1) then
                call Modify_Advection_UY_VX_Y (Me%External_Var%ComputeFaces3D_V, Me%External_Var%ImposedTangentialFacesV, &
                                              Me%External_Var%BoundaryFacesV, Me%External_Var%KFloor_V,               &
                                              Me%External_Var%DXX, Me%External_Var%Volume_V, Me%WaterFluxes%X,        &
                                              Me%Forces%Horizontal_Transport, Me%Velocity%Horizontal%V%Old)
            else
                call Modify_Advection_UY_VX_X (Me%External_Var%ComputeFaces3D_U, Me%External_Var%ImposedTangentialFacesU, &
                                              Me%External_Var%BoundaryFacesU, Me%External_Var%KFloor_U,               &
                                              Me%External_Var%DYY, Me%External_Var%Volume_U, Me%WaterFluxes%Y,        &
                                              Me%Forces%Horizontal_Transport, Me%Velocity%Horizontal%U%Old)
            endif

        else

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "Modify_Advection_UY_VX")
            endif

            call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

            !$ CHUNK = CHUNK_J(JLB,JUB)

            !griflet: Avoid inner parallel zones, avoid all barriers and critical sections...
            !and you'll be fine.
            !ACanas(2010): Parallelization is commented because overheads are
            !ACanas(2010): found very large due to cycle is inner and in index k.
            !ACanas(2010): Since MOHID Water typical applications have horizontal
            !ACanas(2010): grid much larger than vertical grid it is not
            !ACanas(2010): expected that performance could improve in other
            !Acanas(2010): applications than the one used for test.

            !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
            !$OMP                   iSouth,jWest,i_West,j_South,i_East,j_North,i_West2,j_South2, &
            !$OMP                   NotBoundary, FaceRightOK, FaceLeftOK, FaceFlux_SouthWest, &
            !$OMP                   NearBoundary,Vel4,du4, &
            !$OMP                   V4,CFace)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj:    do j=JLB, JUB
    doi:    do i=ILB, IUB

                iSouth  = i -   di
                jWest   = j -   dj

                i_West   = i -   dj
                j_South  = j -   di

                i_East   = i +   dj
                j_North  = j +   di

                i_West2  = i - 2*dj
                j_South2 = j - 2*di

    cd1:        if (BoundaryFacesUV  (i     , j      ) == Not_Boundary .and.                 &
                    BoundaryFacesUV  (i_West, j_South) == Not_Boundary) then

                    NotBoundary = .true.

                else  cd1

                    NotBoundary = .false.

                endif cd1

                !When the boundary is Cyclic the momentum advection flux is also compute for the boundary faces
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) NotBoundary = .true.

    cd2:        if (ComputeFaces3D_UV       (i, j, KUB) == Covered .or.                      &
                    ImposedTangentialFacesUV(i, j, KUB) == Imposed) then

                    FaceRightOK = .true.

                else  cd2

                    FaceRightOK = .false.

                endif cd2

    cd3:        if (ComputeFaces3D_UV       (i_West, j_South, KUB) == Covered .or.           &
                    ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                    FaceLeftOK = .true.

                else  cd3

                    FaceLeftOK = .false.

                endif cd3

    cd4:       if (NotBoundary .and. FaceRightOK .and. FaceLeftOK) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

    dok1:           do k = Kbottom, KUB

                        !South or West Face
                        FaceFlux_SouthWest = (WaterFlux_YX(iSouth  , jWest, k) + &
                                              WaterFlux_YX(i, j, k))/2.

                        NearBoundary = .false.


                        if (FaceFlux_SouthWest > 0) then
                            if (ComputeFaces3D_UV(i_West2, j_South2, k) /= Compute) NearBoundary = .true.
                        else
                            if (ComputeFaces3D_UV(i_East,  j_North,  k) /= Compute) NearBoundary = .true.
                        endif

                        Vel4(1) = Velocity_UV_Old(i_West2, j_South2, k);
                        Vel4(2) = Velocity_UV_Old(i_West, j_South,   k);
                        Vel4(3) = Velocity_UV_Old(i     , j,         k);
                        Vel4(4) = Velocity_UV_Old(i_East, j_North,   k);

                        du4(1) = DYY_XX(i_West2, j_South2)
                        du4(2) = DYY_XX(i_West, j_South  )
                        du4(3) = DYY_XX(i     , j        )
                        du4(4) = DYY_XX(i_East, j_North  )

                        !du4  (1) = DZX_ZY  (i-2);du4  (2) = du  (i-1);du4  (3) = du  (i);du4  (4) = du  (i+1);
                        V4   (1) = Volume_UV  (i_West2, j_South2, k);
                        V4   (2) = Volume_UV  (i_West, j_South,   k);
                        V4   (3) = Volume_UV  (i     , j,         k);
                        V4   (4) = Volume_UV  (i_East, j_North,   k);

                        call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                                  FaceFlux_SouthWest,                       &
                                                  Me%ComputeOptions%VolumeRelMax,           &
                                                  Me%ComputeOptions%AdvectionMethodH,       &
                                                  Me%ComputeOptions%TVD_LimH,               &
                                                  NearBoundary,                             &
                                                  Me%ComputeOptions%Upwind2H, CFace)

                        Me%Aux3DFlux(i, j, k) = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                            Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                            FaceFlux_SouthWest ![m/s*m^3/s]


                        Horizontal_Transport(i, j, k)           = Horizontal_Transport(i, j, k) + &
                                                                  Me%Aux3DFlux(i, j, k)


                    enddo dok1
                endif cd4

            enddo doi
            enddo doj
            !$OMP END DO

            do k=KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB

                i_West   = i -   dj
                j_South  = j -   di

                Horizontal_Transport(i_West, j_South, k)= Horizontal_Transport(i_West, j_South, k) - &
                                                          Me%Aux3DFlux(i, j, k)

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "Modify_Advection_UY_VX")
            endif

        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_YX            )
        nullify (Horizontal_Transport    )
        nullify (Velocity_UV_Old         )
        nullify (ComputeFaces3D_UV       )
        nullify (ImposedTangentialFacesUV)
        nullify (KFloor_UV               )
        nullify (DYY_XX                  )
        nullify (BoundaryFacesUV         )
        nullify (Volume_UV           )

    End Subroutine Modify_Advection_UY_VX2

    !End ----------------------------------------------------------------------

    subroutine Modify_Advection_UY_VX_Y(ComputeFaces3D_V, ImposedTangentialFacesV, BoundaryFacesV, KFloor_V, DXX, &
                                        Volume_V, WaterFlux_X, Horizontal_Transport, Velocity_V_Old)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: Horizontal_Transport
        real(8), dimension(:,:,:), pointer, intent(IN)    :: WaterFlux_X, Volume_V
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_V_Old
        real,    dimension(:,:),   pointer, intent(IN)    :: DXX
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_V, ImposedTangentialFacesV
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_V, BoundaryFacesV
        !Local---------------------------------------------------------------------
        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
        real(8)                            :: FaceFlux_SouthWest
        integer                            :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB, Kbottom
        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, FaceFlux_SouthWest, Vel4,du4,V4,CFace)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            if (BoundaryFacesV(i, j  ) == Not_Boundary .and.                 &
                BoundaryFacesV(i, j-1) == Not_Boundary) then

                if (ComputeFaces3D_V       (i, j, KUB) == Covered .or.       &
                    ImposedTangentialFacesV(i, j, KUB) == Imposed) then

                    if (ComputeFaces3D_V      (i, j-1, KUB) == Covered .or.  &
                       ImposedTangentialFacesV(i, j-1, KUB) == Imposed) then

                        !NotBoundary = .true.; FaceRightOK = .true.; FaceLeftOK = .true.
                        Kbottom = max(KFloor_V(i, j), KFloor_V(i, j-1))

                        do k = Kbottom, KUB

                            !South or West Face
                            FaceFlux_SouthWest = (WaterFlux_X(i-1, j, k) + WaterFlux_X(i, j, k))/2.

                            if ((FaceFlux_SouthWest > 0) .and. (ComputeFaces3D_V(i, j-2, k) == 0)) then
                                !NearBoundary = .true. CFace(2) = 1
                                Me%Aux3DFlux(i, j, k) = dble(Velocity_V_Old(i, j-1, k)) * FaceFlux_SouthWest ![m/s*m^3/s]

                            elseif ((FaceFlux_SouthWest <= 0) .and. (ComputeFaces3D_V(i,  j+1,  k) == 0)) then
                                !NearBoundary = .true. CFace(3) = 1
                                Me%Aux3DFlux(i, j, k) = dble(Velocity_V_Old(i, j  , k)) * FaceFlux_SouthWest ![m/s*m^3/s]

                            else
                                du4(1) = DXX(i, j-2); du4(2) = DXX(i, j-1); du4(3) = DXX(i, j); du4(4) = DXX(i, j+1)

                                V4  (2) = Volume_V(i, j-1, k);
                                V4  (3) = Volume_V(i, j  , k);

                                Vel4(1) = Velocity_V_Old(i, j-2, k); Vel4(2) = Velocity_V_Old(i, j-1, k)
                                Vel4(3) = Velocity_V_Old(i, j  , k); Vel4(4) = Velocity_V_Old(i, j+1, k)

                                call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT, &
                                    FaceFlux_SouthWest, CFace)

                                Me%Aux3DFlux(i, j, k) = dble(Vel4(2) * CFace(2) + Vel4(3) * CFace(3)) *   &
                                                    FaceFlux_SouthWest ![m/s*m^3/s]
                            endif

                            Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
                        enddo
                    endif
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL
        
        !$ CHUNK = CHUNK_K(KLB,KUB)
        !$OMP PARALLEL PRIVATE(i,j,k)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k=KLB, KUB
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i, j-1, k)= Horizontal_Transport(i, j-1, k) - Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine Modify_Advection_UY_VX_Y

    subroutine Modify_Advection_UY_VX_X(ComputeFaces3D_U, ImposedTangentialFacesU, BoundaryFacesU, KFloor_U, DYY, &
                                        Volume_U, WaterFlux_Y, Horizontal_Transport, Velocity_U_Old)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: Horizontal_Transport
        real(8), dimension(:,:,:), pointer, intent(IN)    :: WaterFlux_Y, Volume_U
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_U_Old
        real,    dimension(:,:),   pointer, intent(IN)    :: DYY
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U, ImposedTangentialFacesU
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_U, BoundaryFacesU
        !Local---------------------------------------------------------------------
        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4
        real(8)                            :: FaceFlux_SouthWest
        integer                            :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB, Kbottom
        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,FaceFlux_SouthWest,Vel4,du4,V4,CFace)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB

            if (BoundaryFacesU (i  , j) == Not_Boundary .and.                 &
                BoundaryFacesU (i-1, j) == Not_Boundary) then

                if (ComputeFaces3D_U       (i, j, KUB) == Covered .or.                  &
                    ImposedTangentialFacesU(i, j, KUB) == Imposed) then

                    if (ComputeFaces3D_U       (i-1, j, KUB) == Covered .or.   &
                        ImposedTangentialFacesU(i-1, j, KUB) == Imposed) then

                        !NotBoundary = .true.;!FaceRightOK = .true.;!FaceLeftOK = .true.
                        Kbottom = max(KFloor_U(i, j), KFloor_U(i-1, j))

                        do k = Kbottom, KUB

                            !South or West Face
                            FaceFlux_SouthWest = (WaterFlux_Y(i, j-1, k) + WaterFlux_Y(i, j, k))/2.

                            if ((FaceFlux_SouthWest > 0) .and. (ComputeFaces3D_U(i-2, j, k) == 0)) then
                                !NearBoundary = .true. CFace(2) = 1
                                Me%Aux3DFlux(i, j, k) = dble(Velocity_U_Old(i-1, j, k)) * FaceFlux_SouthWest ![m/s*m^3/s]

                            elseif ((FaceFlux_SouthWest <= 0) .and. (ComputeFaces3D_U(i+1, j, k) == 0)) then
                                !NearBoundary = .true. CFace(3) = 1
                                Me%Aux3DFlux(i, j, k) = dble(Velocity_U_Old(i  , j, k)) * FaceFlux_SouthWest ![m/s*m^3/s]

                            else

                                du4(1) = DYY(i-2, j); du4(2) = DYY(i-1, j); du4(3) = DYY(i, j); du4(4) = DYY(i+1, j)

                                V4 (2) = Volume_U(i-1, j, k);
                                V4 (3) = Volume_U(i  , j, k);

                                Vel4(1) = Velocity_U_Old(i-2, j, k); Vel4(2) = Velocity_U_Old(i-1, j, k);
                                Vel4(3) = Velocity_U_Old(i  , j, k); Vel4(4) = Velocity_U_Old(i+1, j, k);

                                call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,    &
                                                          FaceFlux_SouthWest, CFace)

                                Me%Aux3DFlux(i, j, k) = dble(Vel4(2) * CFace(2) + Vel4(3) * CFace(3)) * &
                                                        FaceFlux_SouthWest ![m/s*m^3/s]

                            endif

                            Horizontal_Transport(i, j, k)= Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
                        enddo
                    endif
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL
        
        !$ CHUNK = CHUNK_K(KLB,KUB)
        !$OMP PARALLEL PRIVATE(i,j,k)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k=KLB, KUB
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i-1, j, k) = Horizontal_Transport(i-1, j, k) - Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine Modify_Advection_UY_VX_X

! Modified by Matthias DELPEY - 06/07/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 19/07/2011- 21/07/2011 - 19/08/2011 - 29/08/2011 - 24/10/2011 - 01/11/2011 - 21/11/2011
!                             - 13/08/2012

    Subroutine Compute_StokesDriftVelocity


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        integer,                 pointer     :: IUB, ILB, JUB, JLB, KUB, KLB
        integer,                 pointer     :: WorkIUB, WorkILB, WorkJUB, WorkJLB, WorkKUB, WorkKLB
        integer,                 pointer     :: NbFreq
        integer                              :: i, j, k, i_freq
        real, dimension (:,:,:), allocatable :: U, V
        real, dimension (:    ), allocatable :: FACT
        real, dimension (:,:,:), pointer     :: WAVN, SZZ
        integer, dimension (:,:,:), pointer  :: OpenPoints3D, ComputeFaces3D_U, ComputeFaces3D_V

        real, dimension (:,:  ), pointer     :: Bathymetry, WaterColumn, DUX, DVY
        real                                 :: ZCenterCell, MaxStokesVel
        integer                              :: STAT_CALL

        !Begin---------------------------------------------------------------------

        ! Shorten variables
        IUB               => Me%Size%IUB
        ILB               => Me%Size%ILB
        JUB               => Me%Size%JUB
        JLB               => Me%Size%JLB
        KUB               => Me%Size%KUB
        KLB               => Me%Size%KLB

        WorkIUB           => Me%WorkSize%IUB
        WorkILB           => Me%WorkSize%ILB
        WorkJUB           => Me%WorkSize%JUB
        WorkJLB           => Me%WorkSize%JLB
        WorkKUB           => Me%WorkSize%KUB
        WorkKLB           => Me%WorkSize%KLB

        DUX               => Me%External_Var%DUX
        DVY               => Me%External_Var%DVY
        SZZ               => Me%External_Var%SZZ

        OpenPoints3D            => Me%External_Var%OpenPoints3D
        ComputeFaces3D_U        => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V        => Me%External_Var%ComputeFaces3D_V

        NbFreq            => Me%External_Var%StokesFreqNum
        WAVN              => Me%External_Var%StokesWaveNumber
        WaterColumn       => Me%External_Var%WaterColumn

        !Gets a pointer to Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Compute_StokesDriftVelocity - ModuleHydrodynamic - ERR20a'

        ! Allocate variables
        allocate( U    ( ILB:IUB, JLB:JUB, KLB:KUB ) )
        allocate( V    ( ILB:IUB, JLB:JUB, KLB:KUB ) )
        allocate( FACT ( 1:NbFreq                  ) )

        U(:,:,:) = 0.
        V(:,:,:) = 0.

        ! TEMPORARY ! Maximum Stokes velocity allowed (stability reasons)
        MaxStokesVel = 1.

        ! Computes Stokes Drift component at Z-points ----------------------------------------------------------------------
        do i=WorkILB,WorkIUB
        do j=WorkJLB,WorkJUB

            do k=WorkKLB,WorkKUB

                FACT(:) = 0.

                if (OpenPoints3D(i,j,k) == 1) then

                    ! Z-points depth
                    ZCenterCell = - 0.5 * ( SZZ(i,j,k) + SZZ(i,j,k-1) )

                    ! Computation of FACT = depth-dependent part of the Stokes drift
                    do i_freq=1,NbFreq

                        if (WAVN(i,j,i_freq) * WaterColumn(i,j) > 6.) then

                            FACT(i_freq) = EXP( 2. * WAVN(i,j,i_freq) * ( ZCenterCell - Me%WaterLevel%New(i,j) ) )

                        else

                            FACT(i_freq) = cosh( 2. * WAVN(i,j,i_freq) * ( Bathymetry(i,j) + ZCenterCell ) ) &
                                           / cosh( 2. * WAVN(i,j,i_freq) * WaterColumn(i,j) )

                        endif

                    enddo

                    ! Stokes drift at Z-points
                    U(i,j,k) = SUM( Me%External_Var%StokesDriftSpectrumX(i,j,:) * FACT(:) )
                    V(i,j,k) = SUM( Me%External_Var%StokesDriftSpectrumY(i,j,:) * FACT(:) )

                    ! TEMPORARY ! A maximum value of the Stokes drift velocity is imposed, for stability reasons.
                    if ( ABS(U(i,j,k)) > MaxStokesVel ) then
                        U(i,j,k) = U(i,j,k) / ABS(U(i,j,k)) * MaxStokesVel
                    endif
                    if ( ABS(V(i,j,k)) > MaxStokesVel ) then
                        V(i,j,k) = V(i,j,k) / ABS(V(i,j,k)) * MaxStokesVel
                    endif

                endif

            enddo

        enddo
        enddo


        ! Interpolation at U,V-points ----------------------------------------------------------------------------------------
        do k = WorkKLB,WorkKUB

            do j = WorkJLB,WorkJUB
            do i = WorkILB,WorkIUB

                if (ComputeFaces3D_U(i,j,k) == Covered .and. ComputeFaces3D_U(i,j-1,k) == Covered) then

                    Me%StokesVel%Horizontal%U%New(i,j,k) = Face_Interpolation(U(i,j,k), U(i,j-1,k), DUX(i,j), DUX(i,j-1))

                else

                    Me%StokesVel%Horizontal%U%New(i,j,k) = U(i,j  ,k) * ComputeFaces3D_U(i,j  ,k)                   &
                                                         + U(i,j-1,k) * ComputeFaces3D_U(i,j-1,k)
                endif

                if (ComputeFaces3D_V(i,j,k) == Covered .and. ComputeFaces3D_V(i-1,j,k) == Covered) then

                    Me%StokesVel%Horizontal%V%New(i,j,k) = Face_Interpolation(V(i,j,k), V(i-1,j,k), DVY(i,j), DVY(i-1,j))

                else

                    Me%StokesVel%Horizontal%V%New(i,j,k) = V(i  ,j,k) * ComputeFaces3D_V(i  ,j,k)  &
                                                         + V(i-1,j,k) * ComputeFaces3D_V(i-1,j,k)
                endif

            enddo
            enddo

        enddo

        ! Imposes null gradient of Stokes Drift near boundaries ----------------------------------------------------------
        ! (analogous to VelNormalOpenBoundary)

        call NullGradientNormalStokesVel

        call NullGradientTangentialStokesVel



        call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Compute_StokesDriftVelocity - ModuleHydrodynamic - ERR120'

        nullify(IUB)
        nullify(ILB)
        nullify(JUB)
        nullify(JLB)
        nullify(KUB)
        nullify(KLB)

        nullify(WorkIUB)
        nullify(WorkILB)
        nullify(WorkJUB)
        nullify(WorkJLB)
        nullify(WorkKUB)
        nullify(WorkKLB)

        nullify(SZZ)
        nullify(OpenPoints3D, ComputeFaces3D_U, ComputeFaces3D_V)

        nullify(NbFreq)
        nullify(WAVN)

        deallocate(U)
        deallocate(V)
        deallocate(FACT)

    End Subroutine Compute_StokesDriftVelocity

    !End-----------------------------------------------------------------------

    Subroutine NullGradientNormalStokesVel


        ! Imposes null gradient of Stokes Drift normal near boundaries (analogous to VelNormalOpenBoundary)


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        integer,                 pointer     :: WorkIUB, WorkILB, WorkJUB, WorkJLB, WorkKUB, WorkKLB

        integer                              :: i, j, k, di, dj, imin, imax, jmin, jmax

        integer, dimension (:,:,:), pointer  :: ComputeFaces3D_U, ComputeFaces3D_V, &
                                                ImposedNormalFacesU, ImposedNormalFacesV

        real                                 :: Vel_Left, Vel_Right

        !Begin---------------------------------------------------------------------

        ! Shorten variables

        WorkIUB           => Me%WorkSize%IUB
        WorkILB           => Me%WorkSize%ILB
        WorkJUB           => Me%WorkSize%JUB
        WorkJLB           => Me%WorkSize%JLB
        WorkKUB           => Me%WorkSize%KUB
        WorkKLB           => Me%WorkSize%KLB

        ComputeFaces3D_U        => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V        => Me%External_Var%ComputeFaces3D_V
        ImposedNormalFacesU     => Me%External_Var%ImposedNormalFacesU
        ImposedNormalFacesV     => Me%External_Var%ImposedNormalFacesV



        do k = WorkKLB,WorkKUB

            do j = WorkJLB,WorkJUB
            do i = WorkILB,WorkIUB

                ! U-component
                di = 0
                dj = 1
                if (ImposedNormalFacesU(i, j, k) == Imposed) then

                     Vel_Left  = Me%StokesVel%Horizontal%U%New (i - di, j - dj, k)   *  &
                                 ComputeFaces3D_U(i - di, j - dj, k)

                     Vel_Right = Me%StokesVel%Horizontal%U%New (i + di, j + dj, k)   *  &
                                 ComputeFaces3D_U(i + di, j + dj, k)

                    !In the exterior faces the
                    !velocity is imposed equal to the nearest computed face
                    Me%StokesVel%Horizontal%U%New(i, j, k)   =  Vel_Left + Vel_Right

               endif

               ! V-component
               di = 1
               dj = 0
               if (ImposedNormalFacesV(i, j, k) == Imposed) then

                     Vel_Left  = Me%StokesVel%Horizontal%V%New (i - di, j - dj, k)   *  &
                                 ComputeFaces3D_V(i - di, j - dj, k)

                     Vel_Right = Me%StokesVel%Horizontal%V%New (i + di, j + dj, k)   *  &
                                 ComputeFaces3D_V(i + di, j + dj, k)

                    !In the exterior faces the
                    !velocity is imposed equal to the nearest computed face
                    Me%StokesVel%Horizontal%V%New(i, j, k)   =  Vel_Left + Vel_Right

               endif

            enddo
            enddo

        enddo

        ! U-component (upper bound special case)
        di = 0
        dj = 1

        imin = di * (WorkIUB + di) + dj * WorkILB
        imax = di * (WorkIUB + di) + dj * WorkIUB

        jmin = dj * (WorkJUB + dj) + di * WorkJLB
        jmax = dj * (WorkJUB + dj) + di * WorkJUB

        do k = WorkKLB, WorkKUB
        do i= imin, imax
        do j= jmin, jmax

            if (ImposedNormalFacesU(i, j, k) == Imposed) then

                Vel_Left  = Me%StokesVel%Horizontal%U%New  (i - di, j - dj, k) * &
                            ComputeFaces3D_U(i - di, j - dj, k)

                 !In the exterior faces the
                 !velocity is imposed equal to the nearest computed face
                  Me%StokesVel%Horizontal%U%New(i, j, k)   =  Vel_Left

            endif
        enddo
        enddo
        enddo


        ! V-component (upper bound special case)
        di = 1
        dj = 0

        imin = di * (WorkIUB + di) + dj * WorkILB
        imax = di * (WorkIUB + di) + dj * WorkIUB

        jmin = dj * (WorkJUB + dj) + di * WorkJLB
        jmax = dj * (WorkJUB + dj) + di * WorkJUB

        do k = WorkKLB, WorkKUB
        do i= imin, imax
        do j= jmin, jmax

            if (ImposedNormalFacesV(i, j, k) == Imposed) then

                Vel_Left  = Me%StokesVel%Horizontal%V%New  (i - di, j - dj, k) * &
                            ComputeFaces3D_V(i - di, j - dj, k)

                 !In the exterior faces the
                 !velocity is imposed equal to the nearest computed face
                  Me%StokesVel%Horizontal%V%New(i, j, k)   =  Vel_Left

            endif
        enddo
        enddo
        enddo



        nullify(WorkIUB)
        nullify(WorkILB)
        nullify(WorkJUB)
        nullify(WorkJLB)
        nullify(WorkKUB)
        nullify(WorkKLB)

        nullify(ComputeFaces3D_U, ComputeFaces3D_V)
        nullify(ImposedNormalFacesU, ImposedNormalFacesV)


    End Subroutine NullGradientNormalStokesVel

    !End-----------------------------------------------------------------------


    Subroutine NullGradientTangentialStokesVel


        ! Imposes null gradient of tangential Stokes Drift near boundaries (analogous to VelTangentialOpenBoundary)



        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        integer,                 pointer     :: WorkIUB, WorkILB, WorkJUB, WorkJLB, WorkKUB, WorkKLB

        integer                              :: i, j, k, di, dj, Aux

        integer, dimension (:,:,:), pointer  :: ComputeFaces3D_U, ComputeFaces3D_V, &
                                                ImposedTangentialFacesU, ImposedTangentialFacesV

        real                                 :: Coef

        !Begin---------------------------------------------------------------------

        ! Shorten variables

        WorkIUB           => Me%WorkSize%IUB
        WorkILB           => Me%WorkSize%ILB
        WorkJUB           => Me%WorkSize%JUB
        WorkJLB           => Me%WorkSize%JLB
        WorkKUB           => Me%WorkSize%KUB
        WorkKLB           => Me%WorkSize%KLB

        ComputeFaces3D_U        => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V        => Me%External_Var%ComputeFaces3D_V

        ImposedTangentialFacesU => Me%External_Var%ImposedTangentialFacesU
        ImposedTangentialFacesV => Me%External_Var%ImposedTangentialFacesV


        do k = WorkKLB,WorkKUB

            do j = WorkJLB,WorkJUB
            do i = WorkILB,WorkIUB

               ! U-component
               di = 0
               dj = 1
               if (ImposedTangentialFacesU(i, j, k) == Imposed) then

                    Aux = ComputeFaces3D_U(i + dj, j + di, k) *  &
                          ComputeFaces3D_U(i - dj, j - di, k)

                    if (Aux == 1) then ! both faces are compute points
                        Coef = 0.5 ! average between the two velocities
                    else
                        Coef = 1.
                    endif

                     Me%StokesVel%Horizontal%U%New(i, j, k) = Coef                                            * &
                                                          (Me%StokesVel%Horizontal%U%New (i + dj, j + di, k)  * &
                                                           ComputeFaces3D_U (i + dj, j + di, k)               + &
                                                           Me%StokesVel%Horizontal%U%New(i - dj, j - di, k)   * &
                                                           ComputeFaces3D_U (i - dj, j - di, k))
                endif

                ! V-component
                di = 1
                dj = 0
                if (ImposedTangentialFacesV(i, j, k) == Imposed) then

                    Aux = ComputeFaces3D_V(i + dj, j + di, k) *  &
                          ComputeFaces3D_V(i - dj, j - di, k)

                    if (Aux == 1) then
                        Coef = 0.5
                    else
                        Coef = 1.
                    endif

                     Me%StokesVel%Horizontal%V%New(i, j, k) = Coef                                            * &
                                                          (Me%StokesVel%Horizontal%V%New (i + dj, j + di, k)  * &
                                                           ComputeFaces3D_V (i + dj, j + di, k)               + &
                                                           Me%StokesVel%Horizontal%V%New(i - dj, j - di, k)   * &
                                                           ComputeFaces3D_V (i - dj, j - di, k))
                endif

            enddo
            enddo

        enddo


        nullify(WorkIUB)
        nullify(WorkILB)
        nullify(WorkJUB)
        nullify(WorkJLB)
        nullify(WorkKUB)
        nullify(WorkKLB)

        nullify(ComputeFaces3D_U, ComputeFaces3D_V)
        nullify(ImposedTangentialFacesU, ImposedTangentialFacesV)


    End Subroutine NullGradientTangentialStokesVel

    !End-----------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !------------------------------------------------------------------------------

    Subroutine Modify_UX_VY_Boundary



        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: VelAux

        real(8)                            :: MomentumFlux

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_XY         => Me%WaterFluxes%XY
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

         if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UX_VY_Boundary")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,iSouth,jWest,i_North)    &
        !$OMP PRIVATE(j_East,VelAux,MomentumFlux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj


cd0:        if (BoundaryFacesUV  (i, j     ) == Boundary .and.                                  &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)


                    ! West or South Face

!cd1:            if (BoundaryFacesUV   (i_North, j_East)      == Not_Boundary .and.       &
!                    ComputeFaces3D_UV (i_North, j_East, KUB) == Not_Covered) then

cd1:            if (ImposedNormalFacesUV (i_North, j_East, KUB)  == Imposed) then

            dok1:   do k = Kbottom, KUB

                        if (WaterFlux_XY(i, j, k) > 0.) then

                            VelAux = Velocity_UV_Old(i, j, k)

                        else

                            VelAux = Velocity_UV_Old(i_North, j_East, k)

                        endif

                        ![m^3/s*m/s]  = [m/s*m^3/s]
                        MomentumFlux = dble(VelAux) * WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFlux

                    enddo dok1

!                else if (BoundaryFacesUV   (iSouth, jWest)      == Not_Boundary .and.  &
!                         ComputeFaces3D_UV (iSouth, jWest, KUB) == Not_Covered ) then cd1

                else if (ImposedNormalFacesUV (iSouth, jWest, KUB)  == Imposed) then cd1

            dok2:   do k = Kbottom, KUB

                        if (WaterFlux_XY(i, j, k) > 0.) then

                            VelAux = Velocity_UV_Old(iSouth, jWest, k)

                        else

                            VelAux = Velocity_UV_Old(i, j, k)

                        endif


                        ![m^3/s*m/s]  = [m/s*m^3/s]
                        MomentumFlux = dble(VelAux) * WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) + &
                                                         MomentumFlux


                    enddo dok2

                endif cd1


            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UX_VY_Boundary")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        nullify (Velocity_UV_Old     )
        nullify (KFloor_UV           )
        nullify (BoundaryFacesUV     )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)

    End Subroutine Modify_UX_VY_Boundary


    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine Modify_UX_VY_SubModel



        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, Horizontal_Transport, Sub_qXY
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old !,Sub_UV
        real,    dimension(:,:  ), pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real(8)                            :: MomentumFlux, FatherFlux, SonFlux, AverageFlux

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_XY         => Me%WaterFluxes%XY
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        !Sub_UV               => Me%SubModel%UV
        Sub_qXY              => Me%SubModel%qXY

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV
        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UX_VY_SubModel")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_North,j_East,Kbottom,SonFLux) &
        !$OMP PRIVATE(FatherFlux,MomentumFlux,AverageFlux)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj


cd0:        if (BoundaryFacesUV  (i, j)      == Boundary .and.                           &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)

                ! East or North Face

!cd1:            if (BoundaryFacesUV   (i_North, j_East)      == Not_Boundary .and.       &
!                    ComputeFaces3D_UV (i_North, j_East, KUB) == Not_Covered) then

cd1:            if (ImposedNormalFacesUV (i_North, j_East, KUB) == Imposed) then

            dok1:   do k = Kbottom, KUB


                       ![m^3/s]  = [m^3/s]
                        SonFlux    =  WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        ![m^3/s]   = [m^2/s]*[m]

                        FatherFlux =      Sub_qXY (i_North, j_East, k)  *                &
                                     dble(DYY_XX  (i_North, j_East)   )

                        AverageFlux  = (FatherFlux + SonFlux) / 2.

                        if (AverageFlux > 0 ) then

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(i,  j,  k))          * AverageFlux

                        else

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(i_North, j_East, k)) * AverageFlux

                        endif


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFlux

                    enddo dok1

                ! West or South Face

!                else if (BoundaryFacesUV   (iSouth, jWest)      == Not_Boundary .and.  &
!                         ComputeFaces3D_UV (iSouth, jWest, KUB) == Not_Covered ) then cd1

                else if (ImposedNormalFacesUV (iSouth, jWest, KUB) == Imposed) then cd1

            dok2:   do k = Kbottom, KUB



                       ![m^3/s]  = [m^3/s]
                        SonFlux    =  WaterFlux_XY(i, j, k) ![m/s*m^3/s]


                        ![m^3/s]  = [m^2/s]*[m]
                        FatherFlux =      Sub_qXY (iSouth, jWest, k)  *                &
                                     dble(DYY_XX  (iSouth, jWest)   )

                        AverageFlux  = (FatherFlux + SonFlux) / 2.

                        if (AverageFlux > 0 ) then

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(iSouth, jWest, k)) * AverageFlux

                        else

                            ![m^3/s*m/s] = [m/s*m^3/s]
                            MomentumFlux = dble(Velocity_UV_Old(i,  j,  k))          * AverageFlux

                        endif


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) + &
                                                         MomentumFlux

                    enddo dok2

                endif cd1

            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UX_VY_SubModel")
        endif

        !Nullify auxiliar pointers
        nullify (WaterFlux_XY        )
        nullify (Horizontal_Transport)
        !nullify (Sub_UV             )
        nullify (Sub_qXY             )
        nullify (DYY_XX              )
        nullify (KFloor_UV           )
        nullify (BoundaryFacesUV     )
        nullify (Velocity_UV_Old     )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)

    End Subroutine Modify_UX_VY_SubModel


    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine Modify_UY_VX_Boundary



        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, WaterFlux_YX

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV,                &
                                              BoundaryFacesVU

        real(8)                            :: MomentumFluxUp, MomentumFluxDown,          &
                                              WaterFluxUp   , WaterFluxDown

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest , i_East,                  &
                                              j_North, i_West, j_South

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU    => Me%External_Var%ComputeFaces3D_VU
        KFloor_UV            => Me%External_Var%KFloor_UV

        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        BoundaryFacesVU      => Me%External_Var%BoundaryFacesVU

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UY_VX_Boundary")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_East,j_North,i_West) &
        !$OMP PRIVATE(j_South,Kbottom,WaterFluxUp,MomentumFluxUp) &
        !$OMP PRIVATE(WaterFluxDown,MomentumFluxDown)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            i_East   = i +   dj
            j_North  = j +   di

            i_West   = i -   dj
            j_South  = j -   di



            Kbottom = KFloor_UV(i, j)

            !Momentum changes perpendicular to the velocity
            ! in boundary faces perpendicular also to the velocity
            !If the velocity is in the X direction the boundaries
            ! compute are the West and the East ones
            !If the velocity is in the Y direction the boundaries
            ! compute are the South and the North ones


cd0:        if (BoundaryFacesUV  (i, j     ) == Boundary .and.                           &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then

        dok1:   do k = Kbottom, KUB

                    ![m^3/s*m/s]  = [m^3/s*m/s]
                    WaterFluxUp       = (dble(ComputeFaces3D_VU(i - di + dj, j - dj + di, k)) * &
                                         WaterFlux_YX          (i - di + dj, j - dj + di, k)  + &
                                         dble(ComputeFaces3D_VU(i_East     , j_North    , k)) * &
                                         WaterFlux_YX          (i_East     , j_North    , k))

                    if (WaterFluxUp > 0) then

                        MomentumFluxUp = dble(Velocity_UV_Old  (i     , j      , k)) * WaterFluxUp

                    else

                        MomentumFluxUp = dble(Velocity_UV_Old  (i_East, j_North, k)) * WaterFluxUp

                    endif


                    WaterFluxDown     = (dble(ComputeFaces3D_VU(iSouth    , jWest     , k)) * &
                                         WaterFlux_YX          (iSouth    , jWest     , k)  + &
                                         dble(ComputeFaces3D_VU(i          , j          , k)) * &
                                         WaterFlux_YX          (i          , j          , k))


                    if (WaterFluxDown > 0) then

                        MomentumFluxDown = dble(Velocity_UV_Old  (i_West, j_South, k)) * WaterFluxDown

                    else

                        MomentumFluxDown = dble(Velocity_UV_Old  (i     , j      , k)) * WaterFluxDown

                    endif

                    !The same tangential boundary condition assumed
                    !for the velocity is assumed for the water flow
                    if (Me%ComputeOptions%VelTangentialBoundary == NULL_VALUE) then

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFluxUp    / 2.        + &
                                                         MomentumFluxDown  / 2.

                    else if (Me%ComputeOptions%VelTangentialBoundary == NULL_GRADIENT) then


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFluxUp        +         &
                                                         MomentumFluxDown

                    endif


                enddo dok1

            endif cd0




        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UY_VX_Boundary")
        endif

        !Nullify auxiliar pointers
        nullify(WaterFlux_YX         )
        nullify(Horizontal_Transport )
        nullify(Velocity_UV_Old      )

        nullify(ComputeFaces3D_UV    )
        nullify(ComputeFaces3D_VU    )
        nullify(KFloor_UV            )

        nullify(BoundaryFacesUV      )
        nullify(BoundaryFacesVU      )

    End Subroutine Modify_UY_VX_Boundary


    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    !------------------------------------------------------------------------------

    Subroutine Modify_UY_VX_SubModel



        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, WaterFlux_YX, Sub_qYX
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old !,Sub_UV, Sub_VU
        real,    dimension(:,:  ), pointer :: DXX_YY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV       , ComputeFaces3D_VU
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV, ImposedTangentialFacesVU
        integer, dimension(:,:),   pointer :: BoundaryFacesUV, KFloor_UV

        real(8)                            :: MomentumFluxUp, MomentumFluxDown
        real(8)                            :: WaterFluxUp, WaterFluxDown
        real(8)                            :: WaterFluxImposed, WaterFluxComputed

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest , i_East,                  &
                                              j_North

        integer                            :: j_South, i_West


        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_YX         => Me%WaterFluxes%YX
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Sub_qYX              => Me%SubModel%qYX

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU        => Me%External_Var%ComputeFaces3D_VU

        ImposedTangentialFacesVU => Me%External_Var%ImposedTangentialFacesVU
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        KFloor_UV                => Me%External_Var%KFloor_UV

        DXX_YY                   => Me%External_Var%DXX_YY

        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV


        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_UY_VX_SubModel")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_East,j_North) &
        !$OMP PRIVATE(i_West,j_South,Kbottom,WaterFluxImposed) &
        !$OMP PRIVATE(WaterFluxComputed,WaterFluxUp,MomentumFluxUp) &
        !$OMP PRIVATE(WaterFluxDown,MomentumFluxDown)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj: do j=JLB, JUB
    doi: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj

            i_East   = i +   dj
            j_North  = j +   di

            i_West   = i -   dj
            j_South  = j -   di


            !Momentum changes perpendicular to the velocity
            ! in boundary faces perpendicular also to the velocity
            !If the velocity is in the X direction the boundaries
            ! compute are the West and the East ones
            !If the velocity is in the Y direction the boundaries
            ! compute are the South and the North ones


cd0:        if (BoundaryFacesUV  (i, j     ) == Boundary .and.                           &
                ComputeFaces3D_UV(i, j, KUB) == Covered) then

                !East or North face
cd1:            if (ComputeFaces3D_UV       (i_East, j_North, KUB) == Covered   .or.     &
                    ImposedTangentialFacesUV(i_East, j_North, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_East, j_North))

dok1:               do k = Kbottom, KUB

                        ![m^3/s]          = [m^2/s]*[m]
                        WaterFluxImposed  =  dble(ImposedTangentialFacesVU(i - di + dj, j - dj + di, k)) * &
                                                  Sub_qYX                 (i - di + dj, j - dj + di, k)  * &
                                             dble(DXX_YY                  (i - di + dj, j - dj + di   )) + &
                                             dble(ImposedTangentialFacesVU(i_East     , j_North    , k)) * &
                                                  Sub_qYX                 (i_East     , j_North    , k)  * &
                                             dble(DXX_YY                  (i_East     , j_North       ))
                        ![m^3/s]          = [m^3/s]
                        WaterFluxComputed =  dble(ComputeFaces3D_VU(i - di + dj, j - dj + di, k)) * &
                                                  WaterFlux_YX     (i - di + dj, j - dj + di, k)  + &
                                             dble(ComputeFaces3D_VU(i_East     , j_North    , k)) * &
                                                  WaterFlux_YX     (i_East     , j_North    , k)




                        WaterFluxUp       =  (WaterFluxImposed + WaterFluxComputed) / 2.


cd2:                    if (WaterFluxUp > 0) then

                            MomentumFluxUp = WaterFluxUp * dble(Velocity_UV_Old  (i , j , k))

                        else  cd2

                            MomentumFluxUp = WaterFluxUp * dble(Velocity_UV_Old  (i_East, j_North, k))

                        endif cd2

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) - &
                                                         MomentumFluxUp

                    enddo dok1

                endif cd1


                !West or South face
cd3:            if (ComputeFaces3D_UV       (i_West, j_South, KUB) == Covered   .or.     &
                    ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

dok2:               do k = Kbottom, KUB

                        ![m^3/s]         = [m^2/s]*[m]
                        WaterFluxImposed =  dble(ImposedTangentialFacesVU(iSouth    , jWest     , k)) * &
                                                 Sub_qYX                 (iSouth    , jWest     , k)  * &
                                            dble(DXX_YY                  (iSouth    , jWest        )) + &
                                            dble(ImposedTangentialFacesVU(i          , j        , k)) * &
                                                 Sub_qYX                 (i          , j        , k)  * &
                                            dble(DXX_YY                  (i          , j           ))


                        ![m^3/s]         = [m^2/s]*[m]
                        WaterFluxComputed=  dble(ComputeFaces3D_VU(iSouth    , jWest     , k)) * &
                                                 WaterFlux_YX     (iSouth    , jWest     , k)  + &
                                            dble(ComputeFaces3D_VU(i          , j          , k)) * &
                                                 WaterFlux_YX     (i          , j          , k)


                        WaterFluxDown    =  (WaterFluxImposed + WaterFluxComputed) / 2.


cd4:                    if (WaterFluxDown > 0) then

                            MomentumFluxDown = WaterFluxDown * dble(Velocity_UV_Old  (i_West, j_South, k))

                        else  cd4

                            MomentumFluxDown = WaterFluxDown * dble(Velocity_UV_Old  (i , j , k))

                        endif cd4

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k) + &
                                                         MomentumFluxDown

                    enddo dok2

                endif cd3

            endif cd0

        enddo doi
        enddo doj
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_UY_VX_SubModel")
        endif

        !Nullify auxiliar pointers
        nullify(WaterFlux_YX         )
        nullify(Horizontal_Transport )
        nullify(Velocity_UV_Old      )

        nullify(Sub_qYX              )

        nullify(ComputeFaces3D_UV    )
        nullify(ComputeFaces3D_VU    )

        nullify(ImposedTangentialFacesUV)
        nullify(ImposedTangentialFacesVU)

        nullify(KFloor_UV            )

        nullify(BoundaryFacesUV      )

        nullify(DXX_YY               )

    End Subroutine Modify_UY_VX_SubModel


    !End ----------------------------------------------------------------------


    !------------------------------------------------------------------------------

    Subroutine AdvectionInSmallDepths


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:  ), pointer :: WaterColumn, WaterColumnUV, DUX_VY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: FaceWaterColumn, Hmin_Advection

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !WaterColumn          => Me%External_Var%WaterColumn
        WaterColumnUV        => Me%External_Var%WaterColumnUV
        DUX_VY               => Me%External_Var%DUX_VY

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        Hmin_Advection      =  Me%ComputeOptions%Hmin_Advection

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "AdvectionInSmallDepths")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,FaceWaterColumn,Kbottom)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj


            FaceWaterColumn = WaterColumnUV(i, j)

 !If the depth in a face is smaller than Hmin_Advection then advection is cancelled
cd0:        if (ComputeFaces3D_UV(i, j, KUB) == Covered .and.                            &
                FaceWaterColumn < Hmin_Advection) then


                Kbottom = KFloor_UV(i, j)

                !West or South Face
        dok1:   do k = Kbottom, KUB

                    Horizontal_Transport(i, j, k) = 0.

                enddo dok1

            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "AdvectionInSmallDepths")
        endif

        nullify (WaterColumn         )
        nullify (DUX_VY              )

        !End ----------------------------------------------------------------------

    end Subroutine AdvectionInSmallDepths


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion with the same direction of the     !
    !  velocity. For the U velocity compute the diffusion with the X direction             !
    !  for the V velocity compute the diffusion with the Y direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Diffusion_UX_VY ( Velocity_UV_Old, Biharmonic)

        !Variables category
        ! Geometry : Volume_Z, DUX_VY (Volume and length of the elevation control volume)
        ! Flow     : Visc_H_Center (Turbulent viscosity in the center of the elevation control volume),
        !            Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables direction dependent:
        ! Horizontal_Transport, DUX_VY, Velocity_UV_Old, ComputeFaces3D_UV, Direction, Kfloor_UV


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        logical, intent (IN)               :: Biharmonic

        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_New, Volume_UV
        real,    dimension(:,:,:), pointer :: Visc_H_Center
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        logical                            :: ConservativeHorDif, ComputeFlux

        real                               :: FaceFlux_WestSouth1, FaceFlux_WestSouth2, Aux, ViscAux

        real                               :: Vel_UV_South, Vel_UV_North

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK

        !Begin-----------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif

        Visc_H_Center        => Me%External_Var%Visc_H_Center

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Volume_Z_New         => Me%External_Var%Volume_Z_New
        DUX_VY               => Me%External_Var%DUX_VY

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        !End - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Diffusion_UX_VY")
        endif


        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !It was lacking Vel_UV_South and Vel_UV_North in private what created OpenMP errors
        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth, jWest, i_North, j_East, &
        !$OMP                   ComputeFlux, &
        !$OMP                   ViscAux,FaceFlux_WestSouth1,FaceFlux_WestSouth2, &
        !$OMP                   Aux,Vel_UV_South,Vel_UV_North)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doi:    do j=JLB, JUB
doj:    do i=ILB, IUB

            iSouth  = i -   di
            jWest   = j -   dj
            i_North = i +   di
            j_East  = j +   dj

            ComputeFlux = .false.

            if (Me%ComputeOptions%SlippingCondition) then

                if (ComputeFaces3D_UV(i      , j   , KUB) == Covered  .and.            &
                    ComputeFaces3D_UV(iSouth, jWest, KUB) == Covered )   ComputeFlux = .true.

            else

                if (ComputeFaces3D_UV   (i      , j     , KUB) == Covered  .or.          &
                    ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered) ComputeFlux = .true.

            endif

            !When the boundary is Cyclic the momentum diffusion flux is also compute for the boundary faces
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_))  then

                if ((ComputeFaces3D_UV   (i     , j     , KUB) == Covered .and.          &
                     ImposedNormalFacesUV(iSouth, jWest , KUB) == Imposed) .or.          &
                    (ComputeFaces3D_UV   (iSouth, jWest , KUB) == Covered .and.          &
                     ImposedNormalFacesUV(i     , j     , KUB) == Imposed))              &
                                                                           ComputeFlux = .true.

            endif

cd0:        if (ComputeFlux) then
                Kbottom = max(KFloor_UV(i, j), KFloor_UV(iSouth, jWest))

dok1:           do k = Kbottom, KUB

                    if (BiHarmonic) then

                        ViscAux = Me%ComputeOptions%BiHarmonicCoef

                    else

                        ViscAux = Visc_H_Center( iSouth, jWest, k)

                    endif

                    Vel_UV_South = Velocity_UV_Old( iSouth, jWest, k)
                    Vel_UV_North = Velocity_UV_Old( i     , j    , k)

                    if (Me%WaterFluxes%Discharges( iSouth, jWest, k) > 0. .and.     &
                                ComputeFaces3D_UV( iSouth, jWest, k) /= Covered) then

                        if (Me%ComputeOptions%MomentumDischarge) then
                            Vel_UV_South = Me%WaterFluxes%DischargesVelUV(iSouth, jWest, k)
                        endif


                    endif

                    if (Me%WaterFluxes%Discharges(i, j, k) > 0. .and.               &
                                ComputeFaces3D_UV(i, j, k) /= Covered) then

                        if (Me%ComputeOptions%MomentumDischarge) then
                            Vel_UV_South = Me%WaterFluxes%DischargesVelUV(i, j, k)
                        endif

                    endif

cd1:                if (ConservativeHorDif) then

                        ! West or South Face

                        ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                        FaceFlux_WestSouth1 = ViscAux                            *      & ! Turbulent viscosity
                                             (Vel_UV_North - Vel_UV_South) /            &
                                             DUX_VY( iSouth, jWest) *                   & ! Velocity gradient
                                             Volume_Z_New( iSouth, jWest, k) /          &
                                             DUX_VY( iSouth, jWest)                     ! Face Area

                        FaceFlux_WestSouth2 = FaceFlux_WestSouth1

                    else cd1

                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux                 = ViscAux                           *       & ! Turbulent viscosity
                                            (Vel_UV_North - Vel_UV_South) /             &
                                             DUX_VY( iSouth, jWest)                       ! Velocity gradient

                        !The velocity gradient plus the volume divided by the distance between
                        !volume faces is equal to compute in a non-conservative way the lapalcian of the
                        !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity
                        !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                        !

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth1 = Aux * Volume_UV(i      , j     , k) /      &
                                                    DZX_ZY   (i - di , j - dj)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth2 = Aux * Volume_UV(iSouth, jWest, k) /      &
                                                    DZX_ZY   (iSouth - di , jWest - dj)

                    endif cd1

                    Horizontal_Transport(i, j, k)            = Horizontal_Transport(i, j, k) &
                                                              - FaceFlux_WestSouth1

                    Me%Aux3DFlux        (iSouth, jWest, k)   =  FaceFlux_WestSouth2

                 enddo dok1

             endif cd0

        enddo doj
        enddo doi
        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_Z_New        )
        nullify (Visc_H_Center       )
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)
        nullify (KFloor_UV           )
        nullify (Volume_UV           )

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Diffusion_UX_VY")
        endif

    End Subroutine Modify_Diffusion_UX_VY

    !End---------------------------------------------------------------------------
    Subroutine Modify_Diffusion_UX_VY2 ( Velocity_UV_Old, Biharmonic)

        !Arguments------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(IN) :: Velocity_UV_Old
        logical, intent (IN)                           :: Biharmonic
        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_New, Volume_UV
        real,    dimension(:,:,:), pointer :: Visc_H_Center
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV
        logical                            :: ConservativeHorDif, ComputeFlux, GoForOptimized
        real                               :: FaceFlux_WestSouth1, FaceFlux_WestSouth2, Aux, ViscAux
        real                               :: Vel_UV_South, Vel_UV_North
        integer                            :: di, dj, i, j, k, Kbottom
        integer                            :: iSouth, jWest, i_North, j_East
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                            :: CHUNK

        !Begin-----------------------------------------------------------------------------

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif
        Visc_H_Center        => Me%External_Var%Visc_H_Center
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        ImposedNormalFacesUV => Me%External_Var%ImposedNormalFacesUV
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV
        Volume_Z_New         => Me%External_Var%Volume_Z_New
        DUX_VY               => Me%External_Var%DUX_VY
        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        if (.not. Me%ComputeOptions%ConservativeHorDif)then
            if (Me%ComputeOptions%SlippingCondition) then
                if ( .not. Me%CyclicBoundary%ON)  then
                    if (.not.Me%ComputeOptions%MomentumDischarge) then
                        GoForOptimized = .true.
                    endif
                endif
            endif
        endif

        if (GoForOptimized) then
            if (Me%Direction%di == 1) then
                !Compute Y direction
                call Modify_Diffusion_UX_VY_Y (Velocity_UV_Old, Me%External_Var%ComputeFaces3D_V,                   &
                                          Me%External_Var%KFloor_V, Me%External_Var%Volume_V, Me%External_Var%DVY,  &
                                          Me%External_Var%DZY, Me%Forces%Horizontal_Transport, Biharmonic)
            else
                !Compute X direction
                call Modify_Diffusion_UX_VY_X (Velocity_UV_Old, Me%External_Var%ComputeFaces3D_U,                   &
                                          Me%External_Var%KFloor_U, Me%External_Var%Volume_U, Me%External_Var%DUX,  &
                                          Me%External_Var%DZX, Me%Forces%Horizontal_Transport, Biharmonic)
            endif

            call SumMatrixes(Me%Forces%Horizontal_Transport, Me%WorkSize, Me%Aux3DFlux)
        else

      !------------------------Original non-optimized routine--------------------------------------------------
            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "Modify_Diffusion_UX_VY")
            endif
            !$ CHUNK = CHUNK_J(JLB,JUB)

            !It was lacking Vel_UV_South and Vel_UV_North in private what created OpenMP errors
            !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
            !$OMP                   iSouth, jWest, i_North, j_East, &
            !$OMP                   ComputeFlux, &
            !$OMP                   ViscAux,FaceFlux_WestSouth1,FaceFlux_WestSouth2, &
            !$OMP                   Aux,Vel_UV_South,Vel_UV_North)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi:    do j=JLB, JUB
    doj:    do i=ILB, IUB

                iSouth  = i -   di
                jWest   = j -   dj
                i_North = i +   di
                j_East  = j +   dj

                ComputeFlux = .false.

                if (Me%ComputeOptions%SlippingCondition) then

                    if (ComputeFaces3D_UV(i      , j   , KUB) == Covered  .and.            &
                        ComputeFaces3D_UV(iSouth, jWest, KUB) == Covered )   ComputeFlux = .true.

                else

                    if (ComputeFaces3D_UV   (i      , j     , KUB) == Covered  .or.          &
                        ComputeFaces3D_UV   (iSouth, jWest, KUB) == Covered) ComputeFlux = .true.

                endif

                !When the boundary is Cyclic the momentum diffusion flux is also compute for the boundary faces
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_))  then

                    if ((ComputeFaces3D_UV   (i     , j     , KUB) == Covered .and.          &
                         ImposedNormalFacesUV(iSouth, jWest , KUB) == Imposed) .or.          &
                        (ComputeFaces3D_UV   (iSouth, jWest , KUB) == Covered .and.          &
                         ImposedNormalFacesUV(i     , j     , KUB) == Imposed))              &
                                                                               ComputeFlux = .true.

                endif

    cd0:        if (ComputeFlux) then
                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(iSouth, jWest))

    dok1:           do k = Kbottom, KUB

                        if (BiHarmonic) then

                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else

                            ViscAux = Visc_H_Center( iSouth, jWest, k)

                        endif

                        Vel_UV_South = Velocity_UV_Old( iSouth, jWest, k)
                        Vel_UV_North = Velocity_UV_Old( i     , j    , k)

                        if (Me%WaterFluxes%Discharges( iSouth, jWest, k) > 0. .and.     &
                                    ComputeFaces3D_UV( iSouth, jWest, k) /= Covered) then

                            if (Me%ComputeOptions%MomentumDischarge) then
                                Vel_UV_South = Me%WaterFluxes%DischargesVelUV(iSouth, jWest, k)
                            endif


                        endif

                        if (Me%WaterFluxes%Discharges(i, j, k) > 0. .and.               &
                                    ComputeFaces3D_UV(i, j, k) /= Covered) then

                            if (Me%ComputeOptions%MomentumDischarge) then
                                Vel_UV_South = Me%WaterFluxes%DischargesVelUV(i, j, k)
                            endif

                        endif

    cd1:                if (ConservativeHorDif) then

                            ! West or South Face

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                            FaceFlux_WestSouth1 = ViscAux                            *      & ! Turbulent viscosity
                                                 (Vel_UV_North - Vel_UV_South) /            &
                                                 DUX_VY( iSouth, jWest) *                   & ! Velocity gradient
                                                 Volume_Z_New( iSouth, jWest, k) /          &
                                                 DUX_VY( iSouth, jWest)                     ! Face Area

                            FaceFlux_WestSouth2 = FaceFlux_WestSouth1

                        else cd1

                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux                 = ViscAux                           *       & ! Turbulent viscosity
                                                (Vel_UV_North - Vel_UV_South) /             &
                                                 DUX_VY( iSouth, jWest)                       ! Velocity gradient

                            !The velocity gradient plus the volume divided by the distance between
                            !volume faces is equal to compute in a non-conservative way the lapalcian of the
                            !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity
                            !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                            !

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_WestSouth1 = Aux * Volume_UV(i      , j     , k) /      &
                                                        DZX_ZY   (i - di , j - dj)

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_WestSouth2 = Aux * Volume_UV(iSouth, jWest, k) /      &
                                                        DZX_ZY   (iSouth - di , jWest - dj)

                        endif cd1

                        Horizontal_Transport(i, j, k)            = Horizontal_Transport(i, j, k) &
                                                                  - FaceFlux_WestSouth1

                        Me%Aux3DFlux        (iSouth, jWest, k)   =  FaceFlux_WestSouth2

                     enddo dok1

                 endif cd0

            enddo doj
            enddo doi
            !$OMP END DO

            do k=KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB
                Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "Modify_Diffusion_UX_VY")
            endif
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_Z_New        )
        nullify (Visc_H_Center       )
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)
        nullify (KFloor_UV           )
        nullify (Volume_UV           )

    End Subroutine Modify_Diffusion_UX_VY2

    !End---------------------------------------------------------------------------

    subroutine Modify_Diffusion_UX_VY_Y(Velocity_V_Old, ComputeFaces3D_V, KFloor_V, Volume_V, DVY, DZY, &
        Horizontal_Transport, Biharmonic)
        !Arguments--------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer , intent(INOUT) :: Horizontal_Transport
        real,    dimension(:,:,:), pointer,  intent(IN)    :: Velocity_V_Old
        logical,                             intent(IN)    :: Biharmonic
        real(8), dimension(:,:,:), pointer , intent(IN)    :: Volume_V
        real,    dimension(:,:),   pointer , intent(IN)    :: DVY, DZY
        integer, dimension(:,:,:), pointer , intent(IN)    :: ComputeFaces3D_V
        integer, dimension(:,:),   pointer , intent(IN)    :: KFloor_V
        !Local-----------------------------------------------------------------------------
        real                               :: FaceFlux_WestSouth1, FaceFlux_WestSouth2, Aux
        integer                            :: i, j, k, Kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                         :: CHUNK

        !Begin-----------------------------------------------------------------------------
        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, FaceFlux_WestSouth1,FaceFlux_WestSouth2, Aux)

        if (BiHarmonic) then
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB

                if (ComputeFaces3D_V(i, j, KUB) == Covered  .and. ComputeFaces3D_V(i-1, j, KUB) == Covered ) then

                    Kbottom = max(KFloor_V(i, j), KFloor_V(i-1, j))

                    do k = Kbottom, KUB

                        ![m^2/s^2]  = [m^2/s] * [m/s] / [m]
                        Aux = Me%ComputeOptions%BiHarmonicCoef  *  &                               !Turbulent viscosity
                             (Velocity_V_Old(i, j, k) - Velocity_V_Old( i-1, j, k)) / DVY( i-1, j) !Velocity gradient

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth1 = Aux * Volume_V(i  , j, k) / DZY(i-1, j)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth2 = Aux * Volume_V(i-1, j, k) / DZY(i-2, j)

                        Horizontal_Transport(i  , j, k) = Horizontal_Transport(i, j, k) - FaceFlux_WestSouth1

                        Me%Aux3DFlux        (i-1, j, k) = FaceFlux_WestSouth2
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        else
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB

                if (ComputeFaces3D_V(i, j, KUB) == Covered  .and. ComputeFaces3D_V(i-1, j, KUB) == Covered ) then

                    Kbottom = max(KFloor_V(i, j), KFloor_V(i-1, j))

                    do k = Kbottom, KUB
                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%External_Var%Visc_H_Center( i-1, j, k)   *      &               ! Turbulent viscosity
                             (Velocity_V_Old(i, j, k) - Velocity_V_Old(i-1, j, k)) / DVY( i-1, j)! Velocity gradient

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth1 = Aux * Volume_V(i  , j, k) / DZY(i-1 , j)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth2 = Aux * Volume_V(i-1, j, k) / DZY(i-2, j)

                        Horizontal_Transport(i  , j, k) = Horizontal_Transport(i, j, k) - FaceFlux_WestSouth1

                        Me%Aux3DFlux        (i-1, j, k) =  FaceFlux_WestSouth2
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif
        !$OMP END PARALLEL

    end subroutine Modify_Diffusion_UX_VY_Y

    !End---------------------------------------------------------------------------

    subroutine Modify_Diffusion_UX_VY_X(Velocity_U_Old, ComputeFaces3D_U, KFloor_U, Volume_U, DUX, DZX, &
        Horizontal_Transport, Biharmonic)
        !Arguments--------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer , intent(INOUT) :: Horizontal_Transport
        real,    dimension(:,:,:), pointer,  intent(IN)    :: Velocity_U_Old
        logical,                             intent(IN)    :: Biharmonic
        real(8), dimension(:,:,:), pointer , intent(IN)    :: Volume_U
        real,    dimension(:,:),   pointer , intent(IN)    :: DUX, DZX
        integer, dimension(:,:,:), pointer , intent(IN)    :: ComputeFaces3D_U
        integer, dimension(:,:),   pointer , intent(IN)    :: KFloor_U
        !Local-----------------------------------------------------------------------------
        real                               :: FaceFlux_WestSouth1, FaceFlux_WestSouth2, Aux
        integer                            :: i, j, k, Kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                         :: CHUNK

        !Begin-----------------------------------------------------------------------------
        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !It was lacking Vel_UV_South and Vel_UV_North in private what created OpenMP errors
        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, FaceFlux_WestSouth1,FaceFlux_WestSouth2, Aux)

        if (BiHarmonic) then
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB
            
                if (ComputeFaces3D_U(i, j, KUB) == Covered .and. ComputeFaces3D_U(i, j-1, KUB) == Covered ) then

                    Kbottom = max(KFloor_U(i, j), KFloor_U(i, j-1))

                    do k = Kbottom, KUB

                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%ComputeOptions%BiHarmonicCoef                           *       &   ! Turbulent viscosity
                             (Velocity_U_Old(i, j, k) - Velocity_U_Old(i, j-1, k)) / DUX( i, j-1) ! Velocity gradient

                        ![m^3/s*m/s]                    = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth1             = Aux * Volume_U(i, j  , k) / DZX(i, j-1)

                        ![m^3/s*m/s]                    = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth2             = Aux * Volume_U(i, j-1, k) / DZX(i, j-2)

                        Horizontal_Transport(i, j  , k) = Horizontal_Transport(i, j, k) - FaceFlux_WestSouth1

                        Me%Aux3DFlux        (i, j-1, k) = FaceFlux_WestSouth2

                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        else
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB
                if (ComputeFaces3D_U(i, j, KUB) == Covered .and. ComputeFaces3D_U(i, j-1, KUB) == Covered ) then

                    Kbottom = max(KFloor_U(i, j), KFloor_U(i, j-1))

                    do k = Kbottom, KUB

                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%External_Var%Visc_H_Center(i, j-1, k)   *                         & ! Turbulent viscosity
                              (Velocity_U_Old(i, j, k) - Velocity_U_Old(i, j-1, k)) / DUX(i, j-1) ! Velocity gradient

                        ![m^3/s*m/s]                    = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth1             = Aux * Volume_U(i, j  , k) / DZX(i, j-1)

                        ![m^3/s*m/s]                    = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_WestSouth2             = Aux * Volume_U(i, j-1, k) / DZX(i, j-2)

                        Horizontal_Transport(i, j  , k) = Horizontal_Transport(i, j, k) - FaceFlux_WestSouth1

                        Me%Aux3DFlux        (i, j-1, k) =  FaceFlux_WestSouth2
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif
        !$OMP END PARALLEL

    end subroutine Modify_Diffusion_UX_VY_X


        !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion perpendicular to the               !
    !  velocity. For the U velocity compute the diffusion with the Y direction             !
    !  for the V velocity compute the diffusion with the X direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_Diffusion_UY_VX ( Velocity_UV_Old, Biharmonic)


        !Variables categories
        ! Geometry : Area_VU (area of the compute V or U compute points), DYY_XX (centered
        !   width of the V or U control volume)
        !
        ! Flow     : Visc_H_Corner (Turbulent viscosity in the SW corner of the elevation
        !   control volume), Velocity_UV_Old (U or V velocity)
        !
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV
        !   (1 - covered faces, 0 - not covered faces)
        !
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        !
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound),
        !            KUB (k upper bound)
        !
        !Variables direction dependent:
        !DUX_DVY, Velocity_UV_Old, ComputeFaces3D_UV, Direction, Kfloor_UV

        !Arguments--------------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        logical, intent (IN)               :: Biharmonic
        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Area_VU
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2

        real                               :: Aux, ViscAux

        logical                            :: ConservativeHorDif, NoSlipFace,            &
                                              ComputeFlux, ComputeFlux1, ComputeFlux2

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_West, j_South

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK

        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        Volume_UV            => Me%External_Var%Volume_UV
        Area_VU              => Me%External_Var%Area_VU
        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_Diffusion_UY_VX")
        endif

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
        !$OMP                   iSouth, jWest, i_West, j_South, &
        !$OMP                   ComputeFlux, ComputeFlux1, ComputeFlux2, &
        !$OMP                   ViscAux,FaceFlux_SouthWest1,FaceFlux_SouthWest2, &
        !$OMP                   NoSlipFace, Aux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i - di
            jWest   = j - dj

            i_West   = i - dj
            j_South  = j - di

            ComputeFlux  = .false.
            ComputeFlux1 = .false.
            ComputeFlux2 = .false.

            if (Me%ComputeOptions%SlippingCondition) then

                if (ComputeFaces3D_UV(i     , j      , KUB) == Covered .and.             &
                    ComputeFaces3D_UV(i_West, j_South, KUB) == Covered) ComputeFlux = .true.

            else

                if (ComputeFaces3D_UV        (i     , j      , KUB) == Covered .or.      &
                    ComputeFaces3D_UV        (i_West, j_South, KUB) == Covered) then

                    ComputeFlux = .true.
                    if (ComputeFaces3D_UV    (i     , j      , KUB) == Covered) ComputeFlux1 = .true.
                    if (ComputeFaces3D_UV    (i_West, j_South, KUB) == Covered) ComputeFlux2 = .true.

                endif

            endif

            !When the boundary is Cyclic the momentum diffusion flux is also compute for the boundary faces
            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                            Me%CyclicBoundary%Direction == DirectionXY_))  then

                if ((ComputeFaces3D_UV       (i     , j       , KUB) == Covered .and.    &
                     ImposedTangentialFacesUV(i_West, j_South , KUB) == Imposed) .or.    &
                    (ComputeFaces3D_UV       (i_West, j_South , KUB) == Covered .and.    &
                     ImposedTangentialFacesUV(i     , j       , KUB) == Imposed)) then

                    ComputeFlux = .true.

                    ComputeFlux1 = .true.

                    ComputeFlux2 = .true.

                  endif

            endif

cd0:        if (ComputeFlux) then

                Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

       dok1:    do k = Kbottom, KUB

                   ! West or South Face

!cd1:                if (ComputeFaces3D_U(i-1,  j,  k) == Covered .and. &
!                        ComputeFaces3D_U(i,  j,  k) == Covered .and. &
!                        ComputeFaces3D_V(i,  j-1,k) == Covered .and. &
!                        ComputeFaces3D_V(i,  j,  k) == Covered) then


                        if (Biharmonic) then

                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else

                            ViscAux = Me%External_Var%Visc_H_Corner(i, j, k)

                        endif

!                    else cd1

!                        ViscAux = 0.

!                    endif cd1

                    NoSlipFace = .false.

                    !Test if one of the faces is not covered
                    if (.not. Me%ComputeOptions%SlippingCondition)  then

                        call DiffusionAlongNotCoveredFaces(Velocity_UV_Old,              &
                                                      ComputeFlux1,                      &
                                                      ComputeFlux2,                      &
                                                      DYY_XX, Volume_UV,                 &
                                                      FaceFlux_SouthWest1,               &
                                                      FaceFlux_SouthWest2,               &
                                                      NoSlipFace,                        &
                                                      ViscAux,                           &
                                                      i_West, j_South, i, j, k)

                    endif

cd3:                if (.not. NoSlipFace) then

cd2:                    if (ConservativeHorDif) then

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2]
                            FaceFlux_SouthWest1 = ViscAux               *           & ! Turbulent viscosity
                                            (Velocity_UV_Old(i, j, k) -             &
                                             Velocity_UV_Old(i_West, j_South, k)) / &
                                            (DYY_XX(i_West, j_South) +              &
                                             DYY_XX( i, j)) *                       & ! half of the Velocity gradient
                                            (Area_VU(iSouth, jWest, k) +            &
                                             Area_VU(i     , j    , k))               ! double of the Face Area

                            FaceFlux_SouthWest2 = FaceFlux_SouthWest1

                        else cd2


                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux = ViscAux                *                                   &  ! Turbulent viscosity
                                 (Velocity_UV_Old(i, j, k) -                                 &
                                  Velocity_UV_Old(i_West, j_South, k)) /                     &
                                 (DYY_XX(i_West, j_South) +                                  &
                                  DYY_XX( i, j)) * 2                        ! Velocity gradient

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_SouthWest1 = Aux  *                                     &
                                                  Volume_UV   (i     , j, k) /               &  ! Area
                                                  DYY_XX      (i     , j   )

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_SouthWest2 = Aux  *                                     &
                                                  Volume_UV   (i_West, j_South, k) /         &
                                                  DYY_XX      (i_West, j_South)

                        endif cd2

                    endif cd3


                    Horizontal_Transport(i, j, k)            = Horizontal_Transport(i, j, k) - &
                                                               FaceFlux_SouthWest1           * &
                                                               ComputeFaces3D_UV   (i, j, k)

                    Me%Aux3DFlux(i_West, j_South, k)         = FaceFlux_SouthWest2   * &
                                                               ComputeFaces3D_UV   (i_West, j_South, k)


                enddo dok1

            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO

        do k=KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            Horizontal_Transport(i, j, k)= Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_Diffusion_UY_VX")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Area_VU)
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (ImposedTangentialFacesUV)
        nullify (KFloor_UV)
        nullify (Volume_UV)

    End Subroutine Modify_Diffusion_UY_VX

    Subroutine Modify_Diffusion_UY_VX2 (Velocity_UV_Old, Biharmonic)

        !Arguments--------------------------------------------------------------------------

        real,    dimension(:,:,:), pointer, intent(IN)  :: Velocity_UV_Old
        logical,                            intent(IN)  :: Biharmonic
        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Area_VU
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2

        real                               :: Aux, ViscAux

        logical                            :: ConservativeHorDif, NoSlipFace,            &
                                              ComputeFlux, ComputeFlux1, ComputeFlux2, GoForOptimized

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_West, j_South

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK

        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif
        Horizontal_Transport => Me%Forces%Horizontal_Transport
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV
        Volume_UV            => Me%External_Var%Volume_UV
        Area_VU              => Me%External_Var%Area_VU
        DYY_XX               => Me%External_Var%DYY_XX
        !End - Shorten variables name

        GoForOptimized = .false.

        call SetMatrixValue( Me%Aux3DFlux, Me%Size, dble(0.))

        if ( .not. Me%ComputeOptions%ConservativeHorDif)then
            if (Me%ComputeOptions%SlippingCondition) then
                if ( .not. Me%CyclicBoundary%ON)  then
                    GoForOptimized = .true.
                endif
            endif
        endif

        if (GoForOptimized) then
            if (Me%Direction%di == 1) then
                !Compute Y direction
                call Modify_Diffusion_UY_VX_Y (Velocity_UV_Old, Me%External_Var%ComputeFaces3D_V,                  &
                                          Me%External_Var%KFloor_V, Me%External_Var%Volume_V, Me%External_Var%DXX, &
                                          Me%Forces%Horizontal_Transport, Biharmonic)
            else
                !Compute X direction
                call Modify_Diffusion_UY_VX_X (Velocity_UV_Old, Me%External_Var%ComputeFaces3D_U,                   &
                                          Me%External_Var%KFloor_U, Me%External_Var%Volume_U, Me%External_Var%DYY,  &
                                          Me%Forces%Horizontal_Transport, Biharmonic)
            endif

            call SumMatrixes(Me%Forces%Horizontal_Transport, Me%WorkSize, Me%Aux3DFlux)
        else
            !Original non-optimized routine

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "Modify_Diffusion_UY_VX")
            endif
            !$ CHUNK = CHUNK_J(JLB,JUB)
            !$OMP PARALLEL PRIVATE( i,j,k, Kbottom, &
            !$OMP                   iSouth, jWest, i_West, j_South, &
            !$OMP                   ComputeFlux, ComputeFlux1, ComputeFlux2, &
            !$OMP                   ViscAux,FaceFlux_SouthWest1,FaceFlux_SouthWest2, &
            !$OMP                   NoSlipFace, Aux)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        doi: do j=JLB, JUB
            doj: do i=ILB, IUB

                    iSouth  = i - di
                    jWest   = j - dj

                    i_West   = i - dj
                    j_South  = j - di

                    ComputeFlux  = .false.
                    ComputeFlux1 = .false.
                    ComputeFlux2 = .false.

                    if (Me%ComputeOptions%SlippingCondition) then

                        if (ComputeFaces3D_UV(i     , j      , KUB) == Covered .and.             &
                            ComputeFaces3D_UV(i_West, j_South, KUB) == Covered) ComputeFlux = .true.

                    else

                        if (ComputeFaces3D_UV        (i     , j      , KUB) == Covered .or.      &
                            ComputeFaces3D_UV        (i_West, j_South, KUB) == Covered) then

                            ComputeFlux = .true.
                            if (ComputeFaces3D_UV    (i     , j      , KUB) == Covered) ComputeFlux1 = .true.
                            if (ComputeFaces3D_UV    (i_West, j_South, KUB) == Covered) ComputeFlux2 = .true.

                        endif

                    endif

                    !When the boundary is Cyclic the momentum diffusion flux is also compute for the boundary faces
                    if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                        Me%CyclicBoundary%Direction == DirectionXY_))  then

                        if ((ComputeFaces3D_UV       (i     , j       , KUB) == Covered .and.    &
                            ImposedTangentialFacesUV(i_West, j_South , KUB) == Imposed) .or.    &
                            (ComputeFaces3D_UV       (i_West, j_South , KUB) == Covered .and.    &
                            ImposedTangentialFacesUV(i     , j       , KUB) == Imposed)) then

                            ComputeFlux = .true.

                            ComputeFlux1 = .true.

                            ComputeFlux2 = .true.

                        endif

                    endif

        cd0:        if (ComputeFlux) then

                        Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

                dok1:    do k = Kbottom, KUB

                            ! West or South Face

                            !cd1:                if (ComputeFaces3D_U(i-1,  j,  k) == Covered .and. &
                            !                        ComputeFaces3D_U(i,  j,  k) == Covered .and. &
                            !                        ComputeFaces3D_V(i,  j-1,k) == Covered .and. &
                            !                        ComputeFaces3D_V(i,  j,  k) == Covered) then


                            if (Biharmonic) then

                                ViscAux = Me%ComputeOptions%BiHarmonicCoef

                            else

                                ViscAux = Me%External_Var%Visc_H_Corner(i, j, k)

                            endif

                            NoSlipFace = .false.

                            !Test if one of the faces is not covered
                            if (.not. Me%ComputeOptions%SlippingCondition)  then

                                call DiffusionAlongNotCoveredFaces(Velocity_UV_Old,              &
                                    ComputeFlux1,                      &
                                    ComputeFlux2,                      &
                                    DYY_XX, Volume_UV,                 &
                                    FaceFlux_SouthWest1,               &
                                    FaceFlux_SouthWest2,               &
                                    NoSlipFace,                        &
                                    ViscAux,                           &
                                    i_West, j_South, i, j, k)

                            endif

        cd3:                if (.not. NoSlipFace) then

        cd2:                    if (ConservativeHorDif) then

                                    ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2]
                                    FaceFlux_SouthWest1 = ViscAux               *           & ! Turbulent viscosity
                                        (Velocity_UV_Old(i, j, k) -             &
                                        Velocity_UV_Old(i_West, j_South, k)) / &
                                        (DYY_XX(i_West, j_South) +              &
                                        DYY_XX( i, j)) *                       & ! half of the Velocity gradient
                                        (Area_VU(iSouth, jWest, k) +            &
                                        Area_VU(i     , j    , k))               ! double of the Face Area

                                    FaceFlux_SouthWest2 = FaceFlux_SouthWest1

                                else cd2


                                    ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                                    Aux = ViscAux                *                                   &  ! Turbulent viscosity
                                        (Velocity_UV_Old(i, j, k) -                                 &
                                        Velocity_UV_Old(i_West, j_South, k)) /                     &
                                        (DYY_XX(i_West, j_South) +                                  &
                                        DYY_XX( i, j)) * 2                        ! Velocity gradient

                                    ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                                    FaceFlux_SouthWest1 = Aux  *                                     &
                                        Volume_UV   (i     , j, k) /               &  ! Area
                                        DYY_XX      (i     , j   )

                                    ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                                    FaceFlux_SouthWest2 = Aux  *                                     &
                                        Volume_UV   (i_West, j_South, k) /         &
                                        DYY_XX      (i_West, j_South)

                                endif cd2

                            endif cd3


                            Horizontal_Transport(i, j, k)            = Horizontal_Transport(i, j, k) - &
                                FaceFlux_SouthWest1           * &
                                ComputeFaces3D_UV   (i, j, k)

                            Me%Aux3DFlux(i_West, j_South, k)         = FaceFlux_SouthWest2   * &
                                ComputeFaces3D_UV   (i_West, j_South, k)


                        enddo dok1

                    endif cd0

                enddo doj
            enddo doi
            !$OMP END DO

            do k=KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB
                Horizontal_Transport(i, j, k)= Horizontal_Transport(i, j, k) + Me%Aux3DFlux(i, j, k)
            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo

            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "Modify_Diffusion_UY_VX")
            endif

        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Area_VU)
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (ImposedTangentialFacesUV)
        nullify (KFloor_UV)
        nullify (Volume_UV)


    End Subroutine Modify_Diffusion_UY_VX2

    !-------------------------------------------------------------------------------------------

    subroutine Modify_Diffusion_UY_VX_Y(Velocity_V_Old, ComputeFaces3D_V, KFloor_V, Volume_V, DXX, &
        Horizontal_Transport, Biharmonic)

        !Arguments--------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer , intent(INOUT) :: Horizontal_Transport
        real,    dimension(:,:,:), pointer,  intent(IN)    :: Velocity_V_Old
        logical,                             intent(IN)    :: Biharmonic
        real(8), dimension(:,:,:), pointer , intent(IN)    :: Volume_V
        real,    dimension(:,:),   pointer , intent(IN)    :: DXX
        integer, dimension(:,:,:), pointer , intent(IN)    :: ComputeFaces3D_V
        integer, dimension(:,:),   pointer , intent(IN)    :: KFloor_V
        !Local-----------------------------------------------------------------------------
        real                               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2, Aux
        integer                            :: i, j, k, Kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                         :: CHUNK
        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !End - Shorten variables name

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, Aux, Kbottom, FaceFlux_SouthWest1, FaceFlux_SouthWest2)
        if (Biharmonic) then
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB
                if (ComputeFaces3D_V(i, j, KUB) == Covered .and. ComputeFaces3D_V(i, j-1, KUB) == Covered)  then

                    Kbottom = max(KFloor_V(i, j), KFloor_V(i, j-1))

                    do k = Kbottom, KUB
                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%ComputeOptions%BiHarmonicCoef        *                &  ! Turbulent viscosity
                              (Velocity_V_Old(i, j, k) - Velocity_V_Old(i, j-1, k)) /  &
                              (DXX(i, j-1) + DXX( i, j)) * 2                              ! Velocity gradient

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest1 = Aux * Volume_V(i , j, k) / DXX(i, j)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest2 = Aux * Volume_V (i, j-1, k) / DXX (i, j-1)

                        Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) - &
                                                        FaceFlux_SouthWest1 * ComputeFaces3D_V (i, j, k)

                        Me%Aux3DFlux(i, j-1, k) = FaceFlux_SouthWest2 * ComputeFaces3D_V (i, j-1, k)
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        else
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB
                if (ComputeFaces3D_V(i, j, KUB) == Covered .and. ComputeFaces3D_V(i, j-1, KUB) == Covered)  then

                    Kbottom = max(KFloor_V(i, j), KFloor_V(i, j-1))

                    do k = Kbottom, KUB
                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%External_Var%Visc_H_Corner(i, j, k)            *       &  ! Turbulent viscosity
                              (Velocity_V_Old(i, j, k) - Velocity_V_Old(i, j-1, k)) /   &
                              (DXX(i, j-1) + DXX( i, j)) * 2                               ! Velocity gradient

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest1 = Aux  * Volume_V(i , j, k) / DXX(i, j)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest2 = Aux * Volume_V(i, j-1, k) / DXX(i, j-1)

                        Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) - &
                                                        FaceFlux_SouthWest1 * ComputeFaces3D_V   (i, j, k)

                        Me%Aux3DFlux(i, j-1, k) = FaceFlux_SouthWest2 * ComputeFaces3D_V(i, j-1, k)
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif
        !$OMP END PARALLEL

    end subroutine Modify_Diffusion_UY_VX_Y

    !-----------------------------------------------------------------------------------------------

    subroutine Modify_Diffusion_UY_VX_X(Velocity_U_Old, ComputeFaces3D_U, KFloor_U, Volume_U, DYY, &
        Horizontal_Transport, Biharmonic)
        !Arguments--------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer , intent(INOUT) :: Horizontal_Transport
        real,    dimension(:,:,:), pointer,  intent(IN)    :: Velocity_U_Old
        logical,                             intent(IN)    :: Biharmonic
        real(8), dimension(:,:,:), pointer , intent(IN)    :: Volume_U
        real,    dimension(:,:),   pointer , intent(IN)    :: DYY
        integer, dimension(:,:,:), pointer , intent(IN)    :: ComputeFaces3D_U
        integer, dimension(:,:),   pointer , intent(IN)    :: KFloor_U
        !Local-----------------------------------------------------------------------------
        real                               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2, Aux
        integer                            :: i, j, k, Kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                         :: CHUNK
        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !End - Shorten variables name

        !$ CHUNK = CHUNK_J(JLB,JUB)

        !$OMP PARALLEL PRIVATE( i,j,k, Aux, Kbottom, FaceFlux_SouthWest1, FaceFlux_SouthWest2)
        if (Biharmonic) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB

                if (ComputeFaces3D_U(i, j, KUB) == Covered .and. ComputeFaces3D_U(i-1, j, KUB) == Covered)  then

                    Kbottom = max(KFloor_U(i, j), KFloor_U(i-1, j))

                    do k = Kbottom, KUB
                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%ComputeOptions%BiHarmonicCoef                      *  & ! Turbulent viscosity
                              (Velocity_U_Old(i, j, k) - Velocity_U_Old(i-1, j, k)) /  &
                              (DYY(i-1, j) + DYY( i, j)) * 2                             ! Velocity gradient

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest1 = Aux * Volume_U(i , j, k) / DYY(i, j)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest2 = Aux * Volume_U (i-1, j, k) / DYY (i-1, j)

                        Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) - &
                                                        FaceFlux_SouthWest1 * ComputeFaces3D_U (i, j, k)

                        Me%Aux3DFlux(i-1, j, k) = FaceFlux_SouthWest2 * ComputeFaces3D_U (i-1, j, k)
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        else
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=JLB, JUB
            do i=ILB, IUB

                if (ComputeFaces3D_U(i, j, KUB) == Covered .and. ComputeFaces3D_U(i-1, j, KUB) == Covered)  then

                    Kbottom = max(KFloor_U(i, j), KFloor_U(i-1, j))

                    do k = Kbottom, KUB

                        ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                        Aux = Me%External_Var%Visc_H_Corner(i, j, k)            *        & ! Turbulent viscosity
                                (Velocity_U_Old(i, j, k) - Velocity_U_Old(i-1, j, k)) /  &
                                (DYY(i-1, j) + DYY( i, j)) * 2                             ! Velocity gradient

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest1 = Aux  * Volume_U(i , j, k) / DYY(i, j)

                        ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                        FaceFlux_SouthWest2 = Aux * Volume_U(i-1, j, k) / DYY(i-1, j)

                        Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k) - &
                                                        FaceFlux_SouthWest1 * ComputeFaces3D_U(i, j, k)

                        Me%Aux3DFlux(i-1, j, k) = FaceFlux_SouthWest2 * ComputeFaces3D_U(i-1, j, k)
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif
        !$OMP END PARALLEL

    end subroutine Modify_Diffusion_UY_VX_X

    !-----------------------------------------------------------------------------------------------

    Subroutine DiffusionAlongNotCoveredFaces(Velocity_UV_Old, ComputeFlux1, ComputeFlux2,&
                                             DYY_XX, Volume_UV,                          &
                                             FaceFlux_SouthWest1,                        &
                                             FaceFlux_SouthWest2,                        &
                                             NoSlipFace,                                 &
                                             ViscAux,                                    &
                                             i_West, j_South, i, j, k)
            !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:),   pointer :: DYY_XX
        logical, intent(IN )               :: ComputeFlux1, ComputeFlux2
        real,    intent(OUT)               :: FaceFlux_SouthWest1, FaceFlux_SouthWest2
        logical, intent(OUT)               :: NoSlipFace

        real                               :: ViscAux

        integer                            :: i, j, k

        integer                            :: i_West, j_South

        !Begin-------------------------------------------------------------------------------


        ! i,j,k not covered face
        if (.not. ComputeFlux1) then

            FaceFlux_SouthWest1 = 0.
            ![m^3/s*m/s]         = [m2/s] * [m/s] / [m] * [m^3]/[m]
            FaceFlux_SouthWest2 = - ViscAux * Velocity_UV_Old(i_West, j_South, k) /      &
                                    DYY_XX      (i_West, j_South)    / 2.         *      &
                                    Volume_UV   (i_West, j_South, k) /                   &
                                    DYY_XX      (i_West, j_South)

            NoSlipFace = .true.

        endif

        ! i_West, j_South, k not covered face
        if (.not. ComputeFlux2) then

            ![m^3/s*m/s]         = [m2/s] * [m/s] / [m] * [m^3]/[m]
            FaceFlux_SouthWest1 =   ViscAux * Velocity_UV_Old(i, j, k)  /                &
                                    DYY_XX      (i, j) / 2. *                            &
                                    Volume_UV   (i, j, k)   /                            &
                                    DYY_XX      (i, j)
            FaceFlux_SouthWest2 = 0.

            NoSlipFace = .true.

        endif

    end Subroutine DiffusionAlongNotCoveredFaces


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion with the same direction of the     !
    !  velocity. For the U velocity compute the diffusion with the X direction             !
    !  for the V velocity compute the diffusion with the Y direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyDiffSub_UX_VY ( Velocity_UV_Old, Biharmonic)


        !Variables category
        ! Geometry : Volume_Z, DUX_VY (Volume and length of the elevation control volume)
        ! Flow     : Visc_H_Center (Turbulent viscosity in the center of the elevation control volume),
        !            Velocity_UV_Old (U or V velocity)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Direction: Direction (DirectionX=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables direction dependent:
        ! Horizontal_Transport, DUX_VY, Velocity_UV_Old, ComputeFaces3D_UV, Direction, Kfloor_UV


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        logical, intent (IN)               :: Biharmonic

        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_New, Volume_UV
        real,    dimension(:,:,:), pointer :: Visc_H_Center
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        logical                            :: ConservativeHorDif

        real                               :: FaceFlux_WestSouth, FaceFlux_EastNorth, Aux, ViscAux

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif

        Visc_H_Center        => Me%External_Var%Visc_H_Center

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ComputeFaces3D_UV      => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV              => Me%External_Var%KFloor_UV
        ImposedNormalFacesUV   => Me%External_Var%ImposedNormalFacesUV

        Volume_Z_New         => Me%External_Var%Volume_Z_New
        DUX_VY               => Me%External_Var%DUX_VY

        DZX_ZY               => Me%External_Var%DZX_ZY
        Volume_UV            => Me%External_Var%Volume_UV

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyDiffSub_UX_VY")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_North,j_East,Kbottom) &
        !$OMP PRIVATE(ViscAux,FaceFlux_WestSouth,Aux,FaceFlux_EastNorth)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB


            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj


cd0:        if (ComputeFaces3D_UV(i, j, KUB)  == Covered) then


cd1:            if (ImposedNormalFacesUV(iSouth, jWest, KUB) == Imposed) then

                    Kbottom = KFloor_UV(i, j)

dok1:               do k = Kbottom, KUB

cd2:                    if (BiHarmonic) then

                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else  cd2

                            ViscAux = Visc_H_Center( iSouth, jWest, k)

                        endif cd2


cd3:                    if (ConservativeHorDif) then

                            ! West or South Face

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                            FaceFlux_WestSouth  = ViscAux                            *   & ! Turbulent viscosity
                                                 (Velocity_UV_Old( i, j, k) -            &
                                                 Velocity_UV_Old( iSouth, jWest, k)) / &
                                                 DUX_VY( iSouth, jWest) *              & ! Velocity gradient
                                                 Volume_Z_New( iSouth, jWest, k) /     &
                                                 DUX_VY( iSouth, jWest)                    ! Face Area


                        else cd3

                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux                 = ViscAux                           *    & ! Turbulent viscosity
                                                (Velocity_UV_Old( i, j, k) -             &
                                                Velocity_UV_Old( iSouth, jWest, k)) /  &
                                                DUX_VY( iSouth, jWest)                       ! Velocity gradient

                            !The velocity gradient plus the volume divided by the distance between
                            !volume faces is equal to compute in a non-conservative way the lapalcian of the
                            !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity
                            !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                            !

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_WestSouth  = Aux * Volume_UV(i      , j     , k) /  &
                                                        DZX_ZY   (iSouth, jWest)

                        endif cd3

                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)   &
                                                       - FaceFlux_WestSouth
                    enddo dok1

                endif cd1



cd4:            if (ImposedNormalFacesUV(i_North, j_East, KUB) == Imposed) then

                    Kbottom = KFloor_UV(i, j)

dok2:               do k = Kbottom, KUB


cd5:                    if (BiHarmonic) then

                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else cd5

                            ViscAux = Visc_H_Center(i, j, k)

                        endif cd5


cd6:                    if (ConservativeHorDif) then

                            ! West or South Face

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m] * [m^3] / [m]
                            FaceFlux_EastNorth  = ViscAux                             *  & ! Turbulent viscosity
                                                 (Velocity_UV_Old(i_North, j_East, k) -  &
                                                 Velocity_UV_Old( i      , j     , k))/  &
                                                 DUX_VY( i, j)                        *  & ! Velocity gradient
                                                 Volume_Z_New( i, j, k) /  DUX_VY( i, j)   ! Face Area


                        else cd6

                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux                 = ViscAux                            *   & ! Turbulent viscosity
                                                 (Velocity_UV_Old(i_North, j_East, k)-   &
                                                  Velocity_UV_Old( i, j, k))         /   & ! Velocity gradient
                                                  DUX_VY(  i, j)

                            !The velocity gradient plus the volume divided by the distance between
                            !volume faces is equal to compute in a non-conservative way the lapalcian of the
                            !velocity plus viscosity. The effect of the variable horizontal_transport in the velocity
                            !is compute dividing the variable horizontal_Transport/VolumeU*DT = Visc * Laplacian(Velocity)
                            !

                            ![m^3/s*m/s]        = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_EastNorth  = Aux * Volume_UV(i      , j     , k) /  &
                                                        DZX_ZY   (iSouth, jWest)

                        endif cd6


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)   &
                                                       + FaceFlux_EastNorth

                    enddo dok2

                 endif cd4


             endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyDiffSub_UX_VY")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_Z_New        )
        nullify (Visc_H_Center       )
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (ImposedNormalFacesUV)
        nullify (KFloor_UV           )
        nullify (Volume_UV           )


    End Subroutine ModifyDiffSub_UX_VY


        !End ----------------------------------------------------------------------

    Subroutine ModifyDiffSub_UY_VX ( Velocity_UV_Old, Biharmonic)


        !Arguments--------------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old
        logical, intent (IN)               :: Biharmonic


        !Local-----------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_UV
        real,    dimension(:,:,:), pointer :: Area_VU
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:,:), pointer :: ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: FaceFlux_SouthWest, FaceFlux_NorthEast

        real                               :: Aux, ViscAux

        logical                            :: ConservativeHorDif

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_West, j_South

        integer                            :: i_North, j_East, i_East, j_North

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ConservativeHorDif   =  Me%ComputeOptions%ConservativeHorDif

        Horizontal_Transport => Me%Forces%Horizontal_Transport

        ComputeFaces3D_U         => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V         => Me%External_Var%ComputeFaces3D_V
        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV                => Me%External_Var%KFloor_UV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        Volume_UV            => Me%External_Var%Volume_UV
        Area_VU              => Me%External_Var%Area_VU
        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyDiffSub_UY_VX")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_West,j_South,i_North) &
        !$OMP PRIVATE(j_East,i_East,j_North,Kbottom,ViscAux,FaceFlux_SouthWest) &
        !$OMP PRIVATE(Aux,FaceFlux_NorthEast)

        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth  = i - di
            jWest   = j - dj

            i_West   = i - dj
            j_South  = j - di

            i_North  = i + di
            j_East   = j + dj

            i_East   = i + dj
            j_North  = j + di


cd0:        if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

cd1:            if (ImposedTangentialFacesUV(i_West, j_South, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_West, j_South))

           dok1:    do k = Kbottom, KUB


                       ! West or South Face


cd2:                    if (BiHarmonic) then

                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else cd2

                            ViscAux = Me%External_Var%Visc_H_Corner(i, j, k)

                        endif cd2


cd3:                    if (ConservativeHorDif) then

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2]
                            FaceFlux_SouthWest = ViscAux               *                 & ! Turbulent viscosity
                                            (Velocity_UV_Old(i, j, k) -                  &
                                             Velocity_UV_Old(i_West, j_South, k)) /      &
                                            (DYY_XX(i_West, j_South) +                   &
                                             DYY_XX( i, j)) *                            & ! half of the Velocity gradient
                                            (Area_VU(iSouth, jWest, k) +               &
                                             Area_VU(i      , j     , k))             ! double of the Face Area


                        else cd3


                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux = ViscAux                *                               &  ! Turbulent viscosity
                                 (Velocity_UV_Old(i, j, k) -                             &
                                  Velocity_UV_Old(i_West, j_South, k)) /                 &
                                 (DYY_XX(i_West, j_South) +                              &
                                  DYY_XX( i, j)) * 2                        ! Velocity gradient

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_SouthWest  = Aux  *                                 &
                                                  Volume_UV   (i     , j, k) /           &  ! Area
                                                  DYY_XX      (i     , j   )

                        endif cd3


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)   &
                                                       - FaceFlux_SouthWest

                    enddo dok1

                endif cd1


cd4:            if (ImposedTangentialFacesUV(i_East, j_North, KUB) == Imposed) then

                    Kbottom = max(KFloor_UV(i, j), KFloor_UV(i_East, j_North))

           dok2:    do k = Kbottom, KUB


                       ! East or North Face


cd5:                    if (BiHarmonic) then

                            ViscAux = Me%ComputeOptions%BiHarmonicCoef

                        else cd5

                            ViscAux = Me%External_Var%Visc_H_Corner(i_East, j_North, k)

                        endif cd5


cd6:                    if (ConservativeHorDif) then

                            ![m^3/s*m/s]       = [m^2/s] * [m/s] / [m]  * [m^2]
                            FaceFlux_NorthEast = ViscAux               *            & ! Turbulent viscosity
                                            (Velocity_UV_Old(i_East, j_North, k) -             &
                                             Velocity_UV_Old(i, j, k)) / &
                                            (DYY_XX(i_East, j_North) +              &
                                             DYY_XX( i, j)) *                       & ! half of the Velocity gradient
                                            (Area_VU(i_East     , j_North    , k) + &
                                             Area_VU(i - di + dj, j - dj + di, k))                        ! double of the Face Area


                        else cd6


                            ![m^2/s^2] = [m^2/s] * [m/s] / [m]
                            Aux = ViscAux                *                                   &  ! Turbulent viscosity
                                 (Velocity_UV_Old(i_East, j_North, k) -                                 &
                                  Velocity_UV_Old(i     , j      , k)) /                     &
                                 (DYY_XX(i_East, j_North) +                                  &
                                  DYY_XX( i, j)) * 2                        ! Velocity gradient

                            ![m^3/s*m/s]         = [m^2/s^2] * [m^3]/[m]
                            FaceFlux_NorthEast  = Aux  *                                     &
                                                  Volume_UV   (i     , j, k) /               &  ! Area
                                                  DYY_XX      (i     , j   )

                        endif cd6


                        Horizontal_Transport(i, j, k)  = Horizontal_Transport(i, j, k)       &
                                                       + FaceFlux_NorthEast

                    enddo dok2

                endif cd4


            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyDiffSub_UY_VX")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Area_VU)
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (ComputeFaces3D_U)
        nullify (ComputeFaces3D_V)
        nullify (KFloor_UV)
        nullify (ImposedTangentialFacesUV)
        nullify (Volume_UV)


    End Subroutine ModifyDiffSub_UY_VX

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the Laplacian                                               !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine LaplacianXY( Velocity_UV_Old, Aux_UX_VY)


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Aux_UX_VY

        !Local-----------------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: DUX_VY, DZX_ZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: Aux1, Aux2

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: iSouth, jWest, i_North, j_East

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-----------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV             => Me%External_Var%KFloor_UV

        DUX_VY               => Me%External_Var%DUX_VY

        DZX_ZY               => Me%External_Var%DZX_ZY

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "LaplacianXY")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,i_North,j_East,Kbottom) &
        !$OMP PRIVATE(Aux1,Aux2)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB


            iSouth  = i -   di
            jWest   = j -   dj
            i_North  = i +   di
            j_East   = j +   dj


cd0:        if (ComputeFaces3D_UV(i, j, KUB)            == Covered ) then

                Kbottom = KFloor_UV(i, j)

dok1:           do k = Kbottom, KUB


                    ! West or South Face
                    if (ComputeFaces3D_UV(iSouth, jWest, k) == Covered ) then
                        ![s^-1] = [m/s] / [m]
                        Aux1 =(Velocity_UV_Old( i      , j     , k) -                        &
                               Velocity_UV_Old( iSouth, jWest, k)) /                       &
                               DUX_VY( iSouth, jWest)
                    else

                        Aux1 = 0

                    endif


                    ! East or North Face
                    if (ComputeFaces3D_UV(i_North, j_East, k) == Covered ) then

                        Aux2 =(Velocity_UV_Old( i_North, j_East, k) -                    &
                               Velocity_UV_Old( i      , j     , k)) /                   &
                               DUX_VY( i, j)

                    else

                        Aux2 = 0.

                    endif

                    Aux_UX_VY(i, j, k) = - (Aux2 - Aux1) / DZX_ZY( iSouth, jWest)

                 enddo dok1

             endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "LaplacianXY")
        endif

        !Nullify auxiliar pointers
        nullify (DUX_VY              )
        nullify (DZX_ZY              )
        nullify (ComputeFaces3D_UV   )
        nullify (KFloor_UV           )


    End Subroutine LaplacianXY


        !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the horizontal diffusion perpendicular to the               !
    !  velocity. For the U velocity compute the diffusion with the Y direction             !
    !  for the V velocity compute the diffusion with the X direction                       !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine LaplacianYX ( Velocity_UV_Old, Aux_UY_VX)


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Aux_UY_VX


        !Local-----------------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: Aux1, Aux2

        integer                            :: di, dj, i, j, k, Kbottom

        integer                            :: i_West, j_South, i_East, j_North

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin-------------------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        DYY_XX               => Me%External_Var%DYY_XX

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "LaplacianYX")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,i_West,i_East,j_South,j_North,Kbottom) &
        !$OMP PRIVATE(Aux1,Aux2)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            i_West   = i - dj
            i_East   = i + dj

            j_South  = j - di
            j_North  = j + di

cd0:        if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)


       dok1:        do k = Kbottom, KUB


                        ! West or South Face
                        if (ComputeFaces3D_UV(i_West, j_South, k) == Covered) then

                            ![s^-1] = [m/s] / [m]
                            Aux1 =(Velocity_UV_Old( i      , j     , k) -                &
                                   Velocity_UV_Old( i_West , j_South, k))* 2 /           &
                                   (DYY_XX(i_West, j_South) +  DYY_XX( i, j))

                        else

                            Aux1 = 0.

                        endif

                        ! East or North Face
                        if (ComputeFaces3D_UV(i_East, j_North, k) == Covered) then

                            Aux2 =(Velocity_UV_Old( i_East, j_North, k) -                &
                                   Velocity_UV_Old( i      , j     , k)) * 2 /           &
                                   (DYY_XX(i_East, j_North) +  DYY_XX( i, j))

                        else

                            Aux2 = 0

                        endif

                        Aux_UY_VX(i, j, k) = - (Aux2 - Aux1) / DYY_XX( i, j)


                    enddo dok1


            endif cd0

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "LaplacianYX")
        endif

        !Nullify auxiliar pointers
        nullify (DYY_XX)
        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)


    End Subroutine LaplacianYX


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of volume variation in the velocity time         !
    !  variation.                                                                          !
    !                                                                                      !
    ! Input : Flow, Mapping,                                                               !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyVolumeVariation


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport, Volume_Z_Old, Volume_UV
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8)                            :: VolumeVariation, VolumeUVOld

        real                               :: DT_Velocity

        integer                            :: i, j, k, Kbottom, di, dj, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity = Me%Velocity%DT

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_Z_Old         => Me%External_Var%Volume_Z_Old
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyVolumeVariation")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,Kbottom,VolumeUVOld) &
        !$OMP PRIVATE(VolumeVariation)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

    cd1:    if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth  = i - di
                jWest   = j - dj

                Kbottom = KFloor_UV(i, j)

        dok1:   do k = Kbottom, KUB

                    VolumeUVOld                   = (Volume_Z_Old(iSouth, jWest, k)  + &
                                                     Volume_Z_Old(i, j, k) ) / 2.

                    ![m/s*m^3/s]                  = [m^3] * [m/s] / [s]
                    VolumeVariation               = (VolumeUVOld - Volume_UV(i, j, k)) * &
                                                    dble(Velocity_UV_Old(i, j, k))     / &
                                                    dble(DT_Velocity)

                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k)      + &
                                                    VolumeVariation

                enddo dok1

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyVolumeVariation")
        endif

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (Volume_UV)
        nullify (Volume_Z_Old)
        nullify (Velocity_UV_Old)
        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)

    End Subroutine ModifyVolumeVariation


    !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of momentum discharges in the velocity time      !
    !  variation.                                                                          !
    !                                                                                      !
    ! Input : Flow, Mapping,                                                               !
    ! OutPut: Horizontal_Transport                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyMomentumDischarge

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, DUZ_VZ
        real,    dimension(:,:  ), pointer :: Bathymetry, WaterColumnUV
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:  ), pointer :: KFloor_UV
        real,    dimension(:    ), pointer :: DistributionCoef
        real(8)                            :: MomentumDischarge
        real                               :: DischargeFlow, DischargeVelocity, AuxFlowK, AuxFlowIJ, SectionHeight
        real                               :: WaterLevelByPass !, Depth
        real                               :: CoordinateX, CoordinateY, XBypass, YBypass
        integer                            :: DirectionXY, DischargesNumber, DischargeID
        integer                            :: i, j, k, kd, kmin, kmax, di, dj, STAT_CALL, iNorth, jEast, KUB, n
        integer                            :: ib, jb !, kbottom, k1
        integer                            :: FlowDistribution, nCells, SpatialEmission
        integer, dimension(:    ), pointer :: VectorI, VectorJ, VectorK
        logical                            :: ByPassON, IgnoreOK, CoordinatesON
        integer                            :: DischVertical
        real                               :: InterceptionRatio

        integer                            :: CHUNK
        logical                            :: UpscalingDischarge

        !Begin----------------------------------------------------------------

        !Begin - Shorten variables name

        DirectionXY = Me%Direction%XY
        KUB         = Me%WorkSize%KUB

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        KFloor_UV            => Me%External_Var%KFloor_UV
        WaterColumnUV        => Me%External_Var%WaterColumnUV
        DUZ_VZ               => Me%External_Var%DUZ_VZ

        !End - Shorten variables name

        UpscalingDischarge  = .false.

        call GetDischargesNumber(Me%ObjDischarges, DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL/=SUCCESS_)stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR10'

        !Gets a pointer to Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR20'

do1:    do DischargeID = 1, DischargesNumber

            call GetDischargeON(Me%ObjDischarges,DischargeID, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR25'

            if (IgnoreOK) cycle

            call GetDischargesGridLocalization(Me%ObjDischarges,                        &
                                               DischargeID,                             &
                                               Igrid         = I,                       &
                                               JGrid         = J,                       &
                                               KGrid         = kd,                      &
                                               IByPass       = Ib,                      &
                                               JByPass       = Jb,                      &
                                               DischVertical = DischVertical,           &
                                               WaterColumnZ  = Me%External_Var%Watercolumn,&
                                               Bathymetry    = Bathymetry,              &
                                               OpenPoints3D  = Me%External_Var%OpenPoints3D,&
                                               CoordinateX   = CoordinateX,             &
                                               CoordinateY   = CoordinateY,             &
                                               CoordinatesON = CoordinatesON,           &
                                               TimeX         = Me%CurrentTime,          &
                                               XBypass       = XBypass,                 &
                                               YBypass       = YBypass,                 &
                                               STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR30'

            !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
            call GetByPassON(Me%ObjDischarges, DischargeID, ByPassON, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR50'

            if (CoordinatesON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR40'

                call CorrectsCellsDischarges(Me%ObjDischarges, DischargeID, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR45'

                if (ByPassON) then

                    call GetXYCellZ(Me%ObjHorizontalGrid, XBypass, YBypass, Ib, Jb, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR400'

                    call CorrectsBypassCellsDischarges(Me%ObjDischarges, DischargeID, Ib, Jb, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR450'

                endif

            endif

            if (ByPassON) then
                WaterLevelByPass = Me%WaterLevel%Old(ib, jb)
            else
                WaterLevelByPass = FillValueReal
            endif

            UpscalingDischarge = IsUpscaling(Me%ObjDischarges, DischargesNumber)

            if (UpscalingDischarge )then

                !do nothing... this is not prepared for momentum discharge

            else

                call GetDischargeWaterFlow(Me%ObjDischarges,                    &
                                           Me%CurrentTime, DischargeID,         &
                                           Me%WaterLevel%Old(I, J),             &
                                           DischargeFlow,                       &
                                           SurfaceElevation2 = WaterLevelByPass,&
                                           STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR60'

                if (DirectionXY == DirectionX_) then

                    call GetDischargeFlowVelocity(Me%ObjDischarges,                       &
                                                    Me%CurrentTime, DischargeID,            &
                                                    VelocityU = DischargeVelocity,          &
                                                    STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR70'

                else if (DirectionXY == DirectionY_) then

                    call GetDischargeFlowVelocity(Me%ObjDischarges,                       &
                                                    Me%CurrentTime, DischargeID,            &
                                                    VelocityV = DischargeVelocity,          &
                                                    STAT = STAT_CALL)
                    if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR80'
                endif

                di  = Me%Direction%di
                dj  = Me%Direction%dj


                call GetDischargeFlowDistribuiton(Me%ObjDischarges, DischargeID, nCells, FlowDistribution, &
                                                    VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)

                if (STAT_CALL/=SUCCESS_)                                                     &
                    stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR90'


i1:         if (nCells > 1) then
                    allocate(DistributionCoef(1:nCells))

i2:                 if      (FlowDistribution == DischByCell_       ) then

                        call GetDischargeSpatialType (Me%ObjDischarges, DischargeID, SpatialEmission, STAT = STAT_CALL)

                        if (STAT_CALL/=SUCCESS_) then
                            stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR100'
                        endif

                        call GetDischargeInterceptionRatio(Me%ObjDischarges, DischargeID, InterceptionRatio,  &
                                                            STAT = STAT_CALL)
                        if (STAT_CALL/=SUCCESS_) then
                            stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR105'
                        endif


                        call DischargeDistributionPerCell (VectorI          = VectorI,      &
                                                            VectorJ          = VectorJ,      &
                                                            nCells           = nCells,       &
                                                            SpatialEmission  = SpatialEmission,&
                                                            Mapping          = Me%External_Var%ComputeFaces3D_UV,&
                                                            Property         = MomentumHorizontal_, &
                                                            InterceptionRatio= InterceptionRatio, &
                                                            DistributionCoef = DistributionCoef)


                    else  i2

                        stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR110'

                    endif i2

                endif i1

                AuxFlowIJ = DischargeFlow

                CHUNK = CHUNK_K(kmin,kmax)

                if (MonitorPerformance) then
                    call StartWatch ("ModuleHydrodynamic", "ModifyMomentumDischarge")
                endif


                if (Me%OutPut%TimeSerieDischON) then
                    if (dj==1) then
                        Me%OutPut%TimeSerieDischProp(DischargeID,2) = 0.
                    else
                        Me%OutPut%TimeSerieDischProp(DischargeID,3) = 0.
                    endif
                endif


                !$OMP PARALLEL PRIVATE(k,AuxFlowK,MomentumDischarge,SectionHeight)

dn:             do n=1, nCells
                    !$OMP MASTER
                    if (nCells > 1) then
                        i         = VectorI(n)
                        j         = VectorJ(n)
                        kd        = VectorK(n)

                        call GetDischargeWaterFlow(Me%ObjDischarges,                        &
                                                   Me%CurrentTime, DischargeID,             &
                                                   Me%WaterLevel%Old(I, J),                 &
                                                   AuxFlowIJ,                               &
                                                   SurfaceElevation2 = WaterLevelByPass,    &
                                                   FlowDistribution  = DistributionCoef(n), &
                                                   STAT              = STAT_CALL)

                        if (STAT_CALL/=SUCCESS_)                                            &
                            stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR120'

                    endif

                    iNorth = i+di
                    jEast =  j+dj

                    if (DischVertical == DischUniform_) then

                        if (kmin == FillValueInt) then
                            if      (ComputeFaces3D_UV(i     , j    , KUB) == Covered) then
                                kmin = KFloor_UV(i     , j    )
                            else if (ComputeFaces3D_UV(iNorth, jEast, KUB) == Covered) then
                                kmin = KFloor_UV(iNorth, jEast)
                            else
                                kmin  = KUB
                            endif
                        endif

                        if (kmax == FillValueInt) kmax = KUB

                        SectionHeight = 0
                        if      (ComputeFaces3D_UV(i     , j    , KUB) == Covered) then
                            do k=kmin, kmax
                                SectionHeight = SectionHeight + DUZ_VZ(i,j,k)
                            enddo
                        else if (ComputeFaces3D_UV(iNorth, jEast, KUB) == Covered) then
                            do k=kmin, kmax
                                SectionHeight = SectionHeight + DUZ_VZ(iNorth, jEast,k)
                            enddo
                        endif
                    else

                        kmin = kd; kmax = kd

                    endif

                    MomentumDischarge = 0.
                    !$OMP END MASTER
                    !$OMP BARRIER

                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    dk:             do k = kmin,kmax

                        AuxFlowK = AuxFlowIJ

                        if (ComputeFaces3D_UV(i, j, k) == Covered) then

                            if (DischVertical == DischUniform_) AuxFlowK = DUZ_VZ(i,j,k) / SectionHeight * AuxFlowIJ

                            ![m/s*m^3/s]                  = [m^3] * [m/s] / [s]
                            if (AuxFlowK >= 0.) then

                                MomentumDischarge  = AuxFlowK * DischargeVelocity

                                Me%WaterFluxes%DischargesVelUV(iNorth, jEast, k) = DischargeVelocity

                            else

                                MomentumDischarge  = AuxFlowK * Velocity_UV_Old(i, j, k)

                                Me%WaterFluxes%DischargesVelUV(iNorth, jEast, k) = Velocity_UV_Old(i, j, k)

                            endif


                            Horizontal_Transport(i     , j    , k) =                                 &
                                Horizontal_Transport(i     , j    , k)   +   MomentumDischarge

                        else if (ComputeFaces3D_UV(iNorth, jEast, k) == Covered) then

                            if (DischVertical == DischUniform_)                                      &
                                        AuxFlowK = DUZ_VZ(iNorth, jEast,k) / SectionHeight * AuxFlowIJ

                            ![m/s*m^3/s]                  = [m^3] * [m/s] / [s]
                            if (AuxFlowK >= 0.) then

                                MomentumDischarge  = AuxFlowK * DischargeVelocity

                                Me%WaterFluxes%DischargesVelUV(i, j, k) = DischargeVelocity

                            else

                                MomentumDischarge  = AuxFlowK * Velocity_UV_Old(iNorth, jEast, k)

                                Me%WaterFluxes%DischargesVelUV(i, j, k) = Velocity_UV_Old(iNorth, jEast, k)

                            endif

                            Horizontal_Transport(iNorth, jEast, k) =                                 &
                                Horizontal_Transport(iNorth, jEast, k)   +   MomentumDischarge


                        else if (abs(MomentumDischarge) > AllmostZero) then
                            !!! $OMP CRITICAL (MMD1_WARN01)
                            write(*,*) 'WARNING_ - The Model is trying to discharge Momentum in a No Compute Face'
                            write(*,*) 'WARNING_ - ModifyMomentumDischarge - ModuleHydrodynamic - WARN01'
                            !!! $OMP END CRITICAL (MMD1_WARN01)
                        endif

                        if (Me%OutPut%TimeSerieDischON) then
                            if (dj==1) then
                                Me%OutPut%TimeSerieDischProp(DischargeID,2) = Me%OutPut%TimeSerieDischProp(DischargeID,2) + &
                                                                              MomentumDischarge
                            else
                                Me%OutPut%TimeSerieDischProp(DischargeID,3) = Me%OutPut%TimeSerieDischProp(DischargeID,3) + &
                                                                              MomentumDischarge
                            endif
                        endif

                    enddo dk
                    !$OMP END DO

                enddo dn
                !$OMP END PARALLEL

                if (MonitorPerformance) then
                    call StopWatch ("ModuleHydrodynamic", "ModifyMomentumDischarge")
                endif

                if (Me%OutPut%TimeSerieDischON) then
                    if (dj==1) then
                        if (Me%OutPut%TimeSerieDischProp(DischargeID,1) /=0) then
                            Me%OutPut%TimeSerieDischProp(DischargeID,2) = Me%OutPut%TimeSerieDischProp(DischargeID,2)/ &
                                                                          Me%OutPut%TimeSerieDischProp(DischargeID,1)
                        else
                            Me%OutPut%TimeSerieDischProp(DischargeID,2) = 0.
                        endif
                    else
                       if (Me%OutPut%TimeSerieDischProp(DischargeID,1) /=0) then
                            Me%OutPut%TimeSerieDischProp(DischargeID,3) = Me%OutPut%TimeSerieDischProp(DischargeID,3)/ &
                                                                          Me%OutPut%TimeSerieDischProp(DischargeID,1)
                        else
                            Me%OutPut%TimeSerieDischProp(DischargeID,3) = 0.
                        endif
                    endif
                endif

                if (nCells>1) deallocate(DistributionCoef)

                call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR130'

                call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR140'

                call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyMomentumDischarge - ModuleHydrodynamic - ERR150'
            endif

    enddo do1

        !Nullify auxiliar pointers
        nullify (Horizontal_Transport)
        nullify (ComputeFaces3D_UV   )
        nullify (Velocity_UV_Old     )
        nullify (KFloor_UV           )
        nullify (WaterColumnUV       )
        nullify (DUZ_VZ              )

        !Disposes pointer to the Bathymetry
        call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischarge - ModuleHydrodynamic - ERR160'


    End Subroutine ModifyMomentumDischarge

    !End -------------------------------------------------------------------------

    Subroutine ModifyMomentumDischargeVert


        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Velocity_W, DWZ
        real,    dimension(:,:  ), pointer :: Bathymetry, WaterColumnZ
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_W
        integer, dimension(:,:  ), pointer :: KFloor_Z
        real,    dimension(:    ), pointer :: DistributionCoef
        real(8)                            :: MomentumDischarge
        real                               :: DischargeFlow, DischargeVelocity, AuxFlowK, AuxFlowIJ, SectionHeight
        real                               :: WaterLevelByPass, CoordinateX, CoordinateY
        real                               :: XBypass, YBypass

        integer                            :: DischargesNumber, DischargeID
        integer                            :: i, j, k, kd, kmin, kmax, STAT_CALL, KUB, n
        integer                            :: ib, jb !, kbottom, k1

        integer                            :: FlowDistribution, nCells, SpatialEmission
        integer, dimension(:    ), pointer :: VectorI, VectorJ, VectorK

        logical                            :: ByPassON, IgnoreOK, CoordinatesON

        real                               :: InterceptionRatio

        integer                            :: DischVertical

        !Begin----------------------------------------------------------------


        !Begin - Shorten variables name

        KUB         = Me%WorkSize%KUB

        ComputeFaces3D_W     => Me%External_Var%ComputeFaces3D_W
        Velocity_W           => Me%Velocity%Vertical%Cartesian
        KFloor_Z             => Me%External_Var%KFloor_Z
        WaterColumnZ         => Me%External_Var%WaterColumn
        DWZ                  => Me%External_Var%DWZ

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyMomentumDischargeVert")
        endif


        !End - Shorten variables name
        call GetDischargesNumber(Me%ObjDischarges, DischargesNumber, STAT = STAT_CALL)
        if (STAT_CALL/=SUCCESS_)stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR10'


        !Gets a pointer to Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR20'

do1:    do DischargeID = 1, DischargesNumber

            call GetDischargeON(Me%ObjDischarges,DischargeID, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR25'

            if (IgnoreOK) cycle

            call GetDischargesGridLocalization(Me%ObjDischarges,                        &
                                               DischargeID,                             &
                                               Igrid         = I,                       &
                                               JGrid         = J,                       &
                                               KGrid         = kd,                      &
                                               IByPass       = Ib,                      &
                                               JByPass       = Jb,                      &
                                               DischVertical = DischVertical,           &
                                               WaterColumnZ  = WaterColumnZ,            &
                                               Bathymetry    = Bathymetry,              &
                                               OpenPoints3D  = Me%External_Var%OpenPoints3D,&
                                               CoordinateX   = CoordinateX,             &
                                               CoordinateY   = CoordinateY,             &
                                               CoordinatesON = CoordinatesON,           &
                                               TimeX         = Me%CurrentTime,          &
                                               XBypass       = XBypass,                 &
                                               YBypass       = YBypass,                 &
                                               STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR30'

            !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
            call GetByPassON(Me%ObjDischarges, DischargeID, ByPassON, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR50'

            if (CoordinatesON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR40'

                call CorrectsCellsDischarges(Me%ObjDischarges, DischargeID, I, J, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR45'

                if (ByPassON) then

                    call GetXYCellZ(Me%ObjHorizontalGrid, XBypass, YBypass, Ib, Jb, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR400'

                    call CorrectsBypassCellsDischarges(Me%ObjDischarges, DischargeID, Ib, Jb, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR450'

                endif

            endif

            if (ByPassON) then
                WaterLevelByPass = Me%WaterLevel%Old(ib, jb)
            else
                WaterLevelByPass = FillValueReal
            endif

            call GetDischargeWaterFlow(Me%ObjDischarges,                    &
                                       Me%CurrentTime, DischargeID,         &
                                       Me%WaterLevel%Old(I, J),             &
                                       DischargeFlow,                       &
                                       SurfaceElevation2 = WaterLevelByPass,&
                                       STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR60'



            call GetDischargeFlowVelocity(Me%ObjDischarges,                 &
                                       Me%CurrentTime, DischargeID,         &
                                       VelocityW = DischargeVelocity, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR70'



            call GetDischargeFlowDistribuiton(Me%ObjDischarges, DischargeID, nCells, FlowDistribution, &
                                              VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)

            if (STAT_CALL/=SUCCESS_) then
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR80'
            endif

i1:         if (nCells > 1) then
                allocate(DistributionCoef(1:nCells))


i2:             if      (FlowDistribution == DischByCell_       ) then

                    call GetDischargeSpatialType (Me%ObjDischarges, DischargeID,    &
                                                  SpatialEmission, STAT = STAT_CALL)

                    if (STAT_CALL/=SUCCESS_) then
                        stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR90'
                    endif

                    call GetDischargeInterceptionRatio(Me%ObjDischarges, DischargeID, InterceptionRatio,     &
                                                       STAT = STAT_CALL)
                    if (STAT_CALL/=SUCCESS_) then
                        stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR105'
                    endif


                    call DischargeDistributionPerCell (VectorI          = VectorI,  &
                                                       VectorJ          = VectorJ,  &
                                                       nCells           = nCells,   &
                                                       SpatialEmission  = SpatialEmission,&
                                                       Mapping          = Me%External_Var%ComputeFaces3D_W,&
                                                       Property         = MomentumVertical_, &
                                                       InterceptionRatio= InterceptionRatio, &
                                                       DistributionCoef = DistributionCoef)

                else i2

                    stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR100'

                endif i2
            endif i1

            if (DischargeFlow > 0.) then
                AuxFlowIJ = DischargeFlow
            else
                AuxFlowIJ = 0.
            endif

            if (Me%OutPut%TimeSerieDischON) then
                Me%OutPut%TimeSerieDischProp(DischargeID,4) = 0.
            endif

dn:         do n=1, nCells

                if (nCells > 1) then
                    i         = VectorI(n)
                    j         = VectorJ(n)
                    kd        = VectorK(n)

                    call GetDischargeWaterFlow(Me%ObjDischarges,                        &
                                               Me%CurrentTime, DischargeID,             &
                                               Me%WaterLevel%Old(I, J),                 &
                                               AuxFlowIJ,                               &
                                               SurfaceElevation2 = WaterLevelByPass,    &
                                               FlowDistribution  = DistributionCoef(n), &
                                               STAT              = STAT_CALL)

                    if (STAT_CALL/=SUCCESS_)                                            &
                        stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR110'

                endif

                if (DischVertical == DischUniform_) then

                    if (kmin == FillValueInt) kmin = KFloor_Z(i, j)

                    if (kmax == FillValueInt) kmax = KUB

                    SectionHeight = 0

                    do k=kmin, kmax
                        SectionHeight = SectionHeight + DWZ(i,j,k)
                    enddo

                else

                    kmin = kd; kmax = kd

                endif

                MomentumDischarge = 0.

dk:             do k = kmin,kmax

                    AuxFlowK = AuxFlowIJ

                    if (ComputeFaces3D_W(i, j, k) == Covered) then

                        if (DischVertical == DischUniform_) AuxFlowK = DWZ(i,j,k) / SectionHeight * AuxFlowIJ

                        ![m/s*m^3/s]                  = [m^3] * [m/s] / [s]
                        MomentumDischarge  = AuxFlowK * DischargeVelocity

                        !Me%WaterFluxes%DischargesVelUV(i, j, k) = DischargeVelocity

                        Me%Coef%D3%Ti (i, j, k) = Me%Coef%D3%Ti (i, j, k) + MomentumDischarge

                    else if (ComputeFaces3D_W(i, j, k+1) == Covered) then

                        if (DischVertical == DischUniform_) AuxFlowK = DWZ(i,j,k) / SectionHeight * AuxFlowIJ

                        ![m/s*m^3/s]                  = [m^3] * [m/s] / [s]
                        MomentumDischarge  = AuxFlowK * DischargeVelocity

                        !Me%WaterFluxes%DischargesVelUV(i, j, k) = DischargeVelocity

                        Me%Coef%D3%Ti (i, j, k+1) = Me%Coef%D3%Ti (i, j, k+1) + MomentumDischarge

                    endif

                    if (Me%OutPut%TimeSerieDischON) then
                        Me%OutPut%TimeSerieDischProp(DischargeID,4) = Me%OutPut%TimeSerieDischProp(DischargeID,4) + &
                                                                      MomentumDischarge

                    endif

                enddo dk

            enddo dn


            if (Me%OutPut%TimeSerieDischON) then
               if (Me%OutPut%TimeSerieDischProp(DischargeID,1) /=0) then
                    Me%OutPut%TimeSerieDischProp(DischargeID,4) = Me%OutPut%TimeSerieDischProp(DischargeID,4)/ &
                                                                  Me%OutPut%TimeSerieDischProp(DischargeID,1)
                else
                    Me%OutPut%TimeSerieDischProp(DischargeID,4) = 0.
                endif
            endif

            if (nCells>1) deallocate(DistributionCoef)

            call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR120'

            call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR130'

            call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)
            if (STAT_CALL/=SUCCESS_)                                                    &
                stop 'Sub. ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR140'

        enddo do1

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyMomentumDischargeVert")
        endif

        !Nullify auxiliar pointers
        nullify (ComputeFaces3D_W    )
        nullify (Velocity_W          )
        nullify (KFloor_Z            )
        nullify (WaterColumnZ        )
        nullify (DWZ                 )


        !Disposes pointer to the Bathymetry
        call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyMomentumDischargeVert - ModuleHydrodynamic - ERR150'


    End Subroutine ModifyMomentumDischargeVert


    !End ----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine distributes the flow along a set of cells link to:                  !
    !           - cloud of points XYZ                                                      !
    !           - lines                                                                    !
    !           - polygons                                                                 !
    !                                                                                      !
    ! Input : VectorI, VectorJ, nCells                                                     !
    ! OutPut: Flow distribution per cell                                                   !
    ! Author: Paulo Chambel (2016/2)                                                       !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine DischargeDistributionPerCell (VectorI, VectorJ, nCells, SpatialEmission, &
                                             Mapping, Property, InterceptionRatio, DistributionCoef)


        !Arguments------------------------------------------------------------
        integer, dimension(:    ), pointer :: VectorI, VectorJ
        integer                            :: nCells, SpatialEmission
        integer, dimension(:,:,:), pointer :: Mapping
        integer                            :: Property
        real                               :: InterceptionRatio
        real,    dimension(:    ), pointer :: DistributionCoef

        !Local---------------------------------------------------------------------
        integer                            :: n_i, n_j, n_iNorth, n_jEast, KUB, n
        integer                            :: di, dj, STAT_CALL
        real                               :: SumCell, Dxy
        logical                            :: UnLockGrid

        !Begin----------------------------------------------------------------

        KUB = Me%WorkSize%KUB

        SumCell    = 0.


        if (.not. associated(Me%External_Var%DUX)) then
            call GetHorizontalGrid(Me%ObjHorizontalGrid,                                &
                                   DUX  = Me%External_Var%DUX,                          &
                                   DVY  = Me%External_Var%DVY,                          &
                                   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine DischargeDistributionPerCell - ModuleHydrodynamic. ERR10.'

            UnLockGrid = .true.

        else
            UnLockGrid = .false.
        endif

i1:     if      (Property == Mass_              ) then

            do n = 1, nCells

                n_i      = VectorI(n)
                n_j      = VectorJ(n)

                if     (SpatialEmission == DischXYZPoints_) then
                    Dxy      = 1.
                elseif (SpatialEmission == DischLine_     ) then
                    Dxy      = sqrt(Me%External_Var%DUX(n_i, n_j)**2.+Me%External_Var%DVY(n_i, n_j)**2.)
                elseif (SpatialEmission == DischPolygon_  ) then
                    Dxy      = Me%External_Var%DUX(n_i, n_j) * Me%External_Var%DVY(n_i, n_j)
                endif

                SumCell             = SumCell + Dxy
                DistributionCoef(n) = Dxy

            enddo

        elseif  (Property == MomentumHorizontal_) then i1

            di  = Me%Direction%di
            dj  = Me%Direction%dj

            do n = 1, nCells
                n_i      = VectorI(n)
                n_j      = VectorJ(n)
                n_iNorth = n_i+di
                n_jEast  = n_j+dj

i2:             if (Mapping(n_i,n_j, KUB) == 1 .or. Mapping(n_iNorth, n_jEast, KUB) == 1) then
                    if     (SpatialEmission == DischXYZPoints_) then
                        Dxy      = 1.
                    elseif (SpatialEmission == DischLine_     ) then
                        Dxy      = sqrt(Me%External_Var%DUX(n_i, n_j)**2. + Me%External_Var%DVY(n_i, n_j)**2.)
                    elseif (SpatialEmission == DischPolygon_  ) then
                        Dxy      = Me%External_Var%DUX(n_i, n_j) * Me%External_Var%DVY(n_i, n_j)
                    endif

                    SumCell             = SumCell + Dxy
                    DistributionCoef(n) = Dxy

                endif i2

            enddo


        elseif  (Property == MomentumVertical_  ) then i1

            do n = 1, nCells

                n_i      = VectorI(n)
                n_j      = VectorJ(n)

i3:             if (Mapping(n_i,n_j, KUB) == 1) then
                    if     (SpatialEmission == DischXYZPoints_) then
                        Dxy      = 1.
                    elseif (SpatialEmission == DischLine_     ) then
                        Dxy      = sqrt(Me%External_Var%DUX(n_i, n_j)**2.+Me%External_Var%DVY(n_i, n_j)**2.)
                    elseif (SpatialEmission == DischPolygon_  ) then
                        Dxy      = Me%External_Var%DUX(n_i, n_j) * Me%External_Var%DVY(n_i, n_j)
                    endif

                    SumCell             = SumCell + Dxy
                    DistributionCoef(n) = Dxy

                endif i3

            enddo

        endif i1


        if (SumCell > 0.) then
            DistributionCoef(1:nCells) = DistributionCoef(1:nCells) / SumCell
        else
            DistributionCoef(1:nCells) = 0.
        endif

        if (Me%DDecomp%MasterOrSlave) then
            if (InterceptionRatio < 0. .or. InterceptionRatio > 1.) then
                write(*,*) 'MPI_ID, InterceptionRatio=', Me%DDecomp%MPI_ID, InterceptionRatio
                stop 'Subroutine DischargeDistributionPerCell - ModuleHydrodynamic. ERR20.'
            endif
            DistributionCoef(1:nCells) = InterceptionRatio * DistributionCoef(1:nCells)

        endif

        if (UnLockGrid) then

            call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                              &
                                     Me%External_Var%DUX,                               &
                                     STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine DischargeDistributionPerCell - ModuleHydrodynamic. ERR30.'

            call UnGetHorizontalGrid(Me%ObjHorizontalGrid,                              &
                                     Me%External_Var%DVY,                               &
                                     STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine DischargeDistributionPerCell - ModuleHydrodynamic. ERR40.'

        endif

    end subroutine DischargeDistributionPerCell

    !-----------------------------------------------------------------------------------

    subroutine Modify_ScraperEffect

        !Local---------------------------------------------------------------------
        real                                :: VelScraper
        integer                             :: IUB, ILB, JUB, JLB, KUB, KLB, kbottom
        integer                             :: di, dj, i, j, k, STAT_CALL
        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_ScraperEffect")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        if (Me%Scraper%ID_U%SolutionFromFile .and. dj == 1) then

            call ModifyFillMatrix(FillMatrixID      = Me%Scraper%ID_U%ObjFillMatrix,        &
                                  Matrix3D          = Me%Scraper%VelU,                      &
                                  PointsToFill3D    = Me%External_Var%WaterPoints3D,        &
                                  STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Modify_ScraperEffect - ModuleHydrodynamic - ERR10'

        endif

        if (Me%Scraper%ID_V%SolutionFromFile .and. dj == 0) then

            call ModifyFillMatrix(FillMatrixID      = Me%Scraper%ID_V%ObjFillMatrix,        &
                                  Matrix3D          = Me%Scraper%VelV,                      &
                                  PointsToFill3D    = Me%External_Var%WaterPoints3D,        &
                                  STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Modify_ScraperEffect - ModuleHydrodynamic - ERR20'

        endif


        if(.not.(associated(Me%Forces%Scraper_Aceleration))) then

                allocate(Me%Forces%Scraper_Aceleration(Me%Size%ILB:Me%Size%IUB,         &
                                              Me%Size%JLB:Me%Size%JUB,                  &
                                              Me%Size%KLB:Me%Size%KUB))

        endif

        Me%Forces%Scraper_Aceleration(:,:,:) = 0.

        Me%Scraper%Position(:,:,:) = Me%External_Var%WaterPoints3D(:,:,:)


        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

            if (Me%External_Var%WaterPoints3D(I, J, KUB) == WaterPoint) then

                kbottom = Me%External_Var%KFloor_Z(I, J)

do3:            do k = kbottom, KUB

                        if (Me%Scraper%VelU(i, j  , k) > Me%Scraper%VelLimit) then
                            Me%Scraper%Position(i,j,k) = 0
                        endif

                        if (Me%Scraper%VelV(i,   j, k) > Me%Scraper%VelLimit) then
                            Me%Scraper%Position(i,j,k) = 0
                        endif

                enddo do3

            endif

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,VelScraper)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do4:    do j = JLB, JUB
do5:    do i = ILB, IUB


            if (Me%External_Var%ComputeFaces3D_UV(I, J, KUB) == Covered) then


                kbottom = Me%External_Var%KFloor_UV(I, J)

do6:            do k = kbottom, KUB

                    if (dj == 1) then
                        VelScraper = Me%Scraper%VelU(i, j, k)
                    else
                        VelScraper = Me%Scraper%VelV(i, j, k)
                    endif

                    if (VelScraper > Me%Scraper%VelLimit) then

                        ![m/s2]              =    [m/s] / [s]
                        Me%Forces%Scraper_Aceleration(i, j, k) =                        &
                            (VelScraper - Me%Velocity%Horizontal%UV%New(I,J,K)) / Me%Scraper%TimeScale

                    endif

                enddo do6

            endif

        enddo do5
        enddo do4
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL


        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_ScraperEffect")
        endif

    end subroutine Modify_ScraperEffect

    !End ----------------------------------------------------------------------

    subroutine ModifyThinWallsDissipation

        !Local---------------------------------------------------------------------
        real                                :: CurrentWLGrad, AuxWLGrad
        integer                             :: di, dj, i, j, k, n, nFaces
        logical                             :: ComputeDissipation


        !Begin---------------------------------------------------------------------
        ! If the thinwalls are variable in time and are in open Mode
        if (Me%ThinWalls%CloseFlag == 0) then

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ModifyThinWallsDissipation")
            endif

            di  = Me%Direction%di
            dj  = Me%Direction%dj

            Me%Forces%ThinWalls_Dissipation(:,:,:) = 0.

            ComputeDissipation = .false.

            if (dj == 1) then
                if (Me%ThinWalls%UOn) then
                    nFaces = Me%ThinWalls%nU
                    ComputeDissipation = .true.
                endif
            else
                if (Me%ThinWalls%VOn) then
                    nFaces = Me%ThinWalls%nV
                    ComputeDissipation = .true.
                endif
            endif

            if (ComputeDissipation) then

                do n=1, nFaces

                    if (dj == 1) then
                        i = Me%ThinWalls%FaceU_I(n)
                        j = Me%ThinWalls%FaceU_J(n)
                        k = Me%ThinWalls%FaceU_K(n)
                    else
                        i = Me%ThinWalls%FaceV_I(n)
                        j = Me%ThinWalls%FaceV_J(n)
                        k = Me%ThinWalls%FaceV_K(n)
                    endif

                    if (Me%External_Var%ComputeFaces3D_UV(i, j, k) == Covered) then
                        CurrentWLGrad = (Me%WaterLevel%New(i,j) - Me%WaterLevel%New(i-di,j-dj)) / Me%External_Var%DZX_ZY(i-di, j-dj)

                        if (CurrentWLGrad < 0.) then
                            if (CurrentWLGrad < - Me%ThinWalls%GradWL_Limit) then
                                AuxWLGrad = CurrentWLGrad + Me%ThinWalls%GradWL_Limit
                            else
                                AuxWLGrad = 0.
                            endif
                        else
                            if (CurrentWLGrad > Me%ThinWalls%GradWL_Limit) then
                                AuxWLGrad = CurrentWLGrad - Me%ThinWalls%GradWL_Limit
                            else
                                AuxWLGrad = 0.
                            endif
                        endif

                        if (abs(AuxWLGrad) > 0.) then
                            ![m/s2]              =    [m/s2] * [m/m]
                            Me%Forces%ThinWalls_Dissipation(i, j, k) = Gravity * AuxWLGrad
                        endif
                    endif

                enddo

            endif

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ModifyThinWallsDissipation")
            endif

        endif

    end subroutine ModifyThinWallsDissipation

    !End ----------------------------------------------------------------------


    subroutine ModifyThinWallsMapping

        !Local---------------------------------------------------------------------
        integer                             :: STAT_CALL
        type (T_Time)                       :: Time1, Time2
        real                                :: Value1, Value2
        logical                             :: TimeCycle

        !Begin---------------------------------------------------------------------

        if (Me%ThinWalls%VariableInTime) then

            !Gets Value for current Time
            call GetTimeSerieValue (Me%ThinWalls%ObjTimeSerie, Me%CurrentTime,          &
                                    Me%ThinWalls%CloseFlagColumn,                       &
                                    Time1, Value1, Time2, Value2, TimeCycle,            &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructThinWalls - ModuleHydrodynamic - ERR110'

            if (Value1 == 1. .and. Value2 == 1) then
                Me%ThinWalls%CloseFlag = 1
            else
                Me%ThinWalls%CloseFlag = 0
            endif

        else
            Me%ThinWalls%CloseFlag = 1
        endif

        ! If the thinwalls are in close Mode
        if (Me%ThinWalls%CloseFlag == 1) then

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ModifyThinWallsMapping")
            endif

            if      (Me%ThinWalls%UOn) then

                call UpdateComputeFaces3D(Map_ID        = Me%ObjMap,                    &
                                          FaceType      = TypeU_,                       &
                                          nFaces        = Me%ThinWalls%Nu,              &
                                          VectorI       = Me%ThinWalls%FaceU_I,         &
                                          VectorJ       = Me%ThinWalls%FaceU_J,         &
                                          VectorK       = Me%ThinWalls%FaceU_K,         &
                                          STAT          = STAT_CALL)

            elseif  (Me%ThinWalls%VOn) then

                call UpdateComputeFaces3D(Map_ID        = Me%ObjMap,                    &
                                          FaceType      = TypeV_,                       &
                                          nFaces        = Me%ThinWalls%Nv,              &
                                          VectorI       = Me%ThinWalls%FaceV_I,         &
                                          VectorJ       = Me%ThinWalls%FaceV_J,         &
                                          VectorK       = Me%ThinWalls%FaceV_K,         &
                                          STAT          = STAT_CALL)

            elseif  (Me%ThinWalls%WOn) then

                call UpdateComputeFaces3D(Map_ID        = Me%ObjMap,                    &
                                          FaceType      = TypeW_,                       &
                                          nFaces        = Me%ThinWalls%Nw,              &
                                          VectorI       = Me%ThinWalls%FaceW_I,         &
                                          VectorJ       = Me%ThinWalls%FaceW_J,         &
                                          VectorK       = Me%ThinWalls%FaceW_K,         &
                                          STAT          = STAT_CALL)

            endif

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ModifyThinWallsMapping")
            endif

        endif

    end subroutine ModifyThinWallsMapping

    !End ----------------------------------------------------------------------

    subroutine Modify_ObstacleDrag

        !Local---------------------------------------------------------------------
        integer                             :: STAT_CALL
        integer                             :: IUB, ILB, JUB, JLB, KUB, KLB, kbottom
        integer                             :: di, dj, i, j, k
        real                                :: FaceDragCoef, VelMod_UV
        integer                             :: iSouth, I_North, J_East, jWest
        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_ObstacleDrag")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        if (Me%Drag%ID%SolutionFromFile) then

            call ModifyFillMatrix(FillMatrixID      = Me%Drag%ID%ObjFillMatrix,             &
                                  Matrix3D          = Me%Drag%Coef,                         &
                                  PointsToFill3D    = Me%External_Var%WaterPoints3D,        &
                                  STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Modify_ObstacleForces - ModuleHydrodynamic - ERR10'

        endif



        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,iSouth,jWest,I_North,J_East, &
        !$OMP                  VelMod_UV, FaceDragCoef)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

            if (Me%External_Var%ComputeFaces3D_UV(I, J, KUB) == Covered) then


                kbottom = Me%External_Var%KFloor_UV(I, J)

                iSouth     = I - di
                jWest      = J - dj

                ! This values (i_North and j_east) can only be used to compute the velocity modulus in a face
                I_North     = I + dj
                J_East      = J + di


do3:            do k = kbottom, KUB


                    VelMod_UV       = Face_Velocity_Modulus(                                &
                                      Me%Velocity%Horizontal%VU%New(I_North, jWest, K),     &
                                      Me%Velocity%Horizontal%VU%New(I_North, J_East, K),    &
                                      Me%Velocity%Horizontal%VU%New(iSouth, jWest, K),      &
                                      Me%Velocity%Horizontal%VU%New(iSouth, J_East, K),     &
                                      Me%External_Var%DXX_YY(I_North, jWest),               &
                                      Me%External_Var%DXX_YY(I_North, J_East),              &
                                      Me%External_Var%DXX_YY(iSouth, jWest),                &
                                      Me%External_Var%DXX_YY(iSouth, J_East),               &
                                      Me%Velocity%Horizontal%UV%New(I,J,K))

                    FaceDragCoef    = Face_Interpolation(Me%Drag%Coef(i, j, k),             &
                                                         Me%Drag%Coef(iSouth, jWest, K),    &
                                                         Me%External_Var%DUX_VY(I, J),      &
                                                         Me%External_Var%DUX_VY(iSouth, jWest))


                    ![m/s2]              =    [1/m] * [m/s] * [m/s]
                    Me%Forces%ObstacleDrag_Aceleration(i, j, k) = -1. * FaceDragCoef * VelMod_UV * &
                                                                      Me%Velocity%Horizontal%UV%New(I,J,K)

                enddo do3

            endif

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_ObstacleDrag")
        endif

    end subroutine Modify_ObstacleDrag


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the coriolis force devided by the density                   !
    !  for both horizontal directions : X and Y                                            !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coriolis force                                                               !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Modify_InertiaForces2

        ! X direction (Coriolis_Force(Vvar, Volume_U, Coriolis_Freq, DXX, DUX, KFloorU, CoveredFacesX, &
        !              ILB, IUB, JLB, JUB, KUB, Direction=1, Inertial_Aceleration)
        ! Y direction (Coriolis_Force(Uvar, Volume_V, Coriolis_Freq, DYY, DVY, KFloorV, CoveredFacesY, &
        !              ILB, IUB, JLB, JUB, KUB, Direction=0, Inertial_Aceleration)

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, Velocity_VU_New, Inertial_Aceleration
        real,    dimension(:,:),   pointer :: DXX_YY, DYY_XX, DUX_VY, DVY_UX, DZX_ZY, Coriolis_Freq

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, LandBoundaryFacesVU
        integer, dimension(:,:),   pointer :: KFloor_UV

        real,    dimension(:  ),   pointer :: XX

        real                               :: VUvar1, VUvar2, VUAverage, F_UV
        integer                            :: di, dj, k, kbottom, NoLand1, NoLand2
        integer                            :: I, I1, I2, I3
        integer                            :: J, J1, J2, J3

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real                               :: Radius, Xorig, Yorig, Coriolis_Aceleration, &
                                              Centrifugal_Aceleration
        real                               :: dx1, dx2, Area, dxdy, dydx, f_Curvature

        integer                            :: FATAL_, INTERNAL_, ICOORD_TIP, CIRCULAR,   &
                                              status, Iaux

        !$ integer                            :: CHUNK

        !------------initialization----

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        Inertial_Aceleration => Me%Forces%Inertial_Aceleration
        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV


        DXX_YY               => Me%External_Var%DXX_YY
        DYY_XX               => Me%External_Var%DYY_XX

        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX

        DZX_ZY               => Me%External_Var%DZX_ZY

        Coriolis_Freq        => Me%External_Var%Coriolis_Freq

        LandBoundaryFacesVU  => Me%External_Var%LandBoundaryFacesVU

        !End - Shorten variables name
        !Gets the type of Coordinates
        call GetCoordTypeList(CIRCULAR  = CIRCULAR)

        call GetGridCoordType(Me%ObjHorizontalGrid, ICOORD_TIP, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR01")

        if (ICOORD_TIP == CIRCULAR .and. Me%ComputeOptions%CentrifugalForce) then

            !Gets XX (radius when the grid coordinates are circular
            call GetHorizontalGrid(Me%ObjHorizontalGrid, XX = XX, STAT = status)
            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR02")

            !Gets Origin of the Bathymetry
            call GetGridOrigin(Me%ObjHorizontalGrid, Xorig, Yorig, STAT = status)
            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR03")


        endif


        !------------Main cicle--------

        !$ CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_InertiaForces")
        endif

        !$OMP PARALLEL PRIVATE( I,J,K,I1,J1,I2,J2,I3,J3,kbottom,VUvar1,NoLand1, &
        !$OMP                   VUvar2,NoLand2,VUAverage,F_UV,Coriolis_Aceleration, &
        !$OMP                   Radius,Centrifugal_Aceleration,Area,dydx,dx1,dx2,dxdy, &
        !$OMP                   f_Curvature, Iaux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then

                kbottom = KFloor_UV(I, J)


                I1    = I+dj-di
                J1    = J-dj+di
                I2    = I+dj
                J2    = J+di
                I3    = I-di
                J3    = J-dj



    do3:        do K=kbottom, KUB


                    !Null gradient is admitted in the land boundary.
                    if ((LandBoundaryFacesVU(I1, J1, K) + LandBoundaryFacesVU(I2, J2, K)) == 0) then

                        VUvar1 = (Velocity_VU_New(I1, J1, K) * DXX_YY(I2, J2) + &
                                  Velocity_VU_New(I2, J2, K) * DXX_YY(I1, J1))/ &
                                 (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                        NoLand1  = 1

                    else

                        VUvar1 = (1 - LandBoundaryFacesVU(I1, J1, K)) * Velocity_VU_New(I1, J1, K) + &
                                 (1 - LandBoundaryFacesVU(I2, J2, K)) * Velocity_VU_New(I2, J2, K)

                        NoLand1  = 2 - LandBoundaryFacesVU(I1, J1, K) - LandBoundaryFacesVU(I2, J2, K)

                    endif

                    if ((LandBoundaryFacesVU(I3, J3, K) + LandBoundaryFacesVU(I, J, K)) == 0) then

                        VUvar2 = (Velocity_VU_New(I3, J3, K) * DXX_YY(I, J)   + &
                                  Velocity_VU_New(I,   J, K) * DXX_YY(I3, J3))/ &
                                 (DXX_YY(I3, J3) +  DXX_YY(I, J))

                       NoLand2  = 1

                    else

                       VUvar2 = (1 - LandBoundaryFacesVU(I3, J3, K)) * Velocity_VU_New(I3, J3, K) + &
                                (1 - LandBoundaryFacesVU(I,   J, K)) * Velocity_VU_New(I,   J, K)

                       NoLand2  = 2 - LandBoundaryFacesVU(I3, J3, K) - LandBoundaryFacesVU(I,   J, K)

                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif


                    !VUvar1 = (Velocity_VU_New(I1, J1, K) * DXX_YY(I2, J2) + &
                    !          Velocity_VU_New(I2, J2, K) * DXX_YY(I1, J1))/ &
                    !         (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                    !VUvar2 = (Velocity_VU_New(I3, J3, K) * DXX_YY(I, J)   + &
                    !          Velocity_VU_New(I,   J, K) * DXX_YY(I3, J3))/ &
                    !         (DXX_YY(I3, J3) +  DXX_YY(I, J))

                    !VUAverage  = (VUvar1  + VUvar2) / 2.

                    Inertial_Aceleration(I, J, K) = 0.


                    if (Me%ComputeOptions%Coriolis) then

                        ! Interpolates Coriolis_Freq for the face
                        F_UV = (DUX_VY(I3, J3) * Coriolis_Freq(I, J) + DUX_VY(I, J) * Coriolis_Freq(I3, J3)) / &
                               (DUX_VY(I3, J3) + DUX_VY(I, J))


                        ! Compute aceleration force

                        ![m/s^2]                 =            [s^-1] * [m/s]
                        Coriolis_Aceleration     = (dj - di) * F_UV * VUAverage
                        Inertial_Aceleration(I, J, K) = Inertial_Aceleration(I, J, K) +  Coriolis_Aceleration

                    endif

                    if (Me%ComputeOptions%CentrifugalForce) then


                        if (ICOORD_TIP == CIRCULAR) then

                            Radius      = Xorig + XX(J)

                            ![m/s^2]                =           [m/s] * [m/s] / [m]
                            Centrifugal_Aceleration =  dj * VUAverage * VUAverage / Radius

                            ![m/s^2]                 =            [m/s^2]  + [m/s^2]
                            Inertial_Aceleration(I, J, K) = Inertial_Aceleration(I, J, K) + Centrifugal_Aceleration

                        else

                            Area      = DZX_ZY(i3, j3) * DYY_XX(i, j)

                            !If
                            dydx      = DVY_UX(i, j) - DVY_UX(i3, j3)

                            dx2       = (DXX_YY(i1, j1) + DXX_YY(i2, j2)) / 2.
                            dx1       = (DXX_YY(i , j ) + DXX_YY(i3, j3)) / 2.

                            dxdy      = dx2 - dx1

                            ! [s-1]     =   [m/s * m / m^2]
                            f_Curvature =   (VUAverage * dydx - Velocity_UV_New(i, j, k) * dxdy) / Area

                            ![m/s^2]                =           [m/s] * [s-1]
                            Centrifugal_Aceleration =  VUAverage * f_Curvature

                            ![m/s^2]                 =            [m/s^2]  + [m/s^2]
                            Inertial_Aceleration(I, J, K) = Inertial_Aceleration(I, J, K) + Centrifugal_Aceleration


                        endif

                    endif


                enddo do3

            end if cd1

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_InertiaForces")
        endif

        if (ICOORD_TIP == CIRCULAR) then

            !Gets XX and YY
            call UngetHorizontalGrid(Me%ObjHorizontalGrid, XX, STAT = status)
            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR02")


        endif

        nullify (Inertial_Aceleration)
        nullify (Velocity_UV_New)
        nullify (Velocity_VU_New)

        nullify (DXX_YY)
        nullify (DYY_XX)
        nullify (DUX_VY)
        nullify (DVY_UX)
        nullify (DZX_ZY)

        nullify (Coriolis_Freq)

        nullify (ComputeFaces3D_UV, LandBoundaryFacesVU)
        nullify (KFloor_UV)

    End Subroutine Modify_InertiaForces2

    !End------------------------------------------------------------------------------

    Subroutine Modify_InertiaForces

        ! X direction (Coriolis_Force(Vvar, Volume_U, Coriolis_Freq, DXX, DUX, KFloorU, CoveredFacesX, &
        !              ILB, IUB, JLB, JUB, KUB, Direction=1, Inertial_Aceleration)
        ! Y direction (Coriolis_Force(Uvar, Volume_V, Coriolis_Freq, DYY, DVY, KFloorV, CoveredFacesY, &
        !              ILB, IUB, JLB, JUB, KUB, Direction=0, Inertial_Aceleration)

        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------
        real,    dimension(:  ),   pointer :: XX
        integer                            :: FATAL_, INTERNAL_, ICOORD_TIP, CIRCULAR,   &
                                                status
        real                               :: Xorig, Yorig
        !------------initialization---------------------------------------------------------

        !Gets the type of Coordinates
        call GetCoordTypeList(CIRCULAR  = CIRCULAR)

        call GetGridCoordType(Me%ObjHorizontalGrid, ICOORD_TIP, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR01")

        if (ICOORD_TIP == CIRCULAR .and. Me%ComputeOptions%CentrifugalForce) then

            !Gets XX (radius when the grid coordinates are circular
            call GetHorizontalGrid(Me%ObjHorizontalGrid, XX = XX, STAT = status)
            if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR02")

            !Gets Origin of the Bathymetry
            call GetGridOrigin(Me%ObjHorizontalGrid, Xorig, Yorig, STAT = status)
            if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR03")

        endif

        !------------Main cicle--------Inertial forces-------------------------------------
        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_InertiaForces")
        endif

        call SetMatrixValue(Me%Forces%Inertial_Aceleration, Me%WorkSize, 0.0)

        if (Me%ComputeOptions%Coriolis) then
            if (Me%Direction%di == 1) then
                call InertialForces_Coriolis_Y (Me%External_Var%ComputeFaces3D_V, Me%External_Var%KFloor_V,           &
                     Me%External_Var%LandBoundaryFacesU, Me%Velocity%Horizontal%U%New, Me%External_Var%Coriolis_Freq, &
                     Me%External_Var%DYY, Me%External_Var%DVY, Me%Forces%Inertial_Aceleration)
            else
                call InertialForces_Coriolis_X (Me%External_Var%ComputeFaces3D_U, Me%External_Var%KFloor_U,           &
                     Me%External_Var%LandBoundaryFacesV, Me%Velocity%Horizontal%V%New, Me%External_Var%Coriolis_Freq, &
                     Me%External_Var%DXX, Me%External_Var%DUX, Me%Forces%Inertial_Aceleration)
            endif
        endif

        !--------------------------------------Centrifugal_force------------------------------------------------------------
        if (Me%ComputeOptions%CentrifugalForce) then
            if (ICOORD_TIP == CIRCULAR) then
                if (Me%Direction%di == 1) then
                    !Do nothing because centrifugal force will be zero
                else
                    call InertialForces_Centrifugal_Cir (Me%External_Var%ComputeFaces3D_U, Me%External_Var%KFloor_U,           &
                         Me%External_Var%LandBoundaryFacesV, Me%Velocity%Horizontal%V%New, Xorig, XX,  &
                         Me%External_Var%DXX, Me%Forces%Inertial_Aceleration)
                endif
            else
                if (Me%Direction%di == 1) then
                    call InertialForces_Centrifugal_Y (Me%External_Var%ComputeFaces3D_V, Me%External_Var%KFloor_V,    &
                         Me%External_Var%LandBoundaryFacesU, Me%External_Var%DXX, Me%External_Var%DYY,                &
                         Me%External_Var%DUX, Me%External_Var%DZY, Me%Velocity%Horizontal%U%New, &
                         Me%Velocity%Horizontal%V%New, Me%Forces%Inertial_Aceleration)
                else
                    call InertialForces_Centrifugal_X (Me%External_Var%ComputeFaces3D_U, Me%External_Var%KFloor_U,    &
                         Me%External_Var%LandBoundaryFacesV, Me%External_Var%DXX, Me%External_Var%DYY,                &
                         Me%External_Var%DVY, Me%External_Var%DZX, Me%Velocity%Horizontal%U%New, &
                         Me%Velocity%Horizontal%V%New, Me%Forces%Inertial_Aceleration)
                endif
            endif
        endif

         if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_InertiaForces")
        endif

        if (ICOORD_TIP == CIRCULAR) then
            !Gets XX and YY
            call UngetHorizontalGrid(Me%ObjHorizontalGrid, XX, STAT = status)
            if (status /= SUCCESS_) call SetError (FATAL_, INTERNAL_, "Modify_InertiaForces - Hydrodynamic - ERR02")
        endif

    end Subroutine Modify_InertiaForces

    !End--------------------------------------------------------------------------------------------

    subroutine InertialForces_Coriolis_X (ComputeFaces3D_U, KFloor_U, LandBoundaryFacesV, Velocity_V_New, &
        Coriolis_Freq, DXX, DUX, Inertial_Aceleration)

        !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_V_New
        real,    dimension(:,:,:), pointer, intent(INOUT) :: Inertial_Aceleration
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U, LandBoundaryFacesV
        real,    dimension(:,:),   pointer, intent(IN)    :: DXX, DUX, Coriolis_Freq
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_U
        !Locals ------------------------------------------------------------------------------
        real                                              :: VUvar1, VUvar2, VUAverage, F_UV, Coriolis_Aceleration
        integer                                           :: NoLand1, NoLand2, Flag1, Flag2, Iaux, kbottom, &
                                                             IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        !$ integer                                        :: CHUNK
        !Begin---------------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !$ CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE( i,j,k,kbottom,VUvar1,NoLand1,Flag1,Flag2, &
        !$OMP                   VUvar2,NoLand2,VUAverage,F_UV,Coriolis_Aceleration,Iaux)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB
            if (ComputeFaces3D_U(i, j, KUB) == Covered) then
                kbottom = KFloor_U(i, j)

                do k=kbottom, KUB
                    !Null gradient is admitted in the land boundary.
                    Flag1 = LandBoundaryFacesV(i+1, j-1, k) + LandBoundaryFacesV(i+1, j, k)
                    if (Flag1 == 0) then
                        VUvar1 = (Velocity_V_New(i+1, j-1, k) * DXX(i+1, j) + &
                                  Velocity_V_New(i+1, j  , k) * DXX(i+1, j-1))/ (DXX(i+1, j-1) + DXX(i+1, j))
                        NoLand1  = 1
                    else
                        VUvar1 = (1 - LandBoundaryFacesV(i+1, j-1, k)) * Velocity_V_New(i+1, j-1, k) + &
                                 (1 - LandBoundaryFacesV(i+1, j  , k)) * Velocity_V_New(i+1, j, k)
                        NoLand1  = 2 - Flag1
                    endif

                    Flag2 = LandBoundaryFacesV(i, j-1, k) + LandBoundaryFacesV(i, j, k)

                    if (Flag2 == 0) then
                        VUvar2 = (Velocity_V_New(i, j-1, k) * DXX(i, j)   + &
                                  Velocity_V_New(i,   j, k) * DXX(i, j-1))/ (DXX(i, j-1) + DXX(i, j))
                        NoLand2  = 1
                    else
                        VUvar2 = (1 - LandBoundaryFacesV(i, j-1, k)) * Velocity_V_New(i, j-1, k) + &
                                 (1 - LandBoundaryFacesV(i,   j, k)) * Velocity_V_New(i,   j, k)
                        NoLand2  = 2 - Flag2
                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif

                    ! Interpolates Coriolis_Freq for the face
                    F_UV = (DUX(i, j-1) * Coriolis_Freq(i, j) + DUX(i, j) * Coriolis_Freq(i, j-1)) / &
                           (DUX(i, j-1) + DUX(i, j))
                    ! Compute aceleration force
                    ![m/s^2]                 =            [s^-1] * [m/s]
                    Coriolis_Aceleration     = F_UV * VUAverage
                    Inertial_Aceleration(i, j, k) = Inertial_Aceleration(i, j, k) + Coriolis_Aceleration
                enddo
            end if
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine InertialForces_Coriolis_X

    !End----------------------------------------------------------------------------------------

    subroutine InertialForces_Coriolis_Y (ComputeFaces3D_V, KFloor_V, LandBoundaryFacesU, Velocity_U_New, &
        Coriolis_Freq, DYY, DVY, Inertial_Aceleration)

        !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_U_New
        real,    dimension(:,:,:), pointer, intent(INOUT) :: Inertial_Aceleration
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_V, LandBoundaryFacesU
        real,    dimension(:,:),   pointer, intent(IN)    :: DYY, DVY, Coriolis_Freq
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_V
        !Locals ------------------------------------------------------------------------------
        real                                              :: VUvar1, VUvar2, VUAverage, F_UV, Coriolis_Aceleration
        integer                                           :: NoLand1, NoLand2, Flag1, Flag2, Iaux, kbottom, &
                                                             IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        !$ integer                                        :: CHUNK
        !Begin---------------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !$ CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE( i,j,k,kbottom,VUvar1,NoLand1,Flag1,Flag2, &
        !$OMP                   VUvar2,NoLand2,VUAverage,F_UV,Coriolis_Aceleration,Iaux)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

            if (ComputeFaces3D_V(i, j, KUB) == Covered) then
                kbottom = KFloor_V(i, j)

                do k=kbottom, KUB
                    !Null gradient is admitted in the land boundary.
                    Flag1 = LandBoundaryFacesU(i-1, j+1, k) + LandBoundaryFacesU(i  , j+1, k)
                    if (Flag1 == 0) then
                        VUvar1 = (Velocity_U_New(i-1, j+1, k) * DYY(i, j+1) + &
                                  Velocity_U_New(i  , j+1, k) * DYY(i-1, j+1))/ (DYY(i-1, j+1) + DYY(i, j+1))
                        NoLand1  = 1
                    else
                        VUvar1 = (1 - LandBoundaryFacesU(i-1, j+1, k)) * Velocity_U_New(i-1, j+1, k) + &
                                 (1 - LandBoundaryFacesU(i  , j+1, k)) * Velocity_U_New(i  , j+1, k)
                        NoLand1  = 2 - Flag1
                    endif

                    Flag2 = LandBoundaryFacesU(i-1, j, k) + LandBoundaryFacesU(i, j, k)

                    if (Flag2 == 0) then
                        VUvar2 = (Velocity_U_New(i-1, j, k) * DYY(i, j)   + &
                                  Velocity_U_New(i,   j, K) * DYY(i-1, j))/ (DYY(i-1, j) +  DYY(i, j))
                        NoLand2  = 1
                    else
                        VUvar2 = (1 - LandBoundaryFacesU(i-1, j, k)) * Velocity_U_New(i-1, j, k) + &
                                 (1 - LandBoundaryFacesU(i,   j, k)) * Velocity_U_New(i,   j, k)
                        NoLand2  = 2 - Flag2
                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif

                    ! Interpolates Coriolis_Freq for the face
                    F_UV = (DVY(i-1, j) * Coriolis_Freq(i, j) + DVY(i, j) * Coriolis_Freq(i-1, j)) / &
                            (DVY(i-1, j) + DVY(i, j))
                    ! Compute aceleration force
                    ![m/s^2]                 =            [s^-1] * [m/s]
                    Coriolis_Aceleration     = -(F_UV) * VUAverage
                    Inertial_Aceleration(i, j, k) = Inertial_Aceleration(i, j, k) +  Coriolis_Aceleration
                enddo
            end if
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine InertialForces_Coriolis_Y

    !End -------------------------------------------------------------------------------------

    subroutine InertialForces_Centrifugal_Cir(ComputeFaces3D_U, KFloor_U, LandBoundaryFacesV, Velocity_V_New, &
        Xorig, XX, DXX, Inertial_Aceleration)

        !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_V_New
        real,    dimension(:,:,:), pointer, intent(INOUT) :: Inertial_Aceleration
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U, LandBoundaryFacesV
        real,    dimension(:,:),   pointer, intent(IN)    :: DXX
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_U
        real,    dimension(:  ),   pointer, intent(IN)    :: XX
        real                              , intent(IN)    :: Xorig
        !Locals ------------------------------------------------------------------------------
        real                                              :: VUvar1, VUvar2, VUAverage, Radius, Centrifugal_Aceleration
        integer                                           :: NoLand1, NoLand2, Flag1, Flag2, Iaux, kbottom, &
                                                             IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        !$ integer                                        :: CHUNK
        !Begin---------------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        !$ CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE( i,j,k,kbottom,VUvar1,NoLand1,Flag1,Flag2,Radius, &
        !$OMP                   VUvar2,NoLand2,VUAverage,Centrifugal_Aceleration,Iaux)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB
            if (ComputeFaces3D_U(i, j, KUB) == Covered) then
                kbottom = KFloor_U(i, j)

                do k=kbottom, KUB
                    !Null gradient is admitted in the land boundary.
                    Flag1 = LandBoundaryFacesV(i+1, j-1, k) + LandBoundaryFacesV(i+1, j, k)
                    if (Flag1 == 0) then
                        VUvar1 = (Velocity_V_New(i+1, j-1, k) * DXX(i+1, j) + &
                                  Velocity_V_New(i+1, j  , k) * DXX(i+1, j-1))/ (DXX(i+1, j-1) + DXX(i+1, j))
                        NoLand1  = 1
                    else
                        VUvar1 = (1 - LandBoundaryFacesV(i+1, j-1, k)) * Velocity_V_New(i+1, j-1, k) + &
                                 (1 - LandBoundaryFacesV(i+1, j  , k)) * Velocity_V_New(i+1, j, k)
                        NoLand1  = 2 - Flag1
                    endif

                    Flag2 = LandBoundaryFacesV(i, j-1, k) + LandBoundaryFacesV(i, j, k)

                    if (Flag2 == 0) then
                        VUvar2 = (Velocity_V_New(i, j-1, k) * DXX(i, j)   + &
                                  Velocity_V_New(i,   j, k) * DXX(i, j-1))/ (DXX(i, j-1) + DXX(i, j))
                        NoLand2  = 1
                    else
                        VUvar2 = (1 - LandBoundaryFacesV(i, j-1, k)) * Velocity_V_New(i, j-1, k) + &
                                 (1 - LandBoundaryFacesV(i,   j, k)) * Velocity_V_New(i,   j, k)
                        NoLand2  = 2 - Flag2
                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif

                    Radius      = Xorig + XX(j)
                    ![m/s^2]                =    [m/s]   *   [m/s]    / [m]
                    Centrifugal_Aceleration =  VUAverage * VUAverage / Radius
                    ![m/s^2]                 =            [m/s^2]  + [m/s^2]
                    Inertial_Aceleration(i, j, k) = Inertial_Aceleration(i, j, k) + Centrifugal_Aceleration
                enddo
            end if
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine InertialForces_Centrifugal_Cir
    ! End-------------------------------------------------------------------------------

    subroutine InertialForces_Centrifugal_Y(ComputeFaces3D_V, KFloor_V, LandBoundaryFacesU, DXX, DYY, DUX, DZY, &
        Velocity_U_New, Velocity_V_New, Inertial_Aceleration)

        !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_U_New, Velocity_V_New
        real,    dimension(:,:,:), pointer, intent(INOUT) :: Inertial_Aceleration
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_V, LandBoundaryFacesU
        real,    dimension(:,:),   pointer, intent(IN)    :: DYY, DXX, DUX, DZY
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_V
        !Locals ------------------------------------------------------------------------------
        real                                              :: VUvar1, VUvar2, VUAverage, Centrifugal_Aceleration, &
                                                             Area, dydx, dx2, dx1, dxdy, f_Curvature
        integer                                           :: NoLand1, NoLand2, Flag1, Flag2, Iaux, kbottom, &
                                                             IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        !$ integer                                        :: CHUNK
        !Begin---------------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !$ CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE( i,j,k,kbottom,VUvar1,NoLand1,Flag1,Flag2, f_Curvature, Area, dydx, dx2, dx1, dxdy, &
        !$OMP                   VUvar2,NoLand2,VUAverage,Centrifugal_Aceleration,Iaux)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB
            if (ComputeFaces3D_V(i, j, KUB) == Covered) then
                kbottom = KFloor_V(i, j)

                do k=kbottom, KUB
                    !Null gradient is admitted in the land boundary.
                    Flag1 = LandBoundaryFacesU(i-1, j+1, k) + LandBoundaryFacesU(i  , j+1, k)
                    if (Flag1 == 0) then
                        VUvar1 = (Velocity_U_New(i-1, j+1, k) * DYY(i, j+1) + &
                                  Velocity_U_New(i  , j+1, k) * DYY(i-1, j+1))/ (DYY(i-1, j+1) + DYY(i, j+1))
                        NoLand1  = 1
                    else
                        VUvar1 = (1 - LandBoundaryFacesU(i-1, j+1, k)) * Velocity_U_New(i-1, j+1, k) + &
                                 (1 - LandBoundaryFacesU(i  , j+1, k)) * Velocity_U_New(i  , j+1, k)
                        NoLand1  = 2 - Flag1
                    endif

                    Flag2 = LandBoundaryFacesU(i-1, j, k) + LandBoundaryFacesU(i, j, k)

                    if (Flag2 == 0) then
                        VUvar2 = (Velocity_U_New(i-1, j, k) * DYY(i, j)   + &
                                  Velocity_U_New(i,   j, K) * DYY(i-1, j))/ (DYY(i-1, j) +  DYY(i, j))
                        NoLand2  = 1
                    else
                        VUvar2 = (1 - LandBoundaryFacesU(i-1, j, k)) * Velocity_U_New(i-1, j, k) + &
                                 (1 - LandBoundaryFacesU(i,   j, k)) * Velocity_U_New(i,   j, k)
                        NoLand2  = 2 - Flag2
                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif

                    Area      = DZY(i-1, j) * DXX(i, j)

                    dydx      = DUX(i, j) - DUX(i-1, j)

                    dx2       = (DYY(i-1, j+1) + DYY(i  , j+1)) / 2.
                    dx1       = (DYY(i  , j  ) + DYY(i-1, j  )) / 2.

                    dxdy      = dx2 - dx1
                    ! [s-1]     =   [m/s * m / m^2]
                    f_Curvature =   (VUAverage * dydx - Velocity_V_New(i, j, k) * dxdy) / Area
                    ![m/s^2]                =           [m/s] * [s-1]
                    Centrifugal_Aceleration =  VUAverage * f_Curvature
                    ![m/s^2]                 =            [m/s^2]  + [m/s^2]
                    Inertial_Aceleration(i, j, k) = Inertial_Aceleration(i, j, k) + Centrifugal_Aceleration
                enddo
            end if
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine InertialForces_Centrifugal_Y

    !End----------------------------------------------------------------------------

    subroutine InertialForces_Centrifugal_X(ComputeFaces3D_U, KFloor_U, LandBoundaryFacesV, DXX, DYY, DVY, DZX, &
        Velocity_U_New, Velocity_V_New, Inertial_Aceleration)

        !Arguments--------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_U_New, Velocity_V_New
        real,    dimension(:,:,:), pointer, intent(INOUT) :: Inertial_Aceleration
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U, LandBoundaryFacesV
        real,    dimension(:,:),   pointer, intent(IN)    :: DYY, DXX, DVY, DZX
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_U
        !Locals ------------------------------------------------------------------------------
        real                                              :: VUvar1, VUvar2, VUAverage, Centrifugal_Aceleration, &
                                                             Area, dydx, dx2, dx1, dxdy, f_Curvature
        integer                                           :: NoLand1, NoLand2, Flag1, Flag2, Iaux, kbottom, &
                                                             IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        !$ integer                                        :: CHUNK
        !Begin---------------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        !$ CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE( i,j,k,kbottom,VUvar1,NoLand1,Flag1,Flag2, f_Curvature, Area, dydx, dx2, dx1, dxdy, &
        !$OMP                   VUvar2,NoLand2,VUAverage,Centrifugal_Aceleration,Iaux)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB
            if (ComputeFaces3D_U(i, j, KUB) == Covered) then
                kbottom = KFloor_U(i, j)

                do K=kbottom, KUB
                    !Null gradient is admitted in the land boundary.
                    Flag1 = LandBoundaryFacesV(i+1, j-1, k) + LandBoundaryFacesV(i+1, j, k)
                    if (Flag1 == 0) then
                        VUvar1 = (Velocity_V_New(i+1, j-1, k) * DXX(i+1, j) + &
                                  Velocity_V_New(i+1, j  , k) * DXX(i+1, j-1))/ (DXX(i+1, j-1) + DXX(i+1, j))
                        NoLand1  = 1
                    else
                        VUvar1 = (1 - LandBoundaryFacesV(i+1, j-1, k)) * Velocity_V_New(i+1, j-1, k) + &
                                 (1 - LandBoundaryFacesV(i+1, j  , k)) * Velocity_V_New(i+1, j, k)
                        NoLand1  = 2 - Flag1
                    endif

                    Flag2 = LandBoundaryFacesV(i, j-1, k) + LandBoundaryFacesV(i, j, k)

                    if (Flag2 == 0) then
                        VUvar2 = (Velocity_V_New(i, j-1, k) * DXX(i, j)   + &
                                  Velocity_V_New(i,   j, k) * DXX(i, j-1))/ (DXX(i, j-1) + DXX(i, j))
                        NoLand2  = 1
                    else
                        VUvar2 = (1 - LandBoundaryFacesV(i, j-1, k)) * Velocity_V_New(i, j-1, k) + &
                                 (1 - LandBoundaryFacesV(i,   j, k)) * Velocity_V_New(i,   j, k)
                        NoLand2  = 2 - Flag2
                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif

                    Area      = DZX(i, j-1) * DYY(i, j)

                    dydx      = DVY(i, j) - DVY(i, j-1)

                    dx2       = (DXX(i+1, j-1) + DXX(i+1, j  )) / 2.
                    dx1       = (DXX(i  , j  ) + DXX(i  , j-1)) / 2.

                    dxdy      = dx2 - dx1
                    ! [s-1]     =   [m/s * m / m^2]
                    f_Curvature =   (VUAverage * dydx - Velocity_U_New(i, j, k) * dxdy) / Area
                    ![m/s^2]                =           [m/s] * [s-1]
                    Centrifugal_Aceleration =  VUAverage * f_Curvature
                    ![m/s^2]                 =            [m/s^2]  + [m/s^2]
                    Inertial_Aceleration(i, j, k) = Inertial_Aceleration(i, j, k) + Centrifugal_Aceleration
                enddo
            end if
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine InertialForces_Centrifugal_X

    !End----------------------------------------------------------------------------------------

    Subroutine ModifyRelaxAceleration


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        type T_Matrix3D
            real,    dimension(:,:,:), pointer :: VelAssimilation3D
        end type T_Matrix3D

        type T_Matrix2D
            real,    dimension(:,:  ), pointer :: VelAssimilation2D
        end type T_Matrix2D


        type (T_Matrix3D), dimension(:), pointer :: List3D
        type (T_Matrix2D), dimension(:), pointer :: List2D

        real,    dimension(:,:,:), pointer :: Velocity_UV_New, SubModel_UV_New,          &
                                              Relax_Aceleration, DecayTime,              &
                                              DUZ_VZ

        real,    dimension(:,:  ), pointer :: WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV

        integer, dimension(:,:),   pointer :: KFloor_UV

        type (T_Time)                      :: CurrentTime, BeginTime, EndTime

        real                               :: ColdPeriod, ColdOrder, DT_RunPeriod, CoefCold, VelModel, VelReference

        integer                            :: Vel_ID, status
        integer                            :: ILB, IUB, JLB, JUB, KUB, kbottom, i, j, k

        integer                            :: CHUNK
        integer                            :: iL, NFieldsUV2D, NFieldsUV3D

    !------------initialization----

        !Begin - Shorten variables name
        Relax_Aceleration    => Me%Forces%Relax_Aceleration

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        WaterColumnUV        => Me%External_Var%WaterColumnUV

        DUZ_VZ               => Me%External_Var%DUZ_VZ


cd1:    if (Me%Relaxation%ReferenceVelocity == TotalVel_   .or.             &
            Me%Relaxation%ReferenceVelocity == BarotrVel_)  then

            Velocity_UV_New      => Me%Velocity%Horizontal%UV%New

        else if (Me%Relaxation%ReferenceVelocity == BaroclVel_) then cd1

            Velocity_UV_New      => Me%VelBaroclinic%UV%New

        endif cd1


        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB

        EndTime     = Me%EndTime

        BeginTime   = Me%BeginTime

        CurrentTime = Me%CurrentTime

        !End - Shorten variables name

        call GetNumberOfFields(AssimilationID  = Me%ObjAssimilation,                &
                                ID              = BarotropicVelocityU_,              &
                                NumberOfFields  = NFieldsUV2D,                       &
                                STAT            = status)
        if (status /= SUCCESS_)                                                     &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR070")

        if (Me%ComputeOptions%AssimilaOneField) then
            NFieldsUV2D = 0
        endif


        call GetNumberOfFields(AssimilationID  = Me%ObjAssimilation,            &
                                ID              = VelocityU_,                    &
                                NumberOfFields  = NFieldsUV3D,                   &
                                STAT            = status)
        if (status /= SUCCESS_)                                                 &
            call SetError (FATAL_, INTERNAL_, "WaterLevel_FlatherLocalSolution - Hydrodynamic - ERR070")

        if (Me%ComputeOptions%AssimilaOneField) then
            NFieldsUV3D = 1
        endif


        allocate(List2D(NFieldsUV2D))
        allocate(List3D(NFieldsUV3D))



        nullify (SubModel_UV_New)

cd2:    if      (Me%Direction%XY == DirectionX_) then

            Vel_ID = VelocityU_

            if (Me%SubModel%ON)                                                         &
                SubModel_UV_New => Me%SubModel%U_New

            !It is important to read vector fields in agreggated way to allow the
            !rotation of the meridional/zonal velocities to be align with the grid/cell orientation

            do iL =1, NFieldsUV3D

                call GetAssimilationVectorField                                         &
                                     (AssimilationID    = Me%ObjAssimilation,           &
                                      VectorX_ID        = VelocityU_,                   &
                                      VectorY_ID        = VelocityV_,                   &
                                      N_Field           = iL ,                          &
                                      VectorX_3D        = List3D(iL)%VelAssimilation3D, &
                                      STAT              = status)
                if (status /= SUCCESS_)                                                 &
                    call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR10")
            enddo

            do iL =1, NFieldsUV2D

                call GetAssimilationVectorField                                         &
                                     (AssimilationID    = Me%ObjAssimilation,           &
                                      VectorX_ID        = BarotropicVelocityU_,         &
                                      VectorY_ID        = BarotropicVelocityV_,         &
                                      N_Field           = iL ,                          &
                                      VectorX_2D        = List2D(iL)%VelAssimilation2D, &
                                      STAT              = status)
                if (status /= SUCCESS_)                                                 &
                    call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR10")
            enddo


        else if (Me%Direction%XY == DirectionY_) then cd2

            Vel_ID = VelocityV_
            if (Me%SubModel%ON)                                                         &
                SubModel_UV_New => Me%SubModel%V_New

            do iL =1, NFieldsUV3D

                !It is important to read vector fields in agreggated way to allow the
                !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
                call GetAssimilationVectorField                                         &
                                     (AssimilationID    = Me%ObjAssimilation,           &
                                      VectorX_ID        = VelocityU_,                   &
                                      VectorY_ID        = VelocityV_,                   &
                                      N_Field           = iL ,                          &
                                      VectorY_3D        = List3D(iL)%VelAssimilation3D, &
                                      STAT              = status)
                if (status /= SUCCESS_)                                                 &
                    call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR15")

            enddo

            do iL =1, NFieldsUV2D

                call GetAssimilationVectorField                                         &
                                     (AssimilationID    = Me%ObjAssimilation,           &
                                      VectorX_ID        = BarotropicVelocityU_,         &
                                      VectorY_ID        = BarotropicVelocityV_,         &
                                      N_Field           = iL ,                          &
                                      VectorY_2D        = List2D(iL)%VelAssimilation2D, &
                                      STAT              = status)
                if (status /= SUCCESS_)                                                 &
                    call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR10")
            enddo

        endif cd2

        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID              = Vel_ID,                             &
                                  CoefField3D     = DecayTime,                          &
                                  ColdRelaxPeriod = ColdPeriod,                         &
                                  ColdOrder       = ColdOrder,                          &
                                  STAT            = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR20")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime) .and. Me%FirstIteration) then
            write(*,*) "ModifyRelaxAceleration - Hydrodynamic - WRN30"
            write(*,*) "Cold Relaxation Aceleration period larger than simulation period"
        endif

cd4:    if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else  cd4
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif cd4

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyRelaxAceleration")
        endif

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom,VelModel,VelReference)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd5:        if (ComputeFaces3D_UV(I, J, KUB) == Covered ) then

                kbottom = KFloor_UV(I, J)

cd6:            if (Me%Relaxation%ReferenceVelocity == BarotrVel_) then

                    VelModel  = 0.

do4:                do K=kbottom, KUB

                        VelModel  =  VelModel + Velocity_UV_New(i, j, k) *              &
                                     DUZ_VZ(i, j, k) / WaterColumnUV(i, j)

                    enddo do4

                endif cd6

do3:            do K=kbottom, KUB

                    if (Me%Relaxation%ReferenceVelocity /= BarotrVel_)                  &
                        VelModel  = Velocity_UV_New(i, j, k)

                    if     (Me%ComputeOptions%LocalSolution == AssimilaPlusSubModel_  .or.  &
                            Me%ComputeOptions%LocalSolution == AssimilaGaugeSubmodel_) then

                        VelReference = SubModel_UV_New(i, j, k)

                        do iL =1, NFieldsUV3D
                            VelReference = VelReference + List3D(iL)%VelAssimilation3D(i, j, k)
                        enddo

                        do iL =1, NFieldsUV2D
                            VelReference = VelReference + List2D(iL)%VelAssimilation2D(i, j)
                        enddo

                    elseif (Me%ComputeOptions%LocalSolution == Submodel_)             then

                        VelReference = SubModel_UV_New(i, j, k)

                    elseif (Me%ComputeOptions%LocalSolution == GaugePlusSubModel_)    then

                        VelReference = SubModel_UV_New(i, j, k)

                    elseif (Me%ComputeOptions%LocalSolution == NoLocalSolution_ .or.    &
                            Me%ComputeOptions%LocalSolution == AssimilationField_ .or.  &
                            Me%ComputeOptions%LocalSolution == AssimilaGauge_) then

                        VelReference = 0.
                        do iL =1, NFieldsUV3D
                            VelReference = VelReference + List3D(iL)%VelAssimilation3D(i, j, k)
                        enddo

                        do iL =1, NFieldsUV2D
                            VelReference = VelReference + List2D(iL)%VelAssimilation2D(i, j)
                        enddo


                    elseif (Me%ComputeOptions%LocalSolution == Gauge_) then

                        stop 'ModifyRelaxAceleration - ModuleHydrodynamic - ERR40'

                    endif

                    if (Me%Relaxation%BrFroceOnlyAssimil) then

                        VelReference = 0.
                        do iL =1, NFieldsUV3D
                            VelReference = VelReference + List3D(iL)%VelAssimilation3D(i, j, k)
                        enddo

                        do iL =1, NFieldsUV2D
                            VelReference = VelReference + List2D(iL)%VelAssimilation2D(i, j)
                        enddo

                    endif

                    ![m/s^2]                   = []*([m/s] - [m/s]) / [s]
                    Relax_Aceleration(i, j, k) = CoefCold  * (VelReference - VelModel)/ DecayTime(i, j, k)


                enddo do3

            endif cd5

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyRelaxAceleration")
        endif

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR50")

        do iL =1, NFieldsUV3D
            call UnGetAssimilation(Me%ObjAssimilation, List3D(iL)%VelAssimilation3D,    &
                                   STAT        = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR60")
        enddo

        do iL =1, NFieldsUV2D
            call UnGetAssimilation(Me%ObjAssimilation, List2D(iL)%VelAssimilation2D,    &
                                   STAT        = status)
            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "ModifyRelaxAceleration - Hydrodynamic - ERR60")
        enddo

        deallocate(List3D)
        deallocate(List2D)

        nullify(Relax_Aceleration)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV        )
        nullify(Velocity_UV_New  )
        nullify(WaterColumnUV    )
        nullify(DUZ_VZ           )

        if (Me%SubModel%ON)                                                 &
            nullify(SubModel_UV_New)


    End Subroutine ModifyRelaxAceleration

    !End------------------------------------------------------------------------------

    Subroutine ModifyRelaxAcelerationVert


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_W, DecayTime,                    &
                                              VelAssimilation
        integer, dimension(:,:,:), pointer :: OpenPoints3D
        integer, dimension(:,:),   pointer :: KFloor_Z
        type (T_Time)                      :: CurrentTime, BeginTime, EndTime
        real                               :: ColdPeriod, ColdOrder, DT_RunPeriod, CoefCold, VelModel
        integer                            :: status
        integer                            :: ILB, IUB, JLB, JUB, KUB, kbottom, i, j, k
        integer                            :: CHUNK

    !------------initialization----

        !Begin - Shorten variables name

        OpenPoints3D         => Me%External_Var%OpenPoints3D
        KFloor_Z             => Me%External_Var%KFloor_Z
        Velocity_W           => Me%Velocity%Vertical%CartesianOld


        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB

        EndTime     = Me%EndTime
        BeginTime   = Me%BeginTime
        CurrentTime = Me%CurrentTime

        !End - Shorten variables name

        call GetAssimilationField(Me%ObjAssimilation,                                   &
                                  ID              = VelocityW_,                         &
                                  Field3D         = VelAssimilation,                    &
                                  STAT            = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR10")


        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID              = VelocityW_,                         &
                                  CoefField3D     = DecayTime,                          &
                                  ColdRelaxPeriod = ColdPeriod,                         &
                                  ColdOrder       = ColdOrder,                          &
                                  STAT            = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR20")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime) .and. Me%FirstIteration) then
            write(*,*) "ModifyRelaxAcelerationVert - Hydrodynamic - WRN30"
            write(*,*) "Cold Relaxation Aceleration period larger than simulation period"
        endif

cd4:    if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else  cd4
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif cd4

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyRelaxAcelerationVert")
        endif

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd5:        if (OpenPoints3D(I, J, KUB) == Covered .or. Me%External_Var%BoundaryPoints(i, j) == Boundary) then

                kbottom = KFloor_Z(I, J)

                VelModel  = 0.

do4:            do K=kbottom+1, KUB

                    ![m/s]                 = []* [s] * ([m/s] - [m/s]) / [s]
                    Me%THOMAS%Ti (i, j, k) = Me%THOMAS%Ti (i, j, k) + CoefCold  * Me%WaterLevel%DT *         &
                                             (VelAssimilation(i,j,k) - Velocity_W(i,j,k))/ DecayTime(i, j, k)

                enddo do4
            endif cd5

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyRelaxAcelerationVert")
        endif

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR50")

        call UnGetAssimilation(Me%ObjAssimilation, VelAssimilation, STAT = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxAcelerationVert - Hydrodynamic - ERR60")


        nullify(OpenPoints3D     )
        nullify(KFloor_Z         )
        nullify(Velocity_W       )




    End Subroutine ModifyRelaxAcelerationVert

    !End------------------------------------------------------------------------------

    Subroutine DumpingWaveStress(AuxTauWaves_UV)


        !Arguments------------------------------------------------------------
        real,    dimension(:,:), pointer   :: AuxTauWaves_UV


        !Local---------------------------------------------------------------------
        integer                            :: i, j
        !$ integer                         :: CHUNK

        !Begin---------------------------------------------------------------------

        !$OMP PARALLEL PRIVATE(I,J)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  j = Me%WorkSize%JLB, Me%WorkSize%JUB
do2:    do  i = Me%WorkSize%ILB, Me%WorkSize%IUB

cd1:        if (Me%External_Var%OpenPoints3D(i, j, Me%WorkSize%KUB) == Covered ) then
                AuxTauWaves_UV(i,j) = AuxTauWaves_UV(i, j) * Me%WaveStress%DumpCoef(i,j)
            endif cd1

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL


    End Subroutine DumpingWaveStress

    !End------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the aceleration due to the geostrophic velocity             !
    !  resultant from Cooper and Haines Method.                                            !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: RelaxAltimGeostAceleration                                                   !
    ! Author: Joao Nogueira (May 2006)                                                     !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ModifyAltimAceleration


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Altim_Relax_Aceleration
        real,    dimension(:,:,:), pointer :: GeostrophicVelocity_UV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        integer                            :: kbottom
        integer                            :: I, J, K
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real                               :: AltimDecayTime
        !$ integer                         :: CHUNK

        !------------initialization----

        !Begin shorten variables---------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyAltimAceleration")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Velocity_UV_Old             => Me%Velocity%Horizontal%UV%Old
        GeostrophicVelocity_UV      => Me%Geostroph%UV
        Altim_Relax_Aceleration     => Me%Forces%Altim_Relax_Aceleration

        ComputeFaces3D_UV           => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV                   => Me%External_Var%KFloor_UV

        AltimDecayTime              = Me%External_Var%AltimDecayTime


        !End - Shorten variables name


        if (Me%CurrentTime .le.( Me%BeginTime +                                         &
            (10.* Me%ComputeOptions%AltimetryAssimilation%DT_Compute))) then

            !Compute GeostrophicVelocity_VU


            call ComputeGeostrophicVelocity(Me%External_Var%AltimWaterLevelAnalyzed,    &
                                            Me%External_Var%AltimSigmaDensAnalyzed)
        endif



        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: new simple parallelization
        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then

                kbottom = KFloor_UV(I, J)

    do3:        do K=kbottom, KUB


                    Altim_Relax_Aceleration(I, J, K) = 0.


                    ! Compute aceleration force  [m/s^2]  =  [m/s]/[s]

                    Altim_Relax_Aceleration(I, J, K) = (GeostrophicVelocity_UV(I, J, K) &
                                                        - Velocity_UV_Old(I, J, K))/    &
                                                        AltimDecayTime

                enddo do3

            end if cd1


        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !Nullify auxiliar pointers
        nullify (Velocity_UV_Old)
        nullify (GeostrophicVelocity_UV)
        nullify (Altim_Relax_Aceleration)

        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyAltimAceleration")
        endif

    End Subroutine ModifyAltimAceleration


    !End------------------------------------------------------------------------------



    Subroutine ComputeGeostrophicVelocity (WaterLevel, SigmaDens)

        !
        !   This routine computes the geostrophic velocity with thermal wind equations.
        !

        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: SigmaDens
        real,    dimension(:,:)  , pointer :: WaterLevel


        !Local---------------------------------------------------------------------
        real,    dimension(:,:),   pointer :: DUX_VY, Coriolis_Freq

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: F_UV
        integer                            :: di, dj, k, kbottom
        integer                            :: I, IAux
        integer                            :: J, JAux
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, dir


        !------------initialization----

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Coriolis_Freq                   => Me%External_Var%Coriolis_Freq

        ComputeFaces3D_UV               => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV                       => Me%External_Var%KFloor_UV

        DUX_VY                          => Me%External_Var%DUX_VY


        !End - Shorten variables name

ddir:   do dir = 1, 2

        di  = Me%Direction%di
        dj  = Me%Direction%dj


        Me%Geostroph%PressGrad   (:,:,:) = 0.

        ! Compute Pressure Gradient

        call ComputeGeostPressGrad(SigmaDens, WaterLevel, Me%Geostroph%PressGrad)

        ! Compute gestrophic Velocity

        Me%Geostroph%AuxDesCentre(:,:,:) = 0.

do1:    do  J = JLB, JUB-1
do2:    do  I = ILB, IUB-1


cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then

                kbottom = KFloor_UV(I, J)

                IAux    = I-di
                JAux    = J-dj


    do3:        do K=kbottom, KUB

                    if (Me%ComputeOptions%Coriolis) then

                        ! Interpolates Coriolis_Freq for the face
                        F_UV = (DUX_VY(IAux, JAux) * Coriolis_Freq(I, J) + DUX_VY(I, J) &
                               * Coriolis_Freq(IAux, JAux))                             &
                                /(DUX_VY(IAux, JAux) + DUX_VY(I, J))

                        Me%Geostroph%AuxDesCentre(I, J, K)= (di - dj) *                 &
                                                     Me%Geostroph%PressGrad (I, J, K)   &
                                                     /(F_UV * SigmaDensityReference)

                    else

                        Write(*,*) 'You cannot compute Geostrophic Velocity without Coriolis aceleration'

                        Stop 'ComputeGeostrophicVelocity - ModuleHydrodynamic - ERR01'

                    endif



                enddo do3

            end if cd1


        enddo do2
        enddo do1

        call ChangeDirection

        ! Correct geostrophic velocity faces
        call CoriolisInterpolation(Me%Geostroph%AuxDesCentre, Me%Geostroph%UV)

       enddo ddir


        !Nullify auxiliar pointers


        nullify (Coriolis_Freq)

        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)

        nullify (DUX_VY)


    End Subroutine ComputeGeostrophicVelocity


    !End------------------------------------------------------------------------------


    Subroutine ComputeGeostPressGrad (SigmaDens, WaterLevel,                            &
                                      GeostrophicPressureGradient_UV)



        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: GeostrophicPressureGradient_UV
        real,    dimension(:,:,:), pointer :: SigmaDens
        real,    dimension(:,:)  , pointer :: WaterLevel


        !Local---------------------------------------------------------------------


        ! Compute baroclinic part of pressure gradient using the same model integration

        call Modify_ROX3(SigmaDens, GeostrophicPressureGradient_UV)

        ! Compute barotropic part of pressure gradient using level gradient

        call Compute_SurfaceAceleration(WaterLevel, GeostrophicPressureGradient_UV)


    End Subroutine ComputeGeostPressGrad


    !End------------------------------------------------------------------------------


    Subroutine Compute_SurfaceAceleration (WaterLevel, GeostrophicPressureGradient_UV)


        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: GeostrophicPressureGradient_UV
        real,    dimension(:,:)  , pointer :: WaterLevel


        !Local---------------------------------------------------------------------


        real,    dimension(:,:  ), pointer :: DUX_VY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV
        Integer                            :: i, j, di, dj, k, kbottom, ileft, jleft

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real                               :: GradLevel

    !------------initialization----

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        KFloor_UV         => Me%External_Var%KFloor_UV

        DUX_VY            => Me%External_Var%DUX_VY



        !End - Shorten variables name



    !------------Main cicle--------

do1:     do J = JLB, JUB
do2:     do I = ILB, IUB

cd1:        if (ComputeFaces3D_UV(i, j, KUB)== Covered) then

                kbottom = KFloor_UV(i, j)

                ileft = i - di
                jleft = j - dj

                ! Calcular o gradiente de nivel

                GradLevel = 2 * (WaterLevel(i,j) - WaterLevel(ileft,jleft))             &
                            /(DUX_VY(ileft,jleft)+DUX_VY(i,j))* SigmaDensityReference

do3:            do  k=KUB, kbottom,-1

                ! Somar o gradiente de nivel ao que ja tinha

                    GeostrophicPressureGradient_UV(i,j,k) =                             &
                                            (GeostrophicPressureGradient_UV(i,j,k)      &
                                            - GradLevel) * Gravity

                enddo do3


            end if cd1

        enddo do2
        enddo do1




        !Nullify auxiliar pointers


        nullify (ComputeFaces3D_UV)
        nullify (BoundaryFacesUV)
        nullify (KFloor_UV)

        nullify (DUX_VY)


    End Subroutine Compute_SurfaceAceleration


    !End------------------------------------------------------------------------------


    Subroutine CoriolisInterpolation(Geostrophic_UV, Geostrophic_UV_New)

        !Arguments------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Geostrophic_UV
        real,    dimension(:,:,:), pointer :: Geostrophic_UV_New


        !Local---------------------------------------------------------------------

        real,    dimension(:,:),   pointer :: DXX_YY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, LandBoundaryFacesVU
        integer, dimension(:,:),   pointer :: KFloor_UV


        integer                            :: di, dj, k, kbottom, NoLand1, NoLand2
        integer                            :: I, I1, I2, I3
        integer                            :: J, J1, J2, J3
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: Iaux
        real                               :: VUvar1, VUvar2, VUAverage


        !------------initialization----

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        LandBoundaryFacesVU  => Me%External_Var%LandBoundaryFacesVU
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        DXX_YY               => Me%External_Var%DXX_YY


        !End - Shorten variables name


        !------------Main cicle--------

do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd1:        if (ComputeFaces3D_UV(I, J, KUB) == Covered) then

                kbottom = KFloor_UV(I, J)


                I1    = I+dj-di
                J1    = J-dj+di
                I2    = I+dj
                J2    = J+di
                I3    = I-di
                J3    = J-dj


    do3:        do K=kbottom, KUB


                    !Null gradient is admitted in the land boundary.
                    if ((LandBoundaryFacesVU(I1, J1, K) +                               &
                         LandBoundaryFacesVU(I2, J2, K)) == 0) then

                        VUvar1 = (Geostrophic_UV(I1, J1, K) * DXX_YY(I2, J2) +          &
                                  Geostrophic_UV(I2, J2, K) * DXX_YY(I1, J1))/          &
                                 (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                        NoLand1  = 1

                    else

                        VUvar1 = (1 - LandBoundaryFacesVU(I1, J1, K))                   &
                                  * Geostrophic_UV(I1, J1, K)                           &
                                  + (1 - LandBoundaryFacesVU(I2, J2, K))                &
                                  * Geostrophic_UV(I2, J2, K)

                        NoLand1  = 2 - LandBoundaryFacesVU(I1, J1, K)                   &
                                   - LandBoundaryFacesVU(I2, J2, K)

                    endif

                    if ((LandBoundaryFacesVU(I3, J3, K) +                               &
                         LandBoundaryFacesVU(I, J, K)) == 0) then

                        VUvar2 = (Geostrophic_UV(I3, J3, K) * DXX_YY(I, J)   +          &
                                  Geostrophic_UV(I,   J, K) * DXX_YY(I3, J3))/          &
                                 (DXX_YY(I3, J3) +  DXX_YY(I, J))

                       NoLand2  = 1

                    else

                       VUvar2 = (1 - LandBoundaryFacesVU(I3, J3, K))                    &
                                 * Geostrophic_UV(I3, J3, K)                            &
                                 + (1 - LandBoundaryFacesVU(I,   J, K))                 &
                                 * Geostrophic_UV(I,   J, K)

                       NoLand2  = 2 - LandBoundaryFacesVU(I3, J3, K)                    &
                                  - LandBoundaryFacesVU(I,   J, K)

                    endif

                    Iaux = NoLand1 + NoLand2

                    if (Iaux > 0) then
                        VUAverage  = (VUvar1 * NoLand1 + VUvar2 * NoLand2) / real(Iaux)
                    else
                        VUAverage  = 0.
                    endif

                    Geostrophic_UV_New(I, J, K) = VUAverage

                enddo do3

            end if cd1

        enddo do2
        enddo do1


        !Nullify auxiliar pointers

        nullify (ComputeFaces3D_UV)
        nullify (KFloor_UV)
        nullify (LandBoundaryFacesVU)

        nullify (DXX_YY)


   End Subroutine CoriolisInterpolation

    !End------------------------------------------------------------------------------




    Subroutine ModifyRelaxHorizAdv


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Horizontal_Transport
        real,    dimension(:,:,:), pointer :: DecayTime
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DecayTimeMin

        integer                            :: HT_ID, status
        integer                            :: ILB, IUB, JLB, JUB, KUB, kbottom, i, j, k

        integer                            :: CHUNK

    !------------initialization----

        !Begin - Shorten variables name

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        Horizontal_Transport => Me%Forces%Horizontal_Transport


        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB


cd2:    if      (Me%Direction%XY == DirectionX_) then

            HT_ID = HorizontalTransportX_


        else if (Me%Direction%XY == DirectionY_) then cd2

            HT_ID = HorizontalTransportY_

        endif cd2

        call GetAssimilationCoef (Me%ObjAssimilation,                       &
                                  ID          = HT_ID,                                   &
                                  Minimum     = DecayTimeMin,                            &
                                  CoefField3D = DecayTime,                               &
                                  STAT        = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxHorizAdv - Hydrodynamic - ERR01")

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyRelaxHorizAdv")
        endif

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd5:        if (ComputeFaces3D_UV(I, J, KUB) == Covered ) then

                kbottom = KFloor_UV(I, J)

do3:            do K=kbottom, KUB

                    ![m3/s*m/s]                   = [m3/s*m/s] * [s/s]
                    Horizontal_Transport(i, j, k) = Horizontal_Transport(i, j, k)*(1. - DecayTimeMin / DecayTime(i, j, k))


                enddo do3

            endif cd5

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyRelaxHorizAdv")
        endif

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyRelaxHorizAdv - Hydrodynamic - ERR02")


        nullify(ComputeFaces3D_UV   )
        nullify(KFloor_UV           )
        nullify(Horizontal_Transport)

    End Subroutine ModifyRelaxHorizAdv

    !End------------------------------------------------------------------------------

! Modified by Matthias DELPEY - 17/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Modify_WaveForces3D


        !Variables Categories-----------------------------------------------------------------


        !Arguments--------------------------------------------------------------------------


        !Local-----------------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Wave3DExplicit_Acceleration

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV

        integer                            :: I, J, K

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !--------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        !End - Shorten variables name

        call SetMatrixValue(Wave3DExplicit_Acceleration, Me%Size, 0.0)


        ! EXPLONENTIAL PROFILE PARAMETERIZATION FOR RADIATION STRESSES
        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then

            call Compute_RadiationStressProfile

        endif


        ! GENERALIZED LAGRANGIAN MEAN APPROACH
        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            ! Wave induced pressure contribution
            call Compute_WaveInducedPressure

            if (Me%ComputeOptions%WaveForcing3D_Two == TauWalstra) then
                ! Wave to ocean momentum flux (breaking waves contribution)
                ! Linear repartition from the surface to depth equal to Hrms/2
                call Compute_WaveToOceanMomentum_Walstra
            endif

            !Vortex force contribution
            call Compute_WaveVortexForce
            ! call Compute_WaveVortexForce2

        endif


        do  k = KLB, KUB
        do  j = JLB, JUB
        do  i = ILB, IUB

            ! Large values (FillReal_Value) in non covered faces
            Wave3DExplicit_Acceleration (i, j, k) = Wave3DExplicit_Acceleration (i, j, k)    * &
                                               ComputeFaces3D_UV(i, j, k)                    + &
                                               (1. - ComputeFaces3D_UV(i, j, k))             * &
                                               FillValueReal

        enddo
        enddo
        enddo


        !Nullify auxiliar pointers
        nullify(Wave3DExplicit_Acceleration)
        nullify(ComputeFaces3D_UV)

    end Subroutine Modify_WaveForces3D


! Modified by Matthias DELPEY - 01/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 03/08/2011 - 04/08/2011 - 12/09/2011 - 15/09/2011 -10/10/2011 - 08/03/2011

    Subroutine Compute_RadiationStressProfile

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV

        real,    dimension(:,:,:), pointer :: Density, SZZ, DUZ_VZ, Wave3DExplicit_Acceleration

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DZX_ZY, TauWaves_UV, WaveLength, &
                                              Waterlevel, WaterColumnUV

        real,    dimension(:), allocatable :: SUZ_VZ

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real,  dimension(:,:), allocatable :: WAVN

        real                               :: force_2D, TauFace, FaceDensity, WlevFace, BathyFace, Vprofile

        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !DT_Velocity          =  Me%Velocity%DT

        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration

        Volume_UV            => Me%External_Var%Volume_UV

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY
        DUZ_VZ               => Me%External_Var%DUZ_VZ

        SZZ                  => Me%External_Var%SZZ

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Density              => Me%External_Var%Density

        TauWaves_UV          => Me%External_Var%TauWaves_UV

        Waterlevel           => Me%Waterlevel%Old
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        WaveLength           => Me%External_Var%WaveLength

        !End - Shorten variables name


        allocate( SUZ_VZ(KLB-1:KUB) )

        allocate(WAVN(ILB:IUB,JLB:JUB))
        !WAVN(:,:) = 2*Pi/WaveLength(:,:)
        !WAVN = 2*Pi/150.


    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth = i-di
            jWest  = j-dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB)==Covered) then

                Kbottom          = KFloor_UV(i, j)

                if (WaveLength(i,j) > 10.) then
                    WAVN(i,j) = 2*Pi/WaveLength(i,j)
                else
                    WAVN(i,j) = 2*Pi/10.
                endif

                TauFace  = Face_Interpolation(TauWaves_UV(I,J), TauWaves_UV(iSouth, jWest), &
                                              DUX_VY(I, J), DUX_VY(iSouth, jWest))

                !![M*m/s]   [s] * [m] * [m] * [M*m/s^2/m^2]
                !Aux_2D   = DT_Velocity * DZX_ZY(iSouth, jWest) * DYY_XX(I, J) * TauFace

                ![M*m/s^2] = [m] * [m] * [M*m/s^2/m^2] = force
                force_2D   = DZX_ZY(iSouth, jWest) * DYY_XX(I, J) * TauFace


                WlevFace = Face_Interpolation(Waterlevel(I,J), Waterlevel(iSouth, jWest), &
                                              DUX_VY(I, J), DUX_VY(iSouth, jWest))

                BathyFace = WaterColumnUV(I,J) - WlevFace    ! (positive downward)

                ! SUZ computation = equivalent of SZZ for the U,V-cell
                ! (Attention! Contralily to SZZ, SUZ is positive updwards!)
                do k = Kbottom-1, KUB-1
                    SUZ_VZ(k) = WlevFace - SUM( DUZ_VZ(i,j,k+1:KUB) )
                enddo
                SUZ_VZ(KUB) = WlevFace

    dok1:       do k = Kbottom, KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        FaceDensity  = Face_Interpolation(Density(I, J, k),                  &
                                                          Density(iSouth, jWest, k),       &
                                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))
                    else

                        FaceDensity  = SigmaDensityReference

                    endif

                    if ( WAVN(i,j) * WaterColumnUV(I,J) < 50.) then  ! (stability threshold)

                        ! Vertical profile parameterization [1/m * m]
                        ! Vprofile is the vertical integration over the U,V-cell of the depth dependent part of
                        ! the stress.
                        Vprofile = 1 / ( exp(WAVN(i,j) * WlevFace) - exp(- WAVN(i,j) * BathyFace ) ) &
                                     * ( exp( WAVN(i,j) * SUZ_VZ(k) ) - exp( WAVN(i,j) * SUZ_VZ(k-1) ) )

                    else
                        ! In deep water, wave stress is assumed to be a surface stress
                        if (k==KUB) then
                            Vprofile = 1.
                        else
                            Vprofile = 0.
                        endif

                    endif

                    !![m/s]                                 [M*m/s] / [m^3] / [M/m^3] * [m/m]
                    !TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) + Aux_2D / Volume_UV(i, j, k) / FaceDensity &
                    !                                     * Vprofile

                    ![m/s^2]                            = [m/s^2] +  [M*m/s^2] / [m^3] / [M/m^3] * [m/m]
                    Wave3DExplicit_Acceleration(i,j,k)  = Wave3DExplicit_Acceleration(i,j,k)           &
                                                          + force_2D / Volume_UV(i, j, k) / FaceDensity  &
                                                          * Vprofile


                    ! Forcing output field
                    Me%WaveRad3D%WaveExpRadUV(i,j,k) = TauWaves_UV(I,J) * Vprofile

                enddo dok1

            endif cd1

        enddo doj
        enddo doi

        ! Deallocate instance
        deallocate(WAVN)
        deallocate(SUZ_VZ)

        !Nullify auxiliar pointers
        ! nullify(TiCoef_3D)
        nullify(Wave3DExplicit_Acceleration)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)
        nullify(DUZ_VZ)

        nullify(Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(TauWaves_UV, Density)
        nullify(WaveLength)

        nullify(WaterColumnUV, Waterlevel)

    End Subroutine Compute_RadiationStressProfile

        !End-----------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 27/07/2011 - 02/08/2011 - 15/09/2011 - 25/11/2011

    Subroutine Compute_WaveInducedPressure


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Wave3DExplicit_Acceleration, Wave3DExplicit_FPressureAccelUV

        real,    dimension(:,:  ), pointer :: DZX_ZY, JWaves

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        ! real                               :: a, b, c, d

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !DT_Velocity          =  Me%Velocity%DT

        Wave3DExplicit_FPressureAccelUV => Me%Forces%Wave3DExplicit_FPressureAccelUV
        Wave3DExplicit_Acceleration     => Me%Forces%Wave3DExplicit_Acceleration

        DZX_ZY               => Me%External_Var%DZX_ZY

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        JWaves               => Me%External_Var%WaveInducedPressureJ

        !End - Shorten variables name

            do j=JLB, JUB
            do i=ILB, IUB

                iSouth  = i-di
                ! iSouth  = i
                jWest   = j-dj

                if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                    Kbottom = KFloor_UV(i, j)

                    ! Analogie avec la pression barotrope et barocline: la somme des flux de J  travers les 6 faces
                    ! de la cellule, i.e. 4 faces laterales + face inf et faces sup (inclines en sigma, donc le flux
                    ! a une comp horiz), est equivalent  (Jij - Jij-1) * Area o Area = VolumeUV / DZX_ZY.
                    ! D'o l'expression ci-dessous en systme de coordonnes quelconque :
                    ! flux de J = Area * DeltaJ
                    ! flux de QDM = Density * flux de J
                    ! Acceleration = flux de QDM / (Density*Volume) = Area*DeltaJ/Volume = DeltaJ/DZX_ZY

                    do k = Kbottom, KUB

                        ! [m/s^2] = [m^2/s^2] / [m]
                        Wave3DExplicit_FPressureAccelUV(i,j,k) = - ( JWaves(i, j) - JWaves(iSouth, jWest) )  &
                                                                 / DZX_ZY(iSouth, jWest)

                        ! [m/s^2] = [m/s^2] + [m/s^2]
                        Wave3DExplicit_Acceleration(i,j,k)  = Wave3DExplicit_Acceleration(i,j,k)             &
                                                            + Wave3DExplicit_FPressureAccelUV(i,j,k)

                    enddo

                endif

            enddo
            enddo

        !Nullify auxiliar pointers
        !nullify(TiCoef_3D)
        nullify(Wave3DExplicit_Acceleration, Wave3DExplicit_FPressureAccelUV)

        nullify(DZX_ZY)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(JWaves)

    End Subroutine Compute_WaveInducedPressure

        !End-----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 12/09/2011 - 15/09/2011 - 25/10/2011 - 18/11/2011 - 24/11/2011

Subroutine Compute_WaveToOceanMomentum_Walstra


        ! Cette routine est construite en partie par analogie  Velocity_WaveStress (forcage par
        ! un champ de stress 2D dont on parametre un profil vertical...).
        ! Le forcage depend cependant ici de z mais sa forme relativement simple permet
        ! le calcul de l'integrale verticale de la force : lorsqu'on integre la force sur
        ! le volume, on considere qu'elle est constante horizontalement mais pas
        ! verticalement (different de ce que fait MOHID pour la pression barotrope
        ! par exemple...)


        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:,:), pointer :: SZZ, DUZ_VZ, &
                                              Wave3DExplicit_FBreakingAccelUV, Wave3DExplicit_Acceleration

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DZX_ZY, Two_UV, Waterlevel, Hs


        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:  ), pointer :: KFloor_UV

        real,    dimension(:), allocatable :: SUZ_VZ

        real                               :: Z0

        real                               :: force_2D, Two_Face, WlevFace, Vprofile

        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest, INDEXZ0

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !DT_Velocity          =  Me%Velocity%DT

        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration
        Wave3DExplicit_FBreakingAccelUV => Me%Forces%Wave3DExplicit_FBreakingAccelUV

        Volume_UV            => Me%External_Var%Volume_UV

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY
        DUZ_VZ               => Me%External_Var%DUZ_VZ

        SZZ                  => Me%External_Var%SZZ

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Two_UV               => Me%External_Var%WaveToOceanMomentum_UV
        Hs                   => Me%External_Var%WaveHeight

        Waterlevel           => Me%Waterlevel%Old

        !End - Shorten variables name


        allocate( SUZ_VZ(KLB-1:KUB) )


    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth = i-di
            jWest  = j-dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB)==Covered) then

                Kbottom          = KFloor_UV(i, j)

                Two_Face  = Face_Interpolation(Two_UV(I,J), Two_UV(iSouth, jWest), &
                                              DUX_VY(I, J), DUX_VY(iSouth, jWest))

                WlevFace  = Face_Interpolation(Waterlevel(I,J), Waterlevel(iSouth, jWest), &
                                              DUX_VY(I, J), DUX_VY(iSouth, jWest))

                !![M*m/s]   [s] * [m] * [m] * [M*m*s^-2/m^2]
                !Aux_2D   = DT_Velocity * DZX_ZY(iSouth, jWest) * DYY_XX(I, J) * Two_Face

                ![M*m*s^-2] = [m] * [m] * [M*m*s^-2/m^2]
                force_2D   = DZX_ZY(iSouth, jWest) * DYY_XX(I, J) * Two_Face


                ! SUZ computation = equivalent of SZZ for the U,V-cell
                ! (Attention! Contrairement a SZZ, SUZ est compte positif vers le haut!)
                do k = Kbottom-1, KUB-1
                    SUZ_VZ(k) = WlevFace - SUM( DUZ_VZ(i,j,k+1:KUB) )
                enddo
                SUZ_VZ(KUB) = WlevFace

                ! Index of the closest sigma level from level (WlevFace - Hrms/2)
                ! (Rem: on ajoute -Kbottom parce que les indices de SUZ_VZ sont entre 0 et KUB, alors
                ! que MINLOC renvoie des valeurs entre Kbottom et KUB+1)
                INDEXZ0 = -Kbottom + MINLOC( ABS( SUZ_VZ(:) - (WlevFace - 0.5 * Hs(i,j) / 1.4157) ), dim = 1 )

                ! Depth of zero momentum flux (the flux is always at least applied to the surface layer)
                if (INDEXZ0 == KUB) then
                    Z0 = SUZ_VZ(KUB-1)
                else
                    Z0 = SUZ_VZ(INDEXZ0)
                endif


    dok1:       do k = Kbottom, KUB

                    ! Vertical profile parameterization [1/m*m] : linear from Z0 to WlevFace.
                    ! Vprofile is the vertical integration over the U,V-cell of the depth dependent part of
                    ! the stress.
                    if (k >= INDEXZ0+1) then

                        ! [ ]    =    [1/m^2] * [m] * [m]
                        Vprofile = 2 / (WlevFace - Z0)**2             &
                                   * DUZ_VZ(i,j,k) * ( 0.5*(SUZ_VZ(k) + SUZ_VZ(k-1)) - Z0 )

                    else

                        Vprofile = 0.

                    endif


                    ![m*s^-2]                      = [M*m*s^-2] / [m^3] / [M/m^3] * [m/m]
                    Wave3DExplicit_FBreakingAccelUV(i,j,k)  = force_2D / Volume_UV(i, j, k) * Vprofile


                    ![m*s^-2]                     =      [m*s^-2] + [m*s^-2]
                    Wave3DExplicit_Acceleration(i,j,k)  = Wave3DExplicit_Acceleration(i,j,k)             &
                                                         + Wave3DExplicit_FBreakingAccelUV(i,j,k)

                enddo dok1

            endif cd1

        enddo doj
        enddo doi


        !Nullify auxiliar pointers
        nullify(Wave3DExplicit_Acceleration)
        nullify(Wave3DExplicit_FBreakingAccelUV)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)
        nullify(DUZ_VZ)

        deallocate(SUZ_VZ)

        nullify(Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(Two_UV)

    End Subroutine Compute_WaveToOceanMomentum_Walstra


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 15/09/2011 - 25/10/2011 - 30/10/2011 - 21/11/2011 - 03/08/2012

    Subroutine Compute_WaveVortexForce


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Wave3DExplicit_Acceleration, Wave3DExplicit_FVortexAccelUV

        real,    dimension(:,:  ), pointer :: DZX_ZY, DXX_YY

        real, dimension(:,:,:), pointer    :: StokesVel_UV, StokesVel_VU,                   &
                                              Velocity_UV_Old, Velocity_VU_Old

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU

        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8)                            :: FVortexAcceleration_1, FVortexAcceleration_2

        real                               :: VUvar1, VUvar2,                               &
                                              Vel_UV_WestSouth, Vel_VU_WestSouth,           &
                                              Vel_UV_EastNorth, Vel_VU_EastNorth,           &
                                              StokesVel_VU_center

        integer                            :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: di, dj, Kbottom, I1, I2, I3, I4, J1, J2,      &
                                              J3, J4, Noland1, Noland2, Iaux

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !DT_Velocity          =  Me%Velocity%DT

        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration

        Wave3DExplicit_FVortexAccelUV => Me%Forces%Wave3DExplicit_FVortexAccelUV

        DZX_ZY               => Me%External_Var%DZX_ZY
        DXX_YY               => Me%External_Var%DXX_YY

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU    => Me%External_Var%ComputeFaces3D_VU
        KFloor_UV            => Me%External_Var%KFloor_UV

        ! The Stokes velocity considered here must imperatively be the same as for the
        ! water flux computation (see Modify_Horizontal_Waterflow)
        StokesVel_UV         => Me%StokesVel%Horizontal%UV%Old
        StokesVel_VU         => Me%StokesVel%Horizontal%VU%Old

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_VU_Old      => Me%Velocity%Horizontal%VU%Old

        !End - Shorten variables name


            do j=JLB, JUB
            do i=ILB, IUB

                I1    = i+dj-di
                J1    = j-dj+di

                I2    = i+dj
                J2    = j+di

                I3    = i-di
                J3    = j-dj

                I4    = i+di
                J4    = j+dj

                if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                    Kbottom = KFloor_UV(i, j)

                    do k = Kbottom, KUB

                        ! Interpolation of U,V in order to get spatial gradients centered at U,V-points
                        ! The methodology used assumes a nul gradient of tangential velocity at land
                        ! boundaries

                        Vel_UV_WestSouth = ( Velocity_UV_Old(i , j , k) + Velocity_UV_Old(I3, J3, k) ) / 2

                        Vel_UV_EastNorth = ( Velocity_UV_Old(i , j , k) + Velocity_UV_Old(I4, J4, k) ) / 2

                        Vel_VU_WestSouth = ( Velocity_VU_Old(I3, J3, k) + Velocity_VU_Old(I1, J1, k) ) / 2

                        Vel_VU_EastNorth = ( Velocity_VU_Old(i , j , k) + Velocity_VU_Old(I2, J2, k) ) / 2


                        ! Interpolation of Vs,Us at U,V point.

                        if (ComputeFaces3D_VU(I1, J1, k) == 1 .and. ComputeFaces3D_VU(I2, J2, k) == 1) then
                            VUvar1 = (StokesVel_VU(I1, J1, k) * DXX_YY(I2, J2)                                    &
                                      + StokesVel_VU(I2, J2, k) * DXX_YY(I1, J1))                                 &
                                     / (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                            NoLand1 = 1

                        else
                            VUvar1 = StokesVel_VU(I1, J1, k) * ComputeFaces3D_VU(I1, J1, k)                       &
                                   + StokesVel_VU(I2, J2, k) * ComputeFaces3D_VU(I2, J2, k)

                            NoLand1 = ComputeFaces3D_VU(I1, J1, k) + ComputeFaces3D_VU(I2, J2, k)

                        endif

                        if (ComputeFaces3D_VU(I3, J3, k) == 1 .and. ComputeFaces3D_VU(i,   j, k) ==1) then
                            VUvar2 = (StokesVel_VU(I3, J3, k) * DXX_YY(i, j)                                      &
                                      + StokesVel_VU(i,   j, k) * DXX_YY(I3, J3))                                 &
                                     / (DXX_YY(I3, J3) +  DXX_YY(i, j))

                            NoLand2 = 1

                        else
                            VUvar2 = StokesVel_VU(I3, J3, k) * ComputeFaces3D_VU(I3, J3, k)                       &
                                   + StokesVel_VU(i,   j, k) * ComputeFaces3D_VU(i,   j, k)

                            NoLand2 = ComputeFaces3D_VU(I3, J3, k) + ComputeFaces3D_VU(i,   j, k)
                        endif

                        Iaux = NoLand1 + NoLand2

                        if (Iaux > 0) then
                            StokesVel_VU_center   = (VUvar1 + VUvar2) / real(Iaux)
                        else
                            StokesVel_VU_center   = 0.0
                        endif


                        ! [m/s^2] = [m/s] * [m/s] / [m]
                        FVortexAcceleration_1 = StokesVel_UV(i,j,k)    &
                                              * (Vel_UV_EastNorth - Vel_UV_WestSouth) / DZX_ZY(I3,J3)

                        FVortexAcceleration_2 = StokesVel_VU_center    &
                                              * (Vel_VU_EastNorth - Vel_VU_WestSouth) / DZX_ZY(I3,J3)

                        ! Test pour codage du terme appele ici WaveVortexForce
                        !if (Me%Direction%dj==1) then
                        !    FVortexAcceleration_1 = 0.
                        !    FVortexAcceleration_2 = 0.
                        !endif

                        ! [m/s^2] = [m/s^2] + [m/s^2]
                        Wave3DExplicit_FVortexAccelUV(i,j,k)  = FVortexAcceleration_1 + FVortexAcceleration_2

                        ! [m/s^2] = [m/s^2] + [m/s^2]
                        Wave3DExplicit_Acceleration(i,j,k)    = Wave3DExplicit_Acceleration(i,j,k)     &
                                                              + FVortexAcceleration_1 + FVortexAcceleration_2

                    enddo

                endif

            enddo
            enddo


        !Nullify auxiliar pointers
        nullify(Wave3DExplicit_Acceleration)
        nullify(Wave3DExplicit_FVortexAccelUV)

        nullify(DZX_ZY, DXX_YY)

        nullify(ComputeFaces3D_UV)
        nullify(ComputeFaces3D_VU)
        nullify(KFloor_UV)

        nullify(StokesVel_UV)
        nullify(StokesVel_VU)
        nullify(Velocity_UV_Old)
        nullify(Velocity_VU_Old)

    End Subroutine Compute_WaveVortexForce

        !End-----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 03/08/2012

    Subroutine Compute_WaveVortexForce2


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:), pointer :: Wave3DExplicit_Acceleration, Wave3DExplicit_FVortexAccelUV

        real(8), dimension(:,:,:), pointer :: StokesWaterFlux_XY, Volume_UV

        real,    dimension(:,:  ), pointer :: DZX_ZY, DXX_YY

        real, dimension(:,:,:), pointer    :: StokesVel_UV, StokesVel_VU,                   &
                                              Velocity_UV_Old, Velocity_VU_Old

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ComputeFaces3D_VU

        integer, dimension(:,:),   pointer :: KFloor_UV

        real(8)                            :: FVortexAcceleration_1, FVortexAcceleration_2

        real                               :: VUvar1, VUvar2,                               &
                                              Vel_UV_WestSouth, Vel_VU_WestSouth,           &
                                              Vel_UV_EastNorth, Vel_VU_EastNorth,           &
                                              StokesVel_VU_center

        integer                            :: i, j, k, IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: di, dj, Kbottom, I1, I2, I3, I4, J1, J2,      &
                                              J3, J4, Noland1, Noland2, Iaux

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !DT_Velocity          =  Me%Velocity%DT

        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration

        Wave3DExplicit_FVortexAccelUV => Me%Forces%Wave3DExplicit_FVortexAccelUV

        DZX_ZY               => Me%External_Var%DZX_ZY
        DXX_YY               => Me%External_Var%DXX_YY
        Volume_UV            => Me%External_Var%Volume_UV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU    => Me%External_Var%ComputeFaces3D_VU
        KFloor_UV            => Me%External_Var%KFloor_UV

        ! The Stokes velocity considered here must imperatively be the same as for the
        ! water flux computation (see Modify_Horizontal_Waterflow)
        StokesVel_UV         => Me%StokesVel%Horizontal%UV%Old
        StokesVel_VU         => Me%StokesVel%Horizontal%VU%Old

        StokesWaterFlux_XY   => Me%StokesWaterFluxes%XY

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_VU_Old      => Me%Velocity%Horizontal%VU%Old

        !End - Shorten variables name


            do j=JLB, JUB
            do i=ILB, IUB

                I1    = i+dj-di
                J1    = j-dj+di

                I2    = i+dj
                J2    = j+di

                I3    = i-di
                J3    = j-dj

                I4    = i+di
                J4    = j+dj

                if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                    kbottom = KFloor_UV(i, j)

                    do k = Kbottom, KUB

                        ! Interpolation of U,V in order to get spatial gradients centered at U,V-points
                        ! The methodology used assumes a nul gradient of tangential velocity at land
                        ! boundaries

                        Vel_UV_WestSouth = ( Velocity_UV_Old(i , j , k) + Velocity_UV_Old(I3, J3, k) ) / 2

                        Vel_UV_EastNorth = ( Velocity_UV_Old(i , j , k) + Velocity_UV_Old(I4, J4, k) ) / 2

                        Vel_VU_WestSouth = ( Velocity_VU_Old(I3, J3, k) + Velocity_VU_Old(I1, J1, k) ) / 2

                        Vel_VU_EastNorth = ( Velocity_VU_Old(i , j , k) + Velocity_VU_Old(I2, J2, k) ) / 2


                        ! Interpolation of Vs,Us at U,V point.

                        if (ComputeFaces3D_VU(I1, J1, k) == 1 .and. ComputeFaces3D_VU(I2, J2, k) == 1) then
                            VUvar1 = (StokesVel_VU(I1, J1, k) * DXX_YY(I2, J2)                                    &
                                      + StokesVel_VU(I2, J2, k) * DXX_YY(I1, J1))                                 &
                                     / (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

                            NoLand1 = 1

                        else
                            VUvar1 = StokesVel_VU(I1, J1, k) * ComputeFaces3D_VU(I1, J1, k)                       &
                                   + StokesVel_VU(I2, J2, k) * ComputeFaces3D_VU(I2, J2, k)

                            NoLand1 = ComputeFaces3D_VU(I1, J1, k) + ComputeFaces3D_VU(I2, J2, k)

                        endif

                        if (ComputeFaces3D_VU(I3, J3, k) == 1 .and. ComputeFaces3D_VU(i,   j, k) ==1) then
                            VUvar2 = (StokesVel_VU(I3, J3, k) * DXX_YY(i, j)                                      &
                                      + StokesVel_VU(i,   j, k) * DXX_YY(I3, J3))                                 &
                                     / (DXX_YY(I3, J3) +  DXX_YY(i, j))

                            NoLand2 = 1

                        else
                            VUvar2 = StokesVel_VU(I3, J3, k) * ComputeFaces3D_VU(I3, J3, k)                       &
                                   + StokesVel_VU(i,   j, k) * ComputeFaces3D_VU(i,   j, k)

                            NoLand2 = ComputeFaces3D_VU(I3, J3, k) + ComputeFaces3D_VU(i,   j, k)
                        endif

                        Iaux = NoLand1 + NoLand2

                        if (Iaux > 0) then
                            StokesVel_VU_center   = (VUvar1 + VUvar2) / real(Iaux)
                        else
                            StokesVel_VU_center   = 0.0
                        endif


                        ! [m/s^] = [m^3/s] * [m/s] / [m^3]
                        FVortexAcceleration_1 = StokesWaterFlux_XY(i,j,k)                               &
                                              * (Vel_UV_EastNorth - Vel_UV_WestSouth) / Volume_UV(i,j,k)
                        ! FVortexAcceleration_1 = 0.

                        FVortexAcceleration_2 = StokesVel_VU_center    &
                                              * (Vel_VU_EastNorth - Vel_VU_WestSouth) / DZX_ZY(I3,J3)

                        ! Test pour codage du terme appele ici WaveVortexForce
                        !if (Me%Direction%dj==1) then
                        !    FVortexAcceleration_1 = 0.
                        !    FVortexAcceleration_2 = 0.
                        !endif

                        ! [m/s^2] = [m/s^2] + [m/s^2]
                        Wave3DExplicit_FVortexAccelUV(i,j,k)  = FVortexAcceleration_1 + FVortexAcceleration_2

                        ! [m/s^2] = [m/s^2] + [m/s^2]
                        Wave3DExplicit_Acceleration(i,j,k)    = Wave3DExplicit_Acceleration(i,j,k)     &
                                                              + FVortexAcceleration_1 + FVortexAcceleration_2

                    enddo

                endif

            enddo
            enddo


        !Nullify auxiliar pointers
        nullify(Wave3DExplicit_Acceleration)
        nullify(Wave3DExplicit_FVortexAccelUV)

        nullify(DZX_ZY, DXX_YY)
        nullify(StokesWaterFlux_XY, Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(ComputeFaces3D_VU)
        nullify(KFloor_UV)

        nullify(StokesVel_UV)
        nullify(StokesVel_VU)
        nullify(Velocity_UV_Old)
        nullify(Velocity_VU_Old)

    End Subroutine Compute_WaveVortexForce2

        !End-----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    !-----------------------------------------------------------------

    Subroutine ModifyTidePotential

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------

        real,    pointer, dimension (:,:)   :: GridLatitude, GridLongitude, &
                                               TidePotentialLevel
        real,    pointer, dimension (:  )   :: Beta, EqAmp, Freq, L, AstroArg
        integer, pointer, dimension (:  )   :: m
        !griflet: lets make L2 and AstroArg local variables, statically allocated.
        real, dimension(4)                  :: L2
        integer, pointer, dimension (:,:,:) :: WaterPoints3D
        type (T_Time)                       :: CurrentTime, TimeRef
        real(8)                             :: UTSeconds, tc, h0, s0, p0, Tau, TimeSeconds !ps, ns,
        real                                :: LatRad, LongRad, Run_Period, Aux, LongDegree
        real                                :: Year, Month, Day, Hour, Minute, Seconds
        integer                             :: STATUS, JulDay, D
        integer                             :: IUB, ILB, JUB, JLB, KUB, i, j, Ncomp, n

        !$ integer                             :: CHUNK

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyTidePotential")
        endif

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        TidePotentialLevel => Me%Forces%TidePotentialLevel

        Beta           => Me%TidePotential%Beta
        EqAmp          => Me%TidePotential%Amplitude
        Freq           => Me%TidePotential%Frequency
        AstroArg       => Me%TidePotential%Arguments
        m              => Me%TidePotential%m
        L              => Me%TidePotential%L

        Ncomp          =  Me%TidePotential%ComponentsNumber

        WaterPoints3D  => Me%External_Var%WaterPoints3D

        TimeRef        =  Me%TidePotential%TimeRef

        CurrentTime    = Me%CurrentTime

        Run_Period     = Me%CurrentTime - Me%BeginTime

        call GetGridLatitudeLongitude(Me%ObjHorizontalGrid,                 &
                                      GridLatitude  = GridLatitude,                      &
                                      GridLongitude = GridLongitude,                     &
                                      STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR01")

        call ExtractDate(CurrentTime, Year, Month, Day, Hour, Minute, Seconds)

        if (year < 1975) call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR02")

        call JulianDay(CurrentTime, JulDay)

        D = JulDay + 365*(int(year)-1975)+int((year-1973)/4)

        !Universal Time in seconds (by default is consider that the model time is the UT)
        UTSeconds = Hour * 3600. + Minute * 60. + Seconds

        if (Me%TidePotential%Algorithm == Kantha) then

            !time in Junlian centuries (36525 days)
            !TimeSeconds = CurrentTime - TimeRef
            !tc = TimeSeconds / 86400. / 36525.
            tc = (27392.500528+1.0000000356*real(D))/36525

            !Lunar and solar ephemerides in degrees - Kantha e Clayson, 2000 (pag. 435)

            h0 = 279.69668    + 36000.768925485*tc + 3.03e-4 *tc*tc
            s0 = 270.434358   + 481267.88314137*tc - 0.001133*tc*tc   + 1.9e-6*tc*tc*tc
            p0 = 334.329653   + 4069.0340329575*tc - 0.10325 *tc*tc   - 1.2e-5*tc*tc*tc
            !ns = 259.16000    - 1934.14        *tc + 0.0021  *tc*tc
            !ps = 281.22083    + 1.71902        *tc + 0.00045 *tc*tc   + 3.0e-6*tc*tc*tc

            !Astronomical Arguments (Table 6.2.1 Kantha and Clayson, 2000)
            AstroArg(Ssa) =  2*h0
            AstroArg(Mm ) =  s0 - p0
            AstroArg(Mf ) =  2*s0

            AstroArg(K1 ) =          h0      +90.
            AstroArg(O1 ) = -2*s0 +  h0      -90.
            AstroArg(P1 ) =       -  h0      -90.
            AstroArg(Q1 ) = -3*s0 +  h0 + p0 -90.

            AstroArg(M2 ) = -2*s0 + 2*h0
            AstroArg(S2 ) = 0.
            AstroArg(N2 ) = -3*s0 + 2*h0 + p0
            AstroArg(K2 ) = 2*h0

            AstroArg(M3 ) = -3*s0 + 3*h0 + 180.

        else if (Me%TidePotential%Algorithm == Lefevre) then

            !time in Junlian centuries (36525 days)
            !Seconds TimeRef = 1900/1/1 : 0h0m

            TimeSeconds = CurrentTime - TimeRef

            tc = TimeSeconds / 86400. / 36525.

            !Lefevre, 2001 (4.19) chapter 4 page 55 (phD Thesis).
            h0 = 280.18950    +  36000.76892*tc + 3.00e-4 *tc*tc
            s0 = 277.02480    + 481267.89060*tc + 2.00e-3 *tc*tc
            p0 = 334.38530    +   4069.03400*tc + 1.03e-2 *tc*tc
            !ns = 100.84320    +   1934.14200*tc + 2.10e-3 *tc*tc
            !ps = 281.22086    +      1.71920*tc + 5.00e-4 *tc*tc

            !Astronomical Arguments (Table 5 Lefevre, 2001)
            ! + 0
            AstroArg(Ssa) =  2*h0
            AstroArg(Mm ) =  s0 - p0
            AstroArg(Mf ) =  2*s0

            !Lefevre, 2001 do not make reference to the phase corrections (+- 90degrees)
            !However this corrections are made in the ModuleToga (Foreman Tidal Analysis package)
            !and are also maed by Kantha e Clayson, 2000.
            ! + Tau
            AstroArg(K1 ) =  s0         + 90.
            AstroArg(O1 ) =  - s0         - 90.
            AstroArg(P1 ) =  s0 - 2*h0  - 90.
            AstroArg(Q1 ) =  - 2*s0 + p0  - 90.

            ! + 2*Tau
            AstroArg(M2 ) = 0.
            AstroArg(S2 ) = 2*s0 - 2*h0
            AstroArg(N2 ) = -   s0 +   p0
            AstroArg(K2 ) = 2*s0

        endif

        !Conversion of Degrees in Radians
        do n = 1, Ncomp
          AstroArg(n) = AstroArg(n) * Pi / 180.
        enddo

        !$ CHUNK = CHUNK_J(JLB, JUB)
        !griflet: needs to privatize array L2
        !griflet: The solution was simply to make L2 a local, *static* array.
        !
        !$OMP PARALLEL PRIVATE(i,j,LatRad,LongDegree,LongRad,L2,n,Aux,Tau)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do  j = JLB, JUB
        do  i = ILB, IUB

iw1:        if (WaterPoints3D(i, j, KUB) == WaterPoint)  then

                LatRad     = GridLatitude (i, j) * Pi / 180.

                LongDegree = GridLongitude(i, j)

                do while (LongDegree>=360.)
                    LongDegree = LongDegree - 360.
                enddo
                do while (LongDegree<   0.)
                    LongDegree = LongDegree + 360.
                enddo

                LongRad = LongDegree * Pi / 180.

                !griflet: need to make this variable local!
                !L (changed from L(0), L(1), L(2) to L(1), L(2), L(3).
                L2(1) = 1.5*cos(LatRad)*cos(LatRad) - 1.
                L2(2) = sin(2*LatRad)
                L2(3) = cos(LatRad)*cos(LatRad)
                L2(4) = cos(LatRad)*cos(LatRad)*cos(LatRad)

                TidePotentialLevel(i,j) = 0.

it1:            if (Me%TidePotential%Algorithm == Kantha) then

                    !griflet: m(n) was taken care of in the construct and yields
                    !1(Ssa,Mm,Mf),2(Q1,O1,N1,P1), 3(M2,N2,O2,P2), 4(M3).
                    do n=1, Ncomp
                        TidePotentialLevel(i,j) = TidePotentialLevel(i,j) +  Beta (n) * EqAmp(n) * L2(m(n)) *     &
                                                  cos ( AstroArg(n) + Freq(n)*UTSeconds/3600 + (real(m(n))-1)*LongRad)
                    enddo

                else if (Me%TidePotential%Algorithm == Lefevre) then it1

                    Tau = (UTseconds / 86400.*360. + LongDegree - s0 + h0) * Pi / 180.

                    !griflet: m(n) was taken care of in the construct and yields
                    !1(Ssa,Mm,Mf),2(Q1,O1,N1,P1) or 3(M2,N2,O2,P2) only.
                    do n=1, 11
                        TidePotentialLevel(i,j) = TidePotentialLevel(i,j) +  Beta (n) * EqAmp(n) * L2(m(n)) *     &
                                                  cos ( AstroArg(n) + (real(m(n))-1)*Tau )
                    enddo

                endif it1

                if (Me%ComputeOptions%TideSlowStartCoef > 0.)  then

                    Aux = Run_Period / Me%ComputeOptions%TideSlowStartCoef

                    if (Aux < 1) TidePotentialLevel(i,j)= TidePotentialLevel(i,j) * Aux

                endif

            else  iw1

                TidePotentialLevel(i, j) = FillValueReal

            endif iw1

        enddo
        enddo
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        call UngetHorizontalGrid(Me%ObjHorizontalGrid,  &
                                 Array = GridLatitude, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR03")

        call UngetHorizontalGrid(Me%ObjHorizontalGrid,  &
                                 Array = GridLongitude, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "ModifyTidePotential - Hydrodynamic - ERR04")

        !nullify auxiliar pointers
        nullify(TidePotentialLevel)
        nullify(Beta     )
        nullify(EqAmp    )
        nullify(Freq     )
        nullify(AstroArg )
        nullify(m        )
        nullify(L        )
        nullify(WaterPoints3D)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyTidePotential")
        endif

    end Subroutine ModifyTidePotential

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the horizontal water flow                                                    !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_HorizontalWaterFlow

         !Variables Categories
            !Geometry  : Area_UV
            !Flow      : WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction


         !Variables Direction Dependent
           !Area_UV, WaterFlux_XY, Me%WaterFluxes%New_Old, Velocity_UV_New, Velocity_UV_Old
           !ComputeFaces3D_UV, KFloor_UV, Direction
        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_XY
! Modified by Matthias DELPEY - 24/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        real(8), dimension(:,:,:), pointer :: StokesWaterFlux_XY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        real,    dimension(:,:,:), pointer :: Velocity_UV_Old, Velocity_UV_New, Area_UV, DWZ
        real,    dimension(:,:,:), pointer :: Baroclinic_UV_New, Baroclinic_UV_Old,      &
                                              DUZ_VZ, SZZ
        real,    dimension(:,:  ), pointer :: WaterColumnUV, DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV, ImposedNormalFacesUV,   &
                                              ImposedTangentialFacesUV
        integer, dimension(:,:),   pointer :: KFloor_Z, KFloor_UV, BoundaryPoints

        real(8)                            :: TotalFlux, dz

        integer                            :: I, J, K, Kbottom, di, dj

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, ic, jc

        integer                            :: CHUNK

        !--------------------------------------------------------------------------

        !A if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        WaterFlux_XY      => Me%WaterFluxes%XY
        Velocity_UV_Old   => Me%Velocity%Horizontal%UV%Old
        Velocity_UV_New   => Me%Velocity%Horizontal%UV%New

        Baroclinic_UV_New => Me%VelBaroclinic%UV%New
        Baroclinic_UV_Old => Me%VelBaroclinic%UV%Old

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        KFloor_Z                 => Me%External_Var%KFloor_Z
        KFloor_UV                => Me%External_Var%KFloor_UV
        Area_UV                  => Me%External_Var%Area_UV
        ImposedNormalFacesUV     => Me%External_Var%ImposedNormalFacesUV
        ImposedTangentialFacesUV => Me%External_Var%ImposedTangentialFacesUV

        BoundaryPoints           => Me%External_Var%BoundaryPoints

        DYY_XX                   => Me%External_Var%DYY_XX
        DWZ                      => Me%External_Var%DWZ

        SZZ                      => Me%External_Var%SZZ
        WaterColumnUV            => Me%External_Var%WaterColumnUV
        DUZ_VZ                   => Me%External_Var%DUZ_VZ

! Modified by Matthias DELPEY - 24/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        StokesWaterFlux_XY      => Me%StokesWaterFluxes%XY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !End - Shorten variables name

        call SetMatrixValue(WaterFlux_XY, Me%WorkSize, dble(0.0))

! Modified by Matthias DELPEY - 29/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if (Me%ComputeOptions%WaveForcing3D == GLM) then
            call SetMatrixValue(StokesWaterFlux_XY, Me%WorkSize, dble(0.0))
        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,ic,jc,TotalFlux,dz)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:     do j = JLB, JUB
doi:     do i = ILB, IUB

Cov1:       if (ComputeFaces3D_UV(I, J, KUB) == Covered) then

                Kbottom = KFloor_UV(i, j)

dok:            do  k = Kbottom, KUB

                    ![m^3/s]              = [ ] * [m/s] * [m^2]
                    WaterFlux_XY(i, j, k) = (dble(Me%WaterFluxes%New_Old) *                  &
                                            dble(Velocity_UV_New(i, j, k))  + &
                                            dble((1. - Me%WaterFluxes%New_Old)) *            &
                                            dble(Velocity_UV_Old(i, j, k))) * &
                                            dble(Area_UV(i, j, k))

! Modified by Matthias DELPEY - 19/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                    if (Me%ComputeOptions%WaveForcing3D == GLM) then

                        ! Contribution of the Stokes Drift to the advection
                        StokesWaterFlux_XY(i,j,k) = (dble(Me%WaterFluxes%New_Old) *                  &
                                                    dble(Me%StokesVel%Horizontal%UV%New(i, j, k))  +  &
                                                    dble((1. - Me%WaterFluxes%New_Old)) *             &
                                                    dble(Me%StokesVel%Horizontal%UV%Old(i, j, k))) *  &
                                                    dble(Area_UV(i, j, k))

                        WaterFlux_XY(i, j, k) = WaterFlux_XY(i, j, k) + StokesWaterFlux_XY(i,j,k)

                    endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                enddo dok

            endif Cov1

        enddo doi
        enddo doj
        !$OMP END DO NOWAIT

cd3:    if (Me%SubModel%ON) then

cd5:        if (Me%SubModel%Set) then

                CHUNK = CHUNK_J(JLB, JUB + dj)

                dok2: do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                doj2: do j = JLB, JUB + dj
                doi2: do i = ILB, IUB + di

                    !The faces that are exterior are put equal to the father model

cd4:                if (ImposedNormalFacesUV    (i, j, k) == Imposed   .or.              &
                        ImposedTangentialFacesUV(i, j, k) == Imposed) then

                        !Specific flow
                        ![m^2/s]            = [m/s] * [m]
                        Me%SubModel%qXY(i, j, k)   =  (dble(Me%WaterFluxes%New_Old) *      &
                                            dble(Velocity_UV_New(i, j, k))        +      &
                                            dble((1. - Me%WaterFluxes%New_Old))                  *      &
                                            dble(Velocity_UV_Old(i, j, k)))       *      &
                                            dble(Me%SubModel%DUVZ_Old(i, j, k))


                    endif cd4


cd11:               if (ComputeFaces3D_UV(i, j, k) == Covered) then

                        !Specific flow
                        ![m^2/s]            = [m/s] * [m]
                        Me%SubModel%qXY(i, j, k)   =  (dble(Me%WaterFluxes%New_Old)           * &
                                            dble(Me%SubModel%UV_New(i, j, k))  + &
                                            dble((1. - Me%WaterFluxes%New_Old))                            * &
                                            dble(Me%SubModel%UV_Old(i, j, k))) * &
                                            dble(Me%SubModel%DUVZ_Old(i, j, k))


                    endif cd11


                enddo doi2
                enddo doj2
                !$OMP END DO
                enddo dok2

            else cd5

                !$OMP MASTER
                call SetError (FATAL_, INTERNAL_, "Modify_HorizontalWaterFlow - Hydrodynamic - ERR01")
                !$OMP END MASTER

            endif cd5

        endif cd3

        !$OMP BARRIER

cd6:    if (Me%ComputeOptions%BaroclinicRadia == Horizontal_) then

            CHUNK = CHUNK_J(JLB, JUB + dj)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj3:   do j = JLB, JUB + dj
    doi3:   do i = ILB, IUB + di

cd9:            if (ImposedNormalFacesUV(i, j, KUB) == Imposed) then



                    if      (BoundaryPoints(i - di, j - dj) == Boundary) then



                        ic = i - di
                        jc = j - dj

                    else if (BoundaryPoints(i     , j     ) == Boundary) then

                        ic = i
                        jc = j

                    endif

                    Kbottom = KFloor_Z(ic, jc)

                    TotalFlux = 0.

            dok3:   do k = Kbottom, KUB


                        ![m^3/s]              = [ ] * [m/s] * [m] * [m]
                        WaterFlux_XY(i, j, k) = (dble(Me%WaterFluxes%New_Old)                     *         &
                                                dble(Baroclinic_UV_New (i, j, k))  +         &
                                                dble((1. - Me%WaterFluxes%New_Old))               *         &
                                                dble(Baroclinic_UV_Old(i, j, k)))  *         &
                                                dble(DWZ(ic, jc, k)) * dble(DYY_XX(i, j))

!                        WaterFlux_XY(i, j, k) = dble(Baroclinic_UV_New (i, j, k))  *         &
!                                                dble(DWZ(ic, jc, k)) * dble(DYY_XX(i, j))


                        TotalFlux = TotalFlux + WaterFlux_XY(i, j, k)

                    enddo dok3


            dok5:   do k = Kbottom, KUB

                        dz = dble(SZZ(ic, jc, k       - 1) - SZZ(ic, jc, k  )) /         &
                             dble(SZZ(ic, jc, kbottom - 1) - SZZ(ic, jc, KUB))

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_XY(i, j, k) = WaterFlux_XY(i, j, k) -                  &
                                                TotalFlux * dz
                    enddo dok5
                endif cd9

cd10:           if (ImposedTangentialFacesUV(i, j, KUB) == Imposed) then

                    Kbottom = KFloor_UV(i, j)
                    TotalFlux = 0.

            dok4:   do k = Kbottom, KUB

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_XY(i, j, k) = (dble(Me%WaterFluxes%New_Old)                     *         &
                                                dble(Baroclinic_UV_New (i, j, k))  +         &
                                                dble((1. - Me%WaterFluxes%New_Old))               *         &
                                                dble(Baroclinic_UV_Old(i, j, k)))  *         &
                                                Area_UV(i, j, k)
!                        ![m^3/s]              = [ ] * [m/s] * [m^2]
!                        WaterFlux_XY(i, j, k) = dble(Baroclinic_UV_New (i, j, k))  *         &
!                                                Area_UV(i, j, k)

                        TotalFlux = TotalFlux + WaterFlux_XY(i, j, k)
                    enddo dok4

            dok6:   do k = Kbottom, KUB
                        dz = dble(DUZ_VZ(i, j, k)) / dble(WaterColumnUV(i, j))

                        ![m^3/s]              = [ ] * [m/s] * [m^2]
                        WaterFlux_XY(i, j, k) = WaterFlux_XY(i, j, k) -                  &
                                                TotalFlux * dz
                    enddo dok6

                endif cd10

            enddo doi3
            enddo doj3
            !$OMP END DO

        endif cd6
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")
        endif

        if (Me%CyclicBoundary%ON) then


            if (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectNormal    ( VectorD = WaterFlux_XY)
            endif

            if (Me%CyclicBoundary%Direction == Me%Direction%YX .or. &
                Me%CyclicBoundary%Direction == DirectionXY_)  then
                call CyclicBoundVectTangential( VectorD = WaterFlux_XY)
            endif

        endif


        nullify (WaterFlux_XY)
        nullify(StokesWaterFlux_XY)
        nullify (Velocity_UV_Old)

        nullify (ComputeFaces3D_UV       )
        nullify (KFloor_UV               )
        nullify (KFloor_Z                )
        nullify (Area_UV                 )
        nullify (ImposedNormalFacesUV    )
        nullify (ImposedTangentialFacesUV)
        nullify (DYY_XX                  )
        nullify (DWZ                     )
        nullify (Baroclinic_UV_New       )
        nullify (Baroclinic_UV_Old       )
        nullify (SZZ                     )
        nullify (WaterColumnUV           )
        nullify (DUZ_VZ                  )

        !A if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Modify_HorizontalWaterFlow")

    end Subroutine Modify_HorizontalWaterFlow

    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the density gradient integral                               !
    !  for both horizontal directions : X and Y                                            !
    !                                                                                      !
    ! Input : Geometry, Mapping, density                                                   !
    ! OutPut: Rox3 - density gradient integral                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine Modify_ROX3 (SigmaDens, Rox3XY)

        !Arguments------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: SigmaDens, Rox3XY

        !Local----------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DWZ, DUZ_VZ, SZZ

        real,    dimension(:,:  ), pointer :: DZX_ZY, Coriolis_Freq, DUX_VY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:  ), pointer :: BoundaryFacesUV
        integer, dimension(:,:),   pointer :: KFloor_UV
        Integer                            :: i, j, di, dj, k, kbottom, ileft, jleft

        Integer, dimension( : ), pointer   :: Kleft,Kright

        Real(8), dimension( : ), pointer   :: Depth_integ, Hcenter, Hleft, &
                                              Hright, HroLeft, HroRight,   &
                                              DensRight, DensLeft

        Real(8)                            :: DAux,DAuxRight,DAuxLeft, AuxRight, AuxLeft, &
                                              ZRight, ZLeft, DRight, DLeft, DensZRight, DensZLeft

        type (T_Time)                      :: CurrentTime

        Real                               :: TimeCoef, F_UV, DT_RunPeriod, InertialPeriods

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: NRight, NLeft, kbright, kbleft, PoliDegree

        logical                            :: FoundBottomRight, FoundBottomLeft, FoundSurfaceRight, FoundSurfaceLeft
        logical                            :: BaroclinicRAMP, BoundaryBaroclinic, PoliIsEven
        !$ integer                            :: CHUNK
        integer                            :: TID
        !griflet
        type(T_Coef_Baroc), pointer        :: LocalBaroc

    !------------initialization----
        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Modify_ROX3")


        !$ CHUNK = CHUNK_J(JLB,JUB)

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ComputeFaces3D_UV => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV   => Me%External_Var%BoundaryFacesUV
        KFloor_UV         => Me%External_Var%KFloor_UV

        DWZ               => Me%External_Var%DWZ
        SZZ               => Me%External_Var%SZZ
        DUZ_VZ            => Me%External_Var%DUZ_VZ
        DZX_ZY            => Me%External_Var%DZX_ZY
        DUX_VY            => Me%External_Var%DUX_VY

        !End - Shorten variables name

        call SetMatrixValue(Rox3XY, Me%WorkSize, FillValueReal)

!        Kleft             = FillValueInt   !rcm 7
!        Kright            = FillValueInt
!
!        Depth_integ       = FillValueReal
!        Hcenter           = FillValueReal
!        Hleft             = FillValueReal
!        Hright            = FillValueReal
!        HroLeft           = FillValueReal
!        HroRight          = FillValueReal

    !------------Main cicle--------

         !griflet
         !$ CHUNK = CHUNK_J(JLB,JUB)
         ! We don't compute turbulence coefficients at the limits of the domain.
         !$OMP PARALLEL &
         !$OMP PRIVATE(i,j,k,kbottom,ileft,jleft,       &
         !$OMP         Kleft, Kright, Depth_integ,      &
         !$OMP         Hcenter, Hleft, Hright,          &
         !$OMP         HroLeft, HroRight,               &
         !$OMP         DensRight, DensLeft,             &
         !$OMP         DAuxRight, DAuxLeft, DAux,       &
         !$OMP         Zright, Zleft,                   &
         !$OMP         Dright, Dleft,                   &
         !$OMP         AuxRight, AuxLeft,               &
         !$OMP         DensZRight, DensZLeft,           &
         !$OMP         NRight, NLeft,                   &
         !$OMP         kbright, kbleft,                 &
         !$OMP         PoliDegree, PoliIsEven,          &
         !$OMP         FoundBottomRight, FoundBottomLeft,   &
         !$OMP         FoundSurfaceRight, FoundSurfaceLeft, &
         !$OMP         TID, LocalBaroc)
         !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do4:     do j = JLB, JUB
do5:     do i = ILB, IUB

            TID = 1
            !$ TID = 1 + omp_get_thread_num();
            LocalBaroc => Me%Coef%Baroc(TID)

            Kleft             => LocalBaroc%Kleft
            Kright            => LocalBaroc%Kright
            Depth_integ       => LocalBaroc%Depth_integ
            Hcenter           => LocalBaroc%Hcenter
            Hleft             => LocalBaroc%Hleft
            Hright            => LocalBaroc%Hright
            HroLeft           => LocalBaroc%HroLeft
            HroRight          => LocalBaroc%HroRight
            DensRight         => LocalBaroc%DensRight
            DensLeft          => LocalBaroc%DensLeft

cd1:        if (ComputeFaces3D_UV(i, j, KUB)== Covered) then

do7:            do k = KLB, KUB
                    Kleft      (k)       = FillValueInt    !rcm 8
                    Kright     (k)       = FillValueInt

                    Depth_integ(k)       = FillValueReal
                    Hcenter    (k)       = FillValueReal
                    Hleft      (k)       = FillValueReal
                    Hright     (k)       = FillValueReal
                    HroLeft    (k)       = FillValueReal
                    HroRight   (k)       = FillValueReal

                    DensRight  (k)       = FillValueReal
                    DensLeft   (k)       = FillValueReal
                end do do7


                kbottom = KFloor_UV(i, j)

                ileft = i - di
                jleft = j - dj

                call calc_depth_and_Hro (Hcenter, Hleft, Hright, HroLeft, HroRight,     &
                                         DensRight, DensLeft, DWZ, SZZ, DUZ_VZ, SigmaDens,&
                                         i, j, ileft, jleft, KUB, kbottom)

                if      (Me%ComputeOptions%BaroclinicMethod == MARSALEIX) then

                     HroRight(KUB+1) = 0.
                     HroLeft (KUB+1) = 0.

                     HRight(KUB+1)   = 0.
                     HLeft (KUB+1)   = 0.

do23:                do  k=KUB, kbottom,-1

                        !pressure in the lower face
                        HroRight(k) = HroRight(k + 1) + dble(SigmaDens(i    ,j    ,k)) * dble(DWZ (    i,    j,  k))
                        Hroleft (k) = Hroleft (k + 1) + dble(SigmaDens(ileft,jleft,k)) * dble(DWZ (ileft, jleft, k))

                        !depth of lower face
                        HRight(k)   = HRight  (k + 1) + dble(DWZ (    i,    j,  k))
                        HLeft (k)   = HLeft   (k + 1) + dble(DWZ (ileft, jleft, k))

                        !pressure in the center cell
                        DAuxRight  =  (HroRight(k) + HroRight(k+1)) / 2.
                        DAuxLeft   =  (HroLeft (k) + HroLeft (k+1)) / 2.

                        !depth of the cell center
                        Zright     =  (Hright(k) + Hright(k+1)) / 2.
                        Zleft      =  (Hleft (k) + Hleft (k+1)) / 2.

                        !Along the iso-sigma
                        DAux       =  (DAuxRight - DAuxLeft)/ dble(DZX_ZY(ileft, jleft))

                        !Correction for the cartesian space
                        Rox3XY(i,j,k) = Daux + (SigmaDens(i, j, k) + SigmaDens(ileft, jleft, k)) * &
                                        (Zright - Zleft) / dble(DZX_ZY(ileft, jleft)) / 2.

                    enddo do23

                endif

                if      (Me%ComputeOptions%BaroclinicMethod == DensityUniform  .or.     &
                         Me%ComputeOptions%BaroclinicMethod == DensityLinear) then

                    call Calc_Depth_integration(Hcenter, Hleft, Hright,                 &
                                                Kleft, Kright, Depth_integ, KUB, kbottom)



do6:                do  k=KUB, kbottom,-1

                        Zright   = Depth_integ    (k)  - Hright (kright(k) + 1)
                        Dright   = Hright (kright (k)) - Hright (kright(k) + 1)

                        Zleft    = Depth_integ    (k)  - Hleft  (kleft (k) + 1)
                        Dleft    = Hleft  (kleft  (k)) - Hleft  (kleft (k) + 1)



                        if      (Me%ComputeOptions%BaroclinicMethod == DensityUniform) then

                            !Constant SigmaDens in each layer

                            AuxRight = Zright / Dright

                            AuxLeft  = Zleft  / Dleft


                            ![M/m^3 * m]  = [M/m^3 * m]
                            DAuxRight=     HroRight(kright(k) + 1)                        + &
                                          (HroRight(kright(k)) - HroRight(kright(k) + 1)) * &
                                           AuxRight

                            DAuxLeft =     Hroleft (kleft (k) + 1)                        + &
                                          (Hroleft(kleft  (k)) - Hroleft(kleft(k)  + 1))  * &
                                           AuxLeft

                        else if (Me%ComputeOptions%BaroclinicMethod == DensityLinear) then

                            !Linear SigmaDens evolution in each layer
                            DensZRight = (DensRight(kright(k)    ) *  Zright/2.          +  &
                                          DensRight(kright(k) + 1) * (Dright-Zright/2.)) /  &
                                          Dright

                            DensZLeft  = (DensLeft(kLeft  (k)    ) *  ZLeft/2.           +  &
                                          DensLeft(kLeft  (k) + 1) * (DLeft-ZLeft/2.))   /  &
                                          DLeft


                            ![M/m^3 * m]  = [M/m^3 * m]
                            DAuxRight  =  HroRight (kright(k) + 1) + DensZRight * Zright

                            DAuxLeft   =  Hroleft  (kleft (k) + 1) + DensZLeft  * ZLeft

                        endif

                        ! DAuxLeft (i or i -1, j-1 or j) - DAuxRight (i,j)
                        DAux     =     DAuxLeft - DAuxRight

                        ![M/m^3] =     [M/m^3 * m] / [m]
                        DAux     =     DAux/dble(DZX_ZY(ileft, jleft))

                        !if Rox3 is positive then the baroclinic force is positive
                        !in the pass was the opposite but to maintain coherence with the
                        !other pressure forces now (Rox3 = (DAuxLeft - DAuxRight)/dxy)
                        !in the pass (Rox3 = (- DAuxLeft + DAuxRight)/dxy)
                        Rox3XY(i,j,k) = real(DAux)

                enddo do6

            endif


            if (Me%ComputeOptions%BaroclinicMethod == Leibniz .or.                     &
                Me%ComputeOptions%BaroclinicMethod == Leibniz2) then

                Rox3XY(i,j,KUB +1) = 0.

                kbright = Me%External_Var%KFloor_Z(i, j)

                NRight = KUB - kbright + 1

                kbleft = Me%External_Var%KFloor_Z(ileft, jleft)


                Hright  (KUB+1) = null_real
                Hleft   (KUB+1) = null_real

                DensRight(KUB+1)   = null_real
                DensLeft (KUB+1)   = null_real

                do k = KUB , kbright, -1
                   Hright  (k) = (dble(SZZ (  i,       j, k)) + dble(SZZ (    i,     j, k-1))) / 2.
                   DensRight(k) = dble(SigmaDens(i    ,j    ,k  ))
                enddo

                do k = KUB , kbleft , -1
                   Hleft   (k) = (dble(SZZ (ileft, jleft, k)) + dble(SZZ (ileft, jleft, k-1))) / 2.
                   DensLeft (k) = dble(SigmaDens(ileft,jleft,k  ))
                enddo

                NLeft  = KUB - kbLeft + 1


do27:           do  k=KUB, kbottom,-1

                    if      (Me%ComputeOptions%BaroclinicMethod == Leibniz) then

                        !Linear interpolation
                        DensZRight = InterpolateProfileR8 (Hcenter(k), NRight, Hright(kbright:KUB),  &
                                                           DensRight(kbright:KUB), FoundBottomRight, &
                                                           FoundSurfaceRight)

                        DensZLeft  = InterpolateProfileR8 (Hcenter(k), NLeft , HLeft (kbleft :KUB),  &
                                                           DensLeft (kbleft :KUB), FoundBottomLeft , &
                                                           FoundSurfaceLeft )


                        if (.not. FoundBottomRight .and. .not. FoundBottomLeft                       &
                            .and. .not.FoundSurfaceRight .and. .not. FoundSurfaceLeft) then

                            DAux       =  (DensZLeft - DensZRight) * DUZ_VZ(i, j, k)  / dble(DZX_ZY(ileft, jleft))

                        else
                            DAux = 0.
                        endif

                    else if (Me%ComputeOptions%BaroclinicMethod == Leibniz2) then

                        if ( (KUB - kbright) == 0) then
                            !Uniform profile is assumed when there only one layer
                            DensZRight = DensRight(KUB)
                        else
                            !Interpolation n degree
                            PoliDegree = min (Me%ComputeOptions%BaroclinicPoliDegree, KUB - kbright)

                            if(IsOdd(PoliDegree))then
                                PoliIsEven = .false.
                            else
                                PoliIsEven = .true.
                            endif

                            DensZRight = PolIntProfile  (Hcenter(k), NRight, Hright(kbright:KUB), &
                                                         DensRight(kbright:KUB), PoliDegree,      &
                                                         PoliIsEven)
                        endif

                        if ( (KUB - kbleft ) == 0) then
                            !Uniform profile is assumed when there only one layer
                            DensZLeft  = DensLeft (KUB)
                        else
                            !Interpolation n degree
                            PoliDegree = min (Me%ComputeOptions%BaroclinicPoliDegree, KUB - kbleft )

                            if(IsOdd(PoliDegree))then
                                PoliIsEven = .false.
                            else
                                PoliIsEven = .true.
                            endif

                            DensZLeft  = PolIntProfile  (Hcenter(k), NLeft , HLeft (kbleft :KUB), &
                                                         DensLeft (kbleft :KUB), PoliDegree,      &
                                                         PoliIsEven)
                        endif

                        DAux       =  (DensZLeft - DensZRight) * DUZ_VZ(i, j, k)  / dble(DZX_ZY(ileft, jleft))

                    endif

                    Rox3XY(i,j,k) = Rox3XY(i,j,k+1) + DAux

                enddo do27


            endif

            end if cd1

        enddo do5
        enddo do4
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !If the baroclinic force is not to be consider in the boundary then
        BoundaryBaroclinic = Me%ComputeOptions%BoundaryBaroclinic

!        if (MonitorPerformance) then
!            call StartWatch ("ModuleHydrodynamic", "Modify_ROX3")
!        endif

cd10:   if ( .not. BoundaryBaroclinic ) then

            !$ CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do41:       do J = JLB, JUB
do51:       do I = ILB, IUB

cd11:           if (BoundaryFacesUV(i, j) == Boundary) then

                    kbottom = KFloor_UV(i, j)

do61:               do  K = kbottom, KUB

                        Rox3XY (i, j, k) = 0.

                    enddo do61

                endif cd11

            enddo do51
            enddo do41
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd10

        !If the RAMP option is on then the baroclinic force is gradually imposed
        BaroclinicRAMP = Me%ComputeOptions%BaroclinicRAMP

cd12:   if ( BaroclinicRAMP ) then

            CurrentTime  = Me%CurrentTime

            DT_RunPeriod = CurrentTime - Me%ComputeOptions%RAMP_BeginTime

            if (Me%ComputeOptions%RampPeriod>0.) then
                TimeCoef = DT_RunPeriod / Me%ComputeOptions%RampPeriod
            endif

            InertialPeriods = Me%ComputeOptions%InertialPeriods

            Coriolis_Freq => Me%External_Var%Coriolis_Freq

            !$ CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(I,J,K,ileft,jleft,F_UV,TimeCoef,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do42:       do J = JLB, JUB
do52:       do I = ILB, IUB

cd13:           if (ComputeFaces3D_UV(i, j, KUB)== Covered) then

                    ileft = i - di
                    jleft = j - dj

                    ! Interpolates Coriolis_Freq for the face
                    F_UV = (DUX_VY(ileft, jleft) * Coriolis_Freq(I, J) + DUX_VY(I, J) * Coriolis_Freq(ileft, jleft)) / &
                           (DUX_VY(ileft, jleft) + DUX_VY(I, J))

                    if (Me%ComputeOptions%RampPeriod<0.) then
                        TimeCoef = abs (DT_RunPeriod * F_UV / (2 * Pi) / InertialPeriods)
                    endif

cd14:               if (TimeCoef < 1) then

                        kbottom = KFloor_UV(i, j)

do62:                   do  K = kbottom, KUB

                            Rox3XY (i, j, k) = TimeCoef * Rox3XY (i, j, k)

                        enddo do62

                    endif cd14

                endif cd13

            enddo do52
            enddo do42
            !$OMP END DO
            !$OMP END PARALLEL

            nullify (Coriolis_Freq)

        endif cd12

!        if (MonitorPerformance) then
!            call StopWatch ("ModuleHydrodynamic", "Modify_ROX3")
!        endif

        !Nullify auxiliar pointers
        nullify (Kleft)
        nullify (Kright)
        nullify (Depth_integ)
        nullify (Hcenter)
        nullify (Hleft)
        nullify (Hright)
        nullify (HroLeft)
        nullify (HroRight)
        nullify (DensRight)
        nullify (DensLeft )


        nullify (ComputeFaces3D_UV)
        nullify (BoundaryFacesUV)
        nullify (KFloor_UV)

        nullify (DWZ, SZZ)
        nullify (DZX_ZY)
        nullify (DUX_VY)
        nullify (DUZ_VZ)

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Modify_ROX3")

    End Subroutine Modify_ROX3



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine relaxes 3D hydrodynamic properties of single precision for a         !
    ! specific value                                                                       !
    !                                                                                      !
    ! Input : Hydrodynamic Property compute by the model                                   !
    ! OutPut: Hydrodynamic Property after assimilation                                     !
    ! Author: Paulo Chambel & Manuel Ruiz Villarreal  (2000/12)                                                              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine HydroPropAssimilationVelocity( PropertyID, PropModel,           &
                                              PropSubModel, Map3D, KFloor, DT)

        !Arguments------------------------------------------------------------


        real,    dimension(:,:,:), pointer :: PropModel, PropSubModel

        integer, dimension(:,:,:), pointer :: Map3D

        integer, dimension(:,:),   pointer :: KFloor

        real                               :: DT

        integer                            :: PropertyID

        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: DecayTime

        real,    dimension(:,:,:), pointer :: PropAssimilation

        type(T_Time)                       :: CurrentTime, EndTime, BeginTime

        real                               :: ColdPeriod, ColdOrder, CoefCold, DT_RunPeriod, AuxDecay

        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, JUB, KUB, ILB, JLB, KLB, status

        integer                            :: CHUNK

    !------------initialization----


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB
        KLB = Me%WorkSize%KLB

        EndTime     = Me%EndTime

        BeginTime   = Me%BeginTime

        CurrentTime = Me%CurrentTime

        !End - Shorten variables name


        if (associated(PropSubModel)) then

            PropAssimilation => PropSubModel
            ColdPeriod       =  0.

        else

            !call GetAssimilationField(Me%ObjAssimilation,                               &
            !                          ID              = PropertyID,                     &
            !                          Field3D         = PropAssimilation,               &
            !                          STAT            = status)
            if      (PropertyID == VelocityU_) then

                !It is important to read vector fields in agreggated way to allow the
                !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
                call GetAssimilationVectorField                                         &
                                     (AssimilationID    = Me%ObjAssimilation,           &
                                      VectorX_ID        = VelocityU_,                   &
                                      VectorY_ID        = VelocityV_,                   &
                                      VectorX_3D        = PropAssimilation,             &
                                      STAT              = status)

                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR10")

            elseif (PropertyID == VelocityV_) then

               !It is important to read vector fields in agreggated way to allow the
                !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
                call GetAssimilationVectorField                                         &
                                     (AssimilationID    = Me%ObjAssimilation,           &
                                      VectorX_ID        = VelocityU_,                   &
                                      VectorY_ID        = VelocityV_,                   &
                                      VectorY_3D        = PropAssimilation,             &
                                      STAT              = status)

                if (status /= SUCCESS_)                                                     &
                    call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR20")

            else

                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR30")

            endif

        endif

        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID                = PropertyID,                       &
                                  CoefField3D       = DecayTime,                        &
                                  ColdRelaxPeriod   = ColdPeriod,                       &
                                  ColdOrder         = ColdOrder,                        &
                                  STAT              = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR40")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime))                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR50")

        if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "HydroPropAssimilationVelocity")

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom,AuxDecay)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd2:        if (Map3D(I, J, KUB) == Covered ) then

                kbottom = KFloor(I, J)

do3:            do K=kbottom, KUB

                    AuxDecay = CoefCold  * DT / DecayTime(i, j, k)

                    PropModel(i, j, k) = (PropModel (i, j, k)                  +         &
                                        AuxDecay * PropAssimilation(i, j, k))  /         &
                                        (1 + AuxDecay)

                enddo do3

            endif cd2

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "HydroPropAssimilationVelocity")

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)

        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR60")

        if (.not. associated(PropSubModel)) then

            call UnGetAssimilation(Me%ObjAssimilation, PropAssimilation,    &
                                   STAT        = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR70")

        else

            nullify(PropAssimilation)

        endif


    End Subroutine HydroPropAssimilationVelocity


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine relaxes 2D hydrodynamic properties of single precision for a         !
    ! specific value                                                                       !
    !                                                                                      !
    ! Input : Hydrodynamic Property computed by the model                                   !
    ! OutPut: Hydrodynamic Property after assimilation                                     !
    ! Author: Manuel & Paulo(2000/12)                                                              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine HydroPropAssimilation2D( PropertyID, PropModel, PropSubModel, Map3D, DT)

        !Arguments------------------------------------------------------------


        real,    dimension(:,:  ), pointer :: PropModel, PropSubModel

        integer, dimension(:,:,:), pointer :: Map3D

        real                               :: DT

        integer                            :: PropertyID

        !Local---------------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: DecayTime

        real,    dimension(:,:  ), pointer :: PropAssimilation

        type(T_Time)                       :: CurrentTime, EndTime, BeginTime

        real                               :: ColdPeriod, ColdOrder, CoefCold, DT_RunPeriod, AuxDecay, AuxProp

        integer                            :: I, J

        integer                            :: IUB, JUB, KUB, ILB, JLB, status
        integer                            :: CHUNK

    !------------initialization----


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB


        EndTime     = Me%EndTime

        BeginTime   = Me%BeginTime

        CurrentTime = Me%CurrentTime

        !End - Shorten variables name

        if (associated(PropSubModel)) then

            PropAssimilation => PropSubModel

        else

            call GetAssimilationField(Me%ObjAssimilation,                               &
                                      ID              = PropertyID,                     &
                                      Field2D         = PropAssimilation,               &
                                      STAT            = status)

            if (status /= SUCCESS_)                                                     &
                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR01")

        endif

        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID          = PropertyID,                             &
                                  CoefField2D = DecayTime,                              &
                                  ColdRelaxPeriod = ColdPeriod,                         &
                                  ColdOrder       = ColdOrder,                          &
                                  STAT        = status)

        if (status /= SUCCESS_)                                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR02")


        DT_RunPeriod = CurrentTime - BeginTime

        if (ColdPeriod > (EndTime - BeginTime))                                         &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilationVelocity - Hydrodynamic - ERR03")

        if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1
        else
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "HydroPropAssimilation2D")

        !$OMP PARALLEL PRIVATE(I,J,AuxDecay,AuxProp)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
do1:    do  J = JLB, JUB
do2:    do  I = ILB, IUB

cd2:        if (Map3D(I, J, KUB) == Covered ) then

                AuxDecay = CoefCold  * DT / DecayTime(i, j)

                AuxProp = PropAssimilation(i, j)

                PropModel(i, j) = (PropModel (i, j) + AuxDecay * AuxProp)  / (1 + AuxDecay)

            endif cd2

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "HydroPropAssimilation2D")

        call UnGetAssimilation(Me%ObjAssimilation, DecayTime, STAT = status)
        if (status /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR04")

        if (.not. associated(PropSubModel)) then

            call UnGetAssimilation(Me%ObjAssimilation, PropAssimilation,    &
                                   STAT        = status)

            if (status /= SUCCESS_)                                                      &
                call SetError (FATAL_, INTERNAL_, "HydroPropAssimilation2D - Hydrodynamic - ERR05")

        else


            nullify(PropAssimilation)

        endif



    End Subroutine HydroPropAssimilation2D


    Subroutine VelocityRelaxation

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Velocity_UV_New, SubModel_UV_New

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV

        integer, dimension(:,:),   pointer :: KFloor_UV

        integer                            :: Vel_ID

    !------------initialization----

        !Begin - Shorten variables name
        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV

        KFloor_UV            => Me%External_Var%KFloor_UV

        Velocity_UV_New      => Me%Velocity%Horizontal%UV%New

       !End - Shorten variables name


        nullify (SubModel_UV_New)

        if      (Me%Direction%XY == DirectionX_) then

            !call GetAssimilationList(VelocityU = Vel_ID)
            Vel_ID = VelocityU_
            if (Me%SubModel%ON)                                             &
                SubModel_UV_New => Me%SubModel%U_New

        else if (Me%Direction%XY == DirectionY_) then

            !call GetAssimilationList(VelocityV = Vel_ID)
            Vel_ID = VelocityV_
            if (Me%SubModel%ON)                                             &
                SubModel_UV_New => Me%SubModel%V_New

        endif


        call HydroPropAssimilation ( Vel_ID, Velocity_UV_New,            &
                                    SubModel_UV_New, ComputeFaces3D_UV, KFloor_UV,       &
                                    Me%Velocity%DT)


        nullify(Velocity_UV_New  )
        nullify(KFloor_UV        )
        nullify(ComputeFaces3D_UV)


    End Subroutine VelocityRelaxation
    !----------------------------------------------------------------

    Subroutine WaterLevelRelaxation

        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: WaterLevel_New, SubModel_Z

        integer, dimension(:,:,:), pointer :: OpenPoints3D

        integer, dimension(:,:),   pointer :: KFloor_Z

        integer                            :: Vel_ID

    !------------initialization----

        !Begin - Shorten variables name
        OpenPoints3D        => Me%External_Var%OpenPoints3D

        KFloor_Z            => Me%External_Var%KFloor_Z

        WaterLevel_New      => Me%WaterLevel%New

       !End - Shorten variables name

        !call GetAssimilationList(WaterLevel = Vel_ID)
        Vel_ID = WaterLevel_
        nullify (SubModel_Z)

        if (Me%SubModel%ON)                                                 &
            SubModel_Z => Me%SubModel%Z


        call HydroPropAssimilation ( Vel_ID, WaterLevel_New, SubModel_Z, &
                                    OpenPoints3D, Me%WaterLevel%DT)


        nullify(WaterLevel_New   )
        nullify(KFloor_Z         )
        nullify(OpenPoints3D     )
        nullify(SubModel_Z       )


    End Subroutine WaterLevelRelaxation
    !----------------------------------------------------------------

    !----------------------------------------------------------------

    Subroutine  WaterLevelRelaxationAltimetry

        !Local -----------------------------------------------------------------
        real,    pointer, dimension(:,:)            :: LevelAnalyzed
        real                                        :: AltimDecayTime
        integer                                     :: ILB, IUB
        integer                                     :: JLB, JUB
        integer                                     :: KLB, KUB
        integer                                     :: I, J
        real                                        :: AuxDecay

        !Begin shorten variable names ----------------------------------------------

        if (MonitorPerformance)                                                         &
            call StartWatch ("ModuleHydrodynamic", "WaterLevelRelaxationAltimetry")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        LevelAnalyzed => Me%External_Var%AltimWaterLevelAnalyzed
        AltimDecayTime = Me%External_Var%AltimDecayTime

cd2:    if( Me%ComputeOptions%AltimetryAssimilation%flag)  then

            !Testar o tempo a ver se e agora que se assimila
            !Se for entao assimilar (nudge)
            if (Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute) then

                ! C(t+dt) = (C(t) + Cref*dt/Tref) / (1 + dt / Tref) -> Implicit

                !Nudging Water Level.
                do j = JLB, JUB
                do i = ILB, IUB

                    if (Me%External_Var%OpenPoints3D(i, j, KUB) == OpenPoint) then

                        AuxDecay = Me%ComputeOptions%AltimetryAssimilation%DT_Compute   &
                                     / AltimDecayTime

                        Me%WaterLevel%New(i, j) = (Me%WaterLevel%New(i, j) +            &
                                                   LevelAnalyzed(i, j) *                &
                                                   AuxDecay) / (1. + AuxDecay)
                    endif


                enddo
                enddo

                Me%ComputeOptions%AltimetryAssimilation%NextCompute =                   &
                        Me%ComputeOptions%AltimetryAssimilation%NextCompute  +          &
                        Me%ComputeOptions%AltimetryAssimilation%DT_Compute

            endif

        else cd2

                Me%ComputeOptions%AltimetryAssimilation%NextCompute  =                  &
                            Me%CurrentTime                                              &
                            + Me%ComputeOptions%AltimetryAssimilation%DT_Compute

                Me%ComputeOptions%AltimetryAssimilation%flag = .true.

        end if cd2

        if (MonitorPerformance)                                                         &
            call StopWatch ("ModuleHydrodynamic", "WaterLevelRelaxationAltimetry")

    End Subroutine WaterLevelRelaxationAltimetry
    !----------------------------------------------------------------

    !----------------------------------------------------------------
    Subroutine calc_depth_and_Hro (Hcenter, Hleft, Hright, HroLeft, HroRight,           &
                                   DensRight, DensLeft, DWZ, SZZ, DUZ_VZ, SigmaDens,    &
                                   i, j, ileft, jleft, KUB, kbottom)



        !Arguments
        Integer,  intent(in )              :: i, j, ileft, jleft, KUB, kbottom

        !griflet: these arguments are intent(out)
        Real(8), pointer,  dimension ( : ) :: Hleft, Hright, Hcenter, HroLeft, HroRight, DensRight, DensLeft

        !griflet: these arguments are intent(in)
        Real, pointer, dimension(:, :, :)  :: DWZ, DUZ_VZ, SigmaDens, SZZ

        !Local variable
        Integer     :: k

        !integer                            :: CHUNK

        !Begin---------------------------------------------------------------------


        if (Me%ComputeOptions%BaroclinicMethod == Leibniz .or. Me%ComputeOptions%BaroclinicMethod == Leibniz2) then

            Hcenter (KUB+1) = null_real
            Hcenter (KUB  ) = (dble(SZZ (i, j, KUB)) + dble(SZZ (ileft, jleft, KUB))) / 2. + dble(DUZ_VZ( i, j, KUB) / 2.)

            do k = KUB-1 , kbottom, -1
                Hcenter(k)  = Hcenter(k+1) + dble(DUZ_VZ( i, j, k+1) / 2.) + dble(DUZ_VZ( i, j, k) / 2.)
            enddo

        else

            Hcenter (KUB+1) = 0
            Hcenter (KUB  ) = dble(DUZ_VZ( i, j, KUB) / 2.)

            do k = KUB-1 , kbottom, -1
                Hcenter(k)  = Hcenter(k+1) + dble(DUZ_VZ( i, j, k+1) / 2.) + dble(DUZ_VZ( i, j, k) / 2.)
            enddo

            Hright  (KUB+1) = 0.0 !rcm 9
            Hleft   (KUB+1) = 0.0

            do k = KUB , kbottom, -1
               Hright  (k) = Hright  (k + 1) + dble(DWZ ( i, j, k))
               Hleft   (k) = Hleft   (k + 1) + dble(DWZ (ileft, jleft, k))
            enddo


            HroRight(KUB+1) = 0.0
            Hroleft (KUB+1) = 0.0


            if      (Me%ComputeOptions%BaroclinicMethod == DensityUniform) then


                do k = KUB , kbottom, -1
                   HroRight(k) = HroRight(k + 1) + dble(SigmaDens(i    ,j    ,k)) * dble(DWZ (    i,    j,  k))
                   Hroleft (k) = Hroleft (k + 1) + dble(SigmaDens(ileft,jleft,k)) * dble(DWZ (ileft, jleft, k))
                enddo


            else if (Me%ComputeOptions%BaroclinicMethod == DensityLinear) then

                DensRight(KUB+1)   = dble(SigmaDens(i    ,j    ,KUB    ))
                DensLeft (KUB+1)   = dble(SigmaDens(ileft,jleft,KUB    ))

                DensRight(kbottom) = dble(SigmaDens(i    ,j    ,kbottom))
                DensLeft (kbottom) = dble(SigmaDens(ileft,jleft,kbottom))

                !griflet: I want to parallelize the calling subroutine, so I un-parallelize the call-ee.
                !CHUNK = CHUNK_K(kbottom+1, KUB)

                !if (MonitorPerformance) then
                !    call StartWatch ("ModuleHydrodynamic", "Calc_depth_and_Hro")
                !endif

                !!!! $OMP PARALLEL PRIVATE(k)
                !!!! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = kbottom+1, KUB
                   DensRight(k) = (dble(SigmaDens(i    ,j    ,k  )) * dble(DWZ (    i,    j,  k-1)) +  &
                                   dble(SigmaDens(i    ,j    ,k-1)) * dble(DWZ (    i,    j,  k  ))) / &
                                  (dble(DWZ    (i    ,j    ,k-1)) + dble(DWZ (    i,    j,  k  )))

                   DensLeft (k) = (dble(SigmaDens(ileft,jleft,k  )) * dble(DWZ (ileft,jleft,  k-1)) +  &
                                   dble(SigmaDens(ileft,jleft,k-1)) * dble(DWZ (ileft,jleft,  k  ))) / &
                                  (dble(DWZ    (ileft,jleft,k-1)) + dble(DWZ (ileft,jleft,  k  )))
                enddo
                !!!! $OMP END DO
                !!!! $OMP END PARALLEL

                !if (MonitorPerformance) then
                !    call StopWatch ("ModuleHydrodynamic", "Calc_depth_and_Hro")
                !endif

                DensRight(kbottom : KUB+1) =  DensRight(kbottom : KUB+1)
                DensLeft (kbottom : KUB+1) =  DensLeft (kbottom : KUB+1)

                do k = KUB , kbottom, -1
                   HroRight(k) = HroRight(k + 1) + (DensRight(k+1) + DensRight(k)) / 2. * dble(DWZ (    i,    j,  k))
                   Hroleft (k) = Hroleft (k + 1) + (DensLeft (k+1) + DensLeft (k)) / 2. * dble(DWZ (ileft, jleft, k))
                enddo

            endif

        endif

    End subroutine calc_depth_and_Hro

    !-------------------------------------------------

    subroutine Calc_Depth_integration(Hcenter, Hleft, Hright,  &
                                      Kleft, Kright, Depth_integ, KUB, kbottom)



        ! External variables

        Integer, intent(in )             :: KUB, kbottom

        !griflet: these arguments are intent(out)
        Real(8), pointer, dimension( : ) :: Hleft, Hright, Hcenter
        Integer, pointer, dimension( : ) :: kleft, kright
        Real(8), pointer, dimension( : ) :: Depth_integ

        ! Internal

        Integer  :: k

        !------------------------------------------------------------------------

!        Depth_integ = 0 !rcm 10
!        kleft       = 0
!        kright      = 0

dok:     do k=KUB,kbottom,-1

          kleft (k) = Locate_Layer(KUB, kbottom, Hcenter(k), Hleft )
          kright(k) = Locate_Layer(KUB, kbottom, Hcenter(k), Hright)

          Depth_integ(k)= min(Hcenter(k), Hleft(kleft (k)), Hright(kright(k)) )

          kleft (k) = Locate_Layer (KUB, kbottom, Depth_integ(k), Hleft )
          kright(k) = Locate_Layer (KUB, kbottom, Depth_integ(k), Hright)

        enddo dok

    end subroutine Calc_Depth_integration

    !--------------------------------------------------------------------

    function Locate_Layer (KUB, kbottom, Zpoint, Zside)
    Integer  :: Locate_Layer

        ! External variables

        Integer,   intent(in )                       :: KUB, kbottom
        Real(8),   pointer, dimension(:)             :: Zside
        Real(8), intent(in)                          :: Zpoint
        ! Internal
        Integer                   :: k_Locate_Layer

        k_Locate_Layer = KUB

        Do While ( (Zside(k_Locate_Layer) < Zpoint) .and. (k_Locate_Layer > kbottom) )
            k_Locate_Layer = k_Locate_Layer -1
        Enddo

        Locate_Layer=k_Locate_Layer

    end function Locate_Layer

    !--------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the vertical water flow                                                      !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Modify_VerticalWaterFlow2( Grid)

        !Variables Categories
            !Geometry  : Volume_Z_New, Volume_Z_Old
            !Flow      : WaterFlux_X, WaterFlux_Y, WaterFlux_Z
            !Mapping   : ComputeFaces3D_U, ComputeFaces3D_V

        !Arguments------------------------------------------------------------

        integer                            :: Grid

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_Z_New, Volume_Z_Old, WaterFlux_X,   &
                                              WaterFlux_Y, WaterFlux_Z, DischargeFlow,   &
                                              qX, qY

        real,    dimension(:,:)  , pointer :: DXX, DYY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V,        &
                                              WaterPoints3D,                             &
                                              ImposedNormalFacesU, ImposedNormalFacesV,  &
                                              ImposedTangentialFacesU,                   &
                                              ImposedTangentialFacesV

        integer, dimension(:,:  ), pointer :: BoundaryPoints

!        real                               :: DT_Elevation, Evolution
        real                               :: Evolution, DT
        real(8)                            :: dVdt, Discharge,                           &
                                              WestFlux, EastFlux, SouthFlux, NorthFlux

        logical                            :: DischargesON

        integer                            :: I, J, K, IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: STAT_CALL

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

!        DT_Elevation = Me%WaterLevel%DT
        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Modify_VerticalWaterFlow - ModuleHydrodynamic - ERR00.'

        Volume_Z_New      => Me%External_Var%Volume_Z_New
        Volume_Z_Old      => Me%External_Var%Volume_Z_Old

        ComputeFaces3D_U  => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V  => Me%External_Var%ComputeFaces3D_V
        WaterPoints3D     => Me%External_Var%WaterPoints3D

        WaterFlux_X       => Me%WaterFluxes%X
        WaterFlux_Y       => Me%WaterFluxes%Y
        WaterFlux_Z       => Me%WaterFluxes%Z
        DischargeFlow     => Me%WaterFluxes%Discharges

        ImposedNormalFacesU      => Me%External_Var%ImposedNormalFacesU
        ImposedTangentialFacesU  => Me%External_Var%ImposedTangentialFacesU
        ImposedNormalFacesV      => Me%External_Var%ImposedNormalFacesV
        ImposedTangentialFacesV  => Me%External_Var%ImposedTangentialFacesV
        BoundaryPoints           => Me%External_Var%BoundaryPoints
        DYY                      => Me%External_Var%DYY
        DXX                      => Me%External_Var%DXX
        qX                       => Me%SubModel%qX
        qY                       => Me%SubModel%qY

        !End - Shorten variables name

        !Compute volume variation if the grid is not fixed
        if (Grid == Variable) then

            Evolution = 1.

        else if (Grid == Fix) then

            Evolution = 0.

        else
            stop 'Subroutine Modify_VerticalWaterFlow - ModuleHydrodynamic. ERR01'
        endif

        DischargesON = .false.

        Discharge    = 0.

        if (associated(DischargeFlow)) then

            DischargesON = .true.

        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_VerticalWaterFlow")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,dVdt,Discharge,WestFlux,EastFlux,SouthFlux) &
        !$OMP PRIVATE(NorthFlux)

        !Fluxes divergence
dok3:   do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj3:   do j = JLB, JUB
doi3:   do i = ILB, IUB
!            dVdt =  dble(Evolution) * (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / &
!                    dble(DT_Elevation )
            dVdt =  dble(Evolution) * (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / &
                    dble(DT)
                    !E preciso alterar esta parte para que se possa calcular fluxos verticais independentemente
                    !de como sao calculados os fluxos horizontais

            if (DischargesON) Discharge = DischargeFlow (i    , j    , k)


            WaterFlux_Z(i, j, k + 1) = WaterFlux_Z          (i    , j    , k)     +      &  !Bottom Face
                                       WaterFlux_X          (i    , j    , k)     *      &
                                       dble(ComputeFaces3D_U(i    , j    , k))    -      &  !West Face
                                       WaterFlux_X          (i    , j + 1, k)     *      &
                                       dble(ComputeFaces3D_U(i    , j + 1, k))    +      &  !East Face
                                       WaterFlux_Y          (i    , j    , k)     *      &
                                       dble(ComputeFaces3D_V(i    , j    , k))    -      &  !South Face
                                       WaterFlux_Y          (i + 1, j    , k)     *      &
                                       dble(ComputeFaces3D_V(i + 1, j    , k))    +      &  !North Face
                                       Discharge                                  *      &
                                       dble(WaterPoints3D   (i    , j    , k))    -      &  !Discharges contribution
                                       dVdt

        enddo doi3
        enddo doj3
        !$OMP END DO
        enddo dok3

cd5:    if (Me%SubModel%ON) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)

            !Fluxes divergence
            doj4: do j = JLB, JUB
            doi4: do i = ILB, IUB


cd4:            if (BoundaryPoints(i, j) == Boundary) then

                    dok4: do k = KLB, KUB

                            dVdt =  dble(Evolution) * (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / &
                                dble(DT)

                            if (DischargesON) Discharge = DischargeFlow (i    , j    , k)


                            !West Face
                            WestFlux = WaterFlux_X(i, j, k) * dble(ComputeFaces3D_U(i, j, k)) + &
                                       qX         (i, j, k) * dble(DYY             (i, j   )) * &
                                       (dble(ImposedNormalFacesU    (i,   j, k))              + &
                                        dble(ImposedTangentialFacesU(i,   j, k)))

                            !East Face
                            EastFlux = WaterFlux_X(i, j+1, k) * dble(ComputeFaces3D_U(i, j+1, k)) + &
                                       qX         (i, j+1, k) * dble(DYY             (i, j+1))    * &
                                       (dble(ImposedNormalFacesU    (i, j+1, k))                  + &
                                        dble(ImposedTangentialFacesU(i, j+1, k)))



                            !South Face
                            SouthFlux = WaterFlux_Y(i, j, k) * dble(ComputeFaces3D_V (i, j, k)) + &
                                        qY         (i, j, k) * dble(DXX              (i, j))    * &
                                       (dble(ImposedNormalFacesV    (i  , j, k))                + &
                                        dble(ImposedTangentialFacesV(i  , j, k)))


                            !North Face
                            NorthFlux = WaterFlux_Y(i+1, j, k) * dble(ComputeFaces3D_V (i+1, j, k)) + &
                                        qY         (i+1, j, k) * dble(DXX              (i+1, j))    * &
                                       (dble(ImposedNormalFacesV    (i+1, j, k))                    + &
                                        dble(ImposedTangentialFacesV(i+1, j, k)))



                            WaterFlux_Z(i, j, k + 1) = WaterFlux_Z          (i    , j    , k)      + &  !Bottom Face
                                                       WestFlux - EastFlux + SouthFlux - NorthFlux + &
                                                       Discharge                                   * &
                                                       dble(WaterPoints3D   (i    , j    , k))     - &  !Discharges contribution
                                                       dVdt

                        enddo dok4
                    endif cd4

            enddo doi4
            enddo doj4
            !$OMP END DO


        endif cd5

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_VerticalWaterFlow")
        endif

        !Nullify auxiliar pointers
        nullify(Volume_Z_New)
        nullify(Volume_Z_Old)

        nullify(ComputeFaces3D_U)
        nullify(ComputeFaces3D_V)
        nullify(WaterPoints3D   )

        nullify(WaterFlux_X)
        nullify(WaterFlux_Y)
        nullify(WaterFlux_Z)
        nullify(DischargeFlow)

        nullify(ImposedNormalFacesU    )
        nullify(ImposedTangentialFacesU)
        nullify(ImposedNormalFacesV    )
        nullify(ImposedTangentialFacesV)
        nullify(BoundaryPoints         )
        nullify(DYY                    )
        nullify(DXX                    )
        nullify(qX                     )
        nullify(qY                     )

    end Subroutine Modify_VerticalWaterFlow2

    !>@author Paulo Chambel Hidromod
    !>@Brief
    !>Computes vertical waterflow.
    !>Edited By Joao Sobrinho - 09-2019
    !>@param[in] Grid
    Subroutine Modify_VerticalWaterFlow( Grid)

        !Arguments------------------------------------------------------------
        integer                            :: Grid
        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: DischargeFlow

        real                               :: Evolution, DT, AccumulatedDischarge
        logical                            :: DischargesON
        integer                            :: I, J, K, IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: STAT_CALL
        integer                            :: CHUNK
        !Begin--------------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Modify_VerticalWaterFlow - ModuleHydrodynamic - ERR00.'

        DischargeFlow     => Me%WaterFluxes%Discharges
        !End - Shorten variables name

        !Compute volume variation if the grid is not fixed
        if (Grid == Variable) then
            Evolution = 1.
        else if (Grid == Fix) then
            Evolution = 0.
        else
            stop 'Subroutine Modify_VerticalWaterFlow - ModuleHydrodynamic. ERR01'
        endif

        DischargesON = .false.
        if (associated(DischargeFlow)) DischargesON = .true.

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Modify_VerticalWaterFlow")
        endif

        !Main ------------------------------------------------------------------------------------------------
        if (Evolution == 1)then
            call WaterFlux_Z_VarGrid (Me%External_Var%Volume_Z_New, Me%External_Var%Volume_Z_Old, &
                                        Me%WaterFluxes%X, Me%WaterFluxes%Y, Me%WaterFluxes%Z,       &
                                        Me%External_Var%ComputeFaces3D_U, Me%External_Var%ComputeFaces3D_V, DT)
        else
            call WaterFlux_Z_FixGrid (Me%WaterFluxes%X, Me%WaterFluxes%Y, Me%WaterFluxes%Z,       &
                                        Me%External_Var%ComputeFaces3D_U, Me%External_Var%ComputeFaces3D_V)
        endif

        if (DischargesON) then
            !$OMP PARALLEL PRIVATE(i,j,k, AccumulatedDischarge)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
                if (Me%External_Var%WaterPoints3D(i, j, KUB) == 1) then
                    AccumulatedDischarge = DischargeFlow(i, j, KLB)
                    do k = KLB + 1, KUB + 1
                        Me%WaterFluxes%Z(i, j, k) = Me%WaterFluxes%Z(i, j, k) + AccumulatedDischarge
                        AccumulatedDischarge      = AccumulatedDischarge      + DischargeFlow(i, j, k)
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
        endif

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Modify_VerticalWaterFlow")
        endif

        !Nullify auxiliar pointers
        nullify(DischargeFlow)

    end Subroutine Modify_VerticalWaterFlow

    !---------------------------------------------------------------------------------------

    !----------------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !>Computes vertical waterflow for a variable grid
    !>@param[in] Volume_Z_New, Volume_Z_Old, WaterFlux_X, WaterFlux_Y, WaterFlux_Z, ComputeFaces3D_U, &
    !>ComputeFaces3D_V, DT
    subroutine WaterFlux_Z_VarGrid (Volume_Z_New, Volume_Z_Old, WaterFlux_X, WaterFlux_Y, WaterFlux_Z, &
         ComputeFaces3D_U, ComputeFaces3D_V, DT)

        !Arguments-------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: WaterFlux_Z
        real(8), dimension(:,:,:), pointer, intent(IN)    :: WaterFlux_X, WaterFlux_Y, Volume_Z_New, Volume_Z_Old
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U, ComputeFaces3D_V
        real,                               intent(IN)    :: DT
        !Local---------------------------------------------------------------------
        real(8)                                           :: WestFace, EastFace, NorthFace, SouthFace, dVdT
        integer                                           :: I, J, K, IUB, ILB, JUB, JLB, KUB, KLB, CHUNK
        !Begin--------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i,j,k,dVdt, WestFace, EastFace, SouthFace, NorthFace)
        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                dVdt =   (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) / dble(DT)

                WestFace  = WaterFlux_X(i  , j  , k) * dble(ComputeFaces3D_U(i  , j  , k))
                EastFace  = WaterFlux_X(i  , j+1, k) * dble(ComputeFaces3D_U(i  , j+1, k))
                SouthFace = WaterFlux_Y(i  , j  , k) * dble(ComputeFaces3D_V(i  , j  , k))
                NorthFace = WaterFlux_Y(i+1, j  , k) * dble(ComputeFaces3D_V(i+1, j  , k))

                WaterFlux_Z(i, j, k + 1) = WaterFlux_Z(i, j, k) + WestFace - EastFace + SouthFace - NorthFace - dVdt
            endif
        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL
    end subroutine WaterFlux_Z_VarGrid

    !--------------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !>Computes vertical waterflow for a fixed grid
    !>@param[in] WaterFlux_X, WaterFlux_Y, WaterFlux_Z, ComputeFaces3D_U, ComputeFaces3D_V
    subroutine WaterFlux_Z_FixGrid (WaterFlux_X, WaterFlux_Y, WaterFlux_Z, ComputeFaces3D_U, ComputeFaces3D_V)

        !Arguments-------------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: WaterFlux_Z
        real(8), dimension(:,:,:), pointer, intent(IN)    :: WaterFlux_X, WaterFlux_Y
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U, ComputeFaces3D_V
        !Local---------------------------------------------------------------------
        real(8)                                           :: SouthFace, WestFace, EastFace, NorthFace
        integer                                           :: I, J, K, IUB, ILB, JUB, JLB, KUB, KLB, CHUNK
        !Begin--------------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i,j,k, WestFace, EastFace, SouthFace, NorthFace)
        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                WestFace  = WaterFlux_X(i  , j  , k) * dble(ComputeFaces3D_U(i  , j  , k))
                EastFace  = WaterFlux_X(i  , j+1, k) * dble(ComputeFaces3D_U(i  , j+1, k))
                SouthFace = WaterFlux_Y(i  , j  , k) * dble(ComputeFaces3D_V(i  , j  , k))
                NorthFace = WaterFlux_Y(i+1, j  , k) * dble(ComputeFaces3D_V(i+1, j  , k))

                WaterFlux_Z(i, j, k + 1) = WaterFlux_Z(i, j, k) + WestFace - EastFace + SouthFace - NorthFace
            endif
        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL
    end subroutine WaterFlux_Z_FixGrid

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Filter the vertical and horizontal Fluxes                                            !
    !                                                                                      !
    ! Input : Flow, Mapping                                                                !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    ! Main Objective: To imposed vertical flux null at the Z boundary points               !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Filter_3D_Fluxes
        !Variables Categories
            !Flow      : WaterFlux_Z
            !Mapping   : BoundaryPoints
        !Local---------------------------------------------------------------------
        integer                            :: I, J, K
        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Filter_3D_Fluxes")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%External_Var%BoundaryPoints(i, j) == 1) then
                do k = Me%WorkSize%KLB + 1, Me%WorkSize%KUB + 1
                    !Vertical flux null at the open boundary points
                    Me%WaterFluxes%Z(i, j, k) = 0
                enddo
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Filter_3D_Fluxes")
        endif

    end subroutine Filter_3D_Fluxes

    !------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Defines a boundary condition for the vertical water fluxes in the boundary
    !                                                                                      !
    ! Input : Flow, Mapping                                                                !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (2001/6)                                                       !
    ! Main Objective: To imposed radiation boundary condition in the baroclinic            !
    !                 component of the vertical flux at the Z boundary points              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Boundary_VerticalFlow ( Grid)

        !Arguments------------------------------------------------------------

        integer                            :: Grid

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_X, WaterFlux_Y
        real   , dimension(:,:  ), pointer :: DZX, DZY

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_U, ComputeFaces3D_V
        integer, dimension(:,:  ), pointer :: BoundaryFacesU, BoundaryFacesV, BoundaryPoints

        integer                            :: I, J, IUB, ILB, JUB, JLB, KUB

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DZX               => Me%External_Var%DZX
        DZY               => Me%External_Var%DZY

        BoundaryFacesU    => Me%External_Var%BoundaryFacesU
        BoundaryFacesV    => Me%External_Var%BoundaryFacesV
        BoundaryPoints    => Me%External_Var%BoundaryPoints

        ComputeFaces3D_U  => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V  => Me%External_Var%ComputeFaces3D_V

        WaterFlux_X       => Me%WaterFluxes%X
        WaterFlux_Y       => Me%WaterFluxes%Y

        !End - Shorten variables name


        if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_)        &
            call ComputeBaroclinicVertVelocity( Grid)

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Boundary_VerticalFlow")
        endif

        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
   do1: do j = JLB, JUB
   do2: do i = ILB, IUB

            if (BoundaryFacesU(i, j) == Boundary .and. ComputeFaces3D_U(i, j, KUB) == Covered) then


                if (BoundaryPoints(i, j) == Boundary) then

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_X,  &
                                                  WaterFlux_YX = WaterFlux_Y,                   &
                                                  i = i, j = j, di = 0, dj = 1, db = 1)


                else

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_X,  &
                                                  WaterFlux_YX = WaterFlux_Y,                   &
                                                  i = i, j = j, di = 0, dj = 1, db = 0)
                endif



            endif

        enddo do2
        enddo do1
        !$OMP END DO

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do3:    do j = JLB, JUB
do4:    do i = ILB, IUB

            if (BoundaryFacesV(i, j) == Boundary .and. ComputeFaces3D_V(i, j, KUB) == Covered) then

                if (BoundaryPoints(i, j) == Boundary) then

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_Y, &
                                                  WaterFlux_YX = WaterFlux_X,                  &
                                                  i = i, j = j, di = 1, dj = 0, db = 1)
                else

                    call Compute_BoundaryVertFlux( WaterFlux_XY = WaterFlux_Y, &
                                                  WaterFlux_YX = WaterFlux_X,                  &
                                                  i = i, j = j, di = 1, dj = 0, db = 0)

                endif


            endif

        enddo do4
        enddo do3
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Boundary_VerticalFlow")
        endif

        !Nullify auxiliar pointers
        nullify(DZX , DZY       )
        nullify(ComputeFaces3D_U)
        nullify(ComputeFaces3D_V)
        nullify(BoundaryFacesU  )
        nullify(BoundaryFacesV  )
        nullify(BoundaryPoints  )

        nullify(WaterFlux_X     )
        nullify(WaterFlux_Y     )

    end Subroutine Boundary_VerticalFlow

    !------------------------------------------------------------------------------

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Defines a boundary condition for the vertical water fluxes in the boundary
    !                                                                                      !
    ! Input : Flow, Mapping                                                                !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (2001/6)                                                       !
    ! Main Objective: To imposed radiation boundary condition in the baroclinic            !
    !                 component of the vertical flux at the Z boundary points              !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Compute_BoundaryVertFlux ( WaterFlux_XY, WaterFlux_YX,    &
                                         i, j, di, dj, db)

        !Arguments------------------------------------------------------------

        real(8), dimension(:,:,:), pointer :: WaterFlux_XY, WaterFlux_YX
        integer                            :: i, j, di, dj, db

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: WaterFlux_Z
        real   , dimension(:,:,:), pointer :: Velocity_Z, Vel_Z_Cartesian,               &
                                              Vel_Z_Baroclinic, SZZ, Density,            &
                                              Vel_Z_BaroclinicOld
        real   , dimension(:,:  ), pointer :: WaterLevel_New, WaterLevel_Old, DUX, DVY
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_W
        integer, dimension(:,:  ), pointer :: KFloor_Z

        real                               :: Vel_Z_BoundBarot,                          &
                                              Vel_Z_B_BarocUp,  Vel_Z_B_BarocLow
        real                               :: DT_Elevation
        real(8)                            :: BarotBoundFlux, BarocBoundFlux,            &
                                              DivBarocFlux, dz

        integer                            :: ib, jb, i_int, j_int, K, KUB, i_int2, j_int2, i_ext, j_ext
        integer                            :: i_Tang1, j_Tang1, i_Tang2, j_Tang2
        integer                            :: kbottom

        !Begin--------------------------------------------------------------------------


        !Begin - Shorten variables name
        KUB = Me%WorkSize%KUB


        DT_Elevation        =  Me%WaterLevel%DT

        DUX                 => Me%External_Var%DUX
        DVY                 => Me%External_Var%DVY

        KFloor_Z            => Me%External_Var%KFloor_Z
        SZZ                 => Me%External_Var%SZZ

        Density             => Me%External_Var%Density
        ComputeFaces3D_W    => Me%External_Var%ComputeFaces3D_W

        Velocity_Z          => Me%Velocity%Vertical%Across
        Vel_Z_Cartesian     => Me%Velocity%Vertical%Cartesian
        Vel_Z_Baroclinic    => Me%VelBaroclinic%W_New
        Vel_Z_BaroclinicOld => Me%VelBaroclinic%W_Old

        WaterFlux_Z         => Me%WaterFluxes%Z
        WaterLevel_New      => Me%WaterLevel%New
        WaterLevel_Old      => Me%WaterLevel%Old

        !End - Shorten variables name


        ib    = i - di * (1- db)
        jb    = j - dj * (1- db)

        i_int = i - di * db
        j_int = j - dj * db

        i_int2 = i - di * (3 * db - 1)
        j_int2 = j - dj * (3 * db - 1)

        i_ext  = i + di * (2 * db - 1)
        j_ext  = j + dj * (2 * db - 1)

        i_tang1  = i_ext * (1 - db) + i     * db
        j_tang1  = j_ext * (1 - db) + j     * db

        i_tang2  = i + di * (db - 1) + dj
        j_tang2  = j + dj * (db - 1) + di

        kbottom = KFloor_Z(ib, jb)

        BarotBoundFlux = 0.

dok1:   do k = kbottom, KUB


            !Compute the vertical velocity induced by the
            !water level variation barotropic.
            !To this vertical velocity is called
            !vertical barotropic velocity
            BarotBoundFlux = BarotBoundFlux + WaterFlux_XY(i, j, k)

        enddo dok1

        Vel_Z_B_BarocLow = 0.


dok2:   do k = kbottom + 1, KUB + 1

            ![m/s]           = ([m] - [m]) / [s] * [m] / [m]
            Vel_Z_BoundBarot =  (WaterLevel_New(ib, jb) -  WaterLevel_Old(ib, jb)) / &
                                 DT_Elevation                                      * &
                                (SZZ(ib, jb, kbottom - 1) - SZZ(ib, jb, k - 1))   /  &
                                (SZZ(ib, jb, kbottom - 1) - SZZ(ib, jb, KUB))

cd1:        if (Me%ComputeOptions%BaroclinicRadia == Horizontal_) then

                ![]= [m] / [m]
                dz = dble(SZZ(ib, jb, k - 2) - SZZ(ib, jb, k - 1))    /              &
                     dble(SZZ(ib, jb, kbottom - 1) - SZZ(ib, jb, KUB))



                ![m^3/s]       = [m^3/s] - [m^3/s] * []
                BarocBoundFlux = WaterFlux_XY(i, j, k - 1) - BarotBoundFlux * dz

                DivBarocFlux   = (2*db - 1) * (BarocBoundFlux - WaterFlux_XY(i_ext, j_ext, k - 1))

                !PCL
                DivBarocFlux   = DivBarocFlux + WaterFlux_YX(i_Tang1, j_Tang1, k - 1) - WaterFlux_YX(i_Tang2, j_Tang2, k - 1)

                Vel_Z_B_BarocUp  = DivBarocFlux / DUX(ib, jb) / DVY(ib, jb) + Vel_Z_B_BarocLow

                Vel_Z_B_BarocLow = Vel_Z_B_BarocUp

            else

                Vel_Z_B_BarocUp = 0.

            endif cd1


            !Compute the vertical velocity relatively to the grid
            !When the cartesian velocity is compute in the routine "ComputeCartesianVelocity"
            !the across grid velocity in the boundary points is consider zero so the
            !Vel_Z_Cartesian(ib, jb, k) only consider the mesh velocity in the boundary points

            !Vel_Z_Cartesian(ib, jb, k) - is temporarlly the grid velocity in the boundary points

! Modified by Matthias DELPEY - 13/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            if (Me%ComputeOptions%WaveForcing3D /= GLM) then  !(inchange)

                !Across Velocity           = (cartesian = barotropic + baroclinic) - Grid velocity
                Velocity_Z(ib, jb, k)      = Vel_Z_BoundBarot + Vel_Z_B_BarocUp - Vel_Z_Cartesian(ib, jb, k)

                !In this way the cartesian velocity is computed in a realistic way in the boundary points
                Vel_Z_Cartesian(ib, jb, k) = Vel_Z_BoundBarot + Vel_Z_B_BarocUp

            endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


            !The water flux across grid is also compute for the boundary points
            WaterFlux_Z(ib, jb, k)     = Velocity_Z(ib, jb, k) * DUX(ib, jb) * DVY(ib, jb)



        enddo dok2


        !Nullify auxiliar pointers
        nullify(DUX, DVY           )
        nullify(KFloor_Z           )
        nullify(ComputeFaces3D_W   )
        nullify(SZZ                )
        nullify(Density            )
        nullify(Velocity_Z         )
        nullify(Vel_Z_Cartesian    )
        nullify(Vel_Z_Baroclinic   )
        nullify(Vel_Z_BaroclinicOld)

        nullify(WaterFlux_Z        )
        nullify(WaterLevel_New     )
        nullify(WaterLevel_Old     )


    end Subroutine Compute_BoundaryVertFlux

    !------------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ComputeCartesianVertVelocity_Waves(Grid, MeshSlope)

        !Arguments-------------------------------------------------------------
        integer, optional                   :: Grid
        logical, optional                   :: MeshSlope

        !Local-----------------------------------------------------------------
        real(8), dimension(:,:,:), pointer  :: Volz_old, Volum_z
        real,    dimension(:,:,:), pointer  :: Velocity_W_Cartesian, Velocity_W_Across,  &
                                               uavar, vavar
        real   , dimension(:,:  ), pointer  :: WaterLevel_New, WaterLevel_Old
        integer, dimension(:,:,:), pointer  :: ComputeFaces3D_U, ComputeFaces3D_V,       &
                                               ComputeFaces3D_W, WaterPoints3D

        integer, dimension(:,:  ), pointer  :: BoundaryPoints

        real                                :: velusup, veluinf, velu, velvsup, velvinf, velv, &
                                               dt, dszdt, szzxp1, dzxp1, szzxm1, dzxm1, dszdx, &
                                               szzyp1, dzyp1, szzym1, dzym1, dszdy

        integer                             :: IUB,ILB,JUB,JLB,KUB,KLB, i, j, k

        real,    dimension(:,:  ), pointer  :: dzx, dzy, dux, dvy
        real,    dimension(:,:,:), pointer  :: dwz, szz

        logical                             :: MeshVelocity_, MeshSlope_

        integer                             :: CHUNK

! Modified by Matthias DELPEY - 26/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        real,    dimension(:,:,:), pointer  :: StokesVelU, StokesVelV, StokesVelW_cart
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        !Begin-----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Velocity_W_Cartesian    => Me%Velocity%Vertical%Cartesian
        Velocity_W_Across       => Me%Velocity%Vertical%Across
        uavar                   => Me%Velocity%Horizontal%U%New
        vavar                   => Me%Velocity%Horizontal%V%New
        dt                      =  Me%Waterlevel%DT
        ComputeFaces3D_U        => Me%External_Var%ComputeFaces3D_U
        ComputeFaces3D_V        => Me%External_Var%ComputeFaces3D_V
        ComputeFaces3D_W        => Me%External_Var%ComputeFaces3D_W
        WaterPoints3D           => Me%External_Var%WaterPoints3D
        BoundaryPoints          => Me%External_Var%BoundaryPoints
        Volz_old                => Me%External_Var%Volume_Z_Old
        Volum_z                 => Me%External_Var%Volume_Z_New
        dzx                     => Me%External_Var%DZX
        dzy                     => Me%External_Var%DZY
        dux                     => Me%External_Var%DUX
        dvy                     => Me%External_Var%DVY
        dwz                     => Me%External_Var%DWZ
        szz                     => Me%External_Var%SZZ


        WaterLevel_New          => Me%WaterLevel%New
        WaterLevel_Old          => Me%WaterLevel%Old

! Modified by Matthias DELPEY - 26/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        StokesVelU          => Me%StokesVel%Horizontal%U%New
        StokesVelV          => Me%StokesVel%Horizontal%V%New
        StokesVelW_cart     => Me%StokesVel%Vertical%Cartesian
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        ! ciclo a todos os pontos interiores

        dszdt = 0.
        velu  = 0.
        dszdx = 0.
        velv  = 0.
        dszdy = 0.


        if (Present(Grid)) then

            if      (Grid == Variable) then

                MeshVelocity_ = .true.

            else if (Grid == Fix     ) then

                MeshVelocity_ = .false.

            endif

        else

            MeshVelocity_ = .true.

        endif

        if (Present(MeshSlope)) then

            MeshSlope_ = MeshSlope

        else

            MeshSlope_ = .true.

        endif

        CHUNK = CHUNK_I(ILB, IUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ComputeCartesianVertVelocity_Waves")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,dszdt,szzxp1,dzxp1,szzxm1,dzxm1,dszdx) &
        !$OMP PRIVATE(szzyp1,dzyp1,szzym1,dzym1,dszdy,velusup,veluinf,velvsup) &
        !$OMP PRIVATE(velvinf,velu,velv)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:    do i = ILB, IUB
do2:    do j = JLB, JUB
            dszdt=0.0

            if (WaterPoints3D(i, j, KUB) == WaterPoint) then

! Modified by Matthias DELPEY - 26/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                ! Velocity_W_Cartesian(i,j,KUB+1)= (WaterLevel_New(i,j)-WaterLevel_Old(i,j)) / dt

                if (Me%ComputeOptions%WaveForcing3D /= GLM) then
                    Velocity_W_Cartesian(i,j,KUB+1)= (WaterLevel_New(i,j)-WaterLevel_Old(i,j)) / dt
                else
                    Velocity_W_Cartesian(i,j,KUB+1)= (WaterLevel_New(i,j)-WaterLevel_Old(i,j)) / dt  &
                                                     - StokesVelW_cart(i,j,KUB+1)
                endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            endif

do3:        do k = KLB, KUB

cd1:            if (ComputeFaces3D_W(i,j,k) == Covered ) then

                    ! mesh velocity
                    if (MeshVelocity_) then
                            dszdt  = dszdt-(volum_z(i,j,k-1)-volz_old(i,j,k-1))/dux(i,j)/dvy(i,j)/dt
                    endif

                    

cd2:                if (MeshSlope_ .and. BoundaryPoints(i, j) /= Boundary) then

                        ! mesh slope in X direction: central, progressive or regressive differences are used as a function of the
                        ! land boundary. The boundary is automatically detected in the equation through "ComputeFaces3D_W" matrix
                        szzxp1 = ComputeFaces3D_W(i,j+1,k)*szz(i,j+1,k-1)+(1-ComputeFaces3D_W(i,j+1,k))*szz(i,j,k-1)
                        dzxp1  = ComputeFaces3D_W(i,j+1,k)*dzx(i,j)
                        szzxm1 = ComputeFaces3D_W(i,j-1,k)*szz(i,j-1,k-1)+(1-ComputeFaces3D_W(i,j-1,k))*szz(i,j,k-1)
                        dzxm1  = ComputeFaces3D_W(i,j-1,k)*dzx(i,j-1)
                        if ((dzxp1+dzxm1) /= 0) then
                          dszdx=(szzxp1-szzxm1)/(dzxp1+dzxm1)
                        else
                          dszdx=0.0
                        endif

                        ! mesh slope in Y direction: central, progressive or regressive differences are used as a function of the
                        ! land boundary. The boundary is automatically detected in the equation through "ComputeFaces3D_W" matrix
                        szzyp1 = ComputeFaces3D_W(i+1,j,k)*szz(i+1,j,k-1)+(1-ComputeFaces3D_W(i+1,j,k))*szz(i,j,k-1)
                        dzyp1  = ComputeFaces3D_W(i+1,j,k)*dzy(i,j)
                        szzym1 = ComputeFaces3D_W(i-1,j,k)*szz(i-1,j,k-1)+(1-ComputeFaces3D_W(i-1,j,k))*szz(i,j,k-1)
                        dzym1  = ComputeFaces3D_W(i-1,j,k)*dzy(i-1,j)
                        if ((dzyp1+dzym1) /= 0) then
                          dszdy=(szzyp1-szzym1)/(dzyp1+dzym1)
                        else
                          dszdy=0.0
                        endif

! Modified by Matthias DELPEY - 26/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        !! Velocity components at cell center
                        !if ((ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k)) /=0) then
                        !    velusup=(ComputeFaces3D_U(i,j,k)*uavar(i,j,k)+ComputeFaces3D_U(i,j+1,k)*uavar(i,j+1,k))/ &
                        !            (ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k))
                        !else
                        !    velusup=0.0
                        !endif
                        !if ((ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)) /=0) then
                        !    veluinf=(ComputeFaces3D_U(i,j,k-1)*uavar(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)*uavar(i,j+1,k-1))/ &
                        !            (ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1))
                        !else
                        !    veluinf=0.0
                        !endif
                        !velu=(velusup*dwz(i,j,k-1)+veluinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))
                        !
                        !if ((ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k)) /=0) then
                        !    velvsup=(ComputeFaces3D_V(i,j,k)*vavar(i,j,k)+ComputeFaces3D_V(i+1,j,k)*vavar(i+1,j,k))/ &
                        !            (ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k))
                        !else
                        !    velvsup=0.0
                        !endif
                        !if ((ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)) /=0) then
                        !    velvinf=(ComputeFaces3D_V(i,j,k-1)*vavar(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)*vavar(i+1,j,k-1))/ &
                        !            (ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1))
                        !else
                        !    velvinf=0.0
                        !endif
                        !
                        !velv=(velvsup*dwz(i,j,k-1)+velvinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))
                        !

                        ! Velocity components at cell center
                        if ((ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k)) /=0) then
                            velusup=(ComputeFaces3D_U(i,j,k)*uavar(i,j,k)+ComputeFaces3D_U(i,j+1,k)*uavar(i,j+1,k))/ &
                                    (ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k))

                            if (Me%ComputeOptions%WaveForcing3D == GLM) then
                                ! Stokes drift contribution to advection
                                velusup = velusup +                                         &
                                         ( ComputeFaces3D_U(i,j,k)*StokesVelU(i,j,k)      + &
                                          ComputeFaces3D_U(i,j+1,k)*StokesVelU(i,j+1,k) ) / &
                                         (ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k))
                            endif

                        else
                            velusup=0.0
                        endif
                        if ((ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)) /=0) then
                            veluinf=(ComputeFaces3D_U(i,j,k-1)*uavar(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)*uavar(i,j+1,k-1))/ &
                                    (ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1))

                            if (Me%ComputeOptions%WaveForcing3D == GLM) then
                                veluinf = veluinf                                              + &
                                          ( ComputeFaces3D_U(i,j,k-1)*StokesVelU(i,j,k-1)      + &
                                           ComputeFaces3D_U(i,j+1,k-1)*StokesVelU(i,j+1,k-1) ) / &
                                          (ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1))
                            endif

                        else
                            veluinf=0.0
                        endif

                        velu=(velusup*dwz(i,j,k-1)+veluinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))

                        if ((ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k)) /=0) then
                            velvsup=(ComputeFaces3D_V(i,j,k)*vavar(i,j,k)+ComputeFaces3D_V(i+1,j,k)*vavar(i+1,j,k))/ &
                                    (ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k))

                            if (Me%ComputeOptions%WaveForcing3D == GLM) then
                                velvsup = velvsup                                          + &
                                          ( ComputeFaces3D_V(i,j,k)*StokesVelV(i,j,k)      + &
                                           ComputeFaces3D_V(i+1,j,k)*StokesVelV(i+1,j,k) ) / &
                                          (ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k))
                            endif

                        else
                            velvsup=0.0
                        endif
                        if ((ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)) /=0) then
                            velvinf=(ComputeFaces3D_V(i,j,k-1)*vavar(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)*vavar(i+1,j,k-1))/ &
                                    (ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1))

                            if (Me%ComputeOptions%WaveForcing3D == GLM) then
                                velvinf = velvinf                                             + &
                                          (ComputeFaces3D_V(i,j,k-1)*StokesVelV(i,j,k-1)      + &
                                           ComputeFaces3D_V(i+1,j,k-1)*StokesVelV(i+1,j,k-1)) / &
                                          (ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1))
                            endif

                        else
                            velvinf=0.0
                        endif

                        velv=(velvsup*dwz(i,j,k-1)+velvinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                    else  cd2

                          dszdx=0.0
                          dszdy=0.0

                    endif cd2

! Modified by Matthias DELPEY - 26/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    !!Cartesian vertical velocity
                    !Velocity_W_Cartesian(i,j,k)=Velocity_W_Across(i,j,k) - dszdt - velu * dszdx - velv * dszdy

                    !Cartesian vertical velocity
                    if (Me%ComputeOptions%WaveForcing3D /= GLM) then 
                        
                        Velocity_W_Cartesian(i,j,k)=Velocity_W_Across(i,j,k) - dszdt - velu * dszdx - velv * dszdy
                        
                    else

                        Velocity_W_Cartesian(i,j,k)=Velocity_W_Across(i,j,k) - dszdt - velu * dszdx - velv * dszdy  &
                                                    - StokesVelW_cart(i,j,k)
                    endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                endif cd1
            enddo do3

        enddo do2
        enddo do1
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ComputeCartesianVertVelocity_Waves")
        endif

        if (Me%CyclicBoundary%ON) then

            call CyclicBoundVertical (Vector = Velocity_W_Cartesian)

        endif


        !nulify auxiliar variables
        nullify(Velocity_W_Cartesian, Velocity_W_Across, uavar, vavar, ComputeFaces3D_U, ComputeFaces3D_V, &
                ComputeFaces3D_W, Volz_old, Volum_z, dzx, dzy, dux, dvy, dwz, szz, WaterPoints3D)

        nullify(WaterLevel_New, WaterLevel_Old)

        nullify(BoundaryPoints)

    !----------------------------------------------------------------------

    end subroutine ComputeCartesianVertVelocity_Waves

    !-----------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> computes vertical velocity
    Subroutine ComputeCartesianVertVelocity(Grid, MeshSlope)

        !Arguments-------------------------------------------------------------
        integer, optional                   :: Grid
        logical, optional                   :: MeshSlope

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer  :: Velocity_W_Cartesian
        real   , dimension(:,:  ), pointer  :: WaterLevel_New, WaterLevel_Old
        integer, dimension(:,:,:), pointer  :: WaterPoints3D
        real                                :: dt
        integer                             :: IUB,ILB,JUB,JLB,KUB,KLB,i, j, CHUNK
        logical                             :: MeshVelocity_, MeshSlope_
        !Begin-----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        Velocity_W_Cartesian    => Me%Velocity%Vertical%Cartesian
        dt                      =  Me%Waterlevel%DT
        WaterPoints3D           => Me%External_Var%WaterPoints3D
        WaterLevel_New          => Me%WaterLevel%New
        WaterLevel_Old          => Me%WaterLevel%Old

        ! ciclo a todos os pontos interiores

        MeshVelocity_ = .true.
        if (Present(Grid)) then
            if (Grid == Fix) MeshVelocity_ = .false.
        endif

        MeshSlope_ = .true.
        if (Present(MeshSlope)) MeshSlope_ = MeshSlope

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ComputeCartesianVertVelocity")
        endif
            
        where (Me%External_Var%ComputeFaces3D_W(:,:,:) == 1) &
                Velocity_W_Cartesian(:,:,:) = Me%Velocity%Vertical%Across(:,:,:)

        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if (WaterPoints3D(i, j, KUB) == WaterPoint) then

                Velocity_W_Cartesian(i,j,KUB+1)= (WaterLevel_New(i,j) - WaterLevel_Old(i,j)) / dt

            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MeshVelocity_) then

            call CartesianVertVelocity_dszdt (Me%External_Var%Volume_Z_New, Me%External_Var%Volume_Z_Old,  &
                                                Me%External_Var%DUX, Me%External_Var%DVY, Me%Waterlevel%DT,  &
                                                Me%Velocity%Vertical%Cartesian, Me%External_Var%ComputeFaces3D_W, &
                                                Me%External_Var%KFloor_Z)

        endif
        
        if (MeshSlope_) then
            
            call CartesianVertVelocity_X (Me%External_Var%ComputeFaces3D_W, Me%External_Var%ComputeFaces3D_U,            &
                                          Me%External_Var%BoundaryPoints, Me%External_Var%SZZ, Me%External_Var%DZX,      &
                                          Me%External_Var%DWZ, Me%Velocity%Horizontal%U%New,                             &
                                          Me%Velocity%Vertical%Cartesian, Me%External_Var%KFloor_Z)
            
            call CartesianVertVelocity_Y (Me%External_Var%ComputeFaces3D_W, Me%External_Var%ComputeFaces3D_V,       &
                                          Me%External_Var%BoundaryPoints, Me%External_Var%SZZ, Me%External_Var%DZY, &
                                          Me%External_Var%DWZ, Me%Velocity%Horizontal%V%New,                        &
                                          Me%Velocity%Vertical%Cartesian, Me%External_Var%KFloor_Z)
        endif

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ComputeCartesianVertVelocity")
        endif

        if (Me%CyclicBoundary%ON) then
            call CyclicBoundVertical (Vector = Velocity_W_Cartesian)
        endif

        !nulify auxiliar variables
        nullify(Velocity_W_Cartesian, WaterPoints3D, WaterLevel_New, WaterLevel_Old)

    end subroutine ComputeCartesianVertVelocity

    !--------------------------------------------------------------------------

    subroutine CartesianVertVelocity_X(ComputeFaces3D_W, ComputeFaces3D_U, BoundaryPoints, SZZ, DZX, DWZ, uavar,&
        Velocity_W_Cartesian, KFloor_Z)
        !Arguments-------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent (INOUT) :: Velocity_W_Cartesian
        real,    dimension(:,:,:), pointer, intent (IN)    :: uavar
        integer, dimension(:,:,:), pointer, intent (IN)    :: ComputeFaces3D_U, ComputeFaces3D_W
        integer, dimension(:,:  ), pointer, intent (IN)    :: BoundaryPoints, KFloor_Z
        real,    dimension(:,:  ), pointer, intent (IN)    :: DZX
        real,    dimension(:,:,:), pointer, intent (IN)    :: DWZ, SZZ
        !Local-----------------------------------------------------------------
        real                                               :: velusup, veluinf, velu, szzxp1, dzxp1, szzxm1, dzxm1, &
                                                              dszdx

        integer                                            :: IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        integer                                            :: CHUNK, kbottom
        !Begin-----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i, j, k,szzxp1,dzxp1,szzxm1,dzxm1,dszdx,velusup,veluinf,velu,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if (ComputeFaces3D_W(i, j, KUB) == 1) then

                if (BoundaryPoints(i, j) /= 1) then

                    kbottom = KFloor_Z(i, j)

                    do k = kbottom + 1, KUB

                        ! mesh slope in X direction: central, progressive or regressive differences are used as a function of the
                        ! land boundary. The boundary is automatically detected in the equation through "ComputeFaces3D_W" matrix
                        szzxp1 = ComputeFaces3D_W(i,j+1,k)*szz(i,j+1,k-1)+(1-ComputeFaces3D_W(i,j+1,k))*szz(i,j,k-1)
                        dzxp1  = ComputeFaces3D_W(i,j+1,k)*dzx(i,j)
                        szzxm1 = ComputeFaces3D_W(i,j-1,k)*szz(i,j-1,k-1)+(1-ComputeFaces3D_W(i,j-1,k))*szz(i,j,k-1)
                        dzxm1  = ComputeFaces3D_W(i,j-1,k)*dzx(i,j-1)

                        if ((dzxp1+dzxm1) /= 0) then
                            dszdx=(szzxp1-szzxm1) / (dzxp1+dzxm1)
                        else
                            dszdx=0.0
                        endif
                        ! Velocity components at cell center
                        if ((ComputeFaces3D_U(i,j,k)+ComputeFaces3D_U(i,j+1,k)) /= 0) then
                            velusup=(ComputeFaces3D_U(i,j,k)*uavar(i,j,k)+ComputeFaces3D_U(i,j+1,k)*uavar(i,j+1,k))/ &
                                    (ComputeFaces3D_U(i,j,k)             +ComputeFaces3D_U(i,j+1,k))
                        else
                            velusup=0.0
                        endif

                        if ((ComputeFaces3D_U(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)) /=0) then
                            veluinf=(ComputeFaces3D_U(i,j,k-1)*uavar(i,j,k-1)+ComputeFaces3D_U(i,j+1,k-1)*uavar(i,j+1,k-1))/ &
                                    (ComputeFaces3D_U(i,j,k-1)               +ComputeFaces3D_U(i,j+1,k-1))
                        else
                            veluinf=0.0
                        endif

                        velu=(velusup*dwz(i,j,k-1)+veluinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))

                        Velocity_W_Cartesian(i,j,k) = Velocity_W_Cartesian(i,j,k) - velu * dszdx
                        
                    enddo
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL
    end subroutine CartesianVertVelocity_X

    !-------------------------------------------------------------------------
    subroutine CartesianVertVelocity_Y(ComputeFaces3D_W, ComputeFaces3D_V, BoundaryPoints, SZZ, DZY, DWZ, vavar, &
        Velocity_W_Cartesian, KFloor_Z)
        !Arguments-------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent (INOUT) :: Velocity_W_Cartesian
        real,    dimension(:,:,:), pointer, intent (IN)    :: vavar
        integer, dimension(:,:,:), pointer, intent (IN)    :: ComputeFaces3D_V, ComputeFaces3D_W
        integer, dimension(:,:  ), pointer, intent (IN)    :: BoundaryPoints, KFloor_Z
        real,    dimension(:,:  ), pointer, intent (IN)    :: DZY
        real,    dimension(:,:,:), pointer, intent (IN)    :: DWZ, SZZ
        !Local-----------------------------------------------------------------
        real                                               :: velvsup, velvinf, velv, szzyp1, dzyp1, szzym1, dzym1, &
                                                              dszdy

        integer                                            :: IUB, ILB, JUB, JLB, KUB, KLB, i, j, k
        integer                                            :: CHUNK, kbottom
        !Begin-----------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i, j, k,szzyp1,dzyp1,szzym1,dzym1,dszdy,velvsup,velvinf,velv,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if (ComputeFaces3D_W(i, j, KUB) == 1) then

                if (BoundaryPoints(i, j) /= 1) then

                    kbottom = KFloor_Z(i, j)

                    do k = kbottom + 1, KUB
                        ! mesh slope in Y direction: central, progressive or regressive differences are used as a function of the
                        ! land boundary. The boundary is automatically detected in the equation through "ComputeFaces3D_W" matrix
                        szzyp1 = ComputeFaces3D_W(i+1,j,k)*szz(i+1,j,k-1)+(1-ComputeFaces3D_W(i+1,j,k))*szz(i,j,k-1)
                        dzyp1  = ComputeFaces3D_W(i+1,j,k)*dzy(i,j)
                        szzym1 = ComputeFaces3D_W(i-1,j,k)*szz(i-1,j,k-1)+(1-ComputeFaces3D_W(i-1,j,k))*szz(i,j,k-1)
                        dzym1  = ComputeFaces3D_W(i-1,j,k)*dzy(i-1,j)

                        if ((dzyp1+dzym1) /= 0) then
                            dszdy=(szzyp1-szzym1) / (dzyp1+dzym1)
                        else
                            dszdy=0.0
                        endif
                        ! Velocity components at cell center
                        if ((ComputeFaces3D_V(i,j,k)+ComputeFaces3D_V(i+1,j,k)) /= 0) then
                            velvsup=(ComputeFaces3D_V(i,j,k)*vavar(i,j,k)+ComputeFaces3D_V(i+1,j,k)*vavar(i+1,j,k))/ &
                                    (ComputeFaces3D_V(i,j,k)             +ComputeFaces3D_V(i+1,j,k))
                        else
                            velvsup=0.0
                        endif

                        if ((ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)) /=0) then
                            velvinf=(ComputeFaces3D_V(i,j,k-1)*vavar(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1)*vavar(i+1,j,k-1))/ &
                                    (ComputeFaces3D_V(i,j,k-1)+ComputeFaces3D_V(i+1,j,k-1))
                        else
                            velvinf=0.0
                        endif

                        velv=(velvsup*dwz(i,j,k-1)+velvinf*dwz(i,j,k))/(dwz(i,j,k-1)+dwz(i,j,k))

                        Velocity_W_Cartesian(i,j,k) = Velocity_W_Cartesian(i,j,k) - velv * dszdy
                    enddo
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine CartesianVertVelocity_Y

    !-------------------------------------------------------------------------

    subroutine CartesianVertVelocity_dszdt(volum_z, volz_old, dux, dvy, dt, Velocity_W_Cartesian, &
        ComputeFaces3D_W, KFloor_Z)
        !Arguments-------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent (INOUT) :: Velocity_W_Cartesian
        real(8), dimension(:,:,:), pointer, intent (IN)    :: Volz_old, Volum_z
        integer, dimension(:,:,:), pointer, intent (IN)    :: ComputeFaces3D_W
        real,    dimension(:,:  ), pointer, intent (IN)    :: dux, dvy
        real,                               intent (IN)    :: dt
        integer, dimension(:,:  ), pointer, intent (IN)    :: KFloor_Z
        !Local-----------------------------------------------------------------
        real                                               :: dszdt, Dux_x_Dvy_x_Dt
        integer                                            :: IUB,ILB,JUB,JLB,KUB,KLB, i, j, k, kbottom
        integer                                            :: CHUNK
        !Begin-----------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i, j, k, dszdt, kbottom, Dux_x_Dvy_x_Dt)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            dszdt=0.0
            if (ComputeFaces3D_W(i,j,KUB) == 1) then

                kbottom = KFloor_Z(i, j)
                
                Dux_x_Dvy_x_Dt = dux(i,j) * dvy(i,j) * dt
                
                do k = kbottom + 1, KUB
                    
                    dszdt  = dszdt - (volum_z(i,j,k-1) - volz_old(i,j,k-1)) / Dux_x_Dvy_x_Dt

                    Velocity_W_Cartesian(i,j,k) = Velocity_W_Cartesian(i,j,k) - dszdt
                enddo
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine CartesianVertVelocity_dszdt

    !-------------------------------------------------------------------------

    subroutine ComputeBaroclinicVertVelocity( Grid)

        !Arguments------------------------------------------------------------

        integer                            :: Grid

        !Local---------------------------------------------------------------------
        real   , dimension(:,:,:), pointer :: Vel_Z_Cartesian, Vel_Z_Baroclinic, SZZ,    &
                                              Vel_Z_BaroclinicOld
        real   , dimension(:,:  ), pointer :: WaterLevel_New, WaterLevel_Old
        integer, dimension(:,:  ), pointer :: KFloor_Z

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_W

        real                               :: DT_Elevation, Vel_Z_Barotropic
        integer                            :: I, J, K, IUB, ILB, JUB, JLB, KUB, kbottom

        integer                            :: CHUNK

        !Begin--------------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB

        DT_Elevation         =  Me%WaterLevel%DT

        Vel_Z_Cartesian      => Me%Velocity%Vertical%Cartesian
        Vel_Z_Baroclinic     => Me%VelBaroclinic%W_New
        Vel_Z_BaroclinicOld  => Me%VelBaroclinic%W_Old

        WaterLevel_New       => Me%WaterLevel%New
        WaterLevel_Old       => Me%WaterLevel%Old

        SZZ                  => Me%External_Var%SZZ
        KFloor_Z             => Me%External_Var%KFloor_Z

        ComputeFaces3D_W     => Me%External_Var%ComputeFaces3D_W

        !End - Shorten variables name

        if (Grid == Fix) then

            Vel_Z_BaroclinicOld(:, :, :)  = Vel_Z_Baroclinic(:, :, :)

        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ComputeBaroclinicVertVelocity")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,Vel_Z_Barotropic)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do j=JLB, JUB
doi:    do i=ILB, IUB

cd1:        if (ComputeFaces3D_W(i, j, KUB) == Covered) then

                kbottom = KFloor_Z(i, j)

dok:            do k = kbottom + 1, KUB

                    !Compute the vertical velocity induced by the
                    !water level variation.
                    !To this vertical velocity is called
                    !vertical barotropic velocity
                    Vel_Z_Barotropic =  (WaterLevel_New(i, j) - WaterLevel_Old(i, j)) /  &
                                         DT_Elevation                                 *  &
                                        (SZZ(i, j, kbottom - 1) - SZZ(i, j, k - 1))   /  &
                                        (SZZ(i, j, kbottom - 1) - SZZ(i, j, KUB))


                    !Compute in all the vertical faces the baroclinic velocity
                    Vel_Z_Baroclinic(i, j, k)  = Vel_Z_Cartesian(i, j, k) - Vel_Z_Barotropic

                enddo dok

            endif cd1

        enddo doi
        enddo doj
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ComputeBaroclinicVertVelocity")
        endif

        !Nullify auxiliar pointers
        nullify(KFloor_Z, SZZ      )
        nullify(Vel_Z_Cartesian    )
        nullify(Vel_Z_Baroclinic   )
        nullify(Vel_Z_BaroclinicOld)

        nullify(ComputeFaces3D_W   )
        nullify(WaterLevel_New     )
        nullify(WaterLevel_Old     )


    end Subroutine ComputeBaroclinicVertVelocity

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 31/08/2011 - 01/08/2012

    Subroutine Compute_BottomStokesVertVel


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        integer,                 pointer   :: IUB, ILB, JUB, JLB, KUB, KLB
        integer,                 pointer   :: WorkIUB, WorkILB, WorkJUB, WorkJLB, WorkKUB, WorkKLB
        integer,                 pointer   :: NbFreq
        integer                            :: i, j, i_freq
        real, dimension (:    ), pointer   :: FACT
        real, dimension (:,:,:), pointer   :: WAVN
        real, dimension (:,:  ), pointer   :: Bathymetry, WaterColumn, DUX, DVY, BottomStokesVertVel, Ubot, Vbot
        integer                            :: STAT_CALL, kbottom

        real                               :: BathyS, BathyN, BathyE, BathyW

        !Begin---------------------------------------------------------------------

        ! Shorten variables
        IUB         => Me%Size%IUB
        ILB         => Me%Size%ILB
        JUB         => Me%Size%JUB
        JLB         => Me%Size%JLB
        KUB         => Me%Size%KUB
        KLB         => Me%Size%KLB

        WorkIUB     => Me%WorkSize%IUB
        WorkILB     => Me%WorkSize%ILB
        WorkJUB     => Me%WorkSize%JUB
        WorkJLB     => Me%WorkSize%JLB
        WorkKUB     => Me%WorkSize%KUB
        WorkKLB     => Me%WorkSize%KLB

        DUX         => Me%External_Var%DUX
        DVY         => Me%External_Var%DVY

        NbFreq      => Me%External_Var%StokesFreqNum
        WAVN        => Me%External_Var%StokesWaveNumber
        WaterColumn => Me%External_Var%WaterColumn

        BottomStokesVertVel => Me%StokesVel%BottomStokesVertVel

        !Gets a pointer to Bathymetry
        call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Compute_BottomStokesVertVel - ModuleHydrodynamic - ERR10'

        ! Allocate variables
        allocate( Ubot ( ILB:IUB, JLB:JUB ) )
        allocate( Vbot ( ILB:IUB, JLB:JUB ) )
        allocate( FACT ( 1:NbFreq         ) )


        do i=WorkILB,WorkIUB
        do j=WorkJLB,WorkJUB

        kbottom = WorkKLB

        if (Me%External_Var%OpenPoints3D(i,j,kbottom) == 1) then

        ! Computation of FACT = depth-dependent part of the Stokes drift
            do i_freq=1,NbFreq

                if (WAVN(i,j,i_freq) * WaterColumn(i,j) > 6.) then

                    FACT(i_freq) = EXP( 2. * WAVN(i,j,i_freq) * ( - WaterColumn(i,j) ) )

                else

                    FACT(i_freq) = 1 / cosh( 2. * WAVN(i,j,i_freq) * WaterColumn(i,j) )
                endif

            enddo

           ! Bottom horizontal Stokes drift
           Ubot(i,j) = SUM( Me%External_Var%StokesDriftSpectrumX(i,j,:) * FACT(:) )
           Vbot(i,j) = SUM( Me%External_Var%StokesDriftSpectrumY(i,j,:) * FACT(:) )

        endif

        enddo
        enddo

        do i=WorkILB,WorkIUB
        do j=WorkJLB,WorkJUB

            if (Me%External_Var%OpenPoints3D(i,j,kbottom) == 1) then

                ! Bathymetry interpolation at U,V-points (in order to get gradients centered at w-points)
                BathyE = Face_Interpolation(Bathymetry(i,j), Bathymetry(i,j+1), DUX(i,j), DUX(i,j+1))
                BathyW = Face_Interpolation(Bathymetry(i,j-1), Bathymetry(i,j), DUX(i,j-1), DUX(i,j))
                BathyN = Face_Interpolation(Bathymetry(i,j), Bathymetry(i+1,j), DVY(i,j), DVY(i+1,j))
                BathyS = Face_Interpolation(Bathymetry(i-1,j), Bathymetry(i,j), DVY(i-1,j), DVY(i,j))

                BottomStokesVertVel(i,j) = - Ubot(i,j) * (BathyE - BathyW) / DUX(i,j) &
                                           - Vbot(i,j) * (BathyN - BathyS) / DVY(i,j)

            endif

        enddo
        enddo



        call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Compute_BottomStokesVertVel - ModuleHydrodynamic - ERR20'

        nullify(IUB)
        nullify(ILB)
        nullify(JUB)
        nullify(JLB)
        nullify(KUB)
        nullify(KLB)

        nullify(WorkIUB)
        nullify(WorkILB)
        nullify(WorkJUB)
        nullify(WorkJLB)
        nullify(WorkKUB)
        nullify(WorkKLB)

        nullify(NbFreq)
        nullify(WAVN)

        nullify(BottomStokesVertVel)

        deallocate(Ubot)
        deallocate(Vbot)
        deallocate(FACT)

    End Subroutine Compute_BottomStokesVertVel

    !End-----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Modified by Matthias DELPEY - 24/08/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 29/08/2011

    subroutine Compute_StokesCartVertVel

        !Variables Categories
            !Flow           :
            !HorizontalGrid :
        !Local---------------------------------------------------------------------

        real,    dimension(:,:,:),   pointer :: StokesVelW_cart, StokesVelU, StokesVelV, DWZ

        real,    dimension(:,:),     pointer :: DUX, DVY, BottomStokesVelW

        real                                 :: VELZ

        integer                              :: i, j, k, kbottom

        integer, dimension(:,:,:),   pointer :: OpenPoints3D

        !Begin--------------------------------------------------------------------------

        ! Shorten variables

        DUX                 => Me%External_Var%DUX
        DVY                 => Me%External_Var%DVY
        DWZ                 => Me%External_Var%DWZ

        OpenPoints3D        => Me%External_Var%OpenPoints3D

        StokesVelU          => Me%StokesVel%Horizontal%U%New
        StokesVelV          => Me%StokesVel%Horizontal%V%New
        BottomStokesVelW    => Me%StokesVel%BottomStokesVertVel
        StokesVelW_cart     => Me%StokesVel%Vertical%Cartesian

        ! End shorten variables


        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

           ! Bottom Stokes drift vertical velocity (computed by Compute_BottomStokesVertVel)
           kbottom = Me%WorkSize%KLB - 1

           VELZ = BottomStokesVelW(i,j)
           ! VELZ = 0.

           StokesVelW_cart(i,j,kbottom) = VELZ

           do k = Me%WorkSize%KLB, Me%WorkSize%KUB

                VELZ = VELZ                                                                 &
                      - DWZ(i,j,k-1) * (StokesVelU(i,j+1,k) - StokesVelU(i,j,k)) / DUX(i,j)  &
                      - DWZ(i,j,k-1) * (StokesVelV(i+1,j,k) - StokesVelV(i,j,k)) / DVY(i,j)

                StokesVelW_cart(i,j,k) = VELZ

           enddo

        enddo
        enddo


        nullify(StokesVelW_cart, StokesVelU, StokesVelV)
        nullify(DUX, DVY, BottomStokesVelW)
        nullify(OpenPoints3D)

    end subroutine Compute_StokesCartVertVel

        ! End -----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Compute the vertical water flow                                                      !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine Compute_VerticalVelocity

        !Variables Categories
            !Flow      : WaterFlux_Z, Velocity_Z
            !HorizontalGrid : DUX, DVY
        !Local---------------------------------------------------------------------
        integer                            :: I, J, K
        real                               :: aux

        integer                            :: CHUNK
        !Begin--------------------------------------------------------------------------

        CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Compute_VerticalVelocity")
        endif
        
        !$OMP PARALLEL PRIVATE(i,j,k, aux)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB+1
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if (Me%External_Var%WaterPoints3D(i, j, k - 1) == 1) then

                aux = Me%External_Var%DUX(i, j) * Me%External_Var%DVY(i, j)
                
                Me%Velocity%Vertical%Across(i, j, k)  = Me%WaterFluxes%Z(i, j, k) / aux

            endif
        enddo
        enddo
        !$OMP END DO
        enddo
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Compute_VerticalVelocity")
        endif

    end subroutine Compute_VerticalVelocity

    !--------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the effect of all the explicit forces ( Baroclinic and      !
    !  barotropic water pressure, Coriolis, Atmospheric pressure,                          !
    !  Horizontal transport - covection + diffusion)                                       !
    !  in the velocity evolution                                                           !
    !                                                                                      !
    ! Input : Flow, Geometry, Mapping, Forces                                              !
    ! OutPut: TiCoef_3D                                                                    !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_ExplicitForces2(PressureBackwardInTime)

        !Variables Categories
            !Geometry  : WaterLevel_New, DUX_VY, DZX_ZY
            !WaterProp : Density
            !Forces    : Inertial_Aceleration, Horizontal_Transport, ROX3, AtmPressure
            !Time      : DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_3D

         !Variables Direction Dependent
            !DUX_VY, DZX_ZY, ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments------------------------------------------------------------
        logical                            :: PressureBackwardInTime


        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, Horizontal_Transport,           &
                                              ECoef_3D

        real,    dimension(:,:,:), pointer :: Density, Inertial_Aceleration,             &
                                              Rox3XY, DCoef_3D, FCoef_3D, TiCoef_3D,     &
                                              Relax_Aceleration, PressureCorrect,        &
                                              Altim_Relax_Aceleration

        real,    dimension(:,:),   pointer :: DZX_ZY, DUX_VY,                            &
                                              WaterLevel_New, WaterLevel_Old,            &
                                              AtmPressure, TidePotentialLevel

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: DT_Velocity, Alpha

        real                               :: FaceDensity, WaterPressure_Aceleration,          &
                                              AtmosphericPressure_Aceleration,                 &
                                              Barotropic_Aceleration, Baroclinic_Aceleration,  &
                                              Transport_Aceleration, TidePotentialAceleration

        integer                            :: I, J, K, kbottom, di, dj, iSouth, jWest
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real                               :: TimeCoef, DT_RunPeriod
        real                               :: TimeCoef2
        real,    dimension(:,:  ), pointer :: Coriolis_Freq

        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity = Me%Velocity%DT

        DCoef_3D                => Me%Coef%D3%D
        ECoef_3D                => Me%Coef%D3%E
        FCoef_3D                => Me%Coef%D3%F
        TiCoef_3D               => Me%Coef%D3%Ti

        Rox3XY                  => Me%Forces%Rox3XY
        Horizontal_Transport    => Me%Forces%Horizontal_Transport
        Inertial_Aceleration    => Me%Forces%Inertial_Aceleration
        TidePotentialLevel      => Me%Forces%TidePotentialLevel
        Relax_Aceleration       => Me%Forces%Relax_Aceleration
        Altim_Relax_Aceleration => Me%Forces%Altim_Relax_Aceleration

        WaterLevel_New          => Me%WaterLevel%New
        WaterLevel_Old          => Me%WaterLevel%Old

        PressureCorrect         => Me%NonHydrostatic%PressureCorrect

        Density                 => Me%External_Var%Density
        AtmPressure             => Me%External_Var%AtmosphericPressure

        Volume_UV               => Me%External_Var%Volume_UV

        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV

        BoundaryFacesUV         => Me%External_Var%BoundaryFacesUV

        DZX_ZY                  => Me%External_Var%DZX_ZY
        DUX_VY                  => Me%External_Var%DUX_VY


        !End - Shorten variables name

        if (Me%ComputeOptions%Turbine) then
            call GetTurbineAcceleration(Me%ObjTurbine, Me%Forces%Turbine_Acceleration)
            !Falta gestao de STAT
        endif

        if (Me%TidePotential%Compute) then

            Alpha = Me%TidePotential%Alpha

        else

            Alpha = 1.

        endif

        if (Me%ComputeOptions%AtmosphereRAMP) then

            TimeCoef = Me%ComputeOptions%AtmosphereCoef

        elseif (Me%ComputeOptions%BaroclinicRamp) then

            DT_RunPeriod = Me%CurrentTime - Me%ComputeOptions%RAMP_BeginTime

            Coriolis_Freq => Me%External_Var%Coriolis_Freq

        endif

        !$ CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_ExplicitForces")
        endif

        !griflet: removed critical. Added TimeCoef to private variables.
        !$OMP PARALLEL PRIVATE( i,j,k,iSouth,jWest,kbottom,FaceDensity, &
        !$OMP                   WaterPressure_Aceleration,TidePotentialAceleration, &
        !$OMP                   AtmosphericPressure_Aceleration,Barotropic_Aceleration, &
        !$OMP                   Baroclinic_Aceleration,Transport_Aceleration,TimeCoef2)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:     do j = JLB, JUB
doi:     do i = ILB, IUB

Cov1:       if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth     = i - di
                jWest      = j - dj

                kbottom = KFloor_UV(i, j)

                !griflet: this was the important step to make the
                !code thread safe. The FIRSTPRIVATE clause could have been used
                !but I'm more reliant on good old fortran logic, rather than
                !openmp logic ;)
                if (Me%ComputeOptions%atmosphereRAMP) TimeCoef2 = TimeCoef

dok:            do  k = kbottom, KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        !!! $OMP CRITICAL (VEF1_FNC01)
                        FaceDensity    = Face_Interpolation(Density(i, j, k),            &
                                                            Density(iSouth, jWest, k), &
                                                            DUX_VY(i, j),                &
                                                            DUX_VY(iSouth, jWest))
                        !!! $OMP END CRITICAL (VEF1_FNC01)
                    else

                        FaceDensity    = SigmaDensityReference

                    endif


                    !Aceleration due the coriolis and centrifugal force

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Inertial_Aceleration(i, j, k)


                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    if (Me%Relaxation%Force)   then
                        !!!! $OMP CRITICAL (VEF1_FNC023)
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *          &
                                                                  Relax_aceleration(i, j, k)
                        !!!! $OMP END CRITICAL (VEF1_FNC023)
                    endif

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    if (Me%ComputeOptions%Obstacle)                                     &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *         &
                                                                  Me%Forces%ObstacleDrag_Aceleration(i, j, k)


                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    if (Me%ComputeOptions%Turbine)                                      &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity*          &
                                                                  Me%Forces%Turbine_Acceleration(i, j, k)

                    if (Me%ComputeOptions%Scraper)                                      &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *         &
                                                                  Me%Forces%Scraper_Aceleration(i, j, k)

                    if (Me%ThinWalls%ON .and. Me%ThinWalls%CloseFlag == 0)              &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *         &
                                                                  Me%Forces%ThinWalls_Dissipation(i,j,k)


                    !Aceleration due to barotropic water Pressure

                    ![m/s^2]                   = [m/s^2] * [m] / [m]
                    WaterPressure_Aceleration  = Gravity * (WaterLevel_New(iSouth, jWest) - &
                                                 WaterLevel_New(i, j)) /                    &
                                                 DZX_ZY(iSouth, jWest)

                    !Deformation "crosta terrestre" - Tide Potential
                    WaterPressure_Aceleration  = Alpha * WaterPressure_Aceleration


                    if (Me%NonHydrostatic%ON .and. Me%NonHydroStatic%PressureCorrection .and. PressureBackwardInTime) then

                        ![m/s^2]           = [m/s^2]  +     [m^2/s^2] / [m]
                        WaterPressure_Aceleration = WaterPressure_Aceleration +            &
                                             (PressureCorrect(iSouth, jWest, k) -          &
                                              PressureCorrect(i     , j    , k))/          &
                                              DZX_ZY(iSouth, jWest)
                    endif


                    !Aceleration due the tide potential
                    ![m/s^2]                   = [m/s^2] * [m] / [m]
                    TidePotentialAceleration   = - Gravity * (TidePotentialLevel(iSouth, jWest) - &
                                                 TidePotentialLevel(i, j)) /                      &
                                                 DZX_ZY(iSouth, jWest)


                    if (Me%ComputeOptions%AtmPressure) then
                    !Aceleration due to Atmospheric Pressure
                        ![m/s^2]                        = [M*m/s^2/m^2] / [M/m^3] / [m]
                        AtmosphericPressure_Aceleration = (AtmPressure(iSouth, jWest) - AtmPressure(i, j)) / &
                                                           FaceDensity / DZX_ZY(iSouth, jWest)

                        if (Me%ComputeOptions%atmosphereRAMP) then

                            if (TimeCoef2 < 1) then

                                AtmosphericPressure_Aceleration = TimeCoef2 * AtmosphericPressure_Aceleration

                            endif

                        endif

                    else

                        AtmosphericPressure_Aceleration = 0.

                    endif


                    !Aceleration due to Barotropic Pressure

                    Barotropic_Aceleration = WaterPressure_Aceleration + AtmosphericPressure_Aceleration + &
                                             TidePotentialAceleration

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Barotropic_Aceleration

                    !Aceleration due to Baroclinic Pressure

                    ![m/s^2]               = [m/s^2] * [M/m^3] / [M/m^3]
                    Baroclinic_Aceleration = Gravity * Rox3XY(i, j, k) / FaceDensity

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Baroclinic_Aceleration



                    !Aceleration due to Horizontal transport = advection + diffusion
                    ![m/s^2]              = [m^4/s^2] / [m^3]
                    Transport_Aceleration = Horizontal_Transport (i, j, k) / Volume_UV(i, j, k)


                    !Aceleration due to Horizontal transport = advection + diffusion

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Transport_Aceleration

                    ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                    if (Me%ComputeOptions%AltimetryAssimilation%flag .and.                          &
                        Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute)    &
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity *                     &
                                             Altim_Relax_Aceleration(i, j, k)


                enddo dok

            endif Cov1

        enddo doi
        enddo doj

        !griflet: added NOWAIT
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_ExplicitForces")
        endif

        if (Me%ComputeOptions%Turbine) then
            call UnGetTurbineAcceleration(Me%ObjTurbine, Me%Forces%Turbine_Acceleration)
        endif

        !Nullify auxiliar pointers
        nullify(DCoef_3D)
        nullify(ECoef_3D)
        nullify(FCoef_3D)
        nullify(TiCoef_3D)

        nullify(Rox3XY)
        nullify(Horizontal_Transport)
        nullify(Inertial_Aceleration)
        nullify(TidePotentialLevel)
        nullify(Relax_Aceleration)
        nullify(Altim_Relax_Aceleration)

        nullify(WaterLevel_New, WaterLevel_Old)

        nullify(Density)
        nullify(AtmPressure)

        nullify(Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(DZX_ZY)
        nullify(DUX_VY)
        nullify(Coriolis_Freq)


    end Subroutine Velocity_ExplicitForces2

    Subroutine Velocity_ExplicitForces(PressureBackwardInTime)
        !Variables Categories
            !Geometry  : WaterLevel_New, DUX_VY, DZX_ZY
            !Forces    : Inertial_Aceleration, Horizontal_Transport, ROX3, AtmPressure
            !Time      : DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_3D

         !Variables Direction Dependent
            !DUX_VY, DZX_ZY, ComputeFaces3D_UV, KFloor_UV, Direction
        !Arguments------------------------------------------------------------
        logical                            :: PressureBackwardInTime

        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: Rox3XY, TiCoef_3D

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity
        real                               :: Baroclinic_Aceleration

        integer                            :: I, J, K, kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------
        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity = Me%Velocity%DT

        TiCoef_3D               => Me%Coef%D3%Ti
        Rox3XY                  => Me%Forces%Rox3XY
        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV
        !End - Shorten variables name

        if (Me%ComputeOptions%Turbine) then
            call GetTurbineAcceleration(Me%ObjTurbine, Me%Forces%Turbine_Acceleration)
            !Falta gestao de STAT
        endif

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_ExplicitForces")
        endif
        
!---------------------------------------------------------------------------------------------------------------
        ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
        !Aceleration due the coriolis and centrifugal force
        call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%Inertial_Aceleration, DT_Velocity, Me%WorkSize,  &
                                    ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
        
!-----------------------------------------------------------------------------------------------------------------
        if (Me%Relaxation%Force) then
            ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
            call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%Relax_Aceleration, DT_Velocity, Me%WorkSize,  &
                                       ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
        endif
!-----------------------------------------------------------------------------------------------------------------
        if (Me%ComputeOptions%Obstacle) then
            ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
            call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%ObstacleDrag_Aceleration, DT_Velocity, Me%WorkSize, &
                                       ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
        endif
!-----------------------------------------------------------------------------------------------------------------
        if (Me%ComputeOptions%Turbine) then
            ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
            call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%Turbine_Acceleration, DT_Velocity, Me%WorkSize, &
                                       ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
        endif
!-----------------------------------------------------------------------------------------------------------------
        if (Me%ComputeOptions%Scraper) then
            ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
            call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%Scraper_Aceleration, DT_Velocity, Me%WorkSize, &
                                       ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
        endif
!------------------------------------------------------------------------------------------------------------------
        if (Me%ThinWalls%ON) then
            if (Me%ThinWalls%CloseFlag == 0) then
                ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
                call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%ThinWalls_Dissipation, DT_Velocity, Me%WorkSize, &
                                       ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
            endif
        endif

    !-------------------------------------------------------------------------------------------------------------------
        if (Me%ComputeOptions%AltimetryAssimilation%flag) then
            if (Me%CurrentTime .ge. Me%ComputeOptions%AltimetryAssimilation%NextCompute) then
                ![m/s]    = [m/s]     +     [s]     *     [m/s^2]
                call AddMAtrixtimesScalar (TiCoef_3D, Me%Forces%Altim_Relax_Aceleration, DT_Velocity, Me%WorkSize, &
                                       ComputeFaces3D_UV, Me%Docycle_method, Me%External_Var%KFloor_UV)
            endif
        endif

    !----------------------------barotropic force--------------------------------------------------------------------
        
        call AddBarotropicForce (PressureBackwardInTime)

    !--------------------------- Baroclinic force--------------------------------------------------------------------

        if (Me%ComputeOptions%Baroclinic) then
            !$OMP PARALLEL PRIVATE( i,j,k,kbottom, Baroclinic_Aceleration)
            if (Me%Docycle_method == 1) then
                !$ CHUNK = CHUNK_J(JLB, JUB)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, KUB) == Covered) then
                        kbottom = KFloor_UV(i, j)

                        do  k = kbottom, KUB
                            !Aceleration due to Baroclinic Pressure
                            ![m/s^2]               = [m/s^2] * [M/m^3] / [M/m^3]
                            Baroclinic_Aceleration = Gravity * Rox3XY(i, j, k) / Me%FaceDensity(i, j, k)
                            ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Baroclinic_Aceleration
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO
            else
                !$ CHUNK = CHUNK_K(KLB, KUB)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == Covered) then
                        !Aceleration due to Baroclinic Pressure
                        ![m/s^2]               = [m/s^2] * [M/m^3] / [M/m^3]
                        Baroclinic_Aceleration = Gravity * Rox3XY(i, j, k) / Me%FaceDensity(i, j, k)
                        ![m/s]           = [m/s]            +     [s]     *     [m/s^2]
                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * Baroclinic_Aceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO
            endif
            !$OMP END PARALLEL
        endif

!--------------------------------------------------------------------------------------------------------------------
        !Aceleration due to Horizontal transport = advection + diffusion
        ![m/s]    = [m/s]     +     [s]     *     [m^4/s^2]        / [m^3]

        call AddMatrixtimesScalarDivByMatrix (TiCoef_3D, Me%Forces%Horizontal_Transport, Me%External_Var%Volume_UV, &
                                              DT_Velocity, Me%WorkSize, ComputeFaces3D_UV, Me%Docycle_method,       &
                                              Me%External_Var%KFloor_UV)
        
        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_ExplicitForces")
        endif

        if (Me%ComputeOptions%Turbine) then
            call UnGetTurbineAcceleration(Me%ObjTurbine, Me%Forces%Turbine_Acceleration)
        endif

        !Nullify auxiliar pointers
        nullify(TiCoef_3D)
        nullify(Rox3XY)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

    end Subroutine Velocity_ExplicitForces

    !------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Adds BarotropicForce to TiCoef_3D
    Subroutine AddBarotropicForce (PressureBackwardInTime)
        !Arguments------------------------------------------------------------
        logical                            :: PressureBackwardInTime
        !Begin---------------------------------------------------------------------

        if (Me%Direction%di == 1)then
            call AddWaterPressure_acceleration_S (PressureBackwardInTime)
        else
            call AddWaterPressure_acceleration_W (PressureBackwardInTime)
        endif

        if (Me%TidePotential%Compute) then
            call AddTidePotential
        endif

        if (Me%ComputeOptions%AtmPressure) then
            call AddAtmPressure
        endif

    end subroutine AddBarotropicForce

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Adds AddWaterPressure_acceleration to TiCoef_3D - direction North-South
    Subroutine AddWaterPressure_acceleration_S (PressureBackwardInTime)
        !Arguments------------------------------------------------------------
        logical                            :: PressureBackwardInTime

        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: TiCoef_3D, PressureCorrect
        real,    dimension(:,:),   pointer :: DZX_ZY, WaterLevel_New
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real                               :: WaterPressure_Aceleration, DT_Velocity, SurfaceGradient, WaterPressure_Velocity, Alpha
        integer                            :: I, J, K, kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity = Me%Velocity%DT
        TiCoef_3D               => Me%Coef%D3%Ti
        WaterLevel_New          => Me%WaterLevel%New
        PressureCorrect         => Me%NonHydrostatic%PressureCorrect
        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV
        DZX_ZY                  => Me%External_Var%DZX_ZY
        
        if (Me%TidePotential%Compute) then
            Alpha = Me%TidePotential%Alpha
        else
            Alpha = 1.0
        endif
        
        !$ CHUNK = CHUNK_J(JLB, JUB)

        if (Me%NonHydrostatic%ON .and. Me%NonHydroStatic%PressureCorrection .and. PressureBackwardInTime) then

            !$OMP PARALLEL PRIVATE( i,j,k,kbottom, WaterPressure_Aceleration)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
                kbottom = KFloor_UV(i, j)
                if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                    do  k = kbottom, KUB

                        !Aceleration due to barotropic water Pressure
                        ![m/s^2]                   = [m/s^2] * [m] / [m]
                        WaterPressure_Aceleration  = Gravity * (WaterLevel_New(i - 1, j) - &
                                                        WaterLevel_New(i, j)) / DZX_ZY(i - 1, j)

                        !Deformation "crosta terrestre" - Tide Potential
                        WaterPressure_Aceleration  = Alpha * WaterPressure_Aceleration

                        ![m/s^2]           = [m/s^2]  +     [m^2/s^2] / [m]
                        WaterPressure_Aceleration = WaterPressure_Aceleration +                               &
                                                (PressureCorrect(i - 1, j, k) - PressureCorrect(i , j , k)) / &
                                                DZX_ZY(i - 1, j)

                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * WaterPressure_Aceleration
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO NOWAIT
            !$OMP END PARALLEL
        else
            if (Me%Docycle_method == 1) then
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, WaterPressure_Aceleration, SurfaceGradient, WaterPressure_Velocity)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                        
                        SurfaceGradient = WaterLevel_New(i - 1, j) - WaterLevel_New(i, j)
                        !Aceleration due to barotropic water Pressure
                        ![m/s^2]                   = [m/s^2] * [m] / [m]
                        WaterPressure_Aceleration  = Gravity * SurfaceGradient / DZX_ZY(i - 1, j)

                        !Deformation "crosta terrestre" - Tide Potential
                        WaterPressure_Velocity  = Alpha * WaterPressure_Aceleration * DT_Velocity
                        
                        kbottom = KFloor_UV(i, j)
                        
                        do  k = kbottom, KUB
                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + WaterPressure_Velocity
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            else
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, WaterPressure_Aceleration, SurfaceGradient)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == 1) then
                        SurfaceGradient = WaterLevel_New(i - 1, j) - WaterLevel_New(i, j)
                        !Aceleration due to barotropic water Pressure
                        ![m/s^2]                   = [m/s^2] * [m] / [m]
                        WaterPressure_Aceleration  = Gravity * SurfaceGradient / DZX_ZY(i - 1, j)

                        !Deformation "crosta terrestre" - Tide Potential
                        WaterPressure_Aceleration  = Alpha * WaterPressure_Aceleration

                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * WaterPressure_Aceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif
        endif

        nullify(TiCoef_3D)
        nullify(WaterLevel_New)
        nullify(PressureCorrect)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(DZX_ZY)

    end subroutine AddWaterPressure_acceleration_S

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Adds AddWaterPressure_acceleration to TiCoef_3D - direction East-West
    Subroutine AddWaterPressure_acceleration_W (PressureBackwardInTime)
        !Arguments------------------------------------------------------------
        logical                            :: PressureBackwardInTime

        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: TiCoef_3D, PressureCorrect
        real,    dimension(:,:),   pointer :: DZX_ZY, WaterLevel_New
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real                               :: WaterPressure_Aceleration, DT_Velocity, SurfaceGradient, WaterPressure_Velocity, Alpha
        integer                            :: I, J, K, kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity = Me%Velocity%DT
        TiCoef_3D               => Me%Coef%D3%Ti
        WaterLevel_New          => Me%WaterLevel%New
        PressureCorrect         => Me%NonHydrostatic%PressureCorrect
        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV
        DZX_ZY                  => Me%External_Var%DZX_ZY

        if (Me%TidePotential%Compute) then
            Alpha = Me%TidePotential%Alpha
        else
            Alpha = 1.0
        endif        
        
        !$ CHUNK = CHUNK_J(JLB, JUB)
        if (Me%NonHydrostatic%ON .and. Me%NonHydroStatic%PressureCorrection .and. PressureBackwardInTime) then
            !$OMP PARALLEL PRIVATE( i,j,k,kbottom, WaterPressure_Aceleration, SurfaceGradient)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
                kbottom = KFloor_UV(i, j)
                if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                    do  k = kbottom, KUB

                        SurfaceGradient = WaterLevel_New(i, j - 1) - WaterLevel_New(i, j)
                        !Aceleration due to barotropic water Pressure
                        ![m/s^2]                   = [m/s^2] * [m] / [m]
                        WaterPressure_Aceleration  = Gravity * SurfaceGradient / DZX_ZY(i, j - 1)

                        !Deformation "crosta terrestre" - Tide Potential
                        WaterPressure_Aceleration  = Alpha * WaterPressure_Aceleration

                        ![m/s^2]           = [m/s^2]  +     [m^2/s^2] / [m]
                        WaterPressure_Aceleration = WaterPressure_Aceleration +                               &
                                                (PressureCorrect(i, j - 1, k) - PressureCorrect(i , j, k)) / &
                                                DZX_ZY(i, j - 1)

                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * WaterPressure_Aceleration
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO NOWAIT
            !$OMP END PARALLEL
        else
            if (Me%Docycle_method == 1) then
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, WaterPressure_Aceleration, SurfaceGradient, WaterPressure_Velocity)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                        
                        SurfaceGradient = WaterLevel_New(i, j - 1) - WaterLevel_New(i, j)

                        !Aceleration due to barotropic water Pressure
                        ![m/s^2]                   = [m/s^2] * [m] / [m]
                        WaterPressure_Aceleration  = Gravity * SurfaceGradient / DZX_ZY(i, j - 1)

                        !Deformation "crosta terrestre" - Tide Potential
                        ![m/s]                     =                                     [m/s^2]        *    s
                        WaterPressure_Velocity  = Alpha * WaterPressure_Aceleration * DT_Velocity
                        
                        kbottom = KFloor_UV(i, j)
                        
                        do  k = kbottom, KUB
                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + WaterPressure_Velocity
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            else
                !$OMP PARALLEL PRIVATE( i,j,k, WaterPressure_Aceleration, SurfaceGradient)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == 1) then

                            SurfaceGradient = WaterLevel_New(i, j - 1) - WaterLevel_New(i, j)

                            !Aceleration due to barotropic water Pressure
                            ![m/s^2]                   = [m/s^2] * [m] / [m]
                            WaterPressure_Aceleration  = Gravity * SurfaceGradient / DZX_ZY(i, j - 1)

                            !Deformation "crosta terrestre" - Tide Potential
                            WaterPressure_Aceleration  = Alpha * WaterPressure_Aceleration

                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * WaterPressure_Aceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif
        endif

        nullify(TiCoef_3D)
        nullify(WaterLevel_New)
        nullify(PressureCorrect)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(DZX_ZY)
    end subroutine AddWaterPressure_acceleration_W
    !--------------------------------------------------------------------------------------

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Adds TidePotential to TiCoef_3D
    Subroutine AddTidePotential
        !Arguments------------------------------------------------------------
        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: TiCoef_3D
        real,    dimension(:,:),   pointer :: DZX_ZY, TidePotentialLevel
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real                               :: DT_Velocity, TidePotentialAceleration, TPGradient
        integer                            :: I, J, K, kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity = Me%Velocity%DT
        TiCoef_3D               => Me%Coef%D3%Ti
        TidePotentialLevel      => Me%Forces%TidePotentialLevel
        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV
        DZX_ZY                  => Me%External_Var%DZX_ZY
        !End - Shorten variables name

        !$ CHUNK = CHUNK_J(JLB, JUB)
        if (Me%Direction%di == 1)then
            if (Me%Docycle_method == 1) then
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, TidePotentialAceleration, TPGradient)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    kbottom = KFloor_UV(i, j)
                    if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                        do  k = kbottom, KUB
                            TPGradient = TidePotentialLevel(i - 1, j) - TidePotentialLevel(i, j)
                            !Aceleration due the tide potential
                            ![m/s^2]                   = [m/s^2] * [m] / [m]
                            TidePotentialAceleration   = - Gravity * TPGradient / DZX_ZY(i - 1, j)

                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * TidePotentialAceleration
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            else
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, TidePotentialAceleration, TPGradient)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == 1) then
                            TPGradient = TidePotentialLevel(i - 1, j) - TidePotentialLevel(i, j)
                            !Aceleration due the tide potential
                            ![m/s^2]                   = [m/s^2] * [m] / [m]
                            TidePotentialAceleration   = - Gravity * TPGradient / DZX_ZY(i - 1, j)

                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * TidePotentialAceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif

        else
            if (Me%Docycle_method == 1) then
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, TidePotentialAceleration, TPGradient)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    kbottom = KFloor_UV(i, j)
                    if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                        do  k = kbottom, KUB
                            TPGradient = TidePotentialLevel(i, j - 1) - TidePotentialLevel(i, j)
                            !Aceleration due the tide potential
                            ![m/s^2]                   = [m/s^2] * [m] / [m]
                            TidePotentialAceleration   = - Gravity * TPGradient / DZX_ZY(i, j - 1)

                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * TidePotentialAceleration
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            else
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, TidePotentialAceleration, TPGradient)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == 1) then

                        TPGradient = TidePotentialLevel(i, j - 1) - TidePotentialLevel(i, j)
                        !Aceleration due the tide potential
                        ![m/s^2]                   = [m/s^2] * [m] / [m]
                        TidePotentialAceleration   = - Gravity * TPGradient / DZX_ZY(i, j - 1)

                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * TidePotentialAceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif
        endif

        nullify(TiCoef_3D)
        nullify(TidePotentialLevel)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(DZX_ZY)
    end subroutine AddTidePotential
    !-----------------------------------------------------------------------------------------

    !------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Adds AddAtmPressure to TiCoef_3D
    Subroutine AddAtmPressure
        !Arguments------------------------------------------------------------
        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: TiCoef_3D
        real,    dimension(:,:),   pointer :: DZX_ZY, AtmPressure
        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV
        real                               :: DT_Velocity, AtmosphericPressure_Aceleration, AtmGradient, Aux
        integer                            :: I, J, K, kbottom
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        !$ integer                            :: CHUNK
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity = Me%Velocity%DT
        TiCoef_3D               => Me%Coef%D3%Ti
        AtmPressure             => Me%External_Var%AtmosphericPressure
        ComputeFaces3D_UV       => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV               => Me%External_Var%KFloor_UV
        DZX_ZY                  => Me%External_Var%DZX_ZY

        !End - Shorten variables name

        !$ CHUNK = CHUNK_J(JLB, JUB)
        if (Me%Direction%di == 1)then
            if (Me%Docycle_method == 1) then
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, AtmosphericPressure_Aceleration, AtmGradient, Aux)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    kbottom = KFloor_UV(i, j)
                    if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                        do  k = kbottom, KUB
                            AtmGradient = AtmPressure(i - 1, j) - AtmPressure(i, j)
                            Aux         = Me%FaceDensity(i, j, k) * DZX_ZY(i - 1, j)
                        !Aceleration due to Atmospheric Pressure
                            ![m/s^2]                        = [M*m/s^2/m^2] / ([M/m^3] * [m])
                            AtmosphericPressure_Aceleration = AtmGradient / Aux

                            AtmosphericPressure_Aceleration = Me%ComputeOptions%AtmosphereCoef * &
                                                                AtmosphericPressure_Aceleration

                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * AtmosphericPressure_Aceleration
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            else
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, AtmosphericPressure_Aceleration, AtmGradient, Aux)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == 1) then
                        AtmGradient = AtmPressure(i - 1, j) - AtmPressure(i, j)
                        Aux         = Me%FaceDensity(i, j, k) * DZX_ZY(i - 1, j)
                        !Aceleration due to Atmospheric Pressure
                        ![m/s^2]                        = [M*m/s^2/m^2] / ([M/m^3] * [m])
                        AtmosphericPressure_Aceleration = AtmGradient / Aux

                        AtmosphericPressure_Aceleration = Me%ComputeOptions%AtmosphereCoef * &
                                                            AtmosphericPressure_Aceleration

                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * AtmosphericPressure_Aceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif

        else
            if (Me%Docycle_method == 1) then
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, AtmosphericPressure_Aceleration, AtmGradient, Aux)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB
                    kbottom = KFloor_UV(i, j)
                    if (ComputeFaces3D_UV(i, j, KUB) == 1) then
                        do  k = kbottom, KUB
                            AtmGradient = AtmPressure(i, j - 1) - AtmPressure(i, j)
                            Aux = Me%FaceDensity(i, j, k) * DZX_ZY(i, j - 1)

                        !Aceleration due to Atmospheric Pressure
                            ![m/s^2]                        = [M*m/s^2/m^2] / ([M/m^3] * [m]
                            AtmosphericPressure_Aceleration = AtmGradient / Aux

                            AtmosphericPressure_Aceleration = Me%ComputeOptions%AtmosphereCoef * &
                                                                AtmosphericPressure_Aceleration

                            TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * AtmosphericPressure_Aceleration
                        enddo
                    endif
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            else
                !$OMP PARALLEL PRIVATE( i,j,k,kbottom, AtmosphericPressure_Aceleration, AtmGradient, Aux)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if (ComputeFaces3D_UV(i, j, k) == 1) then
                        AtmGradient = AtmPressure(i, j - 1) - AtmPressure(i, j)
                        Aux = Me%FaceDensity(i, j, k) * DZX_ZY(i, j - 1)

                        !Aceleration due to Atmospheric Pressure
                        ![m/s^2]                        = [M*m/s^2/m^2] / ([M/m^3] * [m]
                        AtmosphericPressure_Aceleration = AtmGradient / Aux

                        AtmosphericPressure_Aceleration = Me%ComputeOptions%AtmosphereCoef * &
                                                            AtmosphericPressure_Aceleration

                        TiCoef_3D(i, j, k) = TiCoef_3D(i, j, k) + DT_Velocity * AtmosphericPressure_Aceleration
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO NOWAIT
                !$OMP END PARALLEL
            endif

        endif

        nullify(TiCoef_3D)
        nullify(AtmPressure)
        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(DZX_ZY)

    end subroutine AddAtmPressure


    !-----------------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the vertical advection and is able to do the               !
    !  calculation explicit or implicit                                                    !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_VerticalAdvection

        !Variables Categories
        ! Geometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! Flow     : WaterFlux_Z (Vertical water fluxes), Velocity_UV (U or V velocity)
        ! Time     : DT_Velocity (velocity time step)
        ! Mapping  : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        ! Options  : UpStream_CenterDif (1- Upwind and 0- Centered differences), ImplicitVertAdvection (1- implict, 0- explicit)
        ! Direction: Direction (DirectionX_=1,DirectionY_=2)
        ! Dimension: ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction:
        !Volume_UV, Area_UV, Velocity_UV, ComputeFaces3D_UV, Direction, KFloor_UV

        !Variables independent from the direction. In the future this arguments
        !will enter the subroutine associated with modules:
        !WaterFlux_Z, DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,
        !DT_Velocity, UpStream_CenterDif, ImplicitVertAdvection,
        !ILB, IUB, JLB, JUB, KUB

        !X direction
        !call VerticalAdvection(Volume_U, Area_U, Velocity_U,             &
        !                        ComputeFaces3D_U, KFloorU, DirectionX_,      &
        !                        WaterFlux_Z,                              &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,          &
        !                        DT_Velocity,                              &
        !                        UpStream_CenterDif, ImplicitVertAdvection,   &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Y direction
        !call VerticalAdvection(Volume_V, Area_V, Velocity_V,             &
        !                        ComputeFaces3D_V, KFloorV, DirectionY_,      &
        !                        WaterFlux_Z,                              &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,          &
        !                        DT_Velocity,                              &
        !                        UpStream_CenterDif, ImplicitVertAdvection,   &
        !                        ILB, IUB, JLB, JUB, KUB)



        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, WaterFlux_Z, ECoef_3D

        real,    dimension(:,:,:), pointer :: DCoef_3D, FCoef_3D, TiCoef_3D, &
                                              Area_UV, Velocity_UV_Old

        real,    dimension(:,:  ), pointer :: DZX_ZY, WaterColumnUV, DYY_XX

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: UpStream_CenterDif, ImplicitVertAdvection, WaterColumn2D

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, di, dj

        real(8), dimension(4)              :: V4
        real,    dimension(4)              :: CFace, Vel4, du4

        real(8)                            :: Correction, Face_Flux, MomentumFlux

        integer                            :: i, j, k, Kbottom, iSouth, jWest

        logical                            :: NearBoundary

        !griflet: needed to initialize outside of the parallel zone of the code
        real                               :: DT
        integer                            :: STAT_CALL

        !$ integer                            :: CHUNK

        !Begin---------------------------------------------------------------------


        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

!        DT_Velocity          =  Me%Velocity%DT

        UpStream_CenterDif   =  Me%ComputeOptions%UpStream_CenterDif
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        ImplicitVertAdvection   =  Me%ComputeOptions%ImplicitVertAdvection

        WaterFlux_Z          => Me%WaterFluxes%Z

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV
        Area_UV              => Me%External_Var%Area_UV

        DZX_ZY               => Me%External_Var%DZX_ZY
        DYY_XX               => Me%External_Var%DYY_XX
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name

        !griflet: this call must be made outside of the parallelized zone.
        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "Velocity_VerticalAdvection - ModuleHydrodynamic - ERR01")

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_VerticalAdvection")
        endif

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !griflet: Ok, it is assumed that *statically* allocated arrays may be safely replicated
        !with the private directive.
        !$OMP PARALLEL PRIVATE( i,j,k,iSouth,jWest,Kbottom,Correction,      &
        !$OMP                   Face_Flux,NearBoundary,Vel4,                &
        !$OMP                   du4,V4,MomentumFlux,CFace,                  &
        !$OMP                   DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D)

        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F
        TiCoef_3D            => Me%Coef%D3%Ti

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doj:    do j=JLB, JUB
doi:    do i=ILB, IUB

            !This if impose in the open boundary gradient null for the vertical advection
cd1:        if (    ComputeFaces3D_UV(i, j, KUB) == Covered  .and.              &
                    WaterColumnUV(i, j) > WaterColumn2D .and.                   &
                    .not. (                                                     &
                        BoundaryFacesUV  (i, j) == Boundary .and.               &
                        .not. Me%SubModel%ON .and. (                            &
                            .not. Me%CyclicBoundary%ON .or.                     &
                            (Me%CyclicBoundary%ON .and.                         &
                            Me%CyclicBoundary%Direction == Me%Direction%YX)     &
                         )                                                      &
                    )                                                           &
             ) then

                iSouth = i - di
                jWest  = j - dj

                Kbottom = KFloor_UV(i, j)

                Correction = 0.

dok1:           do  k = Kbottom + 1, KUB

                    Face_Flux    = (WaterFlux_Z(iSouth, jWest, k) + WaterFlux_Z(i, j, k))/2.

                    if (Me%SubModel%ON .and. BoundaryFacesUV  (i, j) == Boundary ) then

                        !GRiflet, openmp: no reduce danger.
                        Correction = VertAdvectionSubModel ( Correction, DT, i, j, k)

                        Face_Flux   = Face_Flux + Correction / 2.

                    endif

                    NearBoundary = .false.

                    if (Face_Flux > 0) then
                        if (k == Kbottom + 1) NearBoundary = .true.
                    else
                        if (k == KUB        ) NearBoundary = .true.
                    endif

                    Vel4(1) = Velocity_UV_Old(i, j, k - 2);
                    Vel4(2) = Velocity_UV_Old(i, j, k - 1);
                    Vel4(3) = Velocity_UV_Old(i, j, k    );
                    Vel4(4) = Velocity_UV_Old(i, j, k + 1);

                    du4(1) = Area_UV(i, j, k - 2) / DYY_XX(i, j);
                    du4(2) = Area_UV(i, j, k - 1) / DYY_XX(i, j);
                    du4(3) = Area_UV(i, j, k    ) / DYY_XX(i, j);
                    du4(4) = Area_UV(i, j, k + 1) / DYY_XX(i, j);

                    !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
                    !is the only way of cancel the vertical diffusion and advection terms
                    !when the water flow is considered implicit in the water level calculation.
                    !However, this relation is not true when AreaUV is computed using the
                    !minimum thickness metodology.
                    !See ModuleGeometry
                    ![s/m]                   =   [s] /  [m]
!                    DT_V                     =   DT_Velocity / (Area_UV(i, j, k) * DZX_ZY(iSouth, jWest))

                    V4   (1) = Area_UV(i, j, k - 2) * DZX_ZY(iSouth, jWest);
                    V4   (2) = Area_UV(i, j, k - 1) * DZX_ZY(iSouth, jWest);
                    V4   (3) = Area_UV(i, j, k    ) * DZX_ZY(iSouth, jWest);
                    V4   (4) = Area_UV(i, j, k + 1) * DZX_ZY(iSouth, jWest);

                    !griflet: here all the variables are private including, the statically allocated arrays.
                    call ComputeAdvectionFace(Vel4, V4, du4, Me%Velocity%DT,            &
                                              Face_Flux,                                &
                                              Me%ComputeOptions%VolumeRelMax,           &
                                              Me%ComputeOptions%AdvectionMethodV,       &
                                              Me%ComputeOptions%TVD_LimV,               &
                                              NearBoundary,                             &
                                              Me%ComputeOptions%Upwind2V, CFace)



                    MomentumFlux = dble(Vel4(1) * CFace(1)  + Vel4(2) * CFace(2)  +     &
                                        Vel4(3) * CFace(3)  + Vel4(4) * CFace(4)) *     &
                                        Face_Flux ![m/s*m^3/s]

                    TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + (1. - ImplicitVertAdvection) * &
                                            MomentumFlux * Me%Velocity%DT / V4(3)

                    TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - (1. - ImplicitVertAdvection) * &
                                            MomentumFlux * Me%Velocity%DT / V4(2)

                    DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - ImplicitVertAdvection *  &
                                            CFace(2) * Face_Flux *  Me%Velocity%DT / V4(3)

                    ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - ImplicitVertAdvection *  &
                                            CFace(3) * Face_Flux *  Me%Velocity%DT / V4(3)

                    ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + ImplicitVertAdvection *  &
                                            CFace(2) * Face_Flux *  Me%Velocity%DT / V4(2)

                    FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + ImplicitVertAdvection *  &
                                            CFace(3) * Face_Flux *  Me%Velocity%DT / V4(2)

                enddo dok1

            endif cd1

        enddo doi
        enddo doj
        !$OMP END DO

        !$OMP END PARALLEL

        !Nullify auxiliar pointers
        nullify(DCoef_3D)
        nullify(ECoef_3D)
        nullify(FCoef_3D)
        nullify(TiCoef_3D)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_VerticalAdvection")
        endif

        nullify(WaterFlux_Z)

        nullify(Velocity_UV_Old)

        nullify(Volume_UV)
        nullify(Area_UV  )
        nullify(DZX_ZY, DYY_XX)
        nullify(WaterColumnUV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(BoundaryFacesUV)


!        Deallocate(BottomCell_BottomFace, CenterCell_BottomFace, &
!                   CenterCell_TopFace,    TopCell_TopFace)

    End Subroutine Velocity_VerticalAdvection
    ! End----------------------------------------------------------------------------------------

    Subroutine Velocity_VerticalAdvection2

        !Arguments------------------------------------------------------------
        !Local---------------------------------------------------------------------
        !griflet: needed to initialize outside of the parallel zone of the code
        real                               :: DT

        integer                            :: STAT_CALL
        !Begin---------------------------------------------------------------------

        !griflet: this call must be made outside of the parallelized zone.
        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, "Velocity_VerticalAdvection2 - ModuleHydrodynamic - ERR01")

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_VerticalAdvection2")
        endif

        !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
        !is the only way of cancel the vertical diffusion and advection terms
        !when the water flow is considered implicit in the water level calculation.
        !However, this relation is not true when AreaUV is computed using the
        !minimum thickness metodology.
        !See ModuleGeometry
        ![s/m]                    =   [s] /  [m]
        !DT_V                     =   DT_Velocity / (Area_UV(i, j, k) * DZX_ZY(iSouth, jWest))

        call Vel_VertAdv_P2_TVD_SB(DT)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_VerticalAdvection2")
        endif

    End Subroutine Velocity_VerticalAdvection2

    !End------------------------------------------------------------------------------------

     subroutine Vel_VertAdv_P2_TVD_SB(DT)

        !Arguments------------------------------------------------------------
        real                               :: DT
        !Begin----------------------------------------------------------------

        if (Me%ComputeOptions%ImplicitVertAdvection == 1) then
            if (Me%Direction%di == 1) then
                call Vel_VertAdv_P2_TVD_SB_Imp_Y(Me%Velocity%Horizontal%V%Old, Me%External_Var%ComputeFaces3D_V,       &
                                                Me%External_Var%BoundaryFacesV, Me%External_Var%KFloor_V,             &
                                                Me%External_Var%WaterColumnV, Me%WaterFluxes%Z, Me%External_Var%DZY,  &
                                                Me%External_Var%Area_V, Me%External_Var%DXX, DT)
            else
                call Vel_VertAdv_P2_TVD_SB_Imp_X(Me%Velocity%Horizontal%U%Old, Me%External_Var%ComputeFaces3D_U,       &
                                                Me%External_Var%BoundaryFacesU, Me%External_Var%KFloor_U,             &
                                                Me%External_Var%WaterColumnU, Me%WaterFluxes%Z, Me%External_Var%DZX,  &
                                                Me%External_Var%Area_U, Me%External_Var%DYY, DT)
            endif
        else

            if (Me%Direction%di == 1) then
                call Vel_VertAdv_P2_TVD_SB_Exp_Y(Me%Velocity%Horizontal%V%Old, Me%External_Var%ComputeFaces3D_V,       &
                                                Me%External_Var%BoundaryFacesV, Me%External_Var%KFloor_V,             &
                                                Me%External_Var%WaterColumnV, Me%WaterFluxes%Z, Me%External_Var%DZY,  &
                                                Me%External_Var%Area_V, Me%External_Var%DXX, DT)
            else
                call Vel_VertAdv_P2_TVD_SB_Exp_X(Me%Velocity%Horizontal%U%Old, Me%External_Var%ComputeFaces3D_U,       &
                                                Me%External_Var%BoundaryFacesU, Me%External_Var%KFloor_U,             &
                                                Me%External_Var%WaterColumnU, Me%WaterFluxes%Z, Me%External_Var%DZX,  &
                                                Me%External_Var%Area_U, Me%External_Var%DYY, DT)
            endif
        endif

    end subroutine Vel_VertAdv_P2_TVD_SB

    !-------------------------------------------------------------------------------------------------------------
    subroutine Vel_VertAdv_P2_TVD_SB_Imp_Y(Velocity_V_Old, ComputeFaces3D_V, BoundaryFacesV, KFloor_V, WaterColumnV, &
        WaterFlux_Z, DZY, Area_V, DXX, DT)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(IN) :: WaterFlux_Z
        real,    dimension(:,:,:), pointer, intent(IN) :: Area_V, Velocity_V_Old
        real,    dimension(:,:  ), pointer, intent(IN) :: DZY, WaterColumnV, DXX
        integer, dimension(:,:,:), pointer, intent(IN) :: ComputeFaces3D_V
        integer, dimension(:,:),   pointer, intent(IN) :: KFloor_V, BoundaryFacesV
        real,                              intent(IN)  :: DT
        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer             :: ECoef_3D
        real,    dimension(:,:,:), pointer             :: DCoef_3D, FCoef_3D
        real                                           :: WaterColumn2D, CFace2_x_FaceFlux_x_DT, &
                                                          CFace3_x_FaceFlux_x_DT
        real(8), allocatable, dimension(:)             :: CorrectionKArray
        real(8), dimension(4)                          :: V4
        real,    dimension(4)                          :: CFace, Vel4, du4
        real(8)                                        :: Face_Flux, Correction
        integer                                        :: i, j, k, Kbottom
        !$ integer                                     :: CHUNK
        !Begin---------------------------------------------------------------------
        !Begin - Shorten variables name
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        !$ CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,Correction,CorrectionKArray,Face_Flux,Vel4,du4,V4,CFace,    &
        !$OMP                  DCoef_3D, ECoef_3D, FCoef_3D,CFace2_x_FaceFlux_x_DT,CFace3_x_FaceFlux_x_DT)
        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F

        if (Me%SubModel%ON) then
            allocate(CorrectionKArray(Me%WorkSize%KUB))
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_V(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnV(i, j) > WaterColumn2D) then

                    Kbottom = KFloor_V(i, j)
                    Correction = 0.
                    CorrectionKArray(:) = 0

                    if (BoundaryFacesV  (i, j) == Boundary ) then
                        do  k = Kbottom + 1, Me%WorkSize%KUB
                            !GRiflet, openmp: no reduce danger.
                            Correction = VertAdvectionSubModel ( Correction, DT, i, j, k)
                            CorrectionKArray(k) = Correction
                        enddo
                    endif

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux = (WaterFlux_Z(i-1, j, k) + WaterFlux_Z(i, j, k) + CorrectionKArray(k)) /2.

                        V4 (2) = Area_V(i, j, k - 1) * DZY(i-1, j); V4 (3) = Area_V(i, j, k) * DZY(i-1, j);

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                            !Near bottom boundary   Cface(2) = 1
                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                            !Near surface boundary Cface(3) = 1
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        else

                            Vel4(1) = Velocity_V_Old(i, j, k - 2); Vel4(2) = Velocity_V_Old(i, j, k - 1);
                            Vel4(3) = Velocity_V_Old(i, j, k    ); Vel4(4) = Velocity_V_Old(i, j, k + 1);

                            du4(1) = Area_V(i, j, k - 2) / DXX(i, j); du4(2) = Area_V(i, j, k - 1) / DXX(i, j);
                            du4(3) = Area_V(i, j, k    ) / DXX(i, j); du4(4) = Area_V(i, j, k + 1) / DXX(i, j);

                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                   Face_Flux, CFace)

                            CFace2_x_FaceFlux_x_DT = CFace(2) * Face_Flux * Me%Velocity%DT
                            CFace3_x_FaceFlux_x_DT = CFace(3) * Face_Flux * Me%Velocity%DT

                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - CFace2_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - CFace3_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + CFace2_x_FaceFlux_x_DT / V4(2)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + CFace3_x_FaceFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
            deallocate(CorrectionKArray)

        else
            !Ignore boundary faces
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_V(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnV(i, j) > WaterColumn2D .and. &
                .not. (BoundaryFacesV  (i, j) == Boundary .and. &
                       (.not. Me%CyclicBoundary%ON .or. &
                             (Me%CyclicBoundary%ON .and. Me%CyclicBoundary%Direction == Me%Direction%YX)))) then

                    Kbottom = KFloor_V(i, j)

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux    = (WaterFlux_Z(i-1, j, k) + WaterFlux_Z(i, j, k)) / 2.

                        V4 (2) = Area_V(i, j, k - 1) * DZY(i-1, j); V4 (3) = Area_V(i, j, k) * DZY(i-1, j);

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                            !Near bottom boundary   Cface(2) = 1
                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                            !Near surface boundary Cface(3) = 1
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        else

                            Vel4(1) = Velocity_V_Old(i, j, k - 2); Vel4(2) = Velocity_V_Old(i, j, k - 1);
                            Vel4(3) = Velocity_V_Old(i, j, k    ); Vel4(4) = Velocity_V_Old(i, j, k + 1);

                            du4(1) = Area_V(i, j, k - 2) / DXX(i, j); du4(2) = Area_V(i, j, k - 1) / DXX(i, j);
                            du4(3) = Area_V(i, j, k    ) / DXX(i, j); du4(4) = Area_V(i, j, k + 1) / DXX(i, j);

                            !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                   Face_Flux, CFace)

                            CFace2_x_FaceFlux_x_DT = CFace(2) * Face_Flux * Me%Velocity%DT
                            CFace3_x_FaceFlux_x_DT = CFace(3) * Face_Flux * Me%Velocity%DT

                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - CFace2_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - CFace3_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + CFace2_x_FaceFlux_x_DT / V4(2)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + CFace3_x_FaceFlux_x_DT / V4(2)

                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif

        nullify(DCoef_3D, ECoef_3D, FCoef_3D)
        !$OMP END PARALLEL

    end subroutine Vel_VertAdv_P2_TVD_SB_Imp_Y

    !End-------------------------------------------------------------------------------------------

    subroutine Vel_VertAdv_P2_TVD_SB_Imp_X(Velocity_U_Old, ComputeFaces3D_U, BoundaryFacesU, KFloor_U, WaterColumnU, &
        WaterFlux_Z, DZX, Area_U, DYY, DT)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(IN) :: WaterFlux_Z
        real,    dimension(:,:,:), pointer, intent(IN) :: Area_U, Velocity_U_Old
        real,    dimension(:,:  ), pointer, intent(IN) :: DZX, WaterColumnU, DYY
        integer, dimension(:,:,:), pointer, intent(IN) :: ComputeFaces3D_U
        integer, dimension(:,:),   pointer, intent(IN) :: KFloor_U, BoundaryFacesU
        real,                               intent(IN) :: DT
        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer             :: ECoef_3D
        real,    dimension(:,:,:), pointer             :: DCoef_3D, FCoef_3D
        real                                           :: WaterColumn2D, CFace2_x_FaceFlux_x_DT, &
                                                          CFace3_x_FaceFlux_x_DT
        real(8), allocatable, dimension(:)             :: CorrectionKArray
        real(8), dimension(4)                          :: V4
        real,    dimension(4)                          :: CFace, Vel4, du4
        real(8)                                        :: Face_Flux, Correction
        integer                                        :: i, j, k, Kbottom
        !$ integer                                     :: CHUNK
        !Begin---------------------------------------------------------------------
        !Begin - Shorten variables name
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        !$ CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,Correction,CorrectionKArray,Face_Flux,Vel4,du4,V4,CFace,    &
        !$OMP                  DCoef_3D, ECoef_3D, FCoef_3D,CFace2_x_FaceFlux_x_DT,CFace3_x_FaceFlux_x_DT)
        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F

        if (Me%SubModel%ON) then
            allocate(CorrectionKArray(Me%WorkSize%KUB))
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_U(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnU(i, j) > WaterColumn2D) then

                    Kbottom = KFloor_U(i, j)
                    Correction = 0.
                    CorrectionKArray(:) = 0

                    if (BoundaryFacesU  (i, j) == Boundary ) then
                        do  k = Kbottom + 1, Me%WorkSize%KUB
                            !GRiflet, openmp: no reduce danger.
                            Correction = VertAdvectionSubModel ( Correction, DT, i, j, k)
                            CorrectionKArray(k) = Correction
                        enddo
                    endif

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux = (WaterFlux_Z(i, j-1, k) + WaterFlux_Z(i, j, k) + CorrectionKArray(k)) /2.

                        V4 (2) = Area_U(i, j, k - 1) * DZX(i, j-1); V4(3) = Area_U(i, j, k) * DZX(i, j-1);

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                            !Near bottom boundary   Cface(2) = 1
                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                            !Near surface boundary Cface(3) = 1
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        else

                            Vel4(1) = Velocity_U_Old(i, j, k - 2); Vel4(2) = Velocity_U_Old(i, j, k - 1);
                            Vel4(3) = Velocity_U_Old(i, j, k    ); Vel4(4) = Velocity_U_Old(i, j, k + 1);

                            du4(1) = Area_U(i, j, k - 2) / DYY(i, j); du4(2) = Area_U(i, j, k - 1) / DYY(i, j);
                            du4(3) = Area_U(i, j, k    ) / DYY(i, j); du4(4) = Area_U(i, j, k + 1) / DYY(i, j);

                            !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                    Face_Flux, CFace)

                            CFace2_x_FaceFlux_x_DT = CFace(2) * Face_Flux * Me%Velocity%DT
                            CFace3_x_FaceFlux_x_DT = CFace(3) * Face_Flux * Me%Velocity%DT

                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - CFace2_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - CFace3_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + CFace2_x_FaceFlux_x_DT / V4(2)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + CFace3_x_FaceFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
            deallocate(CorrectionKArray)
        else
            !Ignore boundary faces
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_U(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnU(i, j) > WaterColumn2D .and. &
                .not. (BoundaryFacesU  (i, j) == Boundary .and. &
                       (.not. Me%CyclicBoundary%ON .or. &
                             (Me%CyclicBoundary%ON .and. Me%CyclicBoundary%Direction == Me%Direction%YX)))) then

                    Kbottom = KFloor_U(i, j)

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux = (WaterFlux_Z(i, j-1, k) + WaterFlux_Z(i, j, k)) / 2.

                        V4 (2) = Area_U(i, j, k - 1) * DZX(i, j-1); V4(3) = Area_U(i, j, k) * DZX(i, j-1);

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                            !Near bottom boundary   Cface(2) = 1
                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                            !Near surface boundary Cface(3) = 1
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - Face_Flux * Me%Velocity%DT / V4(3)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + Face_Flux * Me%Velocity%DT / V4(2)
                        else

                            Vel4(1) = Velocity_U_Old(i, j, k - 2); Vel4(2) = Velocity_U_Old(i, j, k - 1);
                            Vel4(3) = Velocity_U_Old(i, j, k    ); Vel4(4) = Velocity_U_Old(i, j, k + 1);

                            du4(1) = Area_U(i, j, k - 2) / DYY(i, j); du4(2) = Area_U(i, j, k - 1) / DYY(i, j);
                            du4(3) = Area_U(i, j, k    ) / DYY(i, j); du4(4) = Area_U(i, j, k + 1) / DYY(i, j);

                            !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                    Face_Flux, CFace)

                            CFace2_x_FaceFlux_x_DT = CFace(2) * Face_Flux * Me%Velocity%DT
                            CFace3_x_FaceFlux_x_DT = CFace(3) * Face_Flux * Me%Velocity%DT

                            DCoef_3D (i, j, k  )  = DCoef_3D (i, j, k  ) - CFace2_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k  )  = ECoef_3D (i, j, k  ) - CFace3_x_FaceFlux_x_DT / V4(3)
                            ECoef_3D (i, j, k-1)  = ECoef_3D (i, j, k-1) + CFace2_x_FaceFlux_x_DT / V4(2)
                            FCoef_3D (i, j, k-1)  = FCoef_3D (i, j, k-1) + CFace3_x_FaceFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif
        nullify(DCoef_3D, ECoef_3D, FCoef_3D)
        !$OMP END PARALLEL

    end subroutine Vel_VertAdv_P2_TVD_SB_Imp_X

    !End-------------------------------------------------------------------------------------------

    subroutine Vel_VertAdv_P2_TVD_SB_Exp_Y(Velocity_V_Old, ComputeFaces3D_V, BoundaryFacesV, KFloor_V, WaterColumnV, &
        WaterFlux_Z, DZY, Area_V, DXX, DT)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(IN) :: WaterFlux_Z
        real,    dimension(:,:,:), pointer, intent(IN) :: Area_V, Velocity_V_Old
        real,    dimension(:,:  ), pointer, intent(IN) :: DZY, WaterColumnV, DXX
        integer, dimension(:,:,:), pointer, intent(IN) :: ComputeFaces3D_V
        integer, dimension(:,:),   pointer, intent(IN) :: KFloor_V, BoundaryFacesV
        real,                               intent(IN) :: DT
        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer             :: TiCoef_3D
        real                                           :: WaterColumn2D, MomentumFlux_x_DT
        real(8), allocatable, dimension(:)             :: CorrectionKArray
        real(8), dimension(4)                          :: V4
        real,    dimension(4)                          :: CFace, Vel4, du4
        real(8)                                        :: Face_Flux, MomentumFlux, Correction
        integer                                        :: i, j, k, Kbottom
        !$ integer                                     :: CHUNK
        !Begin---------------------------------------------------------------------
        !Begin - Shorten variables name
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        !$ CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,CorrectionKArray,Face_Flux,Vel4,du4,V4,CFace,TiCoef_3D, &
        !$OMP                  MomentumFlux_x_DT, MomentumFlux, Correction)
        TiCoef_3D            => Me%Coef%D3%Ti

        if (Me%SubModel%ON) then
            allocate(CorrectionKArray(Me%WorkSize%KUB))
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_V(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnV(i, j) > WaterColumn2D) then

                    Kbottom = KFloor_V(i, j)
                    Correction = 0.
                    CorrectionKArray(:) = 0

                    if (BoundaryFacesV  (i, j) == Boundary ) then
                        do  k = Kbottom + 1, Me%WorkSize%KUB
                            !GRiflet, openmp: no reduce danger.
                            Correction = VertAdvectionSubModel ( Correction, DT, i, j, k)
                            CorrectionKArray(k) = Correction
                        enddo
                    endif

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux = (WaterFlux_Z(i-1, j, k) + WaterFlux_Z(i, j, k) + CorrectionKArray(k)) /2.

                        V4  (2) = Area_V(i, j, k - 1) * DZY(i-1, j); V4  (3) = Area_V(i, j, k) * DZY(i-1, j);

                        Vel4(2) = Velocity_V_Old(i, j, k - 1)      ; Vel4(3) = Velocity_V_Old(i, j, k    );

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                            !Near bottom boundary   Cface(2) = 1
                            MomentumFlux          = dble(Vel4(2) * CFace(2)) * Face_Flux ![m/s*m^3/s]
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux * Me%Velocity%DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux * Me%Velocity%DT / V4(2)
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                            !Near surface boundary Cface(3) = 1
                            MomentumFlux          = dble(Vel4(3) * CFace(3)) * Face_Flux ![m/s*m^3/s]
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux * Me%Velocity%DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux * Me%Velocity%DT / V4(2)
                        else

                            Vel4(1) = Velocity_V_Old(i, j, k - 2); Vel4(4) = Velocity_V_Old(i, j, k + 1);

                            du4(1) = Area_V(i, j, k - 2) / DXX(i, j); du4(2) = Area_V(i, j, k - 1) / DXX(i, j);
                            du4(3) = Area_V(i, j, k    ) / DXX(i, j); du4(4) = Area_V(i, j, k + 1) / DXX(i, j);

                            !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                   Face_Flux, CFace)

                            MomentumFlux = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *     &
                                                Face_Flux ![m/s*m^3/s]

                            MomentumFlux_x_DT     =                  MomentumFlux * Me%Velocity%DT
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux_x_DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
            deallocate(CorrectionKArray)
        else
            !Ignore boundary faces
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_V(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnV(i, j) > WaterColumn2D .and. &
                .not. (BoundaryFacesV  (i, j) == Boundary .and. &
                       (.not. Me%CyclicBoundary%ON .or. &
                             (Me%CyclicBoundary%ON .and. Me%CyclicBoundary%Direction == Me%Direction%YX)))) then

                    Kbottom = KFloor_V(i, j)

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux    = (WaterFlux_Z(i-1, j, k) + WaterFlux_Z(i, j, k))/2.

                        V4  (2) = Area_V(i, j, k - 1) * DZY(i-1, j); V4  (3) = Area_V(i, j, k) * DZY(i-1, j);

                        Vel4(2) = Velocity_V_Old(i, j, k - 1)      ; Vel4(3) = Velocity_V_Old(i, j, k    );

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                            !Near bottom boundary   Cface(2) = 1
                            MomentumFlux          = dble(Vel4(2) * CFace(2)) * Face_Flux ![m/s*m^3/s]
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux * Me%Velocity%DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux * Me%Velocity%DT / V4(2)
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                            !Near surface boundary Cface(3) = 1
                            MomentumFlux          = dble(Vel4(3) * CFace(3)) * Face_Flux ![m/s*m^3/s]
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux * Me%Velocity%DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux * Me%Velocity%DT / V4(2)
                        else

                            Vel4(1) = Velocity_V_Old(i, j, k - 2);   Vel4(4) = Velocity_V_Old(i, j, k + 1);

                            du4(1) = Area_V(i, j, k - 2) / DXX(i, j); du4(2) = Area_V(i, j, k - 1) / DXX(i, j);
                            du4(3) = Area_V(i, j, k    ) / DXX(i, j); du4(4) = Area_V(i, j, k + 1) / DXX(i, j);

                            !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                   Face_Flux, CFace)

                            MomentumFlux = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *     &
                                                Face_Flux ![m/s*m^3/s]

                            MomentumFlux_x_DT     =                  MomentumFlux * Me%Velocity%DT
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux_x_DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif

        nullify(TiCoef_3D)
        !$OMP END PARALLEL

    end subroutine Vel_VertAdv_P2_TVD_SB_Exp_Y

    !End-------------------------------------------------------------------------------------------

    subroutine Vel_VertAdv_P2_TVD_SB_Exp_X(Velocity_U_Old, ComputeFaces3D_U, BoundaryFacesU, KFloor_U, WaterColumnU, &
        WaterFlux_Z, DZX, Area_U, DYY, DT)
        !Arguments------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(IN) :: WaterFlux_Z
        real,    dimension(:,:,:), pointer, intent(IN) :: Area_U, Velocity_U_Old
        real,    dimension(:,:  ), pointer, intent(IN) :: DZX, WaterColumnU, DYY
        integer, dimension(:,:,:), pointer, intent(IN) :: ComputeFaces3D_U
        integer, dimension(:,:),   pointer, intent(IN) :: KFloor_U, BoundaryFacesU
        real,                               intent(IN) :: DT
        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer             :: TiCoef_3D
        real                                           :: WaterColumn2D, MomentumFlux_x_DT
        real(8), allocatable, dimension(:)             :: CorrectionKArray
        real(8), dimension(4)                          :: V4
        real,    dimension(4)                          :: CFace, Vel4, du4
        real(8)                                        :: Face_Flux, MomentumFlux, Correction
        integer                                        :: i, j, k, Kbottom
        !$ integer                                     :: CHUNK
        !Begin---------------------------------------------------------------------
        !Begin - Shorten variables name
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        !$ CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)
        !$OMP PARALLEL PRIVATE( i,j,k,Kbottom,Face_Flux,Vel4,du4,V4,Correction,               &
        !$OMP                   MomentumFlux,CFace,TiCoef_3D,MomentumFlux_x_DT,CorrectionKArray)
        TiCoef_3D            => Me%Coef%D3%Ti

        if (Me%SubModel%ON) then
            allocate(CorrectionKArray(Me%WorkSize%KUB))
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_U(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnU(i, j) > WaterColumn2D) then

                    Kbottom = KFloor_U(i, j)
                    Correction = 0.
                    CorrectionKArray(:) = 0

                    if (BoundaryFacesU  (i, j) == Boundary ) then
                        do  k = Kbottom + 1, Me%WorkSize%KUB
                            !GRiflet, openmp: no reduce danger.
                            Correction = VertAdvectionSubModel ( Correction, DT, i, j, k)
                            CorrectionKArray(k) = Correction
                        enddo
                    endif

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux = (WaterFlux_Z(i, j-1, k) + WaterFlux_Z(i, j, k) + CorrectionKArray(k))/2.

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                                !Nearboundary - Do nothing
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                                !Nearboundary - Do nothing
                        else

                            Vel4(1) = Velocity_U_Old(i, j, k - 2); Vel4(2) = Velocity_U_Old(i, j, k - 1);
                            Vel4(3) = Velocity_U_Old(i, j, k    ); Vel4(4) = Velocity_U_Old(i, j, k + 1);

                            du4(1) = Area_U(i, j, k - 2) / DYY(i, j); du4(2) = Area_U(i, j, k - 1) / DYY(i, j);
                            du4(3) = Area_U(i, j, k    ) / DYY(i, j); du4(4) = Area_U(i, j, k + 1) / DYY(i, j);

                            V4 (2) = Area_U(i, j, k - 1) * DZX(i, j-1); V4 (3) = Area_U(i, j, k  ) * DZX(i, j-1);

                        !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                   Face_Flux, CFace)

                            MomentumFlux = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *     &
                                                Face_Flux ![m/s*m^3/s]

                            MomentumFlux_x_DT     =                  MomentumFlux * Me%Velocity%DT
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux_x_DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
            deallocate(CorrectionKArray)
        else
            !Ignore boundary faces
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j=Me%WorkSize%JLB, Me%WorkSize%JUB
            do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                !This if impose in the open boundary gradient null for the vertical advection
                if (ComputeFaces3D_U(i, j, Me%WorkSize%KUB) == Covered .and. WaterColumnU(i, j) > WaterColumn2D .and. &
                .not. (BoundaryFacesU(i, j) == Boundary .and. &
                       (.not. Me%CyclicBoundary%ON .or. &
                             (Me%CyclicBoundary%ON .and. Me%CyclicBoundary%Direction == Me%Direction%YX)))) then

                    Kbottom = KFloor_U(i, j)

                    do  k = Kbottom + 1, Me%WorkSize%KUB

                        Face_Flux    = (WaterFlux_Z(i-1, j, k) + WaterFlux_Z(i, j, k))/2.

                        if     ((Face_Flux > 0) .and. (k == Kbottom + 1))then
                                !Nearboundary - Do nothing
                        elseif ((Face_Flux <= 0) .and. (k == Me%WorkSize%KUB))then
                                !Nearboundary - Do nothing
                        else

                            Vel4(1) = Velocity_U_Old(i, j, k - 2); Vel4(2) = Velocity_U_Old(i, j, k - 1);
                            Vel4(3) = Velocity_U_Old(i, j, k    ); Vel4(4) = Velocity_U_Old(i, j, k + 1);

                            du4(1) = Area_U(i, j, k - 2) / DYY(i, j); du4(2) = Area_U(i, j, k - 1) / DYY(i, j);
                            du4(3) = Area_U(i, j, k    ) / DYY(i, j); du4(4) = Area_U(i, j, k + 1) / DYY(i, j);

                            V4 (2) = Area_U(i, j, k - 1) * DZX(i, j-1); V4 (3) = Area_U(i, j, k  ) * DZX(i, j-1);

                        !griflet: here all the variables are private including, the statically allocated arrays.
                            call ComputeAdvectionFace_TVD_Superbee(Vel4, V4, du4, Me%Velocity%DT,            &
                                                                   Face_Flux, CFace)

                            MomentumFlux = dble(Vel4(2) * CFace(2)  + Vel4(3) * CFace(3)) *     &
                                                Face_Flux ![m/s*m^3/s]

                            MomentumFlux_x_DT     =                  MomentumFlux * Me%Velocity%DT
                            TiCoef_3D(i, j, k  )  = TiCoef_3D(i, j, k  ) + MomentumFlux_x_DT / V4(3)
                            TiCoef_3D(i, j, k-1)  = TiCoef_3D(i, j, k-1) - MomentumFlux_x_DT / V4(2)
                        endif
                    enddo
                endif
            enddo
            enddo
            !$OMP END DO
        endif

        nullify(TiCoef_3D)
        !$OMP END PARALLEL

    end subroutine Vel_VertAdv_P2_TVD_SB_Exp_X

    !-------------------------------------------------------------------------------------------------------------

    !End-------------------------------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! Corrects the vertical flux in the boundary faces                                     !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping                                                      !
    ! OutPut: Water Flow                                                                   !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    function VertAdvectionSubModel ( BottomFlux, DT, i, j, k)

        !Arguments------------------------------------------------------------


        real(8)               :: BottomFlux
        integer               :: i, j, k
        real(8)               :: VertAdvectionSubModel
        real                  :: DT

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: qXY, qYX, WaterFlux_XY, WaterFlux_YX,      &
                                              Volume_Z_New, Volume_Z_Old
        real   , dimension(:,:  ), pointer :: DYY_XX, DXX_YY
        integer, dimension(:,:,:), pointer :: ImposedNormalFacesUV,                      &
                                              ImposedTangentialFacesVU,                  &
                                              ComputeFaces3D_UV, ComputeFaces3D_VU

        integer, dimension(:,:  ), pointer :: BoundaryPoints

        integer                            :: di, dj
        !integer                           :: status

        !--------------------------------------------------------------------------

        !Begin - Shorten variables name

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        ImposedNormalFacesUV     => Me%External_Var%ImposedNormalFacesUV
        ImposedTangentialFacesVU => Me%External_Var%ImposedTangentialFacesVU
        DYY_XX                   => Me%External_Var%DYY_XX
        DXX_YY                   => Me%External_Var%DXX_YY
        BoundaryPoints           => Me%External_Var%BoundaryPoints
        qXY                      => Me%SubModel%qXY
        qYX                      => Me%SubModel%qYX

        Volume_Z_New             => Me%External_Var%Volume_Z_New
        Volume_Z_Old             => Me%External_Var%Volume_Z_Old

        ComputeFaces3D_UV        => Me%External_Var%ComputeFaces3D_UV
        ComputeFaces3D_VU        => Me%External_Var%ComputeFaces3D_VU

        WaterFlux_XY             => Me%WaterFluxes%XY
        WaterFlux_YX             => Me%WaterFluxes%YX

        !End - Shorten variables name

        !griflet: This call to a subroutine messes up the calling parallel zone.
        !call GetComputeTimeStep(Me%ObjTime, DT, STAT = status)
        !if (status /= SUCCESS_)                                                          &
        !    call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR01")

        !Bottom flux  - positive
        VertAdvectionSubModel = BottomFlux

cd1:    if (BoundaryPoints(i, j) == 1) then

            !Volume Variation - negative
            VertAdvectionSubModel = VertAdvectionSubModel - (Volume_Z_New(i, j, k) - Volume_Z_Old(i, j, k)) /        &
                      dble(DT)

            !Face West (Face Boundary) - positive
            VertAdvectionSubModel = VertAdvectionSubModel + dble(ComputeFaces3D_UV (i, j, k)) * WaterFlux_XY(i, j, k)

            !Face East - negative
            VertAdvectionSubModel = VertAdvectionSubModel - dble(ImposedNormalFacesUV (i + di , j + dj, k))     *    &
                        qXY(i + di , j + dj, k) * dble(DYY_XX(i + di , j + dj))

            !Face South - positive
            if (ImposedTangentialFacesVU (i , j , k) == 1 .and.                          &
                ComputeFaces3D_VU        (i , j , k) == 1)                               &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR02")

            VertAdvectionSubModel = VertAdvectionSubModel + dble(ImposedTangentialFacesVU (i , j , k))          *    &
                        qYX(i, j, k) * dble(DXX_YY(i , j))                               &
                      + dble(ComputeFaces3D_VU (i, j, k))                           *    &
                        WaterFlux_YX(i, j, k)


            !Face North  - negative
            if (ImposedTangentialFacesVU (i + dj , j + di, k) == 1 .and.                 &
                ComputeFaces3D_VU        (i + dj , j + di, k) == 1)                      &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR03")

            VertAdvectionSubModel = VertAdvectionSubModel - dble(ImposedTangentialFacesVU (i + dj , j + di, k)) *    &
                        qYX(i + dj , j + di, k) * dble(DXX_YY(i + dj , j + di))          &
                      - dble(ComputeFaces3D_VU (i + dj , j + di, k))                *    &
                        WaterFlux_YX(i + dj , j + di, k)


        else if (BoundaryPoints(i - di , j - dj) == 1) then cd1

            !Volume Variation - negative
            VertAdvectionSubModel = VertAdvectionSubModel - (Volume_Z_New(i - di , j - dj, k) &
                                    - Volume_Z_Old(i - di , j - dj, k)) / dble(DT)


            !Face West - positive
            VertAdvectionSubModel = VertAdvectionSubModel + dble(ImposedNormalFacesUV (i - di , j - dj, k))     *    &
                        qXY(i - di , j - dj, k) * dble(DYY_XX(i - di , j - dj))


            !Face East (Face Boundary) - negative
            VertAdvectionSubModel = VertAdvectionSubModel - dble(ComputeFaces3D_UV (i, j, k)) * WaterFlux_XY(i, j, k)



            !Face South - positive
            if (ImposedTangentialFacesVU (i - di, j - dj, k) == 1 .and.                  &
                ComputeFaces3D_VU        (i - di, j - dj, k) == 1)                       &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR04")

            VertAdvectionSubModel = VertAdvectionSubModel + dble(ImposedTangentialFacesVU (i - di, j - dj, k))  *    &
                        qYX(i - di, j - dj, k) * dble(DXX_YY(i - di, j - dj))            &
                      + dble(ComputeFaces3D_VU (i - di, j - dj, k))                 *    &
                        WaterFlux_YX(i - di, j - dj, k)


            !Face North  - negative
            if (ImposedTangentialFacesVU (i - di + dj, j - dj + di, k) == 1 .and.        &
                ComputeFaces3D_VU        (i - di + dj, j - dj + di, k) == 1)             &
                call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR05")

            VertAdvectionSubModel = VertAdvectionSubModel - dble(ImposedTangentialFacesVU (i - di + dj, j - dj + di, k)) *  &
                        qYX(i - di + dj, j - dj + di, k) * dble(DXX_YY(i - di + dj, j - dj + di)) &
                      - dble(ComputeFaces3D_VU (i - di + dj, j - dj + di, k))         *  &
                        WaterFlux_YX(i - di + dj, j - dj + di, k)


        else  cd1


            call SetError (FATAL_, INTERNAL_, "VertAdvectionSubModel - Hydrodynamic - ERR06")


        endif cd1


        !Nullify auxiliar pointers
        nullify (ImposedNormalFacesUV    )
        nullify (ImposedTangentialFacesVU)

        nullify (ComputeFaces3D_UV       )
        nullify (ComputeFaces3D_VU       )

        nullify (DYY_XX                  )
        nullify (DXX_YY                  )

        nullify (qXY                     )
        nullify (qYX                     )
        nullify (WaterFlux_XY            )
        nullify (WaterFlux_YX            )

        nullify (Volume_Z_New)
        nullify (Volume_Z_Old)

    end function VertAdvectionSubModel

   !End ----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the vertical diffusion and is able to do the                !
    !  calculation explicit or implicit                                                    !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D                                      !
    ! Author: Paulo Chambel (99/6)                                                         !
    ! Modifications: 2001 Manuel Ruiz Villarreal,
    !                limitation to maximum bottom viscosity   !                                                  !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Velocity_VerticalDiffusion


        !Variables Categories
        ! 3DGeometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! GridGeomtry: DZX_ZY (U or V Control volume length), DUX_VY (distance between faces), DYY_XX (U or V Control Volume width)
        ! Flow       : Velocity_UV_Old (U or V velocity), VerticalViscosity (Vertical turbulent Viscosity)
        ! Time       : DT_Velocity (velocity time step)
        ! Mapping    : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        !
        ! Options    : UpStream_CenterDif (1 - UpStream and 0 - Centered differences),
        !   ImplicitVertAdvection (1 - implict, 0 - explicit)
        !
        ! Direction  : Direction (DirectionX_=1,DirectionY_=2)
        ! Dimension  : ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction:
         !Volume_UV, Area_UV, Velocity_UV_Old, DZX_ZY, DUX_VY, DYY_DXX,
         !VerticalViscosity, ComputeFaces3D_UV, Direction, KFloor_UV

        !Variables independent from the direction. In the future this arguments
        !will enter the subroutine associated with modules:
         !WaterFlux_Z, DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,
         !DT_Velocity, ImplicitVertDiffusion,
         !ILB, IUB, JLB, JUB, KUB


        !X direction
        ! call VerticalDiffusion(Volume_U, Area_U, DZX, DUX, DYY,      &
        !                        VerticalViscosity, Velocity_U,        &
        !                        CoveredFacesX, DirectionX_, KFloorU,   &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,      &
        !                        DT_Velocity, ImplicitVertDiffusion,       &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Y direction
        ! call VerticalDiffusion(Volume_V, Area_V, DZY, DVY, DXX,      &
        !                        VerticalViscosity, Velocity_V,        &
        !                        CoveredFacesY, DirectionY_, KFloorV,   &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,      &
        !                        DT_Velocity, ImplicitVertDiffusion,       &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, ECoef_3D

        real,    dimension(:,:,:), pointer :: DCoef_3D, FCoef_3D, TiCoef_3D,             &
                                              Velocity_UV_Old,                           & !DUZ_VZ                 &
                                              Vertical_Viscosity, DUZ_VZ

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DZX_ZY, WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity, ImplicitVertDiffusion

        real                               :: BottomFaceViscosity,TopFaceViscosity, DT_Z, &
                                              ExplicitVerticalDiffusion, WaterColumn2D

        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        real(8), allocatable, dimension(:) :: BottomCell_BottomFace, CenterCell_BottomFace, &
                                              CenterCell_TopFace, TopCell_TopFace

        real                               :: DUZ_Top, DUZ_Bottom, Visc_bottom_max,      &
                                              BottomViscCoef

        integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT
        ImplicitVertDiffusion=  Me%ComputeOptions%ImplicitVertDiffusion
        BottomViscCoef       =  Me%ComputeOptions%BottomViscCoef
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F
        TiCoef_3D            => Me%Coef%D3%Ti

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old

        Volume_UV            => Me%External_Var%Volume_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY

        WaterColumnUV        => Me%External_Var%WaterColumnUV

        Vertical_Viscosity   => Me%External_Var%Vertical_Viscosity

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name

        !T allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB), &
        !T         CenterCell_TopFace(KUB), TopCell_TopFace(KUB))

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_VerticalDiffusion")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,iSouth,jWest,Kbottom,TopFaceViscosity,DUZ_Top) &
        !$OMP PRIVATE(DT_Z,BottomFaceViscosity,DUZ_Bottom) &
        !$OMP PRIVATE(visc_bottom_max,ExplicitVerticalDiffusion) &
        !$OMP PRIVATE(BottomCell_BottomFace,CenterCell_BottomFace) &
        !$OMP PRIVATE(TopCell_TopFace,CenterCell_TopFace)

        allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB))
        allocate(CenterCell_TopFace(KUB),    TopCell_TopFace(KUB))

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth = i-di
            jWest  = j-dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB)==Covered .and.                              &
                WaterColumnUV(i,j) > WaterColumn2D) then

                Kbottom          = KFloor_UV(i, j)

                TopFaceViscosity = FillValueReal
                DUZ_Top          = FillValueReal


    dok1:       do k = Kbottom, KUB

                    !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
                    !is the only way of cancel the vertical diffusion and advection terms
                    !when the water flow is considered implicit in the water level calculation.
                    !However, this relation is not true when AreaUV is computed using the
                    !minimum thickness metodology.
                    !See ModuleGeometry
                    ![s/m]                   =   [s] /  [m]
                    DT_Z                     =   DT_Velocity / DUZ_VZ(i, j, k)

                    BottomFaceViscosity      =   TopFaceViscosity

                    !Horizontal viscosity faces interpolation
                    TopFaceViscosity         =   (Vertical_Viscosity(i     , j    , k+1) * DUX_VY(iSouth, jWest)  + &
                                                  Vertical_Viscosity(iSouth, jWest, k+1) * DUX_VY(i     , j    )) / &
                                                 (DUX_VY(iSouth, jWest) + DUX_VY(i, j))

                    !Distance in vertical between adjacent velocity compute points.
                    DUZ_Bottom               =   DUZ_Top
                    DUZ_Top                  =  (DUZ_VZ(i, j, k) + DUZ_VZ(i, j, k + 1)) / 2.

                    !Limitation of bottom viscosity due to the semi-implicit discretization of bottom friction. MRV
                    if (Me%ComputeOptions%BottomVisc_LIM .and. k == kbottom) then

                        ![m^2/s]             =  [] * [m] * [m] / [s]
                        visc_bottom_max      =  BottomViscCoef * DUZ_VZ(i, j, k) * DUZ_Top / 2./ DT_Velocity
                        TopFaceViscosity     =  min (TopFaceViscosity , visc_bottom_max)

                    end if

                   ![ ]                      =   [s/m]* [m^2/s] / [m]
                    BottomCell_BottomFace(k) = - DT_Z * BottomFaceViscosity / DUZ_Bottom

                   ![ ]                     =    [s/m]* [m^2/s] / [m]
                    TopCell_TopFace(k)       = - DT_Z * TopFaceViscosity    / DUZ_Top


                    CenterCell_BottomFace(k) = - BottomCell_BottomFace(k)

                    CenterCell_TopFace(k)    = - TopCell_TopFace(k)

                enddo dok1

                !The bottom boundary conditions are imposed in another subroutine
                !see VelVerticalDiffusionBoundaries
                BottomCell_BottomFace(kbottom) = 0.

                CenterCell_BottomFace(kbottom) = 0.

                !The surface boundary conditions are imposed in another subroutine
                !see VelVerticalDiffusionBoundaries
                CenterCell_TopFace(KUB)        = 0.

                TopCell_TopFace(KUB)           = 0.

    dok2:       do k = kbottom, KUB

                   DCoef_3D (i, j, k)  = DCoef_3D (i, j, k) + ImplicitVertDiffusion * BottomCell_BottomFace(k)

                   ECoef_3D (i, j, k)  = ECoef_3D (i, j, k) + ImplicitVertDiffusion *  &
                                        (CenterCell_BottomFace(k) + CenterCell_TopFace(k))

                   FCoef_3D (i, j, k)  = FCoef_3D (i, j, k) + ImplicitVertDiffusion * TopCell_TopFace(k)

                   ExplicitVerticalDiffusion = (BottomCell_BottomFace(k) * Velocity_UV_Old(i, j, k-1)   +  &
                                               (CenterCell_BottomFace(k) +                             &
                                                CenterCell_TopFace(k))   * Velocity_UV_Old(i, j, k)     +  &
                                                TopCell_TopFace(k)       * Velocity_UV_Old(i, j, k+1))

                   TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) + (ImplicitVertDiffusion - 1) * ExplicitVerticalDiffusion

                enddo dok2

            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO

        deallocate(BottomCell_BottomFace, CenterCell_BottomFace)
        deallocate(CenterCell_TopFace,    TopCell_TopFace      )

        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_VerticalDiffusion")
        endif

        !Nullify auxiliar pointers
        nullify(DCoef_3D)
        nullify(ECoef_3D)
        nullify(FCoef_3D)
        nullify(TiCoef_3D)

        nullify(Velocity_UV_Old)

        nullify(Vertical_Viscosity)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)

        nullify(WaterColumnUV)

        nullify(Volume_UV)
        nullify(DUZ_VZ   )

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

    End Subroutine Velocity_VerticalDiffusion

    Subroutine Velocity_VerticalDiffusion2

        !Variables Categories
        ! 3DGeometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! GridGeomtry: DZX_ZY (U or V Control volume length), DUX_VY (distance between faces), DYY_XX (U or V Control Volume width)
        ! Flow       : Velocity_UV_Old (U or V velocity), VerticalViscosity (Vertical turbulent Viscosity)
        ! Time       : DT_Velocity (velocity time step)
        ! Mapping    : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV  (1 - covered faces, 0 - not covered faces)
        !
        !   ImplicitVertAdvection (1 - implict, 0 - explicit)
        !
        ! Direction  : Direction (DirectionX_=1,DirectionY_=2)
        ! Dimension  : ILB (i lower bound), IUB (i upper bound), JLB (j lower bound), JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction:
         !Volume_UV, Area_UV, Velocity_UV_Old, DZX_ZY, DUX_VY, DYY_DXX,
         !VerticalViscosity, ComputeFaces3D_UV, Direction, KFloor_UV

        !Variables independent from the direction. In the future this arguments
        !will enter the subroutine associated with modules:
         !WaterFlux_Z, DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,
         !DT_Velocity, ImplicitVertDiffusion,
         !ILB, IUB, JLB, JUB, KUB


        !X direction
        ! call VerticalDiffusion(Volume_U, Area_U, DZX, DUX, DYY,      &
        !                        VerticalViscosity, Velocity_U,        &
        !                        CoveredFacesX, DirectionX_, KFloorU,   &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,      &
        !                        DT_Velocity, ImplicitVertDiffusion,       &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Y direction
        ! call VerticalDiffusion(Volume_V, Area_V, DZY, DVY, DXX,      &
        !                        VerticalViscosity, Velocity_V,        &
        !                        CoveredFacesY, DirectionY_, KFloorV,   &
        !                        DCoef_3D, ECoef_3D, FCoef_3D, TiCoef_3D,      &
        !                        DT_Velocity, ImplicitVertDiffusion,       &
        !                        ILB, IUB, JLB, JUB, KUB)

        !Arguments------------------------------------------------------------
        !Local---------------------------------------------------------------------

        real                               :: ImplicitVertDiffusion
        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name
        ImplicitVertDiffusion =  Me%ComputeOptions%ImplicitVertDiffusion
        !End - Shorten variables name

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Velocity_VerticalDiffusion")
        endif

        if (ImplicitVertDiffusion == 1) then
            if (Me%Direction%di == 1) then
                call Velocity_VerticalImpDiffusion_Y (Me%External_Var%ComputeFaces3D_V, Me%External_Var%WaterColumnV, &
                                                      Me%External_Var%KFloor_V, Me%External_Var%Vertical_Viscosity,   &
                                                      Me%External_Var%DVZ, Me%External_Var%DVY, Me%Coef%D3%D,         &
                                                      Me%Coef%D3%E, Me%Coef%D3%F)
            else
                call Velocity_VerticalImpDiffusion_X (Me%External_Var%ComputeFaces3D_U, Me%External_Var%WaterColumnU, &
                                                      Me%External_Var%KFloor_U, Me%External_Var%Vertical_Viscosity,   &
                                                      Me%External_Var%DUZ, Me%External_Var%DUX, Me%Coef%D3%D,         &
                                                      Me%Coef%D3%E, Me%Coef%D3%F)
            endif
        else
            if (Me%Direction%di == 1) then
                call Velocity_VerticalExpDiffusion_Y (Me%External_Var%ComputeFaces3D_V, Me%External_Var%WaterColumnV, &
                                                      Me%External_Var%KFloor_V, Me%External_Var%Vertical_Viscosity,   &
                                                      Me%External_Var%DVZ, Me%External_Var%DVY,                       &
                                                      Me%Velocity%Horizontal%V%Old, Me%Coef%D3%Ti)
            else
                call Velocity_VerticalExpDiffusion_X (Me%External_Var%ComputeFaces3D_U, Me%External_Var%WaterColumnU, &
                                                      Me%External_Var%KFloor_U, Me%External_Var%Vertical_Viscosity,   &
                                                      Me%External_Var%DUZ, Me%External_Var%DUX,                       &
                                                      Me%Velocity%Horizontal%U%Old, Me%Coef%D3%Ti)
            endif
        endif

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Velocity_VerticalDiffusion")
        endif

    End Subroutine Velocity_VerticalDiffusion2

    !End-----------------------------------------------------------------------

    Subroutine Velocity_VerticalImpDiffusion_Y (ComputeFaces3D_V, WaterColumnV, KFloor_V, Vertical_Viscosity, &
        DVZ, DVY, DCoef_3D, ECoef_3D, FCoef_3D)

        !Arguments---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: ECoef_3D
        real,    dimension(:,:,:), pointer, intent(INOUT) :: DCoef_3D, FCoef_3D
        real,    dimension(:,:,:), pointer, intent(IN)    :: Vertical_Viscosity, DVZ
        real,    dimension(:,:  ), pointer, intent(IN)    :: DVY, WaterColumnV
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_V
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_V
        !Local ------------------------------------------------------------------------------
        real(8), allocatable, dimension(:)                :: BottomCell_BottomFace, CenterCell_BottomFace, &
                                                             CenterCell_TopFace, TopCell_TopFace
        real                                              :: DT_Velocity
        real                                              :: BottomFaceViscosity,TopFaceViscosity, DT_Z, WaterColumn2D
        integer                                           :: i, j, k, Kbottom, IUB, ILB, JUB, JLB, KUB, KLB, CHUNK
        real                                              :: DUZ_Top, DUZ_Bottom
        !Begin---------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity          =  Me%Velocity%DT
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because it is the only way of cancel the vertical
        !diffusion and advection terms when the water flow is considered implicit in the water level calculation.
        !However, this relation is not true when AreaUV is computed using the minimum thickness metodology.
        !See ModuleGeometry

        !This was in the first doK cycle... its result was erased right after, so I removed it:
        !!Limitation of bottom viscosity due to the semi-implicit discretization of bottom friction. MRV
        !if (Me%ComputeOptions%BottomVisc_LIM .and. k == kbottom) then
        !    ![m^2/s]             =  [] * [m] * [m] / [s]
        !    visc_bottom_max      =  BottomViscCoef * DUZ_VZ(i, j, k) * DUZ_Top / 2./ DT_Velocity
        !    TopFaceViscosity     =  min (TopFaceViscosity , visc_bottom_max)
        !end if
        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,TopFaceViscosity,DUZ_Top, DT_Z,BottomFaceViscosity,DUZ_Bottom) &
        !$OMP PRIVATE(BottomCell_BottomFace,CenterCell_BottomFace,TopCell_TopFace,CenterCell_TopFace)

        allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB))
        allocate(CenterCell_TopFace(KUB),    TopCell_TopFace(KUB))
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            if (ComputeFaces3D_V(i, j, KUB) == 1) then
                if (WaterColumnV(i,j) > WaterColumn2D) then

                    Kbottom          = KFloor_V(i, j)
                    TopFaceViscosity = FillValueReal
                    DUZ_Top          = FillValueReal

                    do k = Kbottom, KUB
                        ![s/m]                   =   [s] /  [m]
                        DT_Z                     =   DT_Velocity / DVZ(i, j, k)
                        BottomFaceViscosity      =   TopFaceViscosity

                        !Horizontal viscosity faces interpolation
                        TopFaceViscosity         =   (Vertical_Viscosity(i  , j, k+1) * DVY(i-1, j)  + &
                                                        Vertical_Viscosity(i-1, j, k+1) * DVY(i  , j)) / &
                                                        (DVY(i-1, j) + DVY(i, j))

                        !Distance in vertical between adjacent velocity compute points.
                        DUZ_Bottom               =   DUZ_Top
                        DUZ_Top                  =  (DVZ(i, j, k) + DVZ(i, j, k + 1)) / 2.

                        ![ ]                      =   [s/m]* [m^2/s] / [m]
                        BottomCell_BottomFace(k) = - DT_Z * BottomFaceViscosity / DUZ_Bottom
                        TopCell_TopFace(k)       = - DT_Z * TopFaceViscosity    / DUZ_Top
                        CenterCell_BottomFace(k) = - BottomCell_BottomFace(k)
                        CenterCell_TopFace(k)    = - TopCell_TopFace(k)
                    enddo
                        !The surface and bottom boundary conditions are imposed in VelVerticalDiffusionBoundaries
                        BottomCell_BottomFace(kbottom) = 0.
                        CenterCell_BottomFace(kbottom) = 0.
                        CenterCell_TopFace(KUB)        = 0.
                        TopCell_TopFace(KUB)           = 0.

                    do k = Kbottom, KUB
                        DCoef_3D(i,j,k) = DCoef_3D(i,j,k) + BottomCell_BottomFace(k)
                        ECoef_3D(i,j,k) = ECoef_3D(i,j,k) + (CenterCell_BottomFace(k) + CenterCell_TopFace(k))
                        FCoef_3D(i,j,k) = FCoef_3D(i,j,k) + TopCell_TopFace(k)
                    enddo
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        deallocate(BottomCell_BottomFace, CenterCell_BottomFace)
        deallocate(CenterCell_TopFace,    TopCell_TopFace      )
        !$OMP END PARALLEL

    end subroutine Velocity_VerticalImpDiffusion_Y

    !End ------------------------------------------------------------------------

    Subroutine Velocity_VerticalExpDiffusion_Y (ComputeFaces3D_V, WaterColumnV, KFloor_V, Vertical_Viscosity, &
        DVZ, DVY, Velocity_V_Old, TiCoef_3D)

        !Arguments---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(INOUT) :: TiCoef_3D
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_V_Old, Vertical_Viscosity, DVZ
        real,    dimension(:,:  ), pointer, intent(IN)    :: DVY, WaterColumnV
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_V
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_V
        !Local ------------------------------------------------------------------------------
        real(8), allocatable, dimension(:)                :: BottomCell_BottomFace, CenterCell_BottomFace, &
                                                             CenterCell_TopFace, TopCell_TopFace
        real                                              :: BottomFaceViscosity,TopFaceViscosity, DT_Z, &
                                                             ExplicitVerticalDiffusion, WaterColumn2D, DT_Velocity
        integer                                           :: i, j, k, Kbottom, IUB, ILB, JUB, JLB, KUB, KLB, CHUNK
        real                                              :: DUZ_Top, DUZ_Bottom
        !Begin---------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity          =  Me%Velocity%DT
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,TopFaceViscosity,DUZ_Top,DT_Z,BottomFaceViscosity,DUZ_Bottom) &
        !$OMP PRIVATE(ExplicitVerticalDiffusion) &
        !$OMP PRIVATE(BottomCell_BottomFace,CenterCell_BottomFace,TopCell_TopFace,CenterCell_TopFace)

        allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB))
        allocate(CenterCell_TopFace(KUB),    TopCell_TopFace(KUB))
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            if (ComputeFaces3D_V(i, j, KUB) == 1) then
                if (WaterColumnV(i,j) > WaterColumn2D) then

                    Kbottom          = KFloor_V(i, j)
                    TopFaceViscosity = FillValueReal
                    DUZ_Top          = FillValueReal

                    do k = Kbottom, KUB
                        ![s/m]                   =   [s] /  [m]
                        DT_Z                     =   DT_Velocity / DVZ(i, j, k)
                        BottomFaceViscosity      =   TopFaceViscosity

                        !Horizontal viscosity faces interpolation
                        TopFaceViscosity         =   (Vertical_Viscosity(i  , j, k+1) * DVY(i-1, j)  + &
                                                      Vertical_Viscosity(i-1, j, k+1) * DVY(i  , j)) / &
                                                      (DVY(i-1, j) + DVY(i, j))

                        !Distance in vertical between adjacent velocity compute points.
                        DUZ_Bottom               =   DUZ_Top
                        DUZ_Top                  =  (DVZ(i, j, k) + DVZ(i, j, k + 1)) / 2.

                        ![ ]                      =   [s/m]* [m^2/s] / [m]
                        BottomCell_BottomFace(k) = - DT_Z * BottomFaceViscosity / DUZ_Bottom
                        TopCell_TopFace(k)       = - DT_Z * TopFaceViscosity    / DUZ_Top
                        CenterCell_BottomFace(k) = - BottomCell_BottomFace(k)
                        CenterCell_TopFace(k)    = - TopCell_TopFace(k)
                    enddo
                        !The surface and bottom boundary conditions are imposed in VelVerticalDiffusionBoundaries
                        BottomCell_BottomFace(kbottom) = 0.
                        CenterCell_BottomFace(kbottom) = 0.
                        CenterCell_TopFace(KUB)        = 0.
                        TopCell_TopFace(KUB)           = 0.
                    do k = Kbottom, KUB
                        ExplicitVerticalDiffusion = (BottomCell_BottomFace(k) * Velocity_V_Old(i, j, k-1)   +  &
                                                    (CenterCell_BottomFace(k) +                             &
                                                    CenterCell_TopFace(k))   * Velocity_V_Old(i, j, k)     +  &
                                                    TopCell_TopFace(k)       * Velocity_V_Old(i, j, k+1))

                        TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) - ExplicitVerticalDiffusion
                    enddo
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        deallocate(BottomCell_BottomFace, CenterCell_BottomFace)
        deallocate(CenterCell_TopFace,    TopCell_TopFace      )
        !$OMP END PARALLEL

    end subroutine Velocity_VerticalExpDiffusion_Y

    !End -------------------------------------------------------------------------------------------------------

    Subroutine Velocity_VerticalImpDiffusion_X(ComputeFaces3D_U, WaterColumnU, KFloor_U, Vertical_Viscosity, &
        DUZ, DUX, DCoef_3D, ECoef_3D, FCoef_3D)

        !Arguments---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer, intent(INOUT) :: ECoef_3D
        real,    dimension(:,:,:), pointer, intent(INOUT) :: DCoef_3D, FCoef_3D
        real,    dimension(:,:,:), pointer, intent(IN)    :: Vertical_Viscosity, DUZ
        real,    dimension(:,:  ), pointer, intent(IN)    :: DUX, WaterColumnU
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_U
        !Local ------------------------------------------------------------------------------
        real(8), allocatable, dimension(:)                :: BottomCell_BottomFace, CenterCell_BottomFace, &
                                                             CenterCell_TopFace, TopCell_TopFace
        real                                              :: DT_Velocity
        real                                              :: BottomFaceViscosity,TopFaceViscosity, DT_Z, WaterColumn2D
        integer                                           :: i, j, k, Kbottom, IUB, ILB, JUB, JLB, KUB, KLB, CHUNK
        real                                              :: DUZ_Top, DUZ_Bottom
        !Begin---------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity          =  Me%Velocity%DT
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,TopFaceViscosity,DUZ_Top, DT_Z,BottomFaceViscosity,DUZ_Bottom) &
        !$OMP PRIVATE(BottomCell_BottomFace,CenterCell_BottomFace,TopCell_TopFace,CenterCell_TopFace)

        allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB))
        allocate(CenterCell_TopFace(KUB),    TopCell_TopFace(KUB))
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            if (ComputeFaces3D_U(i, j, KUB) == 1) then
                if (WaterColumnU(i,j) > WaterColumn2D) then

                    Kbottom          = KFloor_U(i, j)
                    TopFaceViscosity = FillValueReal
                    DUZ_Top          = FillValueReal

                    do k = Kbottom, KUB
                        ![s/m]                   =   [s] /  [m]
                        DT_Z                     =   DT_Velocity / DUZ(i, j, k)
                        BottomFaceViscosity      =   TopFaceViscosity

                        !Horizontal viscosity faces interpolation
                        TopFaceViscosity         =   (Vertical_Viscosity(i  , j, k+1) * DUX(i, j-1)  + &
                                                        Vertical_Viscosity(i, j-1, k+1) * DUX(i  , j)) / &
                                                        (DUX(i, j-1) + DUX(i, j))

                        !Distance in vertical between adjacent velocity compute points.
                        DUZ_Bottom               =   DUZ_Top
                        DUZ_Top                  =  (DUZ(i, j, k) + DUZ(i, j, k + 1)) / 2.

                        ![ ]                      =   [s/m]* [m^2/s] / [m]
                        BottomCell_BottomFace(k) = - DT_Z * BottomFaceViscosity / DUZ_Bottom
                        TopCell_TopFace(k)       = - DT_Z * TopFaceViscosity    / DUZ_Top
                        CenterCell_BottomFace(k) = - BottomCell_BottomFace(k)
                        CenterCell_TopFace(k)    = - TopCell_TopFace(k)
                    enddo
                        BottomCell_BottomFace(kbottom) = 0.
                        CenterCell_BottomFace(kbottom) = 0.
                        CenterCell_TopFace(KUB)        = 0.
                        TopCell_TopFace(KUB)           = 0.
                    do k = Kbottom, KUB
                        !The surface and bottom boundary conditions are imposed in VelVerticalDiffusionBoundaries
                        DCoef_3D(i,j,k) = DCoef_3D(i,j,k) + BottomCell_BottomFace(k)
                        ECoef_3D(i,j,k) = ECoef_3D(i,j,k) + (CenterCell_BottomFace(k) + CenterCell_TopFace(k))
                        FCoef_3D(i,j,k) = FCoef_3D(i,j,k) + TopCell_TopFace(k)
                    enddo
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        deallocate(BottomCell_BottomFace, CenterCell_BottomFace)
        deallocate(CenterCell_TopFace,    TopCell_TopFace      )
        !$OMP END PARALLEL

    end subroutine Velocity_VerticalImpDiffusion_X

    !End ------------------------------------------------------------------------

    Subroutine Velocity_VerticalExpDiffusion_X(ComputeFaces3D_U, WaterColumnU, KFloor_U, Vertical_Viscosity, &
        DUZ, DUX, Velocity_U_Old, TiCoef_3D)
        !Arguments---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer, intent(INOUT) :: TiCoef_3D
        real,    dimension(:,:,:), pointer, intent(IN)    :: Velocity_U_Old, Vertical_Viscosity, DUZ
        real,    dimension(:,:  ), pointer, intent(IN)    :: DUX, WaterColumnU
        integer, dimension(:,:,:), pointer, intent(IN)    :: ComputeFaces3D_U
        integer, dimension(:,:),   pointer, intent(IN)    :: KFloor_U
        !Local ------------------------------------------------------------------------------
        real(8), allocatable, dimension(:)                :: BottomCell_BottomFace, CenterCell_BottomFace, &
                                                             CenterCell_TopFace, TopCell_TopFace
        real                                              :: BottomFaceViscosity,TopFaceViscosity, DT_Z, &
                                                             ExplicitVerticalDiffusion, WaterColumn2D, DT_Velocity
        integer                                           :: i, j, k, Kbottom, IUB, ILB, JUB, JLB, KUB, KLB, CHUNK
        real                                              :: DUZ_Top, DUZ_Bottom
        !Begin---------------------------------------------------------------------
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity          =  Me%Velocity%DT
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,k,Kbottom,TopFaceViscosity,DUZ_Top) &
        !$OMP PRIVATE(DT_Z,BottomFaceViscosity,DUZ_Bottom,ExplicitVerticalDiffusion) &
        !$OMP PRIVATE(BottomCell_BottomFace,CenterCell_BottomFace,TopCell_TopFace,CenterCell_TopFace)

        allocate(BottomCell_BottomFace(KUB), CenterCell_BottomFace(KUB))
        allocate(CenterCell_TopFace(KUB),    TopCell_TopFace(KUB))
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j=JLB, JUB
        do i=ILB, IUB
            if (ComputeFaces3D_U(i, j, KUB) == 1) then
                if (WaterColumnU(i,j) > WaterColumn2D) then

                    Kbottom          = KFloor_U(i, j)
                    TopFaceViscosity = FillValueReal
                    DUZ_Top          = FillValueReal

                    do k = Kbottom, KUB
                        ![s/m]                   =   [s] /  [m]
                        DT_Z                     =   DT_Velocity / DUZ(i, j, k)
                        BottomFaceViscosity      =   TopFaceViscosity

                        !Horizontal viscosity faces interpolation
                        TopFaceViscosity         =   (Vertical_Viscosity(i  , j, k+1) * DUX(i, j-1)  + &
                                                      Vertical_Viscosity(i, j-1, k+1) * DUX(i  , j)) / &
                                                      (DUX(i, j-1) + DUX(i, j))

                        !Distance in vertical between adjacent velocity compute points.
                        DUZ_Bottom               =   DUZ_Top
                        DUZ_Top                  =  (DUZ(i, j, k) + DUZ(i, j, k + 1)) / 2.

                        ![ ]                      =   [s/m]* [m^2/s] / [m]
                        BottomCell_BottomFace(k) = - DT_Z * BottomFaceViscosity / DUZ_Bottom
                        TopCell_TopFace(k)       = - DT_Z * TopFaceViscosity    / DUZ_Top
                        CenterCell_BottomFace(k) = - BottomCell_BottomFace(k)
                        CenterCell_TopFace(k)    = - TopCell_TopFace(k)
                    enddo
                        !The surface and bottom boundary conditions are imposed in VelVerticalDiffusionBoundaries
                        BottomCell_BottomFace(kbottom) = 0.
                        CenterCell_BottomFace(kbottom) = 0.
                        CenterCell_TopFace(KUB)        = 0.
                        TopCell_TopFace(KUB)           = 0.

                    do k = Kbottom, KUB
                        ExplicitVerticalDiffusion = (BottomCell_BottomFace(k) * Velocity_U_Old(i, j, k-1)   +  &
                                                    (CenterCell_BottomFace(k) +                             &
                                                    CenterCell_TopFace(k))   * Velocity_U_Old(i, j, k)     +  &
                                                    TopCell_TopFace(k)       * Velocity_U_Old(i, j, k+1))

                        TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) - ExplicitVerticalDiffusion
                    enddo
                endif
            endif
        enddo
        enddo
        !$OMP END DO
        deallocate(BottomCell_BottomFace, CenterCell_BottomFace)
        deallocate(CenterCell_TopFace,    TopCell_TopFace      )
        !$OMP END PARALLEL

    end subroutine Velocity_VerticalExpDiffusion_X

    Subroutine Velocity_WaveStress


    !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV
        real,    dimension(:,:,:), pointer :: TiCoef_3D, Density, DUZ_VZ

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DZX_ZY, TauWaves_UV,       &
                                              WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity

        real,    dimension(:,:  ), pointer :: AuxTauWaves_UV
        real                               :: Aux_2D, TauFace, FaceDensity

        real                               :: SmoothCoef, RunPeriod

        integer                            :: di, dj, i, j, k, Kbottom, iSouth, jWest

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT

        TiCoef_3D            => Me%Coef%D3%Ti

        Volume_UV            => Me%External_Var%Volume_UV

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DZX_ZY               => Me%External_Var%DZX_ZY

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        Density              => Me%External_Var%Density

        TauWaves_UV          => Me%External_Var%TauWaves_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        !End - Shorten variables name

        SmoothCoef = 1.

        if (Me%ComputeOptions%AtmosphereRAMP) then

            RunPeriod = Me%CurrentTime - Me%BeginTime

            if (RunPeriod < Me%ComputeOptions%AtmospherePeriod) then

                SmoothCoef = Me%ComputeOptions%AtmosphereCoef

            endif

        endif

        if (Me%WaveStress%Dumping) then

            allocate(AuxTauWaves_UV(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB))

            AuxTauWaves_UV(:,:) = TauWaves_UV(:,:)

            call DumpingWaveStress(AuxTauWaves_UV)

        else
            AuxTauWaves_UV => TauWaves_UV
        endif

    doi: do j=JLB, JUB
    doj: do i=ILB, IUB

            iSouth = i-di
            jWest  = j-dj

    cd1:    if (ComputeFaces3D_UV(i, j, KUB)==Covered) then

                Kbottom          = KFloor_UV(i, j)

                TauFace          = Face_Interpolation(AuxTauWaves_UV(I,J), AuxTauWaves_UV(iSouth, jWest), &
                                              DUX_VY(I, J), DUX_VY(iSouth, jWest))

                ![M*m/s]   [] * [s] * [m] * [m] * [M*m/s^2/m^2]
                Aux_2D  =  SmoothCoef * DT_Velocity * DZX_ZY(iSouth, jWest) * DYY_XX(I, J) * TauFace

    dok1:       do k = Kbottom, KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        FaceDensity  = Face_Interpolation(Density(I, J, k),             &
                                                          Density(iSouth, jWest, k),    &
                                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))
                    else

                        FaceDensity  = SigmaDensityReference

                    endif

                    ![m/s]                                 [M*m/s] / [m^3] / [M/m^3]
                    TiCoef_3D(i,j,k)  = TiCoef_3D(i,j,k) + Aux_2D / Volume_UV(i, j, k) / FaceDensity &
                                                         * DUZ_VZ(i, j, k) / WaterColumnUV(i, j)

                enddo dok1

            endif cd1

        enddo doj
        enddo doi


        if (Me%WaveStress%Dumping) then

            deallocate(AuxTauWaves_UV)

        endif

        nullify(AuxTauWaves_UV)


        !Nullify auxiliar pointers
        nullify(TiCoef_3D)


        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)

        nullify(Volume_UV)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

        nullify(TauWaves_UV, Density)
        nullify(DUZ_VZ, WaterColumnUV)

    End Subroutine Velocity_WaveStress

        !End-----------------------------------------------------------------------

! Modified by Matthias DELPEY - 29/06/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 27/07/2011 - 01/08/2011 - 18/08/2011 - 09/09/2011 - 15/09/2011

    Subroutine Velocity_WaveForces3D


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        real,    dimension(:,:,:), pointer :: TiCoef_3D
        real,    dimension(:,:,:), pointer :: Wave3DExplicit_Acceleration

        real                               :: DT_Velocity

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV

        integer, dimension(:,:  ), pointer :: KFloor_UV

        integer                            :: I, J, K, Kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        DT_Velocity          =  Me%Velocity%DT

        TiCoef_3D            => Me%Coef%D3%Ti

        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

        !End - Shorten variables name


        do j=JLB, JUB
        do i=ILB, IUB

            Kbottom          = KFloor_UV(i, j)

            if (ComputeFaces3D_UV(i, j, KUB)==Covered) then

                do k = Kbottom, KUB

                    ! [m/s]          = [m/s] + [s] * [m/s^2]
                    TiCoef_3D(i,j,k) = TiCoef_3D(i,j,k) + DT_Velocity * Wave3DExplicit_Acceleration(i,j,k)

                enddo

            endif

        enddo
        enddo

        !Nullify auxiliar pointers
        nullify(TiCoef_3D)

        nullify(Wave3DExplicit_Acceleration)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

    End Subroutine Velocity_WaveForces3D

        !End-----------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !  This subroutine compute the vertical diffusion surface and bottom boundaries.       !
    !  Compute always the wind effect explicit                                             !
    !  the bottom friction effect implicit can be explicit or implicit (advised)           !
    ! Input : Flow, Geometry, Mapping                                                      !
    ! OutPut: ECoef_3D,  TiCoef_3D                                                             !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine VelVerticalDiffusionBoundaries


        !Variables Categories
        ! 3DGeometry : Volume_UV, Area_UV (Control Volume and Area for the U faces or V faces)
        ! GridGeomtry: DZX_ZY (U or V Control volume length), DUX_VY (distance between faces), DYY_XX (U or V Control Volume width)
        ! Flow       : Velocity_UV_Old (U or V velocity), VerticalViscosity (Vertical turbulent Viscosity)
        ! Time       : DT_Velocity (velocity time step)
        !
        ! Mapping    : KFloor_UV (first water layer for a i, j face), ComputeFaces3D_UV
        !   (1 - covered faces, 0 - not covered faces)
        !
        ! Options    : UpStream_CenterDif (1 - UpStream and 0 - Centered differences),
        !              ImplicitVertAdvection(1 - implict, 0 - explicit)
        !
        ! Direction  : Direction (DirectionX_=1,DirectionY_=2)
        !
        ! Dimension  : ILB (i lower bound), IUB (i upper bound), JLB (j lower bound),
        !              JUB (j upper bound), KUB (k upper bound)

        !Variables dependent from the direction:
         !Volume_UV, Area_UV, Velocity_UV_Old, DZX_ZY, DUX_VY, DYY_DXX,
         !ComputeFaces3D_UV, Direction, KFloor_UV


              !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, ECoef_3D

        real,    dimension(:,:,:), pointer :: DCoef_3D, FCoef_3D, TiCoef_3D,             &
                                              Velocity_UV_Old, Velocity_VU_New, Density, &
                                              DUZ_VZ

        real,    dimension(:,:  ), pointer :: DUX_VY, DYY_XX, DXX_YY, DZX_ZY, ChezyVelUV,&
                                              TauWind_UV, WaterColumnUV

        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV

        real                               :: DT_Velocity, ImplicitVertDiffusion

        real                               :: CellFace_BottomFace, CellFace_TopFace, SmoothCoef, RunPeriod

        real                               :: DT_Z, TauFace, FaceDensity, Coef, WaterColumn2D
        real(8)                            :: TotalVolume

        integer                            :: di, dj, i, j, Kbottom, iSouth, jWest, i_North, j_East, k

        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB

        integer                            :: CHUNK

! Modified by Matthias DELPEY - 08/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        real,    dimension(:,:  ), pointer :: Taw_UV, Two_UV
        real                               :: Taw_Face, Two_Face
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT

        ImplicitVertDiffusion=  Me%ComputeOptions%ImplicitVertDiffusion

        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        DCoef_3D             => Me%Coef%D3%D
        ECoef_3D             => Me%Coef%D3%E
        FCoef_3D             => Me%Coef%D3%F
        TiCoef_3D            => Me%Coef%D3%Ti

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        Volume_UV            => Me%External_Var%Volume_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        DUX_VY               => Me%External_Var%DUX_VY
        DYY_XX               => Me%External_Var%DYY_XX
        DXX_YY               => Me%External_Var%DXX_YY
        DZX_ZY               => Me%External_Var%DZX_ZY

        ChezyVelUV           => Me%External_Var%ChezyVelUV
        TauWind_UV           => Me%External_Var%TauWind_UV

        Density              => Me%External_Var%Density

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        KFloor_UV            => Me%External_Var%KFloor_UV

! Modified by Matthias DELPEY - 08/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        Taw_UV                => Me%External_Var%AtmToWaveMomentum_UV
        Two_UV                => Me%External_Var%WaveToOceanMomentum_UV
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !End - Shorten variables name

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "VelVerticalDiffusionBoundaries")
        endif

        !$OMP PARALLEL PRIVATE(i,j,iSouth,jWest,i_North,j_East,Kbottom,CellFace_BottomFace) &
        !$OMP PRIVATE(FaceDensity,SmoothCoef,RunPeriod,TauFace,DT_Z,CellFace_TopFace) &
        !$OMP PRIVATE(TotalVolume,Coef,k)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
doi:     do j=JLB, JUB
doj:     do i=ILB, IUB

            iSouth = i - di
            jWest  = j - dj
            ! This values (i_North and j_east) can only be use to compute the velocity modulus in a face
            i_North = i + dj
            j_East  = j + di


cd1:        if (ComputeFaces3D_UV(i, j, KUB)==Covered) then


                !Bottom boundary condition (bottom friction)

                Kbottom = KFloor_UV(i, j)

                ![s/m^3]                  = [s] / [m^3] * [m] * [m]
!                DT_Z                      = DT_Velocity / Volume_UV(i, j, Kbottom)       &
!                                            * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

!                VelMod_UV                 = Face_Velocity_Modulus(                     &
!                                            Velocity_VU_New(I_North, jWest, kbottom), &
!                                            Velocity_VU_New(I_North, J_East, kbottom), &
!                                            Velocity_VU_New(iSouth, jWest, kbottom), &
!                                            Velocity_VU_New(iSouth, J_East, kbottom), &
!                                            DXX_YY(I_North, jWest),               &
!                                            DXX_YY(I_North, J_East),               &
!                                            DXX_YY(iSouth, jWest),               &
!                                            DXX_YY(iSouth, J_East),               &
!                                            Velocity_UV_Old(I,J,kbottom))

!                Face_Chezy                = (Chezy(iSouth, jWest) * DUX_VY(I, J)   +  &
!                                             Chezy (I, J) * DUX_VY(iSouth, jWest)) /  &
!                                            (DUX_VY(iSouth, jWest) + DUX_VY(I, J))

!                Face_Chezy              = ChezyVelUV (I, J)


                ![ ]                      = [s/m] * [ ] * [m/s]
!                CellFace_BottomFace     = DT_Z  * Face_Chezy * VelMod_UV

                CellFace_BottomFace     = ChezyVelUV (I, J)

                ![m/s ]                   =          [ ]          *     [m/s]
                !ExplicitVerticalDiffusion = CellFace_BottomFace * Velocity_UV_Old(i, j, Kbottom)

                !TiCoef_3D(i, j, Kbottom)    = TiCoef_3D(i, j, Kbottom) + (ImplicitVertDiffusion - 1) * &
                !                            ExplicitVerticalDiffusion

                !Surface boundary condition (Wind)

                if (Me%ComputeOptions%Wind /= NoWind_) then

                    if (Me%ComputeOptions%LocalDensity) then
                        !!!! $OMP CRITICAL (VVDB1_FNC01)
                        FaceDensity  = Face_Interpolation(Density(I, J, KUB),                &
                                                          Density(iSouth, jWest, KUB),     &
                                                          DUX_VY(I, J), DUX_VY(iSouth, jWest))
                        !!!! $OMP END CRITICAL (VVDB1_FNC01)
                    else

                        FaceDensity  = SigmaDensityReference

                    endif


                    SmoothCoef = 1.

                    if (Me%ComputeOptions%AtmosphereRAMP) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%AtmospherePeriod) then

                            SmoothCoef = Me%ComputeOptions%AtmosphereCoef

                        endif

                    elseif (Me%ComputeOptions%Wind == InitialSmoothWind_) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%SmoothInitialPeriod) then

                            SmoothCoef = RunPeriod / Me%ComputeOptions%SmoothInitialPeriod

                        endif

                    endif

                    !!!! $OMP CRITICAL (VVDB2_FNC02)
                    TauFace  = Face_Interpolation(TauWind_UV(I,J), TauWind_UV(iSouth, jWest), &
                                                  DUX_VY(I, J), DUX_VY(iSouth, jWest))
                    !!!! $OMP END CRITICAL (VVDB2_FNC02)

! Modified by Matthias DELPEY - 08/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    if (Me%ComputeOptions%WaveForcing3D == GLM) then

                        Taw_Face = Face_Interpolation(Taw_UV(I,J), Taw_UV(iSouth, jWest), &
                                                  DUX_VY(I, J), DUX_VY(iSouth, jWest))


                        ! The surface momentum flux from atmosphere to wave is substracted to the total momentum flux
                        ! from the atmosphere at the surface (Taw is in [m^2/s^2])
                        ! TauFace = TauFace - Taw_Face
                        ! [M*m/s^2/m^2] = [M*m/s^2/m^2] - [m^2/s^2]*[M/m^3]
                        TauFace = TauFace - Taw_Face * Air_Density

                    endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                    TauFace  = SmoothCoef * TauFace

                    DT_Z                      = DT_Velocity / Volume_UV(i, j, KUB)       &
                                                * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

                    ![m/s]                    = [s/m] * [M*m/s^2/m^2] / [M/m^3]
                    CellFace_TopFace        = DT_Z * TauFace / FaceDensity
                else

                    CellFace_TopFace        = 0.

                endif

! Modified by Matthias DELPEY - 24/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    if (Me%ComputeOptions%WaveForcing3D == GLM .and. Me%ComputeOptions%WaveForcing3D_Two == TauSurface) then

                        Two_Face = Face_Interpolation(Two_UV(I,J), Two_UV(iSouth, jWest),        &
                                                  DUX_VY(I, J), DUX_VY(iSouth, jWest))

                        DT_Z     = DT_Velocity / Volume_UV(i, j, KUB)                            &
                                   * DZX_ZY(iSouth, jWest) * DYY_XX(I, J)

                        ! The surface momentum flux from wave to ocean due to breaking is added to the total momentum flux
                        ! at the surface

                        ![m/s]                    = [m/s]   + [s*m^-3*m^2] * [m^2*s^-2]
                        CellFace_TopFace = CellFace_TopFace +  DT_Z * Two_Face

                    endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                !In case of 3D models where the depth is very low a linear profile
                !is assumed to the shear stress (pressure = shear stress) and the momentum
                !is decrease in uniform way along the entire water column
                !
                if (KUB > 1 .and. WaterColumnUV(i,j) <= WaterColumn2D) then

                    TotalVolume = 0.

                    do k = Kbottom, KUB

                        TotalVolume = TotalVolume + Volume_UV(i, j, k)

                    enddo

                    do k = Kbottom, KUB

                        Coef = real (Volume_UV(i, j, k) / TotalVolume)

                        ECoef_3D (i, j, k)  = ECoef_3D (i, j, k) + CellFace_BottomFace * Coef

                        !Wind must be always explicit
                        TiCoef_3D(i, j, k)  = TiCoef_3D(i, j, k) + CellFace_TopFace * Coef

                    enddo

                else

                    !the bottom friction is consider always implicit like is done in the water level compute.

                    ECoef_3D (i, j, Kbottom)    = ECoef_3D (i, j, Kbottom) + CellFace_BottomFace

                    !Wind must be always explicit
                    TiCoef_3D(i, j, KUB)        = TiCoef_3D(i, j, KUB)     + CellFace_TopFace

                endif


            endif cd1

        enddo doj
        enddo doi
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "VelVerticalDiffusionBoundaries")
        endif

        !Nullify auxiliar pointers
        nullify(DCoef_3D)
        nullify(ECoef_3D)
        nullify(FCoef_3D)
        nullify(TiCoef_3D)

        nullify(Velocity_UV_Old)
        nullify(Velocity_VU_New)

        nullify(ChezyVelUV)
        nullify(TauWind_UV)

        nullify(Density)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DZX_ZY)
        nullify(DXX_YY)
        nullify(WaterColumnUV)

        nullify(Volume_UV)
        nullify(DUZ_VZ   )

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)

! Modified by Matthias DELPEY - 08/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        nullify(Taw_UV, Two_UV)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    End Subroutine VelVerticalDiffusionBoundaries

        !End-----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This subroutine compute the barotropic pressure effect in the water level            !
    ! calculation. The barotropic pressure is the water barotropic pressure plus           !
    ! the atmospheric pressure                                                             !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_BarotropicPressure

        !Variables Categories
            !Geometry  : WaterColumn, DUX_VY, DVY_UX, DYY_XX, DZX_ZY
            !WaterProp : Density, AtmPressure
            !Time      : DT_Elevation, DT_Velocity, Num_Discretization
            !Mapping   : ComputeFaces3D_UV, Direction
            !Equations : DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D


        !Variables Direction Dependent
            !DUX_VY, DVY_UX, DYY_XX, DZX_ZY, ComputeFaces3D_UV, Direction


        !Arguments------------------------------------------------------------

        !Local---------------------------------------------------------------------
        real(8), dimension(:,:),   pointer :: ECoef_2D, ECoef_2D_Aux
        real,    dimension(:,:),   pointer :: DCoef_2D, FCoef_2D, TiCoef_2D, &
                                              RadCoef_2D, TiRadCoef_2D,      &
                                              TiCoef_2D_Aux

        real                               :: Alpha
        integer                            :: I, J, di, dj, iSouth, jWest, kbottom
        real                               :: AuxPressure, AuxImplicit, AuxExplicit,  &
                                              WaterColumn_High, DT_AUX, DT_AreaCell1, &
                                              DT_AreaCell2, AreaCell1, AreaCell2,     &
                                              SurfaceFaceDensity,                     &
                                              AtmosphericExplicit,                    &
                                              TidePotentialExplicit

        !Begin---------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "WaterLevel_BarotropicPressure")

        !Begin - Shorten variables name

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        !End - Shorten variables name

        if (Me%TidePotential%Compute) then
            Alpha = Me%TidePotential%Alpha
        else
            Alpha = 1.
        endif

        call SetMatrixValue( Me%Coef%D2%Eaux,   Me%WorkSize2D,      dble(0.0))
        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        DCoef_2D             => Me%Coef%D2%D
        ECoef_2D             => Me%Coef%D2%E
        FCoef_2D             => Me%Coef%D2%F
        TiCoef_2D            => Me%Coef%D2%Ti

        ECoef_2D_Aux         => Me%Coef%D2%Eaux
        TiCoef_2D_Aux        => Me%Coef%D2%Tiaux

        RadCoef_2D           => Me%Coef%D2%Rad
        TiRadCoef_2D         => Me%Coef%D2%TiRad

        !$OMP PARALLEL PRIVATE(i,j,iSouth, jWest, kbottom,AuxPressure, AuxImplicit, AuxExplicit,WaterColumn_High, DT_AUX), &
        !$OMP& PRIVATE(DT_AreaCell1,DT_AreaCell2, AreaCell1, AreaCell2,SurfaceFaceDensity,AtmosphericExplicit,TidePotentialExplicit)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
    doj: do j = Me%WorkSize%JLB, Me%WorkSize%JUB
    doi: do i = Me%WorkSize%ILB, Me%WorkSize%IUB

    Cov1:   if (Me%External_Var%ComputeFaces3D_UV(i, j, Me%WorkSize%KUB) == Covered) then

                iSouth     = I - di
                jWest      = J - dj

                kbottom = Me%External_Var%KFloor_UV(i, j)

                WaterColumn_High   = Me%External_Var%WaterColumnUV(i, j)

                ![m*s]            = [m] * [m] * [s] / [m]
                AuxPressure       = WaterColumn_High * Me%External_Var%DYY_XX(I, J) * &
                                    Me%Velocity%DT / Me%External_Var%DZX_ZY(iSouth, jWest)

                !Alpha - Deformation "crosta terreste" Tide potential effect
                AuxPressure       = AuxPressure * Alpha

                !The barotropic water pressure effect is consider implicit while the
                !the atmospheric pressure must be explicit

                !Water Pressure
                ![m^2/s]     = [m*s] * [m/s^2]
                AuxImplicit  = AuxPressure * Gravity

                ![s]         = [s] * []
                DT_AUX       = Me%WaterLevel%DT * Me%ComputeOptions%Num_Discretization / 2.

                !Area of a South or West Z cell
                ![m^2]       = [m] * [m]
                AreaCell1    = Me%External_Var%DUX_VY(iSouth, jWest) * Me%External_Var%DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                ![m^2]       = [m] * [m]
                AreaCell2    = Me%External_Var%DUX_VY(I,J) * Me%External_Var%DVY_UX(I,J)

                ![s/m^2]     = [s] / [m^2]
                DT_AreaCell1 = DT_AUX / AreaCell1

                ![s/m^2]     = [s] / [m^2]
                DT_AreaCell2 = DT_AUX / AreaCell2

                !Atmospheric pressure
                if (Me%ComputeOptions%AtmPressure) then

                    !It should be use the average density of the water column to compute
                    !atmospheric pressure effect but for speed up the program and to simplify the
                    !code was used the surface density. This aproximation dosen't introduce
                    !a large error (<0.3 %).

                    if (Me%ComputeOptions%LocalDensity) then

                        ![M/m^3]
                        SurfaceFaceDensity = Face_Interpolation(Me%External_Var%Density(I,       J,    Me%WorkSize%KUB),     &
                                                                Me%External_Var%Density(iSouth, jWest, Me%WorkSize%KUB),     &
                                                                Me%External_Var%DUX_VY (I,       J),                         &
                                                                Me%External_Var%DUX_VY (iSouth, jWest))
                    else

                        SurfaceFaceDensity = SigmaDensityReference

                    endif


                    ![m^3/s]                  = [m*s]       *  [M*m/s^2/m^2] / [M/m^3]
                    AtmosphericExplicit       = AuxPressure * (Me%External_Var%AtmosphericPressure(iSouth, jWest) -     &
                                                               Me%External_Var%AtmosphericPressure(I, J)) /             &
                                                               SurfaceFaceDensity
                else

                    AtmosphericExplicit       = 0.

                endif

                !Tide potential pressure
                ![m^3/s]                  = [m*s]       * [m/s^2] * [m]
                TidePotentialExplicit     = - AuxPressure * Gravity * (Me%Forces%TidePotentialLevel(iSouth, jWest) - &
                                              Me%Forces%TidePotentialLevel(I, J))

                AuxExplicit               = AtmosphericExplicit + TidePotentialExplicit

ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_))  then


                    call CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux,                                    &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest,                &
                                       Dcoef_2D, ECoef_2D, ECoef_2D_Aux, FCoef_2D, AuxImplicit)

                else ic1

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
                    DCoef_2D(I, J)            = DCoef_2D(I, J)             - AuxImplicit * DT_AreaCell2

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
                    ECoef_2D(I, J)            = ECoef_2D(I, J)             + AuxImplicit * DT_AreaCell2

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
                    FCoef_2D(iSouth, jWest)   = FCoef_2D(iSouth, jWest)  - AuxImplicit * DT_AreaCell1

                    ![ ]                      = [ ]                        +  [m^2/s]    * [s/m^2]
!                    ECoef_2D(iSouth, jWest)   = ECoef_2D(iSouth, jWest)  + AuxImplicit * DT_AreaCell1
                    ECoef_2D_Aux(iSouth, jWest)   = AuxImplicit * DT_AreaCell1


                    ![m]                      = [m]                        + [m^3/s] * [s/m^2]
                    TiCoef_2D (I, J)          = TiCoef_2D(I, J)            + AuxExplicit * DT_AreaCell2

                    ![m]                      = [m]                        + [m^3/s] * [s/m^2]
!                    TiCoef_2D(iSouth, jWest)  = TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    TiCoef_2D_Aux(iSouth, jWest)  = - AuxExplicit * DT_AreaCell1

                endif ic1

                if ((Me%ComputeOptions%BarotropicRadia == FlatherWindWave_       .or.                      &
                     Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) .and.                     &
                     Me%External_Var%BoundaryFacesUV(I, J) == Boundary) then
                    ![m^3/s]
                    TiRadCoef_2D (I, J)   = TiRadCoef_2D(I, J   )      + AuxExplicit * Me%ComputeOptions%Num_Discretization / 2.

                   ![m^2/s]
                    RadCoef_2D   (I, J)   = RadCoef_2D(I, J)           + AuxImplicit * Me%ComputeOptions%Num_Discretization / 2.

                endif

            endif Cov1

        enddo doi
        enddo doj
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !$OMP PARALLEL PRIVATE(I,J)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            ECoef_2D(i, j) = ECoef_2D(i, j) + ECoef_2D_Aux(i, j)
            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)
        enddo
        enddo
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        !Nullify auxiliar pointers
        nullify(DCoef_2D)
        nullify(ECoef_2D)
        nullify(FCoef_2D)
        nullify(TiCoef_2D)

        nullify(ECoef_2D_Aux)
        nullify(TiCoef_2D_Aux)

        nullify(RadCoef_2D)
        nullify(TiRadCoef_2D)

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "WaterLevel_BarotropicPressure")
        endif

    end Subroutine WaterLevel_BarotropicPressure

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! This suborutine computes the bottom friction effect in the water level calculation   !
    !                                                                                      !
    ! Input : Geomtry, Flow, Mapping, Time steps                                           !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine WaterLevel_BottomFriction

        !Variables Categories
            !Geometry  : Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY
            !Flow      : Velocity_UV_Old, Velocity_VU_Old, Vert_Viscosity
            !WaterProp : Density
            !Boundary  : AtmPressure, Chezy
            !Forces    : Horizontal_Transport, Rox3,
            !Time      : DT_Elevation, DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D


        !Variables Direction Dependent
            !Volume_UV, Area_UV, DUX_VY, DVY_UX, DXX_YY, DYY_XX, DZX_ZY
            !Velocity_UV_Old, Velocity_VU_Old, ComputeFaces3D_UV, KFloor_UV, Direction


        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: Volume_UV, Horizontal_Transport
        real(8), dimension(:,:  ), pointer :: ECoef_2D,ECoef_2D_Aux

        real,    dimension(:,:,:), pointer :: Area_UV, Velocity_UV_Old, Velocity_VU_New, &
                                              Density, Inertial_Aceleration, Rox3XY,     &
                                              Vertical_Viscosity, DUZ_VZ,                &
                                              Relax_Aceleration, PressureCorrect

        real,    dimension(:,:  ), pointer :: DCoef_2D, FCoef_2D, TiCoef_2D,             &
                                              DUX_VY, DVY_UX, DYY_XX, DZX_ZY, DXX_YY,    &
                                              ChezyVelUV, AtmPressure, RadCoef_2D,       &
                                              TiRadCoef_2D, TidePotentialLevel,          &
                                              WaterColumnUV, TiCoef_2D_Aux

        !Manuel
        real                               :: visc_bottom_max


        integer, dimension(:,:,:), pointer :: ComputeFaces3D_UV
        integer, dimension(:,:),   pointer :: KFloor_UV, BoundaryFacesUV

        real                               :: DT_Velocity, DT_Elevation, Num_Discretization, &
                                              Alpha, Transport_Aceleration

        integer                            :: I, J, kbottom, di, dj, iSouth, I_North, J_East, jWest

        real                               :: FC, FC_Area, VelModXY, FaceDensity,        &
                                              DUZ, ViscAux, AuxImplicit, AuxExplicit,    &
                                              DT_AUX, DT_AreaCell1, DT_AreaCell2,        &
                                              AreaCell1, AreaCell2, BottomViscCoef      !, CoefRelax

        real                               :: WaterColumn2D


        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB, BarotropicRadia

! Modified by Matthias DELPEY - 16/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 24/11/2011
        real,    dimension(:,:,:), pointer :: StokesVel_UV_Old, Wave3DExplicit_Acceleration
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        !$ integer                          :: CHUNK

        !Begin---------------------------------------------------------------------

        !Begin - Shorten variables name

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        di  = Me%Direction%di
        dj  = Me%Direction%dj

        DT_Velocity          =  Me%Velocity%DT
        DT_Elevation         =  Me%WaterLevel%DT

        Num_Discretization   =  Me%ComputeOptions%Num_Discretization

        BarotropicRadia      =  Me%ComputeOptions%BarotropicRadia
        BottomViscCoef       =  Me%ComputeOptions%BottomViscCoef
        WaterColumn2D        =  Me%ComputeOptions%WaterColumn2D

        Horizontal_Transport => Me%Forces%Horizontal_Transport
        Inertial_Aceleration => Me%Forces%Inertial_Aceleration
        Rox3XY               => Me%Forces%Rox3XY
        TidePotentialLevel   => Me%Forces%TidePotentialLevel
        Relax_Aceleration    => Me%Forces%Relax_Aceleration
! Modified by Matthias DELPEY - 16/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 24/11/2011
        Wave3DExplicit_Acceleration => Me%Forces%Wave3DExplicit_Acceleration
        StokesVel_UV_Old            => Me%StokesVel%Horizontal%UV%Old
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        AtmPressure          => Me%External_Var%AtmosphericPressure
        ChezyVelUV           => Me%External_Var%ChezyVelUV

        DUX_VY               => Me%External_Var%DUX_VY
        DVY_UX               => Me%External_Var%DVY_UX
        DYY_XX               => Me%External_Var%DYY_XX
        DXX_YY               => Me%External_Var%DXX_YY
        DZX_ZY               => Me%External_Var%DZX_ZY

        Density              => Me%External_Var%Density

        Volume_UV            => Me%External_Var%Volume_UV
        Area_UV              => Me%External_Var%Area_UV
        DUZ_VZ               => Me%External_Var%DUZ_VZ
        WaterColumnUV        => Me%External_Var%WaterColumnUV

        Velocity_UV_Old      => Me%Velocity%Horizontal%UV%Old
        Velocity_VU_New      => Me%Velocity%Horizontal%VU%New

        Vertical_Viscosity   => Me%External_Var%Vertical_Viscosity

        ComputeFaces3D_UV    => Me%External_Var%ComputeFaces3D_UV
        BoundaryFacesUV      => Me%External_Var%BoundaryFacesUV
        KFloor_UV            => Me%External_Var%KFloor_UV

        PressureCorrect      => Me%NonHydrostatic%PressureCorrect


        !End - Shorten variables name


        if (Me%TidePotential%Compute) then

            Alpha = Me%TidePotential%Alpha

        else

            Alpha = 1.

        endif

        call SetMatrixValue( Me%Coef%D2%Eaux,  Me%WorkSize2D,      dble(0.0))
        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$ CHUNK = CHUNK_J(JLB, JUB)

        !!GRiflet: just to make it even safer, I'm going to privatize the pointers
        !!GRiflet: of the arrays that are written.
        !! $OMP PARALLEL PRIVATE( I, J, iSouth, jWest, I_North, J_East, kbottom,          &
        !! $OMP                   VelModXY, FC, FC_Area, AuxImplicit, AuxExplicit,        &
        !! $OMP                   FaceDensity, Transport_Aceleration, VISCAUX,            &
        !! $OMP                   DUZ, visc_bottom_max, DT_Aux, AreaCell1, AreaCell2,     &
        !! $OMP                   DT_AreaCell1, DT_AreaCell2,                             &
        !! $OMP                   DCoef_2D, ECoef_2D, FCoef_2D, TiCoef_2D,                &
        !! $OMP                   ECoef_2D_Aux, TiCoef_2D_Aux, RadCoef_2D, TiRadCoef_2D)

        DCoef_2D             => Me%Coef%D2%D
        ECoef_2D             => Me%Coef%D2%E
        FCoef_2D             => Me%Coef%D2%F
        TiCoef_2D            => Me%Coef%D2%Ti

        ECoef_2D_Aux         => Me%Coef%D2%Eaux
        TiCoef_2D_Aux        => Me%Coef%D2%Tiaux

        RadCoef_2D           => Me%Coef%D2%Rad
        TiRadCoef_2D         => Me%Coef%D2%TiRad

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
    doj: do j = JLB, JUB
    doi: do i = ILB, IUB

    Cov1:   if (ComputeFaces3D_UV(i, j, KUB) == Covered) then

                iSouth     = I - di
                jWest      = J - dj

                ! This values (i_North and j_east) can only be used to compute the velocity modulus in a face
                I_North     = I + dj
                J_East      = J + di

                kbottom     = KFloor_UV(I, J)

                VelModXY    = Face_Velocity_Modulus(Velocity_VU_New(I_North, jWest, kbottom), &
                                                    Velocity_VU_New(I_North, J_East, kbottom), &
                                                    Velocity_VU_New(iSouth, jWest, kbottom), &
                                                    Velocity_VU_New(iSouth, J_East, kbottom), &
                                                    DXX_YY(I_North, jWest),               &
                                                    DXX_YY(I_North, J_East),               &
                                                    DXX_YY(iSouth, jWest),               &
                                                    DXX_YY(iSouth, J_East),               &
                                                    Velocity_UV_Old(I,J,kbottom))

                !FC (FrictionCoefficient) is a non-dimensional coefficient
!                FC          = FrictionCoefficient(Chezy(iSouth, jWest) , Chezy (I, J), &
!                                                 DUX_VY(iSouth, jWest), DUX_VY(I, J), &
!                                                 VelModXY, DT_Velocity,                 &
!                                                 DZX_ZY(iSouth, jWest), DYY_XX(I, J), &
!                                                 Volume_UV(I, J, kbottom))

                !FC (FrictionCoefficient) is a non-dimensional coefficient
                !FC = FB - 1 (FB - Backhaus friction coefficient )

                ![]         = [s] * [m] * [m] * [] * [m/s] / [m^3]
                !FC          = 1. / (1. + DT_Velocity * DZX_ZY(iSouth, jWest) *         &
                !              DYY_XX(I, J) * ChezyVelUV(I, J) * VelModXY /                  &
                !              Volume_UV(I, J, kbottom)) - 1.

                ![]         =  []
                FC          = 1. / (1. + ChezyVelUV(I, J)) - 1.



                FC_Area     = FC * Area_UV(I, J, kbottom) ! [m^2]

                ! Corrections to all terms of the bottom layer due to bottom friction (See Mesh3D technical manual)

                !Implicit effects : barotropic water pressure
                !Alpha - Deformation "crosta terreste" Tide potential effect

                ![m^2/s]    = [m^2] * [s] * [m/s^2] / [m]
                AuxImplicit = FC_Area * DT_Velocity * Gravity / DZX_ZY(iSouth, jWest) * Alpha


                !Explicit effects
                ![m^3/s]
                AuxExplicit  = 0.

! Modified by Matthias DELPEY - 24/11/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !WaterFlow in the bottom layer
                ![m^3/s]     = [m^3/s]      + [m^2]*[m/s]
                ! AuxExplicit  = AuxExplicit  + FC_Area * Velocity_UV_Old(I, J, kbottom)

                if (Me%ComputeOptions%WaveForcing3D /= GLM) then
                    ![m^3/s]     = [m^3/s]      + [m^2]*[m/s]
                    AuxExplicit  = AuxExplicit  + FC_Area * Velocity_UV_Old(I, J, kbottom)
                else
                    AuxExplicit  = AuxExplicit  + FC_Area * (Velocity_UV_Old(I, J, kbottom) + StokesVel_UV_Old(I, J, kbottom))
                endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                if (Me%ComputeOptions%LocalDensity) then

                    ![M/m^3]
                    FaceDensity = Face_Interpolation(Density(I,J,kbottom), Density(iSouth, jWest,kbottom), &
                                                     DUX_VY(I, J), DUX_VY(iSouth, jWest))

                else
                    ![M/m^3]
                    FaceDensity = SigmaDensityReference

                endif


                !Atmospheric pressure

                if (Me%ComputeOptions%AtmPressure) then

                    ![m^3/s]     = [m^2] * [s] * [M*m/s^2/m^2] / [M/m^3] / [m]
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *              &
                                                  (AtmPressure(iSouth, jWest) -      &
                                                  AtmPressure(I,J))/                   &
                                                  FaceDensity / DZX_ZY(iSouth, jWest)
                endif


                !Tide potential pressure
                ![m^3/s]                  =   [m^2] * [s] * [m/s^2] * [m] / [m]
                AuxExplicit  = AuxExplicit  - FC_Area * DT_Velocity * Gravity *              &
                                              (TidePotentialLevel(iSouth, jWest) -         &
                                              TidePotentialLevel(I, J)) / DZX_ZY(iSouth, jWest)


                !Aceleration due to Horizontal transport = advection + diffusion
                ![m/s^2]              = [m^4/s^2] / [m^3]
                Transport_Aceleration = Horizontal_Transport (I, J, kbottom) /               &
                                        Volume_UV(I, J, kbottom)


                !Horizontal Transport in the bottom layer = Advection, diffusion
                ![m^3/s]     = [m^3/s]      +  [m^2]  * [s]  * [m/s^2]
                AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                             &
                                              Transport_Aceleration
!                                              Horizontal_Transport(I, J, kbottom) / &
!                                              DZX_ZY(iSouth, jWest)

                !Coriolis and centrifugal force in the bottom layer
                ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]

                AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                   &
                                              Inertial_Aceleration(I, J, kbottom)

                if (Me%Relaxation%Force)                                    &
                    ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Relax_Aceleration(I, J, kbottom)

                if(Me%ComputeOptions%Obstacle)                                          &
                    ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Me%Forces%ObstacleDrag_Aceleration(I, J, kbottom)
! Modified by Matthias DELPEY - 16/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                if (Me%ComputeOptions%WaveForcing3D == GLM)                              &
                    ![m^3/s]     = [m^3/s]      + [m^2]   * [s]         * [m/s^2]
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                &
                                                  Wave3DExplicit_Acceleration(I, J, kbottom)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


                if (Me%ComputeOptions%Scraper)                                          &
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Me%Forces%Scraper_Aceleration(i, j, kbottom)

                if (Me%ThinWalls%ON .and. Me%ThinWalls%CloseFlag == 0)                  &
                    AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *               &
                                                  Me%Forces%ThinWalls_Dissipation(i,j,kbottom)



                !baroclinic pressure in the bottom layer
                ![m^3/s]     = [m^3/s]      + [m^2] * [s] * [M/m^3] * [m/s^2] / [M/m^3]
                AuxExplicit  = AuxExplicit  + FC_Area * DT_Velocity *                    &
                                              Rox3XY(I, J, kbottom)   * Gravity / FaceDensity


                ! Shear stress between the first and the second layer
    kmax1:      if (KUB > kbottom) then
                    ![m^2/s]

                     ! Manuel Remember that viscosities are defined at faces.
                     VISCAUX = Face_Interpolation(Vertical_Viscosity(I, J, kbottom+1),            &
                                                 Vertical_Viscosity(iSouth, jWest, kbottom+1), &
                                                 DUX_VY(I, J), DUX_VY(iSouth, jWest))

                     ! Vertical distance between the velocities "Velocity_X kbottom +1" and "Velocity_X kbottom"
                     DUZ = (DUZ_VZ(I, J, kbottom + 1) + DUZ_VZ(I, J, kbottom)) / 2.0

                     !Limitation of bottom viscosity due to the semi-implicit discretization of bottom friction. MRV
                     if (Me%ComputeOptions%BottomVisc_LIM ) then

                         visc_bottom_max  = BottomViscCoef * DUZ_VZ(I, J, kbottom) * DUZ / 2. / DT_Velocity


                         VISCAUX          = min(VISCAUX,visc_bottom_max)

                    end if


                    !This formulation assumes that AreaUV / VolumeUV = DZX_ZY, because
                    !is the only way of cancel the vertical diffusion and advection terms.
                    !However, this relation is not true when AreaUV is computed using the
                    !minimum thickness metodology.


                    ![m^3/s]    = [m^3/s]     + [ ]* [s] * [m] * [m^2/s] * [m/s] / [m]
                    AuxExplicit = AuxExplicit + FC * DT_Velocity * DYY_XX(i, j) * VISCAUX * &
                                                (Velocity_UV_Old(I, J, kbottom+1) -         &
                                                 Velocity_UV_Old(I, J, kbottom)) / DUZ
                endif kmax1

                DT_Aux = DT_Elevation * Num_Discretization / 2.

                !Area of a South or West Z cell
                ![m^2]
                AreaCell1 = DUX_VY(iSouth, jWest) * DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                ![m^2]
                AreaCell2 = DUX_VY(I,J) * DVY_UX(I,J)

                ![s/m^2]
                DT_AreaCell1 = DT_Aux / AreaCell1

                ![s/m^2]
                DT_AreaCell2 = DT_Aux / AreaCell2


ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicCoef2D ( TiCoef_2D, TiCoef_2D_Aux,                                     &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest,                &
                                       Dcoef_2D, ECoef_2D, ECoef_2D_Aux, FCoef_2D, AuxImplicit)

                else ic1

                    !Compute the coeficients of linear system equations for the I,J Z cell
                    ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
                    DCoef_2D(I,J)             = DCoef_2D(I,J)  - AuxImplicit * DT_AreaCell2

                    ![ ]                   = [ ]         + [m^2/s] * [s/m^2]
                    ECoef_2D (I,J)            = ECoef_2D(I,J)  + AuxImplicit * DT_AreaCell2

                    ![m]                   = [m]         + [m^3/s] * [s/m^2]
                    TiCoef_2D(I,J)            = TiCoef_2D(I,J) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![ ]                   = [ ]                     + [m^2/s] * [s/m^2]
                    FCoef_2D(iSouth, jWest) = FCoef_2D(iSouth, jWest)  - AuxImplicit * DT_AreaCell1

                    ![ ]                   = [ ]                     + [m^2/s] * [s/m^2]
!                    ECoef_2D(iSouth, jWest) = ECoef_2D(iSouth, jWest)  + AuxImplicit * DT_AreaCell1
                    ECoef_2D_Aux(iSouth, jWest) = AuxImplicit * DT_AreaCell1

                    ![m]                   = [m]                     + [m^3/s] * [s/m^2]
!                    TiCoef_2D(iSouth, jWest)= TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    TiCoef_2D_Aux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif ic1


                !PCL - New changes
                if ((BarotropicRadia == FlatherWindWave_       .or.                    &
                     BarotropicRadia == FlatherLocalSolution_) .and.                   &
                     BoundaryFacesUV(I, J) == Boundary) then

                    ![m^3/s]
                    TiRadCoef_2D (I, J) = TiRadCoef_2D(I, J) + AuxExplicit * Num_Discretization / 2.

                   ![m^2/s]
                    RadCoef_2D   (I, J) = RadCoef_2D  (I, J) + AuxImplicit * Num_Discretization / 2.

                endif


            endif Cov1


        enddo doi
        enddo doj
        !! $OMP END DO

        !! $OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            ECoef_2D(i, j) = ECoef_2D(i, j) + ECoef_2D_Aux(i, j)
            TiCoef_2D(i, j) = TiCoef_2D(i, j) + TiCoef_2D_Aux(i, j)

        enddo
        enddo
        !! $OMP END DO NOWAIT

        !! $OMP END PARALLEL


        !Nullify auxiliar pointers
        nullify(DCoef_2D)
        nullify(ECoef_2D)
        nullify(FCoef_2D)
        nullify(TiCoef_2D)

        nullify(RadCoef_2D)
        nullify(TiRadCoef_2D)

        nullify(AtmPressure)

        nullify(Density)

        nullify(DYY_XX)
        nullify(DUX_VY)
        nullify(DVY_UX)
        nullify(DZX_ZY)
        nullify(DXX_YY)

        nullify(ComputeFaces3D_UV)
        nullify(KFloor_UV)
        nullify(BoundaryFacesUV)

        nullify(Horizontal_Transport)
        nullify(Inertial_Aceleration)
        nullify(Relax_Aceleration   )
        nullify(Rox3XY)
        nullify(TidePotentialLevel)

        nullify(ChezyVelUV)

        nullify(Volume_UV)
        nullify(Area_UV  )
        nullify(DUZ_VZ   )

        nullify(Velocity_UV_Old)
        nullify(Velocity_VU_New)

        nullify(Vertical_Viscosity)

! Modified by Matthias DELPEY - 16/09/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 24/11/2011
        nullify(Wave3DExplicit_Acceleration, StokesVel_UV_Old)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    end Subroutine WaterLevel_BottomFriction

    !------------------------------------------------------------------------------

    function Face_Interpolation(X,Y,DX,DY)

        !Arguments
        real ::  Face_Interpolation, X,Y,DX,DY

        !Begin---------------------------------------------------------------------

        Face_Interpolation = (X*DY+Y*DX)/(DX+DY)

    end function Face_Interpolation

    !------------------------------------------------------------------------------

    function Face_Velocity_Modulus(VelVU1, VelVU2, VelVU3, VelVU4, &
                                         DXY1, DXY2, DXY3, DXY4, VelUV)

        !Arguments
        real :: Face_Velocity_Modulus, VelVU1, VelVU2, VelVU3, VelVU4, &
                DXY1, DXY2, DXY3, DXY4, VelUV

        !Local
        real :: VU1, VU2, VU12

        !Begin---------------------------------------------------------------------

        !X - Direction i,j,kbottom face
        !
        !V1 = (Velocity_Y(I+1,J-1,kbottom)*DXX(I+1,J)+Velocity_Y(I+1,J,kbottom)* &
        !      DXX(I+1,J-1))/(DXX(I+1,J)+DXX(I+1,J-1))


        VU1 = Face_Interpolation(VelVU1, VelVU2, DXY1, DXY2)

        !X - Direction i,j,kbottom face
        !
        !V2 = (Velocity_Y(I,J-1,kbottom)*DXX(I,J)+Velocity_Y(I,J,kbottom)*       &
        !      DXX(I,J-1))/(DXX(I,J)+DXX(I,J-1))

        VU2 = Face_Interpolation(VelVU3, VelVU4, DXY3, DXY4)

        VU12= (VU1 + VU2)/2.

        Face_Velocity_Modulus = abs(cmplx(VelUV, VU12))
!        Face_Velocity_Modulus = SQRT(VelUV*VelUV + VU12*VU12)


    end function Face_Velocity_Modulus


    !------------------------------------------------------------------------------

    function FrictionCoefficient(Chezy1, Chezy2, DUV1, DUV2, VelMod, DT, &
                                       DZXY, DYX, Volume_UV)

        !Arguments
          real    :: FrictionCoefficient, Chezy1, Chezy2, DUV1, DUV2, VelMod, &
                     DT, DZXY, DYX
          real(8) :: Volume_UV

        ! Local
          real :: D

        !Begin---------------------------------------------------------------------


        !X - Direction i,j face
        !
        !D  = (CHEZY(I,J)*DUX(I,J-1)+CHEZY(I,J-1)*DUX(I,J))/         &
        !                 (DUX(I,J-1)+DUX(I,J))

        D = Face_Interpolation(Chezy1,Chezy2,DUV1,DUV2)

        !X - Direction i,j,kbottom face

        !FrictionCoefficient = 1./(1. + DT*DZX(I,J-1)*DYY(I,J)/Volume_U(I,J,kbottom)*D*VelMod)-1.


        FrictionCoefficient = 1./(1. + DT*DZXY*DYX*D*VelMod/Volume_UV)-1.


    End function FrictionCoefficient


    !------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !The effect of all explicit forces in the elevation calculation is compute             !
    !in this subroutine except the atmospheric pressure that is compute in the             !
    ! WaterLevel_BarotropicPressure subroutine                                             !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine WaterLevel_ExplicitForces

        !Variables Categories
            !Geometry  : Area_UV, DUX_VY, DVY_UX, DYY_XX, DZX_ZY
            !WaterProp : Density
            !Forces    : Horizontal_Transport, Rox3, TauWind_UV, Inertial_Aceleration
            !Time      : DT_Elevation, DT_Velocity
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_2D


        !Variables Direction Dependent
            !TauWind_UV, Area_UV, DUX_VY, DVY_UX, DYY_XX, DZX_ZY
            !ComputeFaces3D_UV, KFloor_UV, Direction


        !Arguments------------------------------------------------------------


        !Local---------------------------------------------------------------------
        integer                                 :: i, j, k, kbottom, iSouth, jWest
        real                                    :: FaceDensity, SurfaceFaceDensity, AuxExplicit,                            &
                                                   DT_AUX, DT_AreaCell1, DT_AreaCell2,                                      &
                                                   AreaCell1, AreaCell2, TauFace,                                           &
                                                   Transport_Aceleration, SmoothCoef, RunPeriod,                            &
                                                   Aux_2D, Taw_Face, Two_Face


        !Begin---------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "WaterLevel_ExplicitForces")

        if (Me%ComputeOptions%Turbine) then
            call GetTurbineAcceleration(Me%ObjTurbine, Me%Forces%Turbine_Acceleration)
        endif

        call SetMatrixValue(Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$OMP PARALLEL PRIVATE( i, j, k, kbottom, iSouth, jWest),                &
        !$OMP& PRIVATE(FaceDensity, SurfaceFaceDensity, AuxExplicit),            &
        !$OMP& PRIVATE(DT_AUX, DT_AreaCell1, DT_AreaCell2),                      &
        !$OMP& PRIVATE(AreaCell1, AreaCell2, TauFace),                           &
        !$OMP& PRIVATE(Transport_Aceleration, SmoothCoef, RunPeriod),            &
        !$OMP& PRIVATE(Aux_2D, Taw_Face, Two_Face)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (Me%External_Var%ComputeFaces3D_UV(i, j, Me%WorkSize%KUB) == Covered) then

                iSouth     = i - Me%Direction%di
                jWest      = j - Me%Direction%dj

                kbottom     = Me%External_Var%KFloor_UV(i, j)

                AuxExplicit  = 0.

                if (Me%WaveStress%ON) then

                    TauFace  = Face_Interpolation(Me%External_Var%TauWaves_UV(I,J),                                         &
                                                  Me%External_Var%TauWaves_UV(iSouth, jWest),                               &
                                                  Me%External_Var%DUX_VY(I, J),                                             &
                                                  Me%External_Var%DUX_VY(iSouth, jWest))


                    ![M * m/s] = [M*m/s^2/m^2] * [m] * [m] * [s]
                    Aux_2D =   TauFace * Me%External_Var%DZX_ZY(iSouth, jWest) * Me%External_Var%DYY_XX(I, J)* Me%Velocity%DT

                endif

                do  k = kbottom, Me%WorkSize%KUB

                    if (Me%ComputeOptions%LocalDensity) then

                        ![M/m^3]
                        FaceDensity  = Face_Interpolation(Me%External_Var%Density(I,J,K),                                   &
                                                          Me%External_Var%Density(iSouth, jWest,K),                         &
                                                          Me%External_Var%DUX_VY(I, J),                                     &
                                                          Me%External_Var%DUX_VY(iSouth, jWest))
                    else
                        ![M/m^3]
                        FaceDensity = SigmaDensityReference

                    endif

                    !Horizontal Transport - Advection, diffusion

                    !Aceleration due to Horizontal transport = advection + diffusion
                    ![m/s^2]              = [m^4/s^2] / [m^3]
                    Transport_Aceleration = Me%Forces%Horizontal_Transport (I, J, K) /                                      &
                                            Me%External_Var%Volume_UV(I, J, K)



                    ![m^3/s]     = [m^3/s]      + [s] * [m/s^2] * [m^2]
                    AuxExplicit  = AuxExplicit  + Me%Velocity%DT * Transport_Aceleration *                                  &
                                                  Me%External_Var%Area_UV(I, J, K)
                                                  ![m^3/s*m/s] / [m]
                                                  !Me%Forces%Horizontal_Transport(I, J, K) / &
                                                  !Me%External_Var%DZX_ZY(iSouth, jWest)


                    !Coriolis and centrifugal force

                    ![m^3/s]     = [m^3/s]      +     [s]     * [m/s^2] * [m^2]
                    AuxExplicit  = AuxExplicit  + Me%Velocity%DT * Me%Forces%Inertial_Aceleration(I, J, K) *                &
                                                  Me%External_Var%Area_UV(I, J, K)

                    !Relaxation Force

                    if (Me%Relaxation%Force)                                &
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m/s^2] * [m^2]
                        AuxExplicit  = AuxExplicit  + Me%Velocity%DT * Me%Forces%Relax_Aceleration(I, J, K) *               &
                                                      Me%External_Var%Area_UV(I, J, K)

                    if(Me%ComputeOptions%Obstacle) then
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m^2]  * [m/s^2]
                        AuxExplicit  = AuxExplicit  + Me%Velocity%DT * Me%External_Var%Area_UV(I, J, K)   *                 &
                                                      Me%Forces%ObstacleDrag_Aceleration(I, J, K)
                    endif

                    ![m^3/s]           = [m^3/s]            +     [s]     [m^2]*     [m/s^2]
                    if (Me%ComputeOptions%Turbine)                                      &
                        AuxExplicit = AuxExplicit + Me%Velocity%DT * Me%External_Var%Area_UV(I, J, K) *         &
                                                                  Me%Forces%Turbine_Acceleration(I, J, K)


                    if(Me%ComputeOptions%Scraper) then
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m^2]  * [m/s^2]
                        AuxExplicit  = AuxExplicit  + Me%Velocity%DT * Me%External_Var%Area_UV(I, J, K)   *                 &
                                                      Me%Forces%Scraper_Aceleration(I, J, K)
                    endif

                    if (Me%ThinWalls%ON .and. Me%ThinWalls%CloseFlag == 0) then
                        ![m^3/s]     = [m^3/s]      +     [s]     * [m^2]  * [m/s^2]
                        AuxExplicit  = AuxExplicit  + Me%Velocity%DT * Me%External_Var%Area_UV(I, J, K)   *                 &
                                                      Me%Forces%ThinWalls_Dissipation(I, J, K)
                    endif

                    !Baroclinic pressure

                    ![m^3/s]     = [m^3/s]      + [m^2] * [s] * [M/m^3] * [m/s^2] / [M/m^3]
                    AuxExplicit  = AuxExplicit  + Me%External_Var%Area_UV(I, J, K) * Me%Velocity%DT *                       &
                                                  Me%Forces%Rox3XY (I, J, K) *                                              &
                                                  Gravity / FaceDensity


                    if (Me%WaveStress%ON) then

                        ![m^3/s]           = [m^3/s] +  [m^2]        * [M * m/s] / [M/m^3] / [m^3] * [m] / [m]
                        AuxExplicit = AuxExplicit +  Me%External_Var%Area_UV  (I, J, K) * Aux_2D / FaceDensity  / &
                                                     Me%External_Var%Volume_UV(i, j, k) * Me%External_Var%DUZ_VZ(i, j, k) / &
                                                     Me%External_Var%WaterColumnUV(i, j)

                    endif

                    if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress .or.                                          &
                        Me%ComputeOptions%WaveForcing3D == GLM)    then

                        ![m^3/s]           = [m^3/s] +  [s]  * [m^2] * [m/s^2]
                        AuxExplicit = AuxExplicit +  Me%Velocity%DT * Me%External_Var%Area_UV  (I, J, K)     &
                                                   * Me%Forces%Wave3DExplicit_Acceleration(I,J,K)

                    endif

                enddo

                !Wind Shear Stress
                if (Me%ComputeOptions%Wind /= NoWind_) then

                    !The last k of the dok Cyclic is KUB - surface layer
                    SurfaceFaceDensity = FaceDensity

                    SmoothCoef = 1.

                    if (Me%ComputeOptions%AtmosphereRAMP) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%AtmospherePeriod) then

                            SmoothCoef = Me%ComputeOptions%AtmosphereCoef

                        endif

                    elseif (Me%ComputeOptions%Wind == InitialSmoothWind_) then

                        RunPeriod = Me%CurrentTime - Me%BeginTime

                        if (RunPeriod < Me%ComputeOptions%SmoothInitialPeriod) then

                            SmoothCoef = RunPeriod / Me%ComputeOptions%SmoothInitialPeriod

                        endif

                    endif

                    TauFace  = Face_Interpolation(Me%External_Var%TauWind_UV(I,J),                                          &
                                                  Me%External_Var%TauWind_UV(iSouth, jWest),                                &
                                                  Me%External_Var%DUX_VY(I, J),                                             &
                                                  Me%External_Var%DUX_VY(iSouth, jWest))


                    if (Me%ComputeOptions%WaveForcing3D == GLM) then

                        Taw_Face = Face_Interpolation(Me%External_Var%AtmToWaveMomentum_UV(I,J),                            &
                                                      Me%External_Var%AtmToWaveMomentum_UV(iSouth, jWest),                  &
                                                      Me%External_Var%DUX_VY(I, J),                                         &
                                                      Me%External_Var%DUX_VY(iSouth, jWest))

                        ! The surface momentum flux from atmosphere to wave is substracted to the
                        ! total momentum flux from the atmosphere at the surface (Taw is in [m^2/s^2])
                        ! TauFace = TauFace - Taw_Face
                        ! [M*m/s^2/m^2] = [M*m/s^2/m^2] - [m^2/s^2]*[M/m^3]
                        TauFace = TauFace - Taw_Face * Air_Density

                    endif

                    TauFace  = TauFace * SmoothCoef

                    ![m^3/s]     = [m^3/s]     + [M*m/s^2/m^2] * [m] * [s] / [M/m^3]
                    AuxExplicit  = AuxExplicit + TauFace * Me%External_Var%DYY_XX(I, J) *                                   &
                                                 Me%Velocity%DT / SurfaceFaceDensity
                endif

                ! Surface momentum flux from waves to ocean due to wave breaking
                if (Me%ComputeOptions%WaveForcing3D == GLM .and.                                                            &
                    Me%ComputeOptions%WaveForcing3D_Two == TauSurface) then

                    Two_Face  = Face_Interpolation(Me%External_Var%WaveToOceanMomentum_UV(I,J),                             &
                                                   Me%External_Var%WaveToOceanMomentum_UV(iSouth, jWest),                   &
                                                   Me%External_Var%DUX_VY(I, J),                                            &
                                                   Me%External_Var%DUX_VY(iSouth, jWest))


                    ![m^3/s]     = [m^3/s]     + [m^2*s^-2] * [m] * [s]
                    ! AuxExplicit  = AuxExplicit + Two_Face * Me%External_Var%DYY_XX(I, J) * Me%Velocity%DT / SurfaceFaceDensity
                    AuxExplicit  = AuxExplicit + Two_Face * Me%External_Var%DYY_XX(I, J) * Me%Velocity%DT
                endif

                DT_Aux = Me%WaterLevel%DT * Me%ComputeOptions%Num_Discretization / 2.

                !Area of a South or West Z cell
                AreaCell1 = Me%External_Var%DUX_VY(iSouth, jWest) * Me%External_Var%DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                AreaCell2 = Me%External_Var%DUX_VY(I,J) * Me%External_Var%DVY_UX(I,J)

                DT_AreaCell1 = DT_Aux / AreaCell1   ![s/m^2]

                DT_AreaCell2 = DT_Aux / AreaCell2   ![s/m^2]


                !Compute the coeficients of linear system equations for the I,J Z cell
                if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or.                         &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then


                    call CyclicCoef2D (Me%Coef%D2%Ti, Me%Coef%D2%Tiaux,                                                     &
                                       AuxExplicit, DT_AreaCell1,                                                           &
                                       DT_AreaCell2, I, J, iSouth, jWest)
                else


                    ![m]                   = [m]         + [m^3/s]     * [s/m^2]
                    Me%Coef%D2%Ti(I,J)            = Me%Coef%D2%Ti(I,J) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![m]                   = [m]                     + [m^3/s]     * [s/m^2]
                    Me%Coef%D2%Tiaux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif

                !PCL - New changes
                if ((Me%ComputeOptions%BarotropicRadia == FlatherWindWave_       .or.                                       &
                     Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) .and.                                      &
                     Me%External_Var%BoundaryFacesUV(I, J) == Boundary) then

                    ![m^3/s]
                    Me%Coef%D2%TiRad (I, J) = Me%Coef%D2%TiRad(I, J) + AuxExplicit * Me%ComputeOptions%Num_Discretization / 2.

                endif

            endif
        enddo
        enddo
        !$OMP END DO

        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            Me%Coef%D2%Ti(i, j) = Me%Coef%D2%Ti(i, j) + Me%Coef%D2%Tiaux(i, j)
        enddo
        enddo
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (Me%ComputeOptions%Turbine) then
            call UnGetTurbineAcceleration(Me%ObjTurbine, Me%Forces%Turbine_Acceleration)
        endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "WaterLevel_ExplicitForces")

    end Subroutine WaterLevel_ExplicitForces

    !------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! The effect of all explicit water fluxes in the elevation calculation is compute      !
    ! in this subroutine                                                                   !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine WaterLevel_WaterFluxes


        !Variables Categories
            !Geometry  : Area_UV, Area_VU, DUX_VY, DVY_UX
            !Flow      : Velocity_UV_Old, Velocity_VU_Old, Velocity_VU_New
            !Time      : DT_Elevation
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_2D
            !Domain    : KUB, ILB, IUB, JLB, JUB,
            !Numeric   : Num_Discretization


        !Variables Direction Dependent
            !Area_UV, Area_VU, DUX_VY, DVY_UX, Velocity_UV_Old, Velocity_VU_Old,
            !Velocity_VU_New, ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        integer                            :: i, j, k, kbottom, iSouth, jWest
        real                               :: AuxExplicit, DT_AUX, DT_AreaCell1, &
                                              DT_AreaCell2, AreaCell1, AreaCell2
        real                               :: Aux

        !Begin---------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "WaterLevel_WaterFluxes")

        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$OMP PARALLEL PRIVATE(i, j, k, kbottom, iSouth, jWest),                                                            &
        !$OMP& PRIVATE(AuxExplicit, DT_AUX, DT_AreaCell1),                                                                  &
        !$OMP& PRIVATE(DT_AreaCell2, AreaCell1, AreaCell2),                                                                 &
        !$OMP& PRIVATE(Aux)

        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            iSouth = I - Me%Direction%di
            jWest  = J - Me%Direction%dj

    cd1:    if (Me%External_Var%ComputeFaces3D_UV(i, j, Me%WorkSize%KUB) == Covered) then

                kbottom = Me%External_Var%KFloor_UV(I, J)

                AuxExplicit  = 0.

    do3:        do  k = kbottom, Me%WorkSize%KUB

                    !!old U or V water flux
                    !Aux = Me%Velocity%Horizontal%UV%Old(I, J, K) * Area_UV (I, J, K)

                    if (Me%ComputeOptions%WaveForcing3D == GLM) then
                        !Old U or V water flux
                        Aux = (Me%Velocity%Horizontal%UV%Old(I, J, K) + Me%StokesVel%Horizontal%UV%Old(I, J, K)) *          &
                               Me%External_Var%Area_UV (I, J, K)
                    else
                        !Old U or V water flux
                        Aux = Me%Velocity%Horizontal%UV%Old(I, J, K) * Me%External_Var%Area_UV (I, J, K)
                    endif

                    ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                    AuxExplicit  = AuxExplicit  + Aux

                enddo do3

                !Area of a South or West Z cell
                AreaCell1 = Me%External_Var%DUX_VY(iSouth, jWest) * Me%External_Var%DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                AreaCell2 = Me%External_Var%DUX_VY(I, J) * Me%External_Var%DVY_UX(I, J)

                DT_AreaCell1 = Me%WaterLevel%DT / AreaCell1   ![s/m^2]

                DT_AreaCell2 = Me%WaterLevel%DT / AreaCell2   ![s/m^2]


                !Compute the coeficients of linear system equations for the I,J Z cell
ic1:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or.                         &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then


                    call CyclicCoef2D (Me%Coef%D2%Ti, Me%Coef%D2%Tiaux,                                                     &
                                       AuxExplicit, DT_AreaCell1,                                                           &
                                       DT_AreaCell2, I, J, iSouth, jWest)
                else ic1


                    ![m]                   = [m]         + [m^3/s]     * [s/m^2]
                    Me%Coef%D2%Ti(I, J)           = Me%Coef%D2%Ti(I      , J     ) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![m]                   = [m]                     + [m^3/s]     * [s/m^2]
!                    Me%Coef%D2%Ti(iSouth, jWest)= Me%Coef%D2%Ti(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    Me%Coef%D2%Tiaux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif ic1


                if ((Me%ComputeOptions%BarotropicRadia == FlatherWindWave_       .or.                                       &
                     Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) .and.                                      &
                     Me%External_Var%BoundaryFacesUV(I, J) == Boundary) then

                    ![m^3/s]
                    Me%Coef%D2%TiRad (I, J)   = Me%Coef%D2%TiRad(I, J   )  + AuxExplicit

                endif

            endif cd1
        enddo
        enddo
        !$OMP END DO

        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            Me%Coef%D2%Ti(i, j) = Me%Coef%D2%Ti(i, j) + Me%Coef%D2%Tiaux(i, j)

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        !
        !The next call will call an OpenMP loop, thats why we have to implement the end parallel directive above
        !
        call SetMatrixValue( Me%Coef%D2%Tiaux,  Me%WorkSize2D, 0.0)

        !$OMP PARALLEL PRIVATE(i, j, k, kbottom, iSouth, jWest),                                                            &
        !$OMP& PRIVATE(AuxExplicit, DT_AUX, DT_AreaCell1),                                                                  &
        !$OMP& PRIVATE(DT_AreaCell2, AreaCell1, AreaCell2),                                                                 &
        !$OMP& PRIVATE(Aux)


        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
    do4: do j = Me%WorkSize%JLB, Me%WorkSize%JUB
    do5: do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            iSouth = I - Me%Direction%dj
            jWest  = J - Me%Direction%di

    cd2:    if (Me%External_Var%ComputeFaces3D_VU(i, j, Me%WorkSize%KUB) == Covered) then

                kbottom = Me%External_Var%KFloor_VU(I, J)

                AuxExplicit  = 0.

    do6:        do  k = kbottom, Me%WorkSize%KUB

                    !!Old V or U water flux
                    !
                    !![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                    !AuxExplicit  = AuxExplicit  + Me%Velocity%Horizontal%VU%Old(I, J, K) * Area_VU (I, J, K)
                    !
                    !
                    !!New V or U water flux
                    !
                    !![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                    !AuxExplicit  = AuxExplicit  + (2. - Num_Discretization) * &
                    !                              Me%Velocity%Horizontal%VU%New(I, J, K) * Area_VU (I, J, K)

                    if (Me%ComputeOptions%WaveForcing3D == GLM) then

                        !Old V or U water flux
                        ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                        AuxExplicit  = AuxExplicit  +                                                                       &
                                       (Me%Velocity%Horizontal%VU%Old(I, J, K) + Me%StokesVel%Horizontal%VU%Old(I, J, K)) * &
                                        Me%External_Var%Area_VU (I, J, K)

                        !New V or U water flux                          ! Rem: contribution nul for Leendertse scheme
                        ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                        AuxExplicit  = AuxExplicit  + (2. - Me%ComputeOptions%Num_Discretization) *                         &
                                       (Me%Velocity%Horizontal%VU%New(I, J, K) + Me%StokesVel%Horizontal%VU%New(I, J, K)) * &
                                        Me%External_Var%Area_VU (I, J, K)

                    else
                        !Old V or U water flux
                        ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                        AuxExplicit  = AuxExplicit  + Me%Velocity%Horizontal%VU%Old(I, J, K) * Me%External_Var%Area_VU (I, J, K)

                        !New V or U water flux
                        ![m^3/s]     = [m^3/s]      + [m/s] * [m^2]
                        AuxExplicit  = AuxExplicit  + (2. - Me%ComputeOptions%Num_Discretization) * &
                                                  Me%Velocity%Horizontal%VU%New(I, J, K) * Me%External_Var%Area_VU (I, J, K)
                    endif

                enddo do6

                DT_Aux = Me%WaterLevel%DT * Me%ComputeOptions%Num_Discretization / 2.

                !Area of a South or West Z cell
                AreaCell1 = Me%External_Var%DUX_VY(iSouth, jWest) * Me%External_Var%DVY_UX(iSouth, jWest)

                !Area of a North or East Z cell
                AreaCell2 = Me%External_Var%DUX_VY(I,J) * Me%External_Var%DVY_UX(I,J)

                DT_AreaCell1 = DT_Aux / AreaCell1   ![s/m^2]

                DT_AreaCell2 = DT_Aux / AreaCell2   ![s/m^2]

                !Compute the coeficients of linear system equations for the I,J Z cell
ic2:            if (Me%CyclicBoundary%ON .and. (Me%CyclicBoundary%Direction == Me%Direction%XY .or. &
                                                Me%CyclicBoundary%Direction == DirectionXY_)) then

                    call CyclicCoef2D (Me%Coef%D2%Ti, Me%Coef%D2%Tiaux,                                    &
                                       AuxExplicit, DT_AreaCell1,                        &
                                       DT_AreaCell2, I, J, iSouth, jWest, Direction = Me%Direction%YX)

                else ic2

                    ![m]                   = [m]         + [m^3/s]     * [s/m^2]
                    Me%Coef%D2%Ti(I,J)         = Me%Coef%D2%Ti(I,       J     ) + AuxExplicit * DT_AreaCell2

                    !Compute the coeficients of linear system equations for the iSouth, jWest Z cell

                    ![m]                   = [m]                     + [m^3/s]     * [s/m^2]
!                    TiCoef_2D(iSouth, jWest)= TiCoef_2D(iSouth, jWest) - AuxExplicit * DT_AreaCell1
                    Me%Coef%D2%Tiaux(iSouth, jWest)= - AuxExplicit * DT_AreaCell1

                endif ic2

            endif cd2

        enddo do5
        enddo do4
        !$OMP END DO

        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            Me%Coef%D2%Ti(i, j) = Me%Coef%D2%Ti(i, j) + Me%Coef%D2%Tiaux(i, j)
        enddo
        enddo
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "WaterLevel_WaterFluxes")

    end Subroutine WaterLevel_WaterFluxes

    !End------------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! The effect of all explicit water discharges in the elevation calculation is compute  !
    ! in this subroutine                                                                   !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine WaterLevelDischarges


        !Variables Categories
            !Geometry  : Area_UV, Area_VU, DUX_VY, DVY_UX
            !Flow      : Velocity_UV_Old, Velocity_VU_Old, Velocity_VU_New
            !Time      : DT_Elevation
            !Mapping   : ComputeFaces3D_UV, KFloor_UV, Direction
            !Equations : TiCoef_2D
            !Domain    : KUB, ILB, IUB, JLB, JUB,
            !Numeric   : Num_Discretization


        !Variables Direction Dependent
            !Area_UV, Area_VU, DUX_VY, DVY_UX, Velocity_UV_Old, Velocity_VU_Old,
            !Velocity_VU_New, ComputeFaces3D_UV, KFloor_UV, Direction

        !Arguments------------------------------------------------------------



        !Local---------------------------------------------------------------------
        real(8), dimension(:,:,:), pointer :: DischargeFlow
        real,    dimension(:,:  ), pointer :: TiCoef_2D, DUX, DVY

        integer, dimension(:,:,:), pointer :: WaterPoints3D
        integer, dimension(:,:),   pointer :: KFloor_Z

        real                               :: DT_Elevation

        integer                            :: I, J, K, kbottom

        integer                            :: IUB, ILB, JUB, JLB, KUB


        real                               :: AuxExplicit, DT_AreaCell, AreaCell

        integer                            :: CHUNK

        !Begin---------------------------------------------------------------------

cd0:    if (Me%ComputeOptions%SurfaceWaterFlux .or.                         &
            Me%ComputeOptions%WaterDischarges  .or.                         &
            Me%ComputeOptions%BottomWaterFlux) then


            !Begin - Shorten variables name

            IUB = Me%WorkSize%IUB
            ILB = Me%WorkSize%ILB
            JUB = Me%WorkSize%JUB
            JLB = Me%WorkSize%JLB
            KUB = Me%WorkSize%KUB

            DT_Elevation         =  Me%WaterLevel%DT

            TiCoef_2D            => Me%Coef%D2%Ti
            DischargeFlow        => Me%WaterFluxes%Discharges

            DUX                  => Me%External_Var%DUX
            DVY                  => Me%External_Var%DVY

            WaterPoints3D        => Me%External_Var%WaterPoints3D
            KFloor_Z             => Me%External_Var%KFloor_Z
            !End - Shorten variables name

            CHUNK = CHUNK_J(JLB, JUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "WaterLevelDischarges")
            endif

            !$OMP PARALLEL PRIVATE(i,j,k,kbottom,AuxExplicit,AreaCell) &
            !$OMP PRIVATE(DT_AreaCell)

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:        do j = JLB, JUB
do2:        do i = ILB, IUB


cd1:            if (WaterPoints3D(i, j, KUB) == WaterPoint) then

                    kbottom = KFloor_Z(I, J)

                    AuxExplicit  = 0.

do3:                do  k = kbottom, KUB

                        ![m^3/s]     = [m^3/s]      + [m^3/s]
                        AuxExplicit  = AuxExplicit  + DischargeFlow(i, j, k)

                    enddo do3

                    !Area of a North or East Z cell
                    AreaCell = DUX(I, J) * DVY(I, J)

                    DT_AreaCell = DT_Elevation / AreaCell   ![s/m^2]

                    !Compute the coeficients of linear system equations for the I,J Z cell

                    ![m]             = [m]             + [m^3/s]     * [s/m^2]
                    TiCoef_2D(I, J)  = TiCoef_2D(I, J) + AuxExplicit * DT_AreaCell


                endif cd1

            enddo do2
            enddo do1
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "WaterLevelDischarges")
            endif

            !Nullify auxiliar pointers

            nullify(TiCoef_2D)

            nullify(DUX)
            nullify(DVY)

            nullify(WaterPoints3D)
            nullify(KFloor_Z)

            nullify(DischargeFlow)

        endif cd0




    end Subroutine WaterLevelDischarges

    !End------------------------------------------------------------------------------

    !End------------------------------------------------------------------------------
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    ! The effect of all explicit water discharges in the elevation calculation is compute  !
    ! in this subroutine                                                                   !
    !                                                                                      !
    ! Input : Geometry, Flow, Mapping, Time steps                                          !
    ! OutPut: Coefficients of the  linear system equation                                  !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine ModifyWaterDischarges

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: AddSurfaceWater
        type (T_Time)                      :: CurrentTime

        real                               :: DischargeFlow, AuxFlowK
        integer                            :: DischargesNumber, DischargeID, i, j, kd, k, kmin, kmax
        integer                            :: IUB, ILB, JUB, JLB, KUB, KLB
        integer                            :: STAT_CALL, kbottom

        integer, dimension(:,:,:), pointer :: OpenPoints3D, WaterPoints3D
        real(8), dimension(:,:  ), pointer :: BottomWaterFlux
        real,    dimension(:,:  ), pointer :: Bathymetry

        real,    dimension(:,:,:), pointer :: DWZ
        real,    dimension(:,:  ), pointer :: WaterColumnZ
        integer, dimension(:,:  ), pointer :: KFloor_Z

        integer                            :: DischVertical

        real                               :: WaterLevelByPass !, Depth
        integer                            :: ib, jb !, k1
        logical                            :: ByPassON, IgnoreOK !, DepthON

        real,    dimension(:    ), pointer :: DistributionCoef
        integer, dimension(:    ), pointer :: VectorI, VectorJ, VectorK
        real                               :: AuxFlowIJ, SectionHeight
        real                               :: CoordinateX, CoordinateY
        real                               :: XBypass, YBypass
        logical                            :: CoordinatesON
        integer                            :: nCells, n
        integer                            :: FlowDistribution, SpatialEmission
        real                               :: InterceptionRatio

        integer                            :: CHUNK

        !Begin----------------------------------------------------------------------

        !Begin - Shorten variables name

        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB

        OpenPoints3D  => Me%External_Var%OpenPoints3D
        WaterPoints3D => Me%External_Var%WaterPoints3D
        KFloor_Z      => Me%External_Var%KFloor_Z
        DWZ           => Me%External_Var%DWZ
        WaterColumnZ  => Me%External_Var%WaterColumn

        call SetMatrixValue(Me%WaterFluxes%Discharges, Me%WorkSize, dble(0.0))

        !Water discharge - input of mass in the domain
cd1:    if (Me%ComputeOptions%WaterDischarges) then

            ! Sinks and Sources
            call GetDischargesNumber(Me%ObjDischarges,&
                                      DischargesNumber, STAT = STAT_CALL)

            if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR10'

            !Gets a pointer to Bathymetry
            call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR20'

do1:        do DischargeID = 1, DischargesNumber
                if (IsUpscaling(Me%ObjDischarges, DischargeID))then
                    call GetUpscalingDischarge(Me%ObjTwoWay, Me%WaterFluxes%Discharges, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR25'
                    cycle
                endif

                call GetDischargeON(Me%ObjDischarges,DischargeID, IgnoreOK, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR30'

                if (IgnoreOK) cycle

                call GetDischargesGridLocalization(Me%ObjDischarges,                    &
                                                   DischargeID,                         &
                                                   Igrid         = I,                   &
                                                   JGrid         = J,                   &
                                                   KGrid         = Kd,                  &
                                                   IByPass       = Ib,                  &
                                                   JByPass       = Jb,                  &
                                                   DischVertical = DischVertical,       &
                                                   WaterColumnZ  = WaterColumnZ,        &
                                                   Bathymetry    = Bathymetry,          &
                                                   OpenPoints3D  = Me%External_Var%OpenPoints3D,&
                                                   CoordinateX   = CoordinateX,         &
                                                   CoordinateY   = CoordinateY,         &
                                                   CoordinatesON = CoordinatesON,       &
                                                   TimeX         = Me%CurrentTime,      &
                                                   XBypass       = XBypass,             &
                                                   YBypass       = YBypass,             &
                                                   STAT          = STAT_CALL)
                if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR40'


                !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
                call GetByPassON(Me%ObjDischarges, DischargeID, ByPassON, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR50'

                if (CoordinatesON) then
                    call GetXYCellZ(Me%ObjHorizontalGrid, CoordinateX, CoordinateY, I, J, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR60'

                    call CorrectsCellsDischarges(Me%ObjDischarges, DischargeID, I, J, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR70'

                    if (ByPassON) then

                        call GetXYCellZ(Me%ObjHorizontalGrid, XBypass, YBypass, Ib, Jb, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR80'

                        call CorrectsBypassCellsDischarges(Me%ObjDischarges, DischargeID, Ib, Jb, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR90'

                    endif

                endif

                if (ByPassON) then
                    WaterLevelByPass = Me%WaterLevel%Old(ib, jb)
                else
                    WaterLevelByPass = FillValueReal
                endif


                call GetDischargeWaterFlow(Me%ObjDischarges,                            &
                                           Me%CurrentTime, DischargeID,                 &
                                           Me%WaterLevel%Old(I, J),                     &
                                           DischargeFlow,                               &
                                           SurfaceElevation2 = WaterLevelByPass,        &
                                           STAT = STAT_CALL)

                if (STAT_CALL/=SUCCESS_) stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR100'


                call GetDischargeFlowDistribuiton(Me%ObjDischarges, DischargeID, nCells, FlowDistribution, &
                                                  VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)

                if (STAT_CALL/=SUCCESS_)                                                &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR110'


i1:             if (nCells > 1) then
                    allocate(DistributionCoef(1:nCells))

i2:                 if      (FlowDistribution == DischByCell_       ) then

                        call GetDischargeSpatialType (Me%ObjDischarges, DischargeID,    &
                                                      SpatialEmission, STAT = STAT_CALL)

                        if (STAT_CALL/=SUCCESS_) then
                            stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR120'
                        endif

                        call GetDischargeInterceptionRatio(Me%ObjDischarges, DischargeID, InterceptionRatio,     &
                                                           STAT = STAT_CALL)
                        if (STAT_CALL/=SUCCESS_) then
                            stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR130'
                        endif


                        call DischargeDistributionPerCell (VectorI          = VectorI,  &
                                                           VectorJ          = VectorJ,  &
                                                           nCells           = nCells,   &
                                                           SpatialEmission  = SpatialEmission,&
                                                           Mapping          = Me%External_Var%WaterPoints3D,&
                                                           Property         = Mass_,    &
                                                           InterceptionRatio=InterceptionRatio,&
                                                           DistributionCoef = DistributionCoef)
                    else i2

                        stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR150'

                    endif i2
                endif i1

                AuxFlowIJ = DischargeFlow

                if (Me%OutPut%TimeSerieDischON) then
                    Me%OutPut%TimeSerieDischProp(DischargeID,1) = 0.
                endif

 dn:            do n=1, nCells

                    if (nCells > 1) then
                        i         = VectorI(n)
                        j         = VectorJ(n)
                        kd        = VectorK(n)

                        call GetDischargeWaterFlow(Me%ObjDischarges,                       &
                                                   Me%CurrentTime, DischargeID,            &
                                                   Me%WaterLevel%Old(I, J),                &
                                                   AuxFlowIJ,                              &
                                                   SurfaceElevation2 = WaterLevelByPass,   &
                                                   FlowDistribution  = DistributionCoef(n),&
                                                   STAT              = STAT_CALL)

                        if (STAT_CALL/=SUCCESS_)                                        &
                            stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR160'

                    endif

                    if (DischVertical == DischUniform_) then

                        if (kmin == FillValueInt) kmin = KFloor_Z(i, j)
                        if (kmax == FillValueInt) kmax = KUB
                        SectionHeight = 0

                        do k=kmin, kmax
                            SectionHeight = SectionHeight + DWZ(i, j, k)
                        enddo
                    else

                        kmin = kd; kmax = kd

                    endif

dk:                 do k=kmin, kmax

                        if (OpenPoints3D(i, j, k) /= OpenPoint .and. AuxFlowIJ < 0)  Cycle

                        if (DischVertical == DischUniform_) then

                            AuxFlowK = DWZ(i, j, k) / SectionHeight * AuxFlowIJ

                        else

                            AuxFlowK = AuxFlowIJ

                        endif

                        Me%WaterFluxes%Discharges(i, j, k) =                                &
                            Me%WaterFluxes%Discharges(i, j, k) + AuxFlowK

                        if (Me%OutPut%TimeSerieDischON) then
                            Me%OutPut%TimeSerieDischProp(DischargeID,1) = Me%OutPut%TimeSerieDischProp(DischargeID,1) + AuxFlowK
                        endif

                    enddo dk

                enddo dn

                call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR170'

                call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR180'

                call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                    &
                    stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR190'



                if (nCells > 1) then
                    !deallocate(DistributionCoef)
                    call SetDistributionCoefMass(Me%ObjDischarges, DischargeID,     &
                                                 DistributionCoef, STAT = STAT_CALL)
                    if (STAT_CALL/=SUCCESS_) then
                        stop 'Sub. ModifyWaterDischarges - ModuleHydrodynamic - ERR140'
                    endif
                endif

            enddo do1

            !Disposes pointer to the Bathymetry
            call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ModifyWaterDischarges - ModuleHydrodynamic - ERR200'


        endif cd1

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyWaterDischarges")
        endif

cd2:    if (Me%ComputeOptions%SurfaceWaterFlux .and. .not. Me%State%Initial) then

            AddSurfaceWater => Me%External_Var%SurfaceWaterFlux

            CurrentTime   = Me%CurrentTime

            CHUNK = CHUNK_J(JLB, JUB)

            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2:            do j = JLB, JUB
do3:            do i = ILB, IUB

!                    !Precipitation Condition : AddSurfaceWater(i, j) > 0
!                    !Evaporation   Condition : AddSurfaceWater(i, j) < 0
!                    if ((OpenPoints3D (i, j, KUB) == OpenPoint .and. AddSurfaceWater(i, j) < 0) .or. &
!                        (WaterPoints3D(i, j, KUB) == WaterPoint.and. AddSurfaceWater(i, j) > 0)) then

                    !if (OpenPoints3D (i, j, KUB) == OpenPoint) then

                        Me%WaterFluxes%Discharges(i, j, KUB)     =                      &
                            Me%WaterFluxes%Discharges(i, j, KUB) +                      &
                            AddSurfaceWater(i, j) * OpenPoints3D (i, j, KUB)

            enddo do3
            enddo do2
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd2

!Put BottomWaterFlux in data input
cd3:    if (Me%ComputeOptions%BottomWaterFlux .and. .not. Me%State%Initial) then

                BottomWaterFlux => Me%External_Var%BottomWaterFlux

                CHUNK = CHUNK_J(JLB, JUB)

                !$OMP PARALLEL PRIVATE(i,j, kbottom)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do4:            do j = JLB, JUB
do5:            do i = ILB, IUB

                    kbottom  = Me%External_Var%KFloor_Z (i,j)

                    !Water out of sediment : BottomWaterFluxes(i, j) > 0
                    !Water infiltrating    : BottomWaterFluxes(i, j) < 0
                    if ((OpenPoints3D (i, j, KLB) == OpenPoint .and. BottomWaterFlux (i, j) < 0) .or. &
                        (WaterPoints3D(i, j, KLB) == WaterPoint.and. BottomWaterFlux (i, j) > 0)) then

                        Me%WaterFluxes%Discharges(i, j, kbottom)     =                  &
                            Me%WaterFluxes%Discharges(i, j, kbottom) +                  &
                            BottomWaterFlux(i, j)

                    endif

            enddo do5
            enddo do4
            !$OMP END DO
            !$OMP END PARALLEL

        endif cd3

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "ModifyWaterDischarges")
        endif

        !Nullify auxilary pointers
        nullify (OpenPoints3D )
        nullify (WaterPoints3D)
        nullify (KFloor_Z     )
        nullify (DWZ          )
        nullify (WaterColumnZ )


    end subroutine ModifyWaterDischarges

    !End------------------------------------------------------------------------------


    subroutine Hydrodynamic_OutPut


        !Local-----------------------------------------------------------------
        real,  dimension(:), pointer        :: AuxFlow
        logical                             :: OutPutFileOK, OutPutSurfaceFileOK , TimeSeriesFileOK, &
                                               OutPutWindowFileOK, ProfileFileOK, FloodRiskOk
        type (T_Time)                       :: NextProfileOutput
        integer                             :: NextOutPut, STAT_CALL, iW, dis
        real                                :: DT_Model
        real                                :: Year, Month, Day, Hour, Minute, Second

        !Begin---------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Hydrodynamic_OutPut")

        Me%OutPut%Run_End   = .false.
        OutPutFileOK        = .false.
        ProfileFileOK       = .false.
        TimeSeriesFileOK    = .false.
        OutPutWindowFileOK  = .false.
        OutPutSurfaceFileOK = .false.
        FloodRiskOk         = .false.
        
        if (Me%ComputeOptions%MatrixesOutputOpt) then
            
            if (Me%OutPut%TimeSerieON) then
                call OutputTimeSeries_FileOK (TimeSeriesFileOK)
                FloodRiskOk         = .true.
            endif
            
            if (Me%OutPut%hdf5ON) then
                FloodRiskOk  = .true.
                NextOutPut   = Me%OutPut%NextOutPut
                if (NextOutPut <= Me%OutPut%Number) then
                    if (Me%CurrentTime >= Me%OutPut%OutTime(NextOutPut)) then
                        OutPutFileOK = .true.
                    endif
                endif
            endif
            
            if (Me%OutW%OutPutWindowsON)  then
                FloodRiskOk         = .true.
                do iW = 1, Me%OutW%WindowsNumber
                    if (Me%OutW%OutPutWindows(iW)%ON) then
                        NextOutPut = Me%OutW%OutPutWindows(iW)%NextOutPut
                        OutPutWindowFileOK = .false.
                        if (NextOutPut <= Me%OutW%OutPutWindows(iW)%Number) then
                            if (Me%CurrentTime >= Me%OutW%OutPutWindows(iW)%OutTime(NextOutPut)) then
                                OutPutWindowFileOK = .true.
                            endif
                        endif
                    endif
                enddo
            endif
            
            if(Me%OutPut%HDF5_Surface_ON)then
                FloodRiskOk         = .true.
                OutPutSurfaceFileOK = .false.
                if (Me%OutPut%NextSurfaceOutPut <= Me%OutPut%NumberSurfaceOutputs) then
                    if (Me%CurrentTime >= Me%OutPut%SurfaceOutTime(Me%OutPut%NextSurfaceOutPut)) then
                        OutPutSurfaceFileOK = .true.
                    endif
                endif
            endif
            
            if (Me%OutPut%ProfileON) then
                FloodRiskOk         = .true.
                call GetProfileNextOutputTime(Me%ObjProfile, NextProfileOutput, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Hydrodynamic_OutPut - ModuleHydrodynamic - ERR01'
            
                if (Me%CurrentTime >= NextProfileOutput) ProfileFileOK = .true.
            endif
            
            if (ProfileFileOK .or. OutPutFileOK .or. TimeSeriesFileOK .or. OutPutWindowFileOK .or. &
            OutPutSurfaceFileOK) then
            
                call ModifyMatrixesOutput
                
            endif

            if(FloodRiskOk .and. Me%OutPut%FloodRisk)then
                call ComputeFloodRisk
            endif

        else
            
            if (Me%OutPut%TimeSerieON .or. Me%OutPut%hdf5ON .or.                            &
                Me%OutPut%ProfileON   .or. Me%OutPut%HDF5_Surface_ON.or.                    &
                Me%OutW%OutPutWindowsON)then

                call ModifyMatrixesOutput !Joao Sobrinho

                if(Me%OutPut%FloodRisk)then
                    call ComputeFloodRisk
                endif

            end if
            
        endif

        !! $OMP PARALLEL SECTIONS

        !! $OMP SECTION
        if (Me%OutPut%hdf5ON) then

            NextOutPut = Me%OutPut%NextOutPut

            if (NextOutPut <= Me%OutPut%Number) then
                if (Me%CurrentTime >= Me%OutPut%OutTime(NextOutPut)) then

                    OutPutFileOK = .true.

                endif
            endif


             !Next line changed to avoid rounding errors - Frank Aug - 2001
            if (OutPutFileOK) then

!            if ((Me%CurrentTime + DT_Model/10.) >= Me%OutPut%OutTime(NextOutPut)) then

                call GetComputeTimeStep(Me%ObjTime, DT_Model, STAT = STAT_CALL)

                !Next line changed to avoid rounding errors - Frank Aug - 2001
                if (Me%EndTime == Me%OutPut%OutTime(NextOutPut)) then
!                if (abs(Me%EndTime - Me%OutPut%OutTime(NextOutPut)) < DT_Model/10. ) then

                    Me%OutPut%Run_End = .true.

                endif


                !Output in HDF
                call Write_HDF5_Format

                !
                ! This passed to the module ModuleModel
                !
                !Message to the user
                !call PrintProgress(Me%ObjTime)     !Frank

#ifdef _USE_SEQASSIMILATION
                if (.not. Me%VirtualRun) then
#endif _USE_SEQASSIMILATION

                Me%OutPut%NextOutPut = Me%OutPut%NextOutPut + 1

#ifdef _USE_SEQASSIMILATION
                endif
#endif _USE_SEQASSIMILATION

            endif

        endif

        !! $OMP SECTION
        if (Me%OutW%OutPutWindowsON)  then

            do iW = 1, Me%OutW%WindowsNumber

                if (Me%OutW%OutPutWindows(iW)%ON) then

                    NextOutPut = Me%OutW%OutPutWindows(iW)%NextOutPut

                    OutPutFileOK = .false.

                    if (NextOutPut <= Me%OutW%OutPutWindows(iW)%Number) then
                        if (Me%CurrentTime >= Me%OutW%OutPutWindows(iW)%OutTime(NextOutPut)) then
                            OutPutFileOK = .true.
                        endif
                    endif

                    if (OutPutFileOK) then
                        call Write_HDF5_Format(iW)

                        NextOutPut = NextOutPut + 1

                        Me%OutW%OutPutWindows(iW)%NextOutPut = NextOutPut
                    endif
                endif
            enddo

        endif

        !! $OMP SECTION
        if(Me%OutPut%HDF5_Surface_ON)then

            OutPutSurfaceFileOK = .false.


            if (Me%OutPut%NextSurfaceOutPut <= Me%OutPut%NumberSurfaceOutputs) then
                if (Me%CurrentTime >= Me%OutPut%SurfaceOutTime(Me%OutPut%NextSurfaceOutPut)) then

                    OutPutSurfaceFileOK = .true.

                endif
            endif

            if(OutPutSurfaceFileOK)then

                call Write_Surface_HDF5_Format

                Me%OutPut%NextSurfaceOutPut = Me%OutPut%NextSurfaceOutPut + 1

            endif

        end if

        !! $OMP SECTION
        if (Me%OutPut%TimeSerieON)  &
            call OutPut_TimeSeries

        !! $OMP SECTION
        if (Me%OutPut%ProfileON)    &
            call Output_Profile


        if (Me%OutPut%TurbineON)    &
            call OutPut_Turbine(Me%ObjTurbine)


        !! $OMP SECTION
        if(Me%OutPut%WriteRestartFile .and. .not. Me%OutPut%Run_End)then

            if(Me%CurrentTime >= Me%OutPut%RestartOutTime(Me%OutPut%NextRestartOutput))then

                call ReadUnLock_ModuleGeometry

                if (Me%ComputeOptions%Evolution == Solve_Equations_) then
                    call Write_Final_Hydrodynamic_File
                endif


                call ReadLock_ModuleGeometry


                Me%OutPut%NextRestartOutput = Me%OutPut%NextRestartOutput + 1

                call ExtractDate(Me%CurrentTime, Year = Year, Month  = Month,  Day    = Day, &
                                                 Hour = Hour, Minute = Minute, Second = Second)

                call SetError(WARNING_, INTERNAL_, "Hydrodynamic restart file saved        : ", &
                              Year, Month, Day, Hour, Minute, Second)

            end if

        end if
        !! $OMP END PARALLEL SECTIONS

        if (Me%OutPut%TimeSerieDischON) then
            do dis = 1, Me%OutPut%DischargesNumber

                allocate(AuxFlow(4))

                AuxFlow(1:4) = Me%OutPut%TimeSerieDischProp(dis,1:4)

                call WriteTimeSerieLine(Me%OutPut%TimeSerieDischID(dis), AuxFlow,  STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Hydrodynamic_OutPut - ModuleHydrodynamic - ERR10'

                deallocate(AuxFlow)

            enddo
        endif

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Hydrodynamic_OutPut")


    end subroutine Hydrodynamic_OutPut

    !End------------------------------------------------------------------------------

    
    !--------------------------------------------------------------------------

    subroutine WriteHighLowTideOutput

        !Local-----------------------------------------------------------------
        type(T_Time)                            :: Time1, Time2
        real                                    :: Value1, Value2
        real                                    :: n1, n2
        real, dimension(6), target              :: AuxTime
        real, dimension(:), pointer             :: TimePtr
        integer                                 :: STAT_CALL, i, j, Index
        integer                                 :: ILB, IUB, JLB, JUB
        logical                                 :: TimeCycle


        !---------------------------------------------------------------------- 
        
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB


i1:     if (Me%HighLowTide%ON) then        
           
            if (Me%CurrentTime >  Me%HighLowTide%EndWindow) then
                
                !write(*,*) objhdf5
                !Writes current time
                call ExtractDate   (Me%HighLowTide%RefGaugeTime,                        &
                                    AuxTime(1), AuxTime(2), AuxTime(3),                 &
                                    AuxTime(4), AuxTime(5), AuxTime(6))
                TimePtr => AuxTime
                
                Index = Me%HighLowTide%NextOuput
                
                call HDF5SetLimits  (Me%HighLowTide%ObjHDF5, 1, 6, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteHighLowTideOutput - ModuleHydrodynamic - ERR10'

                call HDF5WriteData  (Me%HighLowTide%ObjHDF5, "/Time", "Time",           &
                                     "YYYY/MM/DD HH:MM:SS", Array1D = TimePtr,          &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteHighLowTideOutput - ModuleHydrodynamic - ERR20'    
                
                call HDF5SetLimits  (Me%HighLowTide%ObjHDF5, ILB, IUB, JLB, JUB, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteHighLowTideOutput - ModuleHydrodynamic - ERR10'
                
                call HDF5WriteData  (Me%HighLowTide%ObjHDF5,                            &
                                     "/Results/"//trim(GetPropertyName (WaterLevel_)),  &
                                     trim(GetPropertyName (WaterLevel_)), "m",          &
                                     Array2D = Me%HighLowTide%SeaLevel,                 &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteHighLowTideOutput - ModuleHydrodynamic - ERR30'    
                
                call HDF5WriteData  (Me%HighLowTide%ObjHDF5,                            &
                                     "/Results/"//"Phase_Delay",                        &
                                     "Phase_Delay", "s",                                &
                                     Array2D = Me%HighLowTide%Instant,                  &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteHighLowTideOutput - ModuleHydrodynamic - ERR40'  
                
                
                
                call GetTimeSerieValue(TimeSerieID = Me%HighLowTide%ObjTimeSerieRef,    &
                                       CurrentTime = Me%CurrentTime,                    &        
                                       DataColumn  = Me%HighLowTide%DataColumn,         &
                                       Time1       = Time1,                             &
                                       Value1      = Value1,                            &
                                       Time2       = Time2,                             &
                                       Value2      = Value2,                            &
                                       TimeCycle   = TimeCycle,                         &    
                                       STAT        = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteHighLowTideOutput - ModuleHydrodynamic - ERR50' 
            
                Me%HighLowTide%RefGaugeTime = Time2
                
                if   (Value2 > Value1)    then
                    Me%HighLowTide%HighTide = .true.
                else 
                    Me%HighLowTide%HighTide = .false.
                endif                
                
                Me%HighLowTide%StartWindow = Me%HighLowTide%RefGaugeTime - Me%HighLowTide%BackwardDT
                Me%HighLowTide%EndWindow   = Me%HighLowTide%RefGaugeTime + Me%HighLowTide%ForwardDT       
                
            
                Me%HighLowTide%NextOuput = Me%HighLowTide%NextOuput + 1
                
                if     (Me%HighLowTide%HighTide)    then                
                    Me%HighLowTide%SeaLevel(:, :) =  FillValueReal
                else
                    Me%HighLowTide%SeaLevel(:, :) = -FillValueReal
                endif
                
                Me%HighLowTide%Instant (:, :) = FillValueReal  
                
            endif

            if (Me%CurrentTime >= Me%HighLowTide%StartWindow .and.                      &
                Me%CurrentTime <= Me%HighLowTide%EndWindow        ) then

                do  j = JLB, JUB
                do  i = ILB, IUB
                    
                    n1 = Me%WaterLevel%New(i, j)
                    n2 = Me%HighLowTide%SeaLevel(i, j)                    

                    if (Me%External_Var%OpenPoints3D(i, j, Me%WorkSize%KUB) == Covered) then
                        
                        if     (Me%HighLowTide%HighTide)    then
                            if (n1 > n2) then
                                Me%HighLowTide%SeaLevel(i, j) = n1
                                Me%HighLowTide%Instant (i, j) = Me%CurrentTime - Me%HighLowTide%RefGaugeTime
                            endif
                        else
                            if      (n1 <  n2) then
                                Me%HighLowTide%SeaLevel(i, j) = n1
                                Me%HighLowTide%Instant (i, j) = Me%CurrentTime - Me%HighLowTide%RefGaugeTime
                            elseif  (n1 == n2) then
                                Me%HighLowTide%SeaLevel(i, j) = FillValueReal
                                Me%HighLowTide%Instant (i, j) = FillValueReal    
                            endif
                        endif
                    else
                        if  (n1 == n2 .or. n2 == -FillValueReal) then
                            Me%HighLowTide%SeaLevel(i, j) = FillValueReal
                            Me%HighLowTide%Instant (i, j) = FillValueReal    
                        endif
                    endif
                    
                    
                    
                enddo
                enddo                
                            
            endif    
            
        endif i1

    end subroutine WriteHighLowTideOutput      
    
    !End------------------------------------------------------------------------------    
    

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !>Checks and starts TwoWay nesting
    !>@param[in] HydrodynamicID
    subroutine ComputeTwoWay(HydrodynamicID)
    !Arguments------------------------------------------------------------------------------
        integer, intent(IN)                               :: HydrodynamicID
    !Externals------------------------------------------------------------------------------
        type (T_Hydrodynamic), pointer                    :: ObjHydrodynamicFather
    !Locals---------------------------------------------------------------------------------
        integer                                           :: ready_, readyFather_, STAT_CALL, i
        integer                                           :: AuxHydrodynamicID
    !Begin------------------------------------------------------------------------------
        if (Me%CurrentTime - Me%BeginTime > Me%ComputeOptions%TwoWayWaitPeriod)then

            !Cicle to go over all domains starting from the last nested one
            do i = HydrodynamicID, 2, -1

                if(i == HydrodynamicID)then
                    !does nothing
                else

                    call Ready (i, ready_) ! points Me% to current domain i

                endif

                AuxHydrodynamicID = Me%FatherInstanceID    ! Changes ID to Father

                call ReadyFather(AuxHydrodynamicID, ObjHydrodynamicFather, readyFather_) ! gets Father object

                if (ObjHydrodynamicFather%LastIteration == Me%CurrentTime)then

                    AuxHydrodynamicID = i    !Changes back to Son ID
                    if (ObjHydrodynamicFather%ComputeOptions%UpscalingDischarge)then
                        !makes a copy of velocities U and V of father in order to ompute the difference after upscaling
                        !This difference will be used for the upscaling discharge volume
                        call SetMatrixValue(GetPointer(Me%Submodel%CopyU_New), ObjHydrodynamicFather%Size, &
                                            ObjHydrodynamicFather%Velocity%Horizontal%U%New)
                        call SetMatrixValue(GetPointer(Me%Submodel%CopyV_New), ObjHydrodynamicFather%Size, &
                                            ObjHydrodynamicFather%Velocity%Horizontal%V%New)
                    endif


                    !Tells TwoWay module to get auxiliar variables (volumes, cell conections etc)
                    call PrepTwoWay (SonID             = AuxHydrodynamicID,   &
                                     FatherID          = Me%FatherInstanceID, &
                                     CallerID          = mHydrodynamic_,      &
                                     STAT              = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Subroutine ComputeTwoWay - ModuleHydrodynamic. ERR01.'

                    !Updates father matrixes with son information. For now, hard coded.
                    call ModifyTwoWay (SonID            = AuxHydrodynamicID,                                 &
                                       FatherMatrix     = ObjHydrodynamicFather%Velocity%Horizontal%U%New,   &
                                       SonMatrix        = Me%Velocity%Horizontal%U%New,                      &
                                       CallerID         = mHydrodynamic_,                                    &
                                       VelocityID       = VelocityU_,                                        &
                                       STAT             = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Subroutine ComputeTwoWay - ModuleHydrodynamic. ERR02.'

                    call ModifyTwoWay (SonID            = AuxHydrodynamicID,                                 &
                                       FatherMatrix     = ObjHydrodynamicFather%Velocity%Horizontal%V%New,   &
                                       SonMatrix        = Me%Velocity%Horizontal%V%New,                      &
                                       CallerID         = mHydrodynamic_,                                    &
                                       VelocityID       = VelocityV_,                                        &
                                       STAT             = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Subroutine ComputeTwoWay - ModuleHydrodynamic. ERR03.'

                    call ModifyTwoWay (SonID            = AuxHydrodynamicID,                                 &
                                       FatherMatrix     = ObjHydrodynamicFather%Velocity%Vertical%Cartesian, &
                                       SonMatrix        = Me%Velocity%Vertical%Cartesian,                    &
                                       CallerID         = mHydrodynamic_,                                    &
                                       STAT             = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Subroutine ComputeTwoWay - ModuleHydrodynamic. ERR04.'

                    if (Me%ComputeOptions%TwoWayWaterLevel) then

                        call ModifyTwoWay (SonID            = AuxHydrodynamicID,                                 &
                                           FatherMatrix2D   = ObjHydrodynamicFather%WaterLevel%New,              &
                                           SonMatrix2D      = Me%WaterLevel%New,                                 &
                                           CallerID         = mHydrodynamic_,                                    &
                                           STAT             = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Subroutine ComputeTwoWay - ModuleHydrodynamic. ERR05.'

                    endif

                    if (ObjHydrodynamicFather%ComputeOptions%UpscalingDischarge)then
                        !only for 2D or 3D domains
                        call UpscaleDischarge(SonID       = AuxHydrodynamicID,                               &
                                              FatherU_old = Me%Submodel%CopyU_New,                           &
                                              FatherV_old = Me%Submodel%CopyV_New,                           &
                                              FatherU     = ObjHydrodynamicFather%Velocity%Horizontal%U%New, &
                                              FatherV     = ObjHydrodynamicFather%Velocity%Horizontal%V%New, &
                                              STAT        = STAT_CALL)

                    endif

                    call UngetTwoWayExternal_Vars(SonID             = AuxHydrodynamicID,   &
                                                  FatherID          = Me%FatherInstanceID, &
                                                  CallerID          = mHydrodynamic_,      &
                                                  STAT              = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Subroutine ComputeTwoWay - ModuleHydrodynamic. ERR06.'
                endif
            enddo
            call Ready (HydrodynamicID, ready_) ! swithes back to the last nested Domain
        endif

    end subroutine ComputeTwoWay

    !-------------------------------------------------------------------------------------------------------------------


    subroutine ComputeFloodRisk

        !Locals----------------------------------------------------------------
        integer                                 :: ILB,IUB, JLB, JUB, KUB, i, j
        real                                    :: AuxFloodRisk

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%External_Var%WaterPoints3D(i, j, KUB) == WaterPoint) then

                if (Me%External_Var%WaterColumn(i, j) > Me%Output%MaxWaterColumn(i, j)) then
                    Me%Output%MaxWaterColumn(i, j) = Me%External_Var%WaterColumn(i, j)

                    !Velocity at MaxWater column
                    Me%Output%VelocityAtMaxWaterColumn(i,j) =  Me%OutPut%ModulusH(i, j, KUB)

                endif

                AuxFloodRisk = Me%External_Var%WaterColumn(i, j) * (Me%OutPut%ModulusH(i, j, KUB) + Me%Output%FloodRiskVelCoef)

                if (AuxFloodRisk  > Me%Output%MaxFloodRisk(i,j)) then
                    Me%Output%MaxFloodRisk(i,j) = AuxFloodRisk
                endif

            endif

        enddo
        enddo

        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%External_Var%OpenPoints3D(i, j, KUB) == OpenPoint) then

                if (Me%OutPut%ModulusH(i, j, KUB) > Me%OutPut%MaxVelocity(i, j)) then
                    Me%OutPut%MaxVelocity(i, j) = Me%OutPut%ModulusH(i, j, KUB)
                endif

                if (Me%WaterLevel%New(i, j)       > Me%OutPut%MaxWaterLevel(i, j)) then
                    Me%OutPut%MaxWaterLevel(i, j) = Me%WaterLevel%New(i, j)
                endif

                Me%OutPut%MapMax(i, j) = 1

            else

                Me%OutPut%MapMin(i, j) = 0

            endif

        enddo
        enddo

    end subroutine ComputeFloodRisk

!--------------------------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Constructs Updates facedensity matrix.
    subroutine FaceDensityUpdate
        !External-------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: DUX_VY
        real,    dimension(:,:,:), pointer :: Density
        !Local-----------------------------------------------------------------
        integer                            :: i, j, k, KUB, IUB, JUB, ILB, JLB, KLB

        !$ integer                         :: CHUNK
        !Begin-------------------------------------------------------------------------

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB
        DUX_VY   => Me%External_Var%DUX_VY
        Density  => Me%External_Var%Density

        if (associated(Density))then

            if (Me%Direction%di == 1)then
                !$CHUNK = CHUNK_K(KLB, KUB)
                !$OMP PARALLEL PRIVATE( i,j,k)
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do k=KLB, KUB
                do j=JLB, JUB
                do i=ILB, IUB
                    if (Me%External_Var%ComputeFaces3D_UV(i, j, k)==1) then
                            Me%FaceDensity(i, j, k)  = Face_Interpolation(Density(i, j, k),            &
                                                        Density(i-1, j, k), DUX_VY(i, j), DUX_VY(i-1, j))
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL
            else
                !$CHUNK = CHUNK_K(KLB, KUB)
                !$OMP PARALLEL PRIVATE( i,j,k)
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do k=KLB, KUB
                do j=JLB, JUB
                do i=ILB, IUB
                    if (Me%External_Var%ComputeFaces3D_UV(i, j, k)==1) then
                            Me%FaceDensity(i, j, k)  = Face_Interpolation(Density(i, j, k),            &
                                                        Density(i, j-1, k), DUX_VY(i, j), DUX_VY(i, j-1))
                    endif
                enddo
                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL
            endif
        endif

        nullify(Density, DUX_VY)

    end subroutine FaceDensityUpdate

    ! This subroutine is responsable for computing fluxes between boxes
    subroutine ComputeBoxesWaterFluxes

        !Arguments-------------------------------------------------------------



        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------


        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeBoxesWaterFluxes")

cd1:    if (Me%State%BOXFLUXES) then

            call BoxDif(Me%ObjBoxDif,                                                    &
                        Me%WaterFluxes%X,                                                &
                        Me%WaterFluxes%Y,                                                &
                        Me%WaterFluxes%Z,                                                &
                        Char_Water,                                                      &
                        Me%External_Var%OpenPoints3D,                                   &
                        STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                 &
               stop 'Subroutine ComputeBoxesWaterFluxes - ModuleHydrodynamic. ERR01'

            call BoxDif(Me%ObjBoxDif,                                                    &
                        Me%External_Var%Volume_Z_New,                                    &
                        Char_Water,                                                      &
                        Me%External_Var%OpenPoints3D,                                   &
                        STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                 &
               stop 'Subroutine ComputeBoxesWaterFluxes - ModuleHydrodynamic. ERR02'

        endif cd1

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeBoxesWaterFluxes")

    end subroutine ComputeBoxesWaterFluxes

    !--------------------------------------------------------------------------


    !This subroutine computes
    Subroutine ComputeResidualFlowProperties

        !Local-----------------------------------------------------------------
        integer                            :: i, j, k, kbottom
        integer                            :: ILB, JLB, KLB, IUB, JUB, KUB
        integer                            :: CHUNK
        real                               :: ResidualTime_Plus_DT

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeResidualFlowProperties")

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

        CHUNK = CHUNK_J(JLB, JUB)

        ResidualTime_Plus_DT = Me%Residual%ResidualTime + Me%WaterLevel%DT

        !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)

do1:    do  j = JLB, JUB
do2:    do  i = ILB, IUB

cd2:        if (Me%External_Var%WaterPoints3D(i, j, KUB) == WaterPoint) then

                !Residual Water elevation
                Me%Residual%WaterLevel(i, j) =                                                   &
                                      (Me%Residual%WaterLevel(i, j) * Me%Residual%ResidualTime + &
                                       Me%WaterLevel%New(i, j) * Me%WaterLevel%DT)             / &
                                      ResidualTime_Plus_DT

                kbottom = Me%External_Var%KFloor_Z(i, j)

do3:            do  k = kbottom, KUB

                    !Residual horizontal velocity
                    Me%Residual%Velocity_U(i, j, k) =                                                     &
                                         (Me%Residual%Velocity_U(i, j, k) * Me%Residual%ResidualTime    + &
                                          Me%Velocity%Horizontal%U%New(i, j, k) * Me%WaterLevel%DT)     / &
                                         ResidualTime_Plus_DT

                    Me%Residual%Velocity_V(i, j, k) = &
                                         (Me%Residual%Velocity_V(i, j, k) * Me%Residual%ResidualTime    + &
                                          Me%Velocity%Horizontal%V%New(i, j, k) * Me%WaterLevel%DT)     / &
                                         ResidualTime_Plus_DT

                    !Residual vertical velocity
                    Me%Residual%Vertical_Velocity(i, j, k) =                                                  &
                                         (Me%Residual%Vertical_Velocity(i, j, k) * Me%Residual%ResidualTime + &
                                          Me%Velocity%Vertical%Across(i, j, k) * Me%WaterLevel%DT)          / &
                                         ResidualTime_Plus_DT


                    !Residual Water fluxes by width (residual specifc flow)
                    Me%Residual%WaterFlux_X(i, j, k) =                                                        &
                                             (Me%Residual%WaterFlux_X(i, j, k) * Me%Residual%ResidualTime   + &
                                              Me%WaterFluxes%X(i, j, k) / Me%External_Var%DYY(i, j)         * &
                                              Me%WaterLevel%DT)                                             / &
                                             ResidualTime_Plus_DT

                    Me%Residual%WaterFlux_Y(i, j, k) =                                                        &
                                             (Me%Residual%WaterFlux_Y(i, j, k) * Me%Residual%ResidualTime   + &
                                              Me%WaterFluxes%Y(i, j, k) / Me%External_Var%DXX(i, j)         * &
                                              Me%WaterLevel%DT)                                             / &
                                             ResidualTime_Plus_DT

                    !Residual layer thickness
                    Me%Residual%DWZ(i, j, k) = (Me%Residual%DWZ(i, j, k) * Me%Residual%ResidualTime         + &
                                                Me%External_Var%DWZ(i, j, k)* Me%WaterLevel%DT)             / &
                                                ResidualTime_Plus_DT

                enddo do3

            endif cd2

        enddo do2
        enddo do1
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL

        Me%Residual%ResidualTime  = Me%Residual%ResidualTime + Me%WaterLevel%DT

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeResidualFlowProperties")


    end subroutine ComputeResidualFlowProperties

    !----------------------------------------------------------------------

    subroutine ComputeEmersionTime

        !Local-----------------------------------------------------------------
        integer                                     :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                                     :: WorkKUB
        integer                                     :: i, j, STAT_CALL
        integer, dimension(:, :, :), pointer        :: WaterPoints3D
        integer, dimension(:, :, :), pointer        :: OpenPoints3D
        real                                        :: DT

        !Begin --------------------------------------------------------------------------

        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB
        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB
        WorkKUB = Me%WorkSize%KUB

        WaterPoints3D => Me%External_Var%WaterPoints3D
        OpenPoints3D  => Me%External_Var%OpenPoints3D

        !Gets Compute time step
        call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR01'

        Me%Emersion%TotalSimulationTime = Me%Emersion%TotalSimulationTime +  DT

        do  j = WorkJLB, WorkJUB
        do  i = WorkILB, WorkIUB

            if (WaterPoints3D(i, j, WorkKUB) == Covered) then
                if (OpenPoints3D(i, j, WorkKUB) == Covered) then
                    Me%Emersion%ImmersionTime (i,j) =  Me%Emersion%ImmersionTime(i,j) + DT
                else
                    Me%Emersion%EmersionTime(i,j)   =  Me%Emersion%EmersionTime(i,j)  + DT
                endif
            endif

        enddo
        enddo

        nullify(WaterPoints3D, OpenPoints3D)

    end subroutine ComputeEmersionTime

    !----------------------------------------------------------------------

    subroutine ComputeSystemEnergy !Frank Out99

        !Local-----------------------------------------------------------------
        real(8)                                     :: KineticEnergy,   TotalKineticEnergy        !*, ecin
        real(8)                                     :: BarotropicKineticEnergy,   TotalBarotropicKineticEnergy
        real(8)                                     :: BaroclinicKineticEnergy,   TotalBaroclinicKineticEnergy
        real(8)                                     :: PotentialEnergy, TotalPotentialEnergy      !potmat, epot
!        real(8)                                     :: APE, TotalAPE
!        real(8)                                     :: GPE, TotalGPE
        real(8)                                     :: Vorticity, TotalEnstrophy
        real(8)                                     :: Mass,            TotalMass                 !rmassa, rmtot
        real(8)                                     :: Volume,          TotalVolume, OpenVolume
        real(8)                                     :: TotalLevelArea, TotalArea, Area
        real(8)                                     :: Velocity2, AuxVel
        real                                        :: Year, Month, Day, Hour, Minute, Second
        real(8)                                     :: VelMaxBaroclinic, VelMax, BaroclinicU, BaroclinicV
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: i, j, k, iBuffer
        integer, dimension(:, :, :), pointer        :: WaterPoints3D
        integer, dimension(:, :, :), pointer        :: OpenPoints3D
        integer, dimension(:, :   ), pointer        :: BoundaryPoints
        real, dimension(:, :, :),    pointer        :: Density, SZZ, DWZ
        real(8), dimension(:, :, :), pointer        :: VolumeZ
        !real, dimension(:,:),        pointer        :: Bathymetry
        real, dimension(:,:),        pointer        :: DUX, DVY
        real, dimension(:,:),        pointer        :: DZX, DZY
        real, dimension(:,:),        pointer        :: WaterColumnZ
!        real, dimension(:, :, :),    pointer    :: S,T
!        real(8)                                 :: MinusOnePercentS, A, TotalA,Smin,Smax
!        real(8)                                 :: rho_p, rho
        character(len=256)                          :: String256
        integer                                     :: CHUNK

        !Begin --------------------------------------------------------------------------

        !A if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")

        if (Me%CurrentTime >= Me%Energy%NextOutPut) then

            Me%Energy%NextOutPut = Me%Energy%NextOutPut + Me%Energy%DtOut


            !Size
            IUB     = Me%Size%IUB
            ILB     = Me%Size%ILB
            JUB     = Me%Size%JUB
            JLB     = Me%Size%JLB
            KUB     = Me%Size%KUB
            KLB     = Me%Size%KLB

            !WorkSize
            WorkILB = Me%Energy%Window%ILB
            WorkIUB = Me%Energy%Window%IUB
            WorkJLB = Me%Energy%Window%JLB
            WorkJUB = Me%Energy%Window%JUB
            WorkKLB = Me%Energy%Window%KLB
            WorkKUB = Me%Energy%Window%KUB

            !Gets a pointer to the bathymetry
            !call GetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            !if (STAT_CALL /= SUCCESS_) stop 'ComputeSystemEnergy - ModuleHydrodynamic - ERR00'

            !Shorten variable names
            WaterPoints3D => Me%External_Var%WaterPoints3D
            OpenPoints3D  => Me%External_Var%OpenPoints3D
            BoundaryPoints=> Me%External_Var%BoundaryPoints
            Density       => Me%External_Var%Density
            VolumeZ       => Me%External_Var%Volume_Z_New
            SZZ           => Me%External_Var%SZZ
            DWZ           => Me%External_Var%DWZ
            DUX           => Me%External_Var%DUX
            DVY           => Me%External_Var%DVY
            DZX           => Me%External_Var%DZX
            DZY           => Me%External_Var%DZY
            WaterColumnZ  => Me%External_Var%WaterColumn

            call CenterVelocity(CenterU = Me%Energy%CenterU, CenterV = Me%Energy%CenterV, VectorType = CurrentVelocity)

            call SetMatrixValue(Me%Energy%CenterW, Me%Size, 0.)

            CHUNK = CHUNK_J(WorkJLB, WorkJUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")
            endif

            !$OMP PARALLEL PRIVATE(i,j,k)
            do k = WorkKLB, WorkKUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB
                if (k == WorkKLB) then
                    Me%Energy%CenterW(i, j, k) =  Me%Velocity%Vertical%Cartesian(i, j, k+1) / 2.
                elseif (k == WorkKUB) then
                    Me%Energy%CenterW(i, j, k) =  Me%Velocity%Vertical%Cartesian(i, j, k  ) / 2.
                else
                    Me%Energy%CenterW(i, j, k) = (Me%Velocity%Vertical%Cartesian(i, j, k+1) + &
                                                  Me%Velocity%Vertical%Cartesian(i, j, k  )) / 2.
                endif
            enddo
            enddo
            !$OMP END DO
            enddo
            !$OMP END PARALLEL

            !Inits variables
            TotalKineticEnergy   = 0.d0
            TotalPotentialEnergy = 0.d0
            TotalBarotropicKineticEnergy = 0.d0
            TotalBaroclinicKineticEnergy = 0.d0
            TotalEnstrophy = 0.d0
            TotalMass            = 0.d0
            TotalVolume          = 0.d0
!            TotalAPE             = 0.d0

            OpenVolume           = 0.d0
            TotalLevelArea       = 0.d0
            TotalArea            = 0.d0
!            TotalA               = 0.d0

            VelMax               = -99
            VelMaxBaroclinic     = -99

            !$OMP PARALLEL PRIVATE(i,j,k,Mass,Volume,BarotropicKineticEnergy)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK) &
            !$OMP REDUCTION(+:TotalBarotropicKineticEnergy)
            !ACanas(2010): REDUCTION clause has not found to produce rounding
            !ACanas(2010): errors in cases tested, perhaps due to operating in
            !ACanas(2010): variables with large values.

            !Calculates de barotropic velocity
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB

                Me%Energy%BarotropicU(i, j) = 0.
                Me%Energy%BarotropicV(i, j) = 0.
                Mass                        = 0.

                if (WaterPoints3D(i, j, WorkKUB) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then

                    do k = WorkKLB, WorkKUB

                        if (WaterPoints3D(i, j, k) == WaterPoint) then

                            Volume    = VolumeZ(i, j, k)
                            Mass      = Mass + Density(i, j, k) * Volume

                            Me%Energy%BarotropicU(i, j) = Me%Energy%BarotropicU(i, j) + &
                                                          Me%Energy%CenterU(i, j, k)  * &
                                                          DWZ(i, j, k) / WaterColumnZ(i, j)
                            Me%Energy%BarotropicV(i, j) = Me%Energy%BarotropicV(i, j) + &
                                                          Me%Energy%CenterV(i, j, k)  * &
                                                          DWZ(i, j, k) / WaterColumnZ(i, j)

                        endif
                    enddo

                    BarotropicKineticEnergy      = (Me%Energy%BarotropicU(i, j)**2  + &
                                                    Me%Energy%BarotropicV(i, j)**2) * Mass
                    TotalBarotropicKineticEnergy = TotalBarotropicKineticEnergy + BarotropicKineticEnergy

                endif
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            TotalBarotropicKineticEnergy = 0.5 * TotalBarotropicKineticEnergy

            CHUNK = CHUNK_I(WorkILB, WorkIUB)

            !Calculates Kinetic Energy and Potential Energy of all the sistem
            do i = WorkILB, WorkIUB
            do j = WorkJLB, WorkJUB
            do k = WorkKLB, WorkKUB

                if (WaterPoints3D(i, j, k) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then

                    Volume      = VolumeZ(i, j, k)
                    Mass        = Density(i, j, k) * Volume

                    TotalVolume = TotalVolume + Volume
                    TotalMass   = TotalMass   + Mass

                    if (OpenPoints3D(i, j, k) == OpenPoint) then
                        Velocity2 = Me%Energy%CenterU(i, j, k)**2. + Me%Energy%CenterV(i, j, k)**2. + &
                                    Me%Energy%CenterW(i, j, k)**2.
                        AuxVel = sqrt(Velocity2)

                        if (AuxVel > VelMax) VelMax = AuxVel


                        KineticEnergy        = Mass * Velocity2
                        TotalKineticEnergy   = TotalKineticEnergy + KineticEnergy


                        BaroclinicU = Me%Energy%CenterU(i, j, k) - Me%Energy%BarotropicU(i, j)
                        BaroclinicV = Me%Energy%CenterV(i, j, k) - Me%Energy%BarotropicV(i, j)

                        Velocity2 = BaroclinicU**2.       + &
                                    BaroclinicV**2.       + &
                                    Me%Energy%CenterW(i, j, k)**2.
                        AuxVel = sqrt(Velocity2)

                        if (AuxVel > VelMaxBaroclinic) VelMaxBaroclinic = AuxVel

                        BaroclinicKineticEnergy        = Mass * Velocity2
                        TotalBaroclinicKineticEnergy   = TotalBaroclinicKineticEnergy + BaroclinicKineticEnergy

                    endif

                    !PotentialEnergy      = Mass * Gravity * (Bathymetry(i, j) - (SZZ(i, j, k) + DWZ(i, j, k)/2.))
                    !Potential energy compute relatively to hydrographic zero

                    ![M*L/T^2*L]        =  [M] * [L/T^2]*[L]
                    PotentialEnergy      = Mass * Gravity * (- SZZ(i, j, k) - DWZ(i, j, k)/2.)


                    if (Me%NonHydrostatic%ON) then
                        ![M*L/T^2*L]    = [M*L/T^2*L]     + [M] * [L^2/T^2]
                        PotentialEnergy = PotentialEnergy + Mass * Me%NonHydroStatic%PressureCorrect(i, j, k)
                    endif
                    TotalPotentialEnergy = TotalPotentialEnergy + PotentialEnergy

                    !Calculates the available potential energy
!                    rho_p = SigmaUNESCO(S(i,j,k),T(i,j,k))
!                    rho   = SigmaUNESCO(S(i,j,k+1),T(i,j,k+1))
!                    APE = (rho_p - rho) * DWZ(i,j,k) * volume
!                    TotalAPE = TotalAPE + APE

                    !GravitationalPotentialEnergy
!                    GPE = Mass / (MeanRadius_ - SZZ(i,j,k) - 0.5 * DWZ(i,j,k))
!                    TotalGPE = TotalGPE + GPE

                    !To calculate the graph Level/Volume
                    if (OpenPoints3D(i, j, k) == OpenPoint) then
                        OpenVolume  = OpenVolume  + Volume
                        if (k == WorkKUB) then
                            Area            = DUX(i, j) * DVY(i, j)
                            TotalLevelArea  = TotalLevelArea  + Me%WaterLevel%New(i, j) * Area
                            TotalArea       = TotalArea + Area
                        endif
                    endif

                endif

            enddo
            enddo
            enddo

            TotalKineticEnergy              = 0.5 * TotalKineticEnergy
            TotalBaroclinicKineticEnergy    = 0.5 * TotalBaroclinicKineticEnergy
            TotalPotentialEnergy            = TotalPotentialEnergy
!            TotalAPE = 0.5 * Gravity * TotalAPE
!            TotalGPE = mu_ * TotalGPE

!            Smin = 39.
!            Smax = 0.
!            do i = WorkILB, WorkIUB
!            do j = WorkJLB, WorkJUB
!            do k = WorkKLB, WorkKUB

!                if (WaterPoints3D(i, j, k) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then

!                    if ( Smax .lt. S(i,j,k)) then
!                        Smax = S(i,j,k)
!                    endif

!                    if ( Smin .gt. S(i,j,k)) then
!                        Smin = S(i,j,k)
!                    endif

!                endif

!            enddo
!            enddo
!            enddo

!            MinusOnePercentS = 0.d0
!            do i = WorkILB, WorkIUB
!            do j = WorkJLB, WorkJUB

!                if (WaterPoints3D(i, j, WorkKUB) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then

!                    A = DUX(i, j) * DVY(i, j)
!                    MinusOnePercentS = MinusOnePercentS + S(i,j,WorkKUB) * A
!                    TotalA = TotalA + A

!                endif

!            enddo
!            enddo
!            MinusOnePercentS = MinusOnePercentS * .99d0 / TotalA

!            TotalA = 0.d0
!            do i = WorkILB, WorkIUB
!            do j = WorkJLB, WorkJUB

!                if (WaterPoints3D(i, j, WorkKUB) == WaterPoint .and. BoundaryPoints(i,j) /= Boundary) then

!                    if ( S(i,j,WorkKUB) .lt. MinusOnePercentS ) then
!                        A = DUX(i, j) * DVY(i, j)
!                       TotalA = TotalA + A
!                    endif

!                endif

!            enddo
!            enddo

            !Computes the Enstrophy

            CHUNK = CHUNK_J(WorkJLB, WorkJUB)

            !$OMP PARALLEL PRIVATE(i,j,k,Vorticity,Volume)
dok:        do k = WorkKLB, WorkKUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK) REDUCTION(+:TotalEnstrophy)
doj:        do j = WorkJLB, WorkJUB
doi:        do i = WorkILB, WorkIUB

                Vorticity = 0
                Volume    = VolumeZ(i, j, k)

cd1:            if (WaterPoints3D(i-1, j  ,k)== WaterPoint .and.                &
                    WaterPoints3D(i  , j  ,k)== WaterPoint) then

                    Vorticity = - (Me%Energy%CenterU(i, j, k) - Me%Energy%CenterU(i-1, j, k)) / DZY(i-1,j)

                endif cd1

cd2:            if (WaterPoints3D(i  , j  ,k)== WaterPoint .and.                &
                    WaterPoints3D(i  , j-1,k)== WaterPoint) then

                    Vorticity =  Vorticity + &
                                (Me%Energy%CenterV(i, j, k) - Me%Energy%CenterV(i , j-1, k)) / DZX(i,j-1)

                endif cd2

                TotalEnstrophy = TotalEnstrophy + Volume * Vorticity**2.

            enddo doi
            enddo doj
            !$OMP END DO
            enddo dok
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")
            endif

            ! TotalEnstrophy = 0.5 * TotalEnstrophy



            if (Me%Energy%FirstTime) then

                !Gets the current simulation time
                call ExtractDate(Me%BeginTime,                &
                             Year   = Year,   Month = Month,  &
                             Day    = Day,    Hour  = Hour,   &
                             Minute = Minute, Second= Second)

                Me%Energy%FirstTime = .false.

                !Stores the energy of the first iteration as reference
                Me%Energy%PotentialEnergyReference = TotalPotentialEnergy

                call WriteDataLine(Me%Energy%FileID, 'NAME'              , 'Energy' )
                call WriteDataLine(Me%Energy%FileID, 'LOCALIZATION_I'    , '-999999')
                call WriteDataLine(Me%Energy%FileID, 'LOCALIZATION_J'    , '-999999')
                call WriteDataLine(Me%Energy%FileID, 'LOCALIZATION_K'    , '-999999')
                call WriteDataLine(Me%Energy%FileID, 'SERIE_INITIAL_DATA', Me%BeginTime)
                call WriteDataLine(Me%Energy%FileID, 'TIME_UNITS        ', 'SECONDS')

                write (String256,'(A)')  'Seconds '                               // &
                                            'KEtotal PEtotal KE PE M V '          // &
                                            'OpenV Level BarotropicKE '           // &
                                            'BaroclinicKE VelMax VelMaxBaroclinic'// &
                                            ' Enstrophy'
                write (Me%Energy%FileID,'(A)') trim(adjustl(String256))
                write (Me%Energy%FileID,*)  '<BeginTimeSerie>'

            endif


            !Stores Data in a Buffer
            Me%Energy%BufferCount = Me%Energy%BufferCount + 1
            iBuffer = Me%Energy%BufferCount


            Me%Energy%SecondsBuffer(iBuffer)   = Me%CurrentTime - Me%BeginTime
            Me%Energy%RelativeKEBuffer(iBuffer)= TotalKineticEnergy / TotalMass
            Me%Energy%RelativePEBuffer(iBuffer)= (TotalPotentialEnergy -                &
                                                  Me%Energy%PotentialEnergyReference) / &
                                                  TotalMass
            !Me%Energy%RelativeKEBuffer(iBuffer)= TotalGPE
            !Me%Energy%RelativePEBuffer(iBuffer)= TotalAPE

            Me%Energy%KineticBuffer(iBuffer)   =   TotalKineticEnergy

            Me%Energy%PotentialBuffer(iBuffer) =   TotalPotentialEnergy - Me%Energy%PotentialEnergyReference

            Me%Energy%VorticityBuffer(iBuffer) =   TotalEnstrophy

            Me%Energy%MassBuffer(iBuffer)      =   TotalMass

            Me%Energy%VolumeBuffer(iBuffer)    =   TotalVolume

            if (TotalArea > 0) then
                Me%Energy%WaterLevelBuffer(iBuffer)=   TotalLevelArea / TotalArea
            else
                Me%Energy%WaterLevelBuffer(iBuffer)=   -99.
            endif

            Me%Energy%OpenVolumeBuffer(iBuffer)    =   OpenVolume


            Me%Energy%BarotropicKEBuffer    (iBuffer)  =  TotalBarotropicKineticEnergy / TotalMass
            Me%Energy%BaroclinicKEBuffer    (iBuffer)  =  TotalBaroclinicKineticEnergy / TotalMass

!            Me%Energy%BarotropicKEBuffer    (iBuffer)  =  Smin
!            Me%Energy%BaroclinicKEBuffer    (iBuffer)  =  Smax

           Me%Energy%VelMaxBuffer          (iBuffer)  =  VelMax
!            Me%Energy%VelMaxBuffer          (iBuffer)  =  TotalA
            Me%Energy%VelMaxBaroclinicBuffer(iBuffer)  =  VelMaxBaroclinic

            !If the buffer is full, writes the data file
            if (iBuffer == EnergyBufferSize) then
                call WriteEnergyDataFile
            endif

            !Disposes pointer to the Bathymetry
            !call UngetGridData(Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            !if (STAT_CALL /= SUCCESS_) stop 'ComputeSystemEnergy - ModuleHydrodynamic - ERR03'

            !Nullifies pointers
            nullify(WaterPoints3D, Density, VolumeZ, SZZ, DWZ)
            nullify(OpenPoints3D, BoundaryPoints)
            nullify(DUX, DVY)


        endif


        !A if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ComputeSystemEnergy")


    end subroutine ComputeSystemEnergy

    !--------------------------------------------------------------------------

    subroutine WriteEnergyDataFile !Frank Out99

        !Arguments-------------------------------------------------------------


        !Local
        integer                             :: iBuffer


        do iBuffer = 1, Me%Energy%BufferCount
            write(Me%Energy%FileID, fmt=100) Me%Energy%SecondsBuffer         (iBuffer), &
                                             Me%Energy%KineticBuffer         (iBuffer), &
                                             Me%Energy%PotentialBuffer       (iBuffer), &
                                             Me%Energy%RelativeKEBuffer      (iBuffer), &
                                             Me%Energy%RelativePEBuffer      (iBuffer), &
                                             Me%Energy%MassBuffer            (iBuffer), &
                                             Me%Energy%VolumeBuffer          (iBuffer), &
                                             Me%Energy%OpenVolumeBuffer      (iBuffer), &
                                             Me%Energy%WaterLevelBuffer      (iBuffer), &
                                             Me%Energy%BarotropicKEBuffer    (iBuffer), &
                                             Me%Energy%BaroclinicKEBuffer    (iBuffer), &
                                             Me%Energy%VelMaxBuffer          (iBuffer), &
                                             Me%Energy%VelMaxBaroclinicBuffer(iBuffer), &
                                             Me%Energy%VorticityBuffer       (iBuffer)

            100 format(1x, f16.4, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x,  &
                       e16.8, 1x, e16.8, 1x, e16.8, 1x, f12.6, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x, e16.8, 1x, e16.8)

        enddo
        Me%Energy%BufferCount = 0

    end subroutine WriteEnergyDataFile

    !--------------------------------------------------------------------------

    subroutine Write_HDF5_Format(iW)
        !Arguments-------------------------------------------------------------
        integer,    optional                :: iW

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL
        real, dimension(6), target          :: AuxTime
        real, dimension(:), pointer         :: TimePtr
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                             :: WorkKLB, WorkKUB, Index
        integer                             :: i, j, k, kbottom, ObjHDF5
        real, dimension(:, :, :), pointer   :: SZZ, DWZ   !flavio
        integer, dimension(:,:,:), pointer  :: WaterPoints3D, ComputeFaces3D_W ! flavio
        integer, dimension(:,:,:), pointer  :: OpenPoints3D
        integer, dimension(:,:),   pointer  :: KFloorZ
        character(len = StringLength)       :: AuxChar, AuxProp
        integer                             :: CHUNK
        logical                             :: SimpleOutPut
        type (T_Time)                       :: Aux
        real(8)                             :: AuxPeriod, TotalTime

        !----------------------------------------------------------------------

        SimpleOutPut = .false.

        !Bounds
        if (present(iW)) then

            WorkILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkIUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkJLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkJUB = Me%OutW%OutPutWindows(iW)%JUB

            WorkKLB = Me%OutW%OutPutWindows(iW)%KLB
            WorkKUB = Me%OutW%OutPutWindows(iW)%KUB

            ObjHDF5 = Me%OutW%ObjHDF5(iW)

            !Current output index
            Index   = Me%OutW%OutPutWindows(iW)%NextOutPut

            if (Me%OutW%Simple) SimpleOutPut = .true.

            if (Me%External_Var%BackTracking) then
                Index = Me%OutW%OutPutWindows(iW)%Number - Index + 1
            endif

        else

            WorkILB = Me%WorkSize%ILB
            WorkIUB = Me%WorkSize%IUB

            WorkJLB = Me%WorkSize%JLB
            WorkJUB = Me%WorkSize%JUB

            WorkKLB = Me%WorkSize%KLB
            WorkKUB = Me%WorkSize%KUB

            ObjHDF5 = Me%ObjHDF5

            !Current output index
            Index   = Me%OutPut%NextOutPut

            if (Me%External_Var%BackTracking) then
                Index = Me%OutPut%Number - Index + 1
            endif

            if (Me%OutPut%Simple) SimpleOutPut = .true.

        endif

        WaterPoints3D       => Me%External_Var%WaterPoints3D
        ComputeFaces3D_W    => Me%External_Var%ComputeFaces3D_W
        KFloorZ             => Me%External_Var%KFloor_Z
        OpenPoints3D        => Me%External_Var%OpenPoints3D

        SZZ                 => Me%External_Var%SZZ
        DWZ                 => Me%External_Var%DWZ

       if (Me%External_Var%BackTracking) then
            TotalTime = Me%EndTime      - Me%BeginTime
            AuxPeriod = Me%CurrentTime  - Me%BeginTime
            AuxPeriod = TotalTime       - AuxPeriod

            Aux = Me%BeginTime + AuxPeriod
        else
            Aux = Me%CurrentTime
        endif

        !Writes current time
        call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),                    &
                                 AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime
        call HDF5SetLimits  (ObjHDF5, 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR10'

        call HDF5WriteData  (ObjHDF5, "/Time", "Time", "YYYY/MM/DD HH:MM:SS",        &
                             Array1D = TimePtr, OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR20'

        if (Me%Generic4D%ON) then
            nullify(TimePtr)
            allocate(TimePtr(1))
            TimePtr(1) = Me%Generic4D%CurrentValue

            call HDF5SetLimits  (ObjHDF5, 1, 1, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR30'

            call HDF5WriteData  (ObjHDF5, "/Generic4D", "Generic4D", "-",        &
                                 Array1D = TimePtr, OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR40'
            deallocate(TimePtr)
            nullify(TimePtr)
        endif


        !Writes SZZ
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                        &
                             WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR50'

        call HDF5WriteData  (ObjHDF5, "/Grid/VerticalZ", "Vertical",                    &
                             "m", Array3D = SZZ, OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR60'

        call Write_HDF5_Format_3D_Corners(ObjHDF5 = ObjHDF5, OutputNumber = Index)


        !Writes OpenPoints
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                                 &
                             WorkJLB, WorkJUB, WorkKLB, WorkKUB,                        &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR70'

        call HDF5WriteData  (ObjHDF5, "/Grid/OpenPoints", "OpenPoints",                 &
                             "-", Array3D = OpenPoints3D, OutputNumber = Index,         &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR80'

        if (Me%ComputeOptions%Scraper) then
            call HDF5WriteData  (ObjHDF5, "/Grid/ScraperPosition", "ScraperPosition",      &
                                 "-", Array3D = Me%Scraper%Position, OutputNumber = Index, &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR90'
        endif


        if (Me%Output%Real4 .and. .not. present(iw)) then

        !Writes Waterlevel
            Me%OutPut%Aux2DReal4(:, :) = Me%WaterLevel%New(:,:) * Me%OutPut%WaterLevelUnits

            if      (Me%OutPut%WaterLevelUnits == 100.) then
                AuxChar = 'cm'
            else if (Me%OutPut%WaterLevelUnits == 1.  ) then
                AuxChar = 'm'
            endif

            call HDF5WriteData  (ObjHDF5,                                                   &
                                 "/Results/"//trim(GetPropertyName (WaterLevel_)),          &
                                 trim(GetPropertyName (WaterLevel_)), trim(AuxChar),        &
                                 Array2D = Me%OutPut%Aux2DReal4,                            &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR100'

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%CenterU)

            call HDF5WriteData  (ObjHDF5,                                                &
                                 "/Results/"//trim(GetPropertyName (VelocityU_)),           &
                                 trim(GetPropertyName (VelocityU_)),                        &
                                 "m/s", Array3D = Me%OutPut%AuxReal4,                       &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR101'

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%CenterV)

            call HDF5WriteData  (ObjHDF5,                                                &
                                 "/Results/"//trim(GetPropertyName (VelocityV_)),           &
                                 trim(GetPropertyName (VelocityV_)),                        &
                                 "m/s", Array3D =  Me%OutPut%AuxReal4,                      &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR102'

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%ModulusH)

            call HDF5WriteData  (ObjHDF5,                                                &
                                 "/Results/"//trim(GetPropertyName (VelocityModulus_)),     &
                                 trim(GetPropertyName (VelocityModulus_)),                  &
                                 "m/s", Array3D =  Me%OutPut%AuxReal4,                      &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR103'

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%CenterW)

            !Writes Velocity W
            call HDF5WriteData  (ObjHDF5,                                                   &
                                 "/Results/"//trim(GetPropertyName (VelocityW_)),           &
                                 trim(GetPropertyName (VelocityW_)), "m/s",                 &
                                 Array3D = Me%OutPut%AuxReal4,                              &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR104'
!--------------------------------------------------------------------------------------------------------------------------
        else

         !Writes Waterlevel
        Me%OutPut%Aux2D(:, :) = Me%WaterLevel%New(:,:) * Me%OutPut%WaterLevelUnits


        if      (Me%OutPut%WaterLevelUnits == 100.) then
            AuxChar = 'cm'
        else if (Me%OutPut%WaterLevelUnits == 1.  ) then
            AuxChar = 'm'
        endif

        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (WaterLevel_)),          &
                             trim(GetPropertyName (WaterLevel_)), trim(AuxChar),        &
                             Array2D = Me%OutPut%Aux2D,                                 &
                             OutputNumber = Index, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR105'

        if (Me%ComputeOptions%TideStateON) then
            call HDF5WriteData  (ObjHDF5,                                               &
                                 "/Results/"//trim(GetPropertyName (TideState_)),       &
                                 trim(GetPropertyName (TideState_)),"-",                &
                                 Array2D = Me%WaterLevel%TideState,                     &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR106'
        endif

        !Writes Velocity
        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (VelocityU_)),           &
                             trim(GetPropertyName (VelocityU_)),                        &
                             "m/s", Array3D = Me%OutPut%CenterU,                        &
                             OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR107'

        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (VelocityV_)),           &
                             trim(GetPropertyName (VelocityV_)),                        &
                             "m/s", Array3D =  Me%OutPut%CenterV,                       &
                             OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR108'

        !Writes Velocity modulus
        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (VelocityModulus_)),     &
                             trim(GetPropertyName (VelocityModulus_)),                  &
                             "m/s", Array3D =  Me%OutPut%ModulusH,                      &
                             OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR109'

        !Writes Velocity W
        call HDF5WriteData  (ObjHDF5,                                                   &
                             "/Results/"//trim(GetPropertyName (VelocityW_)),           &
                             trim(GetPropertyName (VelocityW_)), "m/s",                 &
                             Array3D = Me%OutPut%CenterW,                               &
                             OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR110'

        endif

! Modified by Matthias DELPEY - 20/07/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 27/07/2011 - 05/08/2011 - 25/10/2011 - 24/11/2011 - 02/03/2012

        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            ! GLM velocity  -----------------------------------------------------------------------
            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (GlmVelocityU_)),     &
                                trim(GetPropertyName (GlmVelocityU_)),                  &
                                "m/s", Array3D =  Me%Output%CenterUglm,                 &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190a'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (GlmVelocityV_)),     &
                                trim(GetPropertyName (GlmVelocityV_)),                  &
                                "m/s", Array3D =  Me%Output%CenterVglm,                 &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190b'

            call HDF5WriteData  (ObjHDF5,                                               &
                             "/Results/"//trim(GetPropertyName (GlmVelocityModulus_)),  &
                             trim(GetPropertyName (GlmVelocityModulus_)),               &
                             "m/s", Array3D =  Me%OutPut%ModulusHglm,                   &
                             OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR18c'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (GlmVelocityW_)),     &
                                trim(GetPropertyName (GlmVelocityW_)),                  &
                                "m/s", Array3D =  Me%Output%CenterWglm,                 &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190d'


            ! Stokes Drift velocity  --------------------------------------------------------------
            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (StokesDriftU_)),     &
                                trim(GetPropertyName (StokesDriftU_)),                  &
                                "m/s", Array3D =  Me%Output%CenterUstokes,              &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190e'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (StokesDriftV_)),     &
                                trim(GetPropertyName (StokesDriftV_)),                  &
                                "m/s", Array3D =  Me%Output%CenterVstokes,              &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190f'

            call HDF5WriteData  (ObjHDF5,                                               &
                             "/Results/"//trim(GetPropertyName (StokesDriftModulus_)),  &
                             trim(GetPropertyName (StokesDriftModulus_)),               &
                             "m/s", Array3D =  Me%OutPut%ModulusHstokes,                &
                             OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR18ff'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (StokesDriftW_)),     &
                                trim(GetPropertyName (StokesDriftW_)),                  &
                                "m/s", Array3D =  Me%Output%CenterWstokes,              &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190g'


            ! Wave induced pressure acceleration -----------------------------------------------
            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/WavePressureForceAccelU",                     &
                                "WavePressureForceAccelU",                              &
                                "m/s2", Array3D =  Me%Output%Wave3D_FPressureAccelU,    &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190h'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/WavePressureForceAccelV",                     &
                                "WavePressureForceAccelV",                              &
                                "m/s2", Array3D =  Me%Output%Wave3D_FPressureAccelV,    &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190i'


            ! Wave breaking induced acceleration ---------------------------------------------------
            if (Me%ComputeOptions%WaveForcing3D_Two == TauWalstra) then
                call HDF5WriteData  (ObjHDF5,                                           &
                                    "/Results/WaveBreakingForceAccelU",                 &
                                    "WaveBreakingForceAccelU",                          &
                                    "m/s2", Array3D =  Me%Output%Wave3D_FBreakingAccelU, &
                                    OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190j'

                call HDF5WriteData  (ObjHDF5,                                           &
                                    "/Results/WaveBreakingForceAccelV",                 &
                                    "WaveBreakingForceAccelV",                          &
                                    "m/s2", Array3D =  Me%Output%Wave3D_FBreakingAccelV, &
                                    OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190k'
            endif

            ! Wave vortex force induced acceleration -----------------------------------------------
            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/WaveVortexForceAccelU",                       &
                                "WaveVortexForceAccelU",                                &
                                "m/s2", Array3D =  Me%Output%Wave3D_FVortexAccelU,      &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190l'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/WaveVortexForceAccelV",                       &
                                "WaveVortexForceAccelV",                                &
                                "m/s2", Array3D =  Me%Output%Wave3D_FVortexAccelV,      &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190m'


        endif

        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (WaveRad3DX_)),       &
                                trim(GetPropertyName (WaveRad3DX_)),                    &
                                "m/s", Array3D =  Me%WaveRad3D%WaveExpRadU,             &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190g'

            call HDF5WriteData  (ObjHDF5,                                               &
                                "/Results/"//trim(GetPropertyName (WaveRad3DY_)),       &
                                trim(GetPropertyName (WaveRad3DY_)),                    &
                                "m/s", Array3D =  Me%WaveRad3D%WaveExpRadV,             &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190h'

        endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        if (Me%OutPut%Faces) then
            !Write velocity in faces
            !Set HDF5 limits to faces
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                          &
                                 WorkJLB, WorkJUB+1, WorkKLB, WorkKUB,                  &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR130'

            call HDF5WriteData  (ObjHDF5,                                            &
                                 "/Results/"//"FacesVelocityU",                         &
                                 "FacesVelocityU",                                      &
                                 "m/s", Array3D = Me%Velocity%Horizontal%U%New,         &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR140'

            !Set HDF5 limits to faces
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB+1,                        &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,                    &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR150'

            call HDF5WriteData  (ObjHDF5,                                            &
                                 "/Results/"//"FacesVelocityV",                         &
                                 "FacesVelocityV",                                      &
                                 "m/s", Array3D =  Me%Velocity%Horizontal%V%New,        &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR160'

            !Reset the HDF5 limits to cell center
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                          &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,                    &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR170'
        endif



        !Do statistics analysis
        if (.not. present(iW)) then
            call Statistics_OutPut(Me%OutPut%CenterU, Me%OutPut%CenterV, Me%OutPut%CenterW, &
                                   Me%OutPut%ModulusH, Me%WaterLevel%New)
        endif

        CHUNK = CHUNK_J(WorkJLB, WorkJUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "Write_HDF5_Format")
        endif

sp:     if (.not. SimpleOutPut) then

           !Writes YW         vorticity
           call HDF5WriteData  (ObjHDF5,                                                    &
                                "/Results/"//"Vorticity3D",                                 &
                                "Vorticity3D", "s-1",                                       &
                                Array3D = Me%OutPut%Vorticity3D,                            &
                                OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR190'


            call HDF5WriteData  (ObjHDF5,                                                   &
                                 "/Results/"//trim(GetPropertyName (WaterColumn_)),         &
                                 trim(GetPropertyName (WaterColumn_)), "m",                 &
                                 Array2D = Me%External_Var%WaterColumn,                     &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR105'

            if (Me%ComputeOptions%WaterLevelMaxMin) then

                Me%OutPut%WaterLevelMax(:, :) = Me%WaterLevel%Maxi     (:, :) * Me%OutPut%WaterLevelUnits
                Me%OutPut%WaterLevelMin(:, :) = Me%WaterLevel%Mini     (:, :) * Me%OutPut%WaterLevelUnits
                Me%OutPut%WaterLevelDif(:, :) = Me%OutPut%WaterLevelMax(:, :) - Me%OutPut%WaterLevelMin(:, :)

                AuxProp = trim(GetPropertyName (WaterLevel_))//"_Max"

                call HDF5WriteData  (ObjHDF5,                                           &
                                     "/Results/"//trim(AuxProp),                        &
                                     trim(AuxProp), trim(AuxChar) ,                     &
                                     Array2D = Me%OutPut%WaterLevelMax,                 &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR106'

                AuxProp = trim(GetPropertyName (WaterLevel_))//"_Min"

                call HDF5WriteData  (ObjHDF5,                                           &
                                     "/Results/"//trim(AuxProp),                        &
                                     trim(AuxProp), trim(AuxChar) ,                     &
                                     Array2D = Me%OutPut%WaterLevelMin,                 &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR107'

                AuxProp = trim(GetPropertyName (WaterLevel_))//"_Dif"

                call HDF5WriteData  (ObjHDF5,                                           &
                                     "/Results/"//trim(AuxProp),                        &
                                     trim(AuxProp), trim(AuxChar) ,                     &
                                     Array2D = Me%OutPut%WaterLevelDif,                 &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR108'

            endif


            if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then

                call SetMatrixValue(Me%OutPut%CenterWaux, Me%Size, FillValueReal)

                !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D (i  ,j  ,WorkKUB) == WaterPoint) then

                        kbottom = KFloorZ(i, j)

                        !By default the vertical velocity in the faces that are not compute is zero
                        Me%VelBaroclinic%W_New(i, j, kbottom : WorkKUB + 1) = &
                        Me%VelBaroclinic%W_New(i, j, kbottom : WorkKUB + 1) * &
                        ComputeFaces3D_W                   (i, j, kbottom : WorkKUB + 1)


                        do k = kbottom, WorkKUB

                            Me%OutPut%CenterWaux(i, j, k) = (Me%VelBaroclinic%W_New(i, j, k+1) +  &
                                                             Me%VelBaroclinic%W_New(i, j, k)) / 2.
                        enddo

                    endif

                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

                !Baroclinic Vertical Velocity
                call HDF5WriteData  (ObjHDF5, "/Results/Baroclinic/Z",                   &
                                     "B_Vel_Z", "m/s", Array3D = Me%OutPut%CenterWaux,      &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR230'


                !Baroclinic Horizontal Velocity
                call CenterVelocity(CenterU = Me%OutPut%CenterUaux, CenterV = Me%OutPut%CenterVaux, &
                                    VectorType = BaroclinicVelocity)


                call HDF5WriteData  (ObjHDF5, "/Results/Baroclinic/X",                   &
                                     "B_Vel_X", "m/s", Array3D = Me%OutPut%CenterUaux,      &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR240'


                call HDF5WriteData  (ObjHDF5, "/Results/Baroclinic/Y",                   &
                                     "B_Vel_Y", "m/s", Array3D = Me%OutPut%CenterVaux,      &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR250'
            endif

            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB
                Me%OutPut%Aux2D(i, j) = Me%Velocity%Vertical%Across(i, j, WorkKUB + 1)
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            call HDF5WriteData  (ObjHDF5, "/Results/Error",                             &
                                 "Error", "m/s", Array2D = Me%OutPut%Aux2D,             &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR300'

            call HDF5WriteData  (ObjHDF5, "/Results/velocity W Across",                 &
                                 "velocity W Across", "m/s", Array3D = Me%Velocity%Vertical%Across, &
                                 OutputNumber = Index, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR310'


            if (Me%TidePotential%Compute) then

                call HDF5WriteData  (ObjHDF5, "/Results/TidePotential",                  &
                                     "TidePotential", "m",                               &
                                     Array2D = Me%Forces%TidePotentialLevel,             &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR320'

            endif

            if (Me%NonHydroStatic%ON) then

                call HDF5WriteData  (ObjHDF5, "/Results/NonHydroStaticCorrection",      &
                                     "NonHydroStaticCorrection", "m^2/s^2",             &
                                     Array3D = Me%NonHydroStatic%PressureCorrect,       &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR330'

            endif


            if (Me%ComputeOptions%Baroclinic) then

                call HDF5SetLimits(ObjHDF5, WorkILB, WorkIUB,                            &
                                               WorkJLB, WorkJUB,                            &
                                               WorkKLB, WorkKUB,                            &
                                               STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR340'

                call CenterVelocity(CenterU = Me%OutPut%CenterUaux, CenterV = Me%OutPut%CenterVaux, &
                                    VectorType = BaroclinicForce)

                call HDF5WriteData  (ObjHDF5,                                            &
                                     "/Results/"//trim(GetPropertyName(BaroclinicForceX_)), &
                                     trim(GetPropertyName(BaroclinicForceX_)), "kg/m3",     &
                                     Array3D = Me%OutPut%CenterUaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR370'

                call HDF5WriteData  (ObjHDF5,                                            &
                                     "/Results/"//trim(GetPropertyName(BaroclinicForceY_)), &
                                     trim(GetPropertyName(BaroclinicForceY_)), "kg/m3",     &
                                     Array3D = Me%OutPut%CenterVaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR380'

            endif

            ! When using altimetry assimilation
            if (Me%ComputeOptions%AltimetryAssimilation%Yes) then

                call CenterVelocity(CenterU = Me%OutPut%CenterUaux, CenterV = Me%OutPut%CenterVaux, &
                                    VectorType = AltimGeostrophicVelocity)

                call HDF5WriteData  (ObjHDF5, "/Results/AltimGeostrophicVelocityU",      &
                                     "AltimGeostrophicVelocityU", "m/s",                    &
                                     Array3D = Me%OutPut%CenterUaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR430'

                call HDF5WriteData  (ObjHDF5, "/Results/AltimGeostrophicVelocityV",      &
                                     "AltimGeostrophicVelocityV", "m/s",                    &
                                     Array3D = Me%OutPut%CenterVaux,                        &
                                     OutputNumber = Index, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR440'

            endif

            if (Me%SubModel%ON) then

                call CenterVelocity(CenterU = Me%OutPut%CenterUaux, CenterV = Me%OutPut%CenterVaux, &
                                    VectorType = SubModelVelocity)

                call HDF5WriteData  (ObjHDF5, "/Results/SubModelVelocityU",             &
                                     "SubModelVelocityU", "m/s",                        &
                                     Array3D = Me%OutPut%CenterUaux,                    &
                                     OutputNumber = Index, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR442'

                call HDF5WriteData  (ObjHDF5, "/Results/SubModelVelocityV",             &
                                     "SubModelVelocityV", "m/s",                        &
                                     Array3D = Me%OutPut%CenterVaux,                    &
                                     OutputNumber = Index, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR444'

            endif

            if (Me%ComputeOptions%Level_Bottom_Anomaly) then

                !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                !Writes the bottom pressure anomaly converted to level (pressure/(density*gravity))
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB
                    if (WaterPoints3D (i  ,j  ,WorkKUB) == WaterPoint) then
                        kbottom = Me%External_Var%KFloor_Z(i, j)

                        if (Me%FirstIteration) then
                            Me%OutPut%Aux2D(i, j) = 0.
                        else
                            Me%OutPut%Aux2D(i, j) = 0.
                            do k = WorkKUB, kbottom, -1
                                Me%OutPut%Aux2D(i, j)= Me%OutPut%Aux2D(i, j) +              &
                                                       Me%External_Var%Density(i, j, k) *   &
                                                       Me%External_Var%DWZ(i, j, k)
                            enddo
                            Me%OutPut%Aux2D(i, j) = Me%OutPut%Aux2D(i, j) / SigmaDensityReference
                        endif
                    else
                        Me%OutPut%Aux2D(i, j) = FillValueReal
                    endif
                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

                call HDF5WriteData  (ObjHDF5, "/Results/bottom pressure",               &
                                     "bottom pressure", "m", Array2D = Me%OutPut%Aux2D, &
                                     OutputNumber = Index, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                        stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR480'
            endif



        endif sp


cd2:    if (Me%OutPut%Run_End) then

            if (.not. SimpleOutPut) then

                call HDF5WriteData  (ObjHDF5, "/Results/VolumeCreated",                 &
                                     "Volume Created", "m3",                            &
                                     Array2D = Me%WaterLevel%VolumeCreated,             &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ER36'

            endif

            !Residual Velocity
cd3:        if (Me%ComputeOptions%Residual) then

                call CenterVelocity(CenterU = Me%OutPut%CenterUaux, CenterV = Me%OutPut%CenterVaux, &
                                    VectorType = ResidualVelocity)

                !$OMP PARALLEL PRIVATE(i,j,k)

                !Calculates residual modulus
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D(i, j, k) == WaterPoint) then

                        Me%OutPut%ModulusUVaux(i,j,k)= sqrt(Me%OutPut%CenterUaux(i,j,k)*&
                                                            Me%OutPut%CenterUaux(i,j,k)+&
                                                            Me%OutPut%CenterVaux(i,j,k)*&
                                                            Me%OutPut%CenterVaux(i,j,k))

                    endif

                enddo
                enddo
                !$OMP END DO
                enddo
                !$OMP END PARALLEL

                call HDF5SetLimits(ObjHDF5, WorkILB, WorkIUB,                            &
                                               WorkJLB, WorkJUB,                            &
                                               WorkKLB, WorkKUB,                            &
                                               STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR530'

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/X",                &
                                     "Vel_X", "m/s", Array3D = Me%OutPut%CenterUaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR540'

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/Y",     &
                                     "Vel_Y", "m/s", Array3D = Me%OutPut%CenterVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR550'

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/Modulus",     &
                                     "Modulus", "m/s", Array3D = Me%OutPut%ModulusUVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR560'


                !Horizontal Residual Flux
                call CenterVelocity(CenterU = Me%OutPut%CenterUaux, CenterV = Me%OutPut%CenterVaux, &
                                    VectorType = ResidualFlux)

                !$OMP PARALLEL PRIVATE(i,j,k)

                !Calculates residual flux modulus
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D(i, j, k) == WaterPoint) then

                        Me%OutPut%ModulusUVaux(i,j,k)= sqrt(Me%OutPut%CenterUaux(i,j,k)*&
                                                            Me%OutPut%CenterUaux(i,j,k)+&
                                                            Me%OutPut%CenterVaux(i,j,k)*&
                                                            Me%OutPut%CenterVaux(i,j,k))

                    endif

                enddo
                enddo
                !$OMP END DO
                enddo

                !$OMP MASTER
                call HDF5WriteData  (ObjHDF5, "/Residual/Flux/X", &
                                     "Flux X", "m2/s", Array3D = Me%OutPut%CenterUaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR570'

                call HDF5WriteData  (ObjHDF5, "/Residual/Flux/Y", &
                                     "Flux Y", "m2/s", Array3D = Me%OutPut%CenterVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR580'

               call HDF5WriteData  (ObjHDF5, "/Residual/Flux/Modulus",     &
                                     "Modulus", "m/s", Array3D = Me%OutPut%ModulusUVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR590'
                !$OMP END MASTER
                !$OMP BARRIER

                !Calculates residual flux by area.  This a kind of conservative average velocity.
                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (WaterPoints3D(i, j, k) == WaterPoint) then

                        !Divide the specific residual flow interpolate for the cell
                        !center by the residual thickness
                        Me%OutPut%CenterUaux  (i, j, k) =  Me%OutPut%CenterUaux(i, j, k) / Me%Residual%DWZ(i, j, k)
                        Me%OutPut%CenterVaux  (i, j, k) =  Me%OutPut%CenterVaux(i, j, k) / Me%Residual%DWZ(i, j, k)
                        Me%OutPut%ModulusUVaux(i, j, k) = sqrt(Me%OutPut%CenterUaux(i,j,k)*Me%OutPut%CenterUaux(i,j,k) +         &
                                                               Me%OutPut%CenterVaux(i,j,k)*Me%OutPut%CenterVaux(i,j,k))

                    endif

                enddo
                enddo
                !$OMP END DO
                enddo
                !$OMP END PARALLEL

                call HDF5WriteData  (ObjHDF5, "/Residual/FluxVel/X",                 &
                                     "Flux X", "m/s", Array3D = Me%OutPut%CenterUaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR600'

                call HDF5WriteData  (ObjHDF5, "/Residual/FluxVel/Y",                 &
                                     "Flux Y", "m/s", Array3D = Me%OutPut%CenterVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR610'

                call HDF5WriteData  (ObjHDF5, "/Residual/FluxVel/Modulus",     &
                                     "Modulus", "m/s", Array3D = Me%OutPut%ModulusUVaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR620'

                call SetMatrixValue(Me%OutPut%CenterWaux, Me%Size, 0.)

                !$OMP PARALLEL PRIVATE(i,j,k)

                do k = WorkKLB, WorkKUB
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WorkJLB, WorkJUB
                do i = WorkILB, WorkIUB

                    if (k == WorkKLB) then
                        Me%OutPut%CenterWaux(i, j, k) =  Me%Residual%Vertical_Velocity(i, j, k+1) / 2.
                    elseif (k == WorkKUB) then
                        Me%OutPut%CenterWaux(i, j, k) =  Me%Residual%Vertical_Velocity(i, j, k  ) / 2.
                    else
                        Me%OutPut%CenterWaux(i, j, k) = (Me%Residual%Vertical_Velocity(i, j, k+1) +  &
                                                         Me%Residual%Vertical_Velocity(i, j, k  ))/ 2.
                    endif

                enddo
                enddo
                !$OMP END DO
                enddo
                !$OMP END PARALLEL

                call HDF5WriteData  (ObjHDF5, "/Residual/Velocity/Z",                &
                                     "Vel_Z", "m/s", Array3D = Me%OutPut%CenterWaux, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR650'

                !Residual Water Level
                call HDF5WriteData  (ObjHDF5, "/Residual/Waterlevel",                &
                                     "Lev_Z", "m", Array2D = Me%Residual%WaterLevel,    &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR670'

            endif cd3

            if (Me%ComputeOptions%EmersionTime)then

                !Emersion time
                call HDF5WriteData  (ObjHDF5, "/Emersion/EmersionTime",                                 &
                                     "EmersionTime", "s", Array2D = Me%Emersion%EmersionTime,           &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR671'

                !Immersion Time
                call HDF5WriteData  (ObjHDF5, "/Emersion/ImmersionTime",                                &
                                     "ImmersionTime", "s", Array2D = Me%Emersion%ImmersionTime,         &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR672'

                Me%Emersion%EmersionTime  = Me%Emersion%EmersionTime  / Me%Emersion%TotalSimulationTime * 100.0
                Me%Emersion%ImmersionTime = Me%Emersion%ImmersionTime / Me%Emersion%TotalSimulationTime * 100.0

                !Emersion percentage
                call HDF5WriteData  (ObjHDF5, "/Emersion/EmersionPercentage",                           &
                                     "EmersionPercentage", "%", Array2D = Me%Emersion%EmersionTime,     &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR673'

                !Emersion percentage
                call HDF5WriteData  (ObjHDF5, "/Emersion/ImmersionPercentage",                          &
                                     "ImmersionPercentage", "%", Array2D = Me%Emersion%ImmersionTime,   &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR674'

            endif


            if (.not. present(iW)) then
                call KillHydroStatistics
            endif

            call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_HDF5_Format - ModuleHydrodynamic - ERR680'

        else  cd2

            !Writes everything to disk
            call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Open_HDF5_OutPut_File - ModuleHydrodynamic - ERR690'

        endif cd2

        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "Write_HDF5_Format")
        endif

        !Nullify auxiliar variables
        nullify(SZZ             )
        nullify(DWZ             )
        nullify(WaterPoints3D   )
        nullify(KFloorZ         )
        nullify(ComputeFaces3D_W)
        nullify(OpenPoints3D    )


        !A if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Write_HDF5_Format")

    end subroutine Write_HDF5_Format

    !--------------------------------------------------------------------------

    subroutine Write_HDF5_Format_3D_Corners(ObjHDF5, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                             :: ObjHDF5, OutputNumber

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: WorkKLB, WorkKUB
        integer                             :: i, j, k, Coord_Type
        real                                :: n, AuxSum
        real(8), dimension(:,:,:), pointer  :: Aux3D
        real(8), dimension(:,:  ), pointer  :: Value2D
        integer, dimension(:,:  ), pointer  :: Map2D
        real,    dimension(:,:),   pointer  :: Latitude, Longitude, CornersX, CornersY, CornerMatrixX, CornerMatrixY


        !Begin-----------------------------------------------------------------

        if (OutputNumber == 1) then

            WorkILB = Me%WorkSize%ILB
            WorkIUB = Me%WorkSize%IUB
            WorkJLB = Me%WorkSize%JLB
            WorkJUB = Me%WorkSize%JUB
            WorkKLB = Me%WorkSize%KLB
            WorkKUB = Me%WorkSize%KUB



            allocate(Aux3D(WorkILB:WorkIUB+1, WorkJLB:WorkJUB+1, WorkKLB-1:WorkKUB))


            !Writes SZZ
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB+1, WorkJLB,                  &
                                 WorkJUB+1, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR10'
            endif

            call GetGridCoordType(Me%ObjHorizontalGrid, Coord_Type, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'Write_HDF5_Format_3D_Corners - Hydrodynamic - ERR12'

            if (Coord_Type == GRID_COORD_)then
                call GetCornersCoordinates(Me%ObjHorizontalGrid, CoordX = CornersX, CoordY = CornersY, STAT=STAT_CALL)
                CornerMatrixX => CornersX
                CornerMatrixY => CornersY

            else

                call GetGridLatitudeLongitude  (HorizontalGridID    = Me%ObjHorizontalGrid, &
                                                GridLatitudeConn    = Latitude,             &
                                                GridLongitudeConn   = Longitude,            &
                                                STAT                = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR20'
                endif
                CornerMatrixX => Longitude
                CornerMatrixY => Latitude
            endif

            do k = WorkKLB-1, WorkKUB

                Aux3D(WorkILB:WorkIUB+1, WorkJLB:WorkJUB+1,k) = CornerMatrixY(WorkILB:WorkIUB+1, WorkJLB:WorkJUB+1)

            enddo

            call HDF5WriteData (HDF5ID      = ObjHDF5,                                  &
                                GroupName   = "/Grid/Corners3D",                        &
                                Name        = "Latitude",                               &
                                Units       = "",                                      &
                                Array3D     = Aux3D,                                    &
                                !OutputNumber = OutputNumber,
                                STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR30'
            endif

            do k = WorkKLB-1, WorkKUB

                Aux3D(WorkILB:WorkIUB+1, WorkJLB:WorkJUB+1,k) = CornerMatrixX(WorkILB:WorkIUB+1, WorkJLB:WorkJUB+1)

            enddo

            call HDF5WriteData (HDF5ID      = ObjHDF5,                                  &
                                GroupName   = "/Grid/Corners3D",                        &
                                Name        = "Longitude",                              &
                                Units       = "",                                      &
                                Array3D     = Aux3D,                                    &
                                !OutputNumber = OutputNumber,
                                STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR40'
            endif

            Aux3D(:,:,:) = FillValueReal

            do k = WorkKLB-1, WorkKUB
            do i = WorkILB,   WorkIUB+1
            do j = WorkJLB,   WorkJUB+1
                n      = 0.
                AuxSum = 0.
                if (Me%External_Var%SZZ(i-1,j-1,k) > FillValueReal) then
                    AuxSum = AuxSum + Me%External_Var%SZZ(i-1,j-1,k)
                    n    = n + 1
                endif
                if (Me%External_Var%SZZ(i  ,j-1,k) > FillValueReal) then
                    AuxSum = AuxSum + Me%External_Var%SZZ(i  ,j-1,k)
                    n    = n + 1
                endif
                if (Me%External_Var%SZZ(i-1,j  ,k) > FillValueReal) then
                    AuxSum = AuxSum + Me%External_Var%SZZ(i-1,j  ,k)
                    n    = n + 1
                endif
                if (Me%External_Var%SZZ(i  ,j  ,k) > FillValueReal) then
                    AuxSum = AuxSum + Me%External_Var%SZZ(i  ,j  ,k)
                    n    = n + 1
                endif


                if (n > 0) then
                    Aux3D(i, j, k) = AuxSum/n
                else
                    Aux3D(i, j, k) = FillValueReal
                endif

            enddo
            enddo
            enddo

            ILB = WorkILB
            IUB = WorkIUB + 1
            JLB = WorkJLB
            JUB = WorkJUB + 1

            allocate(Value2D(ILB-1:IUB+1, JLB-1:JUB+1))
            allocate(Map2D  (ILB-1:IUB+1, JLB-1:JUB+1))

            Map2D  (:,:) = 1
            Value2D(:,:) = FillValueReal

    d1:     do k = WorkKUB, WorkKLB-1,-1

                Value2D(ILB:IUB,JLB:JUB) = Aux3D(ILB:IUB,JLB:JUB,k)

                call FillMatrix2D (ILB, IUB, JLB, JUB, Map2D, Value2D, FillGridMethod = ExtrapolNearstCell_)

                if (Value2D(ILB,JLB) > FillValueReal) then

                    Aux3D(ILB:IUB,JLB:JUB,k) = Value2D(ILB:IUB,JLB:JUB)

                else
                    Aux3D(ILB:IUB,JLB:JUB,k) = Aux3D(ILB:IUB,JLB:JUB,k+1)
                endif

            enddo d1

            deallocate(Value2D)
            deallocate(Map2D  )

            call HDF5WriteData (HDF5ID      = ObjHDF5,                                  &
                                GroupName   = "/Grid/Corners3D",                        &
                                Name        = "Vertical",                               &
                                Units       = "m",                                      &
                                Array3D     = Aux3D,                                    &
                                !OutputNumber = OutputNumber,
                                STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR50'
            endif


            call UnGetHorizontalGrid(HorizontalGridID   = Me%ObjHorizontalGrid,         &
                                     Array              = Latitude,                     &
                                     STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR60'
            endif

            call UnGetHorizontalGrid(HorizontalGridID   = Me%ObjHorizontalGrid,         &
                                     Array              = Longitude,                    &
                                     STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_HDF5_Format_3D_Corners - ModuleHydrodynamic - ERR70'
            endif

            deallocate(Aux3D)

        endif

    end subroutine Write_HDF5_Format_3D_Corners

    !--------------------------------------------------------------------------



    subroutine Write_Surface_HDF5_Format

        !Local-----------------------------------------------------------------
        integer                             :: NextSurfaceOutPut
        integer                             :: STAT_CALL
        real, dimension(6), target          :: AuxTime
        real, dimension(:), pointer         :: TimePtr
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                             :: WorkKLB, WorkKUB
        integer, dimension(:,:,:), pointer  :: OpenPoints3D
        real(8)                             :: AuxPeriod, TotalTime
        type (T_Time)                       :: Aux

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "Write_Surface_HDF5_Format")


        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB
        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB
        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        OpenPoints3D      => Me%External_Var%OpenPoints3D
        NextSurfaceOutPut =  Me%OutPut%NextSurfaceOutPut


        if (Me%External_Var%BackTracking) then
            NextSurfaceOutPut = Me%OutPut%NumberSurfaceOutputs - NextSurfaceOutPut + 1
        endif


        if (Me%External_Var%BackTracking) then
            TotalTime = Me%EndTime         - Me%BeginTime
            AuxPeriod = Me%CurrentTime     - Me%BeginTime
            AuxPeriod = TotalTime          - AuxPeriod

            Aux = Me%BeginTime + AuxPeriod
        else
            Aux = Me%CurrentTime
        endif

        !Writes current time
        call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),                    &
                            AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime

        call HDF5SetLimits  (Me%ObjSurfaceHDF5, 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR10'

        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Time",                                                   &
                             "Time", "YYYY/MM/DD HH:MM:SS",                             &
                             Array1D        = TimePtr,                                  &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR20'

        !Writes VerticalZ
        call HDF5SetLimits  (Me%ObjSurfaceHDF5, WorkILB, WorkIUB,                       &
                             WorkJLB, WorkJUB, WorkKUB-1, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR30'

        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Grid/VerticalZ",                                         &
                             "Vertical", "m",                                           &
                             Array3D        = Me%External_Var%SZZ,                      &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR40'


        !Writes OpenPoints
        call HDF5SetLimits  (Me%ObjSurfaceHDF5, WorkILB, WorkIUB,                       &
                             WorkJLB, WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR50'

        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Grid/OpenPoints",                                        &
                             "OpenPoints", "-",                                         &
                             Array3D        = OpenPoints3D,                             &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR51'

        if (Me%Output%Real4) then

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%CenterU)
        !surface velocity U
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (VelocityU_)),           &
                             trim(GetPropertyName (VelocityU_)), "m/s",                 &
                                 Array3D        = Me%OutPut%AuxReal4,                       &
                                 OutputNumber   = NextSurfaceOutPut,                        &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR52'

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%CenterV)
            !surface velocity V
            call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                                 "/Results/"//trim(GetPropertyName (VelocityV_)),           &
                                 trim(GetPropertyName (VelocityV_)), "m/s",                 &
                                 Array3D        = Me%OutPut%AuxReal4,                       &
                                 OutputNumber   = NextSurfaceOutPut,                        &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR53'

            call SetMatrixValue(Me%OutPut%AuxReal4, Me%Size, Me%OutPut%ModulusH)
            !Writes Velocity modulus
            call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                                 "/Results/"//trim(GetPropertyName (VelocityModulus_)),     &
                                 trim(GetPropertyName (VelocityModulus_)), "m/s",           &
                                 Array3D        = Me%OutPut%AuxReal4,                       &
                                 OutputNumber   = NextSurfaceOutPut,                        &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR54'

            call SetMatrixValue(Me%OutPut%Aux2DReal4, Me%Size2D, Me%WaterLevel%New)
            !Writes water level
            call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                                 "/Results/"//trim(GetPropertyName (WaterLevel_)),          &
                                 trim(GetPropertyName (WaterLevel_)), "m",                  &
                                 Array2D        = Me%OutPut%Aux2DReal4,                       &
                                 OutputNumber   = NextSurfaceOutPut,                        &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR60'

        else

            !surface velocity U
            call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                                 "/Results/"//trim(GetPropertyName (VelocityU_)),           &
                                 trim(GetPropertyName (VelocityU_)), "m/s",                 &
                             Array3D        = Me%OutPut%CenterU,                        &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR70'


        !surface velocity V
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (VelocityV_)),           &
                             trim(GetPropertyName (VelocityV_)), "m/s",                 &
                             Array3D        = Me%OutPut%CenterV,                        &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR80'

        !Writes Velocity modulus
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (VelocityModulus_)),     &
                             trim(GetPropertyName (VelocityModulus_)), "m/s",           &
                             Array3D        = Me%OutPut%ModulusH,                       &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR90'

        !Writes water level
        call HDF5WriteData  (Me%ObjSurfaceHDF5,                                         &
                             "/Results/"//trim(GetPropertyName (WaterLevel_)),          &
                             trim(GetPropertyName (WaterLevel_)), "m",                  &
                             Array2D        = Me%WaterLevel%New,                        &
                             OutputNumber   = NextSurfaceOutPut,                        &
                             STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR100'
        endif

        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Surface_HDF5_Format - ModuleHydrodynamic - ERR110'


        !Nullify auxiliar variables
        nullify(OpenPoints3D)

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "Write_Surface_HDF5_Format")

    end subroutine Write_Surface_HDF5_Format


    subroutine ModifyMatrixesOutput


        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k, kbottom
        integer                             :: CHUNK

        !----------------------------------------------------------------------

        !Bounds
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        !Horizontal Velocity
        call CenterVelocity( CenterU = Me%OutPut%CenterU, CenterV = Me%OutPut%CenterV,    &
                            VectorType = CurrentVelocity)

        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            call CenterVelocity( CenterU = Me%OutPut%CenterUstokes, CenterV = Me%OutPut%CenterVstokes,   &
                                 VectorType = StokesDriftVelocity)

            Me%OutPut%CenterUglm(:,:,:) = Me%OutPut%CenterU(:,:,:) + Me%OutPut%CenterUstokes(:,:,:)
            Me%OutPut%CenterVglm(:,:,:) = Me%OutPut%CenterV(:,:,:) + Me%OutPut%CenterVstokes(:,:,:)

            call CenterVelocity( CenterU = Me%OutPut%Wave3D_FPressureAccelU,      &
                                    CenterV = Me%OutPut%Wave3D_FPressureAccelV,      &
                                 VectorType = WavePressureForceAccel)

            call CenterVelocity( CenterU = Me%OutPut%Wave3D_FVortexAccelU,        &
                                    CenterV = Me%OutPut%Wave3D_FVortexAccelV,        &
                                 VectorType = WaveVortexForceAccel)

            if (Me%ComputeOptions%WaveForcing3D_Two == TauWalstra) then
                call CenterVelocity( CenterU = Me%OutPut%Wave3D_FBreakingAccelU,  &
                                        CenterV = Me%OutPut%Wave3D_FBreakingAccelV,  &
                                     VectorType = WaveBreakingForceAccel)
            endif

        endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "ModifyMatrixesOutput")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom)

        do k = KLB, KUB
        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%External_Var%WaterPoints3D (i,j ,k) == WaterPoint) then

                Me%OutPut%ModulusH  (i, j, k) = abs(cmplx(Me%OutPut%CenterU(i, j, k), Me%OutPut%CenterV(i, j, k)))
                if (Me%OutPut%ModulusH  (i, j, k) > 0.) then
                    Me%OutPut%DirectionH(i, j, k) = atan2(Me%OutPut%CenterV(i, j, k), Me%OutPut%CenterU(i, j, k))
                else
                    Me%OutPut%DirectionH(i, j, k) = 0.
                endif

                Me%OutPut%DirectionH(i, j, k) = Me%OutPut%DirectionH(i, j, k) * 180. / Pi
                !Instituto Hidrografico convention
                Me%OutPut%DirectionH(i, j, k) = - Me%OutPut%DirectionH(i, j, k) + 90.
                if (Me%OutPut%DirectionH(i, j, k) < 0.) then
                    Me%OutPut%DirectionH(i, j, k) = Me%OutPut%DirectionH(i, j, k) + 360.
                endif

                Me%OutPut%ModulusHglm   (i, j, k) = abs(cmplx(Me%OutPut%CenterUglm(i, j, k), Me%OutPut%CenterVglm(i, j, k)))
                Me%OutPut%ModulusHstokes(i, j, k) = abs(cmplx(Me%OutPut%CenterUstokes(i, j, k), &
                                                              Me%OutPut%CenterVstokes(i, j, k)))
            end if

        enddo
        enddo
        !$OMP END DO NOWAIT
        enddo

        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if (Me%External_Var%WaterPoints3D (i  ,j  ,KUB) == WaterPoint) then

                kbottom = Me%External_Var%KFloor_Z(i, j)

                !By default the vertical velocity in the faces that are not compute is zero
                !Do not apply it to surface points (correction by Hernani Theias)
                !Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) = &
                !Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) * &
                !Me%External_Var%ComputeFaces3D_W(i, j, kbottom : KUB)

                do k = kbottom, KUB
                    Me%Velocity%Vertical%Cartesian (i, j, k) = &
                    Me%Velocity%Vertical%Cartesian (i, j, k) * &
                    Me%External_Var%ComputeFaces3D_W(i, j, k)
                enddo

                do k = kbottom, KUB

                    Me%OutPut%CenterW(i, j, k) = (Me%Velocity%Vertical%Cartesian(i, j, k+1) +  &
                                                  Me%Velocity%Vertical%Cartesian(i, j, k)) / 2.

                    if (Me%ComputeOptions%WaveForcing3D == GLM) then

                        Me%OutPut%CenterWstokes(i, j, k) = (Me%StokesVel%Vertical%Cartesian(i, j, k+1) +  &
                                                            Me%StokesVel%Vertical%Cartesian(i, j, k)) / 2.

                        Me%OutPut%CenterWglm(i, j, k) = Me%OutPut%CenterW(i, j, k) + Me%OutPut%CenterWstokes(i, j, k)
                        ! Me%OutPut%CenterWglm(i, j, k) = (Me%Velocity%Vertical%Across(i, j, k+1) +  &
                        !                                    Me%Velocity%Vertical%Across(i, j, k)) / 2.

                    endif

                enddo

            endif

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if ( .NOT. Me%OutPut%Simple) then

            do j = JLB, JUB
            do i = ILB, IUB
                if (Me%External_Var%WaterPoints3D (i  ,j  ,KUB) == WaterPoint) then
                    kbottom = Me%External_Var%KFloor_Z(i, j)
                    !By default the vertical velocity in the faces that are not compute is zero
                    !Do not apply it to surface points (correction by Hernani Theias)
                    !Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) = &
                    !Me%Velocity%Vertical%Cartesian (i, j, kbottom : KUB) * &
                    !Me%External_Var%ComputeFaces3D_W(i, j, kbottom : KUB)

                    do k = kbottom, KUB
                        Me%Velocity%Vertical%Cartesian (i, j, k) = &
                        Me%Velocity%Vertical%Cartesian (i, j, k) * &
                        Me%External_Var%ComputeFaces3D_W(i, j, k)
                    enddo


                    do k = kbottom, KUB
                        Me%OutPut%Vorticity3D(i, j, k) = 0.

                        !dw/dy
                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                        0.5*(Me%OutPut%CenterW(i, j, k) - Me%OutPut%CenterW(i-1, j, k) * &
                        Me%External_Var%WaterPoints3D (i-1,j,k))/ &
                        Me%External_Var%DZY(i-1, j)

                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                        0.5*(-Me%OutPut%CenterW(i, j, k) + Me%OutPut%CenterW(i+1, j, k) * &
                        Me%External_Var%WaterPoints3D (i+1,j,k))/ &
                        Me%External_Var%DZY(i, j)

                        !dw/dx
                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                        0.5*(Me%OutPut%CenterW(i, j, k) - Me%OutPut%CenterW(i, j-1, k) * &
                        Me%External_Var%WaterPoints3D (i,j-1,k))/ &
                        Me%External_Var%DZX(i, j-1)

                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     +   &
                        0.5*(-Me%OutPut%CenterW(i, j, k) + Me%OutPut%CenterW(i, j+1, k) * &
                        Me%External_Var%WaterPoints3D (i,j+1,k))/ &
                        Me%External_Var%DZX(i, j)

                        !dv/dz
                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(Me%OutPut%CenterV(i, j, k) - Me%OutPut%CenterV(i, j, k-1) * &
                        Me%External_Var%WaterPoints3D (i,j,k-1))/ &
                        Me%External_Var%DWZ(i, j, k)

                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(-Me%OutPut%CenterV(i, j, k) + Me%OutPut%CenterV(i, j, k+1) * &
                        Me%External_Var%WaterPoints3D (i,j,k+1))/ &
                        Me%External_Var%DWZ(i, j, k)

                        !du/dz
                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(Me%OutPut%CenterU(i, j, k) - Me%OutPut%CenterU(i, j, k-1) * &
                        Me%External_Var%WaterPoints3D (i,j,k-1))/ &
                        Me%External_Var%DWZ(i, j, k)

                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(-Me%OutPut%CenterU(i, j, k) + Me%OutPut%CenterU(i, j, k+1) * &
                        Me%External_Var%WaterPoints3D (i,j,k+1))/ &
                        Me%External_Var%DWZ(i, j, k)

                        !dv/dx
                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(Me%OutPut%CenterV(i, j, k) - Me%OutPut%CenterV(i, j-1, k) * &
                        Me%External_Var%WaterPoints3D (i,j-1,k))/ &
                        Me%External_Var%DZX(i, j-1)

                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(-Me%OutPut%CenterV(i, j, k) + Me%OutPut%CenterV(i, j+1, k) * &
                        Me%External_Var%WaterPoints3D (i,j+1,k))/ &
                        Me%External_Var%DZX(i, j)


                        !du/dy
                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(Me%OutPut%CenterU(i, j, k) - Me%OutPut%CenterU(i-1, j, k) * &
                        Me%External_Var%WaterPoints3D (i-1,j,k))/ &
                        Me%External_Var%DZY(i-1, j)

                        Me%OutPut%Vorticity3D(i, j, k) = Me%OutPut%Vorticity3D(i, j, k)     -   &
                        0.5*(-Me%OutPut%CenterU(i, j, k) + Me%OutPut%CenterU(i+1, j, k) * &
                        Me%External_Var%WaterPoints3D (i+1,j,k))/ &
                        Me%External_Var%DZY(i, j)

                    enddo
                endif
            enddo
            enddo
        endif


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "ModifyMatrixesOutput")

    end subroutine ModifyMatrixesOutput

    !--------------------------------------------------------------------------


    subroutine CenterVelocity( CenterU, CenterV, VectorType)

        !Arguments-------------------------------------------------------------
        real,    dimension(:, :, :), pointer              :: CenterU, CenterV
        integer                                           :: VectorType

        !Local-----------------------------------------------------------------
        real,    dimension(:, :, :), pointer              :: FaceVelocityU, FaceVelocityV
        real(8), dimension(:, :, :), pointer              :: FaceUDouble, FaceVDouble
        real                                              :: VelU, VelV, AngleX, AngleY
        integer                                           :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                           :: i, j, k
        logical                                           :: Simple, Double
        integer                                           :: CHUNK

        !Bounds
        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        AngleX = 0.
        AngleY = 0.

        Simple = .false.
        Double = .true.

        !Checks for the type of velocity to interpolate
        if (VectorType == CurrentVelocity) then

            FaceVelocityU => Me%Velocity%Horizontal%U%New
            FaceVelocityV => Me%Velocity%Horizontal%V%New

            Simple = .true.

! Modified by Matthias DELPEY - 25/10/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 25/11/2011
        elseif (VectorType == StokesDriftVelocity) then

            FaceVelocityU => Me%StokesVel%Horizontal%U%New
            FaceVelocityV => Me%StokesVel%Horizontal%V%New

            Simple = .true.

        elseif (VectorType == WaveBreakingForceAccel) then

            FaceVelocityU => Me%Forces%Wave3DExplicit_FBreakingAccelU
            FaceVelocityV => Me%Forces%Wave3DExplicit_FBreakingAccelV

            Simple = .true.

        elseif (VectorType == WaveVortexForceAccel) then

            FaceVelocityU => Me%Forces%Wave3DExplicit_FVortexAccelU
            FaceVelocityV => Me%Forces%Wave3DExplicit_FVortexAccelV

            Simple = .true.

        elseif (VectorType == WavePressureForceAccel) then

            FaceVelocityU => Me%Forces%Wave3DExplicit_FPressureAccelU
            FaceVelocityV => Me%Forces%Wave3DExplicit_FPressureAccelV

            Simple = .true.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        elseif (VectorType == BaroclinicVelocity) then

            FaceVelocityU => Me%VelBaroclinic%U%New
            FaceVelocityV => Me%VelBaroclinic%V%New

            Simple = .true.

        elseif (VectorType == ResidualVelocity) then

            FaceVelocityU => Me%Residual%Velocity_U
            FaceVelocityV => Me%Residual%Velocity_V

            Simple = .true.

        elseif (VectorType == ResidualFlux) then

            FaceUDouble => Me%Residual%WaterFlux_X
            FaceVDouble => Me%Residual%WaterFlux_Y


            Double = .true.

        elseif (VectorType == AltimGeostrophicVelocity) then

            FaceVelocityU => Me%Geostroph%U
            FaceVelocityV => Me%Geostroph%V

            Simple = .true.

        elseif (VectorType == BaroclinicForce) then

            FaceVelocityU => Me%Forces%Rox3X
            FaceVelocityV => Me%Forces%Rox3Y

            Simple = .true.

        elseif (VectorType == SubModelVelocity) then

            FaceVelocityU => Me%SubModel%U_New
            FaceVelocityV => Me%SubModel%V_New

            Simple = .true.

        else

            stop 'CenterVelocity - ModuleHydrodynamic - ERR00'

        endif

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleHydrodynamic", "CenterVelocity")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,AngleX,AngleY,VelU,VelV)

        !Interpolates CenterVelocities
        if (Me%External_Var%Distortion .and. Simple)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = Me%External_Var%RotationX(i, j)
                    AngleY = Me%External_Var%RotationY(i, j)

                    VelU = (FaceVelocityU(i, j, k)  +   FaceVelocityU(i, j+1, k)) / 2.

                    VelV = (FaceVelocityV(i, j, k)  +   FaceVelocityV(i+1, j, k)) / 2.
                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo


        elseif(Me%External_Var%Distortion .and. Double)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB


                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = Me%External_Var%RotationX(i, j)
                    AngleY = Me%External_Var%RotationY(i, j)

                    VelU = (FaceUDouble(i, j, k)  +  FaceUDouble(i, j+1, k)) / 2.

                    VelV = (FaceVDouble(i, j, k)  +  FaceVDouble(i+1, j, k)) / 2.

                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo


        elseif((.not. Me%External_Var%Distortion) .and. Simple)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = 0.
                    AngleY = Pi/2.

                    AngleX = AngleX + Me%External_Var%GridRotation
                    AngleY = AngleY + Me%External_Var%GridRotation

                    VelU = (FaceVelocityU(i, j, k)  +   FaceVelocityU(i, j+1, k)) / 2.

                    VelV = (FaceVelocityV(i, j, k)  +   FaceVelocityV(i+1, j, k)) / 2.

                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo

        elseif((.not. Me%External_Var%Distortion) .and. Double)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%External_Var%WaterPoints3D(i, j, k) == 1) then

                    AngleX = 0.
                    AngleY = Pi/2.


                    AngleX = AngleX + Me%External_Var%GridRotation
                    AngleY = AngleY + Me%External_Var%GridRotation

                    VelU = (FaceUDouble(i, j, k)  +  FaceUDouble(i, j+1, k)) / 2.

                    VelV = (FaceVDouble(i, j, k)  +  FaceVDouble(i+1, j, k)) / 2.

                else

                    VelU = 0.
                    VelV = 0.

                endif

                CenterU(i, j, k) = VelU * cos(AngleX) + VelV * cos(AngleY)
                CenterV(i, j, k) = VelU * sin(AngleX) + VelV * sin(AngleY)

            enddo
            enddo
            !$OMP END DO
            enddo

        endif

        !$OMP END PARALLEL


        if (MonitorPerformance) then
            call StopWatch ("ModuleHydrodynamic", "CenterVelocity")
        endif

        !Nullifies FaceVelocityU, FaceVelocityV
        nullify(FaceVelocityU, FaceVelocityV)
        nullify(FaceUDouble,   FaceVDouble)

    end subroutine CenterVelocity



    subroutine OutPut_TimeSeries

        !Arguments-------------------------------------------------------------


        !External--------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real                                    :: DepthLevel
        integer                                 :: STAT_CALL, TimeSerieNumber, dn, id, jd, kd
        logical                                 :: DepthON, IgnoreOK
        integer                                 :: IUB,ILB,JUB,JLB,KUB,KLB

        IUB = Me%WorkSize%IUB
        ILB = Me%WorkSize%ILB
        JUB = Me%WorkSize%JUB
        JLB = Me%WorkSize%JLB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB



        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "OutPut_TimeSeries")

        !Corrects if necessary the cell of the time serie based in the time serie depth
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR10'

        do dn = 1, TimeSerieNumber


            call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR20'

            if (IgnoreOK) cycle

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                      LocalizationI = id,                               &
                                      LocalizationJ = jd,                               &
                                      DepthLevel    = DepthLevel,                       &
                                      DepthON       = DepthON,                          &
                                      STAT          = STAT_CALL)
            if (DepthON) then

!                if (Id < 0 .or. Jd < 0) then

!                    call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
!                    if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR20'

!                    if (IgnoreOK) then
!                        cycle
!                    else
!                        stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR30'
!                    endif

!                endif

                kd = GetLayer4Level(Me%ObjGeometry, id, jd, DepthLevel, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR40'

                call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn,  k = kd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR50'

                if (Me%External_Var%WaterPoints3D(Id, JD, kd) /= WaterPoint .and. Me%FirstIteration) then

                    write(*,*) 'Time serie station I=',Id, 'J=',Jd,'K=',Kd,'is located in land'
                    write(*,*) 'OutPut_TimeSeries - ModuleHydrodynamic - WRN100'

                endif
            endif

        enddo


        !West-East Velocity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%CenterU,                                 &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR60'

        !South-North Velocity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%CenterV,                                 &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR65'


        !Vertical Velocity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%CenterW,                                 &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR66'

        !Horizontal Velocity intensity
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%ModulusH,                                &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR67'

        !Horizontal Velocity Direction
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D = Me%OutPut%DirectionH,                              &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR100'


        !Elevation
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data2D = Me%WaterLevel%New,                                 &
                            factor = Me%OutPut%WaterLevelUnits,                         &
                            STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR110'


       !Open Points
        call WriteTimeSerie(Me%ObjTimeSerie,                                            &
                            Data3D_Int = Me%External_Var%OpenPoints3D,                  &
                            STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleHydrodynamic - ERR120'


        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "OutPut_TimeSeries")


    end subroutine OutPut_TimeSeries

    !--------------------------------------------------------------------------

    subroutine OutputTimeSeries_FileOK(FileOk)
        !Local-----------------------------------------------------------
        integer                       :: STAT_CALL, TimeSerieNumber, dn
        type (T_Time)                 :: NextTimeOutput, NextTimeSerieOutput
        Logical                       :: FirstTime, FileOk

        !Begin-----------------------------------------------------------
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputTimeSeries_FileOK - ModuleHydrodynamic - ERR01'

        FirstTime = .false.
        FileOk    = .false.

        do dn = 1, TimeSerieNumber

            call GetTimeSerieNextOutput(Me%ObjTimeSerie, dn, NextTimeOutput, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutputTimeSeries_FileOK - ModuleHydrodynamic - ERR02'

            if (FirstTime) then
                NextTimeSerieOutput = NextTimeOutput
            else
                if (NextTimeOutput .ge. NextTimeSerieOutput) then
                    NextTimeSerieOutput = NextTimeOutput
                endif
            endif

        enddo

        if (Me%CurrentTime >= NextTimeSerieOutput) FileOk = .true.

    end subroutine OutputTimeSeries_FileOK

    !--------------------------------------------------------------------------

    subroutine OutPut_Profile

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleHydrodynamic", "OutPut_Profile")

        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%CenterU,                                    &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR01'

        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%CenterV,                                    &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR02'

        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%CenterW,                                    &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR03'


        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%ModulusH,                                   &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR04'

        call WriteProfile(Me%ObjProfile,                                        &
                          Me%OutPut%DirectionH,                                 &
                          SZZ    = Me%External_Var%SZZ,                         &
                          STAT   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Profile - ModuleHydrodynamic - ERR05'

        if (MonitorPerformance) call StopWatch ("ModuleHydrodynamic", "OutPut_Profile")


    end subroutine OutPut_Profile

    !--------------------------------------------------------------------------------------


    Real Function TangentialVelInterpolation(Velocity_VU_New, ComputeFaces3D_VU, &
                                             DXX_YY, di, dj, I, J, K)

        !Parameters variables
        real,    dimension(:,:,:), pointer  :: Velocity_VU_New
        real,    dimension(:,:  ), pointer  :: DXX_YY
        integer, dimension(:,:,:), pointer  :: ComputeFaces3D_VU
        integer                             :: di, dj, I, J, K

        !Local Variables
        real         :: Face1, Face2, Face3, Face4, Face12,  &
                        Face34, VUvar1, VUvar2, VUAverage
        integer      :: I1, I2, I3, J1, J2, J3


            I1    = I+dj-di
            J1    = J-dj+di
            I2    = I+dj
            J2    = J+di
            I3    = I-di
            J3    = J-dj



            !This aux variables are needed to the velocity_UV_New interpolation
            !be valid near the open boundary faces and near land faces

            Face1      = ComputeFaces3D_VU(I1, J1, K)

            Face2      = ComputeFaces3D_VU(I2, J2, K)

            Face3      = ComputeFaces3D_VU(I3, J3, K)

            Face4      = ComputeFaces3D_VU(I , J , K)

            ! Average velocity in the North or East face
            ! if Face1 = 0 => VUvar1 = Velocity_VU_New(I2, J2, K)
            ! Face1 = 0 (cell face where de Velocity_VU is not compute)

            Face12 = Covered

            if (Face1 == Covered .and. Face2 == Covered) then

                VUvar1 = (Velocity_VU_New(I1, J1, K) * DXX_YY(I2, J2) + &
                          Velocity_VU_New(I2, J2, K) * DXX_YY(I1, J1))/ &
                         (DXX_YY(I1, J1) +  DXX_YY(I2, J2))

            else if (Face1 == Covered) then

                VUvar1 = Velocity_VU_New(I1, J1, K)

            else if (Face2 == Covered) then

                VUvar1 = Velocity_VU_New(I2, J2, K)

            else

                VUvar1 = 0.

                Face12 = Not_Covered

            endif

            ! Average velocity in the South or West face
            ! if Face3 = 0 => VUvar2 = Velocity_VU_New(I4, J4, K)
            ! Face3 = 0 (cell face where de Velocity_VU is not compute)

            Face34 = Covered

            if (Face3 == Covered .and. Face4 == Covered) then


                VUvar2 = (Velocity_VU_New(I3, J3, K) * DXX_YY(I, J)   + &
                          Velocity_VU_New(I,   J, K) * DXX_YY(I3, J3))/ &
                         (DXX_YY(I3, J3) +  DXX_YY(I, J))

            else if (Face3 == Covered) then

                VUvar2 = Velocity_VU_New(I3, J3, K)

            else if (Face4 == Covered) then

                VUvar2 = Velocity_VU_New(I , J , K)

            else

                VUvar2 = 0.

                Face34 = Not_Covered

            endif


            ! Velocity V in the U point or Velocity U in the V point
            if (Face12 == Covered .and. Face34 == Covered) then

                VUAverage  = (VUvar1 + VUvar2)/2.

            else if (Face12 == Covered) then

                VUAverage  = VUvar1

            else if (Face34 == Covered) then

                VUAverage  = VUvar2

            else

                VUAverage  = 0.

            endif

            TangentialVelInterpolation = VUAverage

    End Function TangentialVelInterpolation

#ifdef OVERLAP

    subroutine GetHydroOverlap(HydrodynamicID, Overlap, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        logical                                     :: Overlap
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Overlap = Me%ComputeOptions%Overlap

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

    end subroutine GetHydroOverlap

    !--------------------------------------------------------------------------

    subroutine SetModelOverlapHydro(HydrodynamicID, OverlapHydrodynamicID, OverlapCells, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: OverlapHydrodynamicID
        integer, dimension(:,:),pointer             :: OverlapCells
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_, readyOverlap_
        type(T_Hydrodynamic),    pointer            :: ObjOverlapHydrodynamic
        integer                                     :: n, nOverlapCells, i, j, io, jo, k
        real                                        :: AuxWaterLevel, AuxU, AuxV

        !------------------------------------------------------------------------


        call Ready          (HydrodynamicID, ready_)

        call ReadyFather    (OverlapHydrodynamicID, ObjOverlapHydrodynamic, readyOverlap_)

cd1 :   if (ready_ .EQ. IDLE_ERR_ .and. readyOverlap_ .EQ. IDLE_ERR_) then

            nOverlapCells = size(OverlapCells, dim=1)

            do n = 1, nOverlapCells

                i   = OverlapCells(n, 1)
                j   = OverlapCells(n, 2)
                k   = 1
                io  = OverlapCells(n, 3)
                jo  = OverlapCells(n, 4)

                AuxWaterLevel                                    = Me%WaterLevel%New(i,j)

                !Me%Velocity%Horizontal%U%New(i,j,k)             = ObjOverlapHydrodynamic%Velocity%Horizontal%U%New(io,jo,k)
                Me%Velocity%Horizontal%V%New(i,j,k)              = ObjOverlapHydrodynamic%Velocity%Horizontal%V%New(io,jo,k)

                ObjOverlapHydrodynamic%WaterLevel%New(io,jo  )   = AuxWaterLevel
            enddo


            STAT_ = SUCCESS_
        else cd1

            STAT_ = ready_


        end if cd1

        if(present(STAT)) STAT = STAT_

    end subroutine SetModelOverlapHydro


#endif OVERLAP


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCT

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



    subroutine KillHydrodynamic(HydrodynamicID, STAT)

        !Arguments-------------------------------------------------------------
        integer,           intent(INOUT) :: HydrodynamicID
        integer, optional, intent(OUT)   :: STAT


        !Local-----------------------------------------------------------------

        integer :: STAT_, nUsers
        integer :: STAT_CALL
        integer :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ /= OFF_ERR_) then

            nUsers = DeassociateInstance(mHYDRODYNAMIC_,  Me%InstanceID)

cd2:        if (nUsers == 0) then

                !Time Properties - Actualises CurrentTime
                call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) &
                    stop 'KillHydrodynamic; ModuleHydrodynamic. ERR10.'

                !Write final HDF output if necessary
cd3:            if (Me%OutPut%hdf5ON) then

                    call ReadLock_External_Modules

                    if (.not. Me%OutPut%Run_End) then
                        !Output in HDF
                        Me%OutPut%Run_End = .true.
                        call Write_HDF5_Format

                    endif

                    if(Me%OutPut%FloodRisk)then
                        call OutputFloodRisk
                    endif

                    call ReadUnLock_External_Modules

                endif cd3

                if (Me%OutPut%HDF5_Surface_ON) then

                    call KillHDF5 (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR20'

                endif

                if (Me%OutPut%ProfileON) then

                    call ReadLock_External_Modules

                    call OutPut_Profile

                    call ReadUnLock_External_Modules

                endif

                if (Me%ComputeOptions%Evolution == Solve_Equations_) then

                    call Write_Final_Hydrodynamic_File

                endif

                call Deassociate_External_Modules

                call Kill_Sub_Modules

                if (Me%ComputeOptions%Evolution == ImposedSolution_) then
                    call Kill_Imposed_Solution
                endif

                call KillHighLowTideOutput

#ifdef _ENABLE_CUDA
                !Kills ModuleCuda
                call KillCuda (Me%ObjCuda, STAT = STAT_CALL)
                ! No need to give error yet, Module still has users
#endif _ENABLE_CUDA

                call KillDDecomp

                call DeallocateVariables

                call DeallocateInstance()

                HydrodynamicID = 0
                STAT_          = SUCCESS_

            end if cd2

        else

            STAT_ = UNKNOWN_

        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine KillHydrodynamic

    !--------------------------------------------------------------------------

    subroutine Kill_Imposed_Solution

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------

        integer :: STAT_CALL

        !----------------------------------------------------------------------


        if(Me%WaterLevel%ID%SolutionFromFile)then
            call KillFillMatrix(Me%WaterLevel%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR10'
        end if

        if (Me%ComputeOptions%TideStateON) then
            if (Me%WaterLevel%TideStateID%SolutionFromFile) then
                call KillFillMatrix(Me%WaterLevel%TideStateID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR20'
            endif
        endif

        if(Me%Velocity%Horizontal%U%ID%SolutionFromFile)then
            call KillFillMatrix(Me%Velocity%Horizontal%U%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR30'
        end if

        if(Me%Velocity%Horizontal%V%ID%SolutionFromFile)then
            call KillFillMatrix(Me%Velocity%Horizontal%V%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR40'
        end if

        if(Me%WaterLevel%ID_Astro%SolutionFromFile)then
            call KillFillMatrix(Me%WaterLevel%ID_Astro%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR50'
        end if

        if(Me%Velocity%Horizontal%U%ID_Astro%SolutionFromFile)then
            call KillFillMatrix(Me%Velocity%Horizontal%U%ID_Astro%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR60'
        end if

        if(Me%Velocity%Horizontal%V%ID_Astro%SolutionFromFile)then
            call KillFillMatrix(Me%Velocity%Horizontal%V%ID_Astro%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Kill_Imposed_Solution - ModuleHydrodynamic - ERR70'
        end if


    end subroutine Kill_Imposed_Solution

    !--------------------------------------------------------------------------
    ! The model writes the final hydrodynamic properties

    subroutine Write_Final_Hydrodynamic_File

        !Arguments-------------------------------------------------------------

        if      (Me%ComputeOptions%WriteContinuousFormat == Binary_) then
            call Write_Final_Bin
        elseif  (Me%ComputeOptions%WriteContinuousFormat == HDF5_  ) then
            call Write_Final_HDF5
        endif

    end subroutine Write_Final_Hydrodynamic_File

    !--------------------------------------------------------------------------
    ! The model writes the final hydrodynamic properties in a binary file

    subroutine Write_Final_Bin

        !Arguments-------------------------------------------------------------


        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------


        real               :: Year_File, Month_File, Day_File, &
                              Hour_File, Minute_File, Second_File

        integer            :: IUB, JUB, KUB, ILB, JLB, KLB
        integer            :: FinalFile, i, j, k
        character (Len = Pathlength)          :: filename

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB


        call UnitsManager(FinalFile, FileOpen, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR10.')

        !Checks if it's at the end of the run
        !or !if it's supposed to overwrite the final HDF file
        if (Me%Output%Run_End .or. Me%Output%RestartOverwrite) then

            filename = trim(Me%Files%FinalHydrodynamic)

        else

            filename =  ChangeSuffix(Me%Files%FinalHydrodynamic,                         &
                            "_"//trim(TimeToString(Me%CurrentTime))//".fin")

        endif

        open(Unit = FinalFile, File = trim(filename),           &
             Form = 'UNFORMATTED', status = 'UNKNOWN', IOSTAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR20.')

        !Time Properties - Actualizes CurrentTime
        call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR30.')



        !Start writting the final hydrodynamic conditions file

        call ExtractDate(Me%CurrentTime, Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File)

        write(FinalFile) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File

        !Write the discretization Method used
        write(FinalFile) Me%ComputeOptions%Num_Discretization


        write(FinalFile) Me%ComputeOptions%Residual

        !Write the last direction computed implicit by the model
        write(FinalFile) Me%Direction%XY


        !Water level
        write(FinalFile) ((Me%WaterLevel%New(i, j),                         &
                           i = ILB, IUB), j = JLB, JUB)


        !Horizontal velocity Old
        write(FinalFile) (((Me%Velocity%Horizontal%U%Old(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        write(FinalFile) (((Me%Velocity%Horizontal%V%Old(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        !Horizontal velocity New
        write(FinalFile) (((Me%Velocity%Horizontal%U%New(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        write(FinalFile) (((Me%Velocity%Horizontal%V%New(i, j, k),          &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        !Water fluxes
        write(FinalFile) (((Me%WaterFluxes%X(i, j, k),                      &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        write(FinalFile) (((Me%WaterFluxes%Y(i, j, k) ,                     &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        write(FinalFile) (((Me%WaterFluxes%Z(i, j, k),                      &
                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

cd1:    if (Me%ComputeOptions%Residual) then


            write(FinalFile) Me%Residual%ResidualTime

            !Average water level
            write(FinalFile) ((Me%Residual%WaterLevel(i, j),                &
                               i = ILB, IUB), j = JLB, JUB)

            !Residual horizontal velocities
            write(FinalFile) (((Me%Residual%Velocity_U(i, j, k),            &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            write(FinalFile) (((Me%Residual%Velocity_V(i, j, k),            &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual vertical velocity
            write(FinalFile) (((Me%Residual%Vertical_Velocity(i, j, k),     &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Residual Water specific fluxes
            write(FinalFile) (((Me%Residual%WaterFlux_X(i, j, k),           &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            write(FinalFile) (((Me%Residual%WaterFlux_Y(i, j, k) ,          &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


        endif cd1

        call WriteGeometryBin(Me%ObjGeometry, FinalFile, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR40.')

cd2:    if (Me%ComputeOptions%Residual) then

            !Residual layer thickness
            write(FinalFile) (((Me%Residual%DWZ(i, j, k),                   &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        endif cd2

        write(FinalFile) Me%ComputeOptions%BaroclinicRadia

cd4:    if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then


            !Horizontal baroclinic velocity Old
            write(FinalFile) (((Me%VelBaroclinic%U%Old(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            write(FinalFile) (((Me%VelBaroclinic%V%Old(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Horizontal baroclinic velocity New
            write(FinalFile) (((Me%VelBaroclinic%U%New(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            write(FinalFile) (((Me%VelBaroclinic%V%New(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !vertical baroclinic velocity
            write(FinalFile) (((Me%VelBaroclinic%W_New(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            write(FinalFile) (((Me%VelBaroclinic%W_Old(i, j, k),            &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

        endif cd4


        if (Me%NonHydrostatic%ON) then

            write(FinalFile) (((Me%Velocity%Vertical%CartesianOld(i, j, k), &
                                           i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        endif

        !Submodel
        if (Me%SubModel%ON) then

            write(FinalFile, IOSTAT = STAT_CALL)                                        &
                (((Me%SubModel%qX(i, j, k),                                             &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR50.')
            endif

            write(FinalFile, IOSTAT = STAT_CALL)                                        &
                (((Me%SubModel%qY(i, j, k),                                             &
                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            if (STAT_CALL /= SUCCESS_) then
                call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR60.')
            endif

        endif


        call UnitsManager(FinalFile, FileClose, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                        &
            call SetError (FATAL_, INTERNAL_,'Write_Final_Bin; ModuleHydrodynamic. ERR70.')


    end subroutine Write_Final_Bin

    !End--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! The model writes the final hydrodynamic properties in a HDF5
    subroutine Write_Final_HDF5

        !Arguments-------------------------------------------------------------



        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------
        real,       dimension(:,:),     pointer     :: Bathymetry
        integer,    dimension(:,:,:),   pointer     :: WaterPoints3D
        real,       dimension(6), target            :: AuxTime
        real,       dimension(:),       pointer     :: TimePtr
        integer                                     :: IUB, JUB, KUB, ILB, JLB, KLB
        integer                                     :: HDF5_CREATE, ObjHDF5
        integer,    dimension(:),       pointer     :: AuxInt
        real,       dimension(:),       pointer     :: AuxReal
        character (Len = Pathlength)                :: filename


        !----------------------------------------------------------------------

        allocate(AuxReal(1), AuxInt(1))

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB + 1

        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB + 1

        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB + 1


        !Checks if it's at the end of the run
        !or !if it's supposed to overwrite the final HDF file
        if (Me%Output%Run_End .or. Me%Output%RestartOverwrite) then

            filename = trim(Me%Files%FinalHydrodynamic)

        else

            filename =  ChangeSuffix(Me%Files%FinalHydrodynamic,                         &
                            "_"//trim(TimeToString(Me%CurrentTime))//".fin")

        endif


        !Gets a pointer to Bathymetry
        call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR20'

        !Gets WaterPoints3D
        call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR30'


        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        ObjHDF5 = 0

        !Opens HDF File
        call ConstructHDF5      (ObjHDF5,                                               &
                                 trim(FileName),                                        &
                                 HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR40'


        !Write the Horizontal Grid
        call WriteHorizontalGrid_UV(Me%ObjHorizontalGrid, ObjHDF5,                         &
                                    WorkSize = Me%WorkSize2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR50'

        !Sets limits for next write operations
        call HDF5SetLimits   (ObjHDF5, ILB, IUB, JLB, JUB, KLB, KUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR60'

        !Writes the Grid
        call HDF5WriteData   (ObjHDF5, "/Grid", "Bathymetry", "m",                      &
                              Array2D = Bathymetry,                                     &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR70'

        call HDF5WriteData   (ObjHDF5, "/Grid", "WaterPoints3D", "-",                   &
                              Array3D = WaterPoints3D,                                  &
                              STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR80'


        !Writes everything to disk
        call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR90'


        !Ungets the Bathymetry
        call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR110'

        !Ungets the WaterPoints
        call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR120'


        !Time Properties - Actualizes CurrentTime
        call GetComputeCurrentTime(Me%ObjTime, Me%CurrentTime, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError (FATAL_, INTERNAL_,'Write_Final_HDF5; ModuleHydrodynamic. ERR130.')

        !Start writting the final hydrodynamic conditions file
        call ExtractDate   (Me%CurrentTime, AuxTime(1), AuxTime(2), AuxTime(3),         &
                                            AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime
        call HDF5SetLimits  (ObjHDF5, 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR140'

        !write(FinalFile) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File
        call HDF5WriteData  (ObjHDF5, "/Time", "Time", "YYYY/MM/DD HH:MM:SS",           &
                             Array1D = TimePtr, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR150'

        !!!!!!!!!!!!!!!!!start hydrodynamic options!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        !Sets limits for next write operations
        call HDF5SetLimits   (ObjHDF5, 1, 1, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR155'

        !Write the discretization Method used

        AuxReal(1) = Me%ComputeOptions%Num_Discretization

        !write(FinalFile) Me%ComputeOptions%Num_Discretization
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Time",                                  &
                             Name           = "discretization method",                  &
                             Units          = "-",                                      &
                             Array1D        = AuxReal,                                  &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR160'


        !write(FinalFile) Me%ComputeOptions%Residual
        !Convert logical in int
        if (Me%ComputeOptions%Residual) then
            AuxInt(1) = 1
        else
            AuxInt(1) = 0
        endif

        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Time",                                  &
                             Name           = "residual ON",                            &
                             Units          = "0/1",                                    &
                             Array1D        = AuxInt,                                   &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR170'

        AuxInt(1) = Me%Direction%XY

        !Write the last direction computed implicit by the model
        !write(FinalFile) Me%Direction%XY
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Time",                                  &
                             Name           = "direction XY",                           &
                             Units          = "-",                                      &
                             Array1D        = AuxInt,                                   &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR180'

cd2:    if (Me%ComputeOptions%Residual) then

            AuxReal(1) = Me%Residual%ResidualTime

            !write(FinalFile) Me%Residual%ResidualTime
            call HDF5WriteData(HDF5ID        = ObjHDF5,                                 &
                               GroupName     = "/Time",                                 &
                               Name          = "residual time",                         &
                               Units         = "-",                                     &
                               Array1D       = AuxReal,                                 &
                               STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR270'

        endif cd2

        AuxInt(1) = Me%ComputeOptions%BaroclinicRadia

        !write(FinalFile) Me%ComputeOptions%BaroclinicRadia
        call HDF5WriteData (HDF5ID        = ObjHDF5,                                    &
                            GroupName     = "/Time",                                    &
                            Name          = "baroclinc radiation",                      &
                            Units         = "-",                                        &
                            Array1D       = AuxInt,                                     &
                            STAT          = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR350'

        !!!!!!!!!!!!!!!!!end hydrodynamic options!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !!!!!!!!!!!!!!!!!start hydrodynamic matrixes!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        !Sets limits for next write operations
        call HDF5SetLimits   (ObjHDF5, ILB, IUB, JLB, JUB, KLB, KUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR155'

        !Water level
        !write(FinalFile) ((Me%WaterLevel%New(i, j),                         &
        !                   i = ILB, IUB), j = JLB, JUB)

        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Water Level New",                        &
                             Units          = "m",                                      &
                             Array2D        = Me%WaterLevel%New,                        &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR190'



        !Horizontal velocity Old
        !write(FinalFile) (((Me%Velocity%Horizontal%U%Old(i, j, k),          &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Velocity U Old",                         &
                             Units          = "m/s",                                    &
                             Array3D        = Me%Velocity%Horizontal%U%Old,             &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR200'


        !write(FinalFile) (((Me%Velocity%Horizontal%V%Old(i, j, k),          &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Velocity V Old",                         &
                             Units          = "m/s",                                    &
                             Array3D        = Me%Velocity%Horizontal%V%Old,             &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR210'



        !Horizontal velocity New
        !write(FinalFile) (((Me%Velocity%Horizontal%U%New(i, j, k),          &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Velocity U New",                         &
                             Units          = "m/s",                                    &
                             Array3D        = Me%Velocity%Horizontal%U%New,             &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR220'

        !write(FinalFile) (((Me%Velocity%Horizontal%V%New(i, j, k),          &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Velocity V New",                         &
                             Units          = "m/s",                                    &
                             Array3D        = Me%Velocity%Horizontal%V%New,             &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR230'

        !Water fluxes
        !write(FinalFile) (((Me%WaterFluxes%X(i, j, k),                      &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Water Fluxes X",                         &
                             Units          = "m3/s",                                   &
                             Array3D        = Me%WaterFluxes%X,                         &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR240'


        !write(FinalFile) (((Me%WaterFluxes%Y(i, j, k) ,                     &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Water Fluxes Y",                         &
                             Units          = "m3/s",                                   &
                             Array3D        = Me%WaterFluxes%Y,                         &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR250'


        !write(FinalFile) (((Me%WaterFluxes%Z(i, j, k),                      &
        !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
        call HDF5WriteData  (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = "/Results",                               &
                             Name           = "Water Fluxes Z",                         &
                             Units          = "m3/s",                                   &
                             Array3D        = Me%WaterFluxes%Z,                         &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR260'

cd1:    if (Me%ComputeOptions%Residual) then

            !Average water level
            !write(FinalFile) ((Me%Residual%WaterLevel(i, j),                &
            !                   i = ILB, IUB), j = JLB, JUB)
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual Water Level",               &
                                 Units          = "m",                                  &
                                 Array2D        = Me%Residual%WaterLevel,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR280'

            !Residual horizontal velocities
            !write(FinalFile) (((Me%Residual%Velocity_U(i, j, k),            &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual Velocity U",                &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%Residual%Velocity_U,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR290'

            !write(FinalFile) (((Me%Residual%Velocity_V(i, j, k),            &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual Velocity V",                &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%Residual%Velocity_V,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR300'


            !Residual vertical velocity
            !write(FinalFile) (((Me%Residual%Vertical_Velocity(i, j, k),     &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual Velocity W",                &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%Residual%Vertical_Velocity,        &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR310'

            !Residual Water specific fluxes
            !write(FinalFile) (((Me%Residual%WaterFlux_X(i, j, k),           &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual Water Flux X",              &
                                 Units          = "m3/s",                               &
                                 Array3D        = Me%Residual%WaterFlux_X,              &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR320'

            !write(FinalFile) (((Me%Residual%WaterFlux_Y(i, j, k) ,          &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual Water Flux Y",              &
                                 Units          = "m3/s",                               &
                                 Array3D        = Me%Residual%WaterFlux_Y,              &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR330'

        endif cd1

        call WriteGeometryHDF (Me%ObjGeometry, ObjHDF5, AddFaces = .true., STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call SetError (FATAL_, INTERNAL_,'Write_Final_HDF5; ModuleHydrodynamic. ERR40.')

        call HDF5SetLimits   (ObjHDF5, ILB, IUB, JLB, JUB, KLB, KUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR335'

cd23:   if (Me%ComputeOptions%Residual) then

            !Residual layer thickness
            !write(FinalFile) (((Me%Residual%DWZ(i, j, k),                   &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Residual DWZ",                       &
                                 Units          = "m",                                  &
                                 Array3D        = Me%Residual%DWZ,                      &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR340'

        endif cd23



cd4:    if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then


            !Horizontal baroclinic velocity Old
            !write(FinalFile) (((Me%VelBaroclinic%U%Old(i, j, k),            &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Baroclinic U Old",          &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%VelBaroclinic%U%Old,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR360'


            !write(FinalFile) (((Me%VelBaroclinic%V%Old(i, j, k),            &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Baroclinic V Old",          &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%VelBaroclinic%V%Old,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR370'


            !Horizontal baroclinic velocity New
            !write(FinalFile) (((Me%VelBaroclinic%U%New(i, j, k),            &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
           !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Baroclinic U New",          &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%VelBaroclinic%U%New,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR380'

            !write(FinalFile) (((Me%VelBaroclinic%V%New(i, j, k),            &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Baroclinic V New",          &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%VelBaroclinic%V%New,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR390'

            !vertical baroclinic velocity
            !write(FinalFile) (((Me%VelBaroclinic%W_New(i, j, k),            &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            !write(FinalFile) (((Me%VelBaroclinic%W_Old(i, j, k),            &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Baroclinic W New",          &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%VelBaroclinic%W_New,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR400'

            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Baroclinic W Old",          &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%VelBaroclinic%W_Old,               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR410'


        endif cd4


        if (Me%NonHydrostatic%ON) then

            !write(FinalFile) (((Me%Velocity%Vertical%CartesianOld(i, j, k), &
            !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity Vertical Cartesian Old",    &
                                 Units          = "m/s",                                &
                                 Array3D        = Me%Velocity%Vertical%CartesianOld,    &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR410'

        endif

        !Submodel
        if (Me%SubModel%ON) then

            !write(FinalFile, IOSTAT = STAT_CALL)                                        &
            !    (((Me%SubModel%qX(i, j, k),                                             &
            !       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !if (STAT_CALL /= SUCCESS_) then
            !    call SetError (FATAL_, INTERNAL_,'Write_Final_HDF5; ModuleHydrodynamic. ERR50.')
            !endif

            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Submodel qX",                        &
                                 Units          = "m2/s",                               &
                                 Array3D        = Me%SubModel%qX,                       &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR420'


            !write(FinalFile, IOSTAT = STAT_CALL)                                        &
            !    (((Me%SubModel%qY(i, j, k),                                             &
            !       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            !if (STAT_CALL /= SUCCESS_) then
            !    call SetError (FATAL_, INTERNAL_,'Write_Final_HDF5; ModuleHydrodynamic. ERR60.')
            !endif

            call HDF5WriteData  (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Submodel qY",                        &
                                 Units          = "m2/s",                               &
                                 Array3D        = Me%SubModel%qY,                       &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR430'


        endif


        call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF5 - ModuleHydrodynamic - ERR440'

        deallocate(AuxReal, AuxInt)

    end subroutine Write_Final_HDF5

    !End--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    ! The model writes the final hydrodynamic properties

    subroutine Read_Final_Hydrodynamic_File

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        logical                             :: BinaryFormatOK, HDF5FormatOK
        !Begin-----------------------------------------------------------------

        call Read_Final_HDF5(HDF5FormatOK)

        if (.not. HDF5FormatOK) then

            call Read_Final_Bin(BinaryFormatOK)

            if (.not. BinaryFormatOK) then
                stop 'Read_Final_Hydrodynamic_File - ModuleHydrodynamic - ERR10'
            endif

        endif

    end subroutine Read_Final_Hydrodynamic_File

    !--------------------------------------------------------------------------

    !Final hydrodynamic properties in binary format
    subroutine Read_Final_Bin(BinaryFormatOK)

        !Arguments-------------------------------------------------------------

        logical                             :: BinaryFormatOK

        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------
        real   , dimension(:,:  ), pointer :: Aux2D
        real   , dimension(:,:,:), pointer :: Aux3D
        real(8), dimension(:,:,:), pointer :: Aux3DDouble

        type (T_Time)                      :: BeginTime, EndTimeFile, EndTime

        real                               :: Year_File, Month_File, Day_File,           &
                                              Hour_File, Minute_File, Second_File,       &
                                              DT_error
        real                               :: Previous_Discretization

        integer                            :: IUB, JUB, KUB, ILB, JLB, KLB
        integer                            :: InitialFile, i, j, k, Evolution
        integer                            :: BaroclinicRadia
        logical                            :: EXT, Residual
        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB


        inquire (FILE=Me%Files%InitialHydrodynamic, EXIST=EXT)

        if (.not.EXT)                                                                    &
            call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR01.')


        call UnitsManager(InitialFile, FileOpen, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                          &
             call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR02.')

        open(Unit = InitialFile, File = Me%Files%InitialHydrodynamic,       &
             Form = 'UNFORMATTED', status = 'OLD', IOSTAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                          &
             call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR03.')

        !Start reading the end file of the previous run
        read(InitialFile,iostat = STAT_CALL) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File

i1:     if (STAT_CALL /= SUCCESS_) then

            call UnitsManager(InitialFile, FileClose, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                          &
                 call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR03a.')

            BinaryFormatOK = .false.

        else i1

            BinaryFormatOK = .true.

            call SetDate(EndTimeFile, Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File)


            call GetComputeTimeLimits(Me%ObjTime, BeginTime = BeginTime, &
                                      EndTime = EndTime, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                          &
                 call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR04.')

            DT_error = EndTimeFile - BeginTime

            !Avoid rounding erros - Frank 08-2001
            if (abs(DT_error) >= 0.01) then

                write(*,*) 'The end time of the previous run is different from the start time of this run'
                write(*,*) 'Date in the file'
                write(*,*) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File
                write(*,*) 'DT_error', DT_error
                call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR05.')


            endif

            read(InitialFile) Previous_Discretization

            if (Previous_Discretization /= Me%ComputeOptions%Num_Discretization) then

                write(*,*) 'previous run time discretization is different from this one'

                call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR06.')


            endif


            read(InitialFile) Residual

            !Read the last direction computed implicit by the model
            read(InitialFile) Me%Direction%XY


            !Water level

            read(InitialFile) ((Me%WaterLevel%New(i, j), &
                               i = ILB, IUB), j = JLB, JUB)

            Me%WaterLevel%Old (:,:) = Me%WaterLevel%New(:,:)


            !Horizontal velocity Old
            read(InitialFile) (((Me%Velocity%Horizontal%U%Old(i, j, k), &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            read(InitialFile) (((Me%Velocity%Horizontal%V%Old(i, j, k), &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            !Horizontal velocity New
            read(InitialFile) (((Me%Velocity%Horizontal%U%New(i, j, k), &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile) (((Me%Velocity%Horizontal%V%New(i, j, k), &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            !Water fluxes
            read(InitialFile) (((Me%WaterFluxes%X(i, j, k), &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile) (((Me%WaterFluxes%Y(i, j, k) , &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            read(InitialFile) (((Me%WaterFluxes%Z(i, j, k), &
                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


            Evolution = Me%ComputeOptions%Evolution


            if (Evolution == Residual_hydrodynamic_ .and. .not. Residual) then

                write(*,*) 'Can not have a residual evolution with out a initial file with residual values'

                call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR07.')


            endif


    cd1:    if (Residual .and. .not. Me%ComputeOptions%Residual) then

                write(*,*)
                write(*,*)
                write(*,*)
                write(*,*) 'Warning: YOU HAVE STOPPED THE RESIDUAL CALCULATION, '
                write(*,*) 'In the run before this one you have compute residual currents, '
                write(*,*) 'In this run you dont want to compute residual currents ? '
                write(*,*) '                        '
                write(*,*) 'SUBROUTINE Read_Final_Bin - ModuleHydrodynamic. WRN01.'
                write(*,*)
                write(*,*)
                write(*,*)

                allocate (Aux2D         (ILB:IUB, JLB:JUB))
                allocate (Aux3D         (ILB:IUB, JLB:JUB, KLB:KUB))
                allocate (Aux3DDouble   (ILB:IUB, JLB:JUB, KLB:KUB))

                read(InitialFile) Me%Residual%ResidualTime

                !Average water level
                read(InitialFile) ((Aux2D(i, j), i = ILB, IUB), j = JLB, JUB)

                !Residual horizontal velocities
                read(InitialFile) (((Aux3D(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                read(InitialFile) (((Aux3D(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !Residual vertical velocity
                read(InitialFile) (((Aux3D(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !Residual Water specific fluxes
                read(InitialFile) (((Aux3DDouble(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                read(InitialFile) (((Aux3DDouble(i, j, k), i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


                deallocate (Aux2D)
                deallocate (Aux3D)
                deallocate (Aux3DDouble)

            else if (Residual .and. Me%ComputeOptions%Residual) then cd1

                if (Me%computeOptions%RestartResidual)then

                    Me%Residual%ResidualTime = 0

                    do j = JLB, JUB
                    do i = ILB, IUB
                           Me%Residual%WaterLevel(i, j) = 0.
                    enddo
                    enddo

                    do k = KLB, KUB
                    do j = JLB, JUB
                    do i = ILB, IUB

                        !Residual velocity
                        Me%Residual%Velocity_U(i, j, k) =  0.
                        Me%Residual%Velocity_V(i, j, k) =  0.

                        !Residual vertical velocity
                        Me%Residual%Vertical_Velocity(i, j, k) =  0.

                        !Residual Water fluxes
                        Me%Residual%WaterFlux_X(i, j, k) = 0.
                        Me%Residual%WaterFlux_Y(i, j, k) = 0.

                        !Read residual layer thickness
                        Me%Residual%DWZ(i, j, k) = 0

                    enddo
                    enddo
                    enddo


                endif

                read(InitialFile) Me%Residual%ResidualTime

                !Average water level
                read(InitialFile) ((Me%Residual%WaterLevel(i, j),               &
                                   i = ILB, IUB), j = JLB, JUB)

                !Residual horizontal velocities
                read(InitialFile) (((Me%Residual%Velocity_U(i, j, k),           &
                                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                read(InitialFile) (((Me%Residual%Velocity_V(i, j, k),           &
                                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !Residual vertical velocity
                read(InitialFile) (((Me%Residual%Vertical_Velocity(i, j, k),    &
                                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !Residual Water specific fluxes
                read(InitialFile) (((Me%Residual%WaterFlux_X(i, j, k),          &
                                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                read(InitialFile) (((Me%Residual%WaterFlux_Y(i, j, k) ,         &
                                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


    cd2:        if (Evolution == Residual_hydrodynamic_) then

                    Me%WaterLevel%Old(:,:) = Me%Residual%WaterLevel(:,:)

                    Me%WaterLevel%New(:,:) = Me%Residual%WaterLevel(:,:)


                    Me%Velocity%Horizontal%U%Old(:,:,:) = Me%Residual%Velocity_U(:,:,:)

                    Me%Velocity%Horizontal%U%New(:,:,:) = Me%Residual%Velocity_U(:,:,:)


                    Me%Velocity%Horizontal%V%Old(:,:,:) = Me%Residual%Velocity_V(:,:,:)

                    Me%Velocity%Horizontal%V%New(:,:,:) = Me%Residual%Velocity_V(:,:,:)

                    !Module - ModuleHorizontalGrid
                    !Horizontal Grid properties
                     call GetHorizontalGrid(Me%ObjHorizontalGrid,                           &
                                            DXX  = Me%External_Var%DXX,                     &
                                            DYY  = Me%External_Var%DYY,                     &
                                            STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_)                                              &
                         call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR40.')

                    do k = KLB, KUB
                    do j = JLB, JUB
                    do i = ILB, IUB

                        ![m3/s]                 = [m2/s] * [m]
                        Me%WaterFluxes%X(i,j,k) = Me%Residual%WaterFlux_X(i,j,k) * Me%External_Var%DYY(i, J)
                        Me%WaterFluxes%Y(i,j,k) = Me%Residual%WaterFlux_Y(i,j,k) * Me%External_Var%DXX(i, J)

                    enddo
                    enddo
                    enddo

                    call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%External_Var%DXX,     &
                                             STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                              &
                         call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR50.')



                    call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%External_Var%DYY,     &
                                             STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                              &
                         call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR60.')




                endif cd2


            else if (.not. Residual .and. Me%ComputeOptions%Residual) then cd1

                    Me%Residual%ResidualTime    =  0


                    do  j = JLB, JUB
                    do  i = ILB, IUB

                        Me%Residual%WaterLevel(i, j)    =  0.

                        do  k = KLB, KUB

                            !Residual horizontal velocity
                            Me%Residual%Velocity_U(i, j, k) =  0.
                            Me%Residual%Velocity_V(i, j, k) =  0.

                            !Residual vertical velocity
                            Me%Residual%Vertical_Velocity(i, j, k) =  0.

                            !Residual Water fluxes
                            Me%Residual%WaterFlux_X(i, j, k) = 0.
                            Me%Residual%WaterFlux_Y(i, j, k) = 0.

                            !Read residual layer thickness
                            Me%Residual%DWZ(i, j, k) = 0

                        enddo

                    enddo
                    enddo

            endif cd1

            call ReadGeometryBin(Me%ObjGeometry, InitialFile, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                          &
                call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR70.')

    cd3:    if (Residual .and. Me%ComputeOptions%Residual) then
                !Read residual layer thickness
                read(InitialFile, END = 10) (((Me%Residual%DWZ(i, j, k),        &
                                    i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

    10          continue

            endif cd3


            read(InitialFile, END = 20) BaroclinicRadia

    cd4:    if (.not. BaroclinicRadia                                == NoRadiation_ .and.   &
                .not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then


                !Horizontal baroclinic velocity Old
                read(InitialFile, END = 20) (((Me%VelBaroclinic%U%Old(i, j, k), &
                                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )


                read(InitialFile, END = 20) (((Me%VelBaroclinic%V%Old(i, j, k), &
                                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !Horizontal baroclinic velocity New
                read(InitialFile, END = 20) (((Me%VelBaroclinic%U%New(i, j, k), &
                                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                read(InitialFile, END = 20) (((Me%VelBaroclinic%V%New(i, j, k), &
                                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !vertical baroclinic velocity
                read(InitialFile, END = 20) (((Me%VelBaroclinic%W_New(i, j, k), &
                                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                read(InitialFile, END = 20) (((Me%VelBaroclinic%W_Old(i, j, k), &
                                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

            endif cd4

    20      continue

            !NonHydrostatic
            if (Me%NonHydrostatic%ON) then

                read(InitialFile, IOSTAT = STAT_CALL)                                       &
                    (((Me%Velocity%Vertical%CartesianOld(i, j, k),                          &
                       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                if (STAT_CALL /= SUCCESS_) then
                    call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR80.')
                endif

            endif

            !Submodel
            if (Me%SubModel%ON) then

                Me%SubModel%HotStartData = .false.

                read(InitialFile, END = 30, IOSTAT = STAT_CALL)                             &
                    (((Me%SubModel%qX(i, j, k),                                             &
                       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                if (STAT_CALL /= SUCCESS_) then
                    call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR90.')
                endif

                read(InitialFile, END = 30, IOSTAT = STAT_CALL)                                       &
                    (((Me%SubModel%qY(i, j, k),                                             &
                       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                if (STAT_CALL /= SUCCESS_) then
                    call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR100.')
                endif

                Me%SubModel%HotStartData = .true.

    30          continue

                if (.not. Me%SubModel%HotStartData) then
                    write(*,*) 'you are doing a hot start based in a old version of MOHID'
                    write(*,*) 'version before Nov 2010'
                    write(*,*) 'in this case in the first iteration if the South/North boundaries are open'
                    write(*,*) 'and the follow options are on (RADIATION : 2; LOCAL_SOLUTION : 2)'
                    write(*,*) 'the mpodel will generate a perturbation that might take some type to dissipate'
                    write(*,*) 'in less dissipative enviroments like the Ocean'
                endif

            endif

            call UnitsManager(InitialFile, FileClose, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                          &
                call SetError (FATAL_, INTERNAL_,'Read_Final_Bin; ModuleHydrodynamic. ERR110.')

        endif i1

    end subroutine Read_Final_Bin

    !--------------------------------------------------------------------------


    !Final hydrodynamic properties in hdf5 format
    subroutine Read_Final_HDF5(HDF5FormatOK)

        !Arguments-------------------------------------------------------------

        logical                             :: HDF5FormatOK


        !External--------------------------------------------------------------

        integer :: STAT_CALL

        !Local-----------------------------------------------------------------
        real,    dimension(:), pointer     :: TimeVector
        type (T_Time)                      :: BeginTime, EndTimeFile, EndTime

        real                               :: DT_error
        real                               :: Previous_Discretization

        integer                            :: IUB, JUB, KUB, ILB, JLB, KLB, HDF5_READ
        integer                            :: IUW, JUW, ILW, JLW
        integer                            :: i, j, k, Evolution
        integer                            :: BaroclinicRadia
        logical                            :: EXT, Residual
        integer                            :: ObjHDF5
        type (T_Size2D)                    :: WindowLimitsJI
        integer                            :: Imax, Jmax, Kmax
        real,    dimension(:),     pointer :: AuxReal
        integer, dimension(:),     pointer :: AuxInt
        real,    dimension(:,:),   pointer :: Aux2DReal
        real,    dimension(:,:,:), pointer :: Aux3DReal
        real(8), dimension(:,:,:), pointer :: Aux3DR8
        logical                            :: Exist, HDF5Stop

        !----------------------------------------------------------------------

        allocate(AuxInt(1), AuxReal(1))

        inquire (FILE=Me%Files%InitialHydrodynamic, EXIST=EXT)

        if (.not.EXT) then
            write(*,*) 'Do not exist file =',trim(Me%Files%InitialHydrodynamic)
            call SetError (FATAL_, INTERNAL_,'Read_Final_HDF5; ModuleHydrodynamic. ERR10.')
        endif

        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_READ = HDF5_READ)

        ObjHDF5 = 0

        !Opens HDF File
        call ConstructHDF5      (HDF5ID     = ObjHDF5,                                  &
                                 FileName   = trim(Me%Files%InitialHydrodynamic),       &
                                 Access     = HDF5_READ,                                &
                                 HDF5Stop   = HDF5Stop,                                 &
                                 STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR20'


        if (HDF5Stop) then

            HDF5FormatOK = .false.

            call KillHDF5      (HDF5ID      = ObjHDF5,                                  &
                                DoNotStop   = .true.,                                   &
                                STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR25'

        else

            HDF5FormatOK = .true.

        endif

i1:     if (HDF5FormatOK) then


            call GetHDF5ArrayDimensions (HDF5ID = ObjHDF5, GroupName = "/Grid",     &
                                        ItemName = "WaterPoints3D",                    &
                                        Imax = Imax, Jmax = Jmax, Kmax = Kmax, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR30'

            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB + 1

            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB + 1

            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB + 1


    ifMS:   if (Me%DDecomp%MasterOrSlave) then

                call GetDDecompWorkSize2D(HorizontalGridID = Me%ObjHorizontalGrid, &
                                          WorkSize         = WindowLimitsJI,       &
                                          STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR40'

                ILW = WindowLimitsJI%ILB
                IUW = WindowLimitsJI%IUB + 1

                JLW = WindowLimitsJI%JLB
                JUW = WindowLimitsJI%JUB + 1

            else ifMS

                ILW = ILB
                IUW = IUB

                JLW = JLB
                JUW = JUB

            endif ifMS


            if (ILW < 1   ) then
                write(*,*) 'ILW < 1 = ', ILW
                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR50'
            endif
            if (IUW > Imax) then
                write(*,*) 'IUW > Imax = ', IUW, Imax
                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR60'
            endif
            if (JLW < 1   ) then
                write(*,*) 'JLW < 1 = ', JLW
                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR70'
            endif
            if (JUW > Jmax) then
                write(*,*) 'JUW > Jmax = ', JUW, Jmax
                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR80'
            endif
            if (KLB < 1   ) then
                write(*,*) 'KLB < 1 = ', KLB
                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR90'
            endif
            if (KUB > Kmax) then
                write(*,*) 'KUB > Kmax = ', KUB, Kmax
                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR100'
            endif
            allocate(Aux2DReal(ILW:IUW,JLW:JUW        ))
            allocate(Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB))
            allocate(Aux3DR8  (ILW:IUW,JLW:JUW,KLB:KUB))

            !Start reading the end file of the previous run

            !read(InitialFile) Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File
            !call SetDate(EndTimeFile, Year_File, Month_File, Day_File, Hour_File, Minute_File, Second_File)

            call HDF5SetLimits  (ObjHDF5, 1, 6, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR110'

            allocate(TimeVector(6))

            call HDF5ReadData   (HDF5ID         = ObjHDF5,                                  &
                                 GroupName      = "/Time",                                  &
                                 Name           = "Time",                                   &
                                 Array1D        = TimeVector,                               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR120'


            call SetDate(EndTimeFile,     Year     = TimeVector(1), Month  = TimeVector(2), &
                                          Day      = TimeVector(3), Hour   = TimeVector(4), &
                                          Minute   = TimeVector(5), Second = TimeVector(6))

            call GetComputeTimeLimits(Me%ObjTime, BeginTime = BeginTime, &
                                      EndTime = EndTime, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR130'

            DT_error = EndTimeFile - BeginTime

            !Avoid rounding erros - Frank 08-2001
            if (abs(DT_error) >= 0.01) then

                write(*,*) 'The end time of the previous run is different from the start time of this run'
                write(*,*) 'Date in the file'
                write(*,*) int(TimeVector(1:5)), TimeVector(6)
                write(*,*) 'DT_error', DT_error
                call SetError (FATAL_, INTERNAL_,'Read_Final_HDF5; ModuleHydrodynamic. ERR140.')

            endif

            deallocate(TimeVector)

            !Sets limits for next write operations
            call HDF5SetLimits   (ObjHDF5, 1, 1, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR150'


            !read(InitialFile) Previous_Discretization
            call HDF5ReadData (HDF5ID        = ObjHDF5,                                     &
                               GroupName     = "/Time",                                     &
                               Name          = "discretization method",                     &
                               Array1D       = AuxReal,                                     &
                               STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR160'

            Previous_Discretization = AuxReal(1)

            if (Previous_Discretization /= Me%ComputeOptions%Num_Discretization) then

                write(*,*) 'previous run time discretization is different from this one'

                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR170'

            endif


            !read(InitialFile) Residual

            !Convert logical in int
            call HDF5ReadData (HDF5ID        = ObjHDF5,                                     &
                               GroupName     = "/Time",                                     &
                               Name          = "residual ON",                               &
                               Array1D       = AuxInt,                                      &
                               STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR180'

            if (AuxInt(1) == 1) then
                Residual = .true.
            else
                Residual = .false.
            endif

            !Read the last direction computed implicit by the model
            !read(InitialFile) Me%Direction%XY
            call HDF5ReadData (HDF5ID        = ObjHDF5,                                     &
                               GroupName     = "/Time",                                     &
                               Name          = "direction XY",                              &
                               Array1D       = AuxInt,                                      &
                               STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR190'

            Me%Direction%XY = AuxInt(1)

            if (Residual .and. Me%ComputeOptions%Residual) then


                !read(InitialFile) Me%Residual%ResidualTime
                call HDF5ReadData (HDF5ID        = ObjHDF5,                                 &
                                   GroupName     = "/Time",                                 &
                                   Name          = "residual time",                         &
                                   Array1D       = AuxReal,                                 &
                                   STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR290'

                Me%Residual%ResidualTime = AuxReal(1)

            endif

            !read(InitialFile, END = 20) BaroclinicRadia
            call HDF5ReadData (HDF5ID        = ObjHDF5,                          &
                               GroupName     = "/Time",                          &
                               Name          = "baroclinc radiation",            &
                               Array1D       = AuxInt,                           &
                               STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR410'

            BaroclinicRadia = AuxInt(1)

            !Sets limits for next ead operations (2D matrixes)
            call HDF5SetLimits   (ObjHDF5, ILW, IUW, JLW, JUW, KLB, KUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR150'

            !Water level

            !read(InitialFile) ((Me%WaterLevel%New(i, j), &
        !                   i = ILB, IUB), j = JLB, JUB)
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                                  &
                                 GroupName      = "/Results",                               &
                                 Name           = "Water Level New",                        &
                                 Array2D        = Aux2DReal,                                &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR200'

            Me%WaterLevel%New (ILB:IUB,JLB:JUB) = Aux2DReal(ILW:IUW,JLW:JUW)

            Me%WaterLevel%Old (:,:)             = Me%WaterLevel%New(:,:)

            !Horizontal velocity Old
            !read(InitialFile) (((Me%Velocity%Horizontal%U%Old(i, j, k), &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity U Old",                     &
                                 Array3D        = Aux3DReal,                            &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR210'

            Me%Velocity%Horizontal%U%Old(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

            !read(InitialFile) (((Me%Velocity%Horizontal%V%Old(i, j, k), &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity V Old",                     &
                                 Array3D        = Aux3DReal,                            &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR220'

            Me%Velocity%Horizontal%V%Old(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

            !Horizontal velocity New
            !read(InitialFile) (((Me%Velocity%Horizontal%U%New(i, j, k), &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity U New",                     &
                                 Array3D        = Aux3DReal,                            &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR230'

            Me%Velocity%Horizontal%U%New(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

            !read(InitialFile) (((Me%Velocity%Horizontal%V%New(i, j, k), &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Velocity V New",                     &
                                 Array3D        = Aux3DReal,                            &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR240'

            Me%Velocity%Horizontal%V%New(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

            !Water fluxes
            !read(InitialFile) (((Me%WaterFluxes%X(i, j, k), &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Water Fluxes X",                     &
                                 Array3D        = Aux3DR8,                              &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR250'

            Me%WaterFluxes%X(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)

            !read(InitialFile) (((Me%WaterFluxes%Y(i, j, k) , &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Water Fluxes Y",                     &
                                 Array3D        = Aux3DR8,                              &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR260'

            Me%WaterFluxes%Y(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)

            !read(InitialFile) (((Me%WaterFluxes%Z(i, j, k), &
            !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
            call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                 GroupName      = "/Results",                           &
                                 Name           = "Water Fluxes Z",                     &
                                 Array3D        = Aux3DR8,                              &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR270'

            Me%WaterFluxes%Z(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)


            Evolution = Me%ComputeOptions%Evolution


            if (Evolution == Residual_hydrodynamic_ .and. .not. Residual) then

                write(*,*) 'Can not have a residual evolution with out a initial file with residual values'

                stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR280'


            endif


    cd1:    if (Residual .and. .not. Me%ComputeOptions%Residual) then

                write(*,*)
                write(*,*)
                write(*,*)
                write(*,*) 'Warning: YOU HAVE STOPPED THE RESIDUAL CALCULATION, '
                write(*,*) 'In the run before this one you have compute residual currents, '
                write(*,*) 'In this run you dont want to compute residual currents ? '
                write(*,*) '                        '
                write(*,*) 'SUBROUTINE Read_Final_HDF5 - ModuleHydrodynamic. WRN01.'
                write(*,*)
                write(*,*)
                write(*,*)


            else if (Residual .and. Me%ComputeOptions%Residual) then cd1

                !Average water level
                !read(InitialFile) ((Me%Residual%WaterLevel(i, j),               &
                !                   i = ILB, IUB), j = JLB, JUB)
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual Water Level",               &
                                     Array2D        = Aux2DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR300'

                Me%Residual%WaterLevel(ILB:IUB,JLB:JUB) = Aux2DReal(ILW:IUW,JLW:JUW)

                !Residual horizontal velocities
                !read(InitialFile) (((Me%Residual%Velocity_U(i, j, k),           &
                !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual Velocity U",                &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR310'

                Me%Residual%Velocity_U(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !read(InitialFile) (((Me%Residual%Velocity_V(i, j, k),           &
                !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual Velocity V",                &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR320'

                Me%Residual%Velocity_V(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !Residual vertical velocity
                !read(InitialFile) (((Me%Residual%Vertical_Velocity(i, j, k),    &
                !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual Velocity W",                &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR330'

                Me%Residual%Vertical_Velocity(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !Residual Water specific fluxes
                !read(InitialFile) (((Me%Residual%WaterFlux_X(i, j, k),          &
                !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual Water Flux X",              &
                                     Array3D        = Aux3DR8,                              &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR340'

                Me%Residual%WaterFlux_X(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)

                !read(InitialFile) (((Me%Residual%WaterFlux_Y(i, j, k) ,         &
                !                   i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual Water Flux Y",              &
                                     Array3D        = Aux3DR8,                              &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR350'

                Me%Residual%WaterFlux_Y(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)

    cd2:        if (Evolution == Residual_hydrodynamic_) then

                    Me%WaterLevel%Old(:,:) = Me%Residual%WaterLevel(:,:)

                    Me%WaterLevel%New(:,:) = Me%Residual%WaterLevel(:,:)


                    Me%Velocity%Horizontal%U%Old(:,:,:) = Me%Residual%Velocity_U(:,:,:)

                    Me%Velocity%Horizontal%U%New(:,:,:) = Me%Residual%Velocity_U(:,:,:)


                    Me%Velocity%Horizontal%V%Old(:,:,:) = Me%Residual%Velocity_V(:,:,:)

                    Me%Velocity%Horizontal%V%New(:,:,:) = Me%Residual%Velocity_V(:,:,:)

                    !Module - ModuleHorizontalGrid
                    !Horizontal Grid properties
                    call GetHorizontalGrid(Me%ObjHorizontalGrid,                            &
                                           DXX  = Me%External_Var%DXX,                      &
                                           DYY  = Me%External_Var%DYY,                      &
                                           STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR360'

                    do k = KLB, KUB
                    do j = JLB, JUB
                    do i = ILB, IUB

                        ![m3/s]                 = [m2/s] * [m]
                        Me%WaterFluxes%X(i,j,k) = Me%Residual%WaterFlux_X(i,j,k) * Me%External_Var%DYY(i, J)
                        Me%WaterFluxes%Y(i,j,k) = Me%Residual%WaterFlux_Y(i,j,k) * Me%External_Var%DXX(i, J)

                    enddo
                    enddo
                    enddo

                    call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%External_Var%DXX,     &
                                             STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR370'



                    call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%External_Var%DYY,     &
                                             STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR380'



                endif cd2


            else if (.not. Residual .and. Me%ComputeOptions%Residual) then cd1

                    Me%Residual%ResidualTime    =  0


                    do  j = JLB, JUB
                    do  i = ILB, IUB

                        Me%Residual%WaterLevel(i, j)    =  0.

                        do  k = KLB, KUB

                            !Residual horizontal velocity
                            Me%Residual%Velocity_U(i, j, k) =  0.
                            Me%Residual%Velocity_V(i, j, k) =  0.

                            !Residual vertical velocity
                            Me%Residual%Vertical_Velocity(i, j, k) =  0.

                            !Residual Water fluxes
                            Me%Residual%WaterFlux_X(i, j, k) = 0.
                            Me%Residual%WaterFlux_Y(i, j, k) = 0.

                            !Read residual layer thickness
                            Me%Residual%DWZ(i, j, k) = 0

                        enddo

                    enddo
                    enddo

            endif cd1

            call ReadGeometryHDF(GeometryID     = Me%ObjGeometry,                           &
                                 HDF5FileName   = Me%Files%InitialHydrodynamic,             &
                                 MasterOrSlave  = Me%DDecomp%MasterOrSlave,                 &
                                 AddFaces       = .true.,                                   &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR390'

            !Sets limits for next ead operations (3D matrixes)
            call HDF5SetLimits   (ObjHDF5, ILW, IUW, JLW, JUW, KLB, KUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR150'


    cd3:    if (Residual .and. Me%ComputeOptions%Residual) then

                !Read residual layer thickness
                !read(InitialFile, END = 10) (((Me%Residual%DWZ(i, j, k),        &
                !                    i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Residual DWZ",                       &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR400'

                Me%Residual%DWZ(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

            endif cd3


    cd4:    if (.not. BaroclinicRadia                                == NoRadiation_ .and.   &
                .not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then

                !Horizontal baroclinic velocity Old
                !read(InitialFile, END = 20) (((Me%VelBaroclinic%U%Old(i, j, k), &
                !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Velocity Baroclinic U Old",          &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR420'

                Me%VelBaroclinic%U%Old(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !read(InitialFile, END = 20) (((Me%VelBaroclinic%V%Old(i, j, k), &
                !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Velocity Baroclinic V Old",          &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR430'

                Me%VelBaroclinic%V%Old(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !Horizontal baroclinic velocity New
                !read(InitialFile, END = 20) (((Me%VelBaroclinic%U%New(i, j, k), &
                !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Velocity Baroclinic U New",          &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR440'

                Me%VelBaroclinic%U%New(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !read(InitialFile, END = 20) (((Me%VelBaroclinic%V%New(i, j, k), &
                !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Velocity Baroclinic V New",          &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR450'

                Me%VelBaroclinic%V%New(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !vertical baroclinic velocity
                !read(InitialFile, END = 20) (((Me%VelBaroclinic%W_New(i, j, k), &
                !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Velocity Baroclinic W New",          &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR460'

                Me%VelBaroclinic%W_New(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

                !read(InitialFile, END = 20) (((Me%VelBaroclinic%W_Old(i, j, k), &
                !                               i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Velocity Baroclinic W Old",          &
                                     Array3D        = Aux3DReal,                            &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR470'

                Me%VelBaroclinic%W_Old(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)

            endif cd4

    20      continue

            !NonHydrostatic
            if (Me%NonHydrostatic%ON) then

                !read(InitialFile, IOSTAT = STAT_CALL)                                       &
                !    (((Me%Velocity%Vertical%CartesianOld(i, j, k),                          &
                !       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )
                !if (STAT_CALL /= SUCCESS_) then
                !    call SetError (FATAL_, INTERNAL_,'Read_Final_HDF5; ModuleHydrodynamic. ERR80.')
                !endif

                call GetHDF5DataSetExist (HDF5ID        = ObjHDF5,                          &
                                          DataSetName   = "/Results/Velocity Vertical Cartesian Old",&
                                          Exist         = Exist,                            &
                                          STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR480'

                if (Exist) then

                    call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                         GroupName      = "/Results",                           &
                                         Name           = "Velocity Vertical Cartesian Old",    &
                                         Array3D        = Aux3DReal,                            &
                                         STAT           = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR490'

                    Me%Velocity%Vertical%CartesianOld(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DReal(ILW:IUW,JLW:JUW,KLB:KUB)
                else
                    Me%Velocity%Vertical%CartesianOld(ILB:IUB,JLB:JUB,KLB:KUB) = 0.
                endif

            endif

            !Submodel
            if (Me%SubModel%ON) then

                Me%SubModel%HotStartData = .false.

                !read(InitialFile, END = 30, IOSTAT = STAT_CALL)                             &
                !    (((Me%SubModel%qX(i, j, k),                                             &
                !       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !if (STAT_CALL /= SUCCESS_) then
                !    call SetError (FATAL_, INTERNAL_,'Read_Final_HDF5; ModuleHydrodynamic. ERR90.')
                !endif

                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Submodel qX",                        &
                                     Array3D        = Aux3DR8,                              &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR500'

                Me%SubModel%qX(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)

                !read(InitialFile, END = 30, IOSTAT = STAT_CALL)                                       &
                !    (((Me%SubModel%qY(i, j, k),                                             &
                !       i = ILB, IUB), j = JLB, JUB), k = KLB, KUB )

                !if (STAT_CALL /= SUCCESS_) then
                !    call SetError (FATAL_, INTERNAL_,'Read_Final_HDF5; ModuleHydrodynamic. ERR100.')
                !endif

                call HDF5ReadWindow (HDF5ID         = ObjHDF5,                              &
                                     GroupName      = "/Results",                           &
                                     Name           = "Submodel qY",                        &
                                     Array3D        = Aux3DR8,                              &
                                     STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR510'

                Me%SubModel%qY(ILB:IUB,JLB:JUB,KLB:KUB) = Aux3DR8(ILW:IUW,JLW:JUW,KLB:KUB)

                Me%SubModel%HotStartData = .true.

                if (.not. Me%SubModel%HotStartData) then
                    write(*,*) 'you are doing a hot start based in a old version of MOHID'
                    write(*,*) 'version before Nov 2010'
                    write(*,*) 'in this case in the first iteration if the South/North boundaries are open'
                    write(*,*) 'and the follow options are on (RADIATION : 2; LOCAL_SOLUTION : 2)'
                    write(*,*) 'the mpodel will generate a perturbation that might take some type to dissipate'
                    write(*,*) 'in less dissipative enviroments like the Ocean'
                endif

            endif

            call KillHDF5(ObjHDF5, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Read_Final_HDF5 - ModuleHydrodynamic - ERR520'

            deallocate(AuxInt, AuxReal)
            deallocate(Aux2DReal)
            deallocate(Aux3DReal)
            deallocate(Aux3DR8  )

        endif i1


    end subroutine Read_Final_HDF5

    !--------------------------------------------------------------------------

    subroutine OutputFloodRisk


        !Local-----------------------------------------------------------------
        character(len = PathLength)     :: MaxWaterColumnFile
        character(len = PathLength)     :: VelocityAtMaxWaterColumnFile
        character(len = PathLength)     :: MaxWaterFloodRiskFile

        character(len = PathLength)     :: MaxVelocityFile
        character(len = PathLength)     :: MaxWaterLevelFile
        character(len = PathLength)     :: MapMaxFile
        character(len = PathLength)     :: MapMinFile

        integer                         :: STAT_CALL

        !----------------------------------------------------------------------
        MaxWaterColumnFile           = trim(adjustl(Me%Output%FloodRiskRootPath))//"MaxWaterColumn.dat"
        VelocityAtMaxWaterColumnFile = trim(adjustl(Me%Output%FloodRiskRootPath))//"VelocityAtMaxWaterColumn.dat"
        MaxWaterFloodRiskFile        = trim(adjustl(Me%Output%FloodRiskRootPath))//"MaxFloodRisk.dat"

        MaxVelocityFile              = trim(adjustl(Me%Output%FloodRiskRootPath))//"MaxVelocity.dat"
        MaxWaterLevelFile            = trim(adjustl(Me%Output%FloodRiskRootPath))//"MaxWaterLevel.dat"
        MapMaxFile                   = trim(adjustl(Me%Output%FloodRiskRootPath))//"MapMax.dat"
        MapMinFile                   = trim(adjustl(Me%Output%FloodRiskRootPath))//"MapMin.dat"

        call WriteGridData  (MaxWaterColumnFile,                                        &
                             COMENT1          = "MaxWaterColumnFile",                   &
                             COMENT2          = "MaxWaterColumnFile",                   &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.0,                                  &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%MaxWaterColumn,               &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR10'

        call WriteGridData  (VelocityAtMaxWaterColumnFile,                              &
                             COMENT1          = "VelocityAtMaxWaterColumn",             &
                             COMENT2          = "VelocityAtMaxWaterColumn",             &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.0,                                  &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%VelocityAtMaxWaterColumn,     &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR20'

        call WriteGridData  (MaxWaterFloodRiskFile,                                     &
                             COMENT1          = "MaxFloodRisk",                         &
                             COMENT2          = "MaxFloodRisk",                         &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.0,                                  &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%MaxFloodRisk,                 &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR30'

        call WriteGridData  (MaxVelocityFile,                                           &
                             COMENT1          = "MaxVelocity",                          &
                             COMENT2          = "MaxVelocity",                          &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.0,                                  &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%MaxVelocity,                  &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR40'

        call WriteGridData  (MaxWaterLevelFile,                                         &
                             COMENT1          = "MaxWaterLevel",                        &
                             COMENT2          = "MaxWaterLevel",                        &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.0,                                  &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%MaxWaterLevel,                &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR50'

        call WriteGridData  (MapMaxFile,                                                &
                             COMENT1          = "MapMax",                               &
                             COMENT2          = "MapMax",                               &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.,                                   &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%MapMax,                       &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR60'

        call WriteGridData  (MapMinFile,                                                &
                             COMENT1          = "MapMin",                               &
                             COMENT2          = "MapMin",                               &
                             HorizontalGridID = Me%ObjHorizontalGrid,                   &
                             FillValue        = -99.,                                   &
                             OverWrite        = .true.,                                 &
                             GridData2D_Real  = Me%Output%MapMin,                       &
                             STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutputFloodRisk - ModuleHydrodynamic - ERR70'


    end subroutine OutputFloodRisk

    !--------------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                             !
    ! OutPut:                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine Deassociate_External_Modules

        !Arguments-------------------------------------------------------------

        !Local---------------------------------------------------------
        integer                       :: nUsers

        nUsers = DeassociateInstance (mTIME_,           Me%ObjTime)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR01'

        nUsers = DeassociateInstance (mGRIDDATA_,       Me%ObjGridData)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR02'

        nUsers = DeassociateInstance (mHORIZONTALGRID_,  Me%ObjHorizontalGrid)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR03'

        nUsers = DeassociateInstance (mHORIZONTALMAP_,  Me%ObjHorizontalMap)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR04'

        nUsers = DeassociateInstance (mGEOMETRY_,       Me%ObjGeometry)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR05'

        nUsers = DeassociateInstance (mMAP_,            Me%ObjMap)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR06'

        nUsers = DeassociateInstance (mTURBULENCE_,     Me%ObjTurbulence)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR07'
#ifndef _WAVES_
        if(Me%ObjWaves /= 0)then
            nUsers = DeassociateInstance (mWAVES_,  Me%ObjWaves)
            if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR08'
        end if
#endif
        nUsers = DeassociateInstance (mTwoWay_,     Me%ObjTwoWay)
        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR08'

!        nUsers = DeassociateInstance (mBOTTOM_,         Me%ObjBottom)
!        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR08'

!        nUsers = DeassociateInstance (mSURFACE_,        Me%ObjSurface)
!        if (nUsers == 0) stop 'KillHydrodynamic - ModuleHydrodynamic - ERR09'

    End Subroutine Deassociate_External_Modules

    !End---------------------------------------------------------


    !If needed the sub-modules responsible for the:
    !   - Turbulence
    !   - OpenBoundary
    !   - Discharges
    !   - Surface conditions
    !   - Bottom Conditions
    !will be construct in this subroutine

    subroutine Kill_Sub_Modules


        !Arguments------------------------------------------------------------

        !Local----------------------------------------------------------------
        integer :: STAT_CALL, nUsers, dis

        !Begin----------------------------------------------------------------


        if (Me%ComputeOptions%WaterDischarges) then

            nUsers = GetUsersNumber(mDISCHARGES_, Me%ObjDischarges)
            if (nUsers == 1) then

                call Kill_Discharges(Me%ObjDischarges, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                               &
                    stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR01.'


                if (Me%OutPut%TimeSerieDischON) then
                    do dis = 1, Me%OutPut%DischargesNumber

                        call KillTimeSerie(TimeSerieID         = Me%OutPut%TimeSerieDischID(dis), &
                                             STAT              = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Kill_Sub_Modules - Hydrodynamic - ERR40'

                    enddo

                    deallocate(Me%OutPut%TimeSerieDischProp)
                    deallocate(Me%OutPut%TimeSerieDischID)

                endif

            else if (nUsers > 1) then

                nUsers = DeassociateInstance (mDISCHARGES_, Me%ObjDischarges)
                if (nUsers == 0) stop 'Kill_Sub_Modules - ModuleHydrodynamic - ERR02'

            else

                stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR03.'

            endif

        endif


        !Kill the assimilation object
        if (Me%ComputeOptions%Relaxation .or. Me%ComputeOptions%AltimetryAssimilation%Yes)  then

            nUsers = GetUsersNumber(mASSIMILATION_, Me%ObjAssimilation)
            if (nUsers == 1) then

                call KillAssimilation(Me%ObjAssimilation, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                               &
                    stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR04.'

            else if (nUsers > 1) then

                nUsers = DeassociateInstance (mASSIMILATION_, Me%ObjAssimilation)
                if (nUsers == 0) stop 'Kill_Sub_Modules - ModuleHydrodynamic - ERR05'

            else

                stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR06.'

            endif


        endif

        call KillOpenBoundary(Me%ObjOpenBoundary, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR07.'


        if (Me%ComputeOptions%Evolution == Read_File_) then
            call KillHydrodynamicFile(Me%ObjHydrodynamicFileIn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR08.'
        endif

        if (Me%ComputeOptions%Recording) then
            call KillHydrodynamicFile(Me%ObjHydrodynamicFileOut, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                            &
                stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR09.'
        endif

        !Kill boxes
cd1:    if (Me%State%BOXFLUXES) then

            call KillBoxDif(Me%ObjBoxDif, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR10.'

        endif cd1

        !Disposes the rest of the energy buffer
        if (Me%ComputeOptions%Energy) call KillEnergy

        !Deallocates the variables necessary to compute
        !the tide potential
        if (Me%TidePotential%Compute) call KillTidePotential

        if (Me%SubModel%ON) call KillSubModel

        if (Me%Generic4D%ON) call KillTimeSerie(Me%Generic4D%ObjTimeSerie, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR11.'

        if (Me%ComputeOptions%Turbine) then
            nUsers = GetUsersNumber(mTURBINE_, Me%ObjTurbine)
            if (nUsers == 1) then
                call KillTurbine(Me%ObjTurbine, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR12.'
            else if (nUsers > 1) then

                nUsers = DeassociateInstance (mTURBINE_, Me%ObjTurbine)
                if (nUsers == 0) stop 'Kill_Sub_Modules - ModuleHydrodynamic - ERR13'

            else

                stop 'Subroutine Kill_Sub_Modules - ModuleHydrodynamic. ERR14'

            endif

        endif


    end subroutine Kill_Sub_Modules

    !End----------------------------------------------------------------------

    subroutine KillEnergy

        !Arguments------------------------------------------------------------


        !Local----------------------------------------------------------------
        integer                         :: STAT_CALL

        !Disposes the rest of the buffer
        call WriteEnergyDataFile

        write (Me%Energy%FileID,*)  '<EndTimeSerie>'

        call UnitsManager(Me%Energy%FileID, FileClose, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR01'

        !Deallocates buffer
        deallocate(Me%Energy%SecondsBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR07'

        deallocate(Me%Energy%KineticBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR08'

        deallocate(Me%Energy%PotentialBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR09'

        deallocate(Me%Energy%VorticityBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR09a'

        deallocate(Me%Energy%MassBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR10'

        deallocate(Me%Energy%VolumeBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR11'

        deallocate(Me%Energy%OpenVolumeBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR11a'

        deallocate(Me%Energy%WaterLevelBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR12'

        deallocate(Me%Energy%BarotropicKEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR13'

        deallocate(Me%Energy%RelativeKEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR14'

        deallocate(Me%Energy%RelativePEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR15'

        deallocate(Me%Energy%BaroclinicKEBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR16'

        deallocate(Me%Energy%VelMaxBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR17'

        deallocate(Me%Energy%VelMaxBaroclinicBuffer, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR18'

        deallocate(Me%Energy%CenterU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR19'

        deallocate(Me%Energy%CenterV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR20'

        deallocate(Me%Energy%CenterW, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR21'

        deallocate(Me%Energy%BarotropicU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR22'

        deallocate(Me%Energy%BarotropicV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                        &
            stop 'KillEnergy - ModuleHydrodynamic - ERR23'

    end subroutine KillEnergy

    !--------------------------------------------------------------------------

    Subroutine KillTidePotential

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer   :: STATUS



        deallocate (Me%TidePotential%Frequency, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR01")

        deallocate (Me%TidePotential%Amplitude, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR02")

        deallocate (Me%TidePotential%Arguments        , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR03")

        deallocate (Me%TidePotential%Beta            , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR04")

        deallocate (Me%TidePotential%m               , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR05")

        deallocate (Me%TidePotential%L               , STAT = STATUS)
        if (STATUS /= SUCCESS_)                                              &
            call SetError (FATAL_, OUT_OF_MEM_, "KillTidePotential - Hydrodynamic - ERR06")


    end subroutine KillTidePotential


    !-----------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine KillHydroStatistics

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer   :: STATUS, i


        if (Me%Statistics%ON) then


            do i = 1, Me%Statistics%Nprop

                call KillStatistic (Me%Statistics%ID(i), STAT = STATUS)
                if (STATUS /= SUCCESS_)                                                  &
                    call SetError (FATAL_, OUT_OF_MEM_, "KillHydroStatistics - Hydrodynamic - ERR10")

            enddo

            deallocate(Me%Statistics%PropList, Me%Statistics%ID)

        endif

        if (Me%Statistics2D%ON) then


            do i = 1, Me%Statistics2D%Nprop

                call KillStatistic (Me%Statistics2D%ID(i), STAT = STATUS)
                if (STATUS /= SUCCESS_)                                                  &
                    call SetError (FATAL_, OUT_OF_MEM_, "KillHydroStatistics - Hydrodynamic - ERR20")

            enddo

            deallocate(Me%Statistics2D%PropList, Me%Statistics2D%ID)

        endif

    end subroutine KillHydroStatistics

    !-----------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine KillSubModel

        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer   :: STATUS



        deallocate (Me%SubModel%Z, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR01")

        nullify(Me%SubModel%Z)

        deallocate (Me%SubModel%U_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR02")

        nullify(Me%SubModel%U_New)

        deallocate (Me%SubModel%V_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR03")

        nullify(Me%SubModel%V_New)

        nullify(Me%SubModel%UV_New)


        deallocate (Me%SubModel%DUZ_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR04")

        nullify(Me%SubModel%DUZ_New)

        deallocate (Me%SubModel%DVZ_New, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR05")

        nullify(Me%SubModel%DVZ_New)



        deallocate (Me%SubModel%qX, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR06")

        nullify(Me%SubModel%qX)

        deallocate (Me%SubModel%qY, STAT = STATUS)

        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR07")

        nullify(Me%SubModel%qY )

        nullify(Me%SubModel%qXY)

        nullify(Me%SubModel%qYX)


        deallocate (Me%SubModel%DUZ_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR08")

        nullify(Me%SubModel%DUZ_Old)

        deallocate (Me%SubModel%DVZ_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR09")

        nullify(Me%SubModel%DVZ_Old)

        nullify(Me%SubModel%DUVZ_Old)

        deallocate (Me%SubModel%U_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR10")

        nullify(Me%SubModel%U_Old)

        deallocate (Me%SubModel%V_Old, STAT = STATUS)
        if (STATUS /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR11")

        nullify(Me%SubModel%V_Old)

        nullify(Me%SubModel%UV_Old)

cd1:    if (Me%SubModel%InterpolTime) then

            deallocate (Me%SubModel%Z_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR12")

            nullify(Me%SubModel%Z_Previous)

            deallocate (Me%SubModel%Z_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR13")

            nullify(Me%SubModel%Z_Next)

            deallocate (Me%SubModel%U_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR14")

            nullify(Me%SubModel%U_Previous)

            deallocate (Me%SubModel%U_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR15")

            nullify(Me%SubModel%U_Next)


            deallocate (Me%SubModel%V_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR16")

            nullify(Me%SubModel%V_Previous)

            deallocate (Me%SubModel%V_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR17")

            nullify(Me%SubModel%V_Next)


            deallocate (Me%SubModel%DUZ_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR18")

            nullify(Me%SubModel%DUZ_Previous)

            deallocate (Me%SubModel%DUZ_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR19")

            nullify(Me%SubModel%DUZ_Next)


            deallocate (Me%SubModel%DVZ_Previous, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR20")

            nullify(Me%SubModel%DVZ_Previous)

            deallocate (Me%SubModel%DVZ_Next, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR21")

            nullify(Me%SubModel%DVZ_Next)

        endif cd1

        if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                            &
            (Me%SubModel%VertComunic == Father3DSon2D)) then

            deallocate (Me%SubModel%Aux_qX, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR22")

            nullify(Me%SubModel%Aux_qX)

            deallocate (Me%SubModel%Aux_qY, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR23")

            nullify(Me%SubModel%Aux_qY)

            deallocate (Me%SubModel%Aux_DUZ, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR24")

            nullify(Me%SubModel%Aux_DUZ)

            deallocate (Me%SubModel%Aux_DVZ, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR25")

            nullify(Me%SubModel%Aux_DVZ)

            deallocate (Me%SubModel%Aux_U, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR26")

            nullify(Me%SubModel%Aux_U)

            deallocate (Me%SubModel%Aux_V, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR27")

            nullify(Me%SubModel%Aux_V)

        endif

cd2:    if (Me%SubModel%DeadZone) then

            deallocate (Me%SubModel%DeadZonePoint, STAT = STATUS)
            if (STATUS /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "KillSubModel - Hydrodynamic - ERR28")

        endif cd2



    End Subroutine KillSubModel

    !--------------------------------------------------------------------------

    subroutine KillHighLowTideOutput

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL

        !----------------------------------------------------------------------    


i1:     if (Me%HighLowTide%ON) then          
            
            deallocate(Me%HighLowTide%SeaLevel)
            deallocate(Me%HighLowTide%Instant )
            
            !Kill HDF File
            call KillHDF5 (HDF5ID     = Me%HighLowTide%ObjHDF5,                         &
                           STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'KillHighLowTideOutput - ModuleHydrodynamic - ERR10'     

                                                                                                                    
            call KillTimeSerie(TimeSerieID        = Me%HighLowTide%ObjTimeSerieRef,     &
                               STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'KillHighLowTideOutput - ModuleHydrodynamic - ERR20'
            
        endif i1

    end subroutine KillHighLowTideOutput        

    !--------------------------------------------------------------------------    

    Subroutine DeallocateVariables

        !Arguments-------------------------------------------------------------

        !griflet
        type(T_Coef_Baroc), pointer :: LocalBaroc
        type(T_VECGW), pointer      :: VECGW
        integer                     :: p

        !Local-----------------------------------------------------------------

        integer :: STAT_CALL

        !Begin------------------------------------------------------------------

        !Water level variables allocation
        deallocate (Me%WaterLevel%New, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR10.'

        nullify (Me%WaterLevel%New)



        deallocate (Me%WaterLevel%Old, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR20.'

        nullify (Me%WaterLevel%Old)

        deallocate (Me%WaterLevel%VolumeCreated, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR30.'

        nullify (Me%WaterLevel%VolumeCreated)

        if (Me%ComputeOptions%WaterLevelMaxMin) then

            deallocate (Me%WaterLevel%Maxi, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR40.'

            nullify (Me%WaterLevel%Maxi)

            deallocate (Me%WaterLevel%Mini, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR50.'

            nullify (Me%WaterLevel%Mini)

        endif

#ifdef _USE_PAGELOCKED
        ! FreePageLocked will also nullify the pointers and arrays
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%NewPtr, Me%Velocity%Horizontal%U%New)
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%U%OldPtr, Me%Velocity%Horizontal%U%Old)
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%NewPtr, Me%Velocity%Horizontal%U%New)
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Horizontal%V%OldPtr, Me%Velocity%Horizontal%U%Old)
#else
        !Horizontal velocity
        deallocate (Me%Velocity%Horizontal%U%New, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR60.'

        nullify (Me%Velocity%Horizontal%U%New)



        deallocate (Me%Velocity%Horizontal%U%Old, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR70.'

        nullify (Me%Velocity%Horizontal%U%Old)



        deallocate (Me%Velocity%Horizontal%V%New, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR80.'

        nullify (Me%Velocity%Horizontal%V%New)



        deallocate (Me%Velocity%Horizontal%V%Old, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR90.'

        nullify (Me%Velocity%Horizontal%V%Old)
#endif _USE_PAGELOCKED

        !Auxiliar horizontal velocity pointers
        nullify (Me%Velocity%Horizontal%UV%New)
        nullify (Me%Velocity%Horizontal%UV%Old)

        nullify (Me%Velocity%Horizontal%VU%New)
        nullify (Me%Velocity%Horizontal%VU%Old)


        ! guillaume
        if (Me%Geostroph%ON) then
            deallocate (Me%Geostroph%U                      )
            deallocate (Me%Geostroph%V                      )
            deallocate (Me%Geostroph%AuxDesCentre           )
            deallocate (Me%Geostroph%PressGrad              )
            deallocate (Me%Geostroph%U_barotropic           )
            deallocate (Me%Geostroph%V_barotropic           )
            nullify    (Me%Geostroph%U                      )
            nullify    (Me%Geostroph%V                      )
            nullify    (Me%Geostroph%UV                     )
            nullify    (Me%Geostroph%VU                     )
            nullify    (Me%Geostroph%AuxDesCentre           )
            nullify    (Me%Geostroph%PressGrad              )
            nullify    (Me%Geostroph%U_barotropic           )
            nullify    (Me%Geostroph%V_barotropic           )
        endif

        !Vertical Velocity
#ifdef _USE_PAGELOCKED
        ! FreePageLocked will also nullify the pointers and arrays
        call FreePageLocked(Me%ObjCuda, Me%Velocity%Vertical%CartesianPtr, Me%Velocity%Vertical%Cartesian)
#else
        deallocate (Me%Velocity%Vertical%Cartesian, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR100.'

        nullify (Me%Velocity%Vertical%Cartesian)
#endif _USE_PAGELOCKED

        deallocate (Me%Velocity%Vertical%Across, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR110.'

        nullify (Me%Velocity%Vertical%Across)

        deallocate (Me%Velocity%BarotropicUc, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR120.'

        nullify (Me%Velocity%BarotropicUc)

        deallocate (Me%Velocity%BarotropicVc, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR120.'

        nullify (Me%Velocity%BarotropicVc)

        if (Me%NonHydrostatic%ON) then

            deallocate (Me%Velocity%Vertical%CartesianOld, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR130.'

            nullify (Me%Velocity%Vertical%CartesianOld)

            deallocate (Me%NonHydrostatic%PressureCorrect, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR140.'

            nullify (Me%NonHydrostatic%PressureCorrect)

            deallocate (Me%NonHydrostatic%PrevisionalQ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR150.'

            nullify (Me%NonHydrostatic%PrevisionalQ)

            deallocate (Me%NonHydrostatic%CCoef, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR160.'

            nullify (Me%NonHydrostatic%CCoef)

            deallocate (Me%NonHydrostatic%GCoef, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR170.'

            nullify (Me%NonHydrostatic%GCoef)

            deallocate (Me%NonHydrostatic%VerticalSurfLayerOld, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR180.'

            nullify (Me%NonHydrostatic%VerticalSurfLayerOld)


        endif

        if (.not. Me%ComputeOptions%BaroclinicRadia == NoRadiation_) then

            deallocate (Me%VelBaroclinic%W_New, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR190.'

            nullify (Me%VelBaroclinic%W_New)

            deallocate (Me%VelBaroclinic%W_Old, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR200.'

            nullify (Me%VelBaroclinic%W_Old)

            deallocate (Me%VelBaroclinic%U%New, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR210.'

            nullify(Me%VelBaroclinic%U%New)

            deallocate (Me%VelBaroclinic%U%Old, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR220.'

            nullify(Me%VelBaroclinic%U%Old)



            deallocate (Me%VelBaroclinic%V%New, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR230.'

            nullify(Me%VelBaroclinic%V%New)

            deallocate (Me%VelBaroclinic%V%Old, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR240.'

            nullify(Me%VelBaroclinic%V%Old)

            deallocate (Me%VelBaroclinic%U2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR250.'

            nullify(Me%VelBaroclinic%U2D)


            deallocate (Me%VelBaroclinic%V2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR260.'

            nullify(Me%VelBaroclinic%V2D)


            !Auxiliar horizontal baroclinic velocity pointers
            nullify (Me%VelBaroclinic%UV%New)
            nullify (Me%VelBaroclinic%UV%Old)

            nullify (Me%VelBaroclinic%VU%New)
            nullify (Me%VelBaroclinic%VU%Old)

            nullify (Me%VelBaroclinic%UV2D)

        endif



        !Water fluxes
        deallocate (Me%WaterFluxes%X, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DellocateVariables - ModuleHydrodynamic. ERR270.'

        nullify (Me%WaterFluxes%X)

        deallocate (Me%WaterFluxes%Y, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR280.'

        nullify (Me%WaterFluxes%Y)


        deallocate (Me%WaterFluxes%Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR290.'

        nullify (Me%WaterFluxes%Z)

        deallocate (Me%WaterFluxes%Discharges, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                   &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR300.'

        nullify (Me%WaterFluxes%Discharges)

        !Auxiliar Water Fluxes
        nullify (Me%WaterFluxes%XY)
        nullify (Me%WaterFluxes%YX)

        if (Me%ComputeOptions%MomentumDischarge) then
            deallocate (Me%WaterFluxes%DischargesVelU)
            deallocate (Me%WaterFluxes%DischargesVelV)
            nullify    (Me%WaterFluxes%DischargesVelU)
            nullify    (Me%WaterFluxes%DischargesVelV)
            nullify    (Me%WaterFluxes%DischargesVelUV)
        endif


        !If compute Residual properties then must allocate residual variables

cd1:    if (Me%ComputeOptions%Residual) then


            Me%Residual%ResidualTime = FillValueReal


            !Can be interesting to compute the average water level
            deallocate (Me%Residual%WaterLevel, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR310.'

            nullify (Me%Residual%WaterLevel)


            deallocate (Me%Residual%Velocity_U, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR320.'

            nullify (Me%Residual%Velocity_U)



            deallocate (Me%Residual%Velocity_V, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR330.'

            nullify (Me%Residual%Velocity_V)


            deallocate (Me%Residual%Vertical_Velocity, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR340.'

            nullify (Me%Residual%Vertical_Velocity)


            deallocate (Me%Residual%WaterFlux_X, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR350.'

            nullify (Me%Residual%WaterFlux_X)



            deallocate (Me%Residual%WaterFlux_Y, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR360.'

            nullify (Me%Residual%WaterFlux_Y)

            deallocate (Me%Residual%DWZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR380.'

            nullify (Me%Residual%DWZ)


        endif cd1


        !Forces
        deallocate (Me%Forces%Rox3X, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR390.'

        nullify (Me%Forces%Rox3X)

        deallocate (Me%Forces%Rox3Y, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR400.'

        nullify (Me%Forces%Rox3Y)


        deallocate (Me%Forces%Horizontal_Transport, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR410.'

        nullify (Me%Forces%Horizontal_Transport)

        deallocate (Me%Forces%Inertial_Aceleration, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR420.'

        nullify (Me%Forces%Inertial_Aceleration)


        deallocate (Me%Forces%TidePotentialLevel,   STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR430.'

        nullify (Me%Forces%TidePotentialLevel)


        if(Me%ComputeOptions%AltimetryAssimilation%Yes) then

            deallocate (Me%Forces%Altim_Relax_Aceleration,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
               stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR440.'

            nullify (Me%Forces%Altim_Relax_Aceleration)

        endif

        if (Me%Relaxation%Force) then
            deallocate (Me%Forces%Relax_Aceleration, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR450.'

            nullify (Me%Forces%Relax_Aceleration)

        endif


        if (Me%Relaxation%Geometry) then
            deallocate (Me%Relaxation%DecayTimeGeo, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR460.'

            nullify (Me%Relaxation%DecayTimeGeo)

        endif

        if (Me%WaveStress%Dumping) then

            deallocate (Me%WaveStress%DumpCoef, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR470.'

            nullify (Me%WaveStress%DumpCoef)

        endif

        !Coefficients
        deallocate (Me%Coef%D2%D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR480.'

        nullify (Me%Coef%D2%D)



        deallocate (Me%Coef%D2%E, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR490.'

        nullify (Me%Coef%D2%E)

        deallocate (Me%Coef%D2%EAux, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR500.'

        nullify (Me%Coef%D2%EAux)


        deallocate (Me%Coef%D2%F, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR510.'

        nullify (Me%Coef%D2%F)



        deallocate (Me%Coef%D2%Ti, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR520.'

        nullify (Me%Coef%D2%Ti)


        deallocate (Me%Coef%D2%TiAux, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR530.'

        nullify (Me%Coef%D2%TiAux)


cd2:    if (Me%ComputeOptions%BarotropicRadia == FlatherWindWave_ .or.      &
            Me%ComputeOptions%BarotropicRadia == FlatherLocalSolution_) then

            deallocate (Me%Coef%D2%Rad, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR540.'

            nullify(Me%Coef%D2%Rad)


            deallocate (Me%Coef%D2%TiRad, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR550.'

            nullify(Me%Coef%D2%TiRad)

        endif cd2

#ifdef _USE_PAGELOCKED
        ! FreePageLocked will also nullify the pointers and arrays
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%DPtr, Me%Coef%D3%D)
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%EPtr, Me%Coef%D3%E)
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%FPtr, Me%Coef%D3%F)
        call FreePageLocked(Me%ObjCuda, Me%Coef%D3%TiPtr, Me%Coef%D3%Ti)
#else
        deallocate (Me%Coef%D3%D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR560.'

        deallocate (Me%Coef%D3%E, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR570.'

        deallocate (Me%Coef%D3%F, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR580.'

        deallocate (Me%Coef%D3%Ti, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR590.'

        nullify (Me%Coef%D3%D)
        nullify (Me%Coef%D3%E)
        nullify (Me%Coef%D3%F)
        nullify (Me%Coef%D3%Ti)
#endif _USE_PAGELOCKED

        !External Variables

        !Bottom boundary: this variable in the future must migrate to the module ModuleBottom
        deallocate (Me%External_Var%ChezyZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR600.'

        nullify (Me%External_Var%ChezyZ)

        deallocate (Me%External_Var%ChezyVelUV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR610.'

        nullify (Me%External_Var%ChezyVelUV)



        !OutPut Time variables

cd3:    if (Me%OutPut%hdf5ON) then


            Deallocate (Me%OutPut%OutTime, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Sub. DeallocateVariables - ModuleHydrodynamic - ERR620'

            nullify (Me%OutPut%OutTime)


        endif cd3


        if(Me%OutPut%ProfileON)then

            call KillProfile(Me%ObjProfile, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                stop 'DeallocateVariables - ModuleHydrodynamic - ERR630'

        end if

        !Kills the TimeSerie
        if (Me%ObjTimeSerie /= 0) then
            call KillTimeSerie(Me%ObjTimeSerie, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                stop 'DeallocateVariables - ModuleHydrodynamic - ERR640'
        endif


cd4:    if (Me%ComputeOptions%Baroclinic) then

            !griflet
            do p=1,Me%MaxThreads

                LocalBaroc => Me%Coef%Baroc(p)

                deallocate (LocalBaroc%Kleft,       STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR650.'
                nullify (LocalBaroc%Kleft)

                deallocate (LocalBaroc%Kright,      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR660'
                nullify (LocalBaroc%Kright)

                deallocate (LocalBaroc%Depth_integ, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR670'
                nullify (LocalBaroc%Depth_integ)

                deallocate (LocalBaroc%Hcenter,     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR680'
                nullify (LocalBaroc%Hcenter)

                deallocate (LocalBaroc%Hleft,       STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR690'
                nullify (LocalBaroc%Hleft)

                deallocate (LocalBaroc%Hright,      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR700'
                nullify (LocalBaroc%Hright)

                deallocate (LocalBaroc%HroLeft,     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR710'
                nullify (LocalBaroc%HroLeft)

                deallocate (LocalBaroc%HroRight,    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR720'
                nullify (LocalBaroc%HroRight)

                deallocate (LocalBaroc%DensRight,    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR710'
                nullify (LocalBaroc%DensRight)

                deallocate (LocalBaroc%DensLeft,    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                   &
                    stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR720'
                nullify (LocalBaroc%DensLeft)

            enddo

        endif cd4

        !griflet
        do p = 1, Me%MaxThreads
            VECGW => Me%THOMAS2D%VEC(p)
            deallocate(VECGW%G)
            deallocate(VECGW%W)
        enddo
        deallocate(Me%THOMAS2D%VEC)
        deallocate(Me%THOMAS2D%COEF2)
        deallocate(Me%THOMAS2D)

        do p = 1, Me%MaxThreads
            VECGW => Me%THOMAS%VEC(p)
            deallocate(VECGW%G)
            deallocate(VECGW%W)
        enddo
        deallocate(Me%THOMAS%VEC)
        deallocate(Me%THOMAS%COEF3)
        deallocate(Me%THOMAS)

        deallocate (Me%VECG_3D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR730'
        nullify (Me%VECG_3D)


        deallocate (Me%VECW_3D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR740'
        nullify (Me%VECW_3D)


        deallocate (Me%VECG_2D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR750'
        nullify (Me%VECG_2D)


        deallocate (Me%VECW_2D,    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR760'
        nullify (Me%VECW_2D)

        if (Me%ComputeOptions%BarotropicRadia == BlumbergKantha_)  then

            deallocate (Me%ComputeOptions%Tlag, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR770'
            nullify (Me%ComputeOptions%Tlag)

        endif

        if (Me%ComputeOptions%BiHarmonic) then

            deallocate (Me%ComputeOptions%BiHarmonicUX_VY,    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR780'

            deallocate (Me%ComputeOptions%BiHarmonicUY_VX,    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'Subroutine DeallocateVariables - ModuleHydrodynamic. ERR790'

        endif

ic1:    if (Me%CyclicBoundary%ON) then

            deallocate (Me%Coef%D1%a,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR800.'

            deallocate (Me%Coef%D1%b,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR810.'

            deallocate (Me%Coef%D1%bb,  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR820.'

            deallocate (Me%Coef%D1%c,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR830.'

            deallocate (Me%Coef%D1%r,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR840.'

            deallocate (Me%Coef%D1%u,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR850.'

            deallocate (Me%Coef%D1%x,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR860.'

            deallocate (Me%Coef%D1%z,   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR870.'

            deallocate (Me%Coef%D1%gam, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR880.'

        endif ic1

        if(Me%ComputeOptions%Obstacle)then

            deallocate (Me%Drag%Coef, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR890.'

            if(Me%Drag%ID%SolutionFromFile)then
                call KillFillMatrix(Me%Drag%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR900.'
            endif


            deallocate (Me%Forces%ObstacleDrag_Aceleration, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR910.'


        end if

        if(Me%ComputeOptions%Scraper)then

            deallocate (Me%Forces%Scraper_Aceleration, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR920.'

            deallocate (Me%Scraper%Position, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR930.'

            if (Me%Scraper%UOn) deallocate(Me%Scraper%VelU)

            if (Me%Scraper%VOn) deallocate(Me%Scraper%VelV)

            if(Me%Scraper%ID_U%SolutionFromFile)then
                call KillFillMatrix(Me%Scraper%ID_U%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR940.'
            endif


            if(Me%Scraper%ID_V%SolutionFromFile)then
                call KillFillMatrix(Me%Scraper%ID_V%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR950.'
            endif

!            if(Me%Scraper%ID_W%SolutionFromFile)then
!                call KillFillMatrix(Me%Scraper%ID_W%ObjFillMatrix, STAT = STAT_CALL)
!                if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables; ModuleHydrodynamic. ERR960.'
!            endif


        end if

        if (Me%OutPut%TimeSerieON .or. Me%OutPut%hdf5ON .or.                            &
            Me%OutPut%ProfileON   .or. Me%OutPut%HDF5_Surface_ON.or.                    &
            Me%OutW%OutPutWindowsON) then
            call KillMatrixesOutput
        endif

        if (Me%ComputeOptions%InvertBaromSomeBound)                                     &
            deallocate(Me%ComputeOptions%InvertBarometerCells)


        deallocate(Me%Aux3DFlux)

        if (Me%ThinWalls%ON) then
            call KillThinWalls
        endif

        if(Me%ComputeOptions%EmersionTime)then

            deallocate (Me%Emersion%EmersionTime )
            deallocate (Me%Emersion%ImmersionTime)

        endif


        if(Me%Output%FloodRisk)then

            deallocate(Me%Output%MaxWaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR970'

            deallocate(Me%Output%VelocityAtMaxWaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR980'

            deallocate(Me%Output%MaxFloodRisk, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR990'

            deallocate(Me%Output%MaxVelocity, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR1000'

            deallocate(Me%Output%MaxWaterLevel, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR1010'

            deallocate(Me%Output%MapMax, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR1020'

            deallocate(Me%Output%MapMin, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateVariables - ModuleHydrodynamic - ERR1030'

        endif

! Modified by Matthias DELPEY - 21/07/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 27/07/2011 - 19/08/2011 - 24/08/2011 - 31/08/2011 - 08/09/2011 - 25/10/2011 - 25/11/2011
! 25/01/2011

        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            ! Horizontal velocities
            deallocate(Me%StokesVel%Horizontal%U%New)
            deallocate(Me%StokesVel%Horizontal%U%Old)
            deallocate(Me%StokesVel%Horizontal%V%New)
            deallocate(Me%StokesVel%Horizontal%V%Old)

            nullify(Me%StokesVel%Horizontal%U%New)
            nullify(Me%StokesVel%Horizontal%U%Old)
            nullify(Me%StokesVel%Horizontal%V%New)
            nullify(Me%StokesVel%Horizontal%V%Old)

            nullify(Me%StokesVel%Horizontal%UV%New)
            nullify(Me%StokesVel%Horizontal%UV%Old)
            nullify(Me%StokesVel%Horizontal%VU%New)
            nullify(Me%StokesVel%Horizontal%VU%Old)

            ! Vertical velocities
            deallocate(Me%StokesVel%Vertical%Across)
            deallocate(Me%StokesVel%Vertical%Cartesian)
            deallocate(Me%StokesVel%BottomStokesVertVel)

            nullify(Me%StokesVel%Vertical%Across)
            nullify(Me%StokesVel%Vertical%Cartesian)
            nullify(Me%StokesVel%BottomStokesVertVel)

            ! Water fluxes
            deallocate(Me%StokesWaterFluxes%X)
            deallocate(Me%StokesWaterFluxes%Y)
            deallocate(Me%StokesWaterFluxes%Z)

            nullify(Me%StokesWaterFluxes%X)
            nullify(Me%StokesWaterFluxes%Y)
            nullify(Me%StokesWaterFluxes%Z)

            nullify(Me%StokesWaterFluxes%XY)
            nullify(Me%StokesWaterFluxes%YX)

            ! Surface momentum fluxes (les autres champs sont nettoyes dans UnGetWaves3D)
            nullify(Me%External_Var%AtmToWaveMomentum_UV)
            nullify(Me%External_Var%WaveToOceanMomentum_UV)

            ! Accelerations
            deallocate (Me%Forces%Wave3DExplicit_Acceleration)

            deallocate (Me%Forces%Wave3DExplicit_FPressureAccelU)
            deallocate (Me%Forces%Wave3DExplicit_FPressureAccelV)
            ! deallocate (Me%Forces%Wave3DExplicit_FPressureAccelUV)

            deallocate (Me%Forces%Wave3DExplicit_FVortexAccelU)
            deallocate (Me%Forces%Wave3DExplicit_FVortexAccelV)
            ! deallocate (Me%Forces%Wave3DExplicit_FVortexAccelUV)
            ! deallocate (Me%Forces%AdvectVelocity)

            deallocate (Me%Forces%Wave3DExplicit_FBreakingAccelU)
            deallocate (Me%Forces%Wave3DExplicit_FBreakingAccelV)
            ! deallocate (Me%Forces%Wave3DExplicit_FBreakingAccelUV)

            nullify (Me%Forces%Wave3DExplicit_Acceleration)

            nullify (Me%Forces%Wave3DExplicit_FPressureAccelU)
            nullify (Me%Forces%Wave3DExplicit_FPressureAccelV)
            nullify (Me%Forces%Wave3DExplicit_FPressureAccelUV)

            nullify (Me%Forces%Wave3DExplicit_FVortexAccelU)
            nullify (Me%Forces%Wave3DExplicit_FVortexAccelV)
            nullify (Me%Forces%Wave3DExplicit_FVortexAccelUV)
            ! nullify (Me%Forces%AdvectVelocity)

            nullify (Me%Forces%Wave3DExplicit_FBreakingAccelU)
            nullify (Me%Forces%Wave3DExplicit_FBreakingAccelV)
            nullify (Me%Forces%Wave3DExplicit_FBreakingAccelUV)

        endif

        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then

            ! Tensions de radiations 3D
            deallocate(Me%WaveRad3D%WaveExpRadU)
            deallocate(Me%WaveRad3D%WaveExpRadV)

            nullify(Me%WaveRad3D%WaveExpRadU)
            nullify(Me%WaveRad3D%WaveExpRadV)

            nullify(Me%WaveRad3D%WaveExpRadUV)

            ! Accelerations
            deallocate (Me%Forces%Wave3DExplicit_Acceleration)

            nullify (Me%Forces%Wave3DExplicit_Acceleration)

        endif

        deallocate (Me%FaceDensity)
        nullify (Me%FaceDensity)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

       !----------------------------------------------------------------------

    end subroutine DeallocateVariables

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine KillThinWalls

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL

        !----------------------------------------------------------------------

        if (Me%ThinWalls%UOn) then

            deallocate(Me%ThinWalls%FaceU_I)
            deallocate(Me%ThinWalls%FaceU_J)
            deallocate(Me%ThinWalls%FaceU_K)

        endif

        if (Me%ThinWalls%VOn) then

            deallocate(Me%ThinWalls%FaceV_I)
            deallocate(Me%ThinWalls%FaceV_J)
            deallocate(Me%ThinWalls%FaceV_K)

        endif

        if (Me%ThinWalls%WOn) then

            deallocate(Me%ThinWalls%FaceW_I)
            deallocate(Me%ThinWalls%FaceW_J)
            deallocate(Me%ThinWalls%FaceW_K)

        endif

        if (Me%ThinWalls%VariableInTime) then
            deallocate(Me%Forces%ThinWalls_Dissipation)
            call KillTimeSerie(TimeSerieID         = Me%ThinWalls%ObjTimeSerie,         &
                                 STAT              = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'KillThinWalls - Hydrodynamic - ERR10'

        endif

    end subroutine KillThinWalls

    !--------------------------------------------------------------------------

    subroutine KillMatrixesOutput

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------


        !Horizontal Velocity
        if (Me%Output%Real4)then
            deallocate(Me%OutPut%AuxReal4,                                               &
                       Me%OutPut%Aux2DReal4,                                             &
                       Me%OutPut%CenterU,                                                &
                       Me%OutPut%CenterV,                                                &
                       Me%OutPut%ModulusH,                                               &
                       Me%OutPut%Aux2D,                                                  &
                       Me%OutPut%CenterW)
        else
            deallocate(Me%OutPut%CenterU,                                                &
                       Me%OutPut%CenterV,                                                &
                       Me%OutPut%ModulusH,                                               &
                       Me%OutPut%Aux2D,                                                  &
                       Me%OutPut%CenterW)
        endif

        deallocate(Me%OutPut%DirectionH,                                                &
                   Me%OutPut%CenterUaux,                                                &
                   Me%OutPut%CenterVaux,                                                &
                   Me%OutPut%ModulusUVaux,                                              &
                   Me%OutPut%CenterWaux,                                                &
                   Me%OutPut%CenterUglm   ,                                             &
                   Me%OutPut%CenterVglm   ,                                             &
                   Me%OutPut%ModulusHglm  ,                                             &
                   Me%OutPut%CenterWglm   ,                                             &
                   Me%OutPut%CenterUstokes   ,                                          &
                   Me%OutPut%CenterVstokes   ,                                          &
                   Me%OutPut%ModulusHstokes  ,                                          &
                   Me%OutPut%CenterWstokes   ,                                          &
                   STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'KillMatrixesOutput - ModuleHydrodynamic - ERR10'

        if(Me%Output%Real4)then
            nullify  (Me%OutPut%AuxReal4    )
            nullify  (Me%OutPut%Aux2DReal4  )
            nullify  (Me%OutPut%CenterU     )
            nullify  (Me%OutPut%CenterV     )
            nullify  (Me%OutPut%ModulusH    )
            nullify  (Me%OutPut%CenterW     )
            nullify  (Me%OutPut%Aux2D       )
        else
        nullify  (Me%OutPut%CenterU     )
        nullify  (Me%OutPut%CenterV     )
        nullify  (Me%OutPut%ModulusH    )
        nullify  (Me%OutPut%CenterW     )
            nullify  (Me%OutPut%Aux2D       )
        endif

        nullify  (Me%OutPut%DirectionH  )
        nullify  (Me%OutPut%CenterUglm     )
        nullify  (Me%OutPut%CenterVglm     )
        nullify  (Me%OutPut%ModulusHglm    )
        nullify  (Me%OutPut%CenterWglm     )
        nullify  (Me%OutPut%CenterUstokes  )
        nullify  (Me%OutPut%CenterVstokes  )
        nullify  (Me%OutPut%ModulusHstokes )
        nullify  (Me%OutPut%CenterWstokes  )
        nullify  (Me%OutPut%CenterUaux  )
        nullify  (Me%OutPut%CenterVaux  )
        nullify  (Me%OutPut%ModulusUVaux)
        nullify  (Me%OutPut%CenterWaux  )
        nullify  (Me%OutPut%Aux2D       )


        if (Me%ComputeOptions%WaterLevelMaxMin) then

            deallocate(Me%OutPut%WaterLevelMax,                                         &
                       Me%OutPut%WaterLevelMin,                                         &
                       Me%OutPut%WaterLevelDif,                                         &
                       STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'KillMatrixesOutput - ModuleHydrodynamic - ERR20'

            nullify  (Me%OutPut%WaterLevelMax       )
            nullify  (Me%OutPut%WaterLevelMin       )
            nullify  (Me%OutPut%WaterLevelDif       )

        endif

        if (Me%ComputeOptions%TideStateON     ) then
            deallocate (Me%WaterLevel%TideState)
            nullify    (Me%WaterLevel%TideState)
        endif

        deallocate (Me%OutPut%Wave3D_FPressureAccelU  )
        deallocate (Me%OutPut%Wave3D_FPressureAccelV  )
        deallocate (Me%OutPut%Wave3D_FBreakingAccelU)
        deallocate (Me%OutPut%Wave3D_FBreakingAccelV)
        deallocate (Me%OutPut%Wave3D_FVortexAccelU  )
        deallocate (Me%OutPut%Wave3D_FVortexAccelV  )

        nullify  (Me%OutPut%Wave3D_FPressureAccelU  )
        nullify  (Me%OutPut%Wave3D_FPressureAccelV  )
        nullify  (Me%OutPut%Wave3D_FBreakingAccelU)
        nullify  (Me%OutPut%Wave3D_FBreakingAccelV)
        nullify  (Me%OutPut%Wave3D_FVortexAccelU  )
        nullify  (Me%OutPut%Wave3D_FVortexAccelV  )

    end subroutine KillMatrixesOutput

    !--------------------------------------------------------------------------

    subroutine KillDDecomp

#ifdef _USE_MPI

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------


        if (associated(Me%DDecomp%Slaves_MPI_ID))    then
            deallocate(Me%DDecomp%Slaves_MPI_ID)
            nullify   (Me%DDecomp%Slaves_MPI_ID)
        endif

        if (associated(Me%DDecomp%Slaves_Size))      then
            deallocate(Me%DDecomp%Slaves_Size)
            nullify   (Me%DDecomp%Slaves_Size)
        endif

        if (associated(Me%DDecomp%Slaves_Inner))     then
            deallocate(Me%DDecomp%Slaves_Inner)
            nullify   (Me%DDecomp%Slaves_Inner)
        endif

        if (associated(Me%DDecomp%Slaves_Mapping))   then
            deallocate(Me%DDecomp%Slaves_Mapping)
            nullify   (Me%DDecomp%Slaves_Mapping)
        endif

        if (associated(Me%DDecomp%Slaves_HaloMap))   then
            deallocate(Me%DDecomp%Slaves_HaloMap)
            nullify   (Me%DDecomp%Slaves_HaloMap)
        endif

        if (associated(Me%DDecomp%VECG))             then
            deallocate(Me%DDecomp%VECG)
            nullify   (Me%DDecomp%VECG)
        endif

        if (associated(Me%DDecomp%VECW))             then
            deallocate(Me%DDecomp%VECW)
            nullify   (Me%DDecomp%VECW)
        endif

        if (associated(Me%DDecomp%WaterLevel_New))   then
            deallocate(Me%DDecomp%WaterLevel_New)
            nullify   (Me%DDecomp%WaterLevel_New)
        endif

        if (associated(Me%DDecomp%Coef))             then
            deallocate(Me%DDecomp%Coef)
            nullify   (Me%DDecomp%Coef)
        endif

        !----------------------------------------------------------------------


#endif _USE_MPI

    end subroutine KillDDecomp

    !End----------------------------------------------------------------

    subroutine DeallocateInstance ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Hydrodynamic), pointer           :: AuxHydrodynamic
        type (T_Hydrodynamic), pointer           :: PreviousHydrodynamic

        !Updates pointers
        if (Me%InstanceID == FirstHydrodynamic%InstanceID) then
            FirstHydrodynamic => FirstHydrodynamic%Next
        else
            PreviousHydrodynamic => FirstHydrodynamic
            AuxHydrodynamic      => FirstHydrodynamic%Next
            do while (AuxHydrodynamic%InstanceID /= Me%InstanceID)
                PreviousHydrodynamic => AuxHydrodynamic
                AuxHydrodynamic      => AuxHydrodynamic%Next
            enddo

            !Now update linked list
            PreviousHydrodynamic%Next => AuxHydrodynamic%Next

        endif

        !Deallocates instance
        deallocate (Me)
        nullify    (Me)


    end subroutine DeallocateInstance

#ifdef _USE_SEQASSIMILATION
    !--------------------------------------------------------------------------

    subroutine NullifyHydroStatePointer(HydrodynamicID, STAT)

        !Arguments-------------------------------------------------------------

        integer,               intent(IN ) :: HydrodynamicID
        integer, optional,     intent(OUT) :: STAT

        !External--------------------------------------------------------------

        integer :: ready_

        !Local-----------------------------------------------------------------

        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            nullify(Me%AuxPointer%WaterLevelNew)

            nullify(Me%AuxPointer%VelocityUNew)

            nullify(Me%AuxPointer%VelocityVNew)

            nullify(Me%AuxPointer%VelocityUOld)

            nullify(Me%AuxPointer%VelocityVOld)

            nullify(Me%AuxPointer%VelVerticalCartesian)

            nullify(Me%AuxPointer%VelVerticalAcross)

            nullify(Me%AuxPointer%WaterFluxX)

            nullify(Me%AuxPointer%WaterFluxY)

            nullify(Me%AuxPointer%WaterFluxZ)

            if (Me%SubModel%ON) then
                nullify(Me%AuxPointer%SubModelqX)

                nullify(Me%AuxPointer%SubModelqY)
            endif

            nullify(Me%AuxPointer%ChezyVelUV)

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine NullifyHydroStatePointer

#endif _USE_SEQASSIMILATION


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEME

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    subroutine Ready (HydrodynamicID, ready_)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (Me)

cd1:    if (HydrodynamicID > 0) then
            Me => FirstHydrodynamic
            do while (associated (Me))
                if (Me%InstanceID == HydrodynamicID) exit
                Me => Me%Next
            enddo

            if (.not. associated(Me))                                                    &
                stop 'ModuleHydrodynamic - Ready - ERR01'

            ready_ = VerifyReadLock (mHYDRODYNAMIC_, Me%InstanceID)
        else
            ready_ = OFF_ERR_
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Ready

    !--------------------------------------------------------------------------


    subroutine ReadyFather (HydrodynamicID, HydroFather, ready_)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        type (T_Hydrodynamic), pointer              :: HydroFather
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (HydroFather)

cd1:    if (HydrodynamicID > 0) then
            HydroFather => FirstHydrodynamic
            do while (associated (HydroFather))
                if (HydroFather%InstanceID == HydrodynamicID) exit
                HydroFather => HydroFather%Next
            enddo

            if (.not. associated(HydroFather))                                                    &
                stop 'ModuleHydrodynamic - Ready - ERR01'

            ready_ = VerifyReadLock (mHYDRODYNAMIC_, HydroFather%InstanceID)

        else
            ready_ = OFF_ERR_
        end if cd1


        !----------------------------------------------------------------------

    end subroutine ReadyFather




    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !         Manuel Ruiz Villarreal 2000: Vertical viscosities are located at faces of control volume  !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadLock_ModuleTurbulence


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL

        !Module - ModuleTurbulence
        !Turbulence Properties
        call GetHorizontalViscosity(Me%ObjTurbulence,                       &
                                    Me%External_Var%Visc_H_Center,          &
                                    Me%External_Var%Visc_H_Corner,          &
                                    STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleTurbulence - ModuleHydrodynamic. ERR01.'



!Manuel
        call GetVerticalViscosity(Me%ObjTurbulence,                         &
                                  VerticalViscosity =                              &
                                  Me%External_Var%Vertical_Viscosity,       &
                                  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleTurbulence - ModuleHydrodynamic. ERR02.'



    End Subroutine ReadLock_ModuleTurbulence

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    Subroutine ReadUnLock_ModuleTurbulence


        !Arguments-------------------------------------------------------------




        !Local-----------------------------------------------------------------

        integer        :: STAT_CALL

        !----------------------------------------------------------------------

        !Module - ModuleTurbulence
        !Turbulence Properties
        !Horizontal Turbulent Viscosity in the cell Center
        call UnGetTurbulence(Me%ObjTurbulence,                   &
                             Me%External_Var%Visc_H_Center, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleTurbulence - ModuleHydrodynamic. ERR01.'



        !Horizontal Turbulent Viscosity in the cell corner
        call UnGetTurbulence(Me%ObjTurbulence,                   &
                             Me%External_Var%Visc_H_Corner, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleTurbulence - ModuleHydrodynamic. ERR02.'



        !Vertical Turbulent Viscosity
        call UnGetTurbulence(Me%ObjTurbulence,                   &
                             Me%External_Var%Vertical_Viscosity, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleTurbulence - ModuleHydrodynamic. ERR03.'

        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleTurbulence

    !--------------------------------------------------------------------------

#ifndef _WAVES_
    Subroutine ReadLock_ModuleWaves

        !Local------------------------------------------------------------------
        integer                          :: STAT_CALL

        !Begin------------------------------------------------------------------

        if (Me%Generic4D%ON) then

            call SetGeneric4DValues(Me%ObjWaves, Me%Generic4D%CurrentValue, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleWaves - ModuleHydrodynamic - ERR10'

        endif

        if (Me%WaveStress%ON)then

            call GetWavesStress    (Me%ObjWaves,                                        &
                                    Me%External_Var%TauWavesU,                          &
                                    Me%External_Var%TauWavesV,                          &
                                    STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleWaves - ModuleHydrodynamic. ERR20.'
        endif

        if (Me%ComputeOptions%WaveShearStress)then

            call GetWaves (WavesID       = Me%ObjWaves,                                 &
                           Abw           = Me%External_Var%Abw,                         &
                           Ubw           = Me%External_Var%Ubw,                         &
                           STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleWaves - ModuleHydrodynamic. ERR30.'
        endif

! Modified by Matthias DELPEY - 29/06/2011 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Modified by Matthias DELPEY - 06/07/2011 - 27/07/2011 - 04/08/2011 - 05/09/2011 - 09/09/2011 - 10/10/2011

        if (Me%ComputeOptions%WaveForcing3D == GLM) then

            call GetWavesForcing3D (Me%ObjWaves,                                        &
                                    Me%External_Var%WaveInducedPressureJ,               &
                                    Me%External_Var%StokesDriftSpectrumX,               &
                                    Me%External_Var%StokesDriftSpectrumY,               &
                                    Me%External_Var%StokesFreqNum,                      &
                                    Me%External_Var%StokesWaveNumber,                   &
                                    Me%External_Var%AtmToWaveMomentumU,                 &
                                    Me%External_Var%AtmToWaveMomentumV,                 &
                                    Me%External_Var%WaveToOceanMomentumU,               &
                                    Me%External_Var%WaveToOceanMomentumV,               &
                                    STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleWaves; module ModuleHydrodynamic. ERR40.'


            call GetWaves (WavesID     = Me%ObjWaves,                                   &
                          WaveHeight   = Me%External_Var%WaveHeight,                    &
                          STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleWaves; module ModuleHydrodynamic. ERR50.'


        endif


        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then

           call GetWaves (WavesID      = Me%ObjWaves,                                   &
                          WaveLength   = Me%External_Var%WaveLength,                    &
                          STAT         = STAT_CALL)
           if (STAT_CALL /= SUCCESS_)                                                   &
                stop 'Subroutine ReadLock_ModuleWaves; module ModuleHydrodynamic. ERR60.'


           call GetWavesStress    (Me%ObjWaves,                                         &
                                    Me%External_Var%TauWavesU,                          &
                                    Me%External_Var%TauWavesV,                          &
                                    STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleWaves; module ModuleHydrodynamic. ERR70.'

        endif

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    End Subroutine ReadLock_ModuleWaves


    !--------------------------------------------------------------------------

    real function TimeSerieValue(ObjTimeSerie, Now, TimeSerieColumn)
        !Arguments--------------------------------------------------------------
        integer                                         :: ObjTimeSerie, TimeSerieColumn
        type (T_Time)                                   :: Now
        !Local------------------------------------------------------------------
        integer                                         :: STAT_CALL
        type (T_Time)                                   :: Time1, Time2
        real                                            :: Value1, Value2
        logical                                         :: TimeCycle

        !Begin------------------------------------------------------------------



        !Gets Value for current Time
        call GetTimeSerieValue (ObjTimeSerie, Now, TimeSerieColumn,                     &
                                Time1, Value1, Time2, Value2, TimeCycle,                &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'TimeSerieValue - ModuleHydrodynamic - ERR10'

        if (TimeCycle) then
            TimeSerieValue = Value1

        else

            !Interpolates Value for current instant
            call InterpolateValueInTime(Now, Time1, Value1, Time2, Value2, TimeSerieValue)

        endif

    end function TimeSerieValue

    !--------------------------------------------------------------------------

    Subroutine ReadUnLock_ModuleWaves

        !Local-----------------------------------------------------------------

        integer        :: STAT_CALL

        !----------------------------------------------------------------------

        if (Me%WaveStress%ON) then
            call UnGetWaves(Me%ObjWaves,                                                     &
                                 Me%External_Var%TauWavesU, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves - ModuleHydrodynamic. ERR01.'

            call UnGetWaves(Me%ObjWaves,                                                     &
                                 Me%External_Var%TauWavesV, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves - ModuleHydrodynamic. ERR02.'
        endif

        if (Me%ComputeOptions%WaveShearStress) then

            call UnGetWaves(Me%ObjWaves,                                                     &
                                 Me%External_Var%Abw, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves - ModuleHydrodynamic. ERR03.'

            call UnGetWaves(Me%ObjWaves,                                                     &
                                 Me%External_Var%Ubw, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves - ModuleHydrodynamic. ERR04.'

        endif

        if (Me%ComputeOptions%WaveForcing3D == ExpRadiationStress) then
            call UnGetWaves(Me%ObjWaves,                                                     &
                             Me%External_Var%TauWavesU, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR01a.'

            call UnGetWaves(Me%ObjWaves,                                                     &
                             Me%External_Var%TauWavesV, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR02b.'

            call UnGetWaves(Me%ObjWaves,                                                     &
                            Me%External_Var%WaveLength, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR02c.'
         endif


         if (Me%ComputeOptions%WaveForcing3D == GLM) then

            call UnGetWaves(Me%ObjWaves,                                                     &
                             Me%External_Var%WaveInducedPressureJ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR02d.'

            call UnGetWaves(Me%ObjWaves,                                                     &
                             Me%External_Var%WaveHeight, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR02e.'

            call UnGetWaves3D(Me%ObjWaves,                                                   &
                             Me%External_Var%StokesDriftSpectrumX,                           &
                             Me%External_Var%StokesDriftSpectrumY,                           &
                             Me%External_Var%StokesFreqNum,                                  &
                             Me%External_Var%StokesWaveNumber,                               &
                             Me%External_Var%AtmToWaveMomentumU,                             &
                             Me%External_Var%AtmToWaveMomentumV,                             &
                             Me%External_Var%WaveToOceanMomentumU,                           &
                             Me%External_Var%WaveToOceanMomentumV,                           &
                             STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR02c.'

         endif

!         call SetWavesSeaLevelVel2DSwan(WavesID     = Me%ObjWaves,                      &
!                                        SeaLevel    = Me%WaterLevel%New,                &
!                                        VelU        = Me%Velocity%BarotropicUc,         &
!                                        VelV        = Me%Velocity%BarotropicVc,         &
!                                        STAT        = STAT_CALL)

!        stop 'Subroutine ReadUnLock_ModuleWaves; module ModuleHydrodynamic. ERR200.'

    End Subroutine ReadUnLock_ModuleWaves

    !--------------------------------------------------------------------------

#endif

    !--------------------------------------------------------------------------

    Subroutine ReadLock_ModuleHorizontalGrid


        !Arguments-------------------------------------------------------------




        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL


        !Module - ModuleHorizontalGrid
        !Horizontal Grid properties

        call GetHorizontalGrid(Me%ObjHorizontalGrid,                                    &
                               DXX  = Me%External_Var%DXX,                              &
                               DYY  = Me%External_Var%DYY,                              &
                               DZX  = Me%External_Var%DZX,                              &
                               DZY  = Me%External_Var%DZY,                              &
                               DUX  = Me%External_Var%DUX,                              &
                               DVY  = Me%External_Var%DVY,                              &
                               STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR01.'



        call GetCoriolisFrequency(Me%ObjHorizontalGrid,                                 &
                                  Me%External_Var%Coriolis_Freq,                        &
                                  STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR02.'

        call GetCheckDistortion (Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%Distortion,                            &
                                 STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR03.'

        if (Me%External_Var%Distortion) then

            call GetGridRotation(Me%ObjHorizontalGrid,                                  &
                                 Me%External_Var%RotationX,                             &
                                 Me%External_Var%RotationY,                             &
                                 STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR04.'

        else

            call GetGridAngle(Me%ObjHorizontalGrid,                                     &
                              Me%External_Var%GridRotation,                             &
                              STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR40.'

            !Convert from degrees in to radians
            Me%External_Var%GridRotation = Me%External_Var%GridRotation * Pi / 180.


        endif


        call GetGridLatitudeLongitude(Me%ObjHorizontalGrid,                             &
                                      GridLatitude  = Me%External_Var%LatitudeZ,        &
                                      GridLongitude = Me%External_Var%LongitudeZ,       &
                                      STAT          = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR50.'

    End Subroutine ReadLock_ModuleHorizontalGrid

    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadUnLock_ModuleHorizontalGrid


        !Arguments-------------------------------------------------------------




        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL

        !Module - ModuleHorizontalGrid
        !Horizontal Grid properties

        !DXX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DXX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR01.'


        !DYY
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DYY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR02.'


        !DZX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DZX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR03.'


        !DZY
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DZY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR04.'


        !DUX
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DUX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR05.'


        !DVY
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%DVY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR06.'


        !Coriolis frequency
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%Coriolis_Freq, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR07.'

        if (Me%External_Var%Distortion) then

            call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                     Me%External_Var%RotationX, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                            &
                stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR08.'


            call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                     Me%External_Var%RotationY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                            &
                stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR09.'

        endif

        !Longitude Z
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%LongitudeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR100.'

        !Latitude Z
        call UnGetHorizontalGrid(Me%ObjHorizontalGrid,           &
                                 Me%External_Var%LatitudeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleHorizontalGrid - ModuleHydrodynamic. ERR110.'


        !---------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleHorizontalGrid

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    Subroutine ReadLock_ModuleHorizontalMap


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL

        !Module - ModuleHorizontalMap
        !Horizontal Mapping Properties
        call GetBoundaryFaces(Me%ObjHorizontalMap,                                      &
                              Me%External_Var%BoundaryFacesU,                           &
                              Me%External_Var%BoundaryFacesV,                           &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR10.'


        call GetBoundaries(Me%ObjHorizontalMap,                                         &
                           Me%External_Var%BoundaryPoints,                              &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR20.'

        !Gets WaterPoints2D
        call GetWaterPoints2D(Me%ObjHorizontalMap, &
                              Me%External_Var%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR30.'

        !Gets LandPoints2D
        call GetLandPoints2D(Me%ObjHorizontalMap, &
                              Me%External_Var%LandPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR40.'


    End Subroutine ReadLock_ModuleHorizontalMap

    !End----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadUnLock_ModuleHorizontalMap


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        integer        :: STAT_CALL


        !Module - ModuleHorizontalMap
        !Horizontal Mapping Properties

        !Boundary faces along the X direction
        call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%BoundaryFacesU,    &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR10.'


        !Boundary faces along the Y direction
        call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%BoundaryFacesV,    &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR20.'

       !Boundary points
        call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%BoundaryPoints,    &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR30.'

        !UnGets WaterPoints2D
        call UnGetHorizontalMap(Me%ObjHorizontalMap,                                    &
                                Me%External_Var%WaterPoints2D, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR40.'

        !UnGets LandPoints2D
        call UnGetHorizontalMap(Me%ObjHorizontalMap,                                    &
                                Me%External_Var%LandPoints2D, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Subroutine ReadUnLock_ModuleHorizontalMap - ModuleHydrodynamic. ERR50.'


    End Subroutine ReadUnLock_ModuleHorizontalMap

    !End----------------------------------------------------------------------



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadLock_ModuleGeometry


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL

        !Module - ModuleGeometry
        !3D Geometry properties

        call GetGeometryKFloor(Me%ObjGeometry,               &
                               Z = Me%External_Var%KFloor_Z, &
                               U = Me%External_Var%KFloor_U, &
                               V = Me%External_Var%KFloor_V, &
                               STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry - ModuleHydrodynamic. ERR**.'



        call GetGeometryVolumes(Me%ObjGeometry,                            &
                                VolumeZ = Me%External_Var%Volume_Z_New,    &
                                VolumeU = Me%External_Var%Volume_U,        &
                                VolumeV = Me%External_Var%Volume_V,        &
                                VolumeW = Me%External_Var%Volume_W,        &
                                VolumeZOld = Me%External_Var%Volume_Z_Old, &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry - ModuleHydrodynamic. ERR**.'



        call GetGeometryAreas(Me%ObjGeometry,                 &
                              AreaU = Me%External_Var%Area_U, &
                              AreaV = Me%External_Var%Area_V, &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry - ModuleHydrodynamic. ERR**.'



        call GetGeometryDistances(Me%ObjGeometry,             &
                                  DWZ = Me%External_Var%DWZ,  &
                                  SZZ = Me%External_Var%SZZ,  &
                                  DUZ = Me%External_Var%DUZ,  &
                                  DVZ = Me%External_Var%DVZ,  &
                                  DZZ = Me%External_Var%DZZ,  &
                                  STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry - ModuleHydrodynamic. ERR**.'



        call GetGeometryWaterColumn(Me%ObjGeometry,                             &
                                    WaterColumn = Me%External_Var%WaterColumn,  &
                                    WaterColumnU= Me%External_Var%WaterColumnU, &
                                    WaterColumnV= Me%External_Var%WaterColumnV, &
                                    STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleGeometry - ModuleHydrodynamic. ERR**.'



    End Subroutine ReadLock_ModuleGeometry

    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Subroutine ReadUnLock_ModuleGeometry


        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL

        !Module - ModuleGeometry
        !3D Geometry properties


        !First non land layer of the Z cell (water level compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR01.'


        !First non land layer of the U cell (velocity U compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%KFloor_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR02.'


        !First non land layer of the V cell (velocity V compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%KFloor_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR03.'



        !New volume of the Z cell (water level compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_Z_New, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR04.'



        !Old volume of the Z cell (water level compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_Z_Old, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR05.'


        !New volume of the U cell (Velocity U compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR06.'


        !New volume of the V cell (Velocity V compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR07.'

        !New volume of the V cell (Velocity W compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Volume_W, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR07a.'

        !New Area of the U cell (Velocity U compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Area_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR08.'


        !New Area of the V cell (Velocity V compute point)
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%Area_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR09.'


        !Tickness of the Z cell
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR10.'

        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR10a.'


        !Top face position
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR11.'


        !Tickness of the total water column in the Z cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%WaterColumn, STAT = STAT_CALL)
       if (STAT_CALL /= SUCCESS_)                                             &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR12.'

        !Tickness of the total water column in the U cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%WaterColumnU, STAT = STAT_CALL)
       if (STAT_CALL /= SUCCESS_)                                             &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR13.'


        !Tickness of the total water column in the V cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%WaterColumnV, STAT = STAT_CALL)
       if (STAT_CALL /= SUCCESS_)                                             &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR14.'

        !Tickness of the U cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DUZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR15.'


        !Tickness of the V cell center
        call UnGetGeometry(Me%ObjGeometry,                       &
                           Me%External_Var%DVZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleGeometry - ModuleHydrodynamic. ERR16.'


    End Subroutine ReadUnLock_ModuleGeometry

    !End----------------------------------------------------------------------


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input : Geometry, Mapping                                                            !
    ! OutPut: Flow                                                                         !
    ! Author: Paulo Chambel (99/6)                                                         !
    !                                                                                      !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Subroutine ReadLock_ModuleMap


        !Arguments-------------------------------------------------------------------



        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL



        !Module - ModuleMap
        !3D Mapping Properties

        call GetComputeFaces3D(Me%ObjMap,                        &
                               ComputeFacesU3D =                              &
                               Me%External_Var%ComputeFaces3D_U, &
                               ComputeFacesV3D =                              &
                               Me%External_Var%ComputeFaces3D_V, &
                               ComputeFacesW3D =                              &
                               Me%External_Var%ComputeFaces3D_W, &
                               STAT= STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadLock_ModuleMap - ModuleHydrodynamic. ERR**.'


!        call GetUnCoveredFaces3D(Me%ObjMap,                        &
!                               UnCoveredFacesU3D =                              &
!                               Me%External_Var%UnCoveredFaces3D_U, &
!                               UnCoveredFacesV3D =                              &
!                               Me%External_Var%UnCoveredFaces3D_V, &
!                               STAT= STAT_CALL)

!        if (STAT_CALL /= SUCCESS_)                                          &
!            stop 'Subroutine ReadLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        call GetLandBoundaryFaces3D(Me%ObjMap,                     &
                               LandBoundaryFaces3DU =                           &
                               Me%External_Var%LandBoundaryFacesU, &
                               LandBoundaryFaces3DV =                           &
                               Me%External_Var%LandBoundaryFacesV, &
                               STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                          &
            stop 'Subroutine ReadLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        call GetWaterPoints3D(Me%ObjMap,                     &
                              Me%External_Var%WaterPoints3D, &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. ReadLock_ModuleMap - ModuleHydrodynamic - ERR**.'

        call GetOpenPoints3D(Me%ObjMap,                      &
                             Me%External_Var%OpenPoints3D,   &
                             STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) &
            Stop 'Sub. ReadLock_ModuleMap - ModuleHydrodynamic - ERR**.'


        call GetImposedTangentialFaces(Me%ObjMap,                           &
                              Me%External_Var%ImposedTangentialFacesU,      &
                              Me%External_Var%ImposedTangentialFacesV,      &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        call GetImposedNormalFaces(Me%ObjMap,                               &
                              Me%External_Var%ImposedNormalFacesU,          &
                              Me%External_Var%ImposedNormalFacesV,          &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Subroutine ReadLock_ModuleMap - ModuleHydrodynamic. ERR**.'




    End Subroutine ReadLock_ModuleMap

    !End----------------------------------------------------------------------

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                                                                                      !
    !                                                                                      !
    ! Input :                                                                              !
    ! OutPut:                                                                              !
    ! Author: Paulo Chambel (99/6)                                                         !

    Subroutine ReadUnLock_ModuleMap


        !Arguments-------------------------------------------------------------



        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL



        !Module - ModuleMap
        !3D Mapping Properties

        !3D Boundary land faces along the X direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%LandBoundaryFacesU, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR01.'


        !3D Boundary land faces along the Y direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%LandBoundaryFacesV, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR02.'


        !3D water points
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR03.'


        !3D Compute faces along the X direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%ComputeFaces3D_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR04.'


        !3D Compute faces along the Y direction
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%ComputeFaces3D_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR05.'

        !3D Compute faces along the Z direction  !flavio
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%ComputeFaces3D_W, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR05a.'

        !3D UnCovered faces along the X direction
!        call UnGetMap(Me%ObjMap,                                 &
!                      Me%External_Var%UnCoveredFaces3D_U, STAT = STAT_CALL)
!        if (STAT_CALL /= SUCCESS_)                                            &
!            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR06.'


        !3D UnCovered faces along the Y direction
!        call UnGetMap(Me%ObjMap,                                 &
!                      Me%External_Var%UnCoveredFaces3D_V, STAT = STAT_CALL)
!        if (STAT_CALL /= SUCCESS_)                                            &
!            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR07.'

        !3D OpenPoints
        call UnGetMap(Me%ObjMap,                                 &
                      Me%External_Var%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                            &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR07.'



        !Imposed Tangential faces along the X direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedTangentialFacesU,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        !Imposed Tangential  faces along the Y direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedTangentialFacesV,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        !Imposed Normal faces along the X direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedNormalFacesU,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        !Imposed Normal  faces along the Y direction
        call UnGetMap(Me%ObjMap, Me%External_Var%ImposedNormalFacesV,  &
                                STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                           &
            stop 'Subroutine ReadUnLock_ModuleMap - ModuleHydrodynamic. ERR**.'


        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleMap

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ReadLock_ModuleAssimilation


        !Local----------------------------------------------------------------------
        integer                          :: STAT_CALL

cd1:    if(Me%ComputeOptions%AltimetryAssimilation%Yes) then

            !Fetch the analyzed sigma density field
            call GetAltimSigmaDensAnalyzed( Me%ObjAssimilation,                         &
                                            Me%External_Var%AltimSigmaDensAnalyzed,     &
                                            STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR01'

            !Fetch the analyzed Water Level field
            call GetAssimilationField(Me%ObjAssimilation,                               &
                                     ID      = AltimLevelAnalyzed_,                     &
                                     Field2D = Me%External_Var%AltimWaterLevelAnalyzed, &
                                     STAT    = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR02'

            !Fetch the DecayTime
            call GetAltimetryDecayTime(Me%ObjAssimilation,                              &
                                       Me%External_Var%AltimDecayTime,                  &
                                       STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR03'

            !Here we fetch the altimetry DT and initialize the nextcompute time
            call GetAssimilationAltimetryDT(Me%ObjAssimilation,                         &
                                    Me%ComputeOptions%AltimetryAssimilation%DT_Compute, &
                                    STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLock_ModuleAssimilation - ModuleHydrodynamic - ERR04'

        endif cd1

    End Subroutine ReadLock_ModuleAssimilation

    !End----------------------------------------------------------------------


    Subroutine ReadUnLock_ModuleAssimilation


        !Local-----------------------------------------------------------------
        integer        :: STAT_CALL

cd1:    if(Me%ComputeOptions%AltimetryAssimilation%Yes) then


            !Unfetch the analyzed Water Level field
            call UnGetAssimilation( Me%ObjAssimilation,                                 &
                                    Me%External_Var%AltimWaterLevelAnalyzed,            &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadUnLock_ModuleAssimilation - ModuleHydrodynamic - ERR01'

            !Unfetch the analyzed Sigma Density field
            call UnGetAssimilation( Me%ObjAssimilation,                                 &
                                    Me%External_Var%AltimSigmaDensAnalyzed,             &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadUnLock_ModuleAssimilation - ModuleHydrodynamic - ERR02'


        endif cd1

        !---------------------------------------------------------------------

    End Subroutine ReadUnLock_ModuleAssimilation

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ReadLock_External_Modules

        !Arguments-------------------------------------------------------------



        !----------------------------------------------------------------------

            call ReadLock_ModuleHorizontalGrid

            call ReadLock_ModuleHorizontalMap

            call ReadLock_ModuleGeometry

            call ReadLock_ModuleMap

            call ReadLock_ModuleAssimilation

        !----------------------------------------------------------------------

    End Subroutine ReadLock_External_Modules

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    Subroutine ReadUnLock_External_Modules

        !Arguments-------------------------------------------------------------



        !----------------------------------------------------------------------

            call ReadUnLock_ModuleHorizontalGrid

            call ReadUnLock_ModuleHorizontalMap

            call ReadUnLock_ModuleGeometry

            call ReadUnLock_ModuleMap

            call ReadUnLock_ModuleAssimilation


        !----------------------------------------------------------------------

    End Subroutine ReadUnLock_External_Modules

    !--------------------------------------------------------------------------
#ifdef _USE_MPI

    subroutine SendHydrodynamicMPI (HydrodynamicID, Destination, Window, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: Destination
        type (T_Size2D)                             :: Window
        logical                                     :: InitialField
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        real                                        :: DT
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        real, dimension(6)                          :: AuxTime
        real,    dimension(:,:,:), pointer          :: DUZFather, DVZFather
        integer, dimension(:,:,:), pointer          :: Open3DFather
        integer, dimension(:,:,:), pointer          :: WetFaces_UFather
        integer, dimension(:,:,:), pointer          :: WetFaces_VFather
        integer, dimension(:,:,:), pointer          :: Faces3D_UFather
        integer, dimension(:,:,:), pointer          :: Faces3D_VFather
        integer                                     :: iSize
        integer, save                               :: Precision

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            !Window to send
            ILB = Window%ILB
            IUB = Window%IUB
            JLB = Window%JLB
            JUB = Window%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            if (InitialField) then

                !Gets Compute time step
                call GetComputeTimeStep(Me%ObjTime, DT, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR01'

                !Sends Continous Compute
                call MPI_Send (Me%ComputeOptions%Continuous, 1, MPI_LOGICAL, Destination, &
                               1000, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR02'


                !Sends KLB
                call MPI_Send (Me%WorkSize%KLB, 1, MPI_INTEGER, Destination, 1001,       &
                               MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR03'


                !Sends KUB
                call MPI_Send (Me%WorkSize%KUB, 1, MPI_INTEGER, Destination, 1002,       &
                               MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR04'


                Precision = MPIKind(DT)

                !Sends DT
                call MPI_Send (DT, 1, Precision, Destination, 1003, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR05'


            endif

            !Sends last iteration
            call ExtractDate (Me%LastIteration, AuxTime(1), AuxTime(2), AuxTime(3),      &
                              AuxTime(4), AuxTime(5), AuxTime(6))

            !Assuming that all other variables have the same kind
            Precision = MPIKind(Me%Velocity%Horizontal%U%New)

            call MPI_Send (AuxTime, 6, Precision, Destination, 1004, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR06'


            !Gets OpenPoints
            call GetOpenPoints3D      (Me%ObjMap, Open3DFather, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR07'

            !Gets ComputeFaces
            call GetComputeFaces3D    (Me%ObjMap, ComputeFacesU3D = Faces3D_UFather,     &
                                       ComputeFacesV3D = Faces3D_VFather,                &
                                       STAT= STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR08'

            !Gets WetFaces
            call GetWetFaces          (Me%ObjMap, WetFaceU = WetFaces_UFather,           &
                                       WetFaceV = WetFaces_VFather,                      &
                                       STAT= STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR09'

            !Gets DUZ, DVZ
            call GetGeometryDistances (Me%ObjGeometry, DUZ =  DUZFather,                 &
                                       DVZ =  DVZFather, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR10'

            !UFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)

            call MPI_Send (Me%Velocity%Horizontal%U%New(ILB:IUB, JLB:JUB+1, KLB:KUB),    &
                           iSize, Precision, Destination, 1005, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR11'


            !VFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Me%Velocity%Horizontal%V%New(ILB:IUB+1, JLB:JUB, KLB:KUB),    &
                           iSize, Precision, Destination, 1006, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR12'


            !FluxXFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Me%WaterFluxes%X(ILB:IUB, JLB:JUB+1, KLB:KUB),                &
                           iSize, MPI_DOUBLE_PRECISION, Destination, 1007, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR13'

            !FluxYFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Me%WaterFluxes%Y(ILB:IUB+1, JLB:JUB, KLB:KUB),                &
                           iSize, MPI_DOUBLE_PRECISION, Destination, 1008, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR14'


            !ZFather
            iSize = (IUB-ILB+1) * (JUB-JLB+1)
            call MPI_Send (Me%WaterLevel%New(ILB:IUB, JLB:JUB),                          &
                           iSize, Precision, Destination, 1009, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR15'



            !Open3DFather
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Open3DFather(ILB:IUB, JLB:JUB, KLB:KUB),                      &
                           iSize, MPI_INTEGER, Destination, 1010, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR16'


            !Faces3D_UFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Faces3D_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB),                 &
                           iSize, MPI_INTEGER, Destination, 1011, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR17'


            !Faces3D_VFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Faces3D_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB),                 &
                           iSize, MPI_INTEGER, Destination, 1012, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR18'


            !WetFaces_UFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (WetFaces_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB),                &
                           iSize, MPI_INTEGER, Destination, 1013, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR19'


            !WetFaces_VFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (WetFaces_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB),                &
                           iSize, MPI_INTEGER, Destination, 1014, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR20'


            !DUZFather
            iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
            call MPI_Send (DUZFather(ILB:IUB, JLB:JUB+1, KLB:KUB),                       &
                           iSize, Precision , Destination, 1015, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR21'



            !DVZFather
            iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (DVZFather(ILB:IUB+1, JLB:JUB, KLB:KUB),                       &
                           iSize, Precision, Destination, 1016, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SendHydrodynamicMPI - MohidWater - ERR22'



            !Ungets information
            call UnGetMap       (Me%ObjMap,      Open3DFather,    STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      Faces3D_UFather, STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      Faces3D_VFather, STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      WetFaces_UFather, STAT = STAT_CALL)
            call UnGetMap       (Me%ObjMap,      WetFaces_VFather, STAT = STAT_CALL)

            !Ungets information
            call UnGetGeometry  (Me%ObjGeometry, DUZFather,  STAT = STAT_CALL)
            call UnGetGeometry  (Me%ObjGeometry, DVZFather,  STAT = STAT_CALL)


            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine SendHydrodynamicMPI

    !--------------------------------------------------------------------------

    subroutine RecvHydrodynamicMPI (HydrodynamicID, Source, Window, InitialField,        &
                                    FatherGridID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: Source
        type (T_Size2D)                             :: Window
        logical                                     :: InitialField
        integer                                     :: FatherGridID
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        logical                                     :: FatherContinous
        real                                        :: DT, DT_Son
        integer, save                               :: KLB, KUB
        integer                                     :: ILB, IUB, JLB, JUB
        type (T_Size2D), save                       :: WorkSize, Size
        integer                                     :: status(MPI_STATUS_SIZE)
        real, dimension(6)                          :: AuxTime
        type (T_Time)                               :: LastIteration
        real,    dimension(:,:,:), pointer, save    :: UFather, VFather, DUZFather, DVZFather
        real(8), dimension(:,:,:), pointer, save    :: FluxXFather, FluxYFather
        real,    dimension(:,:  ), pointer, save    :: ZFather
        integer, dimension(:,:,:), pointer, save    :: Open3DFather
        integer, dimension(:,:,:), pointer, save    :: WetFaces_UFather
        integer, dimension(:,:,:), pointer, save    :: WetFaces_VFather
        integer, dimension(:,:,:), pointer, save    :: Faces3D_UFather
        integer, dimension(:,:,:), pointer, save    :: Faces3D_VFather


        integer                                     :: iSize
        integer, save                               :: Precision

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            call GetHorizontalGridSize (FatherGridID, Size = Size,                       &
                                        WorkSize = WorkSize, STAT = STAT_CALL)


            !Window Size
            ILB = Window%ILB
            IUB = Window%IUB
            JLB = Window%JLB
            JUB = Window%JUB

            if (InitialField) then

                !Recieves Continous Compute
                call MPI_Recv (FatherContinous, 1, MPI_LOGICAL, Source, 1000, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR01'

                !Recieves KLB
                call MPI_Recv (KLB, 1, MPI_INTEGER, Source, 1001,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR02'

                !Recieves KUB
                call MPI_Recv (KUB, 1, MPI_INTEGER, Source, 1002,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR03'


                Precision = MPIKind(DT)

                !Recieves DT
                call MPI_Recv (DT, 1, Precision, Source, 1003,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR04'


                call TestSubModelOptionsConsistence (FatherContinous)

                !Ang: new implementation
                Me%SubModel%FatherKLB = KLB
                Me%SubModel%FatherKUB = KUB

                call ConstructTimeInterpolation     (DT)

                !Allocates receiving buffer
                allocate (UFather        (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (VFather        (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (DUZFather      (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (DVZFather      (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (FluxXFather    (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (FluxYFather    (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (ZFather        (Size%ILB:Size%IUB, Size%JLB:Size%JUB             ))
                allocate (Open3DFather   (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (WetFaces_UFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (WetFaces_VFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (Faces3D_UFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (Faces3D_VFather(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))


                UFather             = 0.0
                VFather             = 0.0
                DUZFather           = null_real
                DVZFather           = null_real
                FluxXFather         = 0.0
                FluxYFather         = 0.0
                ZFather             = null_real
                Open3DFather        = 0
                WetFaces_UFather    = 0
                WetFaces_VFather    = 0
                Faces3D_UFather     = 0
                Faces3D_VFather     = 0

            endif

            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_New)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_New)

            !Receives LastIteration
            call MPI_Recv (AuxTime, 6, Precision, Source, 1004, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR05'


            call SetDate  (LastIteration, AuxTime(1), AuxTime(2), AuxTime(3), AuxTime(4), AuxTime(5), AuxTime(6))

            if (LastIteration > Me%SubModel%NextTime .or. InitialField) then

                !UFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (UFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, Precision,   &
                               Source, 1005, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR06'


                !VFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (VFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, Precision,   &
                               Source, 1006, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR07'


                !FluxXFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (FluxXFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, MPI_DOUBLE_PRECISION,&
                               Source, 1007, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR08'


                !FluxYFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (FluxYFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, MPI_DOUBLE_PRECISION,&
                               Source, 1008, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR09'


                !ZFather
                iSize = (IUB-ILB+1) * (JUB-JLB+1)
                call MPI_Recv (ZFather(ILB:IUB, JLB:JUB), iSize, Precision,              &
                               Source, 1009, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR10'


                !Open3DFather
                iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (Open3DFather(ILB:IUB, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER, &
                               Source, 1010, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR11'


                !Faces3D_UFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (Faces3D_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1011, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR12'


                !Faces3D_VFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (Faces3D_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1012, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR13'


                !WetFaces_UFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (WetFaces_UFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1013, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR14'


                !WetFaces_VFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (WetFaces_VFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER,&
                               Source, 1014, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR15'


                !DUZFather
                iSize = (IUB-ILB+1) * (JUB+1-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (DUZFather(ILB:IUB, JLB:JUB+1, KLB:KUB), iSize, Precision, &
                               Source, 1015, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR16'


                !DVZFather
                iSize = (IUB+1-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
                call MPI_Recv (DVZFather(ILB:IUB+1, JLB:JUB, KLB:KUB), iSize, Precision, &
                               Source, 1016, MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RecvHydrodynamicMPI - MohidWater - ERR17'




                call ReadNextOrInitialField (UFather, VFather, DUZFather, DVZFather,     &
                                       FluxXFather, FluxYFather, ZFather, Open3DFather,  &
                                       Faces3D_UFather, Faces3D_VFather,                 &
                                       WetFaces_UFather, WetFaces_VFather, InitialField, &
                                       FatherGridID)


                if (.not. InitialField) then

                    if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.               &
                        (Me%SubModel%VertComunic == Father3DSon2D)) then

                        !Ang: new father-son implementation
                        call GetComputeTimeStep(Me%ObjTime, DT_Son, STAT = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_)                                      &
                            call SetError(FATAL_, INTERNAL_, "RecvHydrodynamicMPI; Hydrodynamic. ERR18")

                        !Get time for interpolation from aux variables
                        Me%SubModel%GetFatherTime = Me%SubModel%NextTime + DT_Son

                    endif

                    Me%SubModel%PreviousTime = Me%SubModel%NextTime
                    Me%SubModel%NextTime     = LastIteration
                endif

            endif

            if      (Me%SubModel%VertComunic == FatherSonEqualDim) then

                call ActualizeSubModelValues    (InitialField)

            else if (Me%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DWithFather2D (InitialField)

            else if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.                   &
                      (Me%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DWithFather3D (InitialField)

            endif

!            if (Me%SubModel%DeadZone .and. InitialField  .and. .not. Me%ComputeOptions%Continuous)  then
            if (InitialField  .and. .not. Me%ComputeOptions%Continuous .and. Me%SubModel%FatherHotStart)  then
                call Initial_Geometry(Me%WaterLevel%New)
            endif

            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine RecvHydrodynamicMPI

    !--------------------------------------------------------------------------

    subroutine UpdateHydroMPI (HydrodynamicID, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        logical                                     :: InitialField
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(HydrodynamicID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            call SetMatrixValue(Me%SubModel%DUZ_Old, Me%Size, Me%SubModel%DUZ_New)
            call SetMatrixValue(Me%SubModel%DVZ_Old, Me%Size, Me%SubModel%DVZ_New)

            if      (Me%SubModel%VertComunic == FatherSonEqualDim) then

                call ActualizeSubModelValues    (InitialField)

            else if (Me%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DWithFather2D (InitialField)

            else if ((Me%SubModel%VertComunic == FatherSonDifDim) .or.           &
                      (Me%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DWithFather3D (InitialField)

            endif

            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_


    end subroutine UpdateHydroMPI


#endif _USE_MPI

#ifdef _OPENMI_

        !--------------------------------------------------------------------------

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetWaterLevelAtPoint
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETWATERLEVELATPOINT"::GetWaterLevelAtPoint
    !DEC$ ENDIF
    real(8) function GetWaterLevelAtPoint(HydrodynamicID, i, j)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: i, j

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_

        call Ready(HydrodynamicID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then
            GetWaterLevelAtPoint = Me%WaterLevel%New(i, j)
        else
            GetWaterLevelAtPoint = - 99.0
        end if

        return

    end function GetWaterLevelAtPoint

    !------------------------------------------------------------------------------------

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetWaterLevel1D
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETWATERLEVEL1D"::GetWaterLevel1D
    !DEC$ ENDIF
    logical function GetWaterLevel1D(HydrodynamicID, nComputePoints, waterlevels1D)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: nComputePoints
        real(8), dimension(nComputePoints)          :: waterlevels1D

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_
        integer                                     :: i, j, idx

        call Ready(HydrodynamicID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D,    &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetWaterLevel1D - ModuleHydrodynamic - ERR01'

            idx = 1
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    waterlevels1D(idx) = Me%WaterLevel%New(i, j)
                    idx = idx + 1
                endif
            enddo
            enddo

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetWaterLevel1D - ModuleHydrodynamic - ERR02'


            GetWaterLevel1D = .true.
        else
            GetWaterLevel1D = .false.
        end if

        return


    end function GetWaterLevel1D

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetSurfaceVelocityU
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETSURFACEVELOCITYU"::GetSurfaceVelocityU
    !DEC$ ENDIF
    logical function GetSurfaceVelocityU(HydrodynamicID, nComputePoints, velocityU)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: nComputePoints
        real(8), dimension(nComputePoints)          :: velocityU

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_
        integer                                     :: i, j, idx

        call Ready(HydrodynamicID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D,    &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetSurfaceVelocityU - ModuleHydrodynamic - ERR01'

            idx = 1
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    velocityU(idx) = Me%Velocity%Horizontal%U%New(i, j, Me%WorkSize%KUB)
                    idx = idx + 1
                endif
            enddo
            enddo

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetSurfaceVelocityU - ModuleHydrodynamic - ERR02'


            GetSurfaceVelocityU = .true.
        else
            GetSurfaceVelocityU = .false.
        end if

        return


    end function GetSurfaceVelocityU

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetSurfaceVelocityV
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETSURFACEVELOCITYV"::GetSurfaceVelocityV
    !DEC$ ENDIF
    logical function GetSurfaceVelocityV(HydrodynamicID, nComputePoints, velocityV)

        !Arguments-------------------------------------------------------------
        integer                                     :: HydrodynamicID
        integer                                     :: nComputePoints
        real(8), dimension(nComputePoints)          :: velocityV

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_
        integer                                     :: i, j, idx

        call Ready(HydrodynamicID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D,    &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetSurfaceVelocityV - ModuleHydrodynamic - ERR01'

            idx = 1
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%External_Var%WaterPoints2D(i, j) == WaterPoint) then
                    velocityV(idx) = Me%Velocity%Horizontal%V%New(i, j, Me%WorkSize%KUB)
                    idx = idx + 1
                endif
            enddo
            enddo

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%External_Var%WaterPoints2D, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetSurfaceVelocityV - ModuleHydrodynamic - ERR02'


            GetSurfaceVelocityV = .true.
        else
            GetSurfaceVelocityV = .false.
        end if

        return


    end function GetSurfaceVelocityV

#endif

End Module ModuleHydrodynamic

!----------------------------------------------------------------------------------------------------------
!MOHID Water Modelling System.
!Copyright (C) 1985, 1998, 2002, 2005. Instituto Superior Tcnico, Technical University of Lisbon.
!----------------------------------------------------------------------------------------------------------
