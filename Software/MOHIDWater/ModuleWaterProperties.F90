!------------------------------------------------------------------------------
!        IST/MARETEC, Water Modelling Group, Mohid modelling system
!------------------------------------------------------------------------------
!
! TITLE         : Mohid Model
! PROJECT       : Mohid Water
! MODULE        : WaterProperties
! URL           : http://www.mohid.com
! AFFILIATION   : IST/MARETEC, Marine Modelling Group
! DATE          : June 2003
! REVISION      : Luis Fernandes - v4.0
! DESCRIPTION   : Module to compute water properties processes
!------------------------------------------------------------------------------
!
!This program is free software; you can redistribute it and/or
!modify it under the terms of the GNU General Public License
!version 2, as published by the Free Software Foundation.
!
!This program is distributed in the hope that it will be useful,
!but WITHOUT ANY WARRANTY; without even the implied warranty of
!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!GNU General Public License for more details.
!
!You should have received a copy of the GNU General Public License
!along with this program; if not, write to the Free Software
!Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
!
!------------------------------------------------------------------------------
!
!DataFile
!   REFERENCE_DENSITY           : real           [1000 kg/m3]   !Reference Water Density
!   DENSITY_METHOD              : int               2           !Water density compute method
!                                                               !1-Leendertse; ; 3-Linear
!   PRESSURE_CORRECTION         : 0/1               0           !Check if density is computed with (1) or
!   DENSITY_COHESIVE_SED        : real           [2600 kg/m3]   !Cohesive sediments density
!
!   REFERENCE_SPECIFICHEAT      : real           [4200 J/kg/ยบC] !Reference Water Specific Heat
!   SPECIFICHEAT_METHOD         : int               3           !Specific Heat computation default method
!
!   SMALLDEPTH_LIMIT            : real            null_real     !Water column thickness below which homogeneous
!   FREE_CONVECTION             : 0/1               0           !This option tend to mixe instable density profiles
!                                                               !water properties is assumed.
!   OUTPUT_TIME                 : sec. sec. sec.    -           !Output Time
!   RESTART_FILE_OUTPUT_TIME    : sec. sec. sec.    -           !Output Time to write restart files
!   RESTART_FILE_OVERWRITE      : 0/1              [1]          !Overwrite intermediate restart files
!   TIME_SERIE_LOCATION         : char              -           !Path to time serie location file

!   SIMPLE_OUTPUT               : logical           1           !By default the output is only for the properties
                                                                !However, if the user considers the 0 option several secondries properties will be output
!   SIMPLE_WINDOW_OUTPUT        : logical           1           !The same of SIMPLE_OUTPUT but for the windows output option

!   BOXFLUXES                   : char              -           !If specified computes box integration
!                                                               !based on boxes file defined by this keyword
!   ALTIMETRIC_ASSIMILATION     : 0/1               -           !Cooper-Haines altimetry assimilation method
!   AGE_USING_WATERPOINTS       : 0/1               0           !Compute age using Waterpoints. Default uses OpenPoints
!   MACROALGAE_MASS             : real         [0.001 gC/m2]    !Initial distribution of macroalgae
!   MACROALGAE_HEIGHT           : real            [0.25 m]      !Macroalgae height
!   VARIABLE_MACR_HEIGHT        : 0/1               0           ! switch to compute (1) not compute(0) variable
!                                                                 macroalgae height
!   MACR_HEIGHT_BIOMASS_RATIO   : real            [0.002]       ! ratio Height/biomass (m/gC/m2)
!                                                               ! this ratio is calculated knowing that biomass of
!                                                                500gdw/m2 average height =0.25 (Astill & Lavery, 2001)
!                                                                gC= 0.3*gdw (Duarte, 1990)-->
!                                                                0.25m/[500gdw/m2*0.3gC/gdw] = 0.002 m/gC/m2
!   NO_FLUX_INTERIOR_CONDITION  :                   [0]         ! Check if the domain interior to assume no flux condition along
                                                                ! specific faces.
!   RELAXATION_TIME_SCALE_NO_FLUX_LIMIT :         1000 * DT     ! Below this time scela - no flux along a cell face, each face
                                                                ! relax timescale defined in Assimilation Module for flow properties
                                                                ! VelocityU_ (zonal velocity), VelocityV_ (meridional velocity),
                                                                ! VelocityW_ (vertical velocity)
!
!
!   <begin_shading>
!   See module FillMatrix       : -                [m]          !Imposed shading factor
!                                                               !
!   <end_shading>

!<beginproperty>
!   NAME                        : char              -           !Property name
!   UNITS                       : char              -           !Property units
!   DESCRIPTION                 : char              -           !Small description of the property
!   See module FillMatrix       : -                 -           !Initialization of concentration values
!   PARTICULATE                 : 0/1               [0]         !Property physical state: 0 - Dissolved ; 1 - Particulate
!   OLD                         : 0/1               [0]         !Initialization from previous run (overrides FillMatrix)
!   MIN_VALUE                   : real              -           !Minimum allowed value of property concentration
!   MAX_VALUE                   : real              -           !Maximum allowed value of property concentration
!   IS_COEF                     : real              1e-3        !Conversion factor to I.S. units (1e-3 = mg/l)
!   DEFAULTBOUNDARY             : real              [0]         !Value assumed in open boundaries by default
!   BOUNDARY_INITIALIZATION     : char           INTERIOR       !Type of boundary initialization: INTERIOR or EXTERIOR
!   ADVECTION_DIFFUSION         : 0/1               [0]         !Compute advection-diffusion
!       ADV_DIF_NUM_STABILITY   : 0/1               [0]         !Verifies advection-diffusion numerical stability
!       SCHMIDT_NUMBER_H        : real              [1]         !Conversion number between horizontal turbulent viscosity
!                                                               !and horizontal turbulent diffusion
!       SCHMIDT_COEF_V          : real              [1]         !Vertical diffusivity conversion number
!       SCHMIDT_BACKGROUND_V    : real            [1e-8]        !Molecular diffusion coefficient

!       NULLDIF                 : 0/1               [0]         !Consider null diffusion if velocities are null
!       DECAY_TIME              : real              [0]         !Boundary condition decay time
!       BOUNDARY_CONDITION      : int               [1]         !1-MassConservation,2-ImposedValue,3-VerticalDiffusion,
!                                                               !4-NullGradient,5-SubModel,6-Orlanski,8-CyclicBoundary
!       ADV_METHOD_H            : integer           -           !UpwindOrder1 = 1, UpwindOrder2 = 2,
                                                                !UpwindOrder3 = 3, P2_TVD = 4, CentralDif = 5

!       ADV_METHOD_V            : integer           -           !UpwindOrder1 = 1, UpwindOrder2 = 2,
                                                                !UpwindOrder3 = 3, P2_TVD = 4, CentralDif = 5

!       TVD_LIMIT_H             : integer           -           !MinMod = 1, VanLeer = 2, Muscl = 3, Superbee = 4, PDM = 5
!       TVD_LIMIT_V             : integer           -           !MinMod = 1, VanLeer = 2, Muscl = 3, Superbee = 4, PDM = 5

!       VOLUME_RELATION_MAX     : real              -           !The relation between adjacent volumes aboce which
!                                                               !the advection is upwind

!       ADVECTION_V_IMP_EXP     : real              [0]         !Vertical advection time discretization method
!                                                               !0 - Implicit ; 1 - Explicit
!       DIFFUSION_V_IMP_EXP     : real              [0]         !Vertical diffusion time discretization method
!                                                               !0 - Implicit ; 1 - Explicit
!       ADVECTION_H_IMP_EXP     : real              [1]         !Horizontal advection time discretization method
!                                                               !0 - Implicit ; 1 - Explicit
!   SUBMODEL                    : 0/1               [0]         !Property is influenced by a father model
!       SUBMODEL_INI            : 0/1               [0]         !Property is initialized as being part of a sub model
!   INSTANT_MIXING              : 0/1               [0]         !Compute instant mixing in whole water column
!   PARTITION                   : 0/1               [0]         !Compute partition between dissolved-particulate phases
!       PARTITION_COUPLE        : char               +          !Name of the property (oposite phase) to compute partition
!       PARTITION_FRACTION      : real               -          !Percentage of mass of a property in a determined phase
!       PARTITION_RATE          : real            [1 s-1]       !Kinetic rate of partition to reach equilibrium
!       USE_SED_REF_CONC        : 0/1               [0]         !Use cohesive sediment concentration as a reference
!           SED_REF_CONC        : real              [1]         !Reference cohesive sediment concentration to partition
!       SALINITY_EFFECT         : 0/1               [0]         !Use salinity effect on partition
!           EMPIRIC_COEF        : real            [14.505]      !Empiric coefficient to account for salinity effect
!   WATER_QUALITY               : 0/1               [0]         !Compute water quality processes
!   CEQUALW2                    : 0/1               [0]         !Compute CEQUALW2 ecological processes
!   LIFE                        : 0/1               [0]         !Compute Life ecological processes
!   SURFACE_FLUXES              : 0/1               [0]         !Compute fluxes from water-air interface
!   BOTTOM_FLUXES               : 0/1               [0]         !Compute fluxes from sediment-water interface
!   DISCHARGES                  : 0/1               [0]         !Compute discharges (WWTP, river, etc)
!       DISCHARGES_TRACKING     : 0/1               [0]         !Monitor discharges with outputing a time serie
!   VERTICAL_MOVEMENT           : 0/1               [0]         !Compute vertical movement due to settling velocity
!   DATA_ASSIMILATION           : 0/1/2/3           [0]         !Add nudging term
!   FIRST_ORDER_DECAY           : 0/1               [0]         !Computes the effect of a first order decay
!   T90_VARIABLE                : 0/1               [0]         !Check if the user wants to compute T90 function
!                                                                of ambient properties: salinity,temperature,light
!   T90_VAR_METHOD              : 1/2               [1]         !Fecal decay according to Canteras et al. (1995)
!                                                   [2]         !Fecal decay according to Chapra (1997)
!                                                   [3]         !T90 defined using a time serie
                                                                !0 - No
                                                                !1 - (P-Pref)/Tdecay
                                                                !2 - (P(i-1)-P(i))/Tdecay
!   OXYGEN_SATURATION           : 0/1               [0]         !Check if the user wants to assume oxygen in the
!                                                               !water column equal to saturation
!   CO2_PPRESSURE_OUTPUT        : 0/1               [0]         !Optinal HDF output for CO2 (partial pressure in the water)
!   O2_SATURATION_OUTPUT        : 0/1               [0]         !Optinal HDF output for O2 (saturation in the water)

!   CHLA_WQ_OUTPUT              : 0/1               [0]         !Optinal HDF output for Chla in WaterQuality module
!(conversion from mgC/L to ug Chla/L)
!   C_CHLA_OUTPUT               : real              [60]        !C:Chla ratio for the conversion


!   LIGHT_EXTINCTION            : 0/1               [0]         !Property is accounted to compute light extinction coef.
!       EXTINCTION_PARAMETER    : real              [0]         !Property specific coefficient to compute total
!                                                               !light extinction coef.
!   DT_INTERVAL                 : real              [ModelDT]   !Property evolution time step
!   TIME_SERIE                  : 0/1               [0]         !Ouputs results in time series
!   BOX_TIME_SERIE              : 0/1               [0]         !Ouputs results in box time series
!   OUTPUT_HDF                  : 0/1               [0]         !Ouputs results in HDF5 format
!   STATISTICS                  : 0/1               [0]         !Perform statistics fo property concentration
!       STATISTICS_FILE         : char               -          !Path to statistics input data file
!   WARN_ON_NEGATIVE_VALUES     : 0/1               [0]         !Write a warning to screen when property has negative value
!<endproperty>

!<beginwqrate>
!   NAME                        : char               -           !Name of the rate to perform output
!   DESCRIPTION                 : char               -           !Description of the rate to perform output
!   FIRSTPROP                   : char               -           !Name of the first property involved in the rate
!   SECONDPROP                  : char               -           !Name of the second property involved in the rate
!   MODEL                       : char       [WaterQualityModel] !Name of the biogeochemical to which the rate belongs
!<endwqrate>



Module ModuleWaterProperties

    use ModuleGlobalData
    use ModuleTime
    use ModuleHDF5
    use ModuleEnterData,            only: ReadFileName, ConstructEnterData, GetData,            &
                                          ExtractBlockFromBuffer, Block_Unlock, GetOutPutTime,  &
                                          ExtractBlockFromBlock, KillEnterData, RewindBuffer,   &
                                          GetOutPutTimeWindows, GetNumberOfBlocks, RewindBlock
    use ModuleStopWatch,            only: StartWatch, StopWatch
    use ModuleDrawing
    use ModuleProfile,              only: StartProfile, WriteProfile, KillProfile
    use ModuleGridData,             only: GetGridData, UngetGridData
    use ModuleDischarges,           only: GetDischargesNumber, GetDischargesGridLocalization,   &
                                          GetDischargeWaterFlow, GetDischargeConcentration,     &
                                          GetByPassON, GetDischargesIDName,                     &
                                          GetDischargeFlowDistribuiton, UnGetDischarges,        &
                                          GetDischargeON, GetByPassConcIncrease,                &
                                          GetDischargeFromIntakeON, GetIntakePosition,          &
                                          GetDistributionCoefMass, IsUpscaling, Kill_Discharges
    use ModuleTimeSerie,            only: StartTimeSerie, StartTimeSerieInput, WriteTimeSerie,  &
                                          GetNumberOfTimeSeries, GetTimeSerieLocation,          &
                                          CorrectsCellsTimeSerie, TryIgnoreTimeSerie,           &
                                          WriteTimeSerieLine, GetTimeSerieValue, KillTimeSerie, &
                                          GetTimeSerieName
    use ModuleLightExtinction,      only: ConstructLightExtinction, ModifyLightExtinctionField, &
                                          GetLightExtinctionOptions, KillLightExtinction,       &
                                          GetShortWaveExtinctionField, UnGetLightExtinction,    &
                                          GetLongWaveExtinctionCoef, GetRadiationPercentages,   &
                                          UpdateLightExtinctionSatellite
    use ModuleFillMatrix,           only: ConstructFillMatrix, GetDefaultValue, KillFillMatrix, &
                                          ModifyFillMatrix, GetIfMatrixRemainsConstant
    use ModuleHorizontalMap,        only: GetOpenPoints2D, GetWaterPoints2D, GetBoundaries,     &
                                          UnGetHorizontalMap
    use ModuleHorizontalGrid,       only: GetHorizontalGrid, WriteHorizontalGrid, GetComputeZUV,&
                                          InterpolRegularGrid, UnGetHorizontalGrid,             &
                                          GetHorizontalGridSize, GetGridCellArea, GetXYCellZ,   &
                                          GetDDecompParameters,                                 &
                                          GetDDecompMPI_ID, GetDDecompON,                       &
                                          WindowIntersectDomain, ReturnsIntersectionCorners,    &
                                          GetGridOutBorderPolygon, GetDDecompWorkSize2D,        &
                                          GetDDecompMapping2D, GetConnections

#ifdef _USE_MPI
    use ModuleHorizontalGrid,       only: ReceiveSendProperitiesMPI
#endif

    use ModuleGeometry,             only: GetGeometrySize, GetGeometryVolumes, UnGetGeometry,   &
                                          GetGeometryKFloor, GetGeometryWaterColumn,            &
                                          GetGeometryDistances, GetLayer4Level
    use ModuleMap,                  only: GetWaterPoints3D, GetOpenPoints3D, GetComputeFaces3D, &
                                          GetLandPoints3D, UngetMap
    use ModuleBoxDif,               only: StartBoxDif, GetBoxes, GetDTBoxes, GetNumberOfBoxes,  &
                                          UpdateBoxDif, UngetBoxDif, BoxDif, KillBoxDif
    use ModuleStatistic,            only: ConstructStatistic, GetStatisticMethod,               &
                                          GetStatisticParameters, GetStatisticLayersNumber,     &
                                          GetStatisticLayerDef, AddStatisticLayers,             &
                                          ModifyStatistic, KillStatistic
    use ModuleAssimilation,         only: StartAssimilation, GetAssimilationField,              &
                                          GetAssimilationCoef, UnGetAssimilation,               &
                                          KillAssimilation, GetAssimilationAltimetry,           &
                                          GetAssimilationAltimetryDT, ModifyAssimilation,       &
                                          GetAltimetryDecayTime, GetNumberOfFields, GetNumberOfUpscalingFields
    use ModuleAdvectionDiffusion,   only: StartAdvectionDiffusion, AdvectionDiffusion,          &
                                          GetAdvFlux, GetDifFlux, GetBoundaryConditionList,     &
                                          SetDischarges, UnSetDischarges,                       &
                                          UngetAdvectionDiffusion, KillAdvectionDiffusion
    use ModuleInterface,            only: ConstructInterface, Modify_Interface,                 &
                                          UpdateMassDimensions, GetRateFlux, KillInterface,     &
                                          SetSettlementOnInterface
    use ModuleFreeVerticalMovement, only: Construct_FreeVerticalMovement, GetFreeVertMovOptions,&
                                          Kill_FreeVerticalMovement,Modify_FreeVerticalMovement,&
                                          FreeVertPropertyExists, FreeVertPropertyHasDeposition,&
                                          Get_FreeVelocity, UngetFreeVerticalMovement
    use ModuleHydroIntegration

#ifdef _USE_MPI
    use ModuleFunctions,            only: SigmaLeendertse, SigmaUNESCO,  SigmaWang,             &
                                          SigmaUNESCOPressureCorrection,InterpolateValueInTime, &
                                          SigmaMel96PressureCorrection, SigmaJMD95PressureCorrection, &
                                          ConstructPropertyID, MPIKind,OxygenSaturationCeQualW2,&
                                          OxygenSaturation,OxygenSaturationHenry,               &
                                          CO2PartialPressure, CO2_K0,                           &
                                          ComputeT90_Chapra,                &
                                          ComputeT90_Canteras, SetMatrixValue, CHUNK_J, CHUNK_K, &
                                          InterpolateProfileR8, TimeToString, ChangeSuffix,     &
                                          ExtraPol3DNearestCell, ConstructPropertyIDOnFly, Pad, &
                                          SWPercentage_PaulsonSimpson1977, LWCoef_PaulsonSimpson1977, &
                                          GetPointer, DischargeIsAssociated

    use mpi
#else _USE_MPI
    use ModuleFunctions,            only: SigmaLeendertse, SigmaUNESCO, SigmaWang,              &
                                          SigmaUNESCOPressureCorrection,InterpolateValueInTime, &
                                          SigmaMel96PressureCorrection, SigmaJMD95PressureCorrection, &
                                          ConstructPropertyID,OxygenSaturationCeQualW2,         &
                                          OxygenSaturation,OxygenSaturationHenry,               &
                                          CO2PartialPressure, CO2_K0,                           &
                                          ComputeT90_Chapra,                &
                                          ComputeT90_Canteras, SetMatrixValue, CHUNK_J, CHUNK_K, &
                                          InterpolateProfileR8, TimeToString, ChangeSuffix,     &
                                          ExtraPol3DNearestCell, ConstructPropertyIDOnFly, Pad, &
                                          SWPercentage_PaulsonSimpson1977, LWCoef_PaulsonSimpson1977, &
                                          GetPointer, DischargeIsAssociated
#endif _USE_MPI

    use ModuleTurbulence,           only: GetHorizontalViscosity, GetVerticalDiffusivity,       &
                                          GetMLD_Surf, UnGetTurbulence
    use ModuleHydrodynamic,         only: GetWaterFluxes, GetWaterLevel, GetDischargesFluxes,   &
                                          UngetHydrodynamic, GetHydroAltimAssim, GetVertical1D, &
                                          GetXZFlow, GetHydrodynamicAirOptions,                 &
                                          GetVelocityModulus, GetPointDischargesState, CheckOfflineUpscalingDisch


    use ModuleBivalve,              only: GetBivalveListDeadIDS, GetBivalveNewBornParameters,   &
                                          GetBivalveNewborns, GetBivalveOtherParameters,        &
                                          UpdateBivalvePropertyList, UnGetBivalve

    use ModuleTwoWay,               only: PrepTwoWay, UngetTwoWayExternal_Vars, ModifyTwoWay,  &
                                          UpscaleDischarge_WP, GetUpscalingDischarge, &
                                          Offline_Upscaling_Discharge_WP

#ifdef _ENABLE_CUDA
    use ModuleCuda
#endif _ENABLE_CUDA

    !$ use omp_lib

    implicit none

    private

    !subroutines---------------------------------------------------------------

    !Constructor
    public  :: Construct_WaterProperties
    private ::      AllocateInstance
    private ::      Construct_GlobalVariables
    private ::          Read_WaterProperties_Files_Name
    private ::          ConstructDDecomp
    private ::      ConstructNoFluxInterior
#ifdef _USE_SEQASSIMILATION
    private ::      ConstructBooleanSeqAssimilation
#endif _USE_SEQASSIMILATION
    private ::      Construct_PropertyList
    private ::          Construct_Property
    private ::              Construct_PropertyValues
    private ::                  DefaultValueProp            !Function
    private ::                  ReadOldConcBoundariesHDF
    private ::              Construct_PropertyEvolution
    private ::                  Read_Advec_Difus_Parameters
    private ::                  Read_Partition_Parameters
    private ::                  Read_Filtration_Parameters
    private ::                  Read_Reinitialize_Parameters
    private ::              Construct_PropertyOutPut
    private ::          Add_Property
    private ::      ConstructChemLinks
    private ::          ReadChemLink
    private ::      Construct_WQrateList
    private ::          Construct_WQrate
    private ::              Construct_WqrateID
    private ::              Construct_WQRateValues
    private ::          Add_WqRate
    private ::      ConstructDensity
!~     private ::          Check_Particulate_Property          !Function
    private ::      ConstructSpecificHeat
    private ::      ConstructGlobalOutput
    private ::      ModifyOxygenSaturation
    private ::      Open_HDF5_OutPut_File
    private ::      Open_Surface_HDF5_OutPut_File
    private ::      ConstructDoSat
    private ::      ConstructBooleanAltimAssim              ! guillaume nogueira
    private ::      Construct_Sub_Modules
    private ::          CheckOptionsSolutionFromFile
    private ::          SolarRadiationIsNeeded
    private ::          ConstructConvection
    private ::          CoupleLightExtinction
    private ::          CoupleWaterQuality
    private ::          CoupleCEQUALW2
    private ::          CoupleLife
    private ::          CoupleBivalve
    private ::              ConstructSpeciesList
    private ::                  AddSpecies
    private ::                  ConstructSpecies
    private ::                      ConstructCohortList
    private ::                          AddCohort
    private ::                          ConstructCohort
    private ::                              Construct_CohortPropFromFile
    private ::                      ConstructSpeciesSettlement
    private ::              SetSpeciesSettlementProbability
    private ::              UpdateLarvaeDistribution
    private ::              ConstructBivalveOutput
    private ::          CoupleMacroAlgae
    private ::          CoupleSeagrassesLeaves
    private ::          CoupleFreeVerticalMovement
    private ::          CoupleHydroIntegration
    private ::          ConstructPartition
    private ::          ConstructAltimAssimilation
    private ::          CheckOfflineUpscaling
    private ::          ConstructHybridWeights
    private ::          StartOutputBoxFluxes
    private ::          Construct_Time_Serie
    private ::          Construct_Output_Profile
    private ::      CheckAditionalOutputs
    private ::      ConstructLog
    private ::      Read_Old_Properties_2D
#ifdef _USE_SEQASSIMILATION
    private ::      ConstructBooleanSeqAssimilation
#endif _USE_SEQASSIMILATION
#ifdef OVERLAP
    private ::      ConstructWaterOverlap
#endif OVERLAP


    private ::      ConstructTimeInterpolation
    private ::      ReadNextOrInitialField

#ifdef _USE_SEQASSIMILATION
    public  :: ConstructPropertiesIDArray

    !Subroutine to point to memory space of water properties
    public  :: PointToDensity
    public  :: PointToConcentration
#endif _USE_SEQASSIMILATION

    !Selector
    public  :: GetWaterPropertiesNumber
    public  :: GetConcentration
    public  :: GetFiltrationRate
    public  :: GetWaterPropertyOptions
    public  :: GetDensityOptions
    public  :: GetDensity
    public  :: GetSalinity
    public  :: GetTemperature
    public  :: GetSigma
    public  :: GetSigmaNoPressure
    public  :: GetSpecificHeat
    public  :: GetSpecificHeatReference
    public  :: WaterPropertyExists
    public  :: GetSPM
    public  :: GetWaterNeedsFather
    public  :: GetPropListNeedsFather
    public  :: GetWaterPropertiesSubModulesID
    public  :: GetWaterPropertiesAirOptions
    public  :: GetWaterPropertiesBottomOptions
    public  :: GetPropertySurfaceFlux
    public  :: GetShortWaveRadiationAverage
    public  :: GetSeagrassArray2D
    public  :: GetSeagrassesLeavesRates
    public  :: GetMacroalgaeBiomass
#ifdef _USE_SEQASSIMILATION
    public  :: GetWaterPropertiesIDArray
    public  :: GetWaterSeqAssimilation
#endif _USE_SEQASSIMILATION

#ifdef OVERLAP
    public  :: GetWaterOverlap
    public  :: SetModelOverlapWater
#endif OVERLAP

    private ::          Search_Property
    private ::      Search_PropertyFather

    public  :: UngetWaterProperties

    public  :: SetFluxToWaterProperties
    public  :: SetMacroAlgaeParameters
    public  :: SetSurfaceFlux
    public  :: SetLagrangianSinksSources

#ifdef _USE_SEQASSIMILATION
    !Set subroutines usable to point variables to external variables/memory space
    public  :: SetDensity
    public  :: SetSigma
    public  :: SetConcentration
    !Set subroutine to manage virtual runs
    public  :: SetWaterPropVirtualRun
    !Reset subroutines usable to reestablish variables to internal memory space
    public  :: ReSetDensity
    public  :: ReSetConcentration
#endif _USE_SEQASSIMILATION

    !Modifier
    public  :: WaterProperties_Evolution
    private ::      ModifyPropertiesFromFile
    private ::      HydroIntegration_Processes
    private ::      WaterPropDischarges
    private ::          Modify_Upscaling_Discharges
    private ::      UpdateHybridReferenceField
    private ::      ModifyNoFluxMapping
    private ::      Advection_Diffusion_Processes
    private ::          PrepareLarvaeAdvectionDiffusion
    private ::          FreeConvection
    private ::          SmallDepthsMixing_Processes
    private ::      InstantaneouslyMixing
    private ::      SetLimitsConcentration
    private ::      SetLimitsProperty
    private ::      FreeVerticalMovements_Processes
    private ::      Bottom_Processes
    private ::      ModifySolarRadiation
    private ::          Compute_SWExtCoefField
    private ::      ModifyDecayRate
    private ::      FirstOrderDecayProcesses
    private ::      Surface_Processes
    private ::          ComputeSurfaceHeatFluxes
    private ::      WaterQuality_Processes
    private ::      CEQUALW2_Processes
    private ::      Life_Processes
    private ::      MacroAlgae_Processes
    private ::          DistributeMacroAlgae
    private ::          IntegrateMacroAlgae
    private ::          MacroAlgaePhysicalConditions
    private ::          ComputeMacroAlgaeOccupation
    private ::      WWTPQ_Processes
    private ::      Bivalve_Processes
    private ::          CheckListDeadAndListNewborns
    private ::              UpdatePropertyList
    private ::                  RemoveDeadIDsFromList
    private ::                      RemoveCohortFromList
    private ::                      RemovePropertyFromList
    private ::                  AddNewbornsToList
    private ::                      ConstructNewBornCohort
    private ::                          Construct_CohortPropFromCohort
    private ::                          Construct_OutputBoxesFromCohort
    private ::              UpdateBivalvePropertyList
    private ::              UpdateInterfaceMass
    private ::          BivalveOutput
    private ::              BivalveOutputHDF
    private ::              BivalveOutputBoxTimeSerie
    private ::      Partition_Processes
    private ::      DataAssimilationProcesses
    private ::          GetNumberOfPropFields
    private ::          FillAssimilationField
    private ::          Get_Check_AssimilationCoef
    private ::          Assimilation_Down_Up
    private ::              Nudge_To_Ref
    private ::              Nudge_AdvVert
    private ::      AltimAssimilationProcess
    private ::      CalculateAge
    private ::      ModifyDensity
    private ::      ModifyDensitySed
    private ::      Filtration_Processes
    private ::      Reinitialize_Solution
    private ::      ModifySpecificHeat
    private ::          ComputeSpecificHeatUNESCO
    private ::      Modify_TwoWay_Upscaling
    private ::          Compute_wp_upscaling
    private ::      OutPut_Results_HDF
    private ::      OutPut_SurfaceResults_HDF
    private ::      OutPut_TimeSeries
    private ::      OutPut_Profile
    private ::      OutPut_BoxTimeSeries
    private ::      OutPut_Statistics
    private ::      Actualize_Time_Evolution
    public  ::  SetWaterPropFather
    private ::  ActualizeSubModelValues
    private ::  ActualizeSon3DFather2D
    private ::  ActualizeSon3DFather3D

#ifdef _USE_SEQASSIMILATION
    !Copy subroutines usable in sequential data assimilation to change variables' value
    public  :: CopyDensity
    public  :: CopyTemperature
    public  :: CopySalinity
    public  :: CopyConcentration
#endif _USE_SEQASSIMILATION

    !Destructor
    public  :: KillWaterProperties
    private ::      Write_FinalWaterProperties_HDF
    private ::      DeallocateInstance
    private :: KillDensity
    private :: KillSpecificHeat
    private :: KillSolarRadiation

#ifdef _USE_SEQASSIMILATION
    !Subroutine to point to memory space of water properties
    public  :: NullifyDensityPointer
    public  :: NullifyConcentrationPointer
#endif _USE_SEQASSIMILATION

    !Management
    private ::      Ready
    private ::          LocateObjWaterProperties
    private ::          LocateObjFather
    private ::          LocateObjSon

    private ::              ReadLockExternalVar
    private ::              ReadUnlockExternalVar

#ifdef _USE_MPI
    public  :: SendWaterPropertiesMPI
    public  :: RecvWaterPropertiesMPI
    public  :: UpdateWaterMPI
    !include "mpif.f90"
#endif _USE_MPI


    !Interfaces----------------------------------------------------------------

    private :: UngetWaterProperties3D
    private :: UngetWaterProperties2D ! Isabella
    interface  UngetWaterProperties
#ifdef _USE_SEQASSIMILATION
        module procedure UngetWaterProperties1D_I4
#endif _USE_SEQASSIMILATION
        module procedure UngetWaterProperties3D
        module procedure UngetWaterProperties2D
    end interface UngetWaterProperties

    !Parameter-----------------------------------------------------------------

    ! DoSat type
    integer, parameter                          :: Apha                 = 1
    integer, parameter                          :: Henry                = 2
    integer, parameter                          :: Mortimer             = 3


    !Minimum radiation
    real,    parameter                          :: MinRadiation         = 0.001

    !Directions
    integer, parameter                          :: DirectionX           = 1
    integer, parameter                          :: DirectionY           = 2

    !Nudging
    integer, parameter                          :: NoNudging            = 0
    integer, parameter                          :: NudgingToRef         = 1
    integer, parameter                          :: NudgingAdvVert       = 2
    integer, parameter                          :: Hybrid               = 3

    character(LEN = StringLength), parameter    :: prop_block_begin     = '<beginproperty>'
    character(LEN = StringLength), parameter    :: prop_block_end       = '<endproperty>'
    character(LEN = StringLength), parameter    :: wqrateblock_begin    = '<beginwqrate>'
    character(LEN = StringLength), parameter    :: wqrateblock_end      = '<endwqrate>'

    character(LEN = StringLength), parameter    :: shading_begin        = '<begin_shading>'
    character(LEN = StringLength), parameter    :: shading_end          = '<end_shading>'
    character(LEN = StringLength), parameter    :: SW_Kd_2D_begin       = '<begin_SW_Kd_2D>'
    character(LEN = StringLength), parameter    :: SW_Kd_2D_end         = '<end_SW_Kd_2D>'



    !T90 Calc Method
    integer, parameter                          :: Canteras             = 1
    integer, parameter                          :: Chapra               = 2

    !Filtration
    integer, parameter                          :: GrazeR               = 1
    integer, parameter                          :: GrazeD               = 2


    !Types---------------------------------------------------------------------
    type       T_ID
        integer                                 :: ID, IDNumber
        character(LEN = StringLength)           :: Name
        character(LEN = StringLength)           :: Description
        character(LEN = StringLength)           :: Units
    end type T_ID

    type       T_Property_2D
        type(T_PropertyID)                      :: ID
        real, pointer, dimension (:,:)          :: Field
        real                                    :: Scalar
        logical                                 :: Constant
        logical                                 :: ON =.false.
    end type T_Property_2D

    type       T_Discharge
        integer                                 :: Number
        integer, dimension(:), pointer          :: i, j, k, nCells, kmin, kmax
        real,    dimension(:), pointer          :: Flow
        integer, dimension(:), pointer          :: Vert
        logical, dimension(:), pointer          :: Ignore, ByPass
    end type   T_Discharge


    type       T_AdvectionDiffusion_Parameters
        integer                                 :: BoundaryCondition
        real                                    :: DecayTime
        real                                    :: SchmidtNumberH
        real                                    :: SchmidtCoefV
        real                                    :: SchmidtBackgroundV
        real                                    :: AdvectionV_imp_exp
        real                                    :: DiffusionV_imp_exp
        real                                    :: AdvectionH_imp_exp
        real                                    :: DiffusionH_imp_exp
        real                                    :: ImplicitH_direction
        logical                                 :: Nulldif              = .false.
        logical                                 :: NumericStability
        real, dimension(:,:,:), pointer         :: PropOld
        real                                    :: VolumeRelMax
        integer                                 :: AdvMethodH, TVDLimitationH
        integer                                 :: AdvMethodV, TVDLimitationV
        logical                                 :: Upwind2H, Upwind2V
        logical                                 :: AdvectionNudging
        integer                                 :: AdvectionNudgingCells
    end type T_AdvectionDiffusion_Parameters

    type       T_FreeVerticalMovParameters
        real                                    :: Ws_Value             = FillValueReal
        real                                    :: CHS                  = FillValueReal
        real                                    :: KL                   = FillValueReal
        real                                    :: KL1                  = FillValueReal
        real                                    :: M                    = FillValueReal
        real                                    :: ML                   = FillValueReal
        real                                    :: ImpExp_AdvV          = FillValueReal
        logical                                 :: SALTINT              = .true.
        integer                                 :: Ws_Type              = SPMFunction
        real                                    :: SALTINT_Value        = FillValueReal
    end type T_FreeVerticalMovParameters


    type       T_Partition
        character (LEN = StringLength)          :: Couple
        integer                                 :: Couple_ID            = FillValueInt
        real                                    :: Fraction             = FillValueReal
        real                                    :: Rate                 = FillValueReal
        real                                    :: EmpiricCoef          = FillValueReal
        real                                    :: SedimentRefConc      = FillValueReal
        real                                    :: MaxConc              = FillValueReal
        logical                                 :: UseSedimentRefConc   = .false.
        logical                                 :: SalinityEffect       = .false.
        logical                                 :: NonComplianceCriteria= .false.
    end type T_Partition

    type       T_LightExtinction
        real                                    :: Coefficient          = FillValueReal
    end type   T_LightExtinction

    type       T_Filtration
        type (T_PropertyID)                     :: ID
        real, pointer, dimension(:,:,:)         :: Rate, Cumulative, CumulativePerMeter
        real, pointer, dimension(:,:,:)         :: FilterFeederMass
        logical                                 :: On
        logical                                 :: Freeze               = .false.
        logical                                 :: Excretions           = .false.
        logical                                 :: FeederMassON         = .false.
        integer                                 :: TypeOf
        integer                                 :: GrazedPropID
        integer                                 :: Excreted_Property_ID
        real                                    :: AssimilationEfficiency
        real                                    :: StoichiometricRatio
        real                                    :: UnitsCoef
        real                                    :: MinConcentrationToFilter
    end type   T_Filtration

    type       T_Reinitialize
        logical                                 :: On                   = .false.
        logical,       dimension(:),   pointer  :: OnlyOnce
        integer,       dimension(:,:), pointer  :: BoxCells
        real,          dimension(:),   pointer  :: BoxesValues
        integer                                 :: BoxesNumber
        type (T_time), dimension(:),   pointer  :: Dates
    end type   T_Reinitialize

    type       T_MacroAlgae
        logical                                 :: VariableHeight = .false.
        real,    pointer, dimension(:,:  )      :: Distribution     !kgC/m2
        real                                    :: DefaultValue, HBRatio, HeightConstant
        real,    pointer, dimension(:,:,:)      :: ShearStress3D
        real,    pointer, dimension(:,:,:)      :: SPMDepFlux3D
        real,    pointer, dimension(:,:,:)      :: Occupation
        !real,    pointer, dimension(:,:,:)      :: DistFromTop
        real,    pointer, dimension(:,:  )      :: MaxShearStress, Height
        real,    pointer, dimension(:,:  )      :: MaxSPMDepFlux
    end type   T_MacroAlgae

    type       T_SizeClass
       character(len=StringLength)              :: Name
       real,    pointer, dimension(:,:,:)       :: Density => null()
       real                                     :: Minimum, Maximum
    end type   T_SizeClass

    type       T_Cohort
        type (T_ID)                             :: ID
        logical                                 :: AtLeastOneLarvae
        integer, pointer, dimension(:,:,:)      :: Larvae
        real,    pointer, dimension(:,:,:)      :: AuxLarvaeL
        real,    pointer, dimension(:,:,:)      :: AuxLarvaeME
        real,    pointer, dimension(:,:,:)      :: AuxLarvaeMV
        real,    pointer, dimension(:,:,:)      :: AuxLarvaeMH
        real,    pointer, dimension(:,:,:)      :: AuxLarvaeMR
        real,    pointer, dimension(:,:,:)      :: AuxLarvaeN
        type(T_Cohort), pointer                 :: Next
    end type   T_Cohort

    type       T_Species
        type (T_ID)                             :: ID
        logical                                 :: Old                    = .false.
        real                                    :: DTInterval             = FillValueReal
        logical                                 :: LarvaeTransport        = .false.
        logical                                 :: WarnOnNegativeValues   = .false.
        logical                                 :: CohortOutputHDF        = .false.
        logical                                 :: CohortBoxTimeSerie     = .false.
        logical                                 :: CohortStatistics       = .false.
        character(len=Pathlength)               :: CohortStatisticsFile
        logical                                 :: PopulationHDF          = .false.
        logical                                 :: PopulationBoxTimeSerie = .false.
        logical                                 :: BySizeOutputHDF        = .false.
        logical                                 :: BySizeBoxTimeSerie     = .false.
        integer                                 :: nCohorts               = 0
        integer                                 :: LastCohortID           = 0
        type(T_Cohort),  pointer                :: FirstCohort            => null()
        real                                    :: M_V0                   = FillValueReal
        real                                    :: M_E0                   = FillValueReal
        real                                    :: M_H0                   = FillValueReal
        real                                    :: M_R0                   = 0.0
        real                                    :: L_0                    = FillValueReal
        real                                    :: A_0                    = 0.0
        real                                    :: MinObsLength           = FillValueReal
        real                                    :: LarvaeMaxSize          = FillValueReal
        real,    pointer, dimension(:,:,:)      :: TotalDensity
        real,    pointer, dimension(:,:,:)      :: FieldDensity
        real,    pointer, dimension(:,:,:)      :: TotalBiomass
        real,    pointer, dimension(:,:,:)      :: CohortsNumber
        real,    pointer, dimension(:,:,:)      :: SettlementProbability
        type (T_PropertyID)                     :: SettlementID
        integer                                 :: NumberSizeClasses
        type(T_SizeClass), pointer, dimension(:):: SizeClasses
        type(T_Species), pointer                :: Next
    end type   T_Species

    type       T_Bivalve
        type(T_Species), pointer                :: FirstSpecies           => null()
        integer                                 :: nSpecies               = 0
        integer                                 :: nPropertiesFromBivalve = 0
        integer                                 :: nCohortProperties       = 7 !Each cohort has 7 properties
        integer, pointer, dimension(:)          :: ListDeadIDS             => null()
        integer, pointer, dimension(:)          :: ListNewbornsIDs         => null()
        real   , pointer, dimension(:,:)        :: MatrixNewborns          => null()
        logical                                 :: OutputHDF               = .false.
        logical                                 :: OutputBoxTimeSerie      = .false.
        integer                                 :: ObjHDF5                 = 0
        integer                                 :: ObjBoxDif               = 0
        character(len=Pathlength)               :: BivalveHDFOutputFile

    end type   T_Bivalve

    type       T_Evolution
        logical                                 :: Variable             = .false.
        real                                    :: DTInterval
        type(T_Time)                            :: LastCompute
        type(T_Time)                            :: NextCompute
        logical                                 :: WaterQuality         = .false.
        logical                                 :: MacroAlgae           = .false.
        logical                                 :: SeagrassesLeaves     = .false.
        logical                                 :: CEQUALW2             = .false.
        logical                                 :: Life                 = .false.
        logical                                 :: Bivalve              = .false.
        logical                                 :: WWTPQ                = .false.
        logical                                 :: PhreeqC              = .false.
        logical                                 :: Partitioning         = .false.
        logical                                 :: FreeVerticalMovement = .false.
        logical                                 :: AdvectionDiffusion   = .false.
        logical                                 :: Discharges           = .false.
        logical                                 :: DischargesTracking   = .false.
        logical                                 :: SurfaceFluxes        = .false.
        logical                                 :: BottomFluxes         = .false.
        logical                                 :: HydroIntegration     = .false.
        integer                                 :: DataAssimilation     =  NoNudging
        logical                                 :: MinConcentration     = .false.
        logical                                 :: MaxConcentration     = .false.
        logical                                 :: InstantMixing        = .false.
        logical                                 :: LightExtinction      = .false.
        logical                                 :: FirstOrderDecay      = .false.
        logical                                 :: DecayRateProperty    = .false.
        integer                                 :: T90PropertyID        = FillValueInt
        logical                                 :: T90Variable          = .false.
        logical                                 :: T90Hours             = .false.
        integer                                 :: T90Var_Method        = FillValueInt
        logical                                 :: LagSinksSources
        logical                                 :: OxygenSaturation     = .false.
        logical                                 :: CO2_PP_Output        = .false.
        logical                                 :: O2_Sat_Output        = .false.
        logical                                 :: CHLA_WQ_Output       = .false.
        real                                    :: C_CHLA_Output

        logical                                 :: ImposeDryCells       = .false.

        type (T_Filtration                   )  :: Filtration
        type (T_Reinitialize                 )  :: Reinitialize
        type (T_AdvectionDiffusion_Parameters)  :: Advec_Difus_Parameters
        type (T_FreeVerticalMovParameters    )  :: FreeVert_Parameters
        type (T_Partition                    )  :: Partition
        type (T_LightExtinction              )  :: Extinction

        logical                                 :: NoAdvFluxCells       = .false.
        logical                                 :: NoDifFluxCells       = .false.
        logical                                 :: SetLimitsTrigger     = .false.
        logical                                 :: Upscaling            = .false.
    end type T_Evolution

    type       T_LocalAssimila
        real                                    :: scalar       = FillValueReal
        real, pointer       , dimension(:,:,:)  :: Field
        real, allocatable   , dimension(:,:,:)  :: Field_Upscaling!Sobrinho
        real, pointer       , dimension(:,:,:)  :: DecayTime
        real, pointer       , dimension(:,:)    :: DecayTime2D !Sobrinho
        character(len=StringLength)             :: GroupOutPutName
    end type T_LocalAssimila


    type       T_OutPut
         type (T_Time), pointer, dimension(:)   :: OutTime
         type (T_Time), pointer, dimension(:)   :: RestartOutTime
         type (T_Time), pointer, dimension(:)   :: SurfaceOutTime
         integer                                :: TotalOutputs
         integer                                :: TotalSurfaceOutputs
         integer                                :: NextOutPut
         integer                                :: NextRestartOutput
         integer                                :: NextSurfaceOutput
         logical                                :: Yes                  = .false.
         logical                                :: Run_End              = .false.
         logical                                :: DO_PercentSat        = .false.
         logical                                :: CHLA_WQ              = .false.
         logical                                :: CO2_PartialPressure  = .false.
         logical                                :: T90                  = .false.
         logical                                :: Radiation            = .false.
         logical                                :: AditionalFields      = .false.
         logical                                :: WriteRestartFile     = .false.
         logical                                :: RestartOverwrite     = .false.
         logical                                :: SurfaceOutputs       = .false.
         real                                   :: C_CHLA
         real,    pointer, dimension(:,:,:)     :: Aux3D
         real,    pointer, dimension(:,:)       :: Aux2D
         real(4), pointer, dimension(:,:,:)     :: Aux3Dreal4           => null()
        logical                                 :: Simple               = .false.
    end type T_OutPut

    type      T_OutW
        type(T_OutPutTime),dimension(:),pointer :: OutPutWindows   => null()
        type(T_Size2D    ),dimension(:),pointer :: OriginalCorners => null()
        logical                                 :: OutPutWindowsON = .false.
        integer                                 :: WindowsNumber   = 0
        integer,           dimension(:),pointer :: ObjHDF5         => null()
        logical                                 :: Simple          = .false.
    end type  T_OutW

    type       T_SubModel
        logical                                 :: ON
        logical                                 :: TwoWay
        logical                                 :: Set
        logical                                 :: InterPolTime = .false.
        logical                                 :: Initial
        logical                                 :: Extrapolate
        integer                                 :: VertComunic
        real,    dimension(:,:,:), pointer      :: NextField, PreviousField
        real                                    :: TwoWayWaitPeriod, TwoWayTimeDecay
        type(T_Time)                            :: NextTime, PreviousTime

        ! Ang: new implementation father-son 3D
        !Father3D-Son3D connection auxiliary
        integer                                 :: FatherKLB, FatherKUB
        real,    pointer, dimension(:,:,:)      :: Aux_Field
        real,    pointer, dimension(:,:,:)      :: Aux_ZCellCenter
        type(T_Time)                            :: GetFatherTime

    endtype

    type       T_Property
        type(T_PropertyID)                      :: ID
        real                                    :: ISCoefficient
        logical                                 :: Particulate
        logical                                 :: Non_Cohesive         = .false.
        type (T_Evolution)                      :: Evolution
        type (T_LocalAssimila)                  :: Assimilation
        type (T_SubModel)                       :: SubModel
        real                                    :: Scalar               = FillValueReal
        logical                                 :: Old                  = .false.
        logical                                 :: WarnOnNegativeValues = .false.
        logical                                 :: AddOffSet            = .false.
        real                                    :: OffSet               = FillValueReal
        logical                                 :: TimeSerie            = .false.
        logical                                 :: OutputHDF            = .false.
        logical                                 :: OutputReal4          = .true.
        logical                                 :: OutputSurfaceHDF     = .false.
        logical                                 :: OutputProfile        = .false.
        logical                                 :: OutputHDFSedVel      = .false.
        logical                                 :: UpscalingSinkSource  = .false.
        logical                                 :: BoxTimeSerie         = .false.
        logical                                 :: BoxIntegrationByArea = .false.
        logical                                 :: Statistics           = .false.
        character(len=Pathlength)               :: StatisticsFile
        integer                                 :: StatisticID
        real, pointer, dimension(:,:,:)         :: Concentration
#ifdef _USE_PAGELOCKED
        type(C_PTR)                             :: ConcentrationPtr
#endif
        real, pointer, dimension(:,:,:)         :: ConcentrationOld
        real, pointer, dimension(:,:  )         :: SurfaceFlux
        real, pointer, dimension(:,:,:)         :: Mass_Created
        real, pointer, dimension(:,:,:)         :: Mass_Destroid
        real, allocatable, dimension(:,:,:)     :: UpscalingMassLoss
        real, pointer, dimension(:,:  )         :: BottomFlux
        real, pointer, dimension(:,:,:)         :: Filtration
        real, pointer, dimension(:    )         :: DischConc
        real                                    :: MinValue             =   FillValueReal
        real                                    :: MaxValue             = - FillValueReal
        real                                    :: GFW = - FillValueReal !Gram formula weight
        type(T_Property), pointer               :: Next, Prev

#ifdef _USE_SEQASSIMILATION
        real, pointer, dimension(:,:,:)         :: AuxPointerConc
#endif _USE_SEQASSIMILATION

        real                                    :: DryCellConcentration

    end type T_Property

    !------------------------------------------------
    !Mainly for use with PhreeqC
    type T_ChemItem
        type (T_Property), pointer              :: Property => null()
        integer                                 :: NumberOfAtoms = 0
    end type T_ChemItem

    type T_ChemLink
        type (T_Property), pointer              :: Species => null()
        integer                                 :: NumberOfComponents = 0
        type (T_ChemItem), pointer              :: Components(:) => null()
    end type T_ChemLink

    type T_ChemLinks
        logical                                 :: Coupled = .false.
        integer                                 :: NumberOfLinks = 0
        type(T_ChemLink), pointer               :: Links(:)
    end type T_ChemLinks
    !-----------------------------------------------

    type       T_WQRate
        type (T_ID)                             :: ID
        type (T_ID)                             :: FirstProp, SecondProp
        type (T_OutPut)                         :: OutPut
        real, pointer, dimension(:,:,:)         :: Field
        real, pointer, dimension(:,:,:)         :: Field2
        character(len=StringLength)             :: Model
        type(T_WQRate), pointer                 :: next,prev
        integer                                 :: CeQualID
    end type T_WQRate

    type       T_Files
         character(len=Pathlength)              :: InitialWaterProperties
         character(len=Pathlength)              :: FinalWaterProperties
         character(len=Pathlength)              :: OutPutFields
         character(len=Pathlength)              :: ConstructData
         character(len=Pathlength)              :: BoxesFile
    end type T_Files

    type       T_Coupling
         type(T_Time)                           :: NextCompute
         real                                   :: DT_Compute = FillValueReal
         logical                                :: Yes                  = .false.
         integer                                :: NumberOfProperties   = 0
    end type T_Coupling

    type     T_Age
         logical                                :: UseWaterPoints                  = .false.
    end type T_Age

    type        T_HybridWeights
        type(T_PropertyID)                      :: ID
        real, pointer, dimension(:,:,:)         :: Field
    end type    T_HybridWeights

    type       T_Coupled
         type(T_Coupling)                       :: AdvectionDiffusion
         type(T_Coupling)                       :: WQM
         type(T_Coupling)                       :: CEQUALW2
         type(T_Coupling)                       :: Life
         type(T_Coupling)                       :: Bivalve
         type(T_Coupling)                       :: WWTPQM
         type(T_Coupling)                       :: PhreeqC
         type(T_Coupling)                       :: Partition
         type(T_Coupling)                       :: FreeVerticalMovement
         type(T_Coupling)                       :: SurfaceFluxes
         type(T_Coupling)                       :: BottomFluxes
         type(T_Coupling)                       :: FirstOrderDecay
         type(T_Coupling)                       :: DecayRateProperty
         type(T_Coupling)                       :: InstantMixing
         type(T_Coupling)                       :: LightExtinction
         type(T_Coupling)                       :: Discharges
         type(T_Coupling)                       :: DischargesTracking
         type(T_Coupling)                       :: UpscalingDischarge
         type(T_Coupling)                       :: OfflineUpscalingDischarge
         type(T_Coupling)                       :: HydroIntegration
         type(T_Coupling)                       :: DataAssimilation
         type(T_Coupling)                       :: AltimetryAssimilation ! nogueira e guillaume
         type(T_Coupling)                       :: MinimumConcentration
         type(T_Coupling)                       :: MaximumConcentration
         type(T_Coupling)                       :: TimeSerie
         type(T_Coupling)                       :: OutputProfile
         type(T_Coupling)                       :: BoxTimeSerie
         type(T_Coupling)                       :: Statistics
         type(T_Coupling)                       :: SolutionFromFile
         type(T_Coupling)                       :: CalculateAge
         type(T_Coupling)                       :: Filtration
         type(T_Coupling)                       :: MacroAlgae
         type(T_Coupling)                       :: SeagrassesLeaves
         type(T_Coupling)                       :: LagSinksSources
         type(T_Coupling)                       :: Reinitialize
         type(T_Coupling)                       :: ImposeDryCells
         logical                                :: AllSolutionFromFile
         logical                                :: HybridReferenceField
    end type T_Coupled

    type       T_Density
        type(T_PropertyID)                      :: ID
        integer                                 :: Method
        logical                                 :: CorrecPress, CorrecSed
        logical                                 :: CorrecNonCohesiveSed =.false.
        real, pointer, dimension(:,:,:)         :: Field
        real, pointer, dimension(:,:,:)         :: Sigma
        real, pointer, dimension(:,:,:)         :: SigmaNoPressure
        real                                    :: Reference    = FillValueReal
        real                                    :: CohesiveSed  = FillValueReal
        real                                    :: NonCohesiveSed  = FillValueReal
        logical                                 :: Variable     =.false.
        logical                                 :: VariableSed  =.false.
        type(T_Time)                            :: LastActualization

#ifdef _USE_SEQASSIMILATION
        real, pointer, dimension(:,:,:)         :: AuxPointerConc
        real, pointer, dimension(:,:,:)         :: AuxPointerSigma
#endif _USE_SEQASSIMILATION
    end type T_Density

    type       T_SpecificHeat
        type(T_PropertyID)                      :: ID
        logical                                 :: UseField
        integer                                 :: Method
        real, pointer, dimension(:,:,:)         :: Field
        real                                    :: Reference    = FillValueReal
        logical                                 :: Variable     =.false.
        type(T_Time)                            :: LastActualization
    end type T_SpecificHeat

    type       T_Radiation
        real, pointer, dimension(:,:,:)         :: ShortWaveTop
        real, pointer, dimension(:,:,:)         :: ShortWaveAverage
        real, pointer, dimension(:,:,:)         :: LongWaveTop
        logical                                 :: Exists
        type       (T_Property_2D)              :: Shading
        type       (T_Property_2D)              :: ShortWave_Kd_2D
    end type T_Radiation

    type       T_DischargeTimeSerie
        integer                                 :: TimeSerie = 0
        type (T_DischargeTimeSerie), pointer    :: Next
    end type   T_DischargeTimeSerie

    type       T_SmallDepths
        logical, pointer, dimension(:,:  )      :: ON
        real                                    :: Limit
    end Type

    type       T_External
        type(T_Time)                            :: Now
        real,    pointer, dimension(:,:,:)      :: DWZ
        real,    pointer, dimension(:,:,:)      :: SZZ
        real,    pointer, dimension(:,:  )      :: GridCellArea
        real,    pointer, dimension(:,:,:)      :: ZCellCenter
        real,    pointer, dimension(:,:,:)      :: Visc_H
        real,    pointer, dimension(:,:,:)      :: Diff_V
        real(8), pointer, dimension(:,:,:)      :: VolumeZ
        real(8), pointer, dimension(:,:,:)      :: VolumeZOld
        real(8), pointer, dimension(:,:,:)      :: WaterFluxX
        real(8), pointer, dimension(:,:,:)      :: WaterFluxY
        real(8), pointer, dimension(:,:,:)      :: WaterFluxZ
        real,    pointer, dimension(:,:,:)      :: VelocityModulus
        real(8), pointer, dimension(:,:,:)      :: Discharges
        integer, pointer, dimension(:,:,:)      :: ComputeFacesU3D
        integer, pointer, dimension(:,:,:)      :: ComputeFacesV3D
        integer, pointer, dimension(:,:,:)      :: ComputeFacesW3D
        integer, pointer, dimension(:,:,:)      :: OpenPoints3D
        integer, pointer, dimension(:,:  )      :: BoundaryPoints2D
        integer, pointer, dimension(:,:,:)      :: WaterPoints3D
        integer, pointer, dimension(:,:,:)      :: LandPoints3D
        real,    pointer, dimension(:,:  )      :: XX_IE, YY_IE
        real,    pointer, dimension(:,:  )      :: Bathymetry
        integer, pointer, dimension(:,:  )      :: KFloor_Z
        integer, pointer, dimension(:,:  )      :: WaterPoints2D
        real,    pointer, dimension(:,:  )      :: ShearStress
        real,    pointer, dimension(:,:  )      :: SPMDepositionFlux
        logical                                 :: Vertical1D           = .false.
        logical                                 :: XZFlow               = .false.
        logical                                 :: Backtracking         = .false.
    end type T_External

    type       T_ExtSurface
        real,    pointer, dimension(:,:  )      :: Evaporation
        real,    pointer, dimension(:,:  )      :: Precipitation
        logical                                 :: PrecipitationON
        real,    pointer, dimension(:,:  )      :: OxygenFlux
        real,    pointer, dimension(:,:  )      :: CarbonDioxideFlux
        real,    pointer, dimension(:,:  )      :: AmmoniaFlux
        real,    pointer, dimension(:,:  )      :: NitrateFlux
        real,    pointer, dimension(:,:  )      :: WindShearVelocity
        real,    pointer, dimension(:,:  )      :: NonSolarRadiation
        real,    pointer, dimension(:,:  )      :: SurfaceRadiation
    end type T_ExtSurface

   type       T_SeagrassesLeaves
        type(T_PropertyID)                      :: ID
        real,    pointer, dimension(:,:  )      :: Biomass     !kgC/m2
        real,    pointer, dimension(:,:  )      :: Length
        real,    pointer, dimension(:,:,:)      :: Occupation
        !real,    pointer, dimension(:,:,:)      :: DistFromTop
        real,    pointer, dimension(:,:,:)      :: NintFactor3D
        real,    pointer, dimension(:,:  )      :: NintFactor2D
        real,    pointer, dimension(:,:,:)      :: PintFactor3D
        !real,    pointer, dimension(:,:,:)      :: SeagrassesL3D
        real,    pointer, dimension(:,:  )      :: PintFactor2D
        real,    pointer, dimension(:,:,:)      :: UptakeNH4NO3w3D
        real,    pointer, dimension(:,:,:)      :: UptakePO4w3D
        real,    pointer, dimension(:,:,:)      :: LightFactor3D
        real(8),    pointer, dimension(:,:,:)      :: Volume


        ! aggiungo il puntatore per i tassi: Me%SeagrassesLeaves%Rates(:,:)
        real                                    :: DefaultValue, LBRatio
    end type   T_SeagrassesLeaves

    private :: T_DDecomp
    type       T_DDecomp
        integer                                 :: MPI_ID           = FillValueInt
        logical                                 :: ON               = .true.
        logical                                 :: MasterOrSlave    = .false.
        type (T_Size2D)                         :: HaloMap
        type (T_Size2D)                         :: Mapping
        type (T_Size2D)                         :: Global
    end type T_DDecomp

    type      T_NoFlux
        integer, pointer, dimension(:,:,:)      :: U,V,W
        logical                                 :: ON
        real                                    :: RelaxTimeScaleLimit
    end type  T_NoFlux

    type      T_WaterProperties
        integer                                 :: InstanceID
        character(PathLength)                   :: ModelName
        type(T_Size3D   )                       :: Size
        type(T_Size3D   )                       :: WorkSize
        type(T_Files    )                       :: Files
        type(T_Coupled  )                       :: Coupled
        type(T_Time     )                       :: BeginTime
        type(T_Time     )                       :: EndTime
        type(T_Time     )                       :: LastIteration
        type(T_Density  )                       :: Density
        type(T_SpecificHeat  )                  :: SpecificHeat
        type(T_Radiation)                       :: SolarRadiation
        type(T_External )                       :: ExternalVar
        type(T_ExtSurface )                     :: ExtSurface
        type(T_OutPut   )                       :: OutPut
        type(T_OutW     )                       :: OutW
        type(T_SmallDepths)                     :: SmallDepths
        logical                                 :: FreeConvection
        type(T_Property), pointer               :: FirstProperty
        type(T_Property), pointer               :: LastProperty
        type(T_WqRate), pointer                 :: FirstWQrate
        type(T_WqRate), pointer                 :: LastWQrate
        type(T_DischargeTimeSerie), pointer     :: FirstDischargeTimeSerie
        type(T_Age)                             :: Age
        type(T_MacroAlgae)                      :: MacroAlgae
        type(T_SeagrassesLeaves)                :: SeagrassesLeaves
        type(T_Bivalve)                         :: Bivalve
        type(T_Discharge)                       :: Discharge
        type(T_HybridWeights)                   :: HybridWeights
        type(T_NoFlux       )                   :: NoFlux
        type(T_ChemLinks    )                   :: ChemLinks
        type(T_DDecomp      )                   :: DDecomp
        integer                                 :: PropertiesNumber         = 0
        integer                                 :: WQratesNumber            = 0
        integer                                 :: DoSatType
        real                                    :: Altitude
        real(8), pointer, dimension(:,:,:)      :: MassFluxesX
        real(8), pointer, dimension(:,:,:)      :: MassFluxesY
        real(8), pointer, dimension(:,:,:)      :: MassFluxesZ
        real(8), pointer, dimension(:,:,:)      :: CellMass

        logical                                 :: FirstIteration   = .true.
        logical                                 :: Start2way        = .false.
        logical                                 :: WriteHDFReal4    = .true.
        logical                                 :: OxygenSaturation = .false.
        logical                                 :: CO2_PP_Output    = .false.
        logical                                 :: O2_Sat_Output    = .false.
        logical                                 :: CHLA_WQ_Output   = .false.
        real(8)                                 :: C_CHLA_Output

        integer                                 :: MaxThreads

        logical                                 :: TempFirstTimeWarning  = .false.

        logical                                 :: MustStartPhreeqC = .true.
        logical                                 :: PhreeqCOnlyForStart = .false.

        logical                                 :: Continuous = .false.
        logical                                 :: Optimize   = .false.

        integer                                 :: Docycle_method = 1

#ifdef _USE_SEQASSIMILATION
        integer, pointer, dimension(:)          :: PropertiesID
        logical                                 :: RunSeqAssimilation       = .false.
        logical                                 :: VirtualRun
#endif _USE_SEQASSIMILATION

#ifdef  OVERLAP
        logical                                 :: Overlap                  = .false.
#endif  OVERLAP

        !Instance of ModuleHDF5
        integer                                 :: ObjHDF5                  = 0

        !Instance of ModuleHDF5
        integer                                 :: ObjSurfaceHDF5           = 0

        !Instance of ModuleTimeSerie
        integer                                 :: ObjTimeSerie             = 0

        !Instance of ModuleProfile
        integer                                 :: ObjProfile               = 0

        !Instance of Module_EnterData
        integer                                 :: ObjEnterData             = 0

        !Instance of ModuleGridData
        integer                                 :: ObjGridData              = 0

        !Instance of ModuleHorizontalGrid
        integer                                 :: ObjHorizontalGrid        = 0

        !Instance of ModuleGeometry
        integer                                 :: ObjGeometry              = 0

        !Instance of ModuleHorizontalMap
        integer                                 :: ObjHorizontalMap         = 0

        !Instance of ModuleMap
        integer                                 :: ObjMap                   = 0

        !Instance of ModuleHydrodynamic
        integer                                 :: ObjHydrodynamic          = 0

        !Instance of ModuleTurbulence
        integer                                 :: ObjTurbulence            = 0

        !Instance of ModuleTime
        integer                                 :: ObjTime                  = 0

        !Instance of ModuleTime
        integer                                 :: ObjLightExtinction       = 0

        !Instance of ModuleAdvectionDiffusion
        integer                                 :: ObjAdvectionDiffusion    = 0

        !Instance of ModuleFreeVerticalMovement
        integer                                 :: ObjFreeVerticalMovement  = 0

        !Instance of ModuleTurbGOTM
        integer                                 :: ObjTurbGOTM              = 0

        !Instance of ModuleInterface
        integer                                 :: ObjInterface             = 0

        !Instance of ModuleInterfaceMacroAlgae
        integer                                 :: ObjInterfaceMacroAlgae   = 0

        !Instance of ModuleInterfaceBivalve
        integer                                 :: ObjInterfaceBivalve      = 0

        !Instance of ModuleBivalve
        integer                                 :: ObjBivalve               = 0

        !Instance of ModuleDischarges
        integer                                 :: ObjDischarges            = 0

        !Instance of ModuleBoxDif
        integer                                 :: ObjBoxDif                = 0

        !Instance of ModuleHydroIntegration
        integer                                 :: ObjHydroIntegration      = 0

        !Instance of ModuleAssimilation
        integer                                 :: ObjAssimilation          = 0

        !Instance of ModuleSeagrassWaterInteraction
        integer                                 :: ObjSeagrassWaterInteraction  = 0

        !Instance of TwoWay
        integer                                 :: ObjTwoWay                = 0

#ifdef _ENABLE_CUDA
        integer                                 :: ObjCuda                  = 0
#endif _ENABLE_CUDA

        !Collection of instances
        type(T_WaterProperties), pointer        :: Next
        integer                :: WPFatherInstanceID

    end type T_WaterProperties

    !Global Module Variables
    type (T_WaterProperties), pointer           :: FirstObjWaterProperties
    type (T_WaterProperties), pointer           :: Me


    !--------------------------------------------------------------------------

    contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    subroutine Construct_WaterProperties(ModelName,                          &
                                         WaterPropertiesID,                  &
                                         GridDataID,                         &
                                         HorizontalGridID,                   &
                                         GeometryID,                         &
                                         HorizontalMapID,                    &
                                         MapID,                              &
                                         AssimilationID,                     &
                                         HydrodynamicID,                     &
                                         TurbulenceID,                       &
                                         TimeID,                             &
                                         DischargesID,                       &
                                         FreeVerticalMovementID,             &
                                         TurbGOTMID,                         &
                                         TwoWayID,                           &
                                         Docycle_method,                     &
#ifdef _ENABLE_CUDA
                                         CudaID,                             &
#endif
                                        STAT)

        !Arguments-------------------------------------------------------------
        character(Len=*)                            :: ModelName
        integer                                     :: WaterPropertiesID
        integer                                     :: GridDataID
        integer                                     :: HorizontalGridID
        integer                                     :: GeometryID
        integer                                     :: HorizontalMapID
        integer                                     :: MapID
        integer                                     :: HydrodynamicID
        integer                                     :: TimeID
        integer                                     :: TurbulenceID
        integer                                     :: AssimilationID
        integer                                     :: DischargesID
        integer                                     :: FreeVerticalMovementID
        integer                                     :: TurbGOTMID
        integer                                     :: TwoWayID
        integer                                     :: Docycle_method
#ifdef _ENABLE_CUDA
        integer                                     :: CudaID
#endif
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_, iW

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        !Assures nullification of the global variable
        if (.not. ModuleIsRegistered(mWaterProperties_)) then
            nullify (FirstObjWaterProperties)
            call RegisterModule (mWaterProperties_)
        endif

        call Ready(WaterPropertiesID, ready_)

cd0 :   if (ready_ .EQ. OFF_ERR_) then

            !Allocates a new Instance
            call AllocateInstance

            Me%MaxThreads = openmp_num_threads
            Me%ModelName = ModelName

            nullify (Me%FirstProperty)
            nullify (Me%LastProperty)
            nullify (Me%FirstWQrate)
            nullify (Me%LastWQrate)
            nullify (Me%FirstDischargeTimeSerie)

            Me%ObjTime           = AssociateInstance (mTIME_,           TimeID          )
            Me%ObjGridData       = AssociateInstance (mGRIDDATA_,       GridDataID      )
            Me%ObjHorizontalMap  = AssociateInstance (mHORIZONTALMAP_,  HorizontalMapID )
            Me%ObjHorizontalGrid = AssociateInstance (mHORIZONTALGRID_, HorizontalGridID)
            Me%ObjGeometry       = AssociateInstance (mGEOMETRY_,       GeometryID      )
            Me%ObjMap            = AssociateInstance (mMAP_,            MapID           )
            Me%ObjHydrodynamic   = AssociateInstance (mHYDRODYNAMIC_,   HydrodynamicID  )
            Me%ObjTurbulence     = AssociateInstance (mTURBULENCE_,     TurbulenceID    )
            Me%ObjTwoWay         = AssociateInstance (mTwoWay_,         TwoWayID        )
            ! guillaume nogueira
!            Me%ObjAssimilation   = AssociateInstance (mASSIMILATION_,     AssimilationID  )
#ifdef _ENABLE_CUDA
            Me%ObjCuda           = AssociateInstance (mCUDA_,           CudaID          )
#endif

            if(TurbGOTMID /= 0)then
                Me%ObjTurbGOTM       = AssociateInstance (mTURBGOTM_,       TurbGOTMID    )
            endif

            Me%Docycle_method = Docycle_method

            call ReadLockExternalVar

            ! Construct the variable common to all module
            call Construct_GlobalVariables

            !Construct enter data
            call ConstructEnterData(Me%ObjEnterData, Me%Files%ConstructData, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) &
                call CloseAllAndStop ('Construct_WaterProperties - ModuleWaterProperties - ERR01')

            call ReadConfiguration

            !Construct the variables necessary to impose
            !a no flux condition in the model interior
            call ConstructNoFluxInterior

#ifdef _USE_SEQASSIMILATION
            call ConstructBooleanSeqAssimilation
#endif _USE_SEQASSIMILATION

            !Constructs the property list
            call Construct_PropertyList

            call ConstructChemLinks

            !Constructs the list of WQRates
            call Construct_WQRateList

            !Construct Density
            call ConstructDensity

            !Construct Specific Heat of water
            call ConstructSpecificHeat

            !Initialize oxygen to saturation.
            if (Me%OxygenSaturation)                          &
                call ModifyOxygenSaturation

            call ConstructGlobalOutput

            if (Me%OutPut%Yes)            call Open_HDF5_OutPut_File

            if (Me%OutW%OutPutWindowsON)  then
                do iW = 1, Me%OutW%WindowsNumber
                    call Open_HDF5_OutPut_File(iW)
                enddo
            endif

            if (Me%OutPut%SurfaceOutputs) call Open_Surface_HDF5_OutPut_File

            call ConstructDoSat

            !Constructs if the user wants to assimilate altimetry ! guillaume nogueira
            call ConstructBooleanAltimAssim


            !Construct the Sub-Modules
#ifdef _ENABLE_CUDA
            ! CudaID is needed for thomas algorithm in ModuleAdvectionDiffusion
            call Construct_Sub_Modules(AssimilationID, DischargesID, CudaID)
#else
            call Construct_Sub_Modules(AssimilationID, DischargesID)
#endif _ENABLE_CUDA

            FreeVerticalMovementID = Me%ObjFreeVerticalMovement

            !Message to user
            call ConstructLog

            !Write the first output
            if(Me%OutPut%Yes)            call OutPut_Results_HDF

            if (Me%OutW%OutPutWindowsON)  then

                do iW = 1, Me%OutW%WindowsNumber
                    if (Me%OutW%OutPutWindows(iW)%ON) then
                        call OutPut_Results_HDF(iW)
                    endif
                enddo

            endif

            !Write the first surface output
            if(Me%OutPut%SurfaceOutputs) call OutPut_SurfaceResults_HDF

#ifdef OVERLAP
            call ConstructWaterOverlap
#endif OVERLAP


            call KillEnterData(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) &
                call CloseAllAndStop ('Construct_WaterProperties - ModuleWaterProperties - ERR02')

            call ReadUnlockExternalVar


            !Returns ID
            WaterPropertiesID = Me%InstanceID
            STAT_             = SUCCESS_


        else

            call CloseAllAndStop ('Construct_WaterProperties - ModuleWaterProperties - ERR99')

        end if cd0

        if (present(STAT)) STAT = STAT_


    end subroutine Construct_WaterProperties

    !--------------------------------------------------------------------------

    subroutine AllocateInstance

        !Local-----------------------------------------------------------------
        type (T_WaterProperties), pointer           :: NewWaterProperties
        type (T_WaterProperties), pointer           :: PreviousWaterProperties

        !Allocates new instance
        allocate (NewWaterProperties)
        nullify  (NewWaterProperties%Next)

        !Insert New Instance into list and makes Current point to it
        if (.not. associated(FirstObjWaterProperties)) then
            FirstObjWaterProperties      => NewWaterProperties
            Me                           => NewWaterProperties
        else
            PreviousWaterProperties      => FirstObjWaterProperties
            Me                           => FirstObjWaterProperties%Next
            do while (associated(Me))
                PreviousWaterProperties  => Me
                Me                       => Me%Next
            enddo
            Me                           => NewWaterProperties
            PreviousWaterProperties%Next => NewWaterProperties
        endif

        Me%InstanceID = RegisterNewInstance (mWATERPROPERTIES_)


    end subroutine AllocateInstance

    !--------------------------------------------------------------------------

    subroutine StartOutputBoxFluxes

        !External--------------------------------------------------------------
        integer                                             :: iflag, STAT_CALL
        integer                                             :: ILB, IUB, JLB, JUB, KLB, KUB
        logical                                             :: Exist, Opened

        !Local-----------------------------------------------------------------
        type(T_Property),                           pointer :: PropertyX
        type(T_WQRate  ),                           pointer :: WQRateX
        character(len=StringLength), dimension(:),  pointer :: ScalarOutputList
        character(len=StringLength), dimension(:),  pointer :: FluxesOutputList
        integer                                             :: nScalars, nFluxes, n

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !<BeginKeyword>
            !Keyword          : BOXFLUXES
            !<BeginDescription>
            ! This keyword have two functions if exist fluxes between boxes are compute
            ! and the value read is the name file where the boxes are defined
            !
            !<EndDescription>
            !Type             : Character
            !Default          : Do not have
            !File keyword     : SEDPROP
            !Multiple Options : Do not have
            !Search Type      : From File
        !<EndKeyword>

        call GetData(Me%Files%BoxesFile,                                            &
                     Me%ObjEnterData, iflag,                                       &
                     keyword      = 'BOXFLUXES',                                    &
                     ClientModule = 'ModuleWaterProperties',                        &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR01')
        if (iflag .EQ. 0)                                                           &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR02')

        inquire(File = Me%Files%BoxesFile, Exist = exist)
        if (exist) then
            inquire(File = Me%Files%BoxesFile, Opened  = Opened)
            if (opened) then
                write(*,*    )
                write(*,'(A)') 'BoxesFile = ',trim(adjustl(Me%Files%BoxesFile))
                write(*,*    ) 'Already opened.'
                call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR03')
            end if
        else
            write(*,*)
            write(*,*)     'Could not find the boxes file.'
            write(*,'(A)') 'BoxFileName = ', Me%Files%BoxesFile
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR04')
        end if

        nScalars = Me%Coupled%BoxTimeSerie%NumberOfProperties + Me%WQRatesNumber
        nFluxes  = Me%Coupled%BoxTimeSerie%NumberOfProperties

        allocate(ScalarOutputList(nScalars), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR05')

        allocate(FluxesOutputList(nFluxes), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR06')

        PropertyX  => Me%FirstProperty
        n = 0
        do while (associated(PropertyX))
            if (PropertyX%BoxTimeSerie) then
                n = n + 1
                ScalarOutputList(n) = trim(PropertyX%ID%name)
                FluxesOutputList(n) = trim(PropertyX%ID%name)
            end if

            PropertyX=>PropertyX%Next
        end do

        WQRateX => Me%FirstWQRate
        do while(associated(WQRateX))
            n = n + 1
            ScalarOutputList(n) = trim(WQRateX%ID%name)
            WQRateX => WQRateX%Next
        end do

        call StartBoxDif(BoxDifID           = Me%ObjBoxDif,                 &
                         TimeID             = Me%ObjTime,                   &
                         HorizontalGridID   = Me%ObjHorizontalGrid,         &
                         BoxesFilePath      = Me%Files%BoxesFile,           &
                         FluxesOutputList   = FluxesOutputList,             &
                         ScalarOutputList   = ScalarOutputList,             &
                         WaterPoints3D      = Me%ExternalVar%WaterPoints3D, &
                         Size3D             = Me%Size,                      &
                         WorkSize3D         = Me%WorkSize,                  &
                         STAT               = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR07')

        call GetDTBoxes(Me%ObjBoxDif,Me%Coupled%BoxTimeSerie%DT_Compute, STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR60')

        deallocate(FluxesOutputList, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR08')

        deallocate(ScalarOutputList, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR07')

        allocate(Me%MassFluxesX(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR09')
        Me%MassFluxesX(:,:,:) = 0.

        allocate(Me%MassFluxesY(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR10')
        Me%MassFluxesY(:,:,:) = 0.

        allocate(Me%MassFluxesZ(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR11')
        Me%MassFluxesZ(:,:,:) = 0.

        allocate(Me%CellMass(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('StartOutputBoxFluxes - ModuleWaterProperties - ERR12')
        Me%CellMass(:,:,:) = 0.

    end subroutine StartOutputBoxFluxes


    !--------------------------------------------------------------------------

    subroutine Construct_GlobalVariables

        !External--------------------------------------------------------------
        integer :: STAT_CALL

        !----------------------------------------------------------------------

        !Initialize the water properties number
        Me%PropertiesNumber = 0

        !Initialize the water properties list
        nullify (Me%FirstProperty)
        nullify (Me%LastProperty )

        !Nullify Density, SPM and top face radiation fields
        nullify(Me%Density%Field)
        nullify(Me%SolarRadiation%ShortWaveTop    )
        nullify(Me%SolarRadiation%ShortWaveAverage)
        nullify(Me%SolarRadiation%LongWaveTop     )

        call ConstructDDecomp

        call GetGeometrySize(Me%ObjGeometry,                &
                             Size     = Me%Size,            &
                             WorkSize = Me%WorkSize,        &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                          &
            call CloseAllAndStop ('Construct_GlobalVariables - ModuleWaterProperties - ERR10')

        call GetComputeTimeLimits(Me%ObjTime,               &
                                  EndTime   = Me%EndTime,   &
                                  BeginTime = Me%BeginTime, &
                                  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                          &
            call CloseAllAndStop ('Construct_GlobalVariables - ModuleWaterProperties - ERR20')

        !Actualize the time
        call GetComputeCurrentTime(Me%ObjTime, Me%ExternalVar%Now, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                          &
            call CloseAllAndStop ('Construct_GlobalVariables - ModuleWaterProperties - ERR30')

        ! Check if the simulation goes backward in time or forward in time (default mode)
        call GetBackTracking(Me%ObjTime, Me%ExternalVar%BackTracking, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                          &
            call CloseAllAndStop ('Construct_GlobalVariables - ModuleWaterProperties - ERR40')

        ! read the name of the files need to construct and modify
        ! the water properties
        call Read_WaterProperties_Files_Name

        call GetVertical1D (Me%ObjHydrodynamic, Vertical1D = Me%ExternalVar%Vertical1D, STAT= STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                          &
            call CloseAllAndStop ('Construct_GlobalVariables - ModuleWaterProperties - ERR50')

        call GetXZFlow (Me%ObjHydrodynamic, XZFlow = Me%ExternalVar%XZFlow, STAT= STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                          &
            call CloseAllAndStop ('Construct_GlobalVariables - ModuleWaterProperties - ERR60')

    end subroutine Construct_GlobalVariables

    !--------------------------------------------------------------------------

    subroutine ReadConfiguration

        integer     :: iflag
        integer     :: status

        call GetData(Me%PhreeqCOnlyForStart,                    &
                     Me%ObjEnterData, iflag,                    &
                     SearchType   = FromFile,                   &
                     keyword      = 'PHREEQC_ONLY_START',       &
                     default      = .false.,                    &
                     ClientModule = 'ModuleWaterProperties',    &
                     STAT         = status)
        if (status /= SUCCESS_) &
            call CloseAllAndStop ('ReadConfiguration - ModuleWaterProperties - ERR10')

        call GetData(Me%Continuous,                             &
                     Me%ObjEnterData, iflag,                    &
                     SearchType   = FromFile,                   &
                     keyword      = 'CONTINUOUS',               &
                     default      = .false.,                    &
                     ClientModule = 'ModuleWaterProperties',    &
                     STAT         = status)
        if (status /= SUCCESS_) &
            call CloseAllAndStop ('ReadConfiguration - ModuleWaterProperties - ERR10')

        if (Me%Continuous) Me%MustStartPhreeqC = .false.

    end subroutine ReadConfiguration

    !--------------------------------------------------------------------------

    subroutine ConstructChemLinks

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                         :: client
        logical                                         :: found
        integer                                         :: status
        integer                                         :: index
        type(T_ChemLink), pointer                       :: ptr

        !----------------------------------------------------------------------

        call GetNumberOfBlocks (Me%ObjEnterData,           &
                                '<beginchemlink>',         &
                                '<endchemlink>',           &
                                FromFile_,                 &
                                Me%ChemLinks%NumberOfLinks,&
                                STAT = status)
        if (status /= SUCCESS_) &
            call CloseAllAndStop ('ConstructChemLinks - ModuleWaterProperties - ERR010')

        allocate (Me%ChemLinks%Links (1:Me%ChemLinks%NumberOfLinks))

        if (Me%ChemLinks%NumberOfLinks > 0) then
            Me%ChemLinks%Coupled = .true.

            do index = 1, Me%ChemLinks%NumberOfLinks

                call ExtractBlockFromBuffer(Me%ObjEnterData,                      &
                                            ClientNumber = client,                &
                                            block_begin  = '<beginchemlink>',     &
                                            block_end    = '<endchemlink>',       &
                                            BlockFound   = found,                 &
                                            STAT         = status)
                if (status /= SUCCESS_) &
                    call CloseAllAndStop ('ConstructChemLinks - ModuleWaterProperties - ERR020')

                if (found) then

                    ptr => Me%ChemLinks%Links(index)
                    call ReadChemLink (ptr, client)

                else

                    call CloseAllAndStop ('ConstructChemLinks - ModuleWaterProperties - ERR030')

                endif

            enddo

            call Block_Unlock(Me%ObjEnterData, client, status)
            if (status .NE. SUCCESS_) &
                call CloseAllAndStop ('ConstructChemLinks - ModuleWaterProperties - ERR040')

            call RewindBuffer(Me%ObjEnterData, STAT = status)
            if (status /= SUCCESS_) &
                call CloseAllAndStop ('ConstructChemLinks - ModuleWaterProperties - ERR050.')

        endif

    end subroutine ConstructChemLinks

    !--------------------------------------------------------------------------

    subroutine ReadChemLink (link, client)

        !Arguments-------------------------------------------------------------
        type (T_ChemLink), pointer                      :: link
        integer                                         :: client

        !Local-----------------------------------------------------------------
        logical                                         :: found
        integer                                         :: status
        integer                                         :: index
        character(StringLength)                         :: item
        type (T_Property), pointer                      :: property
        integer                                         :: iflag
        integer                                         :: first
        integer                                         :: last
        integer                                         :: l
        integer                                         :: n_atoms_l
        integer                                         :: item_int

        !----------------------------------------------------------------------

        call GetData(item,                                      &
                     Me%ObjEnterData, iflag,                    &
                     SearchType   = FromBlock,                  &
                     keyword      = 'SPECIES',                  &
                     ClientModule = 'ModuleWaterProperties',    &
                     STAT         = status)
        if (status /= SUCCESS_) &
            call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR10')

        if (WaterPropertyID (item, property = property) /= SUCCESS_) &
            call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR20')

        if (property%GFW <= 0.0) &
            call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR30')

        link%Species => property

        call ExtractBlockFromBlock (Me%ObjEnterData, client,        &
                                    '<<begincomp>>', '<<endcomp>>', &
                                    found, first, last,             &
                                    STAT = status)
        if (status /= SUCCESS_) &
            call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR040')

        if (.not. found) &
            call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR050')

        link%NumberOfComponents = (last - first - 1) / 2

        if (link%NumberOfComponents <= 0) &
            call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR060')

        allocate (link%Components (1:link%NumberOfComponents))

        index = 0
        do l = first + 1, last - 1, 2

            index = index + 1

            call GetData(item,                                      &
                         Me%ObjEnterData, iflag,                    &
                         Buffer_Line  = l,                          &
                         ClientModule = 'ModuleWaterProperties',    &
                         STAT         = status)
            if (status /= SUCCESS_) &
                call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR070')

            if (WaterPropertyID (item, property = property) /= SUCCESS_) &
                call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR80')

            if (property%GFW <= 0.0) &
                call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR90')

            n_atoms_l = l + 1

            call GetData(item_int,                                  &
                         Me%ObjEnterData, iflag,                    &
                         Buffer_Line  = n_atoms_l,                  &
                         ClientModule = 'ModuleWaterProperties',    &
                         STAT         = status)
            if (status /= SUCCESS_) &
                call CloseAllAndStop ('ReadChemLink - ModuleWaterProperties - ERR100')

            link%Components(index)%NumberOfAtoms = item_int
            link%Components(index)%Property => property

        enddo

        call RewindBlock(Me%ObjEnterData, client, STAT = status)
        if (status /= SUCCESS_) &
            call CloseAllAndStop ('ModuleEnterData - GetNumberOfBlocks - ERR110.')

    end subroutine ReadChemLink

    !--------------------------------------------------------------------------

    subroutine ConstructDDecomp

        !Local-----------------------------------------------------------------
        integer :: STAT_CALL

        !----------------------------------------------------------------------

        call GetDDecompParameters(HorizontalGridID = Me%ObjHorizontalGrid,              &
                                  MasterOrSlave    = Me%DDecomp%MasterOrSlave,          &
                                  Global           = Me%DDecomp%Global,                 &
                                  STAT             = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructDDecomp - ModuleWaterProperties - ERR10')


ifMS:   if (Me%DDecomp%MasterOrSlave) then

            call GetDDecompWorkSize2D(HorizontalGridID = Me%ObjHorizontalGrid,          &
                                      WorkSize         = Me%DDecomp%HaloMap,            &
                                      STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructDDecomp - ModuleWaterProperties - ERR20')

            call GetDDecompMapping2D(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                     Mapping2D        = Me%DDecomp%Mapping,             &
                                     STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructDDecomp - ModuleWaterProperties - ERR30')

            Me%DDecomp%MPI_ID = GetDDecompMPI_ID(Me%ObjHorizontalGrid)

            Me%DDecomp%ON     = GetDDecompON    (Me%ObjHorizontalGrid)

        endif ifMS

    end subroutine ConstructDDecomp


    !--------------------------------------------------------------------------


    subroutine Construct_PropertyList

        !External----------------------------------------------------------------
        integer                         :: ClientNumber
        integer                         :: STAT_CALL
        logical                         :: BlockFound

        !Local-------------------------------------------------------------------
        type (T_Property), pointer      :: NewProperty

        !------------------------------------------------------------------------

do1 :   do
            call ExtractBlockFromBuffer(Me%ObjEnterData,                        &
                                        ClientNumber    = ClientNumber,         &
                                        block_begin     = prop_block_begin,     &
                                        block_end       = prop_block_end,       &
                                        BlockFound      = BlockFound,           &
                                        STAT            = STAT_CALL)
cd1 :       if      (STAT_CALL .EQ. SUCCESS_     ) then
cd2 :           if (BlockFound) then

                    !Construct a New Property
                    call Construct_Property(NewProperty,ClientNumber)

                    !Add new Property to the WaterProperties List
                    call Add_Property(NewProperty)

                else cd2

                    call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

                    if (STAT_CALL .NE. SUCCESS_)                                &
                        call CloseAllAndStop ('Construct_PropertyList - ModuleWaterProperties - ERR01')

                    exit do1    !No more blocks
                end if cd2

            else if (STAT_CALL .EQ. BLOCK_END_ERR_) then cd1
                write(*,*)
                write(*,*) 'Error calling ExtractBlockFromBuffer. '
                call CloseAllAndStop ('Construct_PropertyList - ModuleWaterProperties - ERR02')
            else cd1
                call CloseAllAndStop ('Construct_PropertyList - ModuleWaterProperties - ERR03')
            end if cd1
        end do do1

    end subroutine Construct_PropertyList

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    subroutine ConstructSpeciesList

        !Local-----------------------------------------------------------------
        type (T_Species),      pointer              :: NewSpecies
        integer                                     :: ClientNumber, STAT_CALL
        logical                                     :: BlockFound

        !Begin-----------------------------------------------------------------

do1 :   do
            call ExtractBlockFromBuffer(Me%ObjEnterData,                        &
                                        ClientNumber    = ClientNumber,         &
                                        block_begin     = '<begin_species>',    &
                                        block_end       = '<end_species>',      &
                                        BlockFound      = BlockFound,           &
                                        STAT            = STAT_CALL)
cd1 :       if(STAT_CALL .EQ. SUCCESS_)then
cd2 :           if (BlockFound) then

                    call AddSpecies         (NewSpecies)

                    call ConstructSpecies   (NewSpecies, ClientNumber)

                    nullify(NewSpecies)

                else cd2
                    call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

                    if (STAT_CALL .NE. SUCCESS_)                                &
                        call CloseAllAndStop ('ConstructSpeciesList - ModuleWaterProperties - ERR01')

                    exit do1
                end if cd2

            else if (STAT_CALL .EQ. BLOCK_END_ERR_) then cd1
                write(*,*)
                write(*,*) 'Error calling ExtractBlockFromBuffer. '
                    call CloseAllAndStop ('ConstructSpeciesList - ModuleWaterProperties - ERR02')
            else cd1
                    call CloseAllAndStop ('ConstructSpeciesList - ModuleWaterProperties - ERR03')
            end if cd1
        end do do1

    end subroutine ConstructSpeciesList

    !--------------------------------------------------------------------------

    subroutine AddSpecies (ObjSpecies)

        !Arguments-------------------------------------------------------------
        type (T_Species),      pointer              :: ObjSpecies
        !Local-----------------------------------------------------------------
        type (T_Species),      pointer              :: PreviousSpecies
        type (T_Species),      pointer              :: NewSpecies
        integer, save                               :: NextSpeciesID = 1

        !Allocates new Species
        allocate (NewSpecies)
        nullify  (NewSpecies%Next)

        !Insert new Species into list and makes current algae point to it
        if (.not. associated(Me%Bivalve%FirstSpecies)) then
            Me%Bivalve%FirstSpecies    => NewSpecies
            ObjSpecies                 => NewSpecies
        else
            PreviousSpecies            => Me%Bivalve%FirstSpecies
            ObjSpecies                 => Me%Bivalve%FirstSpecies%Next

            do while (associated(ObjSpecies))
                PreviousSpecies        => ObjSpecies
                ObjSpecies             => ObjSpecies%Next
            enddo
            ObjSpecies                 => NewSpecies
            PreviousSpecies%Next       => NewSpecies
        endif

        !Attributes ID
        ObjSpecies%ID%ID               = NextSpeciesID

        NextSpeciesID                  = NextSpeciesID + 1

        Me%Bivalve%nSpecies            = Me%Bivalve%nSpecies + 1

    end subroutine AddSpecies

    !--------------------------------------------------------------------------

    subroutine ConstructSpecies (NewSpecies, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Species),      pointer              :: NewSpecies
        integer                                     :: ClientNumber

        !External--------------------------------------------------------------
        integer                                     :: iflag, STAT_CALL
        real                                        :: ModelDT

        !Local-----------------------------------------------------------------
        real, pointer, dimension(:)                 :: LocalSizeClasses
        integer                                     :: iClass
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        character(len=StringLength)                 :: AuxChar1, AuxChar2

        !Begin-----------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        call GetData(NewSpecies%ID%Name,                                      &
                     Me%ObjEnterData, iflag,                                  &
                     SearchType   = FromBlock,                                &
                     keyword      = 'NAME',                                   &
                     ClientModule = 'ModuleWaterProperties',                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR01')

        if(.not. Checkpropertyname(trim(NewSpecies%ID%Name), NewSpecies%ID%IDNumber))then
            write(*,*)trim(NewSpecies%ID%Name)
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR10')
        end if

        call GetData(NewSpecies%ID%Units,                                      &
                     Me%ObjEnterData, iflag,                                  &
                     SearchType   = FromBlock,                                &
                     keyword      = 'UNITS',                                   &
                     ClientModule = 'ModuleWaterProperties',                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR20')

        call GetData(NewSpecies%Old,                                          &
                     Me%ObjEnterData,iflag,                                   &
                     SearchType     = FromBlock,                              &
                     keyword        = 'OLD',                                  &
                     Default        = .false.,                                &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR30')

        call GetData(NewSpecies%WarnOnNegativeValues,                         &
                     Me%ObjEnterData,iflag,                                   &
                     SearchType     = FromBlock,                              &
                     keyword        = 'WARN_ON_NEGATIVE_VALUES',              &
                     Default        = .false.,                                &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR40')


        call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR50')

        call GetData(NewSpecies%DTInterval,                                   &
                     Me%ObjEnterData,iflag,                                   &
                     SearchType     = FromBlock,                              &
                     keyword        = 'DT_INTERVAL',                          &
                     Default        = ModelDT,                                &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR60')

        call GetData(NewSpecies%CohortOutputHDF,                              &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword        = 'COHORT_OUTPUT_HDF',                    &
                     Default        = .false.,                                &
                     SearchType     = FromBlock,                              &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR70')

        call GetData(NewSpecies%CohortBoxTimeSerie,                           &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword        = 'COHORT_BOX_TIME_SERIE',                &
                     Default        = .false.,                                &
                     SearchType     = FromBlock,                              &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR90')

        call GetData(NewSpecies%CohortStatistics,                             &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword        = 'COHORT_STATISTICS',                    &
                     Default        = .false.,                                &
                     SearchType     = FromBlock,                              &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR100')

        if (NewSpecies%CohortStatistics) then

            call GetData(NewSpecies%CohortStatisticsFile,                     &
                 Me%ObjEnterData, iflag,                                      &
                 Keyword        = 'COHORT_STATISTICS_FILE',                   &
                 SearchType     = FromBlock,                                  &
                 ClientModule   = 'ModuleWaterProperties',                    &
                 STAT           = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                      &
                call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR110')
        endif

        call GetData(NewSpecies%PopulationHDF,                                &
                     Me%ObjEnterData, iflag,                                  &
                     SearchType   = FromBlock,                                &
                     keyword      = 'POPULATION_OUTPUT_HDF',                  &
                     ClientModule = 'ModuleWaterProperties',                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR120')

        call GetData(NewSpecies%PopulationBoxTimeSerie,                       &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword        = 'POPULATION_BOX_TIME_SERIE',            &
                     Default        = .false.,                                &
                     SearchType     = FromBlock,                              &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR140')

        call GetData(NewSpecies%BySizeOutputHDF,                              &
                     Me%ObjEnterData, iflag,                                  &
                     SearchType   = FromBlock,                                &
                     keyword      = 'BYSIZE_OUTPUT_HDF',                      &
                     ClientModule = 'ModuleWaterProperties',                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR150')

        call GetData(NewSpecies%BySizeBoxTimeSerie,                           &
                     Me%ObjEnterData, iflag,                                  &
                     Keyword        = 'BYSIZE_BOX_TIME_SERIE',                &
                     Default        = .false.,                                &
                     SearchType     = FromBlock,                              &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR170')

        if(NewSpecies%BySizeOutputHDF .or. NewSpecies%BySizeBoxTimeSerie)then

            call GetData(NewSpecies%NumberSizeClasses,                            &
                         Me%ObjEnterData, iflag,                                  &
                         SearchType   = FromBlock,                                &
                         keyword      = 'NUMBER_SIZE_CLASSES',                    &
                         ClientModule = 'ModuleWaterProperties',                  &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                          &
                call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR180')

            if (iflag == 0) call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR190')

            allocate (NewSpecies%SizeClasses(NewSpecies%NumberSizeClasses))
            allocate (LocalSizeClasses(NewSpecies%NumberSizeClasses))

            call GetData(LocalSizeClasses,                                        &
                         Me%ObjEnterData, iflag,                                  &
                         SearchType   = FromBlock,                                &
                         keyword      = 'SIZE_CLASSES',                           &
                         ClientModule = 'ModuleWaterProperties',                  &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                          &
                call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR200')


            do iClass = 1, NewSpecies%NumberSizeClasses

                if(iClass .lt. NewSpecies%NumberSizeClasses)then
                    NewSpecies%SizeClasses(iClass)%Minimum = LocalSizeClasses(iClass)
                    NewSpecies%SizeClasses(iClass)%Maximum = LocalSizeClasses(iClass+1)
                else
                    NewSpecies%SizeClasses(iClass)%Minimum = LocalSizeClasses(iClass)
                    NewSpecies%SizeClasses(iClass)%Maximum = 50. !in cm
                endif

                allocate (NewSpecies%SizeClasses(iClass)%Density(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR210')

                write(AuxChar1, fmt=*)NewSpecies%SizeClasses(iClass)%Minimum
                write(AuxChar2, fmt=*)NewSpecies%SizeClasses(iClass)%Maximum

                NewSpecies%SizeClasses(iClass)%Name = trim(adjustl(AuxChar1))//"_"//trim(adjustl(AuxChar2))


            enddo

            deallocate (LocalSizeClasses)

        endif

        call GetData(NewSpecies%LarvaeTransport,                              &
                     Me%ObjEnterData,iflag,                                   &
                     SearchType     = FromBlock,                              &
                     keyword        = 'LARVAE_TRANSPORT',                     &
                     Default        = .false.,                                &
                     ClientModule   = 'ModuleWaterProperties',                &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('ConstructSpecies - ModuleWaterProperties - ERR220')

        if(NewSpecies%Old)then
            call ConstructCohortFromRestart(NewSpecies)
        else
            call ConstructCohortList(NewSpecies, ClientNumber)
        endif

        call ConstructSpeciesSettlement(NewSpecies, ClientNumber)

    end subroutine ConstructSpecies

    !--------------------------------------------------------------------------

    subroutine ConstructSpeciesSettlement(NewSpecies, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Species),      pointer              :: NewSpecies
        integer                                     :: ClientNumber

        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL

        !Local-----------------------------------------------------------------
        logical                                     :: BlockInBlockFound
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB

        !Begin-----------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        allocate(NewSpecies%SettlementProbability(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('ConstructSpeciesSettlement - ModuleWaterProperties - ERR10')

        NewSpecies%SettlementProbability(:,:,:) = FillValueReal

        call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,   &
                                   '<<begin_settlement>>',          &
                                   '<<end_settlement>>',            &
                                   BlockInBlockFound,               &
                                   STAT = STAT_CALL)

        if(STAT_CALL .EQ. SUCCESS_)then

            if (BlockInBlockFound) then

                call ConstructFillMatrix   (PropertyID           = NewSpecies%SettlementID,              &
                                            EnterDataID          = Me%ObjEnterData,                      &
                                            TimeID               = Me%ObjTime,                           &
                                            HorizontalGridID     = Me%ObjHorizontalGrid,                 &
                                            GeometryID           = Me%ObjGeometry,                       &
                                            ExtractType          = FromBlockInBlock,                     &
                                            PointsToFill3D       = Me%ExternalVar%WaterPoints3D,         &
                                            Matrix3D             = NewSpecies%SettlementProbability,     &
                                            TypeZUV              = TypeZ_,                               &
                                            ClientID             = ClientNumber,                         &
                                            STAT                 = STAT_CALL)
                 if (STAT_CALL /= SUCCESS_)                                                              &
                     call CloseAllAndStop ('ConstructSpeciesSettlement - ModuleWaterProperties - ERR20')

                 call KillFillMatrix(NewSpecies%SettlementID%ObjFillMatrix, STAT = STAT_CALL)
                 if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructSpeciesSettlement - ModuleWaterProperties - ERR30')
            else

                write(*,*)
                write(*,*)'Settlement probability set to 1.0'
                write(*,*)'Species : '//trim(adjustl(NewSpecies%ID%Name))
                write(*,*)

                NewSpecies%SettlementProbability = 1.0

            endif

        else

            call CloseAllAndStop ('ConstructSpeciesSettlement - ModuleWaterProperties - ERR40')

        endif

    end subroutine ConstructSpeciesSettlement

    !--------------------------------------------------------------------------

    subroutine ConstructCohortFromRestart(NewSpecies)

        !Arguments-------------------------------------------------------------
        type (T_Species),      pointer              :: NewSpecies

        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Cohort),      pointer               :: NewCohort
        logical                                     :: EXIST
        integer(4)                                  :: HDF5_READ
        integer                                     :: ObjHDF5 = 0, nProperties, iProp, ichar
        character(len=StringLength)                 :: PropertyName
        integer                                     :: PropertyNameLength, SpeciesNameLength
        character(len=10)                           :: NewCohortIDChar
        character(len=1)                            :: one_char
        integer                                     :: NewCohortID

        !Begin-----------------------------------------------------------------


        inquire (FILE=trim(Me%Files%InitialWaterProperties)//"5", EXIST = EXIST)

        if (EXIST) then

            !Gets File Access Code
            call GetHDF5FileAccess  (HDF5_READ = HDF5_READ)

            ObjHDF5 = 0

            !Opens HDF5 File
            call ConstructHDF5 (ObjHDF5,                                                 &
                                trim(Me%Files%InitialWaterProperties)//"5",&
                                HDF5_READ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructCohortFromRestart - ModuleWaterProperties - ERR01')

            call GetHDF5GroupNumberOfItems(ObjHDF5, "/Concentration", nProperties, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructCohortFromRestart - ModuleWaterProperties - ERR10')

            if(nProperties == 0)call CloseAllAndStop ('ConstructCohortFromRestart - ModuleWaterProperties - ERR20')

            SpeciesNameLength = len_trim(NewSpecies%ID%Name)

            iProp = 1

            do while(iProp < nProperties)

                call GetHDF5GroupID(ObjHDF5, "/Concentration", iProp, PropertyName, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('ConstructCohortFromRestart - ModuleWaterProperties - ERR10')

                PropertyNameLength = len_trim(PropertyName)

                if(PropertyNameLength > SpeciesNameLength)then

                    if(trim(PropertyName(1:SpeciesNameLength)) == trim(NewSpecies%ID%Name))then

                        do ichar = SpeciesNameLength+9, PropertyNameLength

                            one_char = PropertyName(ichar:ichar)

                            if(one_char == space)then
                                NewCohortIDChar = trim(PropertyName(SpeciesNameLength+9:ichar-1))

                                read(NewCohortIDChar,*) NewCohortID

                                allocate(NewCohort)

                                call AddCohort(NewSpecies, NewCohort, NewCohortID)

                                call ConstructCohort (NewSpecies, NewCohort)

                                nullify(NewCohort)

                                iProp = iProp + 7  !each cohort has 7 properties

                                exit
                            end if

                        end do

                    else

                        iProp = iProp + 1

                    endif

                else

                    iProp = iProp + 1

                endif

            enddo

            call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ConstructCohortFromRestart - ModuleWaterProperties - ERR100')

        elseif(.not. EXIST)then

            write(*,*)
            write(*,*)"Could not find the following hdf5 file: "
            write(*,*)trim(Me%Files%InitialWaterProperties)//"5"
            write(*,*)"This model is trying to access this file to"
            write(*,*)"continue calculation of bivalve cohorts from: "
            write(*,*)trim(NewSpecies%ID%Name)
            write(*,*)"Please see and correct keyword EUL_INI in nomfich.dat file."
            call CloseAllAndStop ('ConstructCohortFromRestart - ModuleWaterProperties - ERR100')

        endif

    end subroutine ConstructCohortFromRestart

    !--------------------------------------------------------------------------

    subroutine ConstructCohortList(NewSpecies, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Species),      pointer              :: NewSpecies
        integer                                     :: ClientNumber

        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                                     :: FirstLine, LastLine
        logical                                     :: BlockInBlockFound
        type (T_Cohort),      pointer               :: NewCohort

        !Begin-----------------------------------------------------------------

    do1 :   do
            call ExtractBlockFromBlock(Me%ObjEnterData                          ,&
                                        ClientNumber      = ClientNumber        ,&
                                        block_begin       = '<<begin_cohort>>'  ,&
                                        block_end         = '<<end_cohort>>'    ,&
                                        BlockInBlockFound = BlockInBlockFound   ,&
                                        FirstLine         = FirstLine           ,&
                                        LastLine          = LastLine            ,&
                                        STAT              = STAT_CALL)

cd1 :       if(STAT_CALL .EQ. SUCCESS_)then
cd2 :           if (BlockInBlockFound) then

                    allocate(NewCohort)

                    call AddCohort       (NewSpecies, NewCohort)

                    call ConstructCohort (NewSpecies, NewCohort)

                    nullify(NewCohort)

                else cd2

                    exit do1
                end if cd2

            else if (STAT_CALL .EQ. BLOCK_END_ERR_) then cd1
                write(*,*)
                write(*,*) 'Error calling ExtractBlockFromBuffer. '
                    call CloseAllAndStop ('Subroutine ConstructCohortList - ModuleWaterProperties - ERR01')
            else cd1
                    call CloseAllAndStop ('Subroutine ConstructCohortList - ModuleWaterProperties - ERR10')
            end if cd1
        end do do1

    end subroutine ConstructCohortList

    !-------------------------------------------------------------------------------

    subroutine AddCohort (Species, NewCohort, ID)

        !Arguments-------------------------------------------------------------
        type (T_Species),            pointer            :: Species
        type (T_Cohort) ,            pointer            :: NewCohort
        integer, optional                               :: ID

        !Local-----------------------------------------------------------------
        type (T_Cohort),            pointer             :: ObjCohort

        nullify  (NewCohort%Next)

cd1:    if (.not. associated(Species%FirstCohort)) then
            Species%FirstCohort            => NewCohort
        else

            ObjCohort => Species%FirstCohort

do1:        do while (associated(ObjCohort%Next))

                ObjCohort => ObjCohort%Next
            enddo do1

            ObjCohort%Next => NewCohort
        endif cd1

        !Attributes ID
        if(present(ID))then
            NewCohort%ID%ID        = ID
        else
            NewCohort%ID%ID        = Species%LastCohortID + 1
        endif

        Species%LastCohortID       = NewCohort%ID%ID
        Species%nCohorts           = Species%nCohorts + 1

    end subroutine AddCohort

    !----------------------------------------------------------------------------

    subroutine ConstructCohort(Species, NewCohort)

        !Arguments-------------------------------------------------------------
        type(T_Species), pointer            :: Species
        type(T_Cohort), pointer             :: NewCohort

        !Local-----------------------------------------------------------------
        type(T_Property), pointer           :: NewProperty
!        character(LEN = StringLength)       :: CohortPropName
        character(len=5)                    :: CohortIDStr
        integer                             :: MassConservation

        !Begin-----------------------------------------------------------------

        if (Species%LarvaeTransport) then
            call AllocateAuxLarvae(NewCohort)
        end if

        !Cohorts Name
        write(CohortIDStr, ('(i5)'))NewCohort%ID%ID

        NewCohort%ID%Name = trim(adjustl(Species%ID%Name))//" cohort "//trim(adjustl(CohortIDStr))

        write(*,*)trim(adjustl(NewCohort%ID%Name))


        !generate property length
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" length",    &
                                       IsDynamic        = .true.,                                        &
                                       IsParticulate    = .false.,                                        &
                                       IsAngle          = .false.,                                        &
                                       IsVectorial      = .false.,                                        &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'LENGTH')

        !CohortPropName      = 'LENGTH'
        !NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" length"
        !call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property structure
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                    &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" structure",    &
                                       IsDynamic        = .true.,                                            &
                                       IsParticulate    = .false.,                                            &
                                       IsAngle          = .false.,                                            &
                                       IsVectorial      = .false.,                                            &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'STRUCTURE')

        !CohortPropName      = 'STRUCTURE'
        !NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" structure"
        !call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property reserves
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                    &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" reserves",    &
                                       IsDynamic        = .true.,                                            &
                                       IsParticulate    = .false.,                                            &
                                       IsAngle          = .false.,                                            &
                                       IsVectorial      = .false.,                                            &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'RESERVES')

        !CohortPropName      = 'RESERVES'
        !NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" reserves"
        !call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property maturity
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                    &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" maturity",    &
                                       IsDynamic        = .true.,                                            &
                                       IsParticulate    = .false.,                                            &
                                       IsAngle          = .false.,                                            &
                                       IsVectorial      = .false.,                                            &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'MATURITY')

!~         CohortPropName      = 'MATURITY'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" maturity"
!~         call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property reproduction
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                        &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" reproduction",    &
                                       IsDynamic        = .true.,                                                &
                                       IsParticulate    = .false.,                                                &
                                       IsAngle          = .false.,                                                &
                                       IsVectorial      = .false.,                                                &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'REPRODUCTION')

!~         CohortPropName      = 'REPRODUCTION'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" reproduction"
!~         call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property age
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" age",        &
                                       IsDynamic        = .true.,                                        &
                                       IsParticulate    = .false.,                                        &
                                       IsAngle          = .false.,                                        &
                                       IsVectorial      = .false.,                                        &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'AGE')

!~         CohortPropName       = 'AGE'
!~         NewProperty%ID%Name  = trim(adjustl(NewCohort%ID%Name))//" age"
!~         call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))
        NewProperty%Evolution%AdvectionDiffusion  = .false. !age has no advection-diffusion

        nullify(NewProperty)

        !generate property number
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" number",    &
                                       IsDynamic        = .true.,                                        &
                                       IsParticulate    = .false.,                                        &
                                       IsAngle          = .false.,                                        &
                                       IsVectorial      = .false.,                                        &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromFile (NewProperty, Species, 'NUMBER')

!~         CohortPropName = 'NUMBER'
!~         NewProperty%ID%Name               = trim(adjustl(NewCohort%ID%Name))//" number"
!~         call Construct_CohortPropFromFile (NewProperty, Species, trim(CohortPropName))

        Me%Coupled%MinimumConcentration%Yes            = ON
        NewProperty%Evolution%MinConcentration         = ON
        NewProperty%MinValue                           = 0.0

        call GetBoundaryConditionList(MassConservation = MassConservation)

        NewProperty%Evolution%Advec_Difus_Parameters%DecayTime           = 1440.0
        NewProperty%Evolution%Advec_Difus_Parameters%BoundaryCondition   = MassConservation

        nullify(NewProperty)



    end subroutine ConstructCohort

    !--------------------------------------------------------------------------

    subroutine AllocateAuxLarvae(NewCohort)

        !Arguments-------------------------------------------------------------
        type(T_Cohort), pointer             :: NewCohort

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB

        !Begin-----------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !To solve properly the first interaction in case the cohort is
        !constructed from the file, the test if is larvae will be done later if set to true
        NewCohort%AtLeastOneLarvae = .true.

        allocate(NewCohort%Larvae(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

        allocate(NewCohort%AuxLarvaeL(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

        allocate(NewCohort%AuxLarvaeME(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

        allocate(NewCohort%AuxLarvaeMV(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

        allocate(NewCohort%AuxLarvaeMH(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

        allocate(NewCohort%AuxLarvaeMR(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

        allocate(NewCohort%AuxLarvaeN(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('AllocateAuxLarvae - ModuleWaterProperties - ERR10')

    end subroutine AllocateAuxLarvae

    !--------------------------------------------------------------------------

    subroutine Construct_CohortPropFromFile (NewProperty, Species, OverrideKeyword)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer           :: NewProperty
        type(T_Species), pointer            :: Species
        character(len=*)                    :: OverrideKeyword

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        character(len=8)                    :: BoundaryMethod
        logical                             :: VariableDT
        real                                :: ModelDT
        integer                             :: iflag
        integer                             :: i,j,k
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: WILB, WIUB, WJLB, WJUB
        integer                             :: WKLB, WKUB
        real                                :: ErrorAux, auxFactor, DTaux


        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        WILB = Me%WorkSize%ILB
        WIUB = Me%WorkSize%IUB
        WJLB = Me%WorkSize%JLB
        WJUB = Me%WorkSize%JUB
        WKLB = Me%WorkSize%KLB
        WKUB = Me%WorkSize%KUB

        nullify(NewProperty%Concentration        )
        nullify(NewProperty%Mass_Created         )
        nullify(NewProperty%SurfaceFlux          )
        nullify(NewProperty%Mass_Destroid        )
        nullify(NewProperty%Assimilation%Field   )
        nullify(NewProperty%Prev,NewProperty%Next)

        nullify(NewProperty%SubModel%PreviousField, NewProperty%SubModel%NextField)

        !NewProperty%ID%IDNumber                        = RegisterDynamicProperty(NewProperty%ID%Name)

        NewProperty%Old                                = Species%Old
        !NewProperty%ID%Units                           = Species%ID%Units
        NewProperty%WarnOnNegativeValues               = Species%WarnOnNegativeValues
        NewProperty%OutputHDF                          = Species%CohortOutputHDF
        NewProperty%TimeSerie                          = .false.

        if (NewProperty%TimeSerie) then
            Me%Coupled%TimeSerie%NumberOfProperties    = Me%Coupled%TimeSerie%NumberOfProperties + 1
            Me%Coupled%TimeSerie%Yes                   = ON
        endif

        NewProperty%BoxTimeSerie                       = Species%CohortBoxTimeSerie

        if (NewProperty%BoxTimeSerie) then
            Me%Coupled%BoxTimeSerie%NumberOfProperties = Me%Coupled%BoxTimeSerie%NumberOfProperties + 1
            Me%Coupled%BoxTimeSerie%Yes                = ON
            NewProperty%BoxIntegrationByArea           = ON
        endif

        NewProperty%Statistics                         = Species%CohortStatistics
        NewProperty%StatisticsFile                     = Species%CohortStatisticsFile

        if (NewProperty%Statistics) then
            Me%Coupled%Statistics%NumberOfProperties   = Me%Coupled%Statistics%NumberOfProperties + 1
            Me%Coupled%Statistics%Yes                  = ON
        endif

!~         NewProperty%Particulate                        = .false.
        NewProperty%IScoefficient                      = 0.0

        NewProperty%Evolution%Bivalve                  = .true.

        if (Species%LarvaeTransport)  then
            NewProperty%Evolution%AdvectionDiffusion = .true. !just to read default values
        else
            NewProperty%Evolution%AdvectionDiffusion = .false.
        end if

        NewProperty%evolution%Variable                 = .true.

        if (NewProperty%evolution%AdvectionDiffusion)         &
            call Read_Advec_Difus_Parameters(NewProperty)

        NewProperty%Evolution%MinConcentration         = .true.
        NewProperty%Evolution%MaxConcentration         = .false.
        NewProperty%MinValue                           = 0.0
        NewProperty%MaxValue                           = - FillValueReal

        allocate(NewProperty%Mass_Created(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_CohortPropFromFile - ModuleWaterProperties - ERR10')

        NewProperty%Mass_Created(:,:,:) = 0.

        NewProperty%Scalar                             = 0.0
        NewProperty%Assimilation%Scalar                = 0.0

        !Time Step if the property field is variable in time
        if (NewProperty%Evolution%Variable) then

            call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Subroutine Construct_CohortPropFromFile - ModuleWaterProperties - ERR300')

            call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Subroutine Construct_CohortPropFromFile - ModuleWaterProperties - ERR310')

            if (VariableDT) then

                NewProperty%Evolution%DTInterval       = ModelDT
                NewProperty%Evolution%HydroIntegration = .false.

            else

                NewProperty%evolution%DTInterval       = Species%DTInterval

                if (NewProperty%evolution%DTInterval < (ModelDT)) then
                    write(*,*)
                    write(*,*) ' Time step error.'
                    call CloseAllAndStop ('Subroutine Construct_CohortPropFromFile - ModuleWaterProperties - ERR330')

                elseif (NewProperty%evolution%DTInterval > (ModelDT)) then

                    !Property DT  must be a multiple of the ModelDT
                    auxFactor = NewProperty%evolution%DTInterval  / ModelDT

                    Erroraux = auxFactor - int(auxFactor)
                    if (Erroraux /= 0) then
                        write(*,*)
                        write(*,*) ' Time step error.'
                        call CloseAllAndStop ('Subroutine Construct_CohortPropFromFile - ModuleWaterProperties - ERR340')
                    endif

                    ! Run period in seconds
                    DTaux = Me%EndTime - Me%ExternalVar%Now

                    !The run period   must be a multiple of the Property DT
                    auxFactor = DTaux / NewProperty%evolution%DTInterval

                    ErrorAux = auxFactor - int(auxFactor)
                    if (ErrorAux /= 0) then
                        write(*,*)
                        write(*,*) ' Time step error.'
                        call CloseAllAndStop ('Subroutine Construct_CohortPropFromFile - ModuleWaterProperties - ERR350')
                    endif

                    NewProperty%Evolution%HydroIntegration = .true.

                else

                    NewProperty%Evolution%HydroIntegration = .false.

                end if

            endif !(not (VariableDT)

            NewProperty%Evolution%NextCompute = Me%ExternalVar%Now + NewProperty%Evolution%DTInterval

        else ! not (NewProperty%Evolution%Variable)

            call null_time(NewProperty%Evolution%NextCompute)

            NewProperty%evolution%DTInterval = FillValueReal

        endif

#ifdef _USE_PAGELOCKED
        ! Allocate pagelocked memory to optimize CUDA transfers
        call Alloc3DPageLocked(Me%ObjCuda, NewProperty%ConcentrationPtr, NewProperty%Concentration, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate(NewProperty%Concentration(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR10')
#endif

        NewProperty%Concentration(:,:,:) = FillValueReal

        !if (NewProperty%Evolution%DataAssimilation /= NoNudging) then

        allocate (NewProperty%Assimilation%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR30')
            NewProperty%Assimilation%Field(:,:,:) = FillValueReal

        !endif

        ! if the property is not 'OLD' the property values in the domain and
        ! in the boundaries are initialized
        ! if it's true ('OLD') this same values are read from the final file of the
        ! previous run
cd1 :   if (.not.NewProperty%Old) then

            call ConstructFillMatrix  (PropertyID           = NewProperty%ID,               &
                                       EnterDataID          = Me%ObjEnterData,              &
                                       TimeID               = Me%ObjTime,                   &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                       GeometryID           = Me%ObjGeometry,               &
                                       ExtractType          = FromBlockInBlock,             &
                                       PointsToFill3D       = Me%ExternalVar%WaterPoints3D, &
                                       Matrix3D             = NewProperty%Concentration,    &
                                       TypeZUV              = TypeZ_,                       &
                                       OverrideValueKeyword = trim(OverrideKeyword),        &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR110')

            call GetDefaultValue(NewProperty%ID%ObjFillMatrix, NewProperty%Scalar, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR120')

            call KillFillMatrix(NewProperty%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR121')

            call CheckFieldConsistence(NewProperty)

            !By default the bivalve properties are 0 in the boundary
            NewProperty%Concentration(WILB:WIUB,  JLB, WKLB:WKUB) = 0.0

            NewProperty%Concentration(WILB:WIUB,  JUB, WKLB:WKUB) = 0.0

            NewProperty%Concentration( ILB, WJLB:WJUB, WKLB:WKUB) = 0.0

            NewProperty%Concentration( IUB, WJLB:WJUB, WKLB:WKUB) = 0.0

            !By default the assimilation field is equal to the initial one

do3 :       do K = WKLB, WKUB
do2 :       do J = JLB, JUB
do1 :       do I = ILB, IUB

                NewProperty%Assimilation%Field(I, J, K) = NewProperty%Concentration(i,j,k)

            end do do1
            end do do2
            end do do3


            call GetData(BoundaryMethod,                                                &
                         Me%ObjEnterData, iflag,                                        &
                         SearchType = FromBlock,                                        &
                         keyword    = 'BOUNDARY_INITIALIZATION',                        &
                         Default    = 'INTERIOR',                                       &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT       = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR180')

cd4 :       if (associated(Me%ExternalVar%BoundaryPoints2D)) then
cd2 :           if      (BoundaryMethod=='EXTERIOR'        ) then

do4 :               do J = JLB, JUB
do5 :               do I = ILB, IUB

cd5 :                   if (Me%ExternalVar%BoundaryPoints2D(i, j) == Boundary) then

do6 :                       do K = WKLB, WKUB

                                NewProperty%Assimilation%Field(i, j, k) = NewProperty%Assimilation%scalar

                            end do do6

                        endif cd5

                    end do do5
                    end do do4

                elseif(BoundaryMethod .ne. 'EXTERIOR' .and. BoundaryMethod .ne. 'INTERIOR') then

                    write(*,*)
                    write(*,*) 'The boundary initialization methods can only be two: '
                    write(*,*) '    INTERIOR OR EXTERIOR'
                    call CloseAllAndStop ('Construct_CohortPropFromFile - ModuleWaterProperties - ERR190')

               end if cd2

            end if cd4

        else  cd1

            ! If the property is old then the program is going to try to find a property
            ! with the same name in the Water properties initial file written in HDF format
            call ReadOldConcBoundariesHDF(NewProperty)

        end if cd1

        call Add_Property(NewProperty)

        Me%Bivalve%nPropertiesFromBivalve = Me%Bivalve%nPropertiesFromBivalve + 1

    end subroutine Construct_CohortPropFromFile

    !----------------------------------------------------------------------------

    subroutine ConstructNewBornCohort (Species, NewCohort)

        !Arguments-------------------------------------------------------------
        type(T_Species), pointer            :: Species
        type(T_Cohort), pointer             :: NewCohort

        !Local-----------------------------------------------------------------
        type(T_Property), pointer           :: NewProperty, Property_L, Property_N
!        character(LEN = StringLength)       :: CohortPropName
        character(len=5)                    :: CohortIDStr
        integer                             :: STAT_CALL


        !Begin-----------------------------------------------------------------

        !Cohorts Name
        write(CohortIDStr, ('(i5)'))NewCohort%ID%ID
        NewCohort%ID%Name = trim(adjustl(Species%ID%Name))//" cohort "//trim(adjustl(CohortIDStr))
        write(*,*)trim(adjustl(NewCohort%ID%Name))

        if (Species%LarvaeTransport) then
            call AllocateAuxLarvae(NewCohort)
        end if

        !Newborns properties, from bivalve?
        call GetBivalveNewBornParameters (Bivalve_ID      = Me%ObjBivalve,          &
                                          SpeciesIDNumber = Species%ID%IDNumber,    &
                                          M_V0            = Species%M_V0,           &
                                          M_E0            = Species%M_E0,           &
                                          M_H0            = Species%M_H0,           &
                                          L_0             = Species%L_0,            &
                                          STAT            = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('ConstructNewBornCohort - ModuleWaterProperties - ERR01')

        Species%M_R0 = 0.0
        Species%A_0  = 0.0

        !generate property length
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" length",    &
                                       IsDynamic        = .true.,                                        &
                                       IsParticulate    = .false.,                                        &
                                       IsAngle          = .false.,                                        &
                                       IsVectorial      = .false.,                                        &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'LENGTH')

!~         CohortPropName = 'LENGTH'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" length"
!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))

        Property_L => NewProperty

        nullify(NewProperty)

        !generate property structure
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                    &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" structure",    &
                                       IsDynamic        = .true.,                                            &
                                       IsParticulate    = .false.,                                            &
                                       IsAngle          = .false.,                                            &
                                       IsVectorial      = .false.,                                            &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'STRUCTURE')

!~         CohortPropName = 'STRUCTURE'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" structure"

!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property reserves
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                    &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" reserves",    &
                                       IsDynamic        = .true.,                                            &
                                       IsParticulate    = .false.,                                            &
                                       IsAngle          = .false.,                                            &
                                       IsVectorial      = .false.,                                            &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'RESERVES')

!~         CohortPropName = 'RESERVES'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" reserves"

!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property maturity
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                    &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" maturity",    &
                                       IsDynamic        = .true.,                                            &
                                       IsParticulate    = .false.,                                            &
                                       IsAngle          = .false.,                                            &
                                       IsVectorial      = .false.,                                            &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'MATURITY')

!~         CohortPropName = 'MATURITY'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" maturity"

!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)

        !generate property reproduction
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                        &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" reproduction",    &
                                       IsDynamic        = .true.,                                                &
                                       IsParticulate    = .false.,                                                &
                                       IsAngle          = .false.,                                                &
                                       IsVectorial      = .false.,                                                &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'REPRODUCTION')

!~         CohortPropName = 'REPRODUCTION'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" reproduction"

!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))

        nullify(NewProperty)


        !generate property age
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" age",        &
                                       IsDynamic        = .true.,                                        &
                                       IsParticulate    = .false.,                                        &
                                       IsAngle          = .false.,                                        &
                                       IsVectorial      = .false.,                                        &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'AGE')

!~         CohortPropName = 'AGE'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" age"

!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))
        NewProperty%Evolution%AdvectionDiffusion  = .false. !age has no advection-diffusion
        nullify(NewProperty)

        !generate property number
        allocate (NewProperty)

        call ConstructPropertyIDOnFly (PropertyID       = NewProperty%ID,                                &
                                       Name             = trim(adjustl(NewCohort%ID%Name))//" number",    &
                                       IsDynamic        = .true.,                                        &
                                       IsParticulate    = .false.,                                        &
                                       IsAngle          = .false.,                                        &
                                       IsVectorial      = .false.,                                        &
                                       Units            = trim(Species%ID%Units))

        call Construct_CohortPropFromCohort (NewProperty, Species, 'NUMBER')

!~         CohortPropName = 'NUMBER'
!~         NewProperty%ID%Name = trim(adjustl(NewCohort%ID%Name))//" number"

!~         call Construct_CohortPropFromCohort (NewProperty, Species, trim(CohortPropName))

        Me%Coupled%MinimumConcentration%Yes            = ON
        NewProperty%Evolution%MinConcentration         = ON
        NewProperty%MinValue                           = 0.0

        Property_N => NewProperty

        nullify(NewProperty)

        if (Species%CohortBoxTimeSerie) then

            !create and open the box time serie files for the new properties
            call Construct_OutputBoxesFromCohort(NewCohort)

        end if

        call ComputeCohortLarvaeDistribution(NewCohort, Property_L, Property_N, Species%LarvaeMaxSize)

        nullify(Property_L, Property_N)

    end subroutine ConstructNewBornCohort

    !--------------------------------------------------------------------------

    subroutine Construct_CohortPropFromCohort (NewProperty, Species, CohortPropName)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer           :: NewProperty
        type(T_Species), pointer            :: Species
        character(len=*)                    :: CohortPropName

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: i,j,k
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: WILB, WIUB, WJLB, WJUB
        integer                             :: WKLB, WKUB
        integer                             :: Index
        logical                             :: VariableDT
        real                                :: ModelDT
        real                                :: NewbornValue
        integer                             :: iSpecies, SpeciesPosMatrixNewborns
        real                                :: ErrorAux, auxFactor, DTaux
        integer                             :: NullGradient

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        WILB = Me%WorkSize%ILB
        WIUB = Me%WorkSize%IUB
        WJLB = Me%WorkSize%JLB
        WJUB = Me%WorkSize%JUB
        WKLB = Me%WorkSize%KLB
        WKUB = Me%WorkSize%KUB

        nullify(NewProperty%Concentration        )
        nullify(NewProperty%Mass_Created         )
        nullify(NewProperty%SurfaceFlux          )
        nullify(NewProperty%Mass_Destroid        )
        nullify(NewProperty%Assimilation%Field   )
        nullify(NewProperty%Prev,NewProperty%Next)

        nullify(NewProperty%SubModel%PreviousField, NewProperty%SubModel%NextField)

!~         NewProperty%ID%IDNumber                  = RegisterDynamicProperty(NewProperty%ID%Name)

        NewProperty%Old                          = Species%Old
        NewProperty%WarnOnNegativeValues         = Species%WarnOnNegativeValues
        NewProperty%OutputHDF                    = Species%CohortOutputHDF
        NewProperty%TimeSerie                    = .false.
        NewProperty%BoxTimeSerie                 = Species%CohortBoxTimeSerie
        if(NewProperty%BoxTimeSerie)then
            NewProperty%BoxIntegrationByArea     = ON
        endif
        NewProperty%Statistics                   = Species%CohortStatistics
        NewProperty%StatisticsFile               = Species%CohortStatisticsFile

!~         NewProperty%Particulate                  = .false.
        NewProperty%IScoefficient                = 0.0

        NewProperty%Evolution%Bivalve            = .true.

        if (Species%LarvaeTransport)  then
            NewProperty%Evolution%AdvectionDiffusion = .true.
        else
            NewProperty%Evolution%AdvectionDiffusion = .false.
        end if

        NewProperty%evolution%Variable           = .true.

        call GetBoundaryConditionList(NullGradient = NullGradient)

        NewProperty%Evolution%Advec_Difus_Parameters%NumericStability    = .FALSE.
        NewProperty%Evolution%Advec_Difus_Parameters%SchmidtNumberH      = 1.0
        NewProperty%Evolution%Advec_Difus_Parameters%SchmidtCoefV        = 1.0
        NewProperty%Evolution%Advec_Difus_Parameters%SchmidtBackgroundV  = 1.e-8
        NewProperty%Evolution%Advec_Difus_Parameters%AdvectionV_imp_exp  = 1.0
        NewProperty%Evolution%Advec_Difus_Parameters%DiffusionV_imp_exp  = 0.0
        NewProperty%Evolution%Advec_Difus_Parameters%NullDif             = .false.
        NewProperty%Evolution%Advec_Difus_Parameters%DecayTime           = 0.0
        NewProperty%Evolution%Advec_Difus_Parameters%BoundaryCondition   = NullGradient
        NewProperty%Evolution%Advec_Difus_Parameters%AdvectionH_imp_exp  = 0.0
        NewProperty%Evolution%Advec_Difus_Parameters%DiffusionH_imp_exp  = 0.
        NewProperty%Evolution%Advec_Difus_Parameters%ImplicitH_Direction = DirectionX

        NewProperty%Evolution%Advec_Difus_Parameters%AdvMethodH          = UpwindOrder1
        NewProperty%Evolution%Advec_Difus_Parameters%TVDLimitationH      = Superbee
        NewProperty%Evolution%Advec_Difus_Parameters%AdvMethodV          = UpwindOrder1
        NewProperty%Evolution%Advec_Difus_Parameters%TVDLimitationV      =  Superbee
        NewProperty%Evolution%Advec_Difus_Parameters%VolumeRelMax        = 1.5
        NewProperty%Evolution%Advec_Difus_Parameters%AdvectionNudging    = .false.

        NewProperty%Evolution%MinConcentration                           = .true.
        NewProperty%Evolution%MaxConcentration                           = .false.
        NewProperty%MinValue                                             = 0.0
        NewProperty%MaxValue                                             = - FillValueReal

        allocate(NewProperty%Mass_Created(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_CohortPropFromCohort - ModuleWaterProperties - ERR10')

        NewProperty%Mass_Created(:,:,:) = 0.

        NewProperty%Scalar                       = 0.0

        NewProperty%Assimilation%Scalar          = 0.0

        !Time Step if the property field is variable in time
        if (NewProperty%Evolution%Variable) then

            call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Subroutine Construct_CohortPropFromCohort - ModuleWaterProperties - ERR00')

            call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Subroutine Construct_CohortPropFromCohort - ModuleWaterProperties - ERR10')

            if (VariableDT) then

                NewProperty%Evolution%DTInterval       = ModelDT
                NewProperty%Evolution%HydroIntegration = .false.

            else

                NewProperty%evolution%DTInterval = Species%DTInterval

                if (NewProperty%evolution%DTInterval < (ModelDT)) then
                    write(*,*)
                    write(*,*) ' Time step error.'
                    call CloseAllAndStop ('Subroutine Construct_CohortPropFromCohort - ModuleWaterProperties - ERR20')

                elseif (NewProperty%evolution%DTInterval > (ModelDT)) then

                    !Property DT  must be a multiple of the ModelDT
                    auxFactor = NewProperty%evolution%DTInterval  / ModelDT

                    Erroraux = auxFactor - int(auxFactor)
                    if (Erroraux /= 0) then
                        write(*,*)
                        write(*,*) ' Time step error.'
                        call CloseAllAndStop ('Subroutine Construct_CohortPropFromCohort - ModuleWaterProperties - ERR30')
                    endif

                    ! Run period in seconds
                    DTaux = Me%EndTime - Me%ExternalVar%Now

                    !The run period   must be a multiple of the Property DT
                    auxFactor = DTaux / NewProperty%evolution%DTInterval

                    ErrorAux = auxFactor - int(auxFactor)
                    if (ErrorAux /= 0) then
                        write(*,*)
                        write(*,*) ' Time step error.'
                        call CloseAllAndStop ('Subroutine Construct_CohortPropFromCohort - ModuleWaterProperties - ERR40')
                    endif

                    NewProperty%Evolution%HydroIntegration = .true.

                else

                    NewProperty%Evolution%HydroIntegration = .false.

                end if

            endif !(not (VariableDT)

            NewProperty%Evolution%NextCompute = Me%ExternalVar%Now

        else ! not (NewProperty%Evolution%Variable)

            call null_time(NewProperty%Evolution%NextCompute)

            NewProperty%evolution%DTInterval = FillValueReal

        endif


#ifdef _USE_PAGELOCKED
        ! Allocate pagelocked memory to optimize CUDA transfers
        call Alloc3DPageLocked(Me%ObjCuda, NewProperty%ConcentrationPtr, NewProperty%Concentration, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate(NewProperty%Concentration(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_CohortPropFromCohort - ModuleWaterProperties - ERR50')
#endif

        NewProperty%Concentration(:,:,:) = FillValueReal

        !if (NewProperty%Evolution%DataAssimilation /= NoNudging) then

            allocate (NewProperty%Assimilation%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Construct_CohortPropFromCohort - ModuleWaterProperties - ERR60')
                NewProperty%Assimilation%Field(:,:,:) = FillValueReal

        !endif

        !build the concentration matriz for this porperty...
        select case (CohortPropName)
            case('STRUCTURE')
                NewbornValue = Species%M_V0
            case('RESERVES')
                NewbornValue = Species%M_E0
            case('MATURITY')
                NewbornValue = Species%M_H0
            case('REPRODUCTION')
                NewbornValue = Species%M_R0
            case('LENGTH')
                NewbornValue = Species%L_0
            case('AGE')
                NewbornValue = Species%A_0
        end select

        do iSpecies = 1, Me%Bivalve%nSpecies

            if (Species%ID%IDNumber .eq. Me%Bivalve%MatrixNewborns(iSpecies, 1)) then

                SpeciesPosMatrixNewborns = iSpecies

                if (CohortPropName .eq. 'NUMBER') then

                    Index = 1

                        do k = WKLB, WKUB
                         do j = WJLB, WJUB
                          do i = WILB, WIUB

                            if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                                NewProperty%Concentration (i, j, k) = Me%Bivalve%MatrixNewborns(SpeciesPosMatrixNewborns, Index+1)
                                Index = Index + 1
                            end if

                          end do
                         end do
                        end do

                else

                        do k = WKLB, WKUB
                         do j = WJLB, WJUB
                          do i = WILB, WIUB

                            if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                                NewProperty%Concentration (i, j, k) = NewbornValue
                            end if

                          end do
                         end do
                        end do

                end if

            end if

        end do

        call CheckFieldConsistence(NewProperty)

        !By default the exterior points have values equal to nearst interior point
        NewProperty%Concentration(WILB:WIUB,  JLB, WKLB:WKUB) = 0.0

        NewProperty%Concentration(WILB:WIUB,  JUB, WKLB:WKUB) = 0.0

        NewProperty%Concentration( ILB, WJLB:WJUB, WKLB:WKUB) = 0.0

        NewProperty%Concentration( IUB, WJLB:WJUB, WKLB:WKUB) = 0.0

        !if (NewProperty%Evolution%DataAssimilation /= NoNudging) then
            !By default the assimilation field is equal to the initial one

do3 :       do K = WKLB, WKUB
do2 :        do J = JLB, JUB
do1 :        do I = ILB, IUB

                NewProperty%Assimilation%Field(I, J, K) = NewProperty%Concentration(i,j,k)

              end do do1
             end do do2
            end do do3

        !endif

        call Add_Property(NewProperty)

        Me%Bivalve%nPropertiesFromBivalve = Me%Bivalve%nPropertiesFromBivalve + 1

    end subroutine Construct_CohortPropFromCohort

    !--------------------------------------------------------------------------

    subroutine Construct_OutputBoxesFromCohort (NewCohort)

        !Arguments--------------------------------------------------------------
        type(T_Cohort), pointer                             :: NewCohort

        !External--------------------------------------------------------------
        integer                                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        character(len=StringLength), dimension(:),  pointer :: CohortScalarOutputList
        character(len=StringLength), dimension(:),  pointer :: CohortFluxesOutputList
        integer                                             :: nScalars, nFluxes

        !----------------------------------------------------------------------

        nScalars = Me%Bivalve%nCohortProperties
        nFluxes  = Me%Bivalve%nCohortProperties

        allocate(CohortScalarOutputList(nScalars), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('Construct_OutputBoxesFromCohort - ModuleWaterProperties - ERR03')

        allocate(CohortFluxesOutputList(nFluxes), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('Construct_OutputBoxesFromCohort - ModuleWaterProperties - ERR04')

        CohortScalarOutputList(1) = trim(adjustl(NewCohort%ID%Name))//" structure"
        CohortScalarOutputList(2) = trim(adjustl(NewCohort%ID%Name))//" reserves"
        CohortScalarOutputList(3) = trim(adjustl(NewCohort%ID%Name))//" maturity"
        CohortScalarOutputList(4) = trim(adjustl(NewCohort%ID%Name))//" reproduction"
        CohortScalarOutputList(5) = trim(adjustl(NewCohort%ID%Name))//" length"
        CohortScalarOutputList(6) = trim(adjustl(NewCohort%ID%Name))//" age"
        CohortScalarOutputList(7) = trim(adjustl(NewCohort%ID%Name))//" number"

        CohortFluxesOutputList = CohortScalarOutputList

        call UpdateBoxDif( Me%ObjBoxDif,                                         &
                           NewFluxesOutputList   = CohortFluxesOutputList,       &
                           NewScalarOutputList   = CohortScalarOutputList,       &
                           nDimensions           = 3,                            &
                           STAT               = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('Construct_OutputBoxesFromCohort - ModuleWaterProperties - ERR07')

        deallocate(CohortFluxesOutputList, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('Construct_OutputBoxesFromCohort - ModuleWaterProperties - ERR08')
        nullify (CohortFluxesOutputList)


        deallocate(CohortScalarOutputList, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('Construct_OutputBoxesFromCohort - ModuleWaterProperties - ERR07')
        nullify (CohortScalarOutputList)

    end subroutine Construct_OutputBoxesFromCohort

    !----------------------------------------------------------------------------

    subroutine Construct_WqRateList

        !External----------------------------------------------------------------
        integer                                     :: ClientNumber
        integer                                     :: STAT_CALL
        logical                                     :: BlockFound

        !Local-------------------------------------------------------------------
        type (T_WqRate), pointer                    :: NewWqRate

        !------------------------------------------------------------------------

do1 :   do
            call ExtractBlockFromBuffer(Me%ObjEnterData,                        &
                                        ClientNumber    = ClientNumber,         &
                                        block_begin     = wqrateblock_begin,    &
                                        block_end       = wqrateblock_end,      &
                                        BlockFound      = BlockFound,           &
                                        STAT            = STAT_CALL)
cd1 :       if      (STAT_CALL .EQ. SUCCESS_     ) then
cd2 :           if (BlockFound) then

                    ! Construct a New WQRate
                    Call Construct_WqRate(NewWqRate)

                    ! Adds the new WQRate to the list of WQRates
                    Call Add_WqRate      (NewWqRate)

                else cd2

                    call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                &
                        call CloseAllAndStop ('Construct_WqRatesList - ModuleWaterProperties - ERR01')

                    exit do1    !No more blocks

                end if cd2

            else if (STAT_CALL .EQ. BLOCK_END_ERR_) then cd1
                write(*,*)
                write(*,*) 'Error calling ExtractBlockFromBuffer.'
                call CloseAllAndStop ('Construct_WqRatesList - ModuleWaterProperties - ERR02')

            else cd1
                call CloseAllAndStop ('Construct_WqRatesList - ModuleWaterProperties - ERR03')
            end if cd1
        end do do1

    end subroutine Construct_WqRateList

    !----------------------------------------------------------------------------

    subroutine Open_HDF5_OutPut_File(iW, FileNameIN, ObjHDF5External)


        !Arguments-------------------------------------------------------------
        integer, optional                           :: iW
        character (Len = *), optional, intent(in)   :: FileNameIN
        integer,             optional               :: ObjHDF5External

        !Local-----------------------------------------------------------------
        real,    pointer, dimension(:, :   )        :: Bathymetry
        integer, pointer, dimension(:, :, :)        :: WaterPoints3D
        character (Len = PathLength)                :: FileName
        character (Len = StringLength)              :: AuxChar
        type(T_Size2D)                              :: WorkSize2D, WorkSize2DAux, GlobalWorkSizeWindow
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE, ObjHDF5, i, n, j
        logical                                     :: OutputOk

        !----------------------------------------------------------------------
        !Bounds

        if(present(FileNameIN))then
            FileName = FileNameIN
        else
            FileName = trim(Me%Files%OutPutFields)//"5"
        endif

        OutputOk = .true.

i2:     if (present(iW)) then

            WorkILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkIUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkJLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkJUB = Me%OutW%OutPutWindows(iW)%JUB

            WorkKLB = Me%OutW%OutPutWindows(iW)%KLB
            WorkKUB = Me%OutW%OutPutWindows(iW)%KUB

            WorkSize2D%ILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkSize2D%IUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkSize2D%JLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkSize2D%JUB = Me%OutW%OutPutWindows(iW)%JUB

            GlobalWorkSizeWindow = WorkSize2D

            Me%OutW%OutPutWindows(iW)%ON = .true.


            if (Me%DDecomp%MasterOrSlave) then

                if (WindowIntersectDomain(Me%ObjHorizontalGrid, WorkSize2D)) then

                    WorkSize2DAux%ILB             = WorkSize2D%ILB
                    WorkSize2DAux%IUB             = WorkSize2D%IUB

                    WorkSize2DAux%JLB             = WorkSize2D%JLB
                    WorkSize2DAux%JUB             = WorkSize2D%JUB

                    WorkSize2D                    = ReturnsIntersectionCorners(Me%ObjHorizontalGrid, WorkSize2DAux)

                    WorkILB                       = WorkSize2D%ILB
                    WorkIUB                       = WorkSize2D%IUB

                    WorkJLB                       = WorkSize2D%JLB
                    WorkJUB                       = WorkSize2D%JUB

                    Me%OutW%OutPutWindows(iW)%ILB = WorkSize2D%ILB
                    Me%OutW%OutPutWindows(iW)%IUB = WorkSize2D%IUB

                    Me%OutW%OutPutWindows(iW)%JLB = WorkSize2D%JLB
                    Me%OutW%OutPutWindows(iW)%JUB = WorkSize2D%JUB


                else
                    Me%OutW%OutPutWindows(iW)%ON = .false.
                    OutputOk                     = .false.
                endif
            endif

            write(AuxChar,fmt='(i5)') iW
            Auxchar           = "_w"//trim(adjustl(Auxchar))//".hdf5"
            n                 = len_trim(Auxchar)
            do j=1,len_trim(Filename)
                if(FileName(j:j+4)==".hdf5") then
                    i = j
                    exit
                endif
            enddo
            FileName(i:i+n-1) = trim(Auxchar)

        else i2

            WorkILB = Me%WorkSize%ILB
            WorkIUB = Me%WorkSize%IUB

            WorkJLB = Me%WorkSize%JLB
            WorkJUB = Me%WorkSize%JUB

            WorkKLB = Me%WorkSize%KLB
            WorkKUB = Me%WorkSize%KUB

            WorkSize2D%ILB = Me%WorkSize%ILB
            WorkSize2D%IUB = Me%WorkSize%IUB

            WorkSize2D%JLB = Me%WorkSize%JLB
            WorkSize2D%JUB = Me%WorkSize%JUB

        endif i2

i1:     if (OutputOk) then

            !Gets a pointer to Bathymetry
            call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR20')

            !Gets WaterPoints3D
            call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR30')


            !Gets File Access Code
            call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

            ObjHDF5 = 0

            !Opens HDF5 File
            call ConstructHDF5      (ObjHDF5, trim(FileName),                &
                                     HDF5_CREATE, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR40')

            if (present(ObjHDF5External))then

                ObjHDF5External = ObjHDF5

                !Write the Horizontal Grid
                call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5,                         &
                                         WorkSize = WorkSize2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR41')

            else

                if (present(iW)) then

                    Me%OutW%ObjHDF5(iW) = ObjHDF5

                    !Write the Horizontal Grid
                    call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5,                &
                                             WorkSize               = WorkSize2D,          &
                                             WindowGrid             = .true.,              &
                                             GlobalWorkSizeWindow   = GlobalWorkSizeWindow,&
                                             STAT                   = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR50')


                else

                    Me%ObjHDF5          = ObjHDF5

                    !Write the Horizontal Grid
                    call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5,                         &
                                             WorkSize = WorkSize2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR50')

                endif
            endif


            !Sets limits for next write operations
            call HDF5SetLimits   (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                       &
                                  WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR60')


            !Writes the Grid
            call HDF5WriteData   (ObjHDF5, "/Grid", "Bathymetry", "m",                      &
                                  Array2D = Bathymetry,                                     &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR70')

            call HDF5WriteData   (ObjHDF5, "/Grid", "WaterPoints3D", "-",                   &
                                  Array3D = WaterPoints3D,                                  &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR80')

            !Writes everything to disk
            call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR90')


            !Ungets the Bathymetry
            call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR100')

            !Ungets the WaterPoints
            call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_HDF5_OutPut_File - ModuleWaterProperties - ERR110')

        endif i1

        !----------------------------------------------------------------------

    end subroutine Open_HDF5_OutPut_File

    !----------------------------------------------------------------------

    subroutine Open_Surface_HDF5_OutPut_File

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        real, pointer, dimension(:,:)               :: Bathymetry
        integer, pointer, dimension(:,:,:)          :: WaterPoints3D
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE
        character(len=PathLength)                   :: SurfaceHDF5FileName
        integer                                     :: FileNameLength
        character(len=5)                            :: Extension

        !----------------------------------------------------------------------

        !Bounds
        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        !Gets a pointer to Bathymetry
        call GetGridData      (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR00')

        !Gets WaterPoints3D
        call GetWaterPoints3D   (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR10')

        FileNameLength      = len_trim(Me%Files%OutPutFields) + 1
        Extension           = trim(Me%Files%OutPutFields(FileNameLength-4:FileNameLength))
        Extension(5:5)      = "5"
        SurfaceHDF5FileName = Me%Files%OutPutFields(1:FileNameLength-5)//"_Surface"//trim(Extension)


        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        !Opens HDF File
        call ConstructHDF5      (Me%ObjSurfaceHDF5,                                     &
                                 trim(SurfaceHDF5FileName),                             &
                                 HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR20')

        !Write the Horizontal Grid
        call WriteHorizontalGrid(Me%ObjHorizontalGrid, Me%ObjSurfaceHDF5,               &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR30')

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjSurfaceHDF5, WorkILB, WorkIUB, WorkJLB,             &
                              WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR40')

        !Writes the Bathymetry
        call HDF5WriteData   (Me%ObjSurfaceHDF5, "/Grid", "Bathymetry", "m",            &
                              Array2D = Bathymetry,                                     &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR50')

        call HDF5WriteData   (Me%ObjSurfaceHDF5, "/Grid", "WaterPoints3D", "-",         &
                              Array3D = WaterPoints3D,                                  &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR60')

        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR80')

        !Ungets the Bathymetry
        call UngetGridData (Me%ObjGridData, Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR90')

        !Ungets the WaterPoints
        call UnGetMap        (Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Open_Surface_HDF5_OutPut_File - ModuleWaterProperties - ERR100')

        !----------------------------------------------------------------------

    end subroutine Open_Surface_HDF5_OutPut_File

    !--------------------------------------------------------------------------

    subroutine Construct_Time_Serie


        !External--------------------------------------------------------------
        character(len=StringLength), dimension(:), pointer  :: PropertyList
        integer                                             :: STAT_CALL, iflag

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                          :: PropertyX
        integer                                             :: nProperties
        real                                                :: CoordX, CoordY
        logical                                             :: CoordON, IgnoreOK
        integer                                             :: dn, Id, Jd, TimeSerieNumber
        character(len=PathLength)                           :: TimeSerieLocationFile
        character(len=StringLength)                         :: TimeSerieName
        type (T_Polygon), pointer                           :: ModelDomainLimit

        !----------------------------------------------------------------------

        !First checks out how many properties will have time series
        PropertyX   => Me%FirstProperty
        nProperties =  0
        do while (associated(PropertyX))

            if (PropertyX%TimeSerie) then

                nProperties = nProperties + 1

                if (PropertyX%Evolution%Filtration%On) then

                     nProperties = nProperties + 1

                endif



            end if

            PropertyX=>PropertyX%Next
        enddo

        !light extinction
        if (Me%OutPut%Radiation) then
            nProperties = nProperties + 2
        endif

        if (nProperties > 0) then

            !Allocates PropertyList
            allocate(PropertyList(nProperties), STAT = STAT_CALL)
            if (STAT_CALL /= 0) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR10')

            !Fills up PropertyList
            PropertyX   => Me%FirstProperty
            nProperties =  0
            do while (associated(PropertyX))
                if (PropertyX%TimeSerie) then
                    nProperties = nProperties + 1
                    PropertyList(nProperties) = trim(adjustl(PropertyX%ID%name))

                    if (PropertyX%Evolution%Filtration%On) then

                        nProperties = nProperties + 1

                        PropertyList(nProperties) = "Fil_"//trim(adjustl(PropertyX%ID%name))

                    endif

                endif
                PropertyX=>PropertyX%Next
            enddo

            if (Me%OutPut%Radiation) then
                nProperties = nProperties + 1
                PropertyList(nProperties) = "ShortWave Solar Radiation Average [W/m2]"
                nProperties = nProperties + 1
                PropertyList(nProperties) = "ShortWave Solar Radiation Extinction [1/m]"
            endif

            call GetData(TimeSerieLocationFile,                                         &
                         Me%ObjEnterData,iflag,                                         &
                         SearchType   = FromFile,                                       &
                         keyword      = 'TIME_SERIE_LOCATION',                          &
                         ClientModule = 'ModuleWaterProperties',                        &
                         Default      = Me%Files%ConstructData,                         &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR20')

            call GetGridOutBorderPolygon(HorizontalGridID = Me%ObjHorizontalGrid,       &
                                         Polygon          = ModelDomainLimit,           &
                                         STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR30')

            call StartTimeSerie(Me%ObjTimeSerie, Me%ObjTime,                            &
                                trim(TimeSerieLocationFile),                            &
                                PropertyList, "srw",                                    &
                                WaterPoints3D   = Me%ExternalVar%WaterPoints3D,         &
                                ModelName       = Me%ModelName,                         &
                                ModelDomain     = ModelDomainLimit,                     &
                                STAT            = STAT_CALL)
            if (STAT_CALL /= 0) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR40')

            call UngetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                     Polygon          = ModelDomainLimit,               &
                                     STAT             = STAT_CALL)
            if (STAT_CALL /= 0) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR50')

            !Constructs TimeSerie
            !Deallocates PropertyList
            deallocate(PropertyList, STAT = STAT_CALL)
            if (STAT_CALL /= 0) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR60')

            !Corrects if necessary the cell of the time serie based in the time serie coordinates
            call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR70')

            do dn = 1, TimeSerieNumber

                call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR80')

                if (IgnoreOK) cycle

                call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                          CoordX   = CoordX,                                &
                                          CoordY   = CoordY,                                &
                                          CoordON  = CoordON,                               &
                                          STAT     = STAT_CALL)

                call GetTimeSerieName(Me%ObjTimeSerie, dn, TimeSerieName, STAT  = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Time_Serie - ModuleHydrodynamic - ERR90')

                if (CoordON) then
                    call GetXYCellZ(Me%ObjHorizontalGrid, CoordX, CoordY, Id, Jd, STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                        call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR100')
                    endif

!                    if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then

!                        call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
!                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR70')

!                        if (IgnoreOK) then
!                            cycle
!                        else
!                            call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR80')
!                        endif

!                    endif

                    call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn, Id, Jd, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR110')
                endif

                call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                          LocalizationI   = Id,                             &
                                          LocalizationJ   = Jd,                             &
                                          STAT     = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Time_Serie - ModuleWaterProperties - ERR120')

                if (Me%ExternalVar%WaterPoints3D(Id, Jd, Me%WorkSize%KUB) /= WaterPoint) then

                     write(*,*) 'Time Serie in a land cell - ',trim(TimeSerieName),' - ',trim(Me%ModelName)

                endif




            enddo


        endif

    end subroutine Construct_Time_Serie

    !--------------------------------------------------------------------------

    subroutine Construct_Output_Profile

        !Local-----------------------------------------------------------------
        integer                                             :: STAT_CALL, iflag
        character(len=StringLength)                         :: TimeSerieLocationFile
        character(len=StringLength), dimension(:,:), pointer:: PropertyList
        type (T_Property), pointer                          :: PropertyX
        integer                                             :: n
        !----------------------------------------------------------------------

        allocate(PropertyList(1:Me%Coupled%OutputProfile%NumberOfProperties,1:2))

        n = 1

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%OutputProfile) then

                PropertyList(n,1) = trim(PropertyX%ID%Name )
                PropertyList(n,2) = trim(PropertyX%ID%Units)

                n = n + 1

            end if

            PropertyX=>PropertyX%Next

        enddo

        call GetData(TimeSerieLocationFile,                                             &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     Default      = Me%Files%ConstructData,                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_Output_Profile - ModuleWaterProperties - ERR01')


        call StartProfile  (ProfileID       = Me%ObjProfile,                            &
                            ObjTime         = Me%ObjTime,                               &
                            ProfileDataFile = trim(TimeSerieLocationFile),              &
                            WaterPoints2D   = Me%ExternalVar%WaterPoints2D,             &
                            KUB             = Me%WorkSize%KUB,                          &
                            nProperties     = Me%Coupled%OutputProfile%NumberOfProperties, &
                            PropertyList    = PropertyList,                             &
                            ClientName      = "WaterProperties",                        &
                            STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Construct_Output_Profile - ModuleWaterProperties - ERR02')

        deallocate(PropertyList)


    end subroutine Construct_Output_Profile

    !--------------------------------------------------------------------------

    subroutine Construct_Sub_Modules(AssimilationID, DischargesID       &
#ifdef _ENABLE_CUDA
                                     , CudaID                           &
#endif _ENABLE_CUDA
    )

        integer                                              :: DischargesID
        integer                                              :: AssimilationID
#ifdef _ENABLE_CUDA
        integer                                              :: CudaID
#endif
        !Local-----------------------------------------------------------------
        type (T_Property),           pointer                 :: PropertyX
        integer                                              :: STAT_CALL, dis, TotalCells

        !----------------------------------------------------------------------

        Me%Coupled%WQM%NumberOfProperties                   = 0
        Me%Coupled%CEQUALW2%NumberOfProperties              = 0
        Me%Coupled%Life%NumberOfProperties                  = 0
        Me%Coupled%Bivalve%NumberOfProperties               = 0
        Me%Coupled%WWTPQM%NumberOfProperties                = 0
#ifdef _PHREEQC_
        Me%Coupled%PhreeqC%NumberOfProperties               = 0
#endif
        Me%Coupled%AdvectionDiffusion%NumberOfProperties    = 0
        Me%Coupled%FreeVerticalMovement%NumberOfProperties  = 0
        Me%Coupled%SurfaceFluxes%NumberOfProperties         = 0
        Me%Coupled%BottomFluxes%NumberOfProperties          = 0
        Me%Coupled%FirstOrderDecay%NumberOfProperties       = 0
        Me%Coupled%Discharges%NumberOfProperties            = 0
        Me%Coupled%DischargesTracking%NumberOfProperties    = 0
        Me%Coupled%HydroIntegration%NumberOfProperties      = 0
        Me%Coupled%DataAssimilation%NumberOfProperties      = 0
        Me%Coupled%SolutionFromFile%NumberOfProperties      = 0
        Me%Coupled%LightExtinction%NumberOfProperties       = 0
        Me%Coupled%CalculateAge%NumberOfProperties          = 0
        Me%Coupled%Filtration%NumberOfProperties            = 0
        Me%Coupled%MacroAlgae%NumberOfProperties            = 0
        Me%Coupled%LagSinksSources%NumberOfProperties       = 0
        Me%Coupled%Reinitialize%NumberOfProperties          = 0
        Me%Coupled%SeagrassesLeaves%NumberOfProperties      = 0

        Me%Coupled%AllSolutionFromFile                      = .true.
        Me%Coupled%HybridReferenceField                     = .false.

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))

            if (PropertyX%Evolution%AdvectionDiffusion)then
                Me%Coupled%AdvectionDiffusion%NumberOfProperties        = &
                Me%Coupled%AdvectionDiffusion%NumberOfProperties        + 1
                Me%Coupled%AdvectionDiffusion%Yes                       = ON
            endif

            if (PropertyX%Evolution%WaterQuality) then
                Me%Coupled%WQM%NumberOfProperties                       = &
                Me%Coupled%WQM%NumberOfProperties                       + 1
                Me%Coupled%WQM%Yes                                      = ON
            endif

            if (PropertyX%Evolution%MacroAlgae) then
                Me%Coupled%MacroAlgae%NumberOfProperties                = &
                Me%Coupled%MacroAlgae%NumberOfProperties                + 1
                Me%Coupled%MacroAlgae%Yes                               = ON
            endif

            if (PropertyX%Evolution%SeagrassesLeaves)then
                Me%Coupled%SeagrassesLeaves%NumberOfProperties        = &
                Me%Coupled%SeagrassesLeaves%NumberOfProperties        + 1
                Me%Coupled%SeagrassesLeaves%Yes                       = ON
            endif

            if (PropertyX%Evolution%CEQUALW2) then
                Me%Coupled%CEQUALW2%NumberOfProperties                  = &
                Me%Coupled%CEQUALW2%NumberOfProperties                  + 1
                Me%Coupled%CEQUALW2%Yes                                 = ON
            endif

            if (PropertyX%Evolution%Life) then
                Me%Coupled%Life%NumberOfProperties                      = &
                Me%Coupled%Life%NumberOfProperties                      + 1
                Me%Coupled%Life%Yes                                     = ON
            endif

            if (PropertyX%Evolution%Bivalve) then
                Me%Coupled%Bivalve%NumberOfProperties                   = &
                Me%Coupled%Bivalve%NumberOfProperties                   + 1
                Me%Coupled%Bivalve%Yes                                  = ON
            endif

            if (PropertyX%Evolution%WWTPQ) then
                Me%Coupled%WWTPQM%NumberOfProperties                    = &
                Me%Coupled%WWTPQM%NumberOfProperties                    + 1
                Me%Coupled%WWTPQM%Yes                                   = ON
            endif

#ifdef _PHREEQC_
            if (PropertyX%Evolution%PhreeqC) then
                Me%Coupled%PhreeqC%NumberOfProperties                   = &
                Me%Coupled%PhreeqC%NumberOfProperties                   + 1
                Me%Coupled%PhreeqC%Yes                                  = ON
            endif
#endif

            if (PropertyX%Evolution%LightExtinction) then
                Me%Coupled%LightExtinction%NumberOfProperties           = &
                Me%Coupled%LightExtinction%NumberOfProperties           + 1
                Me%Coupled%LightExtinction%Yes                          = ON
            endif

            if (PropertyX%Evolution%Partitioning) then
                Me%Coupled%Partition%NumberOfProperties                 = &
                Me%Coupled%Partition%NumberOfProperties                 + 1
                Me%Coupled%Partition%Yes                                = ON
            endif

            if (PropertyX%Evolution%InstantMixing) then
                Me%Coupled%InstantMixing%NumberOfProperties             = &
                Me%Coupled%InstantMixing%NumberOfProperties             + 1
                Me%Coupled%InstantMixing%Yes                            = ON
            endif

            if (PropertyX%Evolution%FreeVerticalMovement) then
                Me%Coupled%FreeVerticalMovement%NumberOfProperties      = &
                Me%Coupled%FreeVerticalMovement%NumberOfProperties      + 1
                Me%Coupled%FreeVerticalMovement%Yes                     = ON
            endif

            if (PropertyX%Evolution%SurfaceFluxes) then
                Me%Coupled%SurfaceFluxes%NumberOfProperties             = &
                Me%Coupled%SurfaceFluxes%NumberOfProperties             + 1
                Me%Coupled%SurfaceFluxes%Yes                            = ON
            endif

            if (PropertyX%Evolution%BottomFluxes) then
                Me%Coupled%BottomFluxes%NumberOfProperties              = &
                Me%Coupled%BottomFluxes%NumberOfProperties              + 1
                Me%Coupled%BottomFluxes%Yes                             = ON
            endif

            if (PropertyX%Evolution%FirstOrderDecay) then
                Me%Coupled%FirstOrderDecay%NumberOfProperties           = &
                Me%Coupled%FirstOrderDecay%NumberOfProperties           + 1
                Me%Coupled%FirstOrderDecay%Yes                          = ON
            endif

            if (PropertyX%Evolution%DecayRateProperty) then
                Me%Coupled%DecayRateProperty%NumberOfProperties         = &
                Me%Coupled%DecayRateProperty%NumberOfProperties         + 1
                Me%Coupled%DecayRateProperty%Yes                        = ON
            endif

            if (PropertyX%Evolution%Discharges) then
                Me%Coupled%Discharges%NumberOfProperties                = &
                Me%Coupled%Discharges%NumberOfProperties                + 1
                Me%Coupled%Discharges%Yes                               = ON

                call CheckDischarges (PropertyX)

                if (PropertyX%Evolution%DischargesTracking) then
                    Me%Coupled%DischargesTracking%NumberOfProperties    = &
                    Me%Coupled%DischargesTracking%NumberOfProperties    + 1
                    Me%Coupled%DischargesTracking%Yes                   = ON
                endif

            endif

            if (PropertyX%Evolution%HydroIntegration) then
                Me%Coupled%HydroIntegration%NumberOfProperties          = &
                Me%Coupled%HydroIntegration%NumberOfProperties          + 1
                Me%Coupled%HydroIntegration%Yes                         = ON
            endif

            if (PropertyX%Evolution%DataAssimilation /= NoNudging) then
                Me%Coupled%DataAssimilation%NumberOfProperties          = &
                Me%Coupled%DataAssimilation%NumberOfProperties          + 1
                Me%Coupled%DataAssimilation%Yes                         = ON

                if (PropertyX%Evolution%DataAssimilation == Hybrid)then
                    Me%Coupled%HybridReferenceField = .true.
                end if

            endif

            if (PropertyX%Evolution%MinConcentration) then
                Me%Coupled%MinimumConcentration%NumberOfProperties      = &
                Me%Coupled%MinimumConcentration%NumberOfProperties      + 1
                Me%Coupled%MinimumConcentration%Yes                     = ON
            endif

            if (PropertyX%Evolution%MaxConcentration) then
                Me%Coupled%MaximumConcentration%NumberOfProperties      = &
                Me%Coupled%MaximumConcentration%NumberOfProperties      + 1
                Me%Coupled%MaximumConcentration%Yes                     = ON
            endif

            if (PropertyX%TimeSerie) then
                Me%Coupled%TimeSerie%NumberOfProperties                 = &
                Me%Coupled%TimeSerie%NumberOfProperties                 + 1
                Me%Coupled%TimeSerie%Yes                                = ON
            endif

            if (PropertyX%OutputProfile) then
                Me%Coupled%OutputProfile%NumberOfProperties             = &
                Me%Coupled%OutputProfile%NumberOfProperties             + 1
                Me%Coupled%OutputProfile%Yes                            = ON
            endif

            if (PropertyX%BoxTimeSerie) then
                Me%Coupled%BoxTimeSerie%NumberOfProperties              = &
                Me%Coupled%BoxTimeSerie%NumberOfProperties              + 1
                Me%Coupled%BoxTimeSerie%Yes                             = ON
            endif

            if (PropertyX%Statistics) then
                Me%Coupled%Statistics%NumberOfProperties                = &
                Me%Coupled%Statistics%NumberOfProperties                + 1
                Me%Coupled%Statistics%Yes                               = ON
            endif

            if (PropertyX%ID%SolutionFromFile) then
                Me%Coupled%SolutionFromFile%NumberOfProperties          = &
                Me%Coupled%SolutionFromFile%NumberOfProperties          + 1
                Me%Coupled%SolutionFromFile%Yes                         = ON
            endif

            if (PropertyX%ID%IDNumber == Age_) then
                Me%Coupled%CalculateAge%NumberOfProperties              = 1
                Me%Coupled%CalculateAge%Yes                             = ON
            endif

            if (PropertyX%Evolution%Filtration%On) then
                Me%Coupled%Filtration%NumberOfProperties                = &
                Me%Coupled%Filtration%NumberOfProperties                + 1
                Me%Coupled%Filtration%Yes                               = ON
            endif

            if (.not. PropertyX%ID%SolutionFromFile) then
                Me%Coupled%AllSolutionFromFile = .false.
            endif

            if (PropertyX%Evolution%LagSinksSources) then
                Me%Coupled%LagSinksSources%NumberOfProperties           = &
                Me%Coupled%LagSinksSources%NumberOfProperties           + 1
                Me%Coupled%LagSinksSources%Yes                          = ON
            endif

            if (PropertyX%Evolution%Reinitialize%ON) then
                Me%Coupled%Reinitialize%NumberOfProperties              = &
                Me%Coupled%Reinitialize%NumberOfProperties              + 1
                Me%Coupled%Reinitialize%Yes                             = ON
            endif

            if (PropertyX%Evolution%ImposeDryCells) then
                Me%Coupled%ImposeDryCells%NumberOfProperties            = &
                Me%Coupled%ImposeDryCells%NumberOfProperties            + 1
                Me%Coupled%ImposeDryCells%Yes                           = ON
            endif

            PropertyX=>PropertyX%Next

        end do do1

        if(Me%Coupled%SolutionFromFile%Yes)then

            call CheckOptionsSolutionFromFile

        endif

        !Water-atmosphere fluxes
        if (Me%Coupled%SurfaceFluxes%Yes) then
            Me%Coupled%SurfaceFluxes%NextCompute = Me%ExternalVar%Now
        endif

        if(Me%Coupled%BottomFluxes%Yes) then
            Me%Coupled%BottomFluxes%NextCompute  = Me%ExternalVar%Now
        end if

        if(Me%Coupled%FirstOrderDecay%Yes) then
            Me%Coupled%FirstOrderDecay%NextCompute  = Me%ExternalVar%Now
        end if

        !Advection-diffusion
        if (Me%Coupled%AdvectionDiffusion%Yes) then

            call StartAdvectionDiffusion(Me%ObjAdvectionDiffusion,       &
                                         Me%ObjGeometry,                 &
                                         Me%ObjHorizontalMap,            &
                                         Me%ObjHorizontalGrid,           &
                                         Me%ObjTime,                     &
                                         Vertical1D = Me%ExternalVar%Vertical1D, &
                                         XZFlow     = Me%ExternalVar%XZFlow, &
                                         Docycle_method = Me%Docycle_method, &
#ifdef _ENABLE_CUDA
                                         ObjCudaID  = CudaID,            &
#endif
                                         STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR10')

            call ConstructConvection

            Me%Coupled%AdvectionDiffusion%NextCompute = Me%ExternalVar%Now

        endif

!        Light extinction
        if(Me%Coupled%LightExtinction%Yes .or. SolarRadiationIsNeeded())then

            call CoupleLightExtinction

        end if

        if(Me%Coupled%WQM%Yes .and. Me%Coupled%CEQUALW2%Yes)then

            write(*,*)'Cannot run Water Quality model and CEQUALW2 model in the same simulation.'
            call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR20')
        end if

        if(Me%Coupled%Life%Yes .and. (Me%Coupled%WQM%Yes .or. Me%Coupled%CEQUALW2%Yes))then

            write(*,*)'Cannot run Life and Water Quality/CEQUALW2 model in the same simulation.'
            call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR30')
        end if

        if(Me%Coupled%WWTPQM%Yes .and. (Me%Coupled%WQM%Yes .or. Me%Coupled%CEQUALW2%Yes .or. Me%Coupled%Life%Yes))then

            write(*,*)'Cannot run WWTPQ model and Water Quality/CEQUALW2/LIFE model in the same simulation.'
            call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR40')
        end if


        if(Me%Coupled%WWTPQM%Yes .and. Me%Coupled%Bivalve%Yes )then

            write(*,*)'Cannot run WWTPQ model and Bivalve model in the same simulation.'
            call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR50')
        end if


        if(Me%Coupled%CEQUALW2%Yes .and. Me%Coupled%Bivalve%Yes )then

            write(*,*)'Cannot run CEQUALW2 model and Bivalve model in the same simulation, please choose Life or Water Quality.'
            call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR60')
        end if


        !Water quality
        if(Me%Coupled%WQM%Yes)then

            call CoupleWaterQuality

        end if

        !CEQUALW2
        if(Me%Coupled%CEQUALW2%Yes)then

            call CoupleCEQUALW2

        end if

        !Life
        if(Me%Coupled%Life%Yes)then

            call CoupleLife

        end if

        !Bivalve
        if(Me%Coupled%Bivalve%Yes)then

            call CoupleBivalve

        end if

        !MacroAlgae
        if(Me%Coupled%MacroAlgae%Yes)then

            call CoupleMacroAlgae

        end if

        ! SeagrassesLeaves
        if (Me%Coupled%SeagrassesLeaves%Yes)then

            call CoupleSeagrassesLeaves

        end if

        !WWTPQ
        if(Me%Coupled%WWTPQM%Yes)then

            call CoupleWWTPQ

        end if

#ifdef _PHREEQC_
        !PHREEQC
        if(Me%Coupled%PhreeqC%Yes)then

            call CouplePhreeqC

        end if
#endif

        !Free vertical movement
        if(Me%Coupled%FreeVerticalMovement%Yes) then

#ifdef _ENABLE_CUDA
            ! CudaID needed by ModuleFreeVerticalMovement for Thomas algorithm
            call CoupleFreeVerticalMovement (CudaID)
#else
            call CoupleFreeVerticalMovement
#endif

        end if


        if (Me%Coupled%Discharges%Yes) then

            if (DischargesID == 0)  then
                write(*,*)'You need to define a water discharges in the hydrodynamic input'
                call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR40')
            else
                Me%ObjDischarges = AssociateInstance (mDISCHARGES_, DischargesID)

                Me%Coupled%Discharges%NextCompute = Me%ExternalVar%Now


                !Gets the number of discharges
                call GetDischargesNumber(Me%ObjDischarges, Me%Discharge%Number, STAT=STAT_CALL)

                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Sub_Modules - ModuleWaterProperties - ERR50')

                allocate(Me%Discharge%nCells(Me%Discharge%Number))

                TotalCells = 0

                do dis = 1, Me%Discharge%Number

                    call GetDischargeFlowDistribuiton(Me%ObjDischarges, dis,            &
                                                      Me%Discharge%nCells(dis), STAT = STAT_CALL)

                    if (IsUpscaling(Me%ObjDischarges, dis)) then
                        Me%Coupled%UpscalingDischarge%Yes = .true.
                    endif

                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Sub_Modules - ModuleWaterProperties - ERR60')

                    TotalCells = TotalCells +  Me%Discharge%nCells(dis)

                enddo

                allocate(Me%Discharge%Flow   (TotalCells),                              &
                         Me%Discharge%i      (TotalCells),                              &
                         Me%Discharge%j      (TotalCells),                              &
                         Me%Discharge%k      (TotalCells),                              &
                         Me%Discharge%kmin   (TotalCells),                              &
                         Me%Discharge%kmax   (TotalCells))

                allocate(Me%Discharge%Vert   (Me%Discharge%Number),                     &
                         Me%Discharge%Ignore (Me%Discharge%Number),                     &
                         Me%Discharge%ByPass (Me%Discharge%Number))

                Me%Discharge%Flow   (:) = FillValueReal
                Me%Discharge%i      (:) = FillValueInt
                Me%Discharge%j      (:) = FillValueInt
                Me%Discharge%k      (:) = FillValueInt
                Me%Discharge%kmin   (:) = FillValueInt
                Me%Discharge%kmax   (:) = FillValueInt


                Me%Discharge%Vert   (:) = 0
                Me%Discharge%Ignore (:) = .false.
                Me%Discharge%ByPass (:) = .false.

                PropertyX   => Me%FirstProperty
                do while (associated(PropertyX))
                    if (PropertyX%Evolution%Discharges .and. Me%Discharge%Number > 0) then

                        allocate(PropertyX%DischConc(TotalCells))

                        PropertyX%DischConc(1:TotalCells) = FillValueReal

                    endif
                    PropertyX=>PropertyX%Next
                enddo


                !For every discharge with Track Discharge Information construct a new time serie
                if (Me%Coupled%DischargesTracking%Yes) call Construct_Discharges_Tracking
            endif



        endif

        !HydroIntegration
        if (Me%Coupled%HydroIntegration%Yes) then

            call CoupleHydroIntegration

        endif

        !Partition
        if (Me%Coupled%Partition%Yes) then

            call ConstructPartition

        end if

        if (Me%Coupled%DataAssimilation%Yes .or. Me%Coupled%AltimetryAssimilation%Yes .or. &
            Me%NoFlux%ON) then

            if(AssimilationID == 0)then

                call StartAssimilation(Me%ObjAssimilation,                              &
                                       Me%ObjTime,                                      &
                                       Me%ObjGridData,                                  &
                                       Me%ObjHorizontalGrid,                            &
                                       Me%ObjHorizontalMap,                             &
                                       Me%ObjMap,                                       &
                                       Me%ObjGeometry,                                  &
                                       TwoWayID = Me%ObjTwoWay,                         &
                                       STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Sub_Modules - WaterProperties - ERR70')

            else

                Me%ObjAssimilation = AssociateInstance (mASSIMILATION_, AssimilationID)

            end if

            Me%Coupled%DataAssimilation%NextCompute = Me%ExternalVar%Now
            
            call CheckOfflineUpscaling !Sobrinho

        endif

        !Construct the Altim Assimilation Guillaume e nogueira
        if(Me%Coupled%AltimetryAssimilation%Yes)then

            call ConstructAltimAssimilation

        end if


        if(Me%Coupled%HybridReferenceField)then

            call ConstructHybridWeights

        endif


        !check outputs that can be used by timeseries, profile, hdf, etc
        call CheckAditionalOutputs


        if(Me%Coupled%TimeSerie%Yes)then

            call Construct_Time_Serie

        end if

        if(Me%Coupled%OutputProfile%Yes)then

            call Construct_Output_Profile

        end if

        if(Me%Coupled%BoxTimeSerie%Yes)then
            Me%Coupled%BoxTimeSerie%NextCompute = Me%ExternalVar%Now
            call StartOutputBoxFluxes
        end if

        if (Me%Coupled%CalculateAge%Yes) then

            call ConstructAge

        endif

        !Filtration
        if(Me%Coupled%Filtration%Yes) then
            Me%Coupled%Filtration%NextCompute  = Me%ExternalVar%Now
        end if

        PropertyX => Me%FirstProperty
        do while (associated(PropertyX))

            if (PropertyX%Statistics) then

                call ConstructStatistic (StatisticID      = PropertyX%StatisticID,      &
                                         ObjTime          = Me%ObjTime,                 &
                                         ObjHDF5          = Me%ObjHDF5,                 &
                                         DataFile         = PropertyX%StatisticsFile,   &
                                         Size             = Me%Size,                    &
                                         WorkSize         = Me%WorkSize,                &
                                         Name             = PropertyX%ID%name,          &
                                         STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_Sub_Modules - ModuleWaterProperties - ERR80')

            endif

            PropertyX => PropertyX%Next

        enddo



    end subroutine Construct_Sub_Modules


    !--------------------------------------------------------------------------


    subroutine CheckOptionsSolutionFromFile

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                       :: PropertyX

        !----------------------------------------------------------------------

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%ID%SolutionFromFile)then

                if(PropertyX%Evolution%WaterQuality                  .or. &
                   PropertyX%Evolution%MacroAlgae                    .or. &
                   PropertyX%Evolution%SeagrassesLeaves              .or. &
                   PropertyX%Evolution%CEQUALW2                      .or. &
                   PropertyX%Evolution%Life                          .or. &
                   !PropertyX%Evolution%Bivalve                       .or. &
                   PropertyX%Evolution%WWTPQ                         .or. &
                   PropertyX%Evolution%Partitioning                  .or. &
                   PropertyX%Evolution%FreeVerticalMovement          .or. &
                   PropertyX%Evolution%AdvectionDiffusion            .or. &
                   PropertyX%Evolution%Discharges                    .or. &
                   PropertyX%Evolution%SurfaceFluxes                 .or. &
                   PropertyX%Evolution%BottomFluxes                  .or. &
                   PropertyX%Evolution%FirstOrderDecay               .or. &
                   PropertyX%Evolution%HydroIntegration              .or. &
                   PropertyX%Evolution%DataAssimilation /= NoNudging .or. &
                   PropertyX%Evolution%MinConcentration              .or. &
                   PropertyX%Evolution%MaxConcentration              .or. &
                   PropertyX%Evolution%InstantMixing                 .or. &
                   PropertyX%Evolution%LagSinksSources               .or. &
                   PropertyX%Evolution%Filtration%On ) then

                    write(*,*)'Property '//trim(PropertyX%ID%Name)//' solution is read from file.'
                    call CloseAllAndStop ('CheckOptionsSolutionFromFile - ModuleWaterProperties - ERR01')

                endif

            end if

            PropertyX => PropertyX%Next
        enddo


    end subroutine CheckOptionsSolutionFromFile


    !--------------------------------------------------------------------------

    subroutine ConstructAge

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                       :: PropertyX
        integer                                         :: iflag, STAT_CALL


        !Begin-----------------------------------------------------------------

        Me%Coupled%CalculateAge%NextCompute  = Me%ExternalVar%Now

        call Search_Property(PropertyX, PropertyXID = Age_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructAge - ModuleWaterProperties - ERR01')

        if (PropertyX%Evolution%WaterQuality .or. PropertyX%Evolution%WWTPQ) then
            write(*,*)'Property Age cannot use module Waterquality or WWTPQ as sink and source model'
            write(*,*)'Age evolution is automaticly calculated by module Waterproperties'
            write(*,*)'Set WQM and WWTPQ for property age to 0'
            call CloseAllAndStop ('ConstructAge - ModuleWaterProperties - ERR02')
        endif

        select case (trim(adjustl(PropertyX%ID%Units)))

            case ('seconds', 'Seconds', 'SECONDS')
                !OK
            case ('hours', 'Hours', 'HOURS')
                !OK
            case ('days', 'Days', 'DAYS')
                !OK
            case default
                write(*,*)'Invalid units of property age'
                write(*,*)'Use SECONDS, HOURS or DAYS'
                call CloseAllAndStop ('ConstructAge - ModuleWaterProperties - ERR03')
        end select


        call GetData(Me%Age%UseWaterPoints,                                             &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'AGE_USING_WATERPOINTS',                            &
                     Default      = .false.,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('ConstructAge - ModuleWaterProperties - ERR01')

        if(Me%Age%UseWaterPoints)then
            write(*,*)'Property Age will be computed using WaterPoints'
        end if


    end subroutine ConstructAge

    !----------------------------------------------------------------------

    subroutine CoupleLightExtinction

        !External--------------------------------------------------------------
        integer                                         :: STAT_CALL

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                       :: PropertyX
        integer                                         :: ILB, IUB, JLB, JUB, KLB, KUB, ClientNumber
        logical                                         :: NeedsPhyto       = .false.
        logical                                         :: NeedsSPM         = .false.
        logical                                         :: FoundPhyto       = .false.
        logical                                         :: FoundDiatoms     = .false.
        logical                                         :: BlockFound       = .false.

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB


        call ConstructLightExtinction(LightExtinctionID = Me%ObjLightExtinction,        &
                                      TimeID            = Me%ObjTime,                   &
                                      EnterDataID       = Me%ObjEnterData,              &
                                      Size              = Me%Size,                      &
                                      WorkSize          = Me%WorkSize,                  &
                                      MacroAlgaeON      = Me%Coupled%MacroAlgae%Yes,    &
                                      STAT              = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR10')

        allocate (Me%SolarRadiation%ShortWaveTop    (ILB:IUB, JLB:JUB, KLB:KUB))
        Me%SolarRadiation%ShortWaveTop     = FillValueReal

        allocate (Me%SolarRadiation%ShortWaveAverage(ILB:IUB, JLB:JUB, KLB:KUB))
        Me%SolarRadiation%ShortWaveAverage = FillValueReal

        allocate (Me%SolarRadiation%LongWaveTop     (ILB:IUB, JLB:JUB, KLB:KUB))
        Me%SolarRadiation%LongWaveTop      = FillValueReal

        call GetLightExtinctionOptions(LightExtinctionID = Me%ObjLightExtinction,       &
                                       NeedsPhyto        = NeedsPhyto,                  &
                                       NeedsSPM          = NeedsSPM,                    &
                                       STAT              = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR20')

        if(NeedsPhyto)then

            call Search_Property(PropertyX, PropertyXID = Phytoplankton_, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then
                FoundPhyto = .true.
                PropertyX%Evolution%LightExtinction = .true.

            else
                if (STAT_CALL == NOT_FOUND_ERR_) then
                    FoundPhyto = .false.
                else
                    call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR30')
                endif
            end if

            call Search_Property(PropertyX, PropertyXID = Diatoms_, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then
                FoundDiatoms = .true.
                PropertyX%Evolution%LightExtinction = .true.
            else
                if (STAT_CALL == NOT_FOUND_ERR_) then
                    FoundDiatoms = .false.
                else
                    call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR40')
                endif
            end if

            if (FoundPhyto .and. FoundDiatoms)then
                write(*,*)'Only one algae (phytoplankton or diatoms) can be defined'
                write(*,*)'when using this light extinction compute type.'
                write(*,*)'Check WaterProperties and LightExctinction options'
                call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR50')
            end if


            if ((.not. FoundPhyto) .and. (.not. FoundDiatoms))then
                write(*,*)'At least algae (phytoplankton or diatoms) must be defined'
                write(*,*)'Check WaterProperties and LightExctinction options'
                call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR60')
            end if

        end if

        if(NeedsSPM)then

            call Search_Property(PropertyX, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR70')

            PropertyX%Evolution%LightExtinction = .true.

        end if

        Me%SolarRadiation%Shading%ON  = .false.

        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                       &
                                    shading_begin, shading_end, BlockFound,              &
                                    STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR80')

        if(BlockFound)then

            nullify(Me%SolarRadiation%Shading%Field)
            allocate(Me%SolarRadiation%Shading%Field(ILB:IUB, JLB:JUB))

            Me%SolarRadiation%Shading%ON = .true.

            call ConstructFillMatrix(PropertyID        = Me%SolarRadiation%Shading%ID,    &
                                     EnterDataID       = Me%ObjEnterData,               &
                                     TimeID            = Me%ObjTime,                    &
                                     HorizontalGridID  = Me%ObjHorizontalGrid,          &
                                     ExtractType       = FromBlock,                     &
                                     PointsToFill2D    = Me%ExternalVar%WaterPoints2D,  &
                                     Matrix2D          = Me%SolarRadiation%Shading%Field, &
                                     TypeZUV           = TypeZ_,                        &
                                     ClientID          = ClientNumber,                  &
                                     STAT              = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleInterfaceSedimentWater - ERR90')

            call GetDefaultValue(Me%SolarRadiation%Shading%ID%ObjFillMatrix,              &
                                 Me%SolarRadiation%Shading%Scalar,                        &
                                 STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleInterfaceSedimentWater - ERR100')

            call KillFillMatrix(Me%SolarRadiation%Shading%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR110')

            call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR120')

        endif

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR130')

        call ConstructRadiationProp2D(Property_2D = Me%SolarRadiation%ShortWave_Kd_2D,  &
                                      block_begin = SW_Kd_2D_begin,                     &
                                      block_end   = SW_Kd_2D_end)

         if (Me%SolarRadiation%ShortWave_Kd_2D%ON) then

            call UpdateLightExtinctionSatellite(LightExtinctionID = Me%ObjLightExtinction,                    &
                                                SatelliteKd2D     = Me%SolarRadiation%ShortWave_Kd_2D%Field,  &
                                                STAT              = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleLightExtinction - ModuleWaterProperties - ERR140')

        endif

        Me%Coupled%LightExtinction%NextCompute = Me%ExternalVar%Now

    end subroutine CoupleLightExtinction


    !--------------------------------------------------------------------------

    subroutine ConstructRadiationProp2D(Property_2D, block_begin, block_end)

        !Arguments--------------------------------------------------------------
        type (T_Property_2D)                            :: Property_2D
        character(len=*)                                :: block_begin, block_end

        !Local-----------------------------------------------------------------
        integer                                         :: STAT_CALL
        integer                                         :: ILB, IUB, JLB, JUB, ClientNumber
        logical                                         :: BlockFound       = .false.

        !----------------------------------------------------------------------


        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        Property_2D%ON  = .false.

        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                      &
                                    block_begin, block_end, BlockFound,                 &
                                    STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) then
            call CloseAllAndStop ('ConstructRadiationProp2D - ModuleWaterProperties - ERR10')
        endif

        if(BlockFound)then

            nullify (Property_2D%Field)
            allocate(Property_2D%Field(ILB:IUB, JLB:JUB))

            Property_2D%ON = .true.

            call ConstructFillMatrix(PropertyID        = Property_2D%ID,                &
                                     EnterDataID       = Me%ObjEnterData,               &
                                     TimeID            = Me%ObjTime,                    &
                                     HorizontalGridID  = Me%ObjHorizontalGrid,          &
                                     ExtractType       = FromBlock,                     &
                                     PointsToFill2D    = Me%ExternalVar%WaterPoints2D,  &
                                     Matrix2D          = Property_2D%Field,             &
                                     TypeZUV           = TypeZ_,                        &
                                     ClientID          = ClientNumber,                  &
                                     STAT              = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) then
                call CloseAllAndStop ('ConstructRadiationProp2D - ModuleInterfaceSedimentWater - ERR20')
            endif

            if (Property_2D%ID%SolutionFromFile) then

                Property_2D%Constant = .false.

            else

                Property_2D%Constant = .true.

                call KillFillMatrix(Property_2D%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) then
                    call CloseAllAndStop ('ConstructRadiationProp2D - ModuleWaterProperties - ERR40')
                endif

            endif

            call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) then
                call CloseAllAndStop ('ConstructRadiationProp2D - ModuleWaterProperties - ERR50')
            endif

        endif

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) call CloseAllAndStop ('ConstructRadiationProp2D - ModuleWaterProperties - ERR60')

    end subroutine ConstructRadiationProp2D

    !-----------------------------------------------------------------------------------


    subroutine CoupleWaterQuality

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: WaterQualityPropertyList
        integer                                             :: STAT_CALL
        real                                                :: WaterQualityDT
        integer                                             :: Index = 0
        !----------------------------------------------------------------------

        Index = 0

        nullify (WaterQualityPropertyList)
        allocate(WaterQualityPropertyList(1:Me%Coupled%WQM%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%WaterQuality)then

                Index = Index + 1
                WaterQualityPropertyList(Index)  = PropertyX%ID%IDNumber

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)


        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = WaterQualityModel,             &
                                DT                  = WaterQualityDT,                &
                                PropertiesList      = WaterQualityPropertyList,      &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,  &
                                Size3D              = Me%WorkSize,                   &
                                Vertical1D          = Me%ExternalVar%Vertical1D,     &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            call CloseAllAndStop ('CoupleWaterQuality - ModuleWaterProperties - ERR01')

        Me%Coupled%WQM%DT_Compute  = WaterQualityDT
        Me%Coupled%WQM%NextCompute = Me%ExternalVar%Now

        deallocate(WaterQualityPropertyList)
        nullify   (WaterQualityPropertyList)

    end subroutine CoupleWaterQuality

    !--------------------------------------------------------------------------


    subroutine CoupleCEQUALW2

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: CEQUALW2PropertyList
        integer                                             :: STAT_CALL
        real                                                :: CEQUALW2DT
        integer                                             :: Index = 0
        !----------------------------------------------------------------------

        Index = 0

        nullify (CEQUALW2PropertyList)
        allocate(CEQUALW2PropertyList(1:Me%Coupled%CEQUALW2%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%CEQUALW2)then

                Index = Index + 1
                CEQUALW2PropertyList(Index)  = PropertyX%ID%IDNumber

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)


        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = CEQUALW2Model,                 &
                                DT                  = CEQUALW2DT,                    &
                                PropertiesList      = CEQUALW2PropertyList,          &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,  &
                                Size3D              = Me%WorkSize,                   &
                                Vertical1D          = Me%ExternalVar%Vertical1D,     &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            call CloseAllAndStop ('CoupleCEQUALW2 - ModuleWaterProperties - ERR01')

        Me%Coupled%CEQUALW2%DT_Compute   = CEQUALW2DT
        Me%Coupled%CEQUALW2%NextCompute  = Me%ExternalVar%Now

        deallocate(CEQUALW2PropertyList)
        nullify   (CEQUALW2PropertyList)

    end subroutine CoupleCEQUALW2


    !--------------------------------------------------------------------------

    subroutine CoupleLife

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: LifePropertyList
        integer                                             :: STAT_CALL
        real                                                :: LifeDT
        integer                                             :: Index = 0
        !----------------------------------------------------------------------

        Index = 0

        nullify (LifePropertyList)
        allocate(LifePropertyList(1:Me%Coupled%Life%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%Life)then

                Index = Index + 1
                LifePropertyList(Index)  = PropertyX%ID%IDNumber

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)


        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = LifeModel,                     &
                                DT                  = LifeDT,                        &
                                PropertiesList      = LifePropertyList,              &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,  &
                                Size3D              = Me%WorkSize,                   &
                                Vertical1D          = Me%ExternalVar%Vertical1D,     &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            call CloseAllAndStop ('CoupleLife - ModuleWaterProperties - ERR01')

        Me%Coupled%Life%DT_Compute   = LifeDT
        Me%Coupled%Life%NextCompute  = Me%ExternalVar%Now

        deallocate(LifePropertyList)
        nullify   (LifePropertyList)

    end subroutine CoupleLife

    !--------------------------------------------------------------------------

    subroutine CoupleBivalve

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: BivalvePropertyList
        integer                                             :: STAT_CALL
        real                                                :: BivalveDT
        integer                                             :: Index = 0
        integer                                             :: BivalveID = 0
        character(len = StringLength)                       :: FileName
        character(len = StringLength)                       :: Message
        !----------------------------------------------------------------------

        nullify(Me%Bivalve%FirstSpecies)

        ! ---> File in HDF format where is written instant fields of bivalve
        Message   ='Instant fields of bivalve in HDF format.'
        Message   = trim(Message)

        call ReadFileName('BIV_HDF', FileName,                                          &
                           Message = Message, TIME_END = Me%EndTime,                    &
                           Extension = 'elt',                                           &
                           MPI_ID    = Me%DDecomp%MPI_ID,                               &
                           DD_ON     = Me%DDecomp%ON,                                   &
                           STAT      = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('CoupleBivalve - ModuleWaterProperties - ERR00')

        Me%Bivalve%BivalveHDFOutputFile = trim(FileName)//"5"

        call ConstructSpeciesList

        Me%Coupled%Bivalve%NumberOfProperties = Me%Coupled%Bivalve%NumberOfProperties +  &
                                                Me%Bivalve%nPropertiesFromBivalve

        Index = 0

        nullify (BivalvePropertyList)
        allocate(BivalvePropertyList(1:Me%Coupled%Bivalve%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%Bivalve)then

                Index = Index + 1
                BivalvePropertyList(Index)  = PropertyX%ID%IDNumber

            end if

            if (((PropertyX%ID%Name .eq. 'shrimp')        .or. (PropertyX%ID%Name .eq. 'crab')       .or. &
                (PropertyX%ID%Name .eq. 'oystercatcher') .or. (PropertyX%ID%Name .eq. 'eider duck') .or. &
                (PropertyX%ID%Name .eq. 'herring gull')) .and. (PropertyX%ID%Units .ne. '#/m2')) then

                write (*,*) 'WARNING: predators units must be in #/m2'
                call CloseAllAndStop ('CoupleBivalve - ModuleWaterProperties - ERR01')

            end if


            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)

        call ConstructInterface(InterfaceID         = Me%ObjInterfaceBivalve,        &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = BivalveModel,                  &
                                DT                  = BivalveDT,                     &
                                PropertiesList      = BivalvePropertyList,           &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,  &
                                Size3D              = Me%WorkSize,                   &
                                Vertical1D          = Me%ExternalVar%Vertical1D,     &
                                BivalveID           = BivalveID,                     &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            call CloseAllAndStop ('CoupleBivalve - ModuleWaterProperties - ERR01')

        Me%ObjBivalve = AssociateInstance (mBIVALVE_, BivalveID)

        Me%Coupled%Bivalve%DT_Compute   = BivalveDT

        Me%Coupled%Bivalve%NextCompute  = Me%ExternalVar%Now

        deallocate(BivalvePropertyList)
        nullify   (BivalvePropertyList)

        call SetSpeciesSettlementProbability

        call UpdateLarvaeDistribution

        call ConstructBivalveOutput

    end subroutine CoupleBivalve

    !--------------------------------------------------------------------------

    subroutine SetSpeciesSettlementProbability

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Species) , pointer         :: Species

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "SetSpeciesSettlementProbability")

        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

            call SetSettlementOnInterface (InterfaceID           = Me%ObjInterfaceBivalve,          &
                                           SpeciesIDNumber       = Species%ID%IDNumber  ,           &
                                           SettlementProbability = Species%SettlementProbability,   &
                                           STAT                  = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('SetSpeciesSettlementProbability - ModuleWaterProperties - ERR01')

            deallocate(Species%SettlementProbability)
            nullify   (Species%SettlementProbability)

            Species  => Species%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "SetSpeciesSettlementProbability")

    end subroutine SetSpeciesSettlementProbability

    !--------------------------------------------------------------------------

    subroutine ConstructBivalveOutput
        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                                             :: STAT_CALL
        integer                                             :: iflag
        logical                                             :: Exist, Opened

        !Local-----------------------------------------------------------------
        type (T_Species), pointer                   :: Species
        character(len=StringLength), dimension(:),  pointer :: ScalarOutputList
        character(len=StringLength), dimension(:),  pointer :: FluxesOutputList
        integer                                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                             :: nSpeciesBoxTimeSerie
        integer                                             :: nTotalClasses, n, iClass
        integer                                             :: nScalars, nFluxes

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        nSpeciesBoxTimeSerie  = 0
        nTotalClasses         = 0

        Species => Me%Bivalve%FirstSpecies

        !check for population outputs for the Bivalve
        do while (associated(Species))

            if ((Species%PopulationHDF) .or. (Species%BySizeOutputHDF)) then
                Me%Bivalve%OutputHDF = .true.
            endif

            if (Species%PopulationBoxTimeSerie)then
                Me%Bivalve%OutputBoxTimeSerie = .true.
                nSpeciesBoxTimeSerie = nSpeciesBoxTimeSerie + 1
            end if

            if (Species%BySizeBoxTimeSerie)then
                Me%Bivalve%OutputBoxTimeSerie = .true.
                nTotalClasses = nTotalClasses + Species%NumberSizeClasses
            end if

            if (Me%Bivalve%OutputHDF .or. Me%Bivalve%OutputBoxTimeSerie) then

            call GetBivalveOtherParameters (Bivalve_ID      = Me%ObjBivalve       , &
                                            SpeciesIDNumber = Species%ID%IDNumber , &
                                            MinObsLength    = Species%MinObsLength, &
                                            STAT            = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR01')

            nullify (Species%TotalDensity)
            allocate(Species%TotalDensity(ILB:IUB,JLB:JUB,KLB:KUB))

            nullify (Species%FieldDensity)
            allocate(Species%FieldDensity(ILB:IUB,JLB:JUB,KLB:KUB))

            nullify (Species%TotalBiomass)
            allocate(Species%TotalBiomass(ILB:IUB,JLB:JUB,KLB:KUB))

            nullify (Species%CohortsNumber)
            allocate(Species%CohortsNumber(ILB:IUB,JLB:JUB,KLB:KUB))

            end if

            Species => Species%Next

        end do

        if (Me%Bivalve%OutputHDF) then

            call Open_HDF5_OutPut_File(FileNameIN = Me%Bivalve%BivalveHDFOutputFile, ObjHDF5External = Me%Bivalve%ObjHDF5)

        end if

        if (Me%Bivalve%OutputBoxTimeSerie) then

            call GetData(Me%Files%BoxesFile,                                            &
                         Me%ObjEnterData, iflag,                                        &
                         keyword      = 'BOXFLUXES',                                    &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR10')
            if (iflag .EQ. 0)                                                           &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR20')

            inquire(File = Me%Files%BoxesFile, Exist = exist)
            if (exist) then
                inquire(File = Me%Files%BoxesFile, Opened  = Opened)
                if (opened) then
                    write(*,*    )
                    write(*,'(A)') 'BoxesFile = ',trim(adjustl(Me%Files%BoxesFile))
                    write(*,*    ) 'Already opened.'
                    call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR30')
        end if
            else
                write(*,*)
                write(*,*)     'Could not find the boxes file.'
                write(*,'(A)') 'BoxFileName = ', Me%Files%BoxesFile
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR40')
            end if

            ! TotalDensity, FieldDensity, TotalBiomass, CohortsNumber + all the classes
            nScalars = nSpeciesBoxTimeSerie * 3 + nSpeciesBoxTimeSerie * nTotalClasses + 1
            nFluxes  = nSpeciesBoxTimeSerie * 3 + nSpeciesBoxTimeSerie * nTotalClasses + 1

            allocate(ScalarOutputList(nScalars), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR50')

            allocate(FluxesOutputList(nFluxes), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR60')

            n = 1

            ScalarOutputList(n) = trim('BoxArea')

            Species => Me%Bivalve%FirstSpecies

            !check for population outputs for the Bivalve
            do while (associated(Species))

                n = n + 1

                ScalarOutputList(n) = trim(Species%ID%Name)//'_'//trim('TotalDensity')
                n = n + 1
                ScalarOutputList(n) = trim(Species%ID%Name)//'_'//trim('FieldDensity')
                n = n + 1
                ScalarOutputList(n) = trim(Species%ID%Name)//'_'//trim('TotalBiomass')

                if (Species%BySizeBoxTimeSerie) then

                    do iClass = 1, Species%NumberSizeClasses

                        n = n + 1
                        ScalarOutputList(n) = trim(Species%ID%Name)//'_'//trim(Species%SizeClasses(iClass)%Name)


                    enddo

                end if

                Species => Species%Next

            end do

            FluxesOutputList = ScalarOutputList

            call StartBoxDif(BoxDifID           = Me%Bivalve%ObjBoxDif,         &
                             TimeID             = Me%ObjTime,                   &
                             HorizontalGridID   = Me%ObjHorizontalGrid,         &
                             BoxesFilePath      = Me%Files%BoxesFile,           &
                             !FluxesOutputList   = FluxesOutputList,             &
                             ScalarOutputList   = ScalarOutputList,             &
                             WaterPoints3D      = Me%ExternalVar%WaterPoints3D, &
                             Size3D             = Me%Size,                      &
                             WorkSize3D         = Me%WorkSize,                  &
                             STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR60')

!            call GetDTBoxes(Me%Bivalve%ObjBoxDif,Me%Coupled%BoxTimeSerie%DT_Compute, STAT_CALL)
!            if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR09')

            deallocate(FluxesOutputList, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR70')

            deallocate(ScalarOutputList, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR80')

            allocate(Me%CellMass(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('ConstructBivalveOutput - ModuleWaterProperties - ERR90')
            Me%CellMass(:,:,:) = 0.

        end if

        if ((Me%Bivalve%OutputHDF) .or. (Me%Bivalve%OutputBoxTimeSerie)) then

            call BivalveOutput

        end if

    end subroutine ConstructBivalveOutput

    !--------------------------------------------------------------------------

    subroutine CoupleMacroAlgae

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: MacroAlgaePropertyList
        integer                                             :: STAT_CALL, iflag
        real                                                :: MacroAlgaeDT
        integer                                             :: Index = 0
        integer                                             :: ILB, IUB, JLB, JUB, KLB, KUB

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !gC/m2
        call GetData(Me%MacroAlgae%DefaultValue,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'MACROALGAE_MASS',                                &
                     Default        = 0.001,                                            &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR02')
        if (iflag == 0)            call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR03')

        call GetData(Me%MacroAlgae%VariableHeight,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'VARIABLE_MACR_HEIGHT',                              &
                     Default        = .false.,                                             &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR04')

        if ((iflag == 0) .or. (.not.Me%MacroAlgae%VariableHeight))  then
        !m
        call GetData(Me%MacroAlgae%HeightConstant,                                      &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'MACROALGAE_HEIGHT',                              &
                     Default        = 0.25,                                             &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR05')
        if (iflag == 0)            call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR06')
        endif

        allocate(Me%MacroAlgae%Height  (ILB:IUB, JLB:JUB)) !m


        if (Me%MacroAlgae%VariableHeight) then


        call GetData(Me%MacroAlgae%HBRatio,                           &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'MACR_HEIGHT_BIOMASS_RATIO',                           &
                     Default        = 0.002,                                            &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR08')
        if (iflag == 0)            call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR09')


        Me%MacroAlgae%Height   (:,:) = Me%MacroAlgae%DefaultValue * &
                                                        Me%MacroAlgae%HBRatio
        else

        Me%MacroAlgae%Height   (:,:) = Me%MacroAlgae%HeightConstant

        endif

        allocate(Me%MacroAlgae%Distribution  (ILB:IUB, JLB:JUB)) !gC/m2
        Me%MacroAlgae%Distribution   (:,:) = Me%MacroAlgae%DefaultValue

        allocate(Me%MacroAlgae%ShearStress3D (ILB:IUB, JLB:JUB, KLB:KUB))
        Me%MacroAlgae%ShearStress3D  (:,:,:) = FillValueReal

        allocate(Me%MacroAlgae%SPMDepFlux3D  (ILB:IUB, JLB:JUB, KLB:KUB))
        Me%MacroAlgae%SPMDepFlux3D   (:,:,:) = FillValueReal

        allocate(Me%MacroAlgae%Occupation    (ILB:IUB, JLB:JUB, KLB:KUB))
        Me%MacroAlgae%Occupation     (:,:,:) = 0.

        !allocate(Me%MacroAlgae%DistFromTop    (ILB:IUB, JLB:JUB, KLB:KUB))
        !Me%MacroAlgae%DistFromTop     (:,:,:) = 0.

        allocate(Me%MacroAlgae%MaxShearStress(ILB:IUB, JLB:JUB         ))
        Me%MacroAlgae%MaxShearStress (:,:  ) = 0.

        allocate(Me%MacroAlgae%MaxSPMDepFlux (ILB:IUB, JLB:JUB         ))
        Me%MacroAlgae%MaxSPMDepFlux  (:,:  ) = 0.

        Index = 0

        nullify (MacroAlgaePropertyList)
        allocate(MacroAlgaePropertyList(1:Me%Coupled%MacroAlgae%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%MacroAlgae)then

                Index = Index + 1
                MacroAlgaePropertyList(Index) = PropertyX%ID%IDNumber

            end if

            if(PropertyX%ID%IDNumber == MacroAlgae_)then

                if(PropertyX%Old)then
                    call IntegrateMacroAlgae(PropertyX)
                else
                    call ComputeMacroAlgaeOccupation
                    call DistributeMacroAlgae
                end if

                if(PropertyX%Evolution%AdvectionDiffusion)then

                    write(*,*)
                    write(*,*)'Macroalgae can not have ADVECTION_DIFFUSION'
                    write(*,*)'ADVECTION_DIFFUSION will be switched off'

                    PropertyX%Evolution%AdvectionDiffusion = OFF

                end if

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)

        call ConstructInterface(InterfaceID         = Me%ObjInterfaceMacroAlgae,     &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = MacroAlgaeModel,               &
                                DT                  = MacroAlgaeDT,                  &
                                PropertiesList      = MacroAlgaePropertyList,        &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,  &
                                Size3D              = Me%WorkSize,                   &
                                Vertical1D          = Me%ExternalVar%Vertical1D,     &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            call CloseAllAndStop ('CoupleMacroAlgae - ModuleWaterProperties - ERR01')

        Me%Coupled%MacroAlgae%DT_Compute   = MacroAlgaeDT
        Me%Coupled%MacroAlgae%NextCompute  = Me%ExternalVar%Now

        deallocate(MacroAlgaePropertyList)
        nullify   (MacroAlgaePropertyList)


    end subroutine CoupleMacroAlgae

    !--------------------------------------------------------------------------
 !------------------------------------------------------------------------------

     subroutine CoupleSeagrassesLeaves

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX

        integer, pointer, dimension(:)                      :: SeagrassesLeavesPropertyList
        integer                                             :: STAT_CALL, iflag, ClientNumber
        real                                                :: SeagrassesLeavesDT
        integer                                             :: Index = 0
        integer                                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                             :: i, j
        logical                                             :: BlockFound


        ! this subroutine was created to allocate arrays which values
        ! will be calculated in the module SeagrassWaterInteraction
        ! The only reason to create 3d arrays is that the it is not possible to
        ! access the information of ModuleInterfaceSedimentWater from ModuleWaterProperty,
        ! because of dependences in the code.
        !
        ! InterfaceSedimentWater gets those arrays from ModuleWaterProperty,
        ! converts them into 2d arrays and passes them to BenthicEcology module.
        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !g DW/m2
        call GetData(Me%SeagrassesLeaves%DefaultValue,                       &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'LEAVES_MASS',                                &
                     Default        = 0.001,                                            &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties- ERR02')
        if (iflag == 0)            call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties- ERR03')

        !m
        call GetData(Me%SeagrassesLeaves%LBratio,                           &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'LEAVES_LBRATIO',                           &
                     Default        = 0.003,                                            &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties- ERR04')
        if (iflag == 0)            call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties- ERR05')




        ! Leaves Biomass should be initialized in module InterfaceSedimentWater, but it is initialized here because
        ! the constructor of module InterfaceSedimentWater is executed after the constructor of WaterProperties.
        ! Module WaterProperties needs the value of the leaves biomass to calculate the leaves occupation
        ! already during the constructor phase.
        !
        allocate(Me%SeagrassesLeaves%Biomass  (ILB:IUB, JLB:JUB)) !gdw/m2
        Me%SeagrassesLeaves%Biomass   (:,:) = Me%SeagrassesLeaves%DefaultValue


        ! If initialization is carried out by using boxes,
        ! the matrix values will be replaced with boxes values
         call ExtractBlockFromBuffer(Me%ObjEnterData,                                &
                                        ClientNumber    = ClientNumber,                 &
                                        block_begin     = "<begin_leaves_biomass>",        &
                                        block_end       = "<end_leaves_biomass>",          &
                                        BlockFound      = BlockFound,                   &
                                        STAT            = STAT_CALL)
cd11 :       if (STAT_CALL .EQ. SUCCESS_     ) then
cd12 :       if (BlockFound) then


                call ConstructFillMatrix  (PropertyID           = Me%SeagrassesLeaves%ID,           &
                                           EnterDataID          = Me%ObjEnterData,                  &
                                           TimeID               = Me%ObjTime,                       &
                                           HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                           ExtractType          = FromBlock,                        &
                                           PointsToFill2D       = Me%ExternalVar%WaterPoints2D,     &
                                           Matrix2D             = Me%SeagrassesLeaves%Biomass,      &
                                           TypeZUV              = TypeZ_,                           &
                                           STAT                 = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                          &
                    call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties - ERR07')


                call KillFillMatrix(Me%SeagrassesLeaves%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)&
                    call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties - ERR08')

            endif cd12

            call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties - ERR08a')

            endif cd11



        allocate(Me%SeagrassesLeaves%Length  (ILB:IUB, JLB:JUB)) !gdw/m2
          do j = JLB, JUB
            do i = ILB, IUB

              Me%SeagrassesLeaves%Length   (i,j) = Me%SeagrassesLeaves%Biomass(i, j) * &
                                                        Me%SeagrassesLeaves%LBRatio

            enddo
          enddo

        ! Allocation of arrays which values
        ! will be calculated in the module SeagrassWaterInteraction
        allocate(Me%SeagrassesLeaves%Occupation    (ILB:IUB, JLB:JUB, KLB:KUB))
        Me%SeagrassesLeaves%Occupation(:,:,:) = 0.


        allocate (Me%SeagrassesLeaves%NintFactor3D(ILB:IUB,JLB:JUB,KLB:KUB))
        Me%SeagrassesLeaves%NintFactor3D(:,:,:) =0.


        allocate (Me%SeagrassesLeaves%NintFactor2D(ILB:IUB,JLB:JUB))
        Me%SeagrassesLeaves%NintFactor2D(:,:) =0.

        allocate (Me%SeagrassesLeaves%PintFactor3D(ILB:IUB,JLB:JUB,KLB:KUB))
        Me%SeagrassesLeaves%PintFactor3D(:,:,:) =0.

        allocate (Me%SeagrassesLeaves%PintFactor2D(ILB:IUB,JLB:JUB))
        Me%SeagrassesLeaves%PintFactor2D(:,:) =0.


       allocate(Me%SeagrassesLeaves%UptakeNH4NO3w3D(ILB:IUB,JLB:JUB,KLB:KUB))

       allocate(Me%SeagrassesLeaves%UptakePO4w3D(ILB:IUB,JLB:JUB,KLB:KUB))

       allocate(Me%SeagrassesLeaves%LightFactor3D(ILB:IUB,JLB:JUB,KLB:KUB))

       allocate(Me%SeagrassesLeaves%Volume(ILB:IUB,JLB:JUB,KLB:KUB))
       Me%SeagrassesLeaves%UptakeNH4NO3w3D=0.
       Me%SeagrassesLeaves%UptakePO4w3D=0.
       Me%SeagrassesLeaves%UptakePO4w3D=0.
       Me%SeagrassesLeaves%Volume=0.

        ! allocare Me%Rates come array 2d


        Index = 0

        nullify (SeagrassesLeavesPropertyList)
        allocate(SeagrassesLeavesPropertyList(1:Me%Coupled%SeagrassesLeaves%NumberOfProperties))

        PropertyX => Me%FirstProperty

 DoProd1:       do while(associated(PropertyX))

            if(PropertyX%Evolution%SeagrassesLeaves)then

                Index                               = Index + 1
                SeagrassesLeavesPropertyList(Index) = PropertyX%ID%IDNumber


                if(PropertyX%ID%IDNumber == SeagrassesLeaves_)then



                  if(PropertyX%Evolution%AdvectionDiffusion)then

                    write(*,*)
                    write(*,*)'Seagrasses Leaves can not have ADVECTION_DIFFUSION'
                    write(*,*)'Property : ', trim(adjustl(PropertyX%ID%Name))
                    write(*,*)'ADVECTION_DIFFUSION will be switched off'

                    PropertyX%Evolution%AdvectionDiffusion = OFF

                end if

                    if(PropertyX%Old)then
                        call Read_Old_Properties_2D(Me%SeagrassesLeaves%Biomass, "seagrasses leaves biomass" )
                    else

                      !  if (PropertyX%)


                        call LeavesOccupation(Me%SeagrassesLeaves)
                       call DistributeLeaves(PropertyX, Me%SeagrassesLeaves)
                    end if

                end if

      end if

            PropertyX => PropertyX%Next
        enddo DoProd1

        nullify(PropertyX)

        call ConstructInterface(InterfaceID         = Me%ObjSeagrassWaterInteraction,   &
                                TimeID              = Me%ObjTime,                        &
                                SinksSourcesModel   = SeagrassWaterInteractionModel,                   &
                                DT                  = SeagrassesLeavesDT,                &
                                PropertiesList      = SeagrassesLeavesPropertyList,      &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,      &
                                Size3D              = Me%WorkSize,                       &
                                Vertical1D          = Me%ExternalVar%Vertical1D,         &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('CoupleSeagrassesLeaves - ModuleWaterProperties - ERR01')

        Me%Coupled%SeagrassesLeaves%DT_Compute   = SeagrassesLeavesDT
        Me%Coupled%SeagrassesLeaves%NextCompute  = Me%ExternalVar%Now

        deallocate(SeagrassesLeavesPropertyList)
        nullify   (SeagrassesLeavesPropertyList)




    end subroutine CoupleSeagrassesLeaves

!------------------------------------------------------------------------------

    subroutine CoupleWWTPQ

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: WWTPQPropertyList
        integer                                             :: STAT_CALL
        real                                                :: WWTPQDT
        integer                                             :: Index = 0
        !----------------------------------------------------------------------

        Index = 0

        nullify (WWTPQPropertyList)
        allocate(WWTPQPropertyList(1:Me%Coupled%WWTPQM%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%WWTPQ)then

                Index = Index + 1
                WWTPQPropertyList(Index)  = PropertyX%ID%IDNumber

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)


        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = WWTPQModel,                    &
                                DT                  = WWTPQDT,                &
                                PropertiesList      = WWTPQPropertyList,      &
                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,  &
                                Size3D              = Me%WorkSize,                   &
                                Vertical1D          = Me%ExternalVar%Vertical1D,     &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            call CloseAllAndStop ('CoupleWaterQuality - ModuleWaterProperties - ERR01')

        Me%Coupled%WWTPQM%DT_Compute  = WWTPQDT
        Me%Coupled%WWTPQM%NextCompute = Me%ExternalVar%Now

        deallocate(WWTPQPropertyList)
        nullify   (WWTPQPropertyList)

    end subroutine CoupleWWTPQ

    !--------------------------------------------------------------------------

#ifdef _PHREEQC_
    subroutine CouplePhreeqC

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        real, pointer                                       :: SolutionMapping(:,:,:)
        real, pointer                                       :: EquilibriumMapping(:,:,:)
        real, pointer                                       :: ExchangeMapping(:,:,:)
        real, pointer                                       :: SurfaceMapping(:,:,:)
        real, pointer                                       :: GasPhaseMapping(:,:,:)
        real, pointer                                       :: SolidSolutionMapping(:,:,:)
        real, pointer                                       :: KineticsMapping(:,:,:)
        integer, pointer, dimension(:)                      :: PropertyList
        logical, pointer, dimension(:)                      :: IsOutputList
        integer                                             :: STAT_CALL
        real                                                :: DT
        integer                                             :: Index = 0
        !----------------------------------------------------------------------

        Index = 0

        nullify(SolutionMapping)
        nullify(EquilibriumMapping)
        nullify(ExchangeMapping)
        nullify(SurfaceMapping)
        nullify(GasPhaseMapping)
        nullify(SolidSolutionMapping)
        nullify(KineticsMapping)

        nullify (PropertyList)
        allocate(PropertyList(1:Me%Coupled%PhreeqC%NumberOfProperties))
        allocate(IsOutputList(1:Me%Coupled%PhreeqC%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%PhreeqC)then

                select case (PropertyX%ID%IDNumber)
                case (SolutionMapping_)
                    SolutionMapping => PropertyX%Concentration
                case (EquilibriumMapping_)
                    EquilibriumMapping => PropertyX%Concentration
                case (ExchangeMapping_)
                    ExchangeMapping => PropertyX%Concentration
                case (SurfaceMapping_)
                    SurfaceMapping => PropertyX%Concentration
                case (GasPhaseMapping_)
                    GasPhaseMapping => PropertyX%Concentration
                case (SolidSolutionMapping_)
                    SolidSolutionMapping => PropertyX%Concentration
                case (KineticsMapping_)
                    KineticsMapping => PropertyX%Concentration
                case default
                    Index = Index + 1
                    PropertyList(Index) = PropertyX%ID%IDNumber
                end select

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)

        call ConstructInterface(InterfaceID             = Me%ObjInterface,              &
                                TimeID                  = Me%ObjTime,                   &
                                SinksSourcesModel       = PhreeqCModel,                 &
                                DT                      = DT,                           &
                                PropertiesList          = PropertyList,                 &
                                WaterPoints3D           = Me%ExternalVar%WaterPoints3D, &
                                Size3D                  = Me%WorkSize,                  &
                                Vertical1D              = Me%ExternalVar%Vertical1D,    &
                                SolutionMapping         = SolutionMapping,              &
                                EquilibriumMapping      = EquilibriumMapping,           &
                                ExchangeMapping         = ExchangeMapping,              &
                                SurfaceMapping          = SurfaceMapping,               &
                                GasPhaseMapping         = GasPhaseMapping,              &
                                SolidSolutionMapping    = SolidSolutionMapping,         &
                                KineticsMapping         = KineticsMapping,              &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('CoupleWaterQuality - ModuleWaterProperties - ERR01')

        Me%Coupled%PhreeqC%DT_Compute  = DT
        Me%Coupled%PhreeqC%NextCompute = Me%ExternalVar%Now

        deallocate(PropertyList)
        nullify   (PropertyList)

    end subroutine CouplePhreeqC

    !--------------------------------------------------------------------------
#endif

    subroutine CoupleFreeVerticalMovement (             &
#ifdef _ENABLE_CUDA
                                            CudaID      &
#endif
    )

        !Arguments-------------------------------------------------------------
#ifdef _ENABLE_CUDA
        integer                                             :: CudaID
#endif
        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer                                             :: STAT_CALL

        !----------------------------------------------------------------------


        nullify(PropertyX)

        call Construct_FreeVerticalMovement(FreeVerticalMovementID = Me%ObjFreeVerticalMovement, &
                                            TimeID                 = Me%ObjTime,                 &
                                            HorizontalGridID       = Me%ObjHorizontalGrid,       &
                                            MapID                  = Me%ObjMap,                  &
                                            GeometryID             = Me%ObjGeometry,             &
                                            TurbGOTMID             = Me%ObjTurbGOTM,             &
#ifdef _ENABLE_CUDA
                                            ObjCudaID              = CudaID,                     &
#endif
                                            STAT                   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                               &
            call CloseAllAndStop ('CoupleFreeVerticalMovement - ModuleWaterProperties - ERR01')

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%FreeVerticalMovement)then

                if(.not. FreeVertPropertyExists(Me%ObjFreeVerticalMovement, PropertyX%ID%IDNumber))then
                    write(*,*)'Property :'//trim(PropertyX%ID%Name)//' needs to be defined'
                    write(*,*)'in the free vertical movement input data file. '
                    call CloseAllAndStop ('CoupleFreeVerticalMovement - ModuleWaterProperties - ERR02')
                end if

                if(FreeVertPropertyHasDeposition(Me%ObjFreeVerticalMovement, PropertyX%ID%IDNumber))then
                    if(.not. PropertyX%Evolution%BottomFluxes)then
                        write(*,*)
                        write(*,*)'Property '//trim(PropertyX%ID%Name)//' in WaterProperties file'
                        write(*,*)'must have option BOTTOM_FLUXES activated, as DEPOSITION option'
                        write(*,*)'is activated in FreeVerticalMovement data file.'
                        write(*,*)
                        call CloseAllAndStop ('CoupleFreeVerticalMovement - ModuleWaterProperties - ERR03')
                    end if
                end if


            end if

            PropertyX => PropertyX%Next

        enddo

        Me%Coupled%FreeVerticalMovement%NextCompute = Me%ExternalVar%Now

    end subroutine CoupleFreeVerticalMovement


    !--------------------------------------------------------------------------


    subroutine CoupleHydroIntegration

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer                                             :: STAT_CALL
        real                                                :: ModelDT

        !----------------------------------------------------------------------

        !Starts the HydroIntegration
        call StartHydroIntegration(Me%ObjHydroIntegration,  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleHydroIntegration - ModuleWaterProperties - ERR01')

        call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleHydroIntegration - ModuleWaterProperties - ERR02')


        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%HydroIntegration)then

                call StartHydroIntegrationList(ObjHydroIntegrationID = Me%ObjHydroIntegration,          &
                                               Size                  = Me%WorkSize,                     &
                                               DT                    = PropertyX%evolution%DTInterval,  &
                                               CurrentTime           = Me%ExternalVar%Now,              &
                                               DT_ComputeStep        = ModelDT,                         &
                                               BoundaryPoints2D      = Me%ExternalVar%BoundaryPoints2D, &
                                               STAT                  = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CoupleHydroIntegration - ModuleWaterProperties - ERR03')

            end if

            PropertyX => PropertyX%Next

        enddo

        Me%Coupled%HydroIntegration%NextCompute = Me%ExternalVar%Now

        nullify(PropertyX)

    end subroutine CoupleHydroIntegration

    !--------------------------------------------------------------------------

    subroutine ConstructPartition

        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                   :: Property
        type(T_Property), pointer                   :: DissolvedProperty
        type(T_Property), pointer                   :: ParticulateProperty
        character(len=StringLength)                 :: PartPropName
        real                                        :: TotalPartition
        integer                                     :: Couple_ID
        integer                                     :: Error

        !Begin-----------------------------------------------------------------

        Property => Me%FirstProperty

do1:    do while(associated(Property))

            if (Property%Evolution%Partitioning .and. .not. Property%ID%IsParticulate) then

                DissolvedProperty => Property

                PartPropName = trim(DissolvedProperty%Evolution%Partition%Couple)

                if (.not. CheckPropertyName(PartPropName, Couple_ID)) then
                    write(*,*)
                    write(*,*) 'The property name is not recognised by the model'
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR00')
                else

                    DissolvedProperty%Evolution%Partition%Couple_ID = Couple_ID

                end if

                call Search_Property(ParticulateProperty, PropertyXID = Couple_ID, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) &
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR10')

                if(trim(ParticulateProperty%Evolution%Partition%Couple) .ne.                &
                   trim(DissolvedProperty%ID%Name))                                         &
                   call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR20')

                if(ParticulateProperty%Evolution%DTInterval .ne.                            &
                   DissolvedProperty%Evolution%DTInterval)                                  &
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR30')


                if(DissolvedProperty%Evolution%Partition%Rate /=                            &
                   ParticulateProperty%Evolution%Partition%Rate   )then
                    write(*,*)'Particulate and dissolved phases must have equal partition rates'
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR40')
                end if

                TotalPartition = DissolvedProperty%Evolution%Partition%Fraction  +          &
                                 ParticulateProperty%Evolution%Partition%Fraction

                Error = abs(1. - TotalPartition)

                if(Error > 0.001)then
                    write(*,*)'Particulate and dissolved phases fractions must sum iqual to 1.'
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR50')
                end if

                ! .EQV. = Logical equivalence: the expression is true if both A and B
                !  are true, or both are false.
                if (.NOT. (DissolvedProperty%Evolution%Partition%SalinityEffect .EQV.       &
                           ParticulateProperty%Evolution%Partition%SalinityEffect))         &
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR60')

                if (DissolvedProperty%Evolution%Partition%EmpiricCoef .ne.                  &
                    ParticulateProperty%Evolution%Partition%EmpiricCoef )                   &
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR70')


                if (.NOT. (DissolvedProperty%Evolution%Partition%UseSedimentRefConc .EQV.   &
                           ParticulateProperty%Evolution%Partition%UseSedimentRefConc))     &
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR80')

                if(DissolvedProperty%Evolution%Partition%SedimentRefConc /=                 &
                   ParticulateProperty%Evolution%Partition%SedimentRefConc   )then
                    write(*,*)'Particulate and dissolved phases must have equal cohesive sediment'
                    write(*,*)'reference concentration'
                    call CloseAllAndStop ('ConstructPartition - ModuleWaterProperties - ERR90')
                end if


            end if

            nullify(DissolvedProperty, ParticulateProperty)

            Property => Property%Next


        end do do1

        nullify(Property)


    end subroutine ConstructPartition

    !--------------------------------------------------------------------------


subroutine Construct_Discharges_Tracking

        !Local--------------------------------------------------------------------------
        integer                                         :: DischargeTrack = 0
        integer                                         :: idis
!        integer                                         :: I, J, K, kd
        integer                                         :: STAT_CALL
        integer                                         :: nProperties
        character(StringLength)                         :: DischargeName !,AuxI, AuxJ, AuxK
        character(StringLength), pointer, dimension(:)  :: PropertyList
        type (T_DischargeTimeSerie), pointer            :: PrevPointer
        type (T_DischargeTimeSerie), pointer            :: Aux_Pointer
        type (T_Property), pointer                      :: PropertyX

        !Begin--------------------------------------------------------------------------


        !First checks out how many properties will have time series
        PropertyX   => Me%FirstProperty
        nProperties =  1
        do while (associated(PropertyX))
            if (PropertyX%Evolution%DischargesTracking) nProperties = nProperties + 1
            PropertyX=>PropertyX%Next
        enddo

        !Allocates PropertyList
        allocate(PropertyList(nProperties), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)      &
            call CloseAllAndStop ('Construct_Discharges_Tracking - ModuleWaterProperties - ERR02')

        !Fills up PropertyList
        PropertyList(1) = "Flow"
        PropertyX       => Me%FirstProperty
        nProperties     =  1
        do while (associated(PropertyX))
            if (PropertyX%Evolution%DischargesTracking) then
                nProperties = nProperties + 1
                PropertyList(nProperties) = trim(adjustl(PropertyX%ID%name))
            endif
            PropertyX=>PropertyX%Next
        enddo


        !Nullifies first
        nullify(Me%FirstDischargeTimeSerie)


        !For each discharge allocate a time serie
        do idis = 1, Me%Discharge%Number

            call GetDischargesIDName(Me%ObjDischarges, idis, DischargeName, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)      &
                call CloseAllAndStop ('Construct_Discharges_Tracking - ModuleWaterProperties - ERR03')


            !Starts a new Time Serie
            DischargeTrack = 0
            call StartTimeSerie(DischargeTrack,                                          &
                                Me%ObjTime,                                              &
                                Me%Files%ConstructData,                                  &
                                PropertyList, "srd",                                     &
                                ResultFileName = trim(DischargeName),                    &
                                STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)      &
                call CloseAllAndStop ('Construct_Discharges_Tracking - ModuleWaterProperties - ERR04')

            !Insert New Time Serie to List
            if (.not. associated(Me%FirstDischargeTimeSerie)) then
                allocate(Me%FirstDischargeTimeSerie)
                Me%FirstDischargeTimeSerie%TimeSerie = DischargeTrack
                nullify(Me%FirstDischargeTimeSerie%Next)
            else
                PrevPointer             => Me%FirstDischargeTimeSerie
                Aux_Pointer             => Me%FirstDischargeTimeSerie%Next
                do while (associated(Aux_Pointer))
                    PrevPointer         => Aux_Pointer
                    Aux_Pointer         => Aux_Pointer%Next
                enddo
                allocate(Aux_Pointer)
                Aux_Pointer%TimeSerie   =  DischargeTrack
                PrevPointer%Next        => Aux_Pointer
                nullify(Aux_Pointer%Next)
            endif

        enddo

        !Deallocates PropertyList
        deallocate(PropertyList, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)      &
            call CloseAllAndStop ('Construct_Discharges_Tracking - ModuleWaterProperties - ERR05')

    end subroutine Construct_Discharges_Tracking


    !--------------------------------------------------------------------------
    !Read the name of the files need to construct and modify
    ! the water properties

    subroutine Read_WaterProperties_Files_Name

        !External--------------------------------------------------------------

        integer :: STAT_CALL
        character(len = StringLength) :: Message

        !----------------------------------------------------------------------


        ! ---> ASCII file used to construct new properties
        Message   ='ASCII file used to construct new properties.'
        Message   = trim(Message)

        call ReadFileName('DISPQUAL', Me%Files%ConstructData, &
                           Message = Message, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('Read_WaterProperties_Files_Name - ModuleWaterProperties - ERR01')


        ! ---> File in HDF format where is written instant fields of water properties
        Message   ='Instant fields of water properties in HDF format.'
        Message   = trim(Message)

        call ReadFileName('EUL_HDF', Me%Files%OutPutFields,                             &
                           Message = Message, TIME_END = Me%EndTime,                    &
                           Extension = 'elt',                                           &
                           MPI_ID    = Me%DDecomp%MPI_ID,                               &
                           DD_ON     = Me%DDecomp%ON,                                   &
                           STAT      = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_WaterProperties_Files_Name - ModuleWaterProperties - ERR02')

        ! ---> Water properties final values in HDF format
        Message   ='Water properties final values in HDF format.'
        Message   = trim(Message)
        call ReadFileName('EUL_FIN', Me%Files%FinalWaterProperties,                     &
                           Message = Message, TIME_END = Me%EndTime,                    &
                           Extension = 'elf',                                           &
                           MPI_ID    = Me%DDecomp%MPI_ID,                               &
                           DD_ON     = Me%DDecomp%ON,                                   &
                           STAT      = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_WaterProperties_Files_Name - ModuleWaterProperties - ERR03')


        ! ---> Water properties initial values in HDF format
        Message   ='Water properties initial values in HDF format.'
        Message   = trim(Message)

        call ReadFileName('EUL_INI', Me%Files%InitialWaterProperties,                   &
                           Message = Message, TIME_END = Me%ExternalVar%Now,            &
                           Extension = 'elf',                                           &
                           STAT      = STAT_CALL)

cd1 :   if      (STAT_CALL .EQ. FILE_NOT_FOUND_ERR_   ) then
            write(*,*)
            write(*,*) 'Inicial file not found.'
            call CloseAllAndStop ('Read_WaterProperties_Files_Name - ModuleWaterProperties - ERR04')

        else if (STAT_CALL .EQ. KEYWORD_NOT_FOUND_ERR_) then
            write(*,*)
            write(*,*) 'Keyword for the inicial file not found in nomfich.dat.'
            write(*,*) 'Read_WaterProperties_Files_Name - ModuleWaterProperties - WRN01'
            write(*,*)

        else if (STAT_CALL .EQ. SUCCESS_             ) then
            continue
        else
            write(*,*)
            write(*,*) 'Error calling ReadFileName.'
            call CloseAllAndStop ('Read_WaterProperties_Files_Name - ModuleWaterProperties - ERR05')
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Read_WaterProperties_Files_Name

    !--------------------------------------------------------------------------
    !This subroutine reads all the information needed to construct a new property.

    subroutine Construct_Property(NewProperty,ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty
        integer                         :: ClientNumber

        !----------------------------------------------------------------------

        allocate (NewProperty)

        nullify(NewProperty%Concentration        )
        nullify(NewProperty%Mass_Created         )
        nullify(NewProperty%SurfaceFlux          )
        nullify(NewProperty%Mass_Destroid        )
        nullify(NewProperty%Assimilation%Field   )
        nullify(NewProperty%Prev,NewProperty%Next)

        nullify(NewProperty%SubModel%PreviousField, NewProperty%SubModel%NextField)

        !Construct property ID
        call ConstructPropertyID        (NewProperty%ID, Me%ObjEnterData, FromBlock)

        !Construct property values
        call Construct_PropertyState    (NewProperty)

        !Construct property values
        call Construct_PropertyValues   (NewProperty, ClientNumber)

        !Construct property evolution parameters
        call Construct_PropertyEvolution(NewProperty, ClientNumber)

        !Defines the property output
        call Construct_PropertyOutPut   (NewProperty, FromBlock)

        if (NewProperty%Evolution%DecayRateProperty)                                    &
            call SetDecayRatePropertyOptions(NewProperty)

    end subroutine Construct_Property

    !--------------------------------------------------------------------------
   !This subroutine set the evolutions options of a decay rate property.

    subroutine SetDecayRatePropertyOptions(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty

        !----------------------------------------------------------------------
        NewProperty%Evolution%AdvectionDiffusion = .false.

        if (NewProperty%Evolution%WaterQuality          .or.                            &
            NewProperty%Evolution%MacroAlgae            .or.                            &
            NewProperty%Evolution%SeagrassesLeaves      .or.                            &
            NewProperty%Evolution%CEQUALW2              .or.                            &
            NewProperty%Evolution%Life                  .or.                            &
            NewProperty%Evolution%Bivalve               .or.                            &
            NewProperty%Evolution%WWTPQ                 .or.                            &
            NewProperty%Evolution%Partitioning          .or.                            &
            NewProperty%Evolution%FreeVerticalMovement  .or.                            &
            NewProperty%Evolution%AdvectionDiffusion    .or.                            &
            NewProperty%Evolution%Discharges            .or.                            &
            NewProperty%Evolution%DischargesTracking    .or.                            &
            NewProperty%Evolution%SurfaceFluxes         .or.                            &
            NewProperty%Evolution%BottomFluxes          .or.                            &
            NewProperty%Evolution%HydroIntegration      .or.                            &
            NewProperty%Evolution%DataAssimilation /= 0 .or.                            &
            NewProperty%Evolution%MinConcentration      .or.                            &
            NewProperty%Evolution%MaxConcentration      .or.                            &
            NewProperty%Evolution%InstantMixing         .or.                            &
            NewProperty%Evolution%LightExtinction       .or.                            &
            NewProperty%Evolution%FirstOrderDecay    )  then
            write(*,*) "A decay rate property do not change due to a evolution equation"
            stop
        endif

        !----------------------------------------------------------------------


    end subroutine SetDecayRatePropertyOptions

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
   !This subroutine reads all the information needed to construct a new property.

    subroutine Construct_WqRate(NewWqRate)

        !Arguments-------------------------------------------------------------
        type(T_WqRate), pointer                     :: NewWqRate

        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL

        !----------------------------------------------------------------------

        allocate (NewWqRate, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('Construct_WqRate - ModuleWaterProperties - ERR01')

        nullify(NewWqRate%Field, NewWqRate%Prev, NewWqRate%Next)

        !Construct property ID
        call Construct_WqRateID     (NewWqRate)

        !Construct property values
        call Construct_WqRateValues (NewWqRate)


    end subroutine Construct_WqRate

    !--------------------------------------------------------------------------
    !This subroutine reads all the information needed to construct the property ID

    subroutine Construct_PropertyState(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property),        pointer    :: NewProperty

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: iflag

        !----------------------------------------------------------------------

!~         !<BeginKeyword>
!~             !Keyword          : PARTICULATE
!~             !<BeginDescription>
!~                 !Checks if the user wants this property to be particulate.
!~                 !This property will be used to define particulated properties
!~             !<EndDescription>
!~             !Type             : Boolean
!~             !Default          : .false.
!~             !File keyword     : DISPQUAL
!~             !Multiple Options : 1 (.true.), 0 (.false.)
!~             !Search Type      : From Block
!~             !Begin Block      : <beginproperty>
!~             !End Block        : <endproperty>
!~         !<EndKeyword>

!~         call GetData(NewProperty%Particulate,                                           &
!~                      Me%ObjEnterData,iflag,                                            &
!~                      SearchType   = FromBlock,                                          &
!~                      keyword      = 'PARTICULATE',                                      &
!~                      Default      = .false.,                                            &
!~                      ClientModule = 'ModuleWaterProperties',                            &
!~                      STAT         = STAT_CALL)
!~         if (STAT_CALL .NE. SUCCESS_)                                                    &
!~             call CloseAllAndStop ('Construct_PropertyState - ModuleWaterProperties - ERR01')

!~         if (NewProperty%Particulate)then
!~             if(.not. Check_Particulate_Property(NewProperty%ID%IDNumber)) then
!~                 write(*,*) 'Property '//trim(NewProperty%ID%Name)// 'is not'
!~                 write(*,*) 'recognised as PARTICULATE'
!~                 call CloseAllAndStop ('Construct_PropertyState - ModuleWaterProperties - ERR02')
!~             end if
!~         endif


        !<BeginKeyword>
            !Keyword          : IS_COEF
            !<BeginDescription>
                !This coeficient can only be used when the
                !relation between the IS units and units that
                !the user wants to use is linear
            !<EndDescription>
            !Type             : Real
            !Default          : 1.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%IScoefficient,                                         &
                     Me%ObjEnterData, iflag,                                           &
                     KeyWord        = 'IS_COEF',                                        &
                     Default        = 1.e-3,                                            &
                     SearchType     = FromBlock,                                        &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_PropertyState - ModuleWaterProperties - ERR03')

        call GetData(NewProperty%Non_Cohesive,                                           &
                     Me%ObjEnterData,iflag,                                              &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'NON_COHESIVE',                                      &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)&
            call CloseAllAndStop ('Construct_PropertyState - ModuleWaterProperties - ERR04')

        call GetData(NewProperty%GFW,                                                    &
                     Me%ObjEnterData,iflag,                                              &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'GFW',                                               &
                     Default      = -FillValueReal,                                      &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)&
            call CloseAllAndStop ('Construct_PropertyState - ModuleWaterProperties - ERR05')

     end subroutine Construct_PropertyState

    !--------------------------------------------------------------------------

    !This subroutine reads all the information needed to construct the property ID
    subroutine Construct_WqRateID(NewWqRate)

        !Arguments-------------------------------------------------------------
        type(T_WqRate),        pointer      :: NewWqRate

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: iflag, PropNumber
        logical                             :: CheckName, firstprop, secondprop

        !----------------------------------------------------------------------


        !<BeginKeyword>
            !Keyword          : FIRSTPROP
            !<BeginDescription>
                !First Property defined in a rate relation
            !<EndDescription>
            !Type             : Character
            !Default          : none.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginwqrate>
            !End Block        : <endwqrate>
        !<EndKeyword>

        call GetData(NewWqRate%FirstProp%name,                                           &
                     Me%ObjEnterData, iflag,                                             &
                     KeyWord    = 'FIRSTPROP',                                           &
                     SearchType = FromBlock,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR01')


        if (iflag.eq.1) then

            firstprop=.true.

            ! Check if the property name is valid OR not
            CheckName = CheckPropertyName(NewWqRate%FirstProp%name, number = PropNumber)
            if (CheckName) then
                NewWqRate%FirstProp%IDnumber = PropNumber
            else
                write(*,*)
                write(*,*) 'The first property name is not recognised by the model.'
                call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR03')
            end if
        else

            firstprop= .false.

        endif

        !<BeginKeyword>
            !Keyword          : SECONDPROP
            !<BeginDescription>
                !second Property defined in a rate relation
            !<EndDescription>
            !Type             : Character
            !Default          : none.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginwqrate>
            !End Block        : <endwqrate>
        !<EndKeyword>

        call GetData(NewWqRate%SecondProp%name,                                          &
                     Me%ObjEnterData, iflag,                                             &
                     KeyWord    = 'SECONDPROP',                                          &
                     SearchType = FromBlock,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR04')



        if (iflag.eq.1) then

             secondprop=.true.

            ! Check if the property name is valid OR not
            CheckName = CheckPropertyName(NewWqRate%SecondProp%name, number = PropNumber)
            if (CheckName) then
                NewWqRate%SecondProp%IDnumber = PropNumber
            else
                write(*,*)
                write(*,*) 'The Second property name is not recognised by the model.'
                call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR06')
            end if
        else

            secondprop=.false.

        endif


        !<BeginKeyword>
            !Keyword          : DESCRIPTION
            !<BeginDescription>
                !Rate description ex: zooplankton grazing over phytoplankton
            !<EndDescription>
            !Type             : Character
            !Default          : none.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginwqrate>
            !End Block        : <endwqrate>
        !<EndKeyword>

        call GetData(NewWqRate%ID%Description,                                           &
                     Me%ObjEnterData, iflag,                                             &
                     KeyWord      = 'DESCRIPTION',                                       &
                     SearchType   = FromBlock,                                           &
                     ClientModule = 'ModuleWaterProperties',                             &
                     Default      = 'No description was given',                          &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR07')



        !<BeginKeyword>
            !Keyword          : NAME
            !<BeginDescription>
                !Rate name ex: PhyAM
            !<EndDescription>
            !Type             : Character
            !Default          : none.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginwqrate>
            !End Block        : <endwqrate>
        !<EndKeyword>

        call GetData(NewWqRate%ID%Name,                                                  &
                     Me%ObjEnterData, iflag,                                             &
                     KeyWord      = 'NAME',                                              &
                     SearchType   = FromBlock,                                           &
                     Default      = 'No WqRateName was given',                           &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR08')



        if (.not.secondprop.and..not.firstprop) then  !Cequal rates

           CheckName = CheckPropertyName(NewWqRate%ID%Name, number = PropNumber)
             if (CheckName) then
               NewWqRate%CeQualID = PropNumber
             else
               write(*,*)
               write(*,*) 'The rate name is not recognised by the model.'
               call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR09')
             end if
         endif

        !<BeginKeyword>
            !Keyword          : NAME
            !<BeginDescription>
                !Rate name ex: PhyAM
            !<EndDescription>
            !Type             : Character
            !Default          : none.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginwqrate>
            !End Block        : <endwqrate>
        !<EndKeyword>

        call GetData(NewWqRate%Model,                                                    &
                     Me%ObjEnterData, iflag,                                             &
                     KeyWord      = 'MODEL',                                             &
                     SearchType   = FromBlock,                                           &
                     Default      = WaterQualityModel,                                   &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_WqRateID - ModuleWaterProperties - ERR10')


    end subroutine Construct_WqrateID


    !--------------------------------------------------------------------------
    !This subroutine reads all the information needed to construct the property values
    ! in the domain and in the boundaries

    subroutine Construct_PropertyValues(NewProperty, ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty
        integer                         :: ClientNumber
        !External--------------------------------------------------------------
        integer                         :: STAT_CALL
        !Local-----------------------------------------------------------------
        character(len=8)                :: BoundaryMethod
        integer                         :: iflag, i,j,k
        integer                         :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                         :: WILB, WIUB, WJLB, WJUB, WKLB, WKUB
        !----------------------------------------------------------------------

        ILB = Me%Size%ILB; JLB = Me%Size%JLB; KLB = Me%Size%KLB
        IUB = Me%Size%IUB; JUB = Me%Size%JUB; KUB = Me%Size%KUB

        WILB = Me%WorkSize%ILB; WJLB = Me%WorkSize%JLB; WKLB = Me%WorkSize%KLB
        WIUB = Me%WorkSize%IUB; WJUB = Me%WorkSize%JUB; WKUB = Me%WorkSize%KUB

#ifdef _USE_PAGELOCKED
        ! Allocate pagelocked memory to optimize CUDA transfers
        call Alloc3DPageLocked(Me%ObjCuda, NewProperty%ConcentrationPtr, NewProperty%Concentration, IUB + 1, JUB + 1, KUB + 1)
#else
        allocate(NewProperty%Concentration(ILB:Pad(ILB, IUB), JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR10')
#endif

        NewProperty%Concentration(:,:,:) = FillValueReal

        !To store oxygen and CO2 fluxes across the water-air interface
        if(NewProperty%ID%IDNumber == CarbonDioxide_ .OR. &
           NewProperty%ID%IDNumber == Oxygen_) then

            allocate(NewProperty%SurfaceFlux(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR20')
            NewProperty%Surfaceflux(:,:) = FillValueReal

        endif

        if(NewProperty%ID%IDNumber == Ammonia_ .OR. &  !LLP
           NewProperty%ID%IDNumber == Nitrate_) then

            allocate(NewProperty%SurfaceFlux(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR20a')
            NewProperty%Surfaceflux(:,:) = FillValueReal

        endif

        allocate (NewProperty%Assimilation%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR30')
            NewProperty%Assimilation%Field(:,:,:) = FillValueReal

        !<BeginKeyword>
            !Keyword          : OLD
            !<BeginDescription>
               ! This variable is a logic one is true if the property is old
               ! and the user wants to continue the run with results of a previous run.
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>


        call GetData(NewProperty%Old,                                                   &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType     = FromBlock,                                        &
                     keyword        = 'OLD',                                            &
                     Default        = Me%Continuous,                                    &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR40')

        !<BeginKeyword>
            !Keyword          : MIN_VALUE
            !<BeginDescription>
               ! This variable is to avoid negative concentration for properties which
               ! have concentrations close to zero.
               !
            !<EndDescription>
            !Type             : Real
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        NewProperty%Evolution%MinConcentration = .false.

        call GetData(NewProperty%MinValue,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType     = FromBlock,                                        &
                     keyword        = 'MIN_VALUE',                                      &
                     default        = FillValueReal,                                    &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR50')
        if (iflag==1)  then
            NewProperty%Evolution%MinConcentration = .true.

            allocate(NewProperty%Mass_Created(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR60')
            NewProperty%Mass_Created(:,:,:) = 0.

        endif

        !<BeginKeyword>
            !Keyword          : MAX_VALUE
            !<BeginDescription>
               ! This variable is to avoid very large concentrationsassociated with instabilities
               !
            !<EndDescription>
            !Type             : Real
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        NewProperty%Evolution%MaxConcentration = .false.

        call GetData(NewProperty%MaxValue,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType     = FromBlock,                                        &
                     keyword        = 'MAX_VALUE',                                      &
                     default        = - FillValueReal,                                  &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR70')
        if (iflag==1)  then
            NewProperty%Evolution%MaxConcentration = .true.

            allocate(NewProperty%Mass_Destroid(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR80')
            NewProperty%Mass_Destroid(:,:,:) = 0.

        endif

        !<BeginKeyword>
            !Keyword          : WARN_ON_NEGATIVE_VALUES
            !<BeginDescription>
               ! Write a warning to screen when property has negative value
               !
            !<EndDescription>
            !Type             : Real
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>


        call GetData(NewProperty%WarnOnNegativeValues,                                   &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType     = FromBlock,                                         &
                     keyword        = 'WARN_ON_NEGATIVE_VALUES',                         &
                     ClientModule   = 'ModuleWaterProperties',                           &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR90')

        !<BeginKeyword>
            !Keyword          : ADD_OFFSET
            !<BeginDescription>
               ! Allows a property concentration to be negative provided that
               ! an offset is given so that in advection-diffusion the values are positive
               ! and the offset it taken
            !<EndDescription>
            !Type             : Real
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>


        call GetData(NewProperty%AddOffSet,                                              &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType     = FromBlock,                                         &
                     keyword        = 'ADD_OFFSET',                                      &
                     Default        = .false.,                                           &
                     ClientModule   = 'ModuleWaterProperties',                           &
                     STAT           = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR91')


        if(NewProperty%AddOffSet)then
            !<BeginKeyword>
                !Keyword          : OFFSET
                !<BeginDescription>
                   ! An offset if provided when the values of the property can be negative
                   ! the offset value is added before advection-diffusion and added again
                   ! after the advection-diffusion call so that the values are positive
                   ! when computing advection-diffusion
                !<EndDescription>
                !Type             : Real
                !Default          : 0.
                !File keyword     : DISPQUAL
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>


            call GetData(NewProperty%OffSet,                                                 &
                         Me%ObjEnterData, iflag,                                             &
                         SearchType     = FromBlock,                                         &
                         keyword        = 'OFFSET',                                          &
                         ClientModule   = 'ModuleWaterProperties',                           &
                         STAT           = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR92')

            if(iflag .eq. 0)then
                write(*,*) 'Property : ', trim(adjustl(NewProperty%ID%Name))
                write(*,*) 'Must have an offset defined as ALLOW_NEGATIVE_VALUES is ON'
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR93')
            endif

        end if
        !<BeginKeyword>
            !Keyword          : DEFAULTBOUNDARY
            !<BeginDescription>
                ! The default value of a specific water property imposed in the open boundary
            !<EndDescription>
            !Type             : Real
            !Default          : Is function of property (see routine DefaultValueProp in moduleWaterProperites)
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : From Block
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%Assimilation%scalar,                                   &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType = FromBlock,                                            &
                     keyword    = 'DEFAULTBOUNDARY',                                    &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR100')
        if (iflag==0)                                                                   &
            NewProperty%Assimilation%scalar = DefaultValueProp(NewProperty%ID%IDNumber)


        !<BeginKeyword>
            !Keyword          : DRY_CELL_CONCENTRATION
            !<BeginDescription>
                ! The concentration of uncovered cells is assumed equal to this value
            !<EndDescription>
            !Type             : Real
            !Default          : DEFAULT value of the property
            !File keyword     : DISPQUAL
            !Multiple Options : Do not haveCons
            !Search Type      : From Block
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%DryCellConcentration,                                  &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType = FromBlock,                                            &
                     keyword    = 'DRY_CELL_CONCENTRATION',                             &
                     default    = NewProperty%Scalar,                                   &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR105')
        if (iflag==0) then
            NewProperty%Evolution%ImposeDryCells = .false.
        else
            NewProperty%Evolution%ImposeDryCells = .true.
        endif

        ! if the property is not 'OLD' the property values in the domain and
        ! in the boundaries are initialized
        ! if it's true ('OLD') this same values are read from the final file of the
        ! previous run
cd1 :   if (.not.NewProperty%Old) then

            call ConstructFillMatrix  (PropertyID           = NewProperty%ID,               &
                                       EnterDataID          = Me%ObjEnterData,              &
                                       TimeID               = Me%ObjTime,                   &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,         &
                                       GeometryID           = Me%ObjGeometry,               &
                                       ExtractType          = FromBlock,                    &
                                       PointsToFill3D       = Me%ExternalVar%WaterPoints3D, &
                                       Matrix3D             = NewProperty%Concentration,    &
                                       TypeZUV              = TypeZ_,                       &
                                       ClientID             = ClientNumber,                 &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR110')

            call GetDefaultValue(NewProperty%ID%ObjFillMatrix, NewProperty%Scalar, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR120')

            if(NewProperty%ID%SolutionFromFile)then

                NewProperty%Evolution%Variable = ON

            else

                call KillFillMatrix(NewProperty%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)&
                    call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR170')

            end if

            call CheckFieldConsistence(NewProperty)

            !By default the exterior points have values equal to nearst interior point
            NewProperty%Concentration(WILB:WIUB,  JLB, WKLB:WKUB) = &
            NewProperty%Concentration(WILB:WIUB, WJLB, WKLB:WKUB)

            NewProperty%Concentration(WILB:WIUB,  JUB, WKLB:WKUB) = &
            NewProperty%Concentration(WILB:WIUB, WJUB, WKLB:WKUB)

            NewProperty%Concentration( ILB, WJLB:WJUB, WKLB:WKUB) = &
            NewProperty%Concentration(WILB, WJLB:WJUB, WKLB:WKUB)

            NewProperty%Concentration( IUB, WJLB:WJUB, WKLB:WKUB) = &
            NewProperty%Concentration(WIUB, WJLB:WJUB, WKLB:WKUB)

do3 :           do K = WKLB, WKUB
do2 :           do J = JLB, JUB
do1 :           do I = ILB, IUB
                    NewProperty%Assimilation%Field(I, J, K) = NewProperty%Concentration(i,j,k)
                end do do1
                end do do2
                end do do3

            !Only the EXTERIOR and the INTERIOR process were considered

            !<BeginKeyword>
                !Keyword          : BOUNDARY_INITIALIZATION
                !<BeginDescription>
                   ! Two processes were consider to initialize the boundary values:
                   !         EXTERIOR - A value exterior to the domain is be imposed.
                   !                    For this option was only consider a constant value.
                   !         INTERIOR - The boundary are admitted equal to the values given
                   !                    in the same cells during the domain initialization.
                   !
                !<EndDescription>
                !Type             : Character
                !Default          : 'INTERIOR'
                !File keyword     : DISPQUAL
                !Multiple Options : EXTERIOR, INTERIOR
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>

            call GetData(BoundaryMethod,                                                &
                         Me%ObjEnterData, iflag,                                        &
                         SearchType = FromBlock,                                        &
                         keyword    = 'BOUNDARY_INITIALIZATION',                        &
                         Default    = 'INTERIOR',                                       &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT       = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR180')


cd4 :       if (associated(Me%ExternalVar%BoundaryPoints2D)) then
cd2 :           if      (BoundaryMethod=='EXTERIOR'        ) then

do4 :               do J = JLB, JUB
do5 :               do I = ILB, IUB
cd5 :                   if (Me%ExternalVar%BoundaryPoints2D(i, j) == Boundary) then
do6 :                       do K = WKLB, WKUB
                                NewProperty%Assimilation%Field(i, j, k) = NewProperty%Assimilation%scalar
                            end do do6
                        endif cd5
                    end do do5
                    end do do4

                elseif(BoundaryMethod .ne. 'EXTERIOR' .and. BoundaryMethod .ne. 'INTERIOR') then

                    write(*,*)
                    write(*,*) 'The boundary initialization methods can only be two: '
                    write(*,*) '    INTERIOR OR EXTERIOR'
                    call CloseAllAndStop ('Construct_PropertyValues - ModuleWaterProperties - ERR190')

               end if cd2

            end if cd4

        else  cd1

            ! If the property is old then the program is going to try to find a property
            ! with the same name in the Water properties initial file written in HDF format
            call ReadOldConcBoundariesHDF(NewProperty)

        end if cd1


    end subroutine Construct_PropertyValues

    !--------------------------------------------------------------------------

    subroutine CheckFieldConsistence(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property),  pointer      :: NewProperty
        !Local-----------------------------------------------------------------
        integer                         :: i,j,k
        integer                         :: ILB, IUB, JLB, JUB, KLB, KUB
        real                            :: NewValue
        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB; JLB = Me%WorkSize%JLB; KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB; JUB = Me%WorkSize%JUB; KUB = Me%WorkSize%KUB

        if (NewProperty%AddOffSet)then
            do K = Me%WorkSize%KLB, Me%WorkSize%KUB
            do J = Me%WorkSize%JLB, Me%WorkSize%JUB
            do I = Me%WorkSize%ILB, Me%WorkSize%IUB
                if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                    NewProperty%Concentration(i,j,k)   = NewProperty%Concentration(i,j,k) + NewProperty%OffSet
                endif
            enddo
            enddo
            enddo
        endif

        !Verification if the values read are lower than zero in water points
do9 :   do I = ILB, IUB
do8 :   do J = JLB, JUB
do7 :   do K = KLB, KUB

cd21:       if (Me%ExternalVar%WaterPoints3D(i, j, k) == WaterPoint) then
                if(NewProperty%Evolution%MinConcentration) then
                    if (NewProperty%Concentration(i, j, k) < NewProperty%MinValue) then
                        write(*,*)
                        write(*,*)"Property : ", trim(NewProperty%ID%Name)
                        write(*,*)"Initial concentration is below the minimum value in cell", i, j, k

                        NewProperty%Concentration(i, j, k) = NewProperty%MinValue

                        write(*,*)"New concentration = ", NewProperty%MinValue
                        write(*,*)"CheckFieldConsistence - ModuleWaterProperties - WRN01"
                        write(*,*)
                    endif

                elseif (NewProperty%Concentration(i, j, k) < 0.) then
                        write(*,*)
                        write(*,*)"Property : ", trim(NewProperty%ID%Name)
                        write(*,*)"Negative initial concentration in cell", i, j, k

                        call FindNearestPositive(i, j, k, NewProperty%Concentration, NewValue)

                        write(*,*)"New concentration = ", NewValue
                        write(*,*)"CheckFieldConsistence - ModuleWaterProperties - WRN02"
                        write(*,*)

                        NewProperty%Concentration(i,j,k) = NewValue
                endif
            else cd21
                NewProperty%Concentration(i, j, k) = FillValueReal
            endif cd21

        enddo do7
        enddo do8
        enddo do9

        if (NewProperty%AddOffSet)then
            do K = Me%WorkSize%KLB, Me%WorkSize%KUB
            do J = Me%WorkSize%JLB, Me%WorkSize%JUB
            do I = Me%WorkSize%ILB, Me%WorkSize%IUB
                if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                    NewProperty%Concentration(i,j,k)   = NewProperty%Concentration(i,j,k) - NewProperty%OffSet
                endif
            enddo
            enddo
            enddo
        endif

    end subroutine CheckFieldConsistence

    !----------------------------------------------------------------------

    subroutine FindNearestPositive(Start_I, Start_J, Start_K, Concentration, NewValue)

        !Arguments-------------------------------------------------------------
        integer, intent(in)                     :: Start_I, Start_J, Start_K
        real, dimension(:,:,:), pointer         :: Concentration
        real,    intent(out)                    :: NewValue

        !Local-----------------------------------------------------------------
        integer                                 :: i, j, k, increment
        real                                    :: Cumulative, Count
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB


        !----------------------------------------------------------------------

        NewValue = Concentration(Start_I, Start_J, Start_K)

        i = Start_I
        j = Start_J
        k = Start_K

        increment = 1

        do while (NewValue < 0.)

            Cumulative = 0.
            Count      = 0

            if(Start_K - increment < Me%Size%KLB)then
                KLB = 0
            else
                KLB = Start_K - increment
            end if

            if(Start_K + increment > Me%Size%KUB)then
                KUB = Me%Size%KUB
            else
                KUB = Start_K + increment
            end if

            if(Start_J - increment < Me%Size%JLB)then
                JLB = 0
            else
                JLB = Start_J - increment
            end if

            if(Start_J + increment > Me%Size%JUB)then
                JUB = Me%Size%JUB
            else
                JUB = Start_J + increment
            end if

            if(Start_I - increment < Me%Size%ILB)then
                ILB = 0
            else
                ILB = Start_I - increment
            end if

            if(Start_I + increment > Me%Size%IUB)then
                IUB = Me%Size%IUB
            else
                IUB = Start_I + increment
            end if

            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if(Me%ExternalVar%Waterpoints3D(i,j,k) == WaterPoint .and. Concentration(i, j, k) > 0.)then

                    Cumulative = Cumulative + Concentration(i, j, k)
                    Count      = Count + 1

                end if
            enddo
            enddo
            enddo

            if(Count > 0)then
                NewValue = Cumulative / Count
            end if

            increment = increment + 1

            !if radius around negative concentration
            !cell is higher then 10 grid cells
            !this is done to avoid an endless loop
            if(increment > 10)then
                write(*,*) 'Could not find neighbour values to correct '
                write(*,*) 'initial negative concentration value.'
                call CloseAllAndStop ('FindNearestPositive - ModuleWaterProperties -  ERR01')
            end if

        end do


    end subroutine FindNearestPositive

    !----------------------------------------------------------------------

     ! This subroutine reads all the information needed to construct the property values
     ! in the domain and in the boundaries

    subroutine Construct_WqRateValues(NewWqRate)
        !Arguments-------------------------------------------------------------
        type(T_wqrate), pointer         :: NewWqRate
        !External--------------------------------------------------------------
        integer                         :: STAT_CALL
        !Local-----------------------------------------------------------------
        integer                         :: ILB, IUB, JLB, JUB, KLB, KUB
        !----------------------------------------------------------------------
        ILB = Me%Size%ILB; JLB = Me%Size%JLB; KUB = Me%Size%KUB
        IUB = Me%Size%IUB; JUB = Me%Size%JUB; KLB = Me%Size%KLB

        allocate(NewWqRate%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('Construct_WqRateValues - ModuleWaterProperties - ERR01')
        NewWqRate%Field(:,:,:) = FillValueReal

    end subroutine Construct_WqRateValues

    !--------------------------------------------------------------------------

    !This functions gives defaul values to each property if this value are not specified

    function DefaultValueProp(PropertyID)
    !Arguments-----------------------------------------------------------------
    real    :: DefaultValueProp
    integer :: PropertyID

case1 : select case(PropertyID)
            case(Temperature_)
                DefaultValueProp = 11.
            case(Salinity_)
                DefaultValueProp = 35.
            case default
                DefaultValueProp = 0.
        end select case1

    end Function DefaultValueProp

    !--------------------------------------------------------------------------
    !This subroutine reads all the information needed to construct the property
    ! evolution parameters

    subroutine Construct_PropertyEvolution(NewProperty,ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty
        integer                                 :: ClientNumber
        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL
        real                                    :: ModelDT
        !Local-----------------------------------------------------------------
        integer                                 :: iflag
        real                                    :: ErrorAux, auxFactor, DTaux
        logical                                 :: VariableDT, Dummy
        character(LEN = StringLength)           :: AuxName
        !----------------------------------------------------------------------

        !Read the options associated with the Nesting
        call ReadSubModelOptions(NewProperty)

        !<BeginKeyword>
            !Keyword          : ADVECTION_DIFFUSION
            !<BeginDescription>
               ! By default the transport due to advection and Diffusion computed for all properties
            !<EndDescription>
            !Type             : Boolean
            !Default          : .true.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>


        call GetData(NewProperty%Evolution%AdvectionDiffusion,                           &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'ADVECTION_DIFFUSION',                               &
                     Default      = .true.,                                              &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR10')

        if (NewProperty%Evolution%AdvectionDiffusion) NewProperty%Evolution%Variable = .true.

        if (NewProperty%evolution%AdvectionDiffusion) call Read_Advec_Difus_Parameters(NewProperty)


        !<BeginKeyword>
            !Keyword          : INSTANT_MIXING
            !<BeginDescription>
               ! This option mix instantaneously the all water column
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%Evolution%InstantMixing,                                &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'INSTANT_MIXING',                                    &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR20')

        if (NewProperty%Evolution%InstantMixing .and. NewProperty%evolution%AdvectionDiffusion) &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR30')

        if(NewProperty%Evolution%InstantMixing) NewProperty%Evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : WATER_QUALITY
            !<BeginDescription>
               ! This property has Water Quality Model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%WaterQuality,                                 &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'WATER_QUALITY',                                     &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR40')

        if(NewProperty%Evolution%WaterQuality) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : MACROALGAE
            !<BeginDescription>
               ! This property has Macroalgae Model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%MacroAlgae,                                  &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'MACROALGAE',                                       &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR50')

        if(NewProperty%Evolution%Macroalgae) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : SEAGRLEAVES
            !<BeginDescription>
               ! This property has BenthicProducers Model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%Evolution%SeagrassesLeaves,                            &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'SEAGRLEAVES',                                &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR55')

        if(NewProperty%Evolution%SeagrassesLeaves) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : CEQUALW2
            !<BeginDescription>
               ! This property has CEQUALW2 model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%CEQUALW2,                                     &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'CEQUALW2',                                          &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR60')

        if(NewProperty%evolution%CEQUALW2) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : LIFE
            !<BeginDescription>
               ! This property has Life model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Life,                                         &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'LIFE',                                              &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR70')

        if(NewProperty%evolution%Life) NewProperty%evolution%Variable = .true.

        call GetData(NewProperty%evolution%Bivalve,                                      &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'BIVALVE',                                           &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR71')

        if(NewProperty%evolution%Bivalve) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : WWTPQ
            !<BeginDescription>
               ! This property has WWTPQ Model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : WWTPQUAL
            !Multiple Options : NO, WWTPQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%WWTPQ,                                        &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'WWTPQ',                                             &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR72')

        if(NewProperty%Evolution%WWTPQ) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : PHREEQC
            !<BeginDescription>
               ! This property has PHREEQC Model as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : PHREEQC
            !Multiple Options : NO, PHREEQC
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%PHREEQC,                                      &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'PHREEQC',                                           &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR73')

        if(NewProperty%Evolution%PHREEQC) NewProperty%evolution%Variable = .true.


        !<BeginKeyword>
            !Keyword          : PARTITION
            !<BeginDescription>
               ! This property has partition as a sink and source
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%Partitioning,                                 &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'PARTITION',                                         &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR80')

        if(NewProperty%evolution%Partitioning) NewProperty%evolution%Variable = .true.

        if(NewProperty%Evolution%Partitioning) call Read_Partition_Parameters(NewProperty)

        !<BeginKeyword>
            !Keyword          : DISCHARGES
            !<BeginDescription>
               !  This property has discharges ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Discharges,                                   &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'DISCHARGES',                                        &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR90')

        if (NewProperty%evolution%Discharges) NewProperty%Evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : DISCHARGES_TRACKING
            !<BeginDescription>
               !  This property writes discharges as time serie ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%DischargesTracking,                           &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'DISCHARGES_TRACKING',                               &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR110')

        !<BeginKeyword>
            !Keyword          : VERTICAL_MOVEMENT
            !<BeginDescription>
               !  This property has free vertical movement ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%FreeVerticalMovement,                         &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'VERTICAL_MOVEMENT',                                 &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR120')

        if (NewProperty%evolution%FreeVerticalMovement)                                  &
            !PropertyX change in time
            NewProperty%Evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : SURFACE_FLUXES
            !<BeginDescription>
               !  This property has surface fluxes ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%evolution%SurfaceFluxes,                                &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'SURFACE_FLUXES',                                    &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR130')

        if (NewProperty%evolution%SurfaceFluxes)                                         &
            NewProperty%Evolution%Variable = .true.

        if (NewProperty%evolution%SurfaceFluxes .and. .not. Me%ExtSurface%PrecipitationON) then

            call GetHydrodynamicAirOptions (Me%ObjHydrodynamic,                         &
                                            SurfaceWaterFluxYes = Me%ExtSurface%PrecipitationON,              &
                                            WindYes = Dummy,             &
                                            AtmPressureYes = Dummy,      &
                                            MslpYes = Dummy, STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR135')
        endif

        !<BeginKeyword>
            !Keyword          : BOTTOM_FLUXES
            !<BeginDescription>
               !  This property has bottom fluxes ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%BottomFluxes,                                 &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'BOTTOM_FLUXES',                                     &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR140')

        if (NewProperty%Evolution%BottomFluxes) NewProperty%Evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : DATA_ASSIMILATION
            !<BeginDescription>
               !  Chek is this property has data assimilation ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : integer
            !Default          : NoNudging
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%DataAssimilation,                             &
                     Me%ObjEnterData, iflag,                                             &
                     ClientModule ='ModuleWaterProperties',                              &
                     Default      = NoNudging,                                           &
                     SearchType   = FromBlock,                                           &
                     keyword      ='DATA_ASSIMILATION',                                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR150')

        if (NewProperty%Evolution%DataAssimilation /= NoNudging) NewProperty%Evolution%Variable = .true.

        if (NewProperty%Evolution%DataAssimilation /= NoNudging      .and.              &
            NewProperty%Evolution%DataAssimilation /= NudgingToRef   .and.              &
            NewProperty%Evolution%DataAssimilation /= NudgingAdvVert .and.              &
            NewProperty%Evolution%DataAssimilation /= Hybrid)then
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR160')
        endif

        if(NewProperty%Evolution%DataAssimilation == Hybrid .and. .not. NewProperty%SubModel%ON)then
            write(*,*)'Data assimilation scheme set to Hybrid but SUBMODEL is not set'
            write(*,*)'Property : ', trim(NewProperty%ID%Name)
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR170')
        endif

        !<BeginKeyword>
            !Keyword          : LIGHT_EXTINCTION
            !<BeginDescription>
               !  Chek is this property is used to compute light extinction? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%Evolution%LightExtinction,                             &
                     Me%ObjEnterData, iflag,                                            &
                     ClientModule ='ModuleWaterProperties',                             &
                     Default      = OFF,                                                &
                     SearchType   = FromBlock,                                          &
                     keyword      ='LIGHT_EXTINCTION',                                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR180')


        if(NewProperty%Evolution%LightExtinction)then

            call GetData(NewProperty%Evolution%Extinction%Coefficient,                  &
                         Me%ObjEnterData, iflag,                                        &
                         ClientModule ='ModuleWaterProperties',                         &
                         Default      = 1.0,                                            &
                         SearchType   = FromBlock,                                      &
                         keyword      ='EXTINCTION_PARAMETER',                          &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR190')
        end if

        call GetData(NewProperty%Evolution%Filtration%On,                               &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'FILTRATION',                                       &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR200')

        if(NewProperty%Evolution%Filtration%On) NewProperty%evolution%Variable = .true.

        if(NewProperty%Evolution%Filtration%On)                                           &
            call Read_Filtration_Parameters(NewProperty,ClientNumber)

       !<BeginKeyword>
            !Keyword          : LAG_SINKS_SOURCES
            !<BeginDescription>
            ! This property has sinks and sources computed in the lagrangian module
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%LagSinksSources,                             &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'LAG_SINKS_SOURCES',                                &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR210')

        if(NewProperty%Evolution%LagSinksSources) NewProperty%evolution%Variable = .true.

        !<BeginKeyword>
            !Keyword          : FIRST_ORDER_DECAY
            !<BeginDescription>
               !  This property has a first order decay ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%FirstOrderDecay,                              &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'FIRST_ORDER_DECAY',                                 &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR220')

        if (NewProperty%evolution%FirstOrderDecay) then

            NewProperty%evolution%Variable = .true.

            !<BeginKeyword>
                !Keyword          : T90_PROPERTY_NAME
                !<BeginDescription>
                  !  The time in seconds to decay an order of magnitude ?
                !<EndDescription>
                !Type             : real
                !Default          : 'T90')
                !File keyword     : DISPQUAL
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(AuxName,                                                       &
                         Me%ObjEnterData, iflag,                                        &
                         SearchType   = FromBlock,                                      &
                         keyword      = 'T90_PROPERTY_NAME',                            &
                         Default      = trim(GetPropertyName(T90_)),                    &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR230')

            if (.not.CheckPropertyName(trim(AuxName),NewProperty%evolution%T90PropertyID)) then
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR240')
            endif

        endif

        !<BeginKeyword>
            !Keyword          : DECAY_RATE_PROPERTY
            !<BeginDescription>
               !  This property is a decay rate ? no - 0;  yes - 1
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%DecayRateProperty,                            &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'DECAY_RATE_PROPERTY',                               &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR250')

        if (NewProperty%evolution%DecayRateProperty) then

            NewProperty%Evolution%AdvectionDiffusion = .false.

            call GetData(NewProperty%evolution%T90Variable,                             &
                             Me%ObjEnterData,                                           &
                             iflag,                                                     &
                             SearchType   = FromBlock,                                  &
                             keyword      ='T90_VARIABLE',                              &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = .false.,                                    &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR260')

            call GetData(NewProperty%evolution%T90Hours,                                &
                             Me%ObjEnterData,                                           &
                             iflag,                                                     &
                             SearchType   = FromBlock,                                  &
                             keyword      ='T90_HOURS',                                 &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = .false.,                                    &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR265')

            if (NewProperty%evolution%T90Variable) then

                call GetData(NewProperty%evolution%T90Var_Method,                       &
                             Me%ObjEnterData,                                           &
                             iflag,                                                     &
                             SearchType   = FromBlock,                                  &
                             keyword      ='T90_VAR_METHOD',                            &
                             ClientModule ='ModuleWaterProperties',                     &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR270')

                if (iflag /= 1) then
                    write(*,*)'Keyword T90_VAR_METHOD not defined for decay of variable fecal coliforms decay'
                    call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR280')
                endif

                if (NewProperty%evolution%T90Var_Method /= Canteras .and.           &
                    NewProperty%evolution%T90Var_Method /= Chapra) then
                    write (*,*) 'T90 calculation method unknown'
                    call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR290')
                endif

            endif

        endif

        if (NewProperty%ID%IDNumber == Oxygen_) then
            call GetData(NewProperty%evolution%OxygenSaturation,                        &
                             Me%ObjEnterData, iflag,                                    &
                             SearchType   = FromBlock,                                  &
                             keyword      ='OXYGEN_SATURATION',                         &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = .false.,                                    &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                              &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR260')

            if (NewProperty%evolution%OxygenSaturation) then
                Me%OxygenSaturation = .true.
                NewProperty%Evolution%AdvectionDiffusion = .false.
            endif

        else
            NewProperty%evolution%OxygenSaturation = .false.
        endif


        if (NewProperty%ID%IDNumber == CarbonDioxide_) then
            call GetData(NewProperty%evolution%CO2_PP_Output,                           &
                             Me%ObjEnterData, iflag,                                    &
                             SearchType   = FromBlock,                                  &
                             keyword      ='CO2_PPRESSURE_OUTPUT',                      &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = .false.,                                    &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                              &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR270')

        endif

        if (NewProperty%ID%IDNumber == Oxygen_) then
            call GetData(NewProperty%evolution%O2_Sat_Output,                           &
                             Me%ObjEnterData, iflag,                                    &
                             SearchType   = FromBlock,                                  &
                             keyword      ='O2_SATURATION_OUTPUT',                      &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = .false.,                                    &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                              &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR280')

        endif

        if (NewProperty%ID%IDNumber == PHYTOPLANKTON_) then
            call GetData(NewProperty%evolution%CHLA_WQ_Output,                          &
                             Me%ObjEnterData, iflag,                                    &
                             SearchType   = FromBlock,                                  &
                             keyword      ='CHLA_WQ_OUTPUT',                            &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = .false.,                                    &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR290')

        endif

        if (NewProperty%ID%IDNumber == PHYTOPLANKTON_) then
            call GetData(NewProperty%evolution%C_CHLA_Output,                           &
                             Me%ObjEnterData, iflag,                                    &
                             SearchType   = FromBlock,                                  &
                             keyword      ='C_CHLA_OUTPUT',                             &
                             ClientModule ='ModuleWaterProperties',                     &
                             Default      = 60.0,                                       &
                             STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                              &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR300')

        endif

       !<BeginKeyword>
            !Keyword          : REINITIALIZE
            !<BeginDescription>
            ! This property will be reinitialize in run time using boxes (option introduce in the framework of cowama)
            !<EndDescription>
            !Type             : Logical
            !Default          : FALSE
            !File keyword     : DISPQUAL
            !Multiple Options : NO, WQM
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Evolution%Reinitialize%On,                             &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'REINITIALIZE',                                     &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR295')

        if (NewProperty%Evolution%Reinitialize%On) call Read_Reinitialize_Parameters(NewProperty, ClientNumber)

        !Time Step if the property field is variable in time
        if (NewProperty%Evolution%Variable) then

            call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR300')

            call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR310')

            if (VariableDT) then

                NewProperty%Evolution%DTInterval       = ModelDT
                NewProperty%Evolution%HydroIntegration = .false.

            else

            !<BeginKeyword>
                !Keyword          : DT_INTERVAL
                !<BeginDescription>
                   ! In the future a GET_DT_Hydro to a hydrodynamic module should be done to know the DT value
                   ! that is been used to computethe the velocity field
                   ! By default the DTinterval is equal to the time step of the hydrodynamic model. In this case
                   ! is admitted that the hydrodynamic model is computing the velocity field using a ADI method.
                !<EndDescription>
                !Type             : Real
                !Default          : Time step of hydrodynamic model
                !File keyword     : DISPQUAL
                !Multiple Options : Do not have
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>

            call GetData(NewProperty%evolution%DTInterval,                          &
                         Me%ObjEnterData, iflag,                                    &
                         SearchType     = FromBlock,                                &
                         keyword        = 'DT_INTERVAL',                            &
                         Default        = ModelDT,                                  &
                         ClientModule   = 'ModuleWaterProperties',                  &
                         STAT           = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                            &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR320')


            if (NewProperty%evolution%DTInterval < (ModelDT)) then
                write(*,*)
                write(*,*) ' Time step error.'
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR330')

            elseif (NewProperty%evolution%DTInterval > (ModelDT)) then

                !Property DT  must be a multiple of the ModelDT
                auxFactor = NewProperty%evolution%DTInterval  / ModelDT

                Erroraux = auxFactor - int(auxFactor)
                if (Erroraux /= 0) then
                    write(*,*)
                    write(*,*) ' Time step error.'
                    call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR340')
                endif

                    ! Run period in seconds
                    DTaux = Me%EndTime - Me%ExternalVar%Now

                    !The run period   must be a multiple of the Property DT
                    auxFactor = DTaux / NewProperty%evolution%DTInterval

                    ErrorAux = auxFactor - int(auxFactor)
                    if (ErrorAux /= 0) then
                        write(*,*)
                        write(*,*) ' Time step error.'
                        call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR350')
                    endif

                    NewProperty%Evolution%HydroIntegration = .true.

                else
                    NewProperty%Evolution%HydroIntegration = .false.
                end if

            endif

            NewProperty%Evolution%NextCompute = Me%ExternalVar%Now + NewProperty%Evolution%DTInterval

        else

            call null_time(NewProperty%Evolution%NextCompute)

            NewProperty%evolution%DTInterval = FillValueReal

        endif

        if (Me%NoFlux%ON) then

            !<BeginKeyword>
                !Keyword          : NO_ADV_FLUX_CELLS
                !<BeginDescription>
                   !  For this property in cell faces with velocity nudging a no advection flux condition is assumed.
                   !  If the flux is different from zero a mass balace inconsistence takes place
                !<EndDescription>
                !Type             : Boolean
                !Default          : Me%NoFlux%ON
                !File keyword     : DISPQUAL
                !Multiple Options : 1 (.true.), 0 (.false.)
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(NewProperty%evolution%NoAdvFluxCells,                               &
                         Me%ObjEnterData, iflag,                                             &
                         SearchType   = FromBlock,                                           &
                         keyword      = 'NO_ADV_FLUX_CELLS',                                 &
                         Default      = Me%NoFlux%ON,                                        &
                         ClientModule = 'ModuleWaterProperties',                             &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR360')


            !<BeginKeyword>
                !Keyword          : NO_DIF_FLUX_CELLS
                !<BeginDescription>
                   !  For this property in cell faces with velocity nudging a no diffusion flux condition is assumed.
                !<EndDescription>
                !Type             : Boolean
                !Default          : Me%NoFlux%ON
                !File keyword     : DISPQUAL
                !Multiple Options : 1 (.true.), 0 (.false.)
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(NewProperty%evolution%NoDifFluxCells,                               &
                         Me%ObjEnterData, iflag,                                             &
                         SearchType   = FromBlock,                                           &
                         keyword      = 'NO_DIF_FLUX_CELLS',                                 &
                         Default      = Me%NoFlux%ON,                                        &
                         ClientModule = 'ModuleWaterProperties',                             &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                     &
                call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR370')

        else
            NewProperty%evolution%NoAdvFluxCells = .false.
            NewProperty%evolution%NoDifFluxCells = .false.
        endif

        if (.not. NewProperty%evolution%variable .and. NewProperty%Submodel%TwoWay)then
            write(*,*) 'Model not made to run TwoWay if property is constant over time', trim(NewProperty%ID%Name)
            call CloseAllAndStop ('Subroutine Construct_PropertyEvolution - ModuleWaterProperties - ERR380')
        endif

        !Checks if user wants to compute and output mass destroid or gained due to upscaling (set in son domain only)
        call GetData(NewProperty%UpscalingSinkSource,                                   &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'UPSCALING_SINK_SOURCE',                          &
                     Default        = .false.,                                          &
                     SearchType     = FromBlock,                                        &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyEvolution - ModuleWaterProperties - ERR390')

        if (NewProperty%UpscalingSinkSource .and. .not. NewProperty%SubModel%ON) &
            call CloseAllAndStop ('UPSCALING_SINK_SOURCE keyword must only be defined in Son domain')

        !----------------------------------------------------------------------

    end subroutine Construct_PropertyEvolution

    !--------------------------------------------------------------------------

    subroutine CheckDischarges (NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty

        !Local-----------------------------------------------------------------
        logical                         :: HydroDischarge
        !Begin----------------------------------------------------------------------------

       if (NewProperty%evolution%Discharges .and. (.not. NewProperty%evolution%AdvectionDiffusion))  then
            write(*,*)
            write(*,*)' Property ', trim(NewProperty%ID%Name), ' discharged without advection-diffusion.'
            call CloseAllAndStop ('Subroutine CheckDischarges - ModuleWaterProperties - ERR10')
        end if

        call GetPointDischargesState(Me%ObjHydrodynamic, HydroDischarge)

        if (.not. NewProperty%evolution%Discharges) then
            if (HydroDischarge .and. NewProperty%evolution%AdvectionDiffusion)  then
                write(*,*)' Property ', trim(NewProperty%ID%Name), ' must have DISCHARGES active as there is a waterdischarge'
                call CloseAllAndStop ('Subroutine CheckDischarges - ModuleWaterProperties - ERR020')
            endif
        endif

    end subroutine CheckDischarges

    !--------------------------------------------------------------------------
    !Advection / Diffusion parameters

    subroutine Read_Advec_Difus_Parameters(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty

        !External--------------------------------------------------------------
        integer                         :: STAT_CALL
        integer                         :: MassConservation
        integer                         :: ImposedValue
        integer                         :: NullGradient, CyclicBoundary
        integer                         :: SubModel, Orlanski, MassConservNullGrad

        !Local-----------------------------------------------------------------
        integer                         :: iflag, BoundaryCondition
        integer                         :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                         :: WorkKLB, WorkKUB
        integer                         :: KLB, KUB, JLB, JUB, ILB, IUB
        integer                         :: i, j, k

        !Begin----------------------------------------------------------------------------


        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB
        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB
        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        ILB     = Me%Size%ILB
        IUB     = Me%Size%IUB
        JLB     = Me%Size%JLB
        JUB     = Me%Size%JUB
        KLB     = Me%Size%KLB
        KUB     = Me%Size%KUB

        !<BeginKeyword>
            !Keyword          : ADV_DIF_NUM_STABILITY
            !<BeginDescription>
               !Verifies advection-diffusion numerical stability
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%NumericStability,     &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'ADV_DIF_NUM_STABILITY',                              &
                     default    = .FALSE.,                                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR10')

        !<BeginKeyword>
            !Keyword          : SCHMIDT_NUMBER_H
            !<BeginDescription>
               ! Schmidt number for the horizontal. Conversion number between the
               !horizontal turbulent viscosity and
               ! the horizontal turbulent Diffusion. If the property is Heat the name
               ! of this number is not SCHMIDT but prandtl
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 1.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%SchmidtNumberH,       &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'SCHMIDT_NUMBER_H',                                   &
                     Default    = 1.0,                                                  &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR20')

        !<BeginKeyword>
            !Keyword          : SCHMIDT_COEF_V
            !<BeginDescription>
               ! Manolo THis is not a proper schmidt number. Changed to
               ! SCHMIDT_COEF_V SCHMIDT_BACKGROUND_V. In advection diff
               ! Diffusivity of each property is calculated as
               ! SCHMIDT_COEF_V*TURBULENTDIFFUSIVITY+SCHMIDT_BACKGROUND_V
               ! schmidt number for the vertical
            !<EndDescription>
            !Type             : Real
            !Default          : 1.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%SchmidtCoefV,         &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'SCHMIDT_COEF_V',                                     &
                     Default    = 1.0,                                                  &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR30')

        !<BeginKeyword>
            !Keyword          : SCHMIDT_BACKGROUND_V
            !<BeginDescription>
               ! Manolo THis is not a proper schmidt number. Changed to
               ! SCHMIDT_COEF_V SCHMIDT_BACKGROUND_V. In advection diff
               ! Diffusivity of each property is calculated as
               ! SCHMIDT_COEF_V*TURBULENTDIFFUSIVITY+SCHMIDT_BACKGROUND_V
               ! schmidt number for the vertical
            !<EndDescription>
            !Type             : Real
            !Default          : !molecular diffusivity 1e-8: 1.4e-7 for temperature, 1.1e-9 for salinity
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%SchmidtBackgroundV,   &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'SCHMIDT_BACKGROUND_V',                               &
                     Default    = 1.e-8,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR40')


        !<BeginKeyword>
            !Keyword          : ADVECTION_V_IMP_EXP
            !<BeginDescription>
               ! ADVECTION_V_IMP_EXP = 0 - vertical advection computed using a implicit discretization
               ! ADVECTION_V_IMP_EXP = 1 - vertical advection computed using a explicit discretization
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.0
            !File keyword     : DISPQUAL
            !Multiple Options : 1.0, 0.0
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%AdvectionV_imp_exp,   &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'ADVECTION_V_IMP_EXP',                                &
                     Default    = 0.0,                                                  &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR50')

        NewProperty%evolution%Advec_Difus_Parameters%AdvectionV_imp_exp =               &
            1. - NewProperty%evolution%Advec_Difus_Parameters%AdvectionV_imp_exp

        !<BeginKeyword>
            !Keyword          : DIFFUSION_V_IMP_EXP
            !<BeginDescription>
               ! Diffusion_V_IMP_EXP = 0 - vertical Diffusion computed using a implicit discretization
               ! Diffusion_V_IMP_EXP = 1 - vertical Diffusion computed using a explicit discretization
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.0
            !File keyword     : DISPQUAL
            !Multiple Options : 1.0, 0.0
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%DiffusionV_imp_exp,   &
                     Me%ObjEnterData,iflag,                                             &
                     SearchType = FromBlock,                                            &
                     keyword    = 'DIFFUSION_V_IMP_EXP',                                &
                     Default    = 0.,                                                   &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR60')

        NewProperty%evolution%Advec_Difus_Parameters%DiffusionV_imp_exp = 1. -          &
            NewProperty%evolution%Advec_Difus_Parameters%DiffusionV_imp_exp

        !<BeginKeyword>
            !Keyword          : NULLDIF
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.), 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%NullDif,              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'NULLDIF',                                            &
                     Default    = .false.,                                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR70')


        !<BeginKeyword>
            !Keyword          : DECAY_TIME
            !<BeginDescription>
               ! If DECAY_TIME = 0. - The boundary value is constant along time
               ! If DECAY_TIME -> infinity - The boundary value is equal to the computed value
               !
            !<EndDescription>
            !Type             : real
            !Default          : By default the decay time is zero the value
            !                   of this property in the open boundary is always constant
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%DecayTime,            &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromBlock,                                            &
                     keyword    = 'DECAY_TIME',                                         &
                     Default    = 0.,                                                   &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR80')

        call GetBoundaryConditionList(MassConservation   = MassConservation,            &
                              ImposedValue               = ImposedValue,                &
                              NullGradient               = NullGradient,                &
                              SubModel                   = SubModel,                    &
                              Orlanski                   = Orlanski,                    &
                              MassConservNullGrad        = MassConservNullGrad,         &
                              CyclicBoundary             = CyclicBoundary)

        !<BeginKeyword>
            !Keyword          : BOUNDARY_CONDITION
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Integer
            !Default          : 1
            !File keyword     : DISPQUAL
            !Multiple Options : 1-MassConservation,2-ImposedValue,3-VerticalDiffusion,
            !                   4-NullGradient,5-SubModel,6-Orlanski,8-CyclicBoundary
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(BoundaryCondition,                                                 &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'BOUNDARY_CONDITION',                               &
                     Default      = MassConservation,                                   &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR90')

        if (BoundaryCondition /= MassConservation              .and.                    &
            BoundaryCondition /= ImposedValue                  .and.                    &
            BoundaryCondition /= SubModel                      .and.                    &
            BoundaryCondition /= NullGradient                  .and.                    &
            BoundaryCondition /= CyclicBoundary                .and.                    &
            BoundaryCondition /= Orlanski                      .and.                    &
            BoundaryCondition /= MassConservNullGrad                )                   &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR100')


        NewProperty%evolution%Advec_Difus_Parameters%BoundaryCondition = BoundaryCondition



        if (BoundaryCondition == SubModel .and. .not. NewProperty%SubModel%ON)          &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR110')


cd1:    if (BoundaryCondition == Orlanski) then

            allocate(NewProperty%evolution%Advec_Difus_Parameters%PropOld               &
                     (ILB:IUB,JLB:JUB,KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR120')


            do k = WorkKLB, WorkKUB
            do j = WorkJLB, WorkJUB
            do i = WorkILB, WorkIUB

                NewProperty%evolution%Advec_Difus_Parameters%PropOld(i, j, k) =         &
                    NewProperty%Concentration(i, j, k)
            enddo
            enddo
            enddo

        endif cd1

        !<BeginKeyword>
            !Keyword          : ADVECTION_H_IMP_EXP
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 1.0
            !File keyword     : DISPQUAL
            !Multiple Options : 0.0 (), 1.0 (explicit horizontal advection discretization)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%AdvectionH_imp_exp,   &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'ADVECTION_H_IMP_EXP',                                &
                     default    = 1.0,                                                  &
                     SearchType = FromBlock,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR130')

        NewProperty%evolution%Advec_Difus_Parameters%AdvectionH_imp_exp =               &
            1. - NewProperty%evolution%Advec_Difus_Parameters%AdvectionH_imp_exp

        !By default the horizontal Diffusion discretization is explicit
        NewProperty%evolution%Advec_Difus_Parameters%DiffusionH_imp_exp   = 0.

        NewProperty%evolution%Advec_Difus_Parameters%ImplicitH_Direction = DirectionX


        call GetData(NewProperty%evolution%Advec_Difus_Parameters%AdvMethodH,           &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'ADV_METHOD_H',                                       &
                     Default    = UpwindOrder1,                                         &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR140')

        call GetData(NewProperty%evolution%Advec_Difus_Parameters%TVDLimitationH,       &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'TVD_LIMIT_H',                                        &
                     Default    = Superbee,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR150')

        call GetData(NewProperty%evolution%Advec_Difus_Parameters%AdvMethodV,           &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'ADV_METHOD_V',                                       &
                     Default    = UpwindOrder1,                                         &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR160')

        call GetData(NewProperty%evolution%Advec_Difus_Parameters%TVDLimitationV,       &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'TVD_LIMIT_V',                                        &
                     Default    = Superbee,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR170')


        call GetData(NewProperty%evolution%Advec_Difus_Parameters%VolumeRelMax,         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'VOLUME_RELATION_MAX',                                &
                     Default    = 1.5,                                                  &
                     SearchType = FromFile,                                             &
                     ClientModule ='ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR180')


        if (NewProperty%evolution%Advec_Difus_Parameters%AdvMethodH == UpwindOrder2 .or.&
            NewProperty%evolution%Advec_Difus_Parameters%AdvMethodH == UpwindOrder3 .or.&
            NewProperty%evolution%Advec_Difus_Parameters%AdvMethodH == P2_TVD) then
            NewProperty%evolution%Advec_Difus_Parameters%Upwind2H = .true.
        else
            NewProperty%evolution%Advec_Difus_Parameters%Upwind2H = .false.
        endif

        if (NewProperty%evolution%Advec_Difus_Parameters%AdvMethodV == UpwindOrder2 .or.&
            NewProperty%evolution%Advec_Difus_Parameters%AdvMethodV == UpwindOrder3 .or.&
            NewProperty%evolution%Advec_Difus_Parameters%AdvMethodV == P2_TVD) then
            NewProperty%evolution%Advec_Difus_Parameters%Upwind2V = .true.
        else
            NewProperty%evolution%Advec_Difus_Parameters%Upwind2V = .false.
        endif


        if (NewProperty%evolution%Advec_Difus_Parameters%AdvectionH_imp_exp > 0.   .and.&
           (NewProperty%evolution%Advec_Difus_Parameters%AdvMethodH == UpwindOrder2 .or.&
            NewProperty%evolution%Advec_Difus_Parameters%AdvMethodH == UpwindOrder3)) then

            write(*,*) 'If the advection of mass in the horizontal is implicit'
            write(*,*) 'the advection method can not be a second or third order upwind'
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR190.')

        endif

        if (NewProperty%evolution%Advec_Difus_Parameters%AdvectionV_imp_exp > 0.   .and.&
           (NewProperty%evolution%Advec_Difus_Parameters%AdvMethodV == UpwindOrder2 .or.&
            NewProperty%evolution%Advec_Difus_Parameters%AdvMethodV == UpwindOrder3)) then

            write(*,*) 'If the advection of mass in the vertical is implicit'
            write(*,*) 'the advection method can not be a second or third order upwind'
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - WaterProperties - ERR200.')

        endif

        !<BeginKeyword>
            !Keyword          : ADVECTION_NUDGING
            !<BeginDescription>
               !
               ! When using null-gradient for a property, one may want to nudge
               !the advection of that property to null near the open-boundaries.
               ! This method could avoid undesired advection due to
               ! spurious velocities accumulated at the open-boundaries.
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .FALSE.
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Advec_Difus_Parameters%AdvectionNudging,     &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'ADVECTION_NUDGING',                                  &
                     default    = .false.,                                              &
                     SearchType = FromBlock,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR210')

        if ( BoundaryCondition /= NullGradient .and. NewProperty%evolution%Advec_Difus_Parameters%AdvectionNudging ) then
            write(*,*) 'WARNING: When ADVECTION_NUDGING is ACTIVATED the BOUNDARY_CONDITION should be NULLGRADIENT.'
        end if

        if ( NewProperty%evolution%Advec_Difus_Parameters%AdvectionNudging ) then

            !<BeginKeyword>
                !Keyword          : ADVECTION_NUDGING_CELLS
                !<BeginDescription>
                !
                ! Number of cells to use when using ADVECTION_NUDGING
                !
                !<EndDescription>
                !Type             : Integer
                !Default          : 10
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(NewProperty%evolution%Advec_Difus_Parameters%AdvectionNudgingCells,&
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'ADVECTION_NUDGING_CELLS',                            &
                     default    = 10,                                                   &
                     SearchType = FromBlock,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Read_Advec_Difus_Parameters - ModuleWaterProperties - ERR220')

        endif


    end subroutine Read_Advec_Difus_Parameters


    !--------------------------------------------------------------------------
    !SubModel options

    subroutine ReadSubModelOptions(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty

        !External--------------------------------------------------------------
        integer                         :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                         :: iflag


        !Begin----------------------------------------------------------------------------

        !<BeginKeyword>
            !Keyword          : SUBMODEL
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%SubModel%ON,                                            &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'SUBMODEL',                                          &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR10')


        !<BeginKeyword>
            !Keyword          : SUBMODEL_INI
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%SubModel%Initial,                                       &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'SUBMODEL_INI',                                      &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR20')

        !<BeginKeyword>
            !Keyword          : SUBMODEL_EXTRAPOLATE
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Logical
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%SubModel%Extrapolate,                                   &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'SUBMODEL_EXTRAPOLATE',                              &
                     Default      = OFF,                                                 &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR30')

        call GetData(NewProperty%Submodel%TwoWay,                                        &
                    Me%ObjEnterData, iflag,                                              &
                    Keyword    = 'TWO_WAY',                                              &
                    Default    = OFF,                                                    &
                    SearchType = FromBlock,                                              &
                    ClientModule ='ModuleWaterProperties',                               &
                    STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR40')

        if (NewProperty%Submodel%TwoWay .and. .not. NewProperty%SubModel%ON) then
            write(*,*) 'Keyword TWO_WAY must ONLY be defined in nested son domains'
            call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR50')
        endif

        if (NewProperty%Submodel%TwoWay)then

            !Period during which the two way is not computed (to avoid assimilation of instabilities)
            call GetData(NewProperty%Submodel%TwoWayWaitPeriod,                               &
                        Me%ObjEnterData, iflag,                                               &
                        Keyword      = 'TWO_WAY_WAIT_PERIOD',                                 &
                        Default      = 0.,                                                    &
                        SearchType   = FromBlock,                                             &
                        ClientModule ='ModuleWaterProperties',                                &
                        STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                        &
                call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR60')

            if (NewProperty%Old)then
                NewProperty%Submodel%TwoWayWaitPeriod = 0.
            endif

            call GetData(NewProperty%Submodel%TwoWayTimeDecay,                                &
                        Me%ObjEnterData, iflag,                                               &
                        Keyword      = 'TWO_WAY_TIME_DECAY',                                  &
                        Default      = 86400.,                                                &
                        SearchType   = FromBlock,                                             &
                        ClientModule ='ModuleWaterProperties',                                &
                        STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                        &
                call CloseAllAndStop ('ReadSubModelOptions - ModuleWaterProperties - ERR70')

        endif

    end subroutine ReadSubModelOptions


    !--------------------------------------------------------------------------
    subroutine Read_Partition_Parameters(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                                 :: iflag
        real                                    :: DefaultFraction

        !Begin-----------------------------------------------------------------


        !<BeginKeyword>
            !Keyword          : PARTITION_FRACTION
            !<BeginDescription>
               !
               ! Partition fraction
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 0.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        if(NewProperty%ID%IsParticulate)then
            DefaultFraction = 0.9
        else
            DefaultFraction = 0.1
        end if

        call GetData(NewProperty%evolution%Partition%Fraction,                          &
                     Me%ObjEnterData, iflag,                                            &
                     keyword    = 'PARTITION_FRACTION',                                 &
                     default    = DefaultFraction,                                      &
                     SearchType = FromBlock,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR10')

        !<BeginKeyword>
            !Keyword          : PARTITION_RATE
            !<BeginDescription>
               !
               ! Partition transfer rate between the particulate and the dissolved phase
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 1.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%evolution%Partition%Rate,                              &
                     Me%ObjEnterData, iflag,                                            &
                     keyword      = 'PARTITION_RATE',                                   &
                     default      = 1.,                                                 &
                     SearchType   = FromBlock,                                          &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR20')


        !<BeginKeyword>
            !Keyword          : USE_SED_REF_CONC
            !<BeginDescription>
               !
               ! Use Reference cohesive sediment concentration method
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 1.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%evolution%Partition%UseSedimentRefConc,                 &
                     Me%ObjEnterData, iflag,                                             &
                     keyword      = 'USE_SED_REF_CONC',                                  &
                     default      = OFF,                                                 &
                     SearchType   = FromBlock,                                           &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR30')

        if(NewProperty%evolution%Partition%UseSedimentRefConc)then

            !<BeginKeyword>
                !Keyword          : SED_REF_CONC
                !<BeginDescription>
                   !
                   ! Reference cohesive sediment concentration
                   !
                !<EndDescription>
                !Type             : Real
                !Default          : 1.0
                !File keyword     : DISPQUAL
                !Multiple Options : Do not have
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>

            call GetData(NewProperty%evolution%Partition%SedimentRefConc,               &
                         Me%ObjEnterData, iflag,                                        &
                         keyword      = 'SED_REF_CONC',                                 &
                         default      = 1.,                                             &
                         SearchType   = FromBlock,                                      &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR30')

        end if

        !<BeginKeyword>
            !Keyword          : PARTITION_COUPLE
            !<BeginDescription>
               !
               ! Name of property (dissolved/particulated) to couple
               !
            !<EndDescription>
            !Type             : Character
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>

        call GetData(NewProperty%Evolution%Partition%Couple,                             &
                     Me%ObjEnterData, iflag,                                             &
                     keyword      = 'PARTITION_COUPLE',                                  &
                     ClientModule ='ModuleWaterProperties',                              &
                     SearchType   = FromBlock,                                           &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR40')
        if (iflag .NE. 1)                                                                &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR50')

        !<BeginKeyword>
            !Keyword          : SALINITY_EFFECT
            !<BeginDescription>
               ! Verifies if the user wants to compute partition coefficient between the
               ! particulate and the dissolved phase function of salinity
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Partition%SalinityEffect,                     &
                     Me%ObjEnterData, iflag,                                             &
                     keyword      = 'SALINITY_EFFECT',                                   &
                     default      = OFF,                                                 &
                     SearchType   = FromBlock,                                           &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR60')


cd1:    if (NewProperty%Evolution%Partition%SalinityEffect) then

            !<BeginKeyword>
                !Keyword          : EMPIRIC_COEF
                !<BeginDescription>
                   !
                   ! Do not have
                   !
                !<EndDescription>
                !Type             : Real
                !Default          : -14.505
                !File keyword     : DISPQUAL
                !Multiple Options : Do not have
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(NewProperty%evolution%Partition%EmpiricCoef,                    &
                         Me%ObjEnterData, iflag,                                         &
                         keyword      = 'EMPIRIC_COEF',                                  &
                         default      = -14.505 ,                                        &
                         SearchType   = FromBlock,                                       &
                         ClientModule = 'ModuleWaterProperties',                         &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR70')

        endif cd1

        !<BeginKeyword>
            !Keyword          : NON_COMPLIANCE_CRITERIA
            !<BeginDescription>
               ! Verifies if the user wants to define a non-compliance criterium
               ! for the concentration of the contaminant
               !
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%evolution%Partition%NonComplianceCriteria,                     &
                     Me%ObjEnterData, iflag,                                             &
                     keyword      = 'NON_COMPLIANCE_CRITERIA',                           &
                     default      = OFF,                                                 &
                     SearchType   = FromBlock,                                           &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR80')

cd2:    if (NewProperty%Evolution%Partition%NonComplianceCriteria) then

            !<BeginKeyword>
                !Keyword          : CONC_LIM
                !<BeginDescription>
                   !
                   ! The maximum concentration allowed for the contaminant in the water
                   ! above which the water quality is considered negatively affected by the contaminant
                   !
                !<EndDescription>
                !Type             : Real
                !Default          : 0
                !File keyword     : DISPQUAL
                !Multiple Options : Do not have
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(NewProperty%Evolution%Partition%MaxConc,                    &
                         Me%ObjEnterData, iflag,                                         &
                         keyword      = 'CONC_LIM',                                  &
                         default      = 0.000 ,                                        &
                         SearchType   = FromBlock,                                       &
                         ClientModule = 'ModuleWaterProperties',                         &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                call CloseAllAndStop ('Read_Partition_Parameters - ModuleWaterProperties - ERR90')

        endif cd2

    end subroutine Read_Partition_Parameters

    !--------------------------------------------------------------------------

    subroutine Read_Filtration_Parameters(NewProperty,ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty
        integer                                 :: ClientNumber

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL, iflag

        !Local-----------------------------------------------------------------
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        logical                                 :: BlockFound
        character(len=StringLength)             :: Excreted_Property, GrazedProperty

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

       !Begin-----------------------------------------------------------------


        allocate(NewProperty%Filtration(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR10')

        NewProperty%Filtration(:,:,:) = FillValueReal

        allocate(NewProperty%Evolution%Filtration%Rate(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                                 &
            call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR20')

        NewProperty%Evolution%Filtration%Rate(:,:,:) = FillValueReal

        allocate(NewProperty%Evolution%Filtration%FilterFeederMass(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                                 &
            call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR30')

        NewProperty%Evolution%Filtration%FilterFeederMass(:,:,:) = FillValueReal

        allocate(NewProperty%Evolution%Filtration%Cumulative(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                                 &
            call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR40')

        NewProperty%Evolution%Filtration%Cumulative(:,:,:) = 0.

        allocate(NewProperty%Evolution%Filtration%CumulativePerMeter(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                                 &
            call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR50')

        NewProperty%Evolution%Filtration%CumulativePerMeter(:,:,:) = 0.


        call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                                    &
                                   '<<begin_filtrationrate>>', '<<end_filtrationrate>>', BlockFound, &
                                   STAT = STAT_CALL)

        if (BlockFound) then
            call ConstructFillMatrix  ( PropertyID           = NewProperty%Evolution%Filtration%ID,  &
                                        EnterDataID          = Me%ObjEnterData,                      &
                                        TimeID               = Me%ObjTime,                           &
                                        HorizontalGridID     = Me%ObjHorizontalGrid,                 &
                                        GeometryID           = Me%ObjGeometry,                       &
                                        ExtractType          = FromBlockInBlock,                     &
                                        PointsToFill3D       = Me%ExternalVar%WaterPoints3D,         &
                                        Matrix3D             = NewProperty%Evolution%Filtration%Rate,&
                                        TypeZUV              = TypeZ_,                               &
                                        STAT                 = STAT_CALL)
             if (STAT_CALL /= SUCCESS_)                                                              &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR60')


             call KillFillMatrix(NewProperty%Evolution%Filtration%ID%ObjFillMatrix, STAT = STAT_CALL)

             if (STAT_CALL /= SUCCESS_)&
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR70')

            call GetData(NewProperty%Evolution%Filtration%MinConcentrationToFilter,     &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'MIN_CONCENTRATION_TO_FILTER',                &
                         Default        = 0.,                                           &
                         SearchType     = FromBlockInBlock,                             &
                         ClientModule   = 'ModuleWaterProperties',                      &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR71')


            call GetData(NewProperty%Evolution%Filtration%Excretions,                   &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'EXCRETIONS',                                 &
                         Default        = .false.,                                      &
                         SearchType     = FromBlockInBlock,                             &
                         ClientModule   = 'ModuleWaterProperties',                      &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR80')

            if(NewProperty%Evolution%Filtration%Excretions)then

                call GetData(Excreted_Property,                                         &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'EXCRETED_PROPERTY',                      &
                             SearchType     = FromBlockInBlock,                         &
                             ClientModule   = 'ModuleWaterProperties',                  &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR90')


                if(.not. CheckPropertyName(trim(Excreted_Property),                     &
                    Number = NewProperty%Evolution%Filtration%Excreted_Property_ID))then
                    write(*,*)
                    write(*,*) 'The excreted property name is not recognised by the model'
                    call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR100')

                end if

                call GetData(NewProperty%Evolution%Filtration%StoichiometricRatio,      &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'STOICHIOMETRIC_RATIO',                   &
                             Default        = 1.,                                       &
                             SearchType     = FromBlockInBlock,                         &
                             ClientModule   = 'ModuleWaterProperties',                  &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                     call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR110')

                call GetData(NewProperty%Evolution%Filtration%AssimilationEfficiency,   &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'ASSIMILATION_EFFICIENCY',                &
                             Default        = 0.,                                       &
                             SearchType     = FromBlockInBlock,                         &
                             ClientModule   = 'ModuleWaterProperties',                  &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                     call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR120')

            end if

            call GetData(NewProperty%Evolution%Filtration%Freeze,                       &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'FILTRATION_FREEZE',                          &
                         Default        = .false.,                                      &
                         SearchType     = FromBlockInBlock,                             &
                         ClientModule   = 'ModuleWaterProperties',                      &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR130')

            call GetData(NewProperty%Evolution%Filtration%TypeOf,                       &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'FILTRATION_TYPE',                            &
                         Default        = GrazeD,                                       &
                         SearchType     = FromBlockInBlock,                             &
                         ClientModule   = 'ModuleWaterProperties',                      &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR140')

            if (NewProperty%Evolution%Filtration%TypeOf == GrazeR) then

                call GetData(GrazedProperty,                                            &
                             Me%ObjEnterData, iflag,                                    &
                             Keyword        = 'GRAZED_PROPERTY',                        &
                             SearchType     = FromBlockInBlock,                         &
                             ClientModule   = 'ModuleWaterProperties',                  &
                             STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                     call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR150')

                if (iflag == 0)                                                         &
                     call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR160')

                if (.not.CheckPropertyName(GrazedProperty,                              &
                                         NewProperty%Evolution%Filtration%GrazedPropID))&
                     call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR170')
            endif

            call GetData(NewProperty%Evolution%Filtration%UnitsCoef,                    &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'UNITS_COEF',                                 &
                        !l/h = 0.001m3/3600s
                        !UnitsCoef = 0.001/3600.
                         Default        = 2.77778E-07,                                  &
                         SearchType     = FromBlockInBlock,                             &
                         ClientModule   = 'ModuleWaterProperties',                      &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR175')

        else

             write(*,*)'FiltrationRate must be defined in WaterProperties file'
             call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR180')

        endif

        call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                                    &
                                   '<<begin_filterfeedermass>>', '<<end_filterfeedermass>>', BlockFound,&
                                   STAT = STAT_CALL)

        if (BlockFound) then
            call ConstructFillMatrix  ( PropertyID           = NewProperty%Evolution%Filtration%ID,  &
                                        EnterDataID          = Me%ObjEnterData,                      &
                                        TimeID               = Me%ObjTime,                           &
                                        HorizontalGridID     = Me%ObjHorizontalGrid,                 &
                                        GeometryID           = Me%ObjGeometry,                       &
                                        ExtractType          = FromBlockInBlock,                     &
                                        PointsToFill3D       = Me%ExternalVar%WaterPoints3D,         &
                                        Matrix3D             = NewProperty%Evolution%Filtration%FilterFeederMass,&
                                        TypeZUV              = TypeZ_,                               &
                                        STAT                 = STAT_CALL)
             if (STAT_CALL /= SUCCESS_)                                                              &
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR190')


             call KillFillMatrix(NewProperty%Evolution%Filtration%ID%ObjFillMatrix, STAT = STAT_CALL)

             if (STAT_CALL /= SUCCESS_)&
                 call CloseAllAndStop ('Read_Filtration_Parameters - ModuleWaterProperties - ERR200')

             NewProperty%Evolution%Filtration%FeederMassON = .true.

        else

             write(*,*)'The filter feeder mass was not defined'
             write(*,*)'Read_Filtration_Parameters - ModuleWaterProperties - WARN10'

             NewProperty%Evolution%Filtration%FeederMassON = .false.

        endif





    end subroutine Read_Filtration_Parameters

    !-------------------------------------------------------------------------

        !--------------------------------------------------------------------------

    subroutine Read_Reinitialize_Parameters(NewProperty, ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty
        integer                                 :: ClientNumber

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL
        integer                                 :: iflag
        integer                                 :: BoxesNumber, FirstLine, LastLine, l, n
        integer, dimension (:, :   ), pointer   :: Boxes2D
        integer                                 :: ILB, IUB, JLB, JUB
        integer                                 :: ObjBoxdif = 0
        character(len=StringLength)             :: Filename
        logical                                 :: BlockFound

       !Begin-----------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB


        allocate(NewProperty%Evolution%Reinitialize%BoxCells(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR10')


        !Gets name of the Box definition file
        call GetData(FileName,                                                          &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'REINITIALIZE_FILENAME',                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR30')
        if (iflag==0)then
            write(*,*)'Box File Name not given'
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR40')
        end if

        call StartBoxDif(BoxDifID           = ObjBoxDif,                                &
                         TimeID             = Me%ObjTime,                               &
                         HorizontalGridID   = Me%ObjHorizontalGrid,                     &
                         BoxesFilePath      = FileName,                                 &
                         WaterPoints2D      = Me%ExternalVar%WaterPoints2D,             &
                         STAT               = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR50')

        call GetBoxes(ObjBoxDif, Boxes2D = Boxes2D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR60')

        call GetDTBoxes(ObjBoxDif, Me%Coupled%BoxTimeSerie%DT_Compute, STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR60')

        NewProperty%Evolution%Reinitialize%BoxCells(:,:) = Boxes2D(:,:)

        call GetNumberOfBoxes(ObjBoxDif, NumberOfBoxes2D = BoxesNumber, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR70')

        NewProperty%Evolution%Reinitialize%BoxesNumber = BoxesNumber

        !Gets boxes Values
        allocate (NewProperty%Evolution%Reinitialize%BoxesValues(BoxesNumber))

        call GetData(NewProperty%Evolution%Reinitialize%BoxesValues,                    &
                     Me%ObjEnterData , iflag,                                           &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'REINITIALIZE_BOXES_VALUES',                        &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR80')

        if       (STAT_CALL .EQ. SIZE_ERR_)  then
            write(*,*) 'Incorrect number of boxes'
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR90')
        else if ((STAT_CALL .NE. SIZE_ERR_) .AND.  (STAT_CALL .NE. SUCCESS_)) then
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR100')
        end if
        if (iflag==0) then
            write(*,*) 'Boxes Values not given'
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR110')
        end if

        call UngetBoxDif(ObjBoxDif, Boxes2D, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR120')

        call KillBoxDif(ObjBoxDif, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR130')

        allocate(NewProperty%Evolution%Reinitialize%Dates(BoxesNumber), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR140')


        allocate(NewProperty%Evolution%Reinitialize%OnlyOnce(BoxesNumber), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR145')

        NewProperty%Evolution%Reinitialize%OnlyOnce(:) = .true.


        call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                       &
                                   '<<begin_reinitializedate>>', '<<end_reinitializedate>>', &
                                   BlockFound, FirstLine, LastLine, STAT = STAT_CALL)

        if (.not. BlockFound) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR150')

        n = 0
        do l = FirstLine + 1, LastLine - 1

            n = n + 1
            call GetData(NewProperty%Evolution%Reinitialize%Dates(n),                   &
                         Me%ObjEnterData, iflag,                                        &
                         Buffer_Line  = l,                                              &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('Read_Reinitialize_Parameters - ModuleWaterProperties - ERR160')

        enddo

    end subroutine Read_Reinitialize_Parameters

    !-------------------------------------------------------------------------
    subroutine Construct_PropertyOutPut(NewProperty, ExtractType)

        !Arguments------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty
        integer                                 :: ExtractType

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL
        integer                                 :: iflag

        !Begin----------------------------------------------------------------

        !<BeginKeyword>
            !Keyword          : OUTPUT_HDF
            !<BeginDescription>
               !
               ! Checks out if the user pretends to write a HDF format file for this property
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%OutputHDF,                                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTPUT_HDF',                                     &
                     Default        = .false.,                                          &
                     SearchType     = ExtractType,                                      &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR00')

        call GetData(NewProperty%OutputReal4,                                          &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTPUT_HDF_REAL4',                               &
                     Default        = .true.,                                           &
                     SearchType     = ExtractType,                                      &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR0a')

        !<BeginKeyword>
            !Keyword          : OUTPUT_SURFACE_HDF
            !<BeginDescription>
               !
               ! Checks out if the user pretends to write a HDF format file for this property
               ! at the surface layer
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%OutputSurfaceHDF,                                      &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTPUT_SURFACE_HDF',                             &
                     Default        = .false.,                                          &
                     SearchType     = ExtractType,                                      &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR01')


        if(NewProperty%OutputSurfaceHDF .and. .not. NewProperty%OutputHDF)then
            write(*,*)"OUTPUT_SURFACE_HDF is on but OUTPUT_HDF is off"
            write(*,*)"Property: ", trim(NewProperty%ID%Name)
            call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR01')
        endif


        !<BeginKeyword>
            !Keyword          : TIME_SERIE
            !<BeginDescription>
               !
               ! Checks out if the user pretends to write a time serie for this property
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%TimeSerie,                                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'TIME_SERIE',                                     &
                     Default        = .false.,                                          &
                     SearchType     = ExtractType,                                      &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR02')

        !<BeginKeyword>
            !Keyword          : OUTPUT_PROFILE
            !<BeginDescription>
               !
               ! Checks out if the user pretends to write a profile output for this property
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%OutputProfile,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTPUT_PROFILE',                                 &
                     Default        = .false.,                                          &
                     SearchType     = ExtractType,                                      &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR03')
        !<BeginKeyword>
            !Keyword          : BOX_TIME_SERIE
            !<BeginDescription>
                ! Checks out if the user pretends to write a time serie inside each box for this property
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : 1 (.true.) , 0 (.false.)
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%BoxTimeSerie,                                           &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword        = 'BOX_TIME_SERIE',                                  &
                     Default        = .false.,                                           &
                     SearchType     = ExtractType,                                       &
                     ClientModule   = 'ModuleWaterProperties',                           &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR04')

        if(NewProperty%BoxTimeSerie)then

            call GetData(NewProperty%BoxIntegrationByArea,                               &
                         Me%ObjEnterData, iflag,                                         &
                         Keyword        = 'BOX_INTEGRATION_BY_AREA',                     &
                         Default        = .false.,                                       &
                         SearchType     = ExtractType,                                   &
                         ClientModule   = 'ModuleWaterProperties',                       &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR04a')

        endif

        !<BeginKeyword>
            !Keyword          : STATISTICS
            !<BeginDescription>
               !
               ! Checks out if the user pretends the statistics of this property
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%Statistics,                                            &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword    = 'STATISTICS',                                         &
                     Default    = .false.,                                              &
                     SearchType = ExtractType,                                          &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR05')


        if (NewProperty%Statistics) then

            !<BeginKeyword>
                !Keyword          : STATISTICS_FILE
                !<BeginDescription>
                   !
                   ! The statistics definition file of this property
                   !
                !<EndDescription>
                !Type             : Character
                !Default          : Do not have
                !File keyword     : DISPQUAL
                !Multiple Options : Do not have
                !Search Type      : FromBlock
                !Begin Block      : <beginproperty>
                !End Block        : <endproperty>
            !<EndKeyword>
            call GetData(NewProperty%StatisticsFile,                                    &
                 Me%ObjEnterData, iflag,                                                &
                 Keyword        = 'STATISTICS_FILE',                                    &
                 SearchType     = ExtractType,                                          &
                 ClientModule   = 'ModuleWaterProperties',                              &
                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_ .or. iflag /= 1)                                  &
                call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR06')

        endif

        !<BeginKeyword>
            !Keyword          : OUTPUT_HDF_SEDVEL
            !<BeginDescription>
               !
               ! Checks out if the user pretends to write a HDF format file for this property
               ! at the surface layer
               !
            !<EndDescription>
            !Type             : Boolean
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromBlock
            !Begin Block      : <beginproperty>
            !End Block        : <endproperty>
        !<EndKeyword>
        call GetData(NewProperty%OutputHDFSedVel,                                       &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTPUT_HDF_SEDVEL',                              &
                     Default        = .false.,                                          &
                     SearchType     = ExtractType,                                      &
                     ClientModule   = 'ModuleWaterProperties',                          &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Construct_PropertyOutPut - ModuleWaterProperties - ERR07')

    end subroutine Construct_PropertyOutPut

    !--------------------------------------------------------------------------
    !If the user want's to use the values of a previous
    ! run the read the property values form the final
    ! results file of a previous run. By default this
    ! file is in HDF format

    subroutine ReadOldConcBoundariesHDF(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_Property       ), pointer            :: NewProperty

        !Local-----------------------------------------------------------------
        logical                                     :: EXIST
        character (Len = StringLength)              :: PropertyName
        integer                                     :: STAT_CALL
        integer                                     :: ObjHDF5
        integer(4)                                  :: HDF5_READ
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: ILW, IUW, JLW, JUW
        real,    dimension(:,:,:), pointer          :: Aux3D

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        inquire (FILE=trim(Me%Files%InitialWaterProperties)//"5", EXIST = EXIST)

cd0:    if (EXIST) then

            !Gets File Access Code
            call GetHDF5FileAccess  (HDF5_READ = HDF5_READ)


            ObjHDF5 = 0

            !Opens HDF5 File
            call ConstructHDF5 (ObjHDF5,                                                 &
                                trim(Me%Files%InitialWaterProperties)//"5",&
                                HDF5_READ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                call CloseAllAndStop ('ReadOldConcBoundariesHDF - ModuleWaterProperties - ERR01.')

ifMS:       if (Me%DDecomp%MasterOrSlave) then

                ILW = Me%DDecomp%HaloMap%ILB
                IUW = Me%DDecomp%HaloMap%IUB

                JLW = Me%DDecomp%HaloMap%JLB
                JUW = Me%DDecomp%HaloMap%JUB

            else ifMS

                ILW = ILB
                IUW = IUB

                JLW = JLB
                JUW = JUB

            endif ifMS

            PropertyName = trim(adjustl(NewProperty%ID%name))

            NewProperty%Concentration(:,:,:) = FillValueReal

cd1 :       if (associated(NewProperty%Assimilation%Field)) then

                NewProperty%Assimilation%Field(:,:,:) = FillValueReal

            end if cd1


            ! Reads from HDF file the Property concentration and open boundary values
            call HDF5SetLimits  (ObjHDF5, ILW, IUW, JLW, JUW, KLB, KUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ReadOldConcBoundariesHDF - ModuleWaterProperties - ERR02.')

            allocate(Aux3D(ILW:IUW, JLW:JUW, KLB:KUB))


            call HDF5ReadWindow(HDF5ID        = ObjHDF5,                                &
                                GroupName     = "/Concentration/"//NewProperty%ID%Name, &
                                Name          = NewProperty%ID%Name,                    &
                                Array3D       = Aux3D,                                  &
                                STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ReadOldConcBoundariesHDF - ModuleWaterProperties - ERR03.')

            NewProperty%Concentration(ILB:IUB, JLB:JUB, KLB:KUB) = Aux3D(ILW:IUW, JLW:JUW, KLB:KUB)

cd2 :       if (associated(NewProperty%Assimilation%Field)) then

                call HDF5ReadWindow(HDF5ID     = ObjHDF5,                               &
                                    GroupName  = "/Assimilation/"//NewProperty%ID%Name, &
                                    Name       = NewProperty%ID%Name,                   &
                                    Array3D    = Aux3D,                                 &
                                    STAT       = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('ReadOldConcBoundariesHDF - ModuleWaterProperties - ERR05.')

                NewProperty%Assimilation%Field(ILB:IUB, JLB:JUB, KLB:KUB) = Aux3D(ILW:IUW, JLW:JUW, KLB:KUB)

            end if cd2

            deallocate(Aux3D)

            call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                call CloseAllAndStop ('ReadOldConcBoundariesHDF - ModuleWaterProperties - ERR06.')


        else if(.not. EXIST) then cd0

            write(*,*)
            write(*,*)"Could not find the following hdf5 file: "
            write(*,*)trim(Me%Files%InitialWaterProperties)//"5"
            write(*,*)"This model is trying to access this file to"
            write(*,*)"continue calculation of water property: "
            write(*,*)trim(NewProperty%ID%Name)
            write(*,*)"Please see and correct keyword EUL_INI in nomfich.dat file."
            call CloseAllAndStop ('ReadOldConcBoundariesHDF - ModuleWaterProperties - ERR07.')

        endif cd0


        !----------------------------------------------------------------------

    end subroutine ReadOldConcBoundariesHDF

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! This subroutine adds a new property to the Water Property List

    subroutine Add_Property(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_Property),           pointer     :: NewProperty

        !----------------------------------------------------------------------

        ! Add to the WaterProperty List a new property
        if (.not.associated(Me%FirstProperty)) then
            Me%PropertiesNumber = 1
            Me%FirstProperty    => NewProperty
            Me%LastProperty     => NewProperty
        else
            NewProperty%Prev     => Me%LastProperty
            Me%LastProperty%Next => NewProperty
            Me%LastProperty      => NewProperty
            Me%PropertiesNumber  = Me%PropertiesNumber + 1
        end if

        !----------------------------------------------------------------------

    end subroutine Add_Property

    !--------------------------------------------------------------------------


    subroutine Add_WQRate(NewWqRate)

        !Arguments-------------------------------------------------------------
        type(T_WqRate),             pointer     :: NewWqRate

        !----------------------------------------------------------------------

        ! Add to the WaterProperty List a new property
        if (.not.associated(Me%FirstWqRate)) then
            Me%WqRatesNumber = 1
            Me%FirstWqRate    => NewWqRate
            Me%LastWqRate     => NewWqRate
        else
            NewWqRate%Prev                     => Me%LastWqRate
            Me%LastWqRate%Next => NewWqRate
            Me%LastWqRate      => NewWqRate
            Me%WqRatesNumber   = Me%WqRatesNumber + 1
        end if

        NewWqRate%ID%IDNumber = Me%WqRatesNumber

        !----------------------------------------------------------------------

    end subroutine Add_WQRate


    !--------------------------------------------------------------------------
    ! guillaume nogueira
    subroutine ConstructAltimAssimilation

        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL
        logical                            :: AltimetricAssimilation

        !----------------------------------------------------------------------

        !Aqui faz-se o teste se o hydrodynamic.dat tinha a opcao activada
        call GetHydroAltimAssim(Me%ObjHydrodynamic, AltimetricAssimilation, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('< - ModuleWaterProperties - ERR02')

        if(.not. AltimetricAssimilation) then
            write(*,*)                                                                  &
            'Error: In Hydrodynamic.dat keyword ALTIMETRIC_ASSIMILATION is missing or is NULL '
            call CloseAllAndStop ('ConstructAltimAssimilation - ModuleWaterProperties - ERR03')
        end if

        !Aqui faz-se o teste se o assimilation.dat tinha a opcao activada
        call GetAssimilationAltimetry(Me%ObjAssimilation, AltimetricAssimilation, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructAltimAssimilation - ModuleWaterProperties - ERR03b')

        if(.not. AltimetricAssimilation) then
            write(*,*)                                                                  &
            'Error: In Assimilation.dat keyword ALTIMETRIC_ASSIMILATION is missing or is NULL '
            call CloseAllAndStop ('ConstructAltimAssimilation - ModuleWaterProperties - ERR04')
        end if

        !Here we fetch the altimetry DT and initialize the nextcompute time
        call GetAssimilationAltimetryDT(Me%ObjAssimilation, Me%Coupled%AltimetryAssimilation%DT_Compute, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructAltimAssimilation - ModuleWaterProperties - ERR05')

        Me%Coupled%AltimetryAssimilation%NextCompute  =                                 &
                            Me%ExternalVar%Now                &
                            + Me%Coupled%AltimetryAssimilation%DT_Compute

    end subroutine ConstructAltimAssimilation

    !--------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Checks whether a discharge needs to be implemented for an upscaling domain present in assimilation.dat
    subroutine CheckOfflineUpscaling
        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: Property
        !Local -----------------------------------------------------------------
        integer                                     :: PropertyID, STAT_CALL
        integer                                     :: NumberOfFields_Upscaling, NumberOfFields
        logical                                     :: FoundDischarge
        !Begin--------------------------------------------------------------------
        FoundDischarge = .false.
        
        call CheckOfflineUpscalingDisch (Me%ObjHydrodynamic, FoundDischarge, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CheckOfflineUpscaling - ModuleWaterProperties - ERR01.')
        
        if (FoundDischarge) Me%Coupled%OfflineUpscalingDischarge%Yes = .true.
        
        Property => Me%FirstProperty
        
        do while (associated(Property))
            if (.not. CheckPropertyName   (Property%ID%Name, PropertyID))           &
            call CloseAllAndStop ('CheckOfflineUpscaling; WaterProperties. ERR02')
            !Sobrinho
            call GetNumberOfPropFields(Property, PropertyID, NumberOfFields, NumberOfFields_Upscaling)
            
            if (Property%Evolution%DataAssimilation /= NoNudging) then

                if (FoundDischarge .and. (NumberOfFields_Upscaling == 0)) then
                    write (*,*) 'Found an offline upscaling discharge but no upscaling field in assimilation.dat'
                    call CloseAllAndStop ('CheckOfflineUpscaling; WaterProperties. ERR03')
                endif
                
                if (NumberOfFields_Upscaling > 0) then
                    Property%Evolution%Upscaling = .true.
                endif
            else
                if (NumberOfFields_Upscaling == 0 .and. Me%Coupled%OfflineUpscalingDischarge%Yes &
                    .and. Property%Evolution%Discharges) then
                    write (*,*) 'Found an offline upscaling discharge but no upscaling field in assimilation.dat'
                    write (*,*) 'Also, DATA_ASSIMILATION must be ON in waterproperties.dat : ', trim(Property%ID%Name)
                    call CloseAllAndStop ('CheckOfflineUpscaling; WaterProperties. ERR04') 
                endif
            
            endif
            
            Property => Property%Next
        end do
        nullify(Property)
        
    end subroutine CheckOfflineUpscaling
    
    !--------------------------------------------------------------------------

    subroutine ConstructHybridWeights

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL, ClientNumber
        logical                             :: BlockFound, RemainsConstant
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        allocate (Me%HybridWeights%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR40')

        call SetMatrixValue(Me%HybridWeights%Field, Me%Size, 0.)

        call ExtractBlockFromBuffer(Me%ObjEnterData,                                    &
                                    ClientNumber    = ClientNumber,                     &
                                    block_begin     = "<begin_hybrid_weights>",         &
                                    block_end       = "<end_hybrid_weights>",           &
                                    BlockFound      = BlockFound,                       &
                                    STAT            = STAT_CALL)

cd1 :   if (STAT_CALL .EQ. SUCCESS_) then

cd2 :       if (BlockFound) then

                call ConstructFillMatrix(PropertyID           = Me%HybridWeights%ID,            &
                                         EnterDataID          = Me%ObjEnterData,                &
                                         TimeID               = Me%ObjTime,                     &
                                         HorizontalGridID     = Me%ObjHorizontalGrid,           &
                                         GeometryID           = Me%ObjGeometry,                 &
                                         ExtractType          = FromBlock,                      &
                                         PointsToFill3D       = Me%ExternalVar%WaterPoints3D,   &
                                         Matrix3D             = Me%HybridWeights%Field,         &
                                         TypeZUV              = TypeZ_,                         &
                                         STAT                 = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                      &
                    call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR01')

                call GetIfMatrixRemainsConstant(FillMatrixID    = Me%HybridWeights%ID%ObjFillMatrix,    &
                                                RemainsConstant = RemainsConstant, STAT= STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                      &
                    call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR02')

                if(.not. RemainsConstant)then
                    call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR03')
                end if

                call KillFillMatrix(Me%HybridWeights%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)&
                    call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR10')

            endif cd2

            call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR20')

        else
            call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR30')
        endif cd1

        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if(Me%ExternalVar%WaterPoints3D(i,j,k) .eq. WaterPoint)then

                if(Me%HybridWeights%Field(i,j,k) < 0. .or. &
                   Me%HybridWeights%Field(i,j,k) > 1.)then
                    write(*,*)'Inconsistent value for hydrid weight in cell (i,j,k)', i, j, k
                    write(*,*) i, j, k
                    call CloseAllAndStop ('ConstructHybridWeights - ModuleWaterProperties - ERR40')
                end if
            endif
        enddo
        enddo
        enddo




    end subroutine ConstructHybridWeights

    !--------------------------------------------------------------------------


    subroutine ConstructDensity

        !Local-----------------------------------------------------------------
        type(T_Property), pointer          :: PropertyX
        integer                            :: STAT_CALL, iflag, ClientNumber
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k
        integer                            :: aux
        logical                            :: BlockFound

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !----------------------------------------------------------------------

        !<BeginKeyword>
            !Keyword          : REFERENCE_DENSITY
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 1026.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%Density%Reference,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'REFERENCE_DENSITY',                                  &
                     Default    = 1000.0,                                               &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR10')

        !<BeginKeyword>
            !Keyword          : DENSITY_METHOD
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : integer
            !Default          : UNESCOState_
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%Density%Method,                                                 &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'DENSITY_METHOD',                                     &
                     Default    = UNESCOState_,                                         &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR20')

        call GetData(Me%Density%CorrecPress,                                            &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'PRESSURE_CORRECTION',                                &
                     Default    = .true.,                                               &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR30')


        call GetData(Me%Density%CorrecSed,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'SEDIMENT_CORRECTION',                                &
                     Default    = .false.,                                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR30')


        call GetData(Me%Density%CohesiveSed,                                            &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'DENSITY_COHESIVE_SED',                               &
                     Default    = 2650.,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR40')

        call GetData(Me%Density%CorrecNonCohesiveSed,                                   &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'NONCOHESIVE_CORRECTION',                             &
                     Default    = .false.,                                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR41')

        call GetData(Me%Density%NonCohesiveSed,                                         &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'DENSITY_NONCOHESIVE_SED',                            &
                     Default    = 2650.,                                                &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR42')


        allocate (Me%Density%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR50')

        allocate (Me%Density%Sigma(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR60')

        if (Me%Density%CorrecPress) then

            allocate (Me%Density%SigmaNoPressure(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR70')

        else
            Me%Density%SigmaNoPressure => Me%Density%Sigma
        endif

        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB
            if(Me%ExternalVar%WaterPoints3D(i,j,k) .eq. WaterPoint)then
                Me%Density%Field(i, j, k) = Me%Density%Reference
            else
                Me%Density%Field(i, j, k) = FillValueReal
            end if
        enddo
        enddo
        enddo

        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB
            if(Me%ExternalVar%WaterPoints3D(i,j,k) .eq. WaterPoint)then
                Me%Density%Sigma(i, j, k) = Me%Density%Reference - SigmaDensityReference
            else
                Me%Density%Sigma(i, j, k) = FillValueReal
            end if
        enddo
        enddo
        enddo


        call ExtractBlockFromBuffer(Me%ObjEnterData,                        &
                                    ClientNumber    = ClientNumber,         &
                                    block_begin     = "<begindensity>",     &
                                    block_end       = "<enddensity>",       &
                                    BlockFound      = BlockFound,           &
                                    STAT            = STAT_CALL)
cd1 :   if (STAT_CALL .EQ. SUCCESS_     ) then
cd2 :       if (BlockFound) then


                call ConstructFillMatrix  (PropertyID           = Me%Density%ID,            &
                                        EnterDataID          = Me%ObjEnterData,             &
                                        TimeID               = Me%ObjTime,                  &
                                        HorizontalGridID     = Me%ObjHorizontalGrid,        &
                                        GeometryID           = Me%ObjGeometry,              &
                                        ExtractType          = FromBlock,                   &
                                        PointsToFill3D       = Me%ExternalVar%WaterPoints3D,&
                                        Matrix3D             = Me%Density%Sigma,            &
                                        TypeZUV              = TypeZ_,                      &
                                        ClientID             = ClientNumber,                &
                                        STAT                 = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                  &
                    call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR90')


                call KillFillMatrix(Me%Density%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)&
                    call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR100')

                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    if(Me%ExternalVar%WaterPoints3D(i,j,k) .eq. WaterPoint)then
                        Me%Density%Field(i, j, k) = Me%Density%Sigma(i, j, k) + SigmaDensityReference
                    end if
                enddo
                enddo
                enddo

            endif cd2

            call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_) then
                call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR110')
            endif
        else
            call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR120')
        endif cd1

        if (Me%Density%CorrecPress) then

            Me%Density%SigmaNoPressure(:,:,:) = Me%Density%Sigma(:,:,:)

        endif

        Me%Density%Variable = .false.

        !If the model is 2D the density in not computed
        if (Me%WorkSize%KUB == 1) then

            Me%Density%Variable = .FALSE.

        else

            call Search_Property(PropertyX, PropertyXID = Salinity_, STAT = STAT_CALL)

Sal:        if(STAT_CALL == SUCCESS_)then

               if (PropertyX%Evolution%Variable) Me%Density%Variable = .TRUE.

               call Search_Property(PropertyX, PropertyXID = Temperature_, STAT = STAT_CALL)

temp:          if (STAT_CALL == SUCCESS_)then

                    if (PropertyX%Evolution%Variable) Me%Density%Variable = .TRUE.

                    call null_time(Me%Density%LastActualization)

                    call ModifyDensity(Me%ExternalVar%Now)

                else

                    call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR140')

                endif temp

            endif sal

            if (Me%Density%CorrecSed) then
                call Search_Property(PropertyX, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
                if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR130.')

                if (PropertyX%Evolution%Variable) Me%Density%VariableSed = .TRUE.
            endif

            if (Me%Density%CorrecNonCohesiveSed) then

                aux = 0

                PropertyX => Me%FirstProperty

                do while (associated(PropertyX))

                    if (PropertyX%Non_Cohesive) then

                        if (PropertyX%Evolution%Variable) aux = aux + 1

                        PropertyX=>PropertyX%Next

                    endif

                end do

                if (aux .gt. 0)  then

                    Me%Density%VariableSed = .TRUE.

                else
                    write(*,*)
                    write(*,*) 'Keyword NONCOHESIVE_CORRECTION is activated'
                    write(*,*) 'but there is not defined any NON_COHESIVE property'
                    call CloseAllAndStop ('ConstructDensity - ModuleWaterProperties - ERR140.')
                endif

            endif

            if (Me%Density%VariableSed) then

                call null_time(Me%Density%LastActualization)

                call ModifyDensitySed(Me%ExternalVar%Now)

            endif

        endif


    end subroutine ConstructDensity

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    ! guillaume nogueira
    subroutine ConstructBooleanAltimAssim

        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL, iflag
        integer                            :: AltimAssim

        !----------------------------------------------------------------------

        !Aqui temos que fazer um call GetData
        !<BeginKeyword>
            !Keyword          : ALTIMETRIC_ASSIMILATION
            !<BeginDescription>
               !
               ! Do the Cooper-Haines method for altimetry assimilation
               !
            !<EndDescription>
            !Type             : logical
            !Default          : 0
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(AltimAssim,                                                        &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'ALTIMETRIC_ASSIMILATION',                            &
                     Default    = 0,                                                    &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructAltimAssimilation - ModuleWaterProperties - ERR01')

        if(AltimAssim.eq.1) Me%Coupled%AltimetryAssimilation%Yes = .true.

#ifdef _USE_SEQASSIMILATION
        if (Me%Coupled%AltimetryAssimilation%Yes .and. Me%RunSeqAssimilation) then
            write(*,*)
            write(*,*) 'Sequential and altimetry assimilation cannot be used together.'
            call CloseAllAndStop ('ConstructAltimAssimilation - ModuleWaterProperties - ERR02')
        endif
#endif _USE_SEQASSIMILATION

    end subroutine ConstructBooleanAltimAssim

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine ConstructBooleanSeqAssimilation

        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL, iflag

        !----------------------------------------------------------------------

        call GetData(Me%RunSeqAssimilation,                                              &
                     Me%ObjEnterData, iflag,                                             &
                     Keyword    = 'SEQUENTIAL_ASSIMILATION',                             &
                     Default    = .false.,                                               &
                     SearchType = FromFile,                                              &
                     ClientModule ='ModuleWaterProperties',                              &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('ConstructBooleanSeqAssimilation - ModuleWaterProperties - ERR01')

    end subroutine ConstructBooleanSeqAssimilation

#endif _USE_SEQASSIMILATION


#ifdef OVERLAP
    subroutine ConstructWaterOverlap


        !Local-----------------------------------------------------------------
        integer                            :: STAT_CALL, iflag

        !----------------------------------------------------------------------

        call GetData(Me%Overlap,                                                        &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OVERLAP',                                        &
                     Default        = .false.,                                          &
                     SearchType     = FromFile,                                         &
                     ClientModule   ='ModuleWaterProperties',                           &
                     STAT           = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('ConstructWaterOverlap - ModuleWaterProperties - ERR01')


    end subroutine ConstructWaterOverlap
#endif OVERLAP


    !--------------------------------------------------------------------------

    subroutine ConstructNoFluxInterior

        !Local-----------------------------------------------------------------
        real                               :: ModelDT
        integer                            :: STAT_CALL, iflag

        !----------------------------------------------------------------------


        call GetData(Me%NoFlux%ON,                                                      &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                             &
                     keyword    = 'NO_FLUX_INTERIOR_CONDITION',                         &
                     Default    = .false.,                                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('ConstructNoFluxInterior - ModuleWaterProperties - ERR10')


        if (Me%NoFlux%ON) then

            call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ConstructNoFluxInterior - ModuleWaterProperties - ERR30')

            call GetData(Me%NoFlux%RelaxTimeScaleLimit,                                 &
                         Me%ObjEnterData, iflag,                                        &
                         SearchType = FromFile,                                         &
                         keyword    = 'RELAXATION_TIME_SCALE_NO_FLUX_LIMIT',            &
                         Default    = 1000.*ModelDT,                                    &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT       = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ConstructNoFluxInterior - ModuleWaterProperties - ERR40')

            allocate(Me%NoFlux%U(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))
            allocate(Me%NoFlux%V(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))
            allocate(Me%NoFlux%W(Me%Size%ILB:Me%Size%IUB,Me%Size%JLB:Me%Size%JUB,Me%Size%KLB:Me%Size%KUB))

        endif



    end subroutine ConstructNoFluxInterior

    !--------------------------------------------------------------------------


     subroutine ConstructSpecificHeat

        !Local-----------------------------------------------------------------
        type(T_Property), pointer          :: PropertyX
        integer                            :: STAT_CALL, iflag, ClientNumber
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k
        logical                            :: BlockFound

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        !----------------------------------------------------------------------

        !<BeginKeyword>
            !Keyword          : REFERENCE_SPECIFICHEAT
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : Real
            !Default          : 4200.0
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%SpecificHeat%Reference,                                               &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType = FromFile,                                              &
                     keyword    = 'REFERENCE_SPECIFICHEAT',                                   &
                     Default    = SpecificHeatDefault,                                                &
                     ClientModule = 'ModuleWaterProperties',                             &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR01')

        !<BeginKeyword>
            !Keyword          : SPECIFICHEAT_METHOD
            !<BeginDescription>
               !
               ! Do not have
               !
            !<EndDescription>
            !Type             : integer
            !Default          : 1
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%SpecificHeat%Method,                                &
                     Me%ObjEnterData, iflag,                                &
                     SearchType = FromFile,                                 &
                     keyword    = 'SPECIFICHEAT_METHOD',                    &
                     Default    = Linear_,                                  &
                     ClientModule = 'ModuleWaterProperties',                &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR02')

        select case (Me%SpecificHeat%Method)
            case (Linear_)
                Me%SpecificHeat%UseField = .FALSE.
            case (UNESCOState_)
                Me%SpecificHeat%UseField = .TRUE.
            case default
                Me%SpecificHeat%UseField = .FALSE.
        end select

cd3:    if(Me%SpecificHeat%UseField) then

            allocate (Me%SpecificHeat%Field(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR03')

            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if(Me%ExternalVar%WaterPoints3D(i,j,k) .eq. WaterPoint)then
                    Me%SpecificHeat%Field(i, j, k) = Me%SpecificHeat%Reference
                else
                    Me%SpecificHeat%Field(i, j, k) = FillValueReal
                end if
            enddo
            enddo
            enddo

            call ExtractBlockFromBuffer(Me%ObjEnterData,                                &
                                        ClientNumber    = ClientNumber,                 &
                                        block_begin     = "<beginspecificheat>",        &
                                        block_end       = "<endspecificheat>",          &
                                        BlockFound      = BlockFound,                   &
                                        STAT            = STAT_CALL)
cd1 :       if (STAT_CALL .EQ. SUCCESS_     ) then
cd2 :       if (BlockFound) then


                call ConstructFillMatrix  (PropertyID           = Me%SpecificHeat%ID,               &
                                           EnterDataID          = Me%ObjEnterData,                  &
                                           TimeID               = Me%ObjTime,                       &
                                           HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                           GeometryID           = Me%ObjGeometry,                   &
                                           ExtractType          = FromBlock,                        &
                                           PointsToFill3D       = Me%ExternalVar%WaterPoints3D,     &
                                           Matrix3D             = Me%SpecificHeat%Field,            &
                                           TypeZUV              = TypeZ_,                           &
                                           ClientID             = ClientNumber,                     &
                                           STAT                 = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                          &
                    call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR07')


                call KillFillMatrix(Me%SpecificHeat%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)&
                    call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR08')

            endif cd2

            call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR08a')

            endif cd1
        endif cd3

        Me%SpecificHeat%Variable = .FALSE.

        select case(Me%SpecificHeat%Method)

            case (UNESCOState_)

                !If the model is 2D the specific heat in not computed
                if (Me%WorkSize%KUB == 1)  call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR09')

                !Salinidade
                call Search_Property(PropertyX, PropertyXID = Salinity_, STAT = STAT_CALL)
                if(STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR10')

                if (PropertyX%Evolution%Variable) Me%SpecificHeat%Variable = .TRUE.

                !Temperatura
                call Search_Property(PropertyX, PropertyXID = Temperature_, STAT = STAT_CALL)
                if(STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructSpecificHeat - ModuleWaterProperties - ERR11')

                if (PropertyX%Evolution%Variable) Me%SpecificHeat%Variable = .TRUE.

                call null_time(Me%SpecificHeat%LastActualization)

                call ModifySpecificHeat(Me%ExternalVar%Now)

            case default

        end select

    end subroutine ConstructSpecificHeat

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    logical function SolarRadiationIsNeeded()

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX

        !----------------------------------------------------------------------

        SolarRadiationIsNeeded = .false.

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            select case(PropertyX%ID%IDNumber)

                case(Temperature_)

                    if(PropertyX%Evolution%SurfaceFluxes) SolarRadiationIsNeeded = .true.

                case(Phytoplankton_, Diatoms_)

                    if(PropertyX%Evolution%WaterQuality ) SolarRadiationIsNeeded = .true.
                    if(PropertyX%Evolution%WWTPQ ) SolarRadiationIsNeeded = .true.

                case(MacroAlgae_)

                    if(PropertyX%Evolution%MacroAlgae   ) SolarRadiationIsNeeded = .true.

                case(SeagrassesLeaves_)

                    if(PropertyX%Evolution%SeagrassesLeaves) SolarRadiationIsNeeded = .true.

                case(Algae_1_, Algae_2_, Algae_3_, Algae_4_, Algae_5_)

                    if(PropertyX%Evolution%CEQUALW2     ) SolarRadiationIsNeeded = .true.

                case(Epiphyton_1_, Epiphyton_2_, Epiphyton_3_, Epiphyton_4_, Epiphyton_5_)

                    if(PropertyX%Evolution%CEQUALW2     ) SolarRadiationIsNeeded = .true.

                case(Diatom_C_, Mix_Flagellate_C_, Picoalgae_C_, Flagellate_C_)

                    if(PropertyX%Evolution%Life         ) SolarRadiationIsNeeded = .true.

            end select

            if(PropertyX%Evolution%T90Variable  ) SolarRadiationIsNeeded = .true.

            PropertyX => PropertyX%Next

        enddo

        Me%SolarRadiation%Exists = SolarRadiationIsNeeded


    end function SolarRadiationIsNeeded

    !--------------------------------------------------------------------------

    subroutine ConstructConvection

        !Local-----------------------------------------------------------------
        integer                          :: STAT_CALL, IUB, ILB, JUB, JLB
        integer                          :: iflag

        !Begin-----------------------------------------------------------------

        IUB    = Me%Size%IUB
        ILB    = Me%Size%ILB
        JUB    = Me%Size%JUB
        JLB    = Me%Size%JLB

        allocate (Me%SmallDepths%ON(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "ConstructConvection - WaterProperties - ERR01")

        Me%SmallDepths%ON (:,:) = .false.



        !<BeginKeyword>
            !Keyword          : SMALLDEPTH_LIMIT
            !<BeginDescription>
               !
               ! Water column thickness below which homogeneous water properties is assumed.
               !
            !<EndDescription>
            !Type             : Real
            !Default          : FillValueReal
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%SmallDepths%Limit,                                              &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType = FromFile,                                             &
                     keyword    = 'SMALLDEPTH_LIMIT',                                   &
                     Default    = FillValueReal,                                        &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "ConstructConvection - WaterProperties - ERR02")

        if(iflag .ne. 0 .and. Me%Coupled%Bivalve%Yes)then
            write(*,*)'Cannot run BIVALVE with SMALLDEPTH_LIMIT'
            call SetError(FATAL_, KEYWORD_, "ConstructConvection - WaterProperties - ERR04")
        end if


        !<BeginKeyword>
            !Keyword          : FREE_CONVECTION
            !<BeginDescription>
               !
               ! This option tend to mixe instable density profiles
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .false.
            !File keyword     : DISPQUAL
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%FreeConvection,                                                 &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'FREE_CONVECTION',                                  &
                     Default      = .false.,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "ConstructConvection - WaterProperties - ERR03")


    end subroutine ConstructConvection

    !--------------------------------------------------------------------------


    subroutine ConstructLog


        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty

#ifndef _OUTPUT_OFF_

        write(*, *)"--------------------- WATERPROPERTIES --------------------"
        write(*, *)
        write(*, *)"Num of Properties : ", Me%PropertiesNumber
        write(*, *)

        CurrentProperty => Me%FirstProperty
        do while (associated(CurrentProperty))

            write(*, *)"Property            : ", trim(CurrentProperty%ID%Name)
            write(*, *)"---Water Quality    : ", CurrentProperty%Evolution%WaterQuality
            write(*, *)"---CEQUALW2         : ", CurrentProperty%Evolution%CEQUALW2
            write(*, *)"---Life             : ", CurrentProperty%Evolution%Life
            write(*, *)"---MacroAlgae       : ", CurrentProperty%Evolution%MacroAlgae
            write(*, *)"---Seagrasses       : ", CurrentProperty%Evolution%SeagrassesLeaves
            write(*, *)"---WWTPQ            : ", CurrentProperty%Evolution%WWTPQ
            write(*, *)"---Bivalve          : ", CurrentProperty%Evolution%Bivalve
            write(*, *)"---Partitioning     : ", CurrentProperty%Evolution%Partitioning
            write(*, *)"---Free Vert. Mov   : ", CurrentProperty%Evolution%FreeVerticalMovement
            write(*, *)"---Adv. Diff.       : ", CurrentProperty%Evolution%AdvectionDiffusion
            write(*, *)"---Discharges       : ", CurrentProperty%Evolution%Discharges
            write(*, *)"---Surface Fluxes   : ", CurrentProperty%Evolution%SurfaceFluxes
            write(*, *)"---Bottom Fluxes    : ", CurrentProperty%Evolution%BottomFluxes
            write(*, *)"---First Order Decay: ", CurrentProperty%Evolution%FirstOrderDecay
            write(*, *)"---Decay Rate Property: ", CurrentProperty%Evolution%DecayRateProperty
            write(*, *)"---Assimilation     : ", CurrentProperty%Evolution%DataAssimilation
            write(*, *)

            CurrentProperty=>CurrentProperty%Next
        enddo
#endif

    end subroutine ConstructLog



!--------------------------------------------------------------------------


    subroutine Read_Old_Properties_2D(Scalar_2D, PropertyName)

        !Arguments--------------------------------------------------------------
        real, dimension(:,:), pointer               :: Scalar_2D
        character (Len=*), Intent(IN)               :: PropertyName

        !Local-----------------------------------------------------------------
        integer                                     :: IUB, JUB, ILB, JLB
        integer                                     :: IUW, JUW, ILW, JLW
        integer                                     :: STAT_CALL
        integer                                     :: HDF5_READ
        integer                                     :: ObjHDF5 = 0
        logical                                     :: exist

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB
        JUB = Me%WorkSize%JUB


        ObjHDF5 = 0


        inquire(File = trim(Me%Files%InitialWaterProperties)//"5", Exist = exist)

        if(.not. exist)then
            write(*,*)
            write(*,*)     'Could not find the final WaterProperties file.'
            write(*,'(A)') 'Hdf5 file name = ', trim(Me%Files%InitialWaterProperties)//"5"
            call CloseAllAndStop ('Read_Old_Properties_2D - WaterProperties - ERR10')
        end if

        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_READ = HDF5_READ)

        !Opens HDF5 File
        call ConstructHDF5 (ObjHDF5, trim(Me%Files%InitialWaterProperties)//"5", HDF5_READ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('read_Old_Properties_2D - WaterProperties - ERR20')

ifMS:   if (Me%DDecomp%MasterOrSlave) then

            ILW = Me%DDecomp%HaloMap%ILB
            IUW = Me%DDecomp%HaloMap%IUB

            JLW = Me%DDecomp%HaloMap%JLB
            JUW = Me%DDecomp%HaloMap%JUB

        else ifMS

            ILW = ILB
            IUW = IUB

            JLW = JLB
            JUW = JUB

        endif ifMS


        !Reads from HDF file the Property concentration and open boundary values
        call HDF5SetLimits  (ObjHDF5, ILW, IUW, JLW, JUW, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('read_Old_Properties_2D - WaterProperties - ERR50')

        call HDF5ReadWindow (HDF5ID         = ObjHDF5,                                  &
                             GroupName      = trim("/Results/"//PropertyName),          &
                             Name           = PropertyName,                             &
                             Array2D        = Scalar_2D,                                &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('read_Old_Properties_2D - WaterProperties - ERR60')

        call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('read_Old_Properties_2D - WaterProperties - ERR70')

    end subroutine Read_Old_Properties_2D
    !------------------------------------------------------------------------------------

    subroutine ConstructGlobalOutput

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty
        logical                                     :: OutputON
        logical                                     :: SurfaceOutputON
        integer                                     :: STAT_CALL
        integer                                     :: iflag
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB, iW

        !Begin-----------------------------------------------------------------

        nullify(Me%OutPut%OutTime)

        OutputON        = OFF

        CurrentProperty => Me%FirstProperty
        do while (associated(CurrentProperty))

            if(CurrentProperty%OutputHDF) OutputON = ON
            CurrentProperty => CurrentProperty%Next

        enddo

        SurfaceOutputON = OFF

        CurrentProperty => Me%FirstProperty
        do while (associated(CurrentProperty))

            if(CurrentProperty%OutputSurfaceHDF) SurfaceOutputON = ON
            CurrentProperty => CurrentProperty%Next

        enddo


        if(OutputON)then

            CurrentProperty => Me%FirstProperty
            do while (associated(CurrentProperty))

                if(.not. CurrentProperty%OutputReal4) then
                    Me%WriteHDFReal4 = .false.
                    exit
                endif

                CurrentProperty => CurrentProperty%Next

            enddo

            if(Me%WriteHDFReal4)then

                nullify(Me%Output%Aux3Dreal4)
                allocate(Me%Output%Aux3Dreal4(Me%Size%ILB:Me%Size%IUB,&
                                              Me%Size%JLB:Me%Size%JUB,&
                                              Me%Size%KLB:Me%Size%KUB))

                Me%Output%Aux3Dreal4(:,:,:) = 0.0
            endif

            call GetOutPutTime(Me%ObjEnterData,                                         &
                               CurrentTime      = Me%ExternalVar%Now,                   &
                               EndTime          = Me%EndTime,                           &
                               keyword          = 'OUTPUT_TIME',                        &
                               SearchType       = FromFile,                             &
                               OutPutsTime      = Me%OutPut%OutTime,                    &
                               OutPutsOn        = Me%OutPut%Yes,                        &
                               OutPutsNumber    = Me%OutPut%TotalOutputs,               &
                               STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ConstructGlobalOutput - WaterProperties - ERR01')

            if (Me%OutPut%Yes) then

                Me%OutPut%NextOutPut = 1

            else
                write(*,*)'Keyword OUTPUT_TIME must be defined if at least'
                write(*,*)'one property has HDF format outputs.'
                call CloseAllAndStop ('ConstructGlobalOutput - WaterProperties - ERR02')
            endif

            ILB = Me%Size%ILB
            IUB = Me%Size%IUB
            JLB = Me%Size%JLB
            JUB = Me%Size%JUB
            KLB = Me%Size%KLB
            KUB = Me%Size%KUB

            nullify (Me%OutPut%Aux3D)
            allocate(Me%OutPut%Aux3D(ILB:IUB,JLB:JUB,KLB:KUB))

            nullify (Me%OutPut%Aux2D)
            allocate(Me%OutPut%Aux2D(ILB:IUB,JLB:JUB))

        end if

        call GetOutPutTime(Me%ObjEnterData,                                         &
                           CurrentTime = Me%ExternalVar%Now,                        &
                           EndTime     = Me%EndTime,                                &
                           keyword     = 'RESTART_FILE_OUTPUT_TIME',                &
                           SearchType  = FromFile,                                  &
                           OutPutsTime = Me%OutPut%RestartOutTime,                  &
                           OutPutsOn   = Me%OutPut%WriteRestartFile,                &
                           STAT        = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
            call CloseAllAndStop ('ConstructGlobalOutput - WaterProperties - ERR30')

        if(Me%OutPut%WriteRestartFile)then

            Me%OutPut%NextRestartOutput = 1

        end if

        !<BeginKeyword>
            !Keyword          : RESTART_FILE_OVERWRITE
            !<BeginDescription>
               !
               ! This option checks wether the restart file is to be overwritten or not
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%OutPut%RestartOverwrite,                                        &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'RESTART_FILE_OVERWRITE',                           &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "ConstructGlobalOutput - WaterProperties - ERR03b")

        if(SurfaceOutputON)then

            call GetOutPutTime(Me%ObjEnterData,                                         &
                               CurrentTime   = Me%ExternalVar%Now,                      &
                               EndTime       = Me%EndTime,                              &
                               keyword       = 'SURFACE_OUTPUT_TIME',                   &
                               SearchType    = FromFile,                                &
                               OutPutsTime   = Me%OutPut%SurfaceOutTime,                &
                               OutPutsOn     = Me%OutPut%SurfaceOutputs,                &
                               OutPutsNumber = Me%OutPut%TotalSurfaceOutputs,           &
                               STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('ConstructGlobalOutput - WaterProperties - ERR04')

            if(Me%OutPut%SurfaceOutputs)then

                Me%OutPut%NextSurfaceOutput = 1

            end if

        end if

        call GetOutPutTimeWindows(EnterDataID     = Me%ObjEnterData,                    &
                                  CurrentTime     = Me%ExternalVar%Now,                 &
                                  EndTime         = Me%EndTime,                         &
                                  OutPutWindows   = Me%OutW%OutPutWindows,              &
                                  OutPutWindowsON = Me%OutW%OutPutWindowsON,            &
                                  WindowsNumber   = Me%OutW%WindowsNumber,              &
                                  STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, INTERNAL_, 'Construct_OutPutTime - Hydrodynamic - ERR60')

         if(Me%OutW%OutPutWindowsON)then

            allocate(Me%OutW%ObjHDF5        (Me%OutW%WindowsNumber))
            allocate(Me%OutW%OriginalCorners(Me%OutW%WindowsNumber))

            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            do iW = 1, Me%OutW%WindowsNumber

                if (Me%DDecomp%MasterOrSlave) then

                    ILB = Me%DDecomp%Global%ILB
                    IUB = Me%DDecomp%Global%IUB
                    JLB = Me%DDecomp%Global%JLB
                    JUB = Me%DDecomp%Global%JUB

                else

                    ILB = Me%WorkSize%ILB
                    IUB = Me%WorkSize%IUB
                    JLB = Me%WorkSize%JLB
                    JUB = Me%WorkSize%JUB

                endif

                if (Me%OutW%OutPutWindows(iW)%KLB < KLB .or.                            &
                    Me%OutW%OutPutWindows(iW)%KUB > KUB .or.                            &
                    Me%OutW%OutPutWindows(iW)%KLB > KUB .or.                            &
                    Me%OutW%OutPutWindows(iW)%KUB < KLB) then
                    write(*,*) 'Cell layers out of the model domain for the output window number',iW
                    !stop 'ConstructGlobalOutput - WaterProperties - ERR65'
                    write(*,*) 'All model layers will be assumed for the window output'
                    Me%OutW%OutPutWindows(iW)%KLB = KLB
                    Me%OutW%OutPutWindows(iW)%KUB = KUB
                endif

                if (Me%OutW%OutPutWindows(iW)%ILB < ILB .or.                            &
                    Me%OutW%OutPutWindows(iW)%IUB > IUB .or.                            &
                    Me%OutW%OutPutWindows(iW)%JLB < JLB .or.                            &
                    Me%OutW%OutPutWindows(iW)%JUB > JUB) then

                    write(*,*) 'cell corners out of the model domain for the output window number',iW
                    stop 'ConstructGlobalOutput - WaterProperties - ERR70'

                endif

                Me%OutW%OutPutWindows%NextOutPut = 1

                Me%OutW%OriginalCorners(iW)%ILB = Me%OutW%OutPutWindows(iW)%ILB
                Me%OutW%OriginalCorners(iW)%IUB = Me%OutW%OutPutWindows(iW)%IUB
                Me%OutW%OriginalCorners(iW)%JLB = Me%OutW%OutPutWindows(iW)%JLB
                Me%OutW%OriginalCorners(iW)%JUB = Me%OutW%OutPutWindows(iW)%JUB

                Me%OutW%OutPutWindows(iW)%ON    = .true.

            enddo

            if (.not.associated(Me%OutPut%Aux3D)) then

                ILB = Me%Size%ILB
                IUB = Me%Size%IUB
                JLB = Me%Size%JLB
                JUB = Me%Size%JUB
                KLB = Me%Size%KLB
                KUB = Me%Size%KUB

                nullify (Me%OutPut%Aux3D)
                allocate(Me%OutPut%Aux3D(ILB:IUB,JLB:JUB,KLB:KUB))

            endif

            if (.not.associated(Me%OutPut%Aux2D)) then

                ILB = Me%Size%ILB
                IUB = Me%Size%IUB
                JLB = Me%Size%JLB
                JUB = Me%Size%JUB

                nullify (Me%OutPut%Aux2D)
                allocate(Me%OutPut%Aux2D(ILB:IUB,JLB:JUB))

            endif

        end if


        call GetData(Me%OutW%Simple,                                                    &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'SIMPLE_WINDOW_OUTPUT',                             &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "ConstructGlobalOutput - WaterProperties - ERR80")

        call GetData(Me%OutPut%Simple,                                                  &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'SIMPLE_OUTPUT',                                    &
                     Default      = .false.,                                            &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call SetError(FATAL_, KEYWORD_, "ConstructGlobalOutput - WaterProperties - ERR90")

    end subroutine ConstructGlobalOutput



    !--------------------------------------------------------------------------


    subroutine ConstructDoSat

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: iflag
        !Begin-----------------------------------------------------------------

        call GetData(Me%DoSatType,                                                      &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'DOSAT_TYPE',                                       &
                     Default      = Apha,                                               &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ConstructDoSat - WaterProperties - ERR01')


        if (Me%DoSatType.eq.Mortimer) then

            call GetData(Me%Altitude,                                                   &
                         Me%ObjEnterData,                                               &
                         iflag,                                                         &
                         SearchType   = FromFile,                                       &
                         keyword      = 'ALTITUDE',                                     &
                         ClientModule = 'ModuleWaterProperties',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_ .or. iflag .eq. 0)                                &
                call CloseAllAndStop ('ConstructDoSat - WaterProperties - ERR02')
        endif


    end subroutine ConstructDoSat

    !--------------------------------------------------------------------------

    subroutine CheckAditionalOutputs

        !Local-----------------------------------------------------------------
        type(T_Property),  pointer                  :: Property, PropAux
        integer                                     :: STAT_CALL

        !Begin-----------------------------------------------------------------

        Me%OutPut%DO_PercentSat         = .false.
        Me%OutPut%CHLA_WQ               = .false.
        Me%OutPut%Radiation             = .false.
        Me%OutPut%AditionalFields       = .false.
        Me%OutPut%CO2_PartialPressure   = .false.

        if (Me%ObjLightExtinction /= 0) then
            Me%OutPut%Radiation       = .true.
            Me%OutPut%AditionalFields = .true.
        endif

        Property => Me%FirstProperty

do1 :   do while (associated(Property))

            if (Property%Evolution%T90Variable) then
                Me%OutPut%Radiation       = .true.
                Me%OutPut%AditionalFields = .true.
            endif

case1 :     select case(Property%ID%IDNumber)

                case (Oxygen_)

                    !Search the temperature
                    call Search_Property(PropAux, PropertyXID = Temperature_, STAT = STAT_CALL)
                    if (STAT_CALL == SUCCESS_) then

                        !Search the salinity
                        call Search_Property(PropAux, PropertyXID = Salinity_, STAT = STAT_CALL)
                        if (STAT_CALL == SUCCESS_ .AND. Property%evolution%O2_Sat_Output) then

                            Me%OutPut%DO_PercentSat   = .true.
                            Me%OutPut%AditionalFields = .true.

                        endif

                    endif

                case (CarbonDioxide_)

                    !Search the temperature
                    call Search_Property(PropAux, PropertyXID = Temperature_, STAT = STAT_CALL)
                    if (STAT_CALL == SUCCESS_) then

                        !Search the salinity
                        call Search_Property(PropAux, PropertyXID = Salinity_, STAT = STAT_CALL)
                        if (STAT_CALL == SUCCESS_ .AND. Property%evolution%CO2_PP_Output) then

                            Me%OutPut%CO2_PartialPressure  = .true.
                            Me%OutPut%AditionalFields      = .true.

                        endif

                    endif


                case (Phytoplankton_)

                    !Search the temperature
                    call Search_Property(PropAux, PropertyXID = Temperature_, STAT = STAT_CALL)
                    if (STAT_CALL == SUCCESS_ .AND. Property%evolution%CHLA_WQ_Output) then

                            Me%OutPut%CHLA_WQ         = .true.
                            Me%OutPut%AditionalFields = .true.
                            Me%OutPut%C_CHLA          = Property%evolution%C_CHLA_Output

                    endif



                case default

            end select case1


        Property => Property%Next
        end do do1

        nullify(Property)

    end subroutine CheckAditionalOutputs

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION
    subroutine ConstructPropertiesIDArray(WaterPropertiesID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        type(T_Property), pointer                   :: ObjProperty
        integer                                     :: k

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            !Allocate ID array
            allocate(Me%PropertiesID(1:Me%PropertiesNumber))

            !Fill array with properties ID

            ObjProperty => Me%FirstProperty

            do k = 1, Me%PropertiesNumber

                Me%PropertiesID(k) = ObjProperty%ID%IDNumber
                ObjProperty => Me%FirstProperty%Next
            enddo

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine ConstructPropertiesIDArray

    !--------------------------------------------------------------------------

    subroutine PointToDensity(WaterPropertiesID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        !This is a set for internal memory space

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%Density%AuxPointerConc  => Me%Density%Field
            Me%Density%AuxPointerSigma => Me%Density%Sigma

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine PointToDensity

    !--------------------------------------------------------------------------

    subroutine PointToConcentration(WaterPropertiesID, PropertyXIDNumber, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,                      intent(IN )   :: PropertyXIDNumber
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_CALL

        !------------------------------------------------------------------------

        !This is a set for internal memory space

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber,    &
                                 STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                PropertyX%AuxPointerConc => PropertyX%concentration

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine PointToConcentration

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MO

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    subroutine WaterProperties_Evolution(WaterPropertiesID, NewDT, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        type(T_NewDT) , optional, intent(OUT)       :: NewDT
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_, iW
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "WaterProperties_Evolution")

            call ReadLockExternalVar

#ifdef _PHREEQC_
            if (Me%Coupled%PhreeqC%Yes .and. Me%MustStartPhreeqC) then
                call PhreeqC_Processes (.true.)
                if(Me%OutPut%Yes) &
                    call OutPut_Results_HDF
                Me%MustStartPhreeqC = .false.
            endif
#endif
            call TimeStepActualization

            if (Me%Coupled%SolutionFromFile%Yes)              &
                call ModifyPropertiesFromFile

            if (Me%Coupled%HydroIntegration%Yes)              &
                call HydroIntegration_Processes

            if (Me%Coupled%Discharges%Yes)                    &
                call WaterPropDischarges

            if (Me%Coupled%HybridReferenceField)              &
                call UpdateHybridReferenceField

            if (Me%NoFlux%ON)                                 &
                call ModifyNoFluxMapping

            if (Me%Coupled%AdvectionDiffusion%Yes)            &
                call Advection_Diffusion_Processes

            if (Me%Coupled%InstantMixing%Yes)                 &
                call InstantaneouslyMixing

            !Sets Limits to the concentration
            if (Me%Coupled%MinimumConcentration%Yes .or.      &
                Me%Coupled%MaximumConcentration%Yes)          &
                call SetLimitsConcentration(PhysicalProcesses = .true.) !('Physical Processes')

            if (Me%Coupled%FreeVerticalMovement%Yes)          &
                call FreeVerticalMovements_Processes

            if (Me%Coupled%BottomFluxes%Yes)                  &
                call Bottom_Processes

            !Sets Limits to the concentration
            if (Me%Coupled%MinimumConcentration%Yes .or.      &
                Me%Coupled%MaximumConcentration%Yes)          &
                call SetLimitsConcentration(PhysicalProcesses = .false.) !('Bottom Processes')

            if (Me%SolarRadiation%Exists)                       &
                call ModifySolarRadiation

            if (Me%OxygenSaturation)                          &
                call ModifyOxygenSaturation

            if (Me%Coupled%DecayRateProperty%Yes)             &
                call ModifyDecayRate

            if (Me%Coupled%FirstOrderDecay%Yes)               &
                call FirstOrderDecayProcesses

            if (Me%Coupled%SurfaceFluxes%Yes)                 &
                call Surface_Processes

            if (Me%ChemLinks%Coupled)                         &
                call ChemicalLinks

            !Sets Limits to the concentration
            if (Me%Coupled%MinimumConcentration%Yes .or.      &
                Me%Coupled%MaximumConcentration%Yes)          &
                call SetLimitsConcentration(PhysicalProcesses = .false.) !('Surface Processes')

            if (Me%Coupled%WQM%Yes)                           &
                call WaterQuality_Processes

            if (Me%Coupled%CEQUALW2%Yes)                      &
                call CEQUALW2_Processes

            if (Me%Coupled%Life%Yes)                          &
                call Life_Processes

            if (Me%Coupled%MacroAlgae%Yes)                    &
                call MacroAlgae_Processes

            if (Me%Coupled%SeagrassesLeaves%Yes)              &
                call SeagrassesLeaves_Processes

            if (Me%Coupled%WWTPQM%Yes)                        &
                call WWTPQ_Processes

#ifdef _PHREEQC_
            if (Me%Coupled%PhreeqC%Yes .and. .not. Me%PhreeqCOnlyForStart)                       &
                call PhreeqC_Processes (.false.)
#endif

            if (Me%Coupled%MinimumConcentration%Yes .or.      &
                Me%Coupled%MaximumConcentration%Yes)          &
                call SetLimitsConcentration(PhysicalProcesses = .false.) !('WaterQuality Processes')

            if (Me%Coupled%Bivalve%Yes)                       &
                call Bivalve_Processes

            if (Me%Coupled%MinimumConcentration%Yes .or.      &
                Me%Coupled%MaximumConcentration%Yes)          &
                call SetLimitsConcentration(PhysicalProcesses = .false.) !('Bivalve Processes')

            if (Me%Coupled%Partition%Yes)                     &
                call Partition_Processes

            if (Me%Coupled%DataAssimilation%Yes)              &
                call DataAssimilationProcesses

            ! nogueira e guillaume
            if (Me%Coupled%AltimetryAssimilation%Yes)         &
                call AltimAssimilationProcess

            if (Me%Coupled%CalculateAge%Yes)                  &
                call CalculateAge

            if (Me%Density%Variable)                          &
                call ModifyDensity(Me%ExternalVar%Now)

            if (Me%Density%VariableSed)                       &
                call ModifyDensitySed(Me%ExternalVar%Now)

            if (Me%Coupled%Filtration%Yes)                    &
                call Filtration_Processes

            if (Me%Coupled%Reinitialize%Yes)                  &
                call Reinitialize_Solution

            if (Me%SpecificHeat%Variable)                     &
                call ModifySpecificHeat(Me%ExternalVar%Now)

            if (Me%Coupled%ImposeDryCells%Yes)                &
                call ModifyImposeDryCells

#ifdef _USE_SEQASSIMILATION
            if (.not. Me%VirtualRun) then
#endif _USE_SEQASSIMILATION


            if (.not. associated (Me%Next))then
                Call Modify_TwoWay_Upscaling (WaterPropertiesID, Me%ExternalVar%Now)
            endif

            if(Me%OutPut%Yes)                                 &
                call OutPut_Results_HDF

            if (Me%OutW%OutPutWindowsON)  then

                do iW = 1, Me%OutW%WindowsNumber

                    if (Me%OutW%OutPutWindows(iW)%ON) then
                        call OutPut_Results_HDF(iW)
                    endif

                enddo

            endif


            if(Me%OutPut%SurfaceOutputs)                      &
                call OutPut_SurfaceResults_HDF

            if(Me%Coupled%TimeSerie%Yes)                      &
                call OutPut_TimeSeries

            if(Me%Coupled%OutputProfile%Yes)                  &
                call OutPut_Profile

            if(Me%Coupled%BoxTimeSerie%Yes) then
                if (Me%ExternalVar%Now .GE. Me%Coupled%BoxTimeSerie%NextCompute) then
                    call OutPut_BoxTimeSeries
                    Me%Coupled%BoxTimeSerie%NextCompute = Me%Coupled%BoxTimeSerie%NextCompute   &
                                                + Me%Coupled%BoxTimeSerie%DT_Compute
                endif
            endif

            if(Me%Coupled%Statistics%Yes)                     &
                call OutPut_Statistics

            if (present(NewDT)) call CalcNewDT (NewDT)

            call Actualize_Time_Evolution

#ifdef _USE_SEQASSIMILATION
            endif
#endif _USE_SEQASSIMILATION

            call ReadUnlockExternalVar

            if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "WaterProperties_Evolution")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

    end subroutine WaterProperties_Evolution

    !--------------------------------------------------------------------------

    Subroutine TimeStepActualization

        !Local-----------------------------------------------------------------

        type (T_Property), pointer       :: Property
        real                             :: NewDT
        integer                          :: FATAL_, INTERNAL_, STAT_CALL
        logical                          :: VariableDT

        !Begin-----------------------------------------------------------------


        !Get the time step of the model

        call GetComputeTimeStep(Me%ObjTime, NewDT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, INTERNAL_, 'TimeStepActualization; WaterProperties. ERR01.')


        call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                          &
             call CloseAllAndStop ('TimeStepActualization; WaterProperties. ERR02')

cd1:    if (VariableDT) then

            Property => Me%FirstProperty

do1 :       do while (associated(Property))

                Property%evolution%DTInterval = NewDT

                Property => Property%Next

            enddo do1


            nullify(Property)


        endif cd1


    end subroutine TimeStepActualization


    !--------------------------------------------------------------------------


    subroutine SmallDepthsMixing_Processes(PropertyX, VolumeZ, OpenPoints3D)


        !Arguments-------------------------------------------------------------
        type (T_Property),         pointer :: PropertyX
        real(8), dimension(:,:,:), pointer :: VolumeZ
        integer, dimension(:,:,:), pointer :: OpenPoints3D

        !Local-----------------------------------------------------------------
        real,    dimension(:,:  ), pointer :: WaterColumnZ
        integer, dimension(:,:  ), pointer :: KFloor_Z
        real(8)                            :: MassSum, VolSum
        integer                            :: STAT_CALL
        integer                            :: i, j, k, kbottom
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        !Begin-----------------------------------------------------------------


        !Begin - Shorten variables name

        IUB    = Me%WorkSize%IUB
        ILB    = Me%WorkSize%ILB
        JUB    = Me%WorkSize%JUB
        JLB    = Me%WorkSize%JLB
        KUB    = Me%WorkSize%KUB
        KLB    = Me%WorkSize%KLB

        KFloor_Z => Me%ExternalVar%KFloor_Z

        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)  &
            call CloseAllAndStop ('SmallDepthsMixing_Processes - ModuleWaterProperties - ERR01')

        do j = JLB, JUB
        do i = ILB, IUB

            Me%SmallDepths%ON(i, j) =.false.

            if (OpenPoints3D(i, j, KUB) == OpenPoint .and. &
                WaterColumnZ(i, j) < Me%SmallDepths%Limit) then

                Me%SmallDepths%ON(i, j) =.true.

                MassSum = 0.
                VolSum  = 0.

                kbottom = KFloor_Z(i, j)

                do k = kbottom, KUB

                    MassSum = MassSum + VolumeZ(i, j, k) * dble(PropertyX%Concentration(i, j, k))
                    VolSum  = VolSum  + VolumeZ(i, j, k)

                enddo

                ![M/L^3] = [M] / [L^3]
                PropertyX%Concentration(i, j, kbottom:KUB) = MassSum/VolSum


            endif

        enddo
        enddo



        call UnGetGeometry(Me%ObjGeometry,WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('SmallDepthsMixing_Processes - ModuleWaterProperties - ERR02')




    end subroutine SmallDepthsMixing_Processes

    !--------------------------------------------------------------------------


    subroutine FreeConvection(PropertyX, VolumeZ, OpenPoints3D)


        !Arguments-----------------------------------------------------------
        type (T_Property),         pointer :: PropertyX
        real(8), dimension(:,:,:), pointer :: VolumeZ
        integer, dimension(:,:,:), pointer :: OpenPoints3D

        !Local-----------------------------------------------------------------
        real(8)                            :: Cnew, Msum, Vsum
        integer                            :: i, j, k, ki
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        logical                            :: ProfileInstable
        !Begin-----------------------------------------------------------------


        !Begin - Shorten variables name

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        do j = JLB, JUB
        do i = ILB, IUB

            ProfileInstable = .false.
            do k = KLB, KUB
                if (OpenPoints3D(i, j, k  ) == OpenPoint .and. OpenPoints3D(i, j, k+1) == OpenPoint) then

                    if ((Me%Density%Field(i, j, k+1) - Me%Density%Field(i, j, k)) > 0.) then
                        ki = k
                        ProfileInstable = .true.
                        exit
                    endif
                endif
            enddo
            !If the density profile is instable mixe instantaniously the water column above the instable point
            if (ProfileInstable) then
                Msum = 0.
                Vsum = 0.
                do k=ki, KUB
                    Msum = Msum + VolumeZ(i, j, k) * dble(PropertyX%Concentration(i, j, k))
                    Vsum = Vsum + VolumeZ(i, j, k)
                enddo
                Cnew = real(Msum / Vsum)

                PropertyX%Concentration(i, j, ki:KUB) = Cnew

            endif


        enddo
        enddo

    end subroutine FreeConvection
    !--------------------------------------------------------------------------

#ifdef _USE_MPI

    subroutine SendWaterPropertiesMPI (WaterPropertiesID, Destination, Window, InitialField, &
                                       PropIDNumber, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: Destination
        type (T_Size2D)                             :: Window
        logical                                     :: InitialField
        integer                                     :: PropIDNumber
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        integer                                     :: iSize
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        real, dimension(6)                          :: AuxTime
        type(T_Property), pointer                   :: PropertyFather
        integer, dimension(:,:,:), pointer          :: Open3DFather
        integer, save                               :: Precision
        real,    pointer, dimension(:,:,:)          :: FatherZCellCenter

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then


            !Window to send
            ILB = Window%ILB
            IUB = Window%IUB
            JLB = Window%JLB
            JUB = Window%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB


            call Search_Property(PropertyFather, PropertyXID = PropIDNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR01')


            !OpenPoints3D father
            call GetOpenPoints3D(Me%ObjMap, Open3DFather, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR02')

            !FatherZCellCenter
            call GetGeometryDistances(Me%ObjGeometry, ZCellCenter   = FatherZCellCenter,     &
                                      STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR02b')

            if (InitialField) then

                !Sends KLB
                call MPI_Send (Me%WorkSize%KLB, 1, MPI_INTEGER, Destination, 954,            &
                               MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR03')

                !Sends KUB
                call MPI_Send (Me%WorkSize%KUB, 1, MPI_INTEGER, Destination, 955,            &
                               MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR04')

                !Sends if Property Father Old
                call MPI_Send (PropertyFather%Old, 1, MPI_LOGICAL, Destination, &
                               956, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR05')


                !Sends if Property Father is variable
                call MPI_Send (PropertyFather%Evolution%Variable, 1, MPI_LOGICAL, Destination, &
                               957, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR06')

                Precision = MPIKind(PropertyFather%Evolution%DTInterval)

                !Sends Property Father DTInterval
                call MPI_Send (PropertyFather%Evolution%DTInterval, 1, Precision, &
                               Destination, 958, MPI_COMM_WORLD, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR07')


                Precision = MPIKind(PropertyFather%Concentration)

            endif


            !Sends last iteration
            call ExtractDate (PropertyFather%Evolution%LastCompute,     &
                              AuxTime(1), AuxTime(2), AuxTime(3),       &
                              AuxTime(4), AuxTime(5), AuxTime(6))

            call MPI_Send (AuxTime, 6, Precision, Destination, 959, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR08')

            !Open3DFather
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (Open3DFather(ILB:IUB, JLB:JUB, KLB:KUB),                      &
                           iSize, MPI_INTEGER, Destination, 960, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR09')

            !FatherZCellCenter
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (FatherZCellCenter(ILB:IUB, JLB:JUB, KLB:KUB),                 &
                           iSize, Precision, Destination, 961, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR9b')

            !Property Father Concentration
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Send (PropertyFather%Concentration(ILB:IUB, JLB:JUB, KLB:KUB),      &
                           iSize, Precision, Destination, 962, MPI_COMM_WORLD, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR10')


            call UngetMap(Me%ObjMap, Open3DFather, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR11')

            call UnGetGeometry(Me%ObjGeometry, FatherZCellCenter, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SendWaterPropertiesMPI - ModuleWaterProperties - ERR12')

            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine SendWaterPropertiesMPI

    !--------------------------------------------------------------------------

    subroutine RecvWaterPropertiesMPI (WaterPropertiesID, Source, Window, InitialField,        &
                                       FatherGridID, PropIDNumber, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: Source
        type (T_Size2D)                             :: Window
        logical                                     :: InitialField
        integer                                     :: FatherGridID
        integer                                     :: PropIDNumber
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        integer, save                               :: KLB, KUB
        integer                                     :: ILB, IUB, JLB, JUB
        type (T_Size2D), save                       :: WorkSize, Size
        integer                                     :: status(MPI_STATUS_SIZE)
        real, dimension(6)                          :: AuxTime
        type(T_Time)                                :: PropFatherLastCompute
        type(T_Property), pointer                   :: PropertySon
        integer                                     :: iSize
        integer, save                               :: Precision
        real                                        :: DT_Father
        logical                                     :: PropFatherVariable, PropFatherOld
        integer, dimension(:,:,:),  pointer, save   :: Open3DFather
        real   , dimension(:,:,:),  pointer, save   :: PropFatherConcentration
        real   , dimension(:,:,:),  pointer, save   :: FatherZCellCenter

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            !Window Size
            ILB = Window%ILB
            IUB = Window%IUB
            JLB = Window%JLB
            JUB = Window%JUB

            call GetHorizontalGridSize (HorizontalGridID = FatherGridID, &
                                        Size = Size, WorkSize = WorkSize, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR01')

            call Search_Property(PropertySon, PropertyXID = PropIDNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR02')

            PropertySon%SubModel%Set = .false.

            if(InitialField)then

                !Receives KLB
                call MPI_Recv (KLB, 1, MPI_INTEGER, Source, 954,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR03')

                !Receives KUB
                call MPI_Recv (KUB, 1, MPI_INTEGER, Source, 955,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR04')

                !Receives if Property Father is old
                call MPI_Recv (PropFatherOld, 1, MPI_LOGICAL, Source, 956,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR05')

                !Receives if Property Father is variable
                call MPI_Recv (PropFatherVariable, 1, MPI_LOGICAL, Source, 957,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR06')

                if(PropFatherVariable .and. .not. PropertySon%Evolution%Variable)then
                    write(*,*)'Property father is variable and property son is not.'
                    write(*,*)'Property : ', trim(PropertySon%ID%Name)
                    !call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR07')
                end if
                if(.not. PropFatherVariable .and. PropertySon%Evolution%Variable)then
                    write(*,*)'Property father is not variable and property son is.'
                    write(*,*)'Property : ', trim(PropertySon%ID%Name)
                    !call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR08')
                end if

                Precision = MPIKind(DT_Father)

                !Receives Property Father DTInterval
                call MPI_Recv (DT_Father, 1, Precision, Source, 958,  MPI_COMM_WORLD, status, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR09')


                allocate (Open3DFather           (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (PropFatherConcentration(Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))
                allocate (FatherZCellCenter      (Size%ILB:Size%IUB, Size%JLB:Size%JUB, KLB-1:KUB+1))

                Open3DFather            = null_int
                PropFatherConcentration = null_real
                FatherZCellCenter       = null_real

                !Ang: new implementation
                PropertySon%SubModel%FatherKLB = KLB
                PropertySon%SubModel%FatherKUB = KUB

                call ConstructTimeInterpolation(PropertySon         = PropertySon,            &
                                                PropFatherVariable  = PropFatherVariable,     &
                                                DT_Father           = DT_Father)

                Precision = MPIKind(PropFatherConcentration)

            end if

            !Receives LastIteration
            call MPI_Recv (AuxTime, 6, Precision, Source, 959, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR10')


            call SetDate  (PropFatherLastCompute, &
                           AuxTime(1), AuxTime(2), AuxTime(3), AuxTime(4), AuxTime(5), AuxTime(6))


            !Open3DFather
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Recv (Open3DFather(ILB:IUB, JLB:JUB, KLB:KUB), iSize, MPI_INTEGER, &
                           Source, 960, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR11')

            !FatherZCellCenter
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Recv (FatherZCellCenter(ILB:IUB, JLB:JUB, KLB:KUB), iSize,         &
                           Precision, Source, 961, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR11b')

            !PropFatherConcentration
            iSize = (IUB-ILB+1) * (JUB-JLB+1) * (KUB-KLB+1)
            call MPI_Recv (PropFatherConcentration(ILB:IUB, JLB:JUB, KLB:KUB), iSize,   &
                           Precision, Source, 962, MPI_COMM_WORLD, status, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('RecvWaterPropertiesMPI - ModuleWaterProperties - ERR12')

            call ReadNextOrInitialField(FatherGridID = FatherGridID,                        &
                                        Open3DFather = Open3DFather,                        &
                                        FatherZCellCenter = FatherZCellCenter,              &
                                        PropertySon  = PropertySon,                         &
                                        PropFatherConcentration = PropFatherConcentration,  &
                                        InitialField = InitialField)

            if (.not. InitialField) then

                if ((PropertySon%SubModel%VertComunic == FatherSonDifDim) .or.                &
                    (PropertySon%SubModel%VertComunic == Father3DSon2D)) then

                    !Get time for interpolation from aux variables
                    PropertySon%SubModel%GetFatherTime = PropertySon%SubModel%NextTime &
                        + PropertySon%Evolution%DTInterval

                endif

                PropertySon%SubModel%PreviousTime = PropertySon%SubModel%NextTime
                PropertySon%SubModel%NextTime     = PropFatherLastCompute
            endif



            if      (PropertySon%SubModel%VertComunic == FatherSonEqualDim) then

                call ActualizeSubModelValues(PropertySon, PropFatherOld, InitialField)

            else if (PropertySon%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DFather2D (PropertySon, PropFatherOld, InitialField)

            else if ((PropertySon%SubModel%VertComunic == FatherSonDifDim) .or.                   &
                      (PropertySon%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DFather3D (PropertySon, PropFatherOld, InitialField)

            endif

            nullify (PropertySon)


            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine RecvWaterPropertiesMPI

    !--------------------------------------------------------------------------

    subroutine UpdateWaterMPI (WaterPropertiesID, InitialField, PropIDNumber, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        logical                                     :: InitialField
        integer                                     :: PropIDNumber
        integer, optional, intent (OUT)             :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        type(T_Property), pointer                   :: PropertySon

        !Begin-----------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            call Search_Property(PropertySon, PropertyXID = PropIDNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('UpdateWaterMPI - ModuleWaterProperties - ERR01')

            PropertySon%SubModel%Set = .false.

            if      (PropertySon%SubModel%VertComunic == FatherSonEqualDim) then

                !PropFatherOld can be set to old because initial field is false
                call ActualizeSubModelValues(PropertySon, PropFatherOld = .false., InitialField = InitialField)

            else if (PropertySon%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DFather2D (PropertySon, PropFatherOld = .false., InitialField = InitialField)

            else if ((PropertySon%SubModel%VertComunic == FatherSonDifDim) .or.           &
                      (PropertySon%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DFather3D (PropertySon, PropFatherOld = .false., InitialField = InitialField)

            endif

            nullify (PropertySon)

            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine UpdateWaterMPI


#endif _USE_MPI


    !---------------------------------------------------------------------------------------------


    subroutine SetWaterPropFather (WaterPropertiesSonID, WaterPropertiesFatherID,      &
                                   PropIDNumber, InitialField, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesSonID, WaterPropertiesFatherID
        integer,            intent(IN )             :: PropIDNumber
        logical,            intent(IN )             :: InitialField
        integer, optional,  intent(OUT)             :: STAT

        !Local-----------------------------------------------------------------
        type(T_WaterProperties), pointer            :: ObjWaterPropertiesFather
        type(T_Property       ), pointer            :: PropertyFather, PropertySon
        integer                                     :: ready_, STAT_, STAT_CALL, ILB, IUB, JLB, JUB, KLB, KUB
        integer, dimension(:,:,:),  pointer         :: Open3DFather
        logical                                     :: PropFatherOld
        real,    pointer, dimension(:,:,:)          :: FatherZCellCenter
        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesSonID, ready_)

        call LocateObjFather (ObjWaterPropertiesFather, WaterPropertiesFatherID)

        JLB = ObjWaterPropertiesFather%WorkSize%JLB; JUB = ObjWaterPropertiesFather%WorkSize%JUB !Sobrinho
        ILB = ObjWaterPropertiesFather%WorkSize%ILB; IUB = ObjWaterPropertiesFather%WorkSize%IUB
        KLB = ObjWaterPropertiesFather%WorkSize%KLB; KUB = ObjWaterPropertiesFather%WorkSize%KUB

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            call Search_Property(PropertySon, PropertyXID = PropIDNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR10')

            PropertySon%SubModel%Set = .false.

            call Search_PropertyFather(ObjWaterPropertiesFather, PropertyFather,            &
                                       PropertyXID = PropIDNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR20')

            if (.not.associated(PropertyFather)) then
                call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR30')
            endif

            if(InitialField)then

                Me%WPFatherInstanceID = ObjWaterPropertiesFather%InstanceID

                if(PropertyFather%Evolution%Variable .and. .not. PropertySon%Evolution%Variable) then
                    write(*,*)'Property father is variable and property son is not.'
                    write(*,*)'Property : ', trim(PropertySon%ID%Name)
                    write(*,*)'SetWaterPropFather - ModuleWaterProperties - WARN10'
                end if
                if(.not. PropertyFather%Evolution%Variable .and. PropertySon%Evolution%Variable) then
                    write(*,*)'Property father is not variable and property son is.'
                    write(*,*)'Property : ', trim(PropertySon%ID%Name)
                    write(*,*)'SetWaterPropFather - ModuleWaterProperties - WARN20'
                end if

                !Ang: new implementation
                PropertySon%SubModel%FatherKLB = ObjWaterPropertiesFather%WorkSize%KLB
                PropertySon%SubModel%FatherKUB = ObjWaterPropertiesFather%WorkSize%KUB

                call ConstructTimeInterpolation(PropertySon         = PropertySon,                           &
                                                PropFatherVariable  = PropertyFather%Evolution%Variable,     &
                                                DT_Father           = PropertyFather%Evolution%DTInterval)
                !Sobrinho
                if (PropertySon%UpscalingSinkSource) allocate(PropertyFather%UpscalingMassLoss(ILB:IUB, JLB:JUB, KLB:KUB))
                PropertyFather%UpscalingMassLoss = 0.0
                !Change variable here instead of in construct phase, because user must define everything in son domain.
                !Doing it here facilitates writing to HDF
                PropertyFather%UpscalingSinkSource = .true.
            end if

            if (PropertyFather%Evolution%LastCompute > PropertySon%SubModel%NextTime .or. InitialField) then

                !OpenPoints3D Son
                call GetOpenPoints3D(ObjWaterPropertiesFather%ObjMap, Open3DFather, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR40')

                call GetGeometryDistances(ObjWaterPropertiesFather%ObjGeometry,                         &
                                          ZCellCenter   = FatherZCellCenter,                            &
                                          STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR41')

                call ReadNextOrInitialField(FatherGridID = ObjWaterPropertiesFather%ObjHorizontalGrid,  &
                                            Open3DFather = Open3DFather,                                &
                                            FatherZCellCenter = FatherZCellCenter,                      &
                                            PropertySon  = PropertySon,                                 &
                                            PropFatherConcentration = PropertyFather%Concentration,     &
                                            InitialField = InitialField)

                if (.not. InitialField) then

                    if ((PropertySon%SubModel%VertComunic == FatherSonDifDim) .or.                &
                        (PropertySon%SubModel%VertComunic == Father3DSon2D)) then

                        !Ang: new father-son implementation

                        !Get time for interpolation from aux variables
                        PropertySon%SubModel%GetFatherTime = PropertySon%SubModel%NextTime &
                            + PropertySon%Evolution%DTInterval

                    endif

                    PropertySon%SubModel%PreviousTime = PropertySon%SubModel%NextTime
                    PropertySon%SubModel%NextTime     = PropertyFather%Evolution%LastCompute
                endif

                call UngetMap(ObjWaterPropertiesFather%ObjMap, Open3DFather, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR50')

                call UnGetGeometry(ObjWaterPropertiesFather%ObjGeometry, FatherZCellCenter, STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetWaterPropFather - ModuleWaterProperties - ERR60')

            endif

            if      (PropertySon%SubModel%VertComunic == FatherSonEqualDim ) then

                call ActualizeSubModelValues(PropertySon, PropFatherOld, InitialField)

            else if (PropertySon%SubModel%VertComunic == Father2DSon3D) then

                call ActualizeSon3DFather2D (PropertySon, PropFatherOld, InitialField)

            else if ((PropertySon%SubModel%VertComunic == FatherSonDifDim) .or. &
                      (PropertySon%SubModel%VertComunic == Father3DSon2D)) then

                !Ang: new implementation
                call ActualizeSon3DFather3D (PropertySon, PropFatherOld, InitialField)

            endif

            nullify (PropertySon   )
            nullify (PropertyFather)

            STAT_ = SUCCESS_
        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT))STAT = STAT_

    end subroutine SetWaterPropFather

    !--------------------------------------------------------------------------

    subroutine ConstructTimeInterpolation(PropertySon, PropFatherVariable, DT_Father)

        !Arguments-------------------------------------------------------------
        type(T_Property), pointer           :: PropertySon
        logical,    intent(IN)              :: PropFatherVariable
        real,       intent(IN)              :: DT_Father

        !Local---------------------------------------------------------------------
        real                                :: Aux1, Aux2, DT_Son
        integer                             :: STAT_CALL, FATAL_, OUT_OF_MEM_
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: FatherLayers, SonLayers, FatherKLB, FatherKUB
        !----------------------------------------------------------------------

        IUB = Me%Size%IUB; JUB = Me%Size%JUB; KUB = Me%Size%KUB
        ILB = Me%Size%ILB; JLB = Me%Size%JLB; KLB = Me%Size%KLB

        !Ang: new implementation
        FatherKLB = PropertySon%SubModel%FatherKLB
        FatherKUB = PropertySon%SubModel%FatherKUB

        FatherLayers = FatherKUB - FatherKLB + 1
        SonLayers    = Me%WorkSize%KUB - Me%WorkSize%KLB + 1

        !Check if necessary to interpolate in time
        DT_Son    = PropertySon%Evolution%DTInterval

cd3:    if (PropFatherVariable) then

cd1:        if      (DT_Son <  DT_Father) then

                Aux1 = DT_Father / DT_Son
                Aux2 = real(int (Aux1))

                if (Aux1 /= Aux2)                                                            &
                    call CloseAllAndStop ('ConstructTimeInterpolation; WaterProperties. ERR01')

                PropertySon%SubModel%InterpolTime  = .true.

            else if (DT_Son == DT_Father) then cd1

                PropertySon%SubModel%InterpolTime  = .false.

            else  cd1

                call CloseAllAndStop ('ConstructTimeInterpolation; WaterProperties. ERR02')

            endif cd1

        else  cd3

            PropertySon%SubModel%InterpolTime  = .false.

        endif cd3

        call null_time(PropertySon%SubModel%PreviousTime)

        PropertySon%SubModel%NextTime = Me%BeginTime


        if      ((FatherLayers == 1) .and. (SonLayers >  1)) then

            PropertySon%SubModel%VertComunic = Father2DSon3D

        else if ((FatherLayers >  1) .and. (SonLayers == 1)) then

            PropertySon%SubModel%VertComunic = Father3DSon2D

            !Ang: new implementation
            !Allocate auxiliary variables for father-son connection
            nullify(PropertySon%SubModel%Aux_Field)
            nullify(PropertySon%SubModel%Aux_ZCellCenter)

            allocate(PropertySon%SubModel%Aux_Field (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB), &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                          &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - WaterProperties - ERR06")
            PropertySon%SubModel%Aux_Field (:,:,:) = FillValueReal

            allocate(PropertySon%SubModel%Aux_ZCellCenter (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB), &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                          &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - WaterProperties - ERR06")
            PropertySon%SubModel%Aux_ZCellCenter (:,:,:) = FillValueReal

            call Null_Time(PropertySon%SubModel%GetFatherTime)

        else if (FatherLayers         ==  SonLayers) then

            PropertySon%SubModel%VertComunic = FatherSonEqualDim

        else

            PropertySon%SubModel%VertComunic = FatherSonDifDim

            !Ang: new implementation
            !Allocate auxiliary variables for father-son connection
            nullify(PropertySon%SubModel%Aux_Field)
            nullify(PropertySon%SubModel%Aux_ZCellCenter)

            allocate(PropertySon%SubModel%Aux_Field (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB), &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                          &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - WaterProperties - ERR06")
            PropertySon%SubModel%Aux_Field (:,:,:) = FillValueReal

            allocate(PropertySon%SubModel%Aux_ZCellCenter (ILB:IUB, JLB:JUB, FatherKLB:FatherKUB), &
                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                          &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - WaterProperties - ERR06")
            PropertySon%SubModel%Aux_ZCellCenter (:,:,:) = FillValueReal

            call Null_Time(PropertySon%SubModel%GetFatherTime)

        endif


cd2:    if (PropertySon%SubModel%InterpolTime) then

            allocate (PropertySon%SubModel%PreviousField(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - WaterProperties - ERR03")

            PropertySon%SubModel%PreviousField (:,:,:) = FillValueReal

            allocate (PropertySon%SubModel%NextField(ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                call SetError (FATAL_, OUT_OF_MEM_, "ConstructTimeInterpolation - WaterProperties - ERR04")

            PropertySon%SubModel%NextField(:,:,:) = FillValueReal

        else  cd2

            PropertySon%SubModel%PreviousField   => PropertySon%Assimilation%Field
            PropertySon%SubModel%NextField       => PropertySon%Assimilation%Field


        endif cd2


    end subroutine ConstructTimeInterpolation

    !--------------------------------------------------------------------------
    !called by son model
    Subroutine ReadNextOrInitialField (FatherGridID, Open3DFather, FatherZCellCenter,    &
                                       PropertySon, PropFatherConcentration, InitialField)

        !Arguments-------------------------------------------------------------
        integer                                 :: FatherGridID
        type(T_Property),           pointer     :: PropertySon
        real,    dimension(:,:,:),  pointer     :: PropFatherConcentration
        integer, dimension(:,:,:),  pointer     :: Open3DFather
        real,    pointer, dimension(:,:,:)      :: FatherZCellCenter
        logical                                 :: InitialField

        !Local-----------------------------------------------------------------
        integer                                 :: ComputeZ
        integer                                 :: STAT_CALL
        integer                                 :: ILBSon, IUBSon, JLBSon, JUBSon, KLBSon, KUBSon
        integer                                 :: KLBFather, KUBFather
        integer, dimension(:,:,:),  pointer     :: Open3DSon, Null_Mapping

        !----------------------------------------------------------------------


        KUBSon    = Me%WorkSize%KUB
        KLBSon    = Me%WorkSize%KLB
        ILBson    = Me%WorkSize%ILB
        IUBson    = Me%WorkSize%IUB
        JLBson    = Me%WorkSize%JLB
        JUBson    = Me%WorkSize%JUB

        !Ang: new implementation father-son 3D connection
        KUBFather = PropertySon%SubModel%FatherKUB
        KLBFather = PropertySon%SubModel%FatherKLB

        call GetComputeZUV(FatherGridID, ComputeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ReadNextOrInitialField - WaterProperties - ERR10')

        if (PropertySon%SubModel%InterPolTime .and. .not. InitialField)then
            call SetMatrixValue(PropertySon%SubModel%PreviousField,         &
                                Me%Size, PropertySon%SubModel%NextField)
        endif

        if (PropertySon%SubModel%Extrapolate) then

            call GetOpenPoints3D(Me%ObjMap, Open3DSon, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadNextOrInitialField - WaterProperties - ERR20')

        endif

        !Ang: new implementation
        if ((PropertySon%SubModel%VertComunic == FatherSonDifDim) .or.      &
            (PropertySon%SubModel%VertComunic == Father3DSon2D)) then

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,               &
                                        FatherGridID,                       &
                                        PropFatherConcentration,            &
                                        PropertySon%SubModel%Aux_Field,     &
                                        Open3DFather, ComputeZ,             &
                                        KLBFather, KUBFather, KUBSon,       &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ReadNextOrInitialField - WaterProperties - ERR30')

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,               &
                                        FatherGridID,                       &
                                        FatherZCellCenter,                  &
                                        PropertySon%SubModel%Aux_ZCellCenter, &
                                        Open3DFather, ComputeZ,             &
                                        KLBFather, KUBFather, KUBSon,       &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ReadNextOrInitialField - WaterProperties - ERR40')

            if (PropertySon%SubModel%Extrapolate) then

                nullify(Null_Mapping)

                call ExtraPol3DNearestCell (ILBson, IUBson, JLBson, JUBson, KLBFather, KUBFather, &
                                            Null_Mapping, PropertySon%SubModel%Aux_Field)

                call ExtraPol3DNearestCell (ILBson, IUBson, JLBson, JUBson, KLBFather, KUBFather, &
                                            Null_Mapping, PropertySon%SubModel%Aux_ZCellCenter)

            endif

        else

            call InterpolRegularGrid   (Me%ObjHorizontalGrid,               &
                                        FatherGridID,                       &
                                        PropFatherConcentration,            &
                                        PropertySon%SubModel%NextField,     &
                                        Open3DFather, ComputeZ,             &
                                        KLBFather, KUBFather, KUBSon,       &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ReadNextOrInitialField - WaterProperties - ERR50')

            if (PropertySon%SubModel%Extrapolate) then

                call ExtraPol3DNearestCell (ILBson, IUBson, JLBson, JUBson, KLBson, KUBson, &
                                            Open3DSon, PropertySon%SubModel%NextField)

           endif

        endif

        if (PropertySon%SubModel%Extrapolate) then

            call UnGetMap(Me%ObjMap, Open3DSon, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadNextOrInitialField - WaterProperties - ERR60')

        endif

        if (PropertySon%SubModel%InterPolTime .and. InitialField)then

            if ((PropertySon%SubModel%VertComunic /= FatherSonDifDim) .or.  &
                (PropertySon%SubModel%VertComunic /= Father3DSon2D)) then

                call SetMatrixValue(PropertySon%SubModel%PreviousField,     &
                                    Me%Size, PropertySon%SubModel%NextField)
            endif

        end if

    end Subroutine ReadNextOrInitialField


    !--------------------------------------------------------------------------

    Subroutine ActualizeSubModelValues (PropertySon, PropFatherOld, InitialField)

        !Arguments-------------------------------------------------------------
        type (T_Property),       pointer    :: PropertySon
        logical, intent(in)                 :: PropFatherOld, InitialField

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: Open3DSon
        type(T_Time)                        :: CurrentTime
        real                                :: TimeCoef
        integer                             :: STAT_CALL
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k
        integer                             :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (PropertySon%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime, CurrentTime, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSubModelValues - WaterProperties - ERR01')

            TimeCoef = (CurrentTime                   - PropertySon%SubModel%PreviousTime) / &
                       (PropertySon%SubModel%NextTime - PropertySon%SubModel%PreviousTime)

        else

            TimeCoef = 1

        endif

        !OpenPoints3D Son
        call GetOpenPoints3D(Me%ObjMap, OpenPoints3D = Open3DSon, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSubModelValues - WaterProperties - ERR02')

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleWaterProperties", "ActualizeSubModelValues")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k)
        if(InitialField)then

            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Open3DSon(i, j, k) == OpenPoint) then
                    if (abs(PropertySon%SubModel%NextField    (i, j, k)) < abs(FillValueReal) / 2. .and.   &
                        abs(PropertySon%SubModel%PreviousField(i, j, k)) < abs(FillValueReal) / 2.) then

                        PropertySon%Assimilation%Field(i, j, k) =                                &
                            PropertySon%SubModel%NextField    (i, j, k) * TimeCoef  +            &
                            PropertySon%SubModel%PreviousField(i, j, k) * (1 - TimeCoef)

                        if ((.not. PropertySon%Old) .and. (PropFatherOld .or. PropertySon%SubModel%Initial))then
                            PropertySon%Concentration(i, j, k) = PropertySon%Assimilation%Field(i, j, k)
                        endif

                    else
                        !$OMP CRITICAL (ASMV1WP_OUT01)
                        write(*,*) 'The cell ', i, j, k, ' can not access to father ',trim(PropertySon%ID%Name)
                        !$OMP END CRITICAL(ASMV1WP_OUT01)
                        PropertySon%Assimilation%Field(i, j, k) = PropertySon%Concentration(i, j, k)

                    endif
                endif
            enddo
            enddo
            !$OMP END DO
            enddo

        else
            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB
                if (Open3DSon(i, j, k) == OpenPoint) then

                    if (abs(PropertySon%SubModel%NextField    (i, j, k)) < abs(FillValueReal) / 2. .and.   &
                        abs(PropertySon%SubModel%PreviousField(i, j, k)) < abs(FillValueReal) / 2.) then

                        PropertySon%Assimilation%Field(i, j, k) =                                &
                            PropertySon%SubModel%NextField    (i, j, k) * TimeCoef  +            &
                            PropertySon%SubModel%PreviousField(i, j, k) * (1 - TimeCoef)
                    else

                        PropertySon%Assimilation%Field(i, j, k) = PropertySon%Concentration(i, j, k)

                    endif
                endif
            enddo
            enddo
            !$OMP END DO
            enddo

        endif
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleWaterProperties", "ActualizeSubModelValues")
        endif

        PropertySon%SubModel%Set = .true.

        !OpenPoints3D Son
        call UnGetMap(Me%ObjMap, Open3DSon, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ActualizeSubModelValues - WaterProperties - ERR03')

    end Subroutine ActualizeSubModelValues


    !--------------------------------------------------------------------------

    Subroutine ActualizeSon3DFather2D (PropertySon, PropFatherOld, InitialField)

        !Arguments-------------------------------------------------------------
        type (T_Property),       pointer    :: PropertySon
        logical                             :: PropFatherOld, InitialField

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: Open3DSon
        integer, dimension(:,:  ), pointer  :: KFloor_Z
        type(T_Time)                        :: CurrentTime
        real                                :: TimeCoef
        integer                             :: STAT_CALL
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k, kbottom
        integer                             :: CHUNK

        !----------------------------------------------------------------------
        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (PropertySon%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime, CurrentTime, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR01')

            TimeCoef = (PropertySon%SubModel%NextTime - CurrentTime)             /       &
                       (PropertySon%SubModel%NextTime - PropertySon%SubModel%PreviousTime)

        else

            TimeCoef = 1

        endif

        !OpenPoints3D Son
        call GetOpenPoints3D(Me%ObjMap,  OpenPoints3D = Open3DSon, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR02')

        !KFloor_Z
        call GetGeometryKFloor(Me%ObjGeometry, Z = KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR03')

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleWaterProperties", "ActualizeSon3DFather2D")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
        if(InitialField)then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Open3DSon(i, j, KUB) == OpenPoint) then

                    if (abs(PropertySon%SubModel%NextField    (i, j, KUB)) < abs(FillValueReal) / 2. .and.   &
                        abs(PropertySon%SubModel%PreviousField(i, j, KUB)) < abs(FillValueReal) / 2.) then

                        kbottom = kFloor_Z(i, j)

                        do k = kbottom, KUB
                            PropertySon%Assimilation%Field(i, j, k) =                             &
                                PropertySon%SubModel%NextField    (i, j, KUB) * TimeCoef      +  &
                                PropertySon%SubModel%PreviousField(i, j, KUB) * (1 - TimeCoef)
                        enddo

                        if (.not. PropertySon%Old  .and. (PropFatherOld .or. PropertySon%SubModel%Initial)) then
                            PropertySon%Concentration(i, j, k) = PropertySon%Assimilation%Field(i, j, k)
                        endif

                    else

                        kbottom = kFloor_Z(i, j)
                        !$OMP CRITICAL (AS3DF2D1WP_OUT01)
                        do k = kbottom, KUB
                            write(*,*) 'The cell ', i, j, k, ' can not access to father ',trim(PropertySon%ID%Name)
                        enddo
                        !$OMP END CRITICAL(AS3DF2D1WP_OUT01)
                    endif
                endif
            enddo
            enddo
            !$OMP END DO

        else

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Open3DSon(i, j, KUB) == OpenPoint) then

                    if (abs(PropertySon%SubModel%NextField    (i, j, KUB)) < abs(FillValueReal) / 2. .and.   &
                        abs(PropertySon%SubModel%PreviousField(i, j, KUB)) < abs(FillValueReal) / 2.) then

                        kbottom = kFloor_Z(i, j)

                        do k = kbottom, KUB

                            PropertySon%Assimilation%Field(i, j, k) =                             &
                                PropertySon%SubModel%NextField    (i, j, KUB) * TimeCoef      +  &
                                PropertySon%SubModel%PreviousField(i, j, KUB) * (1 - TimeCoef)

                        enddo

                    else
                        !do nothing?
                    endif
                endif
            enddo
            enddo
            !$OMP END DO

        endif
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleWaterProperties", "ActualizeSon3DFather2D")
        endif

        PropertySon%SubModel%Set = .true.

        !OpenPoints3D Son
        call UnGetMap(Me%ObjMap, Open3DSon, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR04')

        !KFloor_Z
        call UnGetGeometry(Me%ObjGeometry, KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR05')

    end Subroutine ActualizeSon3DFather2D

    !--------------------------------------------------------------------------

    Subroutine ActualizeSon3DFather3D (PropertySon, PropFatherOld, InitialField) !Ang: new implementation

        !Arguments-------------------------------------------------------------
        type (T_Property),       pointer    :: PropertySon
        logical                             :: PropFatherOld, InitialField

        !Local-----------------------------------------------------------------
        integer, dimension(:,:,:), pointer  :: Open3DSon
        integer, dimension(:,:  ), pointer  :: KFloor_Z
        type(T_Time)                        :: CurrentTime
        real                                :: TimeCoef
        integer                             :: STAT_CALL
        integer                             :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                             :: i, j, k, kbottom

        integer                             :: KLBFather, KUBFather
        real(8)                             :: SonDepth
        real(8), dimension (:), pointer     :: Depths, Values
        real,    pointer, dimension(:,:,:)  :: SonZCellCenter
        integer                             :: NDepths, Aux
        integer                             :: kfather
        logical                             :: FoundBottom, FoundSurface
        integer                             :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        if (PropertySon%SubModel%InterPolTime .and. .not. InitialField) then

            !Time Properties - Actualises CurrentTime
            call GetComputeCurrentTime(Me%ObjTime, CurrentTime, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR01')

            TimeCoef = (PropertySon%SubModel%NextTime - CurrentTime)             /       &
                       (PropertySon%SubModel%NextTime - PropertySon%SubModel%PreviousTime)

        else

            TimeCoef = 1

        endif

        !Ang: new father-son implementation
        !Get father layers (just shorten variables)
        KLBFather = PropertySon%SubModel%FatherKLB
        KUBFather = PropertySon%SubModel%FatherKUB

        !OpenPoints3D Son
        call GetOpenPoints3D(Me%ObjMap,  OpenPoints3D = Open3DSon, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather3D - WaterProperties - ERR02')

        !KFloor_Z
        call GetGeometryKFloor(Me%ObjGeometry, Z = KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather3D - WaterProperties - ERR03')

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleWaterProperties", "ActualizeSon3DFather3D")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,Aux,kfather,Values,Depths,Kbottom,NDepths,SonDepth)

        !Get data for vertical interpolation father-son layers
        if (((CurrentTime == PropertySon%SubModel%GetFatherTime) .and.              &
            PropertySon%SubModel%InterPolTime) .or.                                 &
            (.not. PropertySon%SubModel%InterPolTime)                               &
            .or. InitialField) then

            !allocate father depth values arrays
            allocate(Depths(KLBFather: KUBFather),STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                              &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR06")

            allocate(Values(KLBFather: KUBFather),STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                              &
                call SetError(FATAL_, INTERNAL_,                                    &
                              "ActualizeSon3DWithFather3D; Hydrodynamic. ERR07")

            !$OMP MASTER
            call GetGeometryDistances(Me%ObjGeometry,                               &
                                      ZCellCenter   = SonZCellCenter,               &
                                      STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR02')
            !$OMP END MASTER
            !$OMP BARRIER

        endif

        if(InitialField)then

            !ACanas: Next cycle is not parallelized because of function call
            !ACanas: inside cycle iterations.

            !$OMP MASTER
            do j = JLB, JUB
            do i = ILB, IUB

                !Prepare profiles for vertical layers interpolation father to son
                !find the first father layer for interpolation
                Aux = KLBFather

                do kfather=KUBFather, KLBFather, -1
                    if (PropertySon%SubModel%Aux_Field(i, j, kfather)           &
                        < FillValueReal / 2.) then
                        Aux = kfather + 1
                       exit
                    else
                        Values(kfather) = PropertySon%SubModel%Aux_Field(i,j,kfather)
                        Depths(kfather) = - PropertySon%SubModel%Aux_ZCellCenter(i,j,kfather)
                    endif
                enddo

                Kbottom = KFloor_Z(i, j)

                if (Kbottom > 0) then
                !(only for water points (which can be water))

                    !get number of father depths
                    NDepths = KUBFather - Aux + 1

                    do k = KUB, Kbottom, -1

                        if (Open3DSon(i, j, k) == OpenPoint) then

                            if (NDepths > 0) then
                                !Perform vertical layers interpolation father to son
                                !(get NextField from father)

                                !get son cell depth
                                SonDepth = - SonZCellCenter(i, j, k)

                                !interpolate father values as a profile
                                PropertySon%SubModel%NextField(i,j,k) =                 &
                                                InterpolateProfileR8(SonDepth,          &
                                                NDepths, Depths(Aux:KUBFather),         &
                                                Values(Aux:KUBFather),                  &
                                                FoundBottom, FoundSurface)

                                PropertySon%SubModel%PreviousField(i,j,k) =             &
                                PropertySon%SubModel%NextField(i,j,k)

                            endif

                            !Perform time interpolation
                            if (abs(PropertySon%SubModel%NextField    (i, j, k)) < abs(FillValueReal) / 2. .and.   &
                                abs(PropertySon%SubModel%PreviousField(i, j, k)) < abs(FillValueReal) / 2.) then

                                PropertySon%Assimilation%Field(i, j, k) =               &
                                    PropertySon%SubModel%NextField    (i, j, k) * TimeCoef      +  &
                                    PropertySon%SubModel%PreviousField(i, j, k) * (1 - TimeCoef)

                                if (.not. PropertySon%Old  .and. (PropFatherOld .or. PropertySon%SubModel%Initial)) then
                                    PropertySon%Concentration(i, j, k) = PropertySon%Assimilation%Field(i, j, k)
                                endif

                            else

                                write(*,*) 'The cell ', i, j, k, ' can not access to father ',trim(PropertySon%ID%Name)

                            endif
                        endif

                    enddo

                endif

            enddo
            enddo
            !$OMP END MASTER

        else


            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (((CurrentTime == PropertySon%SubModel%GetFatherTime) .and.      &
                     PropertySon%SubModel%InterPolTime) .or.                        &
                     (.not. PropertySon%SubModel%InterPolTime)) then
                    !Prepare profiles for vertical layers interpolation father to son

                    !find the first father layer for interpolation
                    Aux = KLBFather

                    do kfather=KUBFather, KLBFather, -1
                        if (PropertySon%SubModel%Aux_Field(i, j, kfather)                        &
                            < FillValueReal / 2.) then
                            Aux = kfather + 1
                           exit
                        else
                            Values(kfather) =   PropertySon%SubModel%Aux_Field(i,j,kfather)
                            Depths(kfather) = - PropertySon%SubModel%Aux_ZCellCenter(i,j,kfather)
                        endif
                    enddo

                    !get number of father depths
                    NDepths = KUBFather - Aux + 1

                endif

                Kbottom = KFloor_Z(i, j)

                if (Kbottom > 0)then
                !Only for water points (can be water)

                    do k = KUB, Kbottom, -1

                        if (Open3DSon(i, j, k) == OpenPoint) then

                            if ((((CurrentTime == PropertySon%SubModel%GetFatherTime) .and. &
                                PropertySon%SubModel%InterPolTime) .or.                     &
                                (.not. PropertySon%SubModel%InterPolTime)) .and.            &
                                (NDepths > 0)) then
                                !Perform vertical layers interpolation father to son
                                !(get NextField from father)

                                !get son cell depth
                                SonDepth = - SonZCellCenter(i, j, k)

                                !$OMP CRITICAL (AS3DF3D3WP_FNC02)
                                !interpolate father values as a profile
                                PropertySon%SubModel%NextField(i,j,k) =                     &
                                                    InterpolateProfileR8(SonDepth,          &
                                                    NDepths, Depths(Aux:KUBFather),         &
                                                    Values(Aux:KUBFather),                  &
                                                    FoundBottom, FoundSurface)
                                !$OMP END CRITICAL (AS3DF3D3WP_FNC02)

                            endif

                            if (abs(PropertySon%SubModel%NextField    (i, j, k)) < abs(FillValueReal) / 2. .and.   &
                                abs(PropertySon%SubModel%PreviousField(i, j, k)) < abs(FillValueReal) / 2.) then

                                PropertySon%Assimilation%Field(i, j, k) =                             &
                                    PropertySon%SubModel%NextField    (i, j, k) * TimeCoef      +  &
                                    PropertySon%SubModel%PreviousField(i, j, k) * (1 - TimeCoef)

                                !(only the assimilation field is changed: it can or not be used)

                            else
                                !do nothing?
                            endif

                        endif

                    enddo

                endif

            enddo
            enddo
            !$OMP END DO

        endif

        !Deallocates values and depths used in vertical interpolation
        if (((CurrentTime == PropertySon%SubModel%GetFatherTime) .and.              &
            PropertySon%SubModel%InterPolTime) .or.                                 &
            (.not. PropertySon%SubModel%InterPolTime)                               &
            .or. InitialField) then

            deallocate(Depths)
            deallocate(Values)

            !$OMP MASTER
            !ZCellCenter
            call UnGetGeometry(Me%ObjGeometry, SonZCellCenter, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR05')

            if (PropertySon%SubModel%InterPolTime .and. .not. InitialField) then

                call null_Time(CurrentTime)

            endif
            !$OMP END MASTER

        endif
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleWaterProperties", "ActualizeSon3DFather3D")
        endif

        PropertySon%SubModel%Set = .true.

        !OpenPoints3D Son
        call UnGetMap(Me%ObjMap, Open3DSon, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR04')

        !KFloor_Z
        call UnGetGeometry(Me%ObjGeometry, KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('ActualizeSon3DFather2D - WaterProperties - ERR05')

    end Subroutine ActualizeSon3DFather3D

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing the
    ! advection Diffusion processes

    subroutine Advection_Diffusion_Processes

        !External--------------------------------------------------------------
        real(8), pointer, dimension(:,:,:)      :: AdvFluxX, AdvFluxY, AdvFluxZ
        real(8), pointer, dimension(:,:,:)      :: DifFluxX, DifFluxY, DifFluxZ
        integer                                 :: STAT_CALL
        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: Property
        type (T_Time)                           :: Actual
        real                                    :: ImpExp_AdvXX, ImpExp_AdvYY, firstSchmidt
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: I, J, K
        integer, pointer, dimension(:,:,:)      :: OpenPoints3D
        integer                                 :: CHUNK
        logical                                 :: ComputeBoxTimeSerie, PropertyComputeBoxTimeSerie, &
                                                   OptimizeFlag, FirstWaterProperty
        !----------------------------------------------------------------------

        if (MonitorPerformance)                                         &
              call StartWatch ("ModuleWaterProperties", "Advection_Diffusion_Processes")

        ILB = Me%Size%ILB;  JLB = Me%Size%JLB;  KLB = Me%Size%KLB
        IUB = Me%Size%IUB;  JUB = Me%Size%JUB;  KUB = Me%Size%KUB

        Property => Me%FirstProperty

        Actual = Me%ExternalVar%Now

        if (Me%ExternalVar%Now .GE. Me%Coupled%BoxTimeSerie%NextCompute) then
            ComputeBoxTimeSerie = .true.
        else
            ComputeBoxTimeSerie = .false.
        endif

        call GetHorizontalViscosity(Me%ObjTurbulence, Me%ExternalVar%Visc_H, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
           call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR10')

        call GetVerticalDiffusivity(Me%ObjTurbulence, VerticalDiffusivityCenter = Me%ExternalVar%Diff_V, &
                                    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR20')

        if(Me%Coupled%Bivalve%Yes)then

            call GetGeometryVolumes(Me%ObjGeometry,                                     &
                                    VolumeZOld     = Me%ExternalVar%VolumeZOld,         &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR21')

            !Convert concentrations in /m2 to /m3; buil matrix saying where larvae exist;
            !compute total values (* number of individuals) to use in the advection diffusion
            call PrepareLarvaeAdvectionDiffusion

            call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%VolumeZOld, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR22')

        endif
        !check is schmidt is equal for all property
        firstSchmidt = Property%evolution%Advec_Difus_Parameters%SchmidtNumberH
        OptimizeFlag = .true.
        do while (associated(Property))
            if (Property%Evolution%AdvectionDiffusion) then
                if (Property%evolution%Advec_Difus_Parameters%SchmidtNumberH /= firstSchmidt) OptimizeFlag = .false.
                if (Property%evolution%NoDifFluxCells)                                        OptimizeFlag = .false.
                if (Property%evolution%NoAdvFluxCells)                                        OptimizeFlag = .false.
                if (Property%evolution%Advec_Difus_Parameters%NullDif)                        OptimizeFlag = .false.
                if (Property%evolution%Advec_Difus_Parameters%AdvMethodH /= P2_TVD)           OptimizeFlag = .false.
                if (Property%evolution%Advec_Difus_Parameters%AdvMethodV /= P2_TVD)           OptimizeFlag = .false.
                if (Property%evolution%Advec_Difus_Parameters%TVDLimitationH /= SuperBee)     OptimizeFlag = .false.
                if (Property%evolution%Advec_Difus_Parameters%TVDLimitationV /= SuperBee)     OptimizeFlag = .false.
                if (Property%evolution%Advec_Difus_Parameters%AdvectionNudging)               OptimizeFlag = .false.
            endif

            Property => Property%Next
        enddo
        if (Me%Coupled%AdvectionDiffusion%NumberOfProperties < 2) OptimizeFlag = .false.

        FirstWaterProperty = .true.
        Property => Me%FirstProperty

do1 :   do while (associated(Property))
cd1 :       if (Property%Evolution%AdvectionDiffusion) then
cd2 :           if (Actual.GE.Property%Evolution%NextCompute) then

                    !Get Fluxes And Mapping from integration
                    if (Property%evolution%HydroIntegration) then

                        !WaterFluxes
                        call GetHydroIntegrationWaterFluxes(Me%ObjHydroIntegration,         &
                                                            Property%evolution%DTInterval,  &
                                                            Me%WorkSize,                    &
                                                            Me%ExternalVar%WaterFluxX,      &
                                                            Me%ExternalVar%WaterFluxY,      &
                                                            Me%ExternalVar%WaterFluxZ,      &
                                                            STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                          &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR30')

                        !Mapping
                        call GetHydroIntegrationComputeFaces(Me%ObjHydroIntegration,        &
                                                             Property%Evolution%DTInterval, &
                                                             Me%WorkSize,                   &
                                                             Me%ExternalVar%ComputeFacesU3D,&
                                                             Me%ExternalVar%ComputeFacesV3D,&
                                                             Me%ExternalVar%ComputeFacesW3D,&
                                                             OpenPoints3D,                  &
                                                             STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                        &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR40')

                        !Initial Volume
                        call GetHydroIntegrationVolumeZOld(Me%ObjHydroIntegration,          &
                                                           Property%evolution%DTInterval,   &
                                                           Me%WorkSize,                     &
                                                           Me%ExternalVar%VolumeZOld,       &
                                                           STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                       &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR50')
                    else

                        !WaterFluxes
                        call GetWaterFluxes(Me%ObjHydrodynamic,                            &
                                            WaterFluxX = Me%ExternalVar%WaterFluxX,        &
                                            WaterFluxY = Me%ExternalVar%WaterFluxY,        &
                                            WaterFluxZ = Me%ExternalVar%WaterFluxZ,        &
                                            STAT       = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                       &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR60')


                        !ComputeFaces3D
                        call GetComputeFaces3D(Me%ObjMap,                                           &
                                               ComputeFacesU3D = Me%ExternalVar%ComputeFacesU3D,    &
                                               ComputeFacesV3D = Me%ExternalVar%ComputeFacesV3D,    &
                                               ComputeFacesW3D = Me%ExternalVar%ComputeFacesW3D,    &
                                               STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                                &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR70')

                        call GetGeometryVolumes(Me%ObjGeometry,                                     &
                                                VolumeZOld     = Me%ExternalVar%VolumeZOld,         &
                                                STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                       &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR80')


                        OpenPoints3D => Me%ExternalVar%OpenPoints3D

                    endif


cd7:                if (Property%evolution%Advec_Difus_Parameters%AdvectionH_imp_exp == ImplicitScheme) then

cd10:                       if (Property%evolution%Advec_Difus_Parameters%ImplicitH_Direction &
                                == DirectionX) then !Direction X implicit

                                ImpExp_AdvXX = ImplicitScheme

                                ImpExp_AdvYY = ExplicitScheme

                                Property%evolution%Advec_Difus_Parameters%ImplicitH_Direction = DirectionY

                            else cd10 !Direction Y implicit

                                ImpExp_AdvXX = ExplicitScheme

                                ImpExp_AdvYY = ImplicitScheme

                                Property%evolution%Advec_Difus_Parameters%ImplicitH_Direction = DirectionX

                            endif cd10

                    else cd7 ! Horizontal Advection Explicit

                        ImpExp_AdvXX = ExplicitScheme

                        ImpExp_AdvYY = ExplicitScheme

                    endif cd7

                    if (Property%SubModel%ON) then
                        if (.not. Property%SubModel%Set) then
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR90')
                        endif
                    endif

                    if  (Me%FreeConvection) call FreeConvection(Property, Me%ExternalVar%VolumeZ, OpenPoints3D)

                    call SmallDepthsMixing_Processes(Property, Me%ExternalVar%VolumeZ, OpenPoints3D)

                    if (Property%WarnOnNegativeValues)then
                        call CheckIfConcentrationIsNegative(Property, 'before advection-diffusion')
                    endif

                    if (Property%AddOffSet)then

                        if (Property%Evolution%Discharges) then
                            Property%DischConc(:) = Property%DischConc(:) + Property%OffSet
                        endif

                        do K = Me%WorkSize%KLB, Me%WorkSize%KUB
                        do J = Me%WorkSize%JLB, Me%WorkSize%JUB
                        do I = Me%WorkSize%ILB, Me%WorkSize%IUB

                            if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                                Property%Concentration(i,j,k)      = Property%Concentration(i,j,k)      + &
                                                                     Property%OffSet
                            endif

                        enddo
                        enddo
                        enddo

                        if (associated(Property%Assimilation%Field)) then

                            do K = Me%WorkSize%KLB, Me%WorkSize%KUB
                            do J = Me%WorkSize%JLB, Me%WorkSize%JUB
                            do I = Me%WorkSize%ILB, Me%WorkSize%IUB

                                if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                                    Property%Assimilation%Field(i,j,k) = Property%Assimilation%Field(i,j,k) + &
                                                                         Property%OffSet
                                endif

                            enddo
                            enddo
                            enddo

                        endif
                    endif

                    if (Property%Evolution%Discharges)then

                        call SetDischarges (Me%ObjAdvectionDiffusion, Me%Discharge%Flow,    &
                                                Property%DischConc,   Me%Discharge%i,       &
                                                Me%Discharge%j,       Me%Discharge%k,       &
                                                Me%Discharge%kmin,    Me%Discharge%kmax,    &
                                                Me%Discharge%Vert,    Me%Discharge%Number,  &
                                                Me%Discharge%Ignore,  Me%Discharge%nCells,  &
                                                Me%Discharge%ByPass,  STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                            &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR100')
                    endif

                    if (Property%BoxTimeSerie .and. ComputeBoxTimeSerie) then
                            PropertyComputeBoxTimeSerie = .true.
                    else
                            PropertyComputeBoxTimeSerie = .false.
                    endif

                    call AdvectionDiffusion(Me%ObjAdvectionDiffusion,                       &
                            Property%Concentration,                                         &
                            Property%evolution%Advec_Difus_Parameters%SchmidtNumberH,       &
                            Property%evolution%Advec_Difus_Parameters%SchmidtCoefV,         &
                            Property%evolution%Advec_Difus_Parameters%SchmidtBackgroundV,   &
                            Property%evolution%Advec_Difus_Parameters%AdvMethodH,           &
                            Property%evolution%Advec_Difus_Parameters%TVDLimitationH,       &
                            Property%evolution%Advec_Difus_Parameters%AdvMethodV,           &
                            Property%evolution%Advec_Difus_Parameters%TVDLimitationV,       &
                            Property%evolution%Advec_Difus_Parameters%Upwind2H,             &
                            Property%evolution%Advec_Difus_Parameters%Upwind2V,             &
                            Property%evolution%Advec_Difus_Parameters%VolumeRelMax,         &
                            Property%evolution%Advec_Difus_Parameters%AdvectionNudging,     &
                            Property%evolution%Advec_Difus_Parameters%AdvectionNudgingCells, &
                            Property%evolution%DTInterval,                                  &
                            Property%evolution%Advec_Difus_Parameters%AdvectionV_imp_exp,   &
                            Property%evolution%Advec_Difus_Parameters%DiffusionV_imp_exp,   &
                            ImpExp_AdvXX, ImpExp_AdvYY,                                     &
                            Property%evolution%Advec_Difus_Parameters%DiffusionH_imp_exp,   &
                            Property%evolution%Advec_Difus_Parameters%NullDif,              &
                            Me%ExternalVar%WaterFluxX,                                      &
                            Me%ExternalVar%WaterFluxY,                                      &
                            Me%ExternalVar%WaterFluxZ,                                      &
                            Me%ExternalVar%VolumeZOld, Me%ExternalVar%VolumeZ,              &
                            OpenPoints3D,                                                   &
                            Me%ExternalVar%LandPoints3D,                                    &
                            Me%ExternalVar%ComputeFacesU3D,                                 &
                            Me%ExternalVar%ComputeFacesV3D,                                 &
                            Me%ExternalVar%ComputeFacesW3D,                                 &
                            Me%ExternalVar%Visc_H,                                          &
                            Me%ExternalVar%Diff_V,                                          &
                            CellFluxes        = PropertyComputeBoxTimeSerie,               &
                            WaterPoints3D     = Me%ExternalVar%WaterPoints3D,              &
                            ReferenceProp     = Property%Assimilation%Field,                &
                            BoundaryCondition = Property%evolution%Advec_Difus_Parameters%BoundaryCondition, &
                            DecayTime         = Property%evolution%Advec_Difus_Parameters%DecayTime,         &
                            NumericStability  = Property%evolution%Advec_Difus_Parameters%NumericStability,  &
                            PropOld           = Property%evolution%Advec_Difus_Parameters%PropOld,           &
                            SmallDepths       = Me%SmallDepths%ON,                          &
                            NoAdvFlux         = Property%evolution%NoAdvFluxCells,          &
                            NoDifFlux         = Property%evolution%NoDifFluxCells,          &
                            NoFluxU           = Me%NoFlux%U,                                &
                            NoFluxV           = Me%NoFlux%V,                                &
                            NoFluxW           = Me%NoFlux%W,                                &
                            Optimize          = OptimizeFlag,                               &
                            FirstProperty     = FirstWaterProperty,                         &
                            STAT              = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                            &
                        call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR110')

                    FirstWaterProperty = .false.

                    if (Property%Evolution%Discharges)then

                        call UnSetDischarges (Me%ObjAdvectionDiffusion, STAT = STAT_CALL)

                        if (STAT_CALL .NE. SUCCESS_)                                            &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR120')

                    endif

                    if (Property%AddOffSet)then

                        if (Property%Evolution%Discharges) then
                            Property%DischConc(:) = Property%DischConc(:) - Property%OffSet
                        endif


                        do K = Me%WorkSize%KLB, Me%WorkSize%KUB
                        do J = Me%WorkSize%JLB, Me%WorkSize%JUB
                        do I = Me%WorkSize%ILB, Me%WorkSize%IUB

                            if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                                Property%Concentration(i,j,k)      = Property%Concentration(i,j,k)      - &
                                                                     Property%OffSet
                            endif

                        enddo
                        enddo
                        enddo

                        if (associated(Property%Assimilation%Field)) then

                            do K = Me%WorkSize%KLB, Me%WorkSize%KUB
                            do J = Me%WorkSize%JLB, Me%WorkSize%JUB
                            do I = Me%WorkSize%ILB, Me%WorkSize%IUB

                                if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                                    Property%Assimilation%Field(i,j,k) = Property%Assimilation%Field(i,j,k) - &
                                                                         Property%OffSet
                                endif

                            enddo
                            enddo
                            enddo

                        endif

                    endif


                    if (Property%WarnOnNegativeValues)then

                        call CheckIfConcentrationIsNegative(Property, 'after advection-diffusion')

                    endif

                    !UnGet Fluxes And MObjing from integration
                    if (Property%evolution%HydroIntegration) then

                        !WaterFluxes
                        call UnGetHydroIntegration(Me%ObjHydroIntegration, Me%ExternalVar%WaterFluxX, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR130')

                        call UnGetHydroIntegration(Me%ObjHydroIntegration, Me%ExternalVar%WaterFluxY, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR140')

                        call UnGetHydroIntegration(Me%ObjHydroIntegration, Me%ExternalVar%WaterFluxZ, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR150')

                        !Mapping
                        call UnGetHydroIntegration(Me%ObjHydroIntegration,              &
                                                   Me%ExternalVar%ComputeFacesU3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR160')

                        call UnGetHydroIntegration(Me%ObjHydroIntegration,              &
                                                   Me%ExternalVar%ComputeFacesV3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR170')


                        call UnGetHydroIntegration(Me%ObjHydroIntegration,              &
                                                   Me%ExternalVar%ComputeFacesW3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR180')

                        call UnGetHydroIntegration(Me%ObjHydroIntegration, OpenPoints3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR190')

                        call UnGetHydroIntegration(Me%ObjHydroIntegration, Me%ExternalVar%VolumeZOld, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR200')

                    else

                        call UngetHydrodynamic(Me%ObjHydrodynamic, Me%ExternalVar%WaterFluxX, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR210')

                        call UngetHydrodynamic(Me%ObjHydrodynamic, Me%ExternalVar%WaterFluxY, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR220')

                        call UngetHydrodynamic(Me%ObjHydrodynamic, Me%ExternalVar%WaterFluxZ, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR230')

                        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesU3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR240')

                        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesV3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR250')

                        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesW3D, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR260')

                        call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%VolumeZOld, STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                    &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR270')

                    endif

cd6 :               if (PropertyComputeBoxTimeSerie) then

                            !Gets Advective Flux
                            call GetAdvFlux(Me%ObjAdvectionDiffusion, AdvFluxX, AdvFluxY, AdvFluxZ, STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                                    &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR280')

                            !Gets Diffusive Flux
                            call GetDifFlux (Me%ObjAdvectionDiffusion, DifFluxX, DifFluxY, DifFluxZ, STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                                    &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR290')

                            !CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB) Sobrinho
                            CHUNK = CHUNK_K(Me%WorkSize%KLB, Me%WorkSize%KUB)
                            !$OMP PARALLEL PRIVATE(I,J,K)
                            !$OMP DO SCHEDULE(STATIC, CHUNK)
                            do2 : do K = Me%WorkSize%KLB, Me%WorkSize%KUB
                            do3 : do J = Me%WorkSize%JLB, Me%WorkSize%JUB
                            do4 : do I = Me%WorkSize%ILB, Me%WorkSize%IUB
                                Me%MassFluxesX (I,J,K) = AdvFluxX(I,J,K) + DifFluxX (I,J,K)
                                Me%MassFluxesY (I,J,K) = AdvFluxY(I,J,K) + DifFluxY (I,J,K)
                            end do do4
                            end do do3
                            end do do2
                            !$OMP END DO
                            !$OMP END PARALLEL
                            !Sobrinho
                            if (Me%WorkSize%KUB > Me%WorkSize%KLB) then
                                !$OMP PARALLEL PRIVATE(I,J,K)
                                !$OMP DO SCHEDULE(STATIC, CHUNK)
                                do5 : do K = Me%WorkSize%KLB, Me%WorkSize%KUB
                                do6 : do J = Me%WorkSize%JLB, Me%WorkSize%JUB
                                do7 : do I = Me%WorkSize%ILB, Me%WorkSize%IUB
                                    Me%MassFluxesZ (I,J,K) = AdvFluxZ(I,J,K) + DifFluxZ (I,J,K)
                                end do do7
                                end do do6
                                end do do5
                                !$OMP END DO
                                !$OMP END PARALLEL
                            endif

                            !Integration of fluxes
                            call BoxDif(Me%ObjBoxDif,                        &
                                        Me%MassFluxesX,                      &
                                        Me%MassFluxesY,                      &
                                        Me%MassFluxesZ,                      &
                                        trim(Property%ID%Name),              &
                                        Me%ExternalVar%OpenPoints3D,        &
                                        STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                            call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR300')

                            call UngetAdvectionDiffusion(Me%ObjAdvectionDiffusion, AdvFluxX, STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR310')

                            call UngetAdvectionDiffusion(Me%ObjAdvectionDiffusion, AdvFluxY, STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR320')

                            call UngetAdvectionDiffusion(Me%ObjAdvectionDiffusion, AdvFluxZ, STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR330')

                            call UngetAdvectionDiffusion(Me%ObjAdvectionDiffusion, DifFluxX, STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR340')

                            call UngetAdvectionDiffusion(Me%ObjAdvectionDiffusion, DifFluxY,  STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR350')

                            call UngetAdvectionDiffusion(Me%ObjAdvectionDiffusion, DifFluxZ,  STAT = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                     &
                                call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR360')

                    end if cd6

#if _USE_MPI
                    !MPI and Domain Decomposition is ON exchanges data along domain interfaces
                    !call ReceiveSendProperities3DMPI(Property%Concentration)
                    call ReceiveSendProperitiesMPI(HorizontalGridID = Me%ObjHorizontalGrid,     &
                                                   Property3D       = Property%Concentration,   &
                                                   KLB              = Me%WorkSize%KLB,          &
                                                   KUB              = Me%WorkSize%KUB,          &
                                                   STAT             = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR370')
                    endif
#endif _USE_MPI
                end if cd2

            end if cd1

            Property => Property%Next

        end do do1

        if(Me%Coupled%Bivalve%Yes)then
        !be aware that the box fluxes of bivalve processes are not well computed
        !because they were transported as Property * Number

            !Restore concentrations to /m2; update concentration in the cells where larvae exist
            call RestoreLarvaeAdvectionDiffusion

        endif



        nullify(Property    )
        nullify(OpenPoints3D)

        call UnGetTurbulence(Me%ObjTurbulence, Me%ExternalVar%Visc_H, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR380')

        call UnGetTurbulence(Me%ObjTurbulence, Me%ExternalVar%Diff_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Advection_Diffusion_Processes - ModuleWaterProperties - ERR390')

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Advection_Diffusion_Processes")

        !----------------------------------------------------------------------

    end subroutine Advection_Diffusion_Processes

    !----------------------------------------------------------------------

    subroutine PrepareLarvaeAdvectionDiffusion

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                            :: i, j, k
        type (T_Species) , pointer         :: Species
        type (T_Cohort)  , pointer         :: Cohort
        type (T_Property), pointer         :: Property_N, Property_L,Property_MH
        type (T_Property), pointer         :: Property_MV, Property_ME, Property_MR
        character(len=StringLength)        :: PropertyName_N, PropertyName_L, PropertyName_MH
        character(len=StringLength)        :: PropertyName_MV, PropertyName_ME, PropertyName_MR
        integer                            :: STAT_CALL
        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "PrepareLarvaeAdvectionDiffusion")

        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

            if (Species%LarvaeTransport) then

                Cohort  => Species%FirstCohort
                do while (associated(Cohort))

                    if(Cohort%AtLeastOneLarvae)then

                        !number
                        PropertyName_N = trim(adjustl(Cohort%ID%Name))//" number"

                        call Search_Property(Property_N                                                    , &
                                             PropertyXID = GetDynamicPropertyIDNumber(trim(PropertyName_N)), &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('PrepareLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR10')

                        !length
                        PropertyName_L = trim(adjustl(Cohort%ID%Name))//" length"

                        call Search_Property(Property_L                                                    , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_L)      , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('PrepareLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR20')

                        !reserves
                        PropertyName_ME = trim(adjustl(Cohort%ID%Name))//" reserves"

                        call Search_Property(Property_ME                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_ME)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('PrepareLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR30')

                        !structure
                        PropertyName_MV = trim(adjustl(Cohort%ID%Name))//" structure"

                        call Search_Property(Property_MV                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MV)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('PrepareLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR40')

                        !maturity
                        PropertyName_MH = trim(adjustl(Cohort%ID%Name))//" maturity"

                        call Search_Property(Property_MH                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MH)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('PrepareLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR50')

                        !reproduction
                        PropertyName_MR = trim(adjustl(Cohort%ID%Name))//" reproduction"

                        call Search_Property(Property_MR                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MR)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('PrepareLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR60')

                        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                            if(Me%ExternalVar%WaterPoints3D(i, j, k) == 1)then

                                !store cohort properties in the matrix before advection diffusion, /ind
                                Cohort%AuxLarvaeL( i,j,k) = Property_L%Concentration(i,j,k)
                                Cohort%AuxLarvaeME(i,j,k) = Property_ME%Concentration(i,j,k)
                                Cohort%AuxLarvaeMV(i,j,k) = Property_MV%Concentration(i,j,k)
                                Cohort%AuxLarvaeMH(i,j,k) = Property_MH%Concentration(i,j,k)
                                Cohort%AuxLarvaeMR(i,j,k) = Property_MR%Concentration(i,j,k)

                                !store number of individuals if not larvae, #/m2
                                Cohort%AuxLarvaeN (i,j,k) = Property_N%Concentration(i,j,k) * (1.0 - Cohort%Larvae (i,j,k))

                            endif

                        end do
                        end do
                        end do

                        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                            if(Me%ExternalVar%WaterPoints3D(i, j, k) == 1)then

                                !CHANGE PROPERTY UNITS to total cell biomass/m3, to be transported by advection diffusion
                                !the molC/ind * ind/m2 * m2/m3 = molC/m3
                                !By applying - * Cohort%Larvae (i,j,k) - cells with no larvae will have concentration 0.0

                                !number, #/m3 = #/m2 * m2/m3
                                Property_N%Concentration (i,j,k) = Property_N%Concentration(i,j,k)     * &
                                                                   Me%ExternalVar%GridCellArea(i, j)   / &
                                                                   Me%ExternalVar%VolumeZOld (i, j, k) * &
                                                                   Cohort%Larvae (i,j,k)
                                !length, cm/m3 = cm/# * #/m3
                                Property_L%Concentration (i,j,k) = Property_L%Concentration (i,j,k)    * &
                                                                   Property_N%Concentration(i,j,k)     * &
                                                                   Cohort%Larvae (i,j,k)
                                !reserves, molC/m3 = molC/# * #/m3
                                Property_ME%Concentration(i,j,k) = Property_ME%Concentration(i,j,k)    * &
                                                                   Property_N%Concentration(i,j,k)     * &
                                                                   Cohort%Larvae (i,j,k)
                                !structure, molC/m3 = molC/# * #/m3
                                Property_MV%Concentration(i,j,k) = Property_MV%Concentration(i,j,k)    * &
                                                                   Property_N%Concentration(i,j,k)     * &
                                                                   Cohort%Larvae (i,j,k)
                                !maturity, molC/m3 = molC/# * #/m3
                                Property_MH%Concentration(i,j,k) = Property_MH%Concentration(i,j,k)    * &
                                                                   Property_N%Concentration(i,j,k)     * &
                                                                   Cohort%Larvae (i,j,k)
                                !reproduction, molC/m3 = molC/# * #/m3
                                Property_MR%Concentration(i,j,k) = Property_MR%Concentration(i,j,k)    * &
                                                                   Property_N%Concentration(i,j,k)     * &
                                                                   Cohort%Larvae (i,j,k)

                            endif

                        end do
                        end do
                        end do

                    endif

                    Cohort  => Cohort%Next

                enddo

            end if ! if not larvae transport, dont change concentrations
            Species  => Species%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "PrepareLarvaeAdvectionDiffusion")

    end subroutine PrepareLarvaeAdvectionDiffusion

    !----------------------------------------------------------------------

    subroutine RestoreLarvaeAdvectionDiffusion

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                            :: i, j, k
        type (T_Species) , pointer         :: Species
        type (T_Cohort)  , pointer         :: Cohort
        type (T_Property), pointer         :: Property_N, Property_L, Property_MH
        type (T_Property), pointer         :: Property_MV, Property_ME, Property_MR
        character(len=StringLength)        :: PropertyName_N, PropertyName_L, PropertyName_MH
        character(len=StringLength)        :: PropertyName_MV, PropertyName_ME, PropertyName_MR
        integer                            :: STAT_CALL
        real                               :: NewTotalN

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "RestoreLarvaeAdvectionDiffusion")

        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

            if (Species%LarvaeTransport) then

                Cohort  => Species%FirstCohort
                do while (associated(Cohort))

                    if(Cohort%AtLeastOneLarvae)then

                        !number
                        PropertyName_N = trim(adjustl(Cohort%ID%Name))//" number"

                        call Search_Property(Property_N                                                    , &
                                             PropertyXID = GetDynamicPropertyIDNumber(trim(PropertyName_N)), &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('RestoreLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR10')

                        !length
                        PropertyName_L = trim(adjustl(Cohort%ID%Name))//" length"

                        call Search_Property(Property_L                                                    , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_L)      , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('RestoreLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR20')

                        !reserves
                        PropertyName_ME = trim(adjustl(Cohort%ID%Name))//" reserves"

                        call Search_Property(Property_ME                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_ME)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('RestoreLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR30')

                        !structure
                        PropertyName_MV = trim(adjustl(Cohort%ID%Name))//" structure"

                        call Search_Property(Property_MV                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MV)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('RestoreLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR10')

                        !maturity
                        PropertyName_MH = trim(adjustl(Cohort%ID%Name))//" maturity"

                        call Search_Property(Property_MH                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MH)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('RestoreLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR40')

                        !reproduction
                        PropertyName_MR = trim(adjustl(Cohort%ID%Name))//" reproduction"

                        call Search_Property(Property_MR                                                   , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MR)     , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('RestoreLarvaeAdvectionDiffusion - ModuleWaterProperties - ERR50')

                        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                            if(Me%ExternalVar%WaterPoints3D(i, j, k) == 1)then

                                !Total number of individuals in the cell, #/m3
                                NewTotalN = Property_N%Concentration(i,j,k)     + & !new larvae values from advection diffusion
                                            Cohort%AuxLarvaeN(i,j,k)            * & !non larvae values stored before adv diff
                                            Me%ExternalVar%GridCellArea(i, j)   / &
                                            Me%ExternalVar%VolumeZ (i, j, k)

                                if(NewTotalN > 0.0)then

                                    !Average properties based on number/m3 and RESTORE UNITS to biomass/ind and #/m2

                                    !molC/ind = [molC/m3 (from larvae) + molC/# * #/m2 * m2/m3] (from non larvae) / #/m3
                                    Property_ME%Concentration(i,j,k) = ( Property_ME%Concentration(i,j,k)                      + &
                                                                        (Cohort%AuxLarvaeME(i,j,k) * Cohort%AuxLarvaeN(i,j,k)  * &
                                                                        Me%ExternalVar%GridCellArea(i, j)                      / &
                                                                        Me%ExternalVar%VolumeZ (i, j, k)) )                    / &
                                                                        NewTotalN

                                    !molC/ind = [molC/m3 (from larvae) + molC/# * #/m2 * m2/m3] (from non larvae) / #/m3
                                    Property_MV%Concentration(i,j,k) = ( Property_MV%Concentration(i,j,k)                      + &
                                                                        (Cohort%AuxLarvaeMV(i,j,k) * Cohort%AuxLarvaeN(i,j,k)  * &
                                                                        Me%ExternalVar%GridCellArea(i, j)                      / &
                                                                        Me%ExternalVar%VolumeZ (i, j, k)) )                    / &
                                                                        NewTotalN

                                    !molC/ind = [molC/m3 (from larvae) + molC/# * #/m2 * m2/m3] (from non larvae) / #/m3
                                    Property_MH%Concentration(i,j,k) = ( Property_MH%Concentration(i,j,k)                      + &
                                                                        (Cohort%AuxLarvaeMH(i,j,k) * Cohort%AuxLarvaeN(i,j,k)  * &
                                                                        Me%ExternalVar%GridCellArea(i, j)                      / &
                                                                        Me%ExternalVar%VolumeZ (i, j, k)) )                    / &
                                                                        NewTotalN

                                    !molC/ind = [molC/m3 (from larvae) + molC/# * #/m2 * m2/m3] (from non larvae) / #/m3
                                    Property_MR%Concentration(i,j,k) = ( Property_MR%Concentration(i,j,k)                      + &
                                                                        (Cohort%AuxLarvaeMR(i,j,k) * Cohort%AuxLarvaeN(i,j,k)  * &
                                                                        Me%ExternalVar%GridCellArea(i, j)                      / &
                                                                        Me%ExternalVar%VolumeZ (i, j, k)) )                    / &
                                                                        NewTotalN

                                    !molC/ind = [molC/m3 (from larvae) + molC/# * #/m2 * m2/m3] (from non larvae) / #/m3
                                    Property_L%Concentration(i,j,k)  = ( Property_L%Concentration(i,j,k)                      + &
                                                                        (Cohort%AuxLarvaeL(i,j,k) * Cohort%AuxLarvaeN(i,j,k)  * &
                                                                        Me%ExternalVar%GridCellArea(i, j)                     / &
                                                                        Me%ExternalVar%VolumeZ (i, j, k)) )                   / &
                                                                        NewTotalN

                                    !RESTORE UNITS, #/m2 = #/m3 * m3/m2
                                    Property_N%Concentration(i,j,k) = NewTotalN                            * &
                                                                      Me%ExternalVar%VolumeZ (i, j, k)     / &
                                                                      Me%ExternalVar%GridCellArea(i, j)

                                else

                                    Property_N%Concentration(i,j,k)  = 0.0
                                    Property_MV%Concentration(i,j,k) = 0.0
                                    Property_MH%Concentration(i,j,k) = 0.0
                                    Property_MR%Concentration(i,j,k) = 0.0
                                    Property_ME%Concentration(i,j,k) = 0.0
                                    Property_L%Concentration (i,j,k) = 0.0

                                endif
                            endif

                        end do
                        end do
                        end do

                    endif

                    Cohort  => Cohort%Next

                enddo

            end if !if (Species%LarvaeTransport)

            Species  => Species%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "RestoreLarvaeAdvectionDiffusion")

    end subroutine RestoreLarvaeAdvectionDiffusion

    !----------------------------------------------------------------------

    subroutine CheckIfConcentrationIsNegative(Property, Message)

        !Arguments-------------------------------------------------------------
        type (T_Property), pointer          :: Property
        character(len=*)                    :: Message

        !External--------------------------------------------------------------
        character (len = StringLength)      :: StrWarning

        !Local-----------------------------------------------------------------
        integer                             :: i, j, k
        character(len=5)                    :: char_i, char_j, char_k
        !$ integer                          :: CHUNK

        !Begin-----------------------------------------------------------------

        !$ CHUNK = CHUNK_K(Me%Size%KLB,Me%Size%KUB)
        !$OMP PARALLEL PRIVATE(k,j,i,char_i,char_j,char_k)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB
            if(Me%ExternalVar%WaterPoints3D(i, j, k) == 1)then
                if (Property%Concentration (i,j,k) .lt. 0.0) then
                    write(char_i, '(i4)')i
                    write(char_j, '(i4)')j
                    write(char_k, '(i4)')k
                    StrWarning = trim(Property%ID%Name)//' has a negative concentration in cell(i,j,k)'// &
                                                       char_i//','//char_j//','//char_k//' '//Message
                    call SetError(WARNING_, INTERNAL_, StrWarning, ON)
                end if
            end if
        end do
        end do
        end do
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine CheckIfConcentrationIsNegative

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing the
    ! Instantaneously Mixing and the dilution (or concentration) by volume variation

    subroutine InstantaneouslyMixing

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL

        !Local-----------------------------------------------------------------

        real(8), dimension(:,:,:), pointer :: VolumeZ, VolumeZOld
        integer, dimension(:,:,:), pointer :: WaterPoints3D
        type (T_Property), pointer         :: Property
        type (T_Time)                      :: Actual
        real(8)                            :: TotalMass, TotalVolume, AverageConc
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                            :: i, j, k
        integer                            :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB


        call GetGeometryVolumes(Me%ObjGeometry,                                 &
                                VolumeZOld = Me%ExternalVar%VolumeZOld,         &
                                STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                              &
            call CloseAllAndStop ('InstantaneouslyMixing; ModuleWaterProperties. ERR01')

        VolumeZ         => Me%ExternalVar%VolumeZ
        VolumeZOld      => Me%ExternalVar%VolumeZOld
        WaterPoints3D   => Me%ExternalVar%WaterPoints3D

        Property => Me%FirstProperty

        Actual = Me%ExternalVar%Now

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "InstantaneouslyMixing")

        CHUNK = CHUNK_J(JLB, JUB)

do1 :   do while (associated(Property))
cd1 :       if (Property%Evolution%InstantMixing) then
cd2 :           if (Actual.GE.Property%Evolution%NextCompute) then
                    TotalMass   = 0.
                    TotalVolume = 0.

                    !$OMP PARALLEL PRIVATE(i,j,k)

                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK) REDUCTION(+:TotalMass,TotalVolume)
                    !ACanas (2010): REDUCTION of real type variables may cause rounding errors
                    !ACanas (2010): relative to no OpenMP parallelized code!
                    do j = JLB, JUB
                    do i = ILB, IUB

cd3:                    if (WaterPoints3D(i, j, k) == WaterPoint) then
                            !Total Old Mass
                            TotalMass   = TotalMass + Property%Concentration(i, j, k) *  &
                                                      VolumeZOld(i, j, k)
                            !Total New Volume
                            TotalVolume = TotalVolume + VolumeZ(i, j, k)
                        endif cd3
                    enddo
                    enddo
                    !$OMP END DO
                    enddo

cd5:                if (TotalVolume > 0.) then
                        !$OMP MASTER
                        AverageConc = TotalMass / TotalVolume
                        !$OMP END MASTER

                        do k = KLB, KUB
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = JLB, JUB
                        do i = ILB, IUB

                           if (WaterPoints3D(i, j, k) == WaterPoint)                     &
                                Property%Concentration(i, j, k) = AverageConc

                        enddo
                        enddo
                        !$OMP END DO
                        enddo

                    endif cd5

                    !$OMP END PARALLEL

                endif cd2
            endif cd1

            Property => Property%Next

        end do do1

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "InstantaneouslyMixing")

        call UnGetGeometry (Me%ObjGeometry, Me%ExternalVar%VolumeZOld, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                       &
            call CloseAllAndStop ('InstantaneouslyMixing; ModuleWaterProperties. ERR02')

        nullify(Property, VolumeZ, VolumeZOld, WaterPoints3D)


    end subroutine InstantaneouslyMixing

    !--------------------------------------------------------------------------

    subroutine ModifyPropertiesFromFile

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "ModifyPropertiesFromFile")

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if (PropertyX%ID%SolutionFromFile) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                    call ModifyFillMatrix (FillMatrixID   = PropertyX%ID%ObjFillMatrix,         &
                                           Matrix3D       = PropertyX%Concentration,            &
                                           PointsToFill3D = Me%ExternalVar%WaterPoints3D,       &
                                           STAT           = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('ModifyPropertiesFromFile - ModuleWaterProperties - ERR01')

                end if

            end if

            PropertyX => PropertyX%Next
        end do


        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "ModifyPropertiesFromFile")


    end subroutine ModifyPropertiesFromFile


    !--------------------------------------------------------------------------
    !   Makes the connection between the Water
    !   Properties module and the water quality
    !   model
    !--------------------------------------------------------------------------
    subroutine WaterQuality_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX
        type (T_WqRate),        pointer         :: WqRateX
        real, dimension(:,:,:), pointer         :: ShortWaveExtinctionField
        real, dimension(:,:,:), pointer         :: ShortWaveTop

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "WaterQuality_Processes")

        ShortWaveTop => Me%SolarRadiation%ShortWaveTop

        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterQuality_Processes - ModuleWaterProperties - ERR01')

        PropertyX => Me%FirstProperty

        if (Me%ExternalVar%Now .GE. Me%Coupled%WQM%NextCompute) then

            do while(associated(PropertyX))

                PropertyX%Evolution%SetLimitsTrigger = .true.

                call Modify_Interface(InterfaceID       = Me%ObjInterface,              &
                                      PropertyID        = PropertyX%ID%IDNumber,        &
                                      Concentration     = PropertyX%Concentration,      &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D, &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,  &
                                      ShortWaveTop= ShortWaveTop,           &
                                      LightExtCoefField = ShortWaveExtinctionField,     &
                                      DWZ               = Me%ExternalVar%DWZ,           &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('WaterQuality_Processes - ModuleWaterProperties - ERR02')

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%WQM%NextCompute = Me%Coupled%WQM%NextCompute + Me%Coupled%WQM%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%WaterQuality) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                   PropertyX%Evolution%SetLimitsTrigger = .true.

                   call Modify_Interface(InterfaceID   = Me%ObjInterface,               &
                                         PropertyID    = PropertyX%ID%IDNumber,         &
                                         Concentration = PropertyX%Concentration,       &
                                         DTProp        = PropertyX%Evolution%DTInterval,&
                                         WaterPoints3D = Me%ExternalVar%WaterPoints3D,  &
                                         OpenPoints3D  = Me%ExternalVar%OpenPoints3D,   &
                                         STAT           = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                        &
                        call CloseAllAndStop ('WaterQuality_Processes - ModuleWaterProperties - ERR03')
                endif

            endif

            PropertyX=>PropertyX%Next

        enddo

        nullify(PropertyX)

        !Get rate fluxes, integrate them and write box time series
        WqRateX => Me%FirstWqRate

        do while (associated(WqRateX))

            if(WqRateX%Model == WaterQualityModel)then

                call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
                                 FirstProp      = WqRateX%FirstProp%IDNumber,               &
                                 SecondProp     = WqRateX%SecondProp%IDNumber,              &
                                 RateFlux3D     = WqRateX%Field,                            &
                                 WaterPoints3D  = Me%ExternalVar%OpenPoints3D,             &
                                 STAT           = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('WaterQuality_Processes - ModuleWaterProperties - ERR04')

                where (Me%ExternalVar%OpenPoints3D == WaterPoint) &
                        WqRateX%Field = WqRateX%Field * Me%ExternalVar%VolumeZ / Me%Coupled%WQM%DT_Compute

                call BoxDif(Me%ObjBoxDif,                                                   &
                            WqRateX%Field,                                                  &
                            trim(WqRateX%ID%Name),                                          &
                            Me%ExternalVar%OpenPoints3D,                                   &
                            STAT  = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('WaterQuality_Processes - ModuleWaterProperties - ERR05')
            end if

            WqRateX=>WqRateX%Next

        enddo

        nullify(WqRateX)

        call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterQuality_Processes - ModuleWaterProperties - ERR06')

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "WaterQuality_Processes")


    end subroutine WaterQuality_Processes

    !--------------------------------------------------------------------------

    subroutine CEQUALW2_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX
        real, dimension(:,:,:), pointer         :: ShortWaveExtinctionField
        real, dimension(:,:,:), pointer         :: ShortWaveTop
        type (T_WqRate),        pointer         :: WqRateX

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "CEQUALW2_Processes")

        ShortWaveTop => Me%SolarRadiation%ShortWaveTop

        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CEQUALW2_Processes - ModuleWaterProperties - ERR01')

        PropertyX => Me%FirstProperty

        if (Me%ExternalVar%Now .GE. Me%Coupled%CEQUALW2%NextCompute) then

            PropertyX%Evolution%SetLimitsTrigger = .true.

            do while(associated(PropertyX))

                call Modify_Interface(InterfaceID       = Me%ObjInterface,              &
                                      PropertyID        = PropertyX%ID%IDNumber,        &
                                      Concentration     = PropertyX%Concentration,      &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D, &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,  &
                                      ShortWaveTop      = ShortWaveTop,                 &
                                      LightExtCoefField = ShortWaveExtinctionField,     &
                                      DWZ               = Me%ExternalVar%DWZ,           &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('CEQUALW2_Processes - ModuleWaterProperties - ERR02')

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%CEQUALW2%NextCompute = Me%Coupled%CEQUALW2%NextCompute + Me%Coupled%CEQUALW2%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%CEQUALW2) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                   call Modify_Interface(InterfaceID   = Me%ObjInterface,               &
                                         PropertyID    = PropertyX%ID%IDNumber,         &
                                         Concentration = PropertyX%Concentration,       &
                                         DTProp        = PropertyX%Evolution%DTInterval,&
                                         WaterPoints3D = Me%ExternalVar%WaterPoints3D,  &
                                         OpenPoints3D  = Me%ExternalVar%OpenPoints3D,   &
                                         STAT           = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                        &
                        call CloseAllAndStop ('CEQUALW2_Processes - ModuleWaterProperties - ERR03')
                endif

            endif

            PropertyX=>PropertyX%Next

        enddo

        WqRateX => Me%FirstWqRate

        do while (associated(WqRateX))

            if(WqRateX%Model == CEQUALW2Model)then


                call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
                                 RateIndex      = WqRateX%CeQualID,                         &
                                 RateFlux3D     = WqRateX%Field,                            &
                                 WaterPoints3D  = Me%ExternalVar%OpenPoints3D,             &
                                 STAT           = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('CEQUALW2_Processes - ModuleWaterProperties - ERR04')


                where (Me%ExternalVar%OpenPoints3D == WaterPoint) &
                    WqRateX%Field = WqRateX%Field * Me%ExternalVar%VolumeZ

                call BoxDif(Me%ObjBoxDif,                                                   &
                            WqRateX%Field,                                                  &
                            trim(WqRateX%ID%Name),                                          &
                            Me%ExternalVar%OpenPoints3D,                                   &
                            STAT  = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('CEQUALW2_Processes - ModuleWaterProperties - ERR05')

            end if

            WqRateX=>WqRateX%Next

        enddo

        nullify(WqRateX)
        nullify(PropertyX)

        call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CEQUALW2_Processes - ModuleWaterProperties - ERR06')

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "CEQUALW2_Processes")


    end subroutine CEQUALW2_Processes

    !--------------------------------------------------------------------------

    subroutine Life_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX
        real, dimension(:,:,:), pointer         :: ShortWaveExtinctionField
        real, dimension(:,:,:), pointer         :: ShortWaveTop, ShortWaveAverage

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Life_Processes")

        ShortWaveTop       => Me%SolarRadiation%ShortWaveTop

        ShortWaveAverage   => Me%SolarRadiation%ShortWaveAverage

        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Life_Processes - ModuleWaterProperties - ERR01')


        PropertyX => Me%FirstProperty

        if (Me%ExternalVar%Now .GE. Me%Coupled%Life%NextCompute) then

            do while(associated(PropertyX))

                PropertyX%Evolution%SetLimitsTrigger = .true.

                call Modify_Interface(InterfaceID       = Me%ObjInterface,              &
                                      PropertyID        = PropertyX%ID%IDNumber,        &
                                      Concentration     = PropertyX%Concentration,      &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D, &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,  &
                                      ShortWaveAverage  = ShortWaveAverage,             &
                                      ShortWaveTop      = ShortWaveTop,                 &
                                      LightExtCoefField = ShortWaveExtinctionField,     &
                                      DWZ               = Me%ExternalVar%DWZ,           &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('Life_Processes - ModuleWaterProperties - ERR02')

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%Life%NextCompute = Me%Coupled%Life%NextCompute + Me%Coupled%Life%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%Life) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                   call Modify_Interface(InterfaceID   = Me%ObjInterface,               &
                                         PropertyID    = PropertyX%ID%IDNumber,         &
                                         Concentration = PropertyX%Concentration,       &
                                         DTProp        = PropertyX%Evolution%DTInterval,&
                                         WaterPoints3D = Me%ExternalVar%WaterPoints3D,  &
                                         OpenPoints3D  = Me%ExternalVar%OpenPoints3D,   &
                                         STAT           = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                        &
                        call CloseAllAndStop ('Life_Processes - ModuleWaterProperties - ERR03')
                endif

            endif

            PropertyX=>PropertyX%Next

        enddo


        nullify(PropertyX)

        call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Life_Processes - ModuleWaterProperties - ERR06')


        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Life_Processes")


    end subroutine Life_Processes

    !--------------------------------------------------------------------------

    subroutine MacroAlgae_Processes

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX
        type (T_WQRate  ),      pointer         :: WqRateX
        real, dimension(:,:,:), pointer         :: ShortWaveExtinctionField
        real, dimension(:,:,:), pointer         :: ShortWaveTop
        integer                                 :: i, j, k, kbottom
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: STAT_CALL
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        ShortWaveTop => Me%SolarRadiation%ShortWaveTop

        !Short wave light extinction coefficient
        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('MacroAlgae_Processes - ModuleWaterProperties - ERR01')

        call ComputeMacroAlgaeOccupation

        !Convert macroalgae distribution in the water column into gC/m3
        call DistributeMacroAlgae

        call MacroAlgaePhysicalConditions

        PropertyX => Me%FirstProperty

        if (Me%ExternalVar%Now .GE. Me%Coupled%MacroAlgae%NextCompute) then

            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB
            KUB = Me%WorkSize%KUB

            CHUNK = CHUNK_J(JLB, JUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleWaterProperties", "MacroAlgae_Processes")
            endif

            !$OMP PARALLEL PRIVATE(i,j,k,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    kbottom = Me%ExternalVar%KFloor_Z(i, j)

                    do k = kbottom, KUB

                        Me%MacroAlgae%ShearStress3D(i,j,k) = Me%MacroAlgae%MaxShearStress(i,j)
                        Me%MacroAlgae%SPMDepFlux3D (i,j,k) = Me%MacroAlgae%MaxSPMDepFlux (i,j)

                    enddo

                endif

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleWaterProperties", "MacroAlgae_Processes")
            endif

            call SetMatrixValue(Me%MacroAlgae%MaxShearStress, T_Size2D(ILB, IUB, JLB, JUB), 0.)
            call SetMatrixValue(Me%MacroAlgae%MaxSPMDepFlux , T_Size2D(ILB, IUB, JLB, JUB), 0.)

            do while(associated(PropertyX))

                call Modify_Interface(InterfaceID       = Me%ObjInterfaceMacroAlgae,    &
                                      PropertyID        = PropertyX%ID%IDNumber,        &
                                      Concentration     = PropertyX%Concentration,      &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D, &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,  &
                                      ShortWaveTop      = ShortWaveTop,                 &
                                      LightExtCoefField = ShortWaveExtinctionField,     &
                                      DWZ               = Me%ExternalVar%DWZ,           &
                                      ShearStress       = Me%MacroAlgae%ShearStress3D,  &
                                      SPMFlux           = Me%MacroAlgae%SPMDepFlux3D,   &
                                      MacrOccupation    = Me%Macroalgae%Occupation,    &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('MacroAlgae_Processes - ModuleWaterProperties - ERR02')

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%MacroAlgae%NextCompute = Me%Coupled%MacroAlgae%NextCompute + &
                                                Me%Coupled%MacroAlgae%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%MacroAlgae) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                    call Modify_Interface(InterfaceID   = Me%ObjInterfaceMacroAlgae,        &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%Concentration,          &
                                          DTProp        = PropertyX%Evolution%DTInterval,   &
                                          WaterPoints3D = Me%ExternalVar%WaterPoints3D,     &
                                          OpenPoints3D  = Me%ExternalVar%OpenPoints3D,      &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                            &
                        call CloseAllAndStop ('MacroAlgae_Processes - ModuleWaterProperties - ERR03')

                    if(PropertyX%ID%IDNumber == MacroAlgae_)then

                        !Integrate macroalgae distribution in the water column in to kgC/m2
                        call IntegrateMacroAlgae(PropertyX)

                    end if
                endif

            endif

            PropertyX=>PropertyX%Next

        enddo


        WqRateX => Me%FirstWqRate

        do while (associated(WqRateX))

            if(WqRateX%Model == MacroAlgaeModel)then

                call GetRateFlux(InterfaceID    = Me%ObjInterfaceMacroAlgae,                &
                                 FirstProp      = WqRateX%FirstProp%IDNumber,               &
                                 SecondProp     = WqRateX%SecondProp%IDNumber,              &
                                 RateFlux3D     = WqRateX%Field,                            &
                                 WaterPoints3D  = Me%ExternalVar%OpenPoints3D,             &
                                 STAT           = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('MacroAlgae_Processes - ModuleWaterProperties - ERR04')


                where (Me%ExternalVar%OpenPoints3D == WaterPoint) &
                    WqRateX%Field = WqRateX%Field * Me%ExternalVar%VolumeZ / &
                                    Me%Coupled%MacroAlgae%DT_Compute

                call BoxDif(Me%ObjBoxDif,                                                   &
                            WqRateX%Field,                                                  &
                            trim(WqRateX%ID%Name),                                          &
                            Me%ExternalVar%OpenPoints3D,                                   &
                            STAT  = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('MacroAlgae_Processes - ModuleWaterProperties - ERR05')

            end if

            WqRateX=>WqRateX%Next

        enddo

        nullify(WqRateX)
        nullify(PropertyX)

        call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('MacroAlgae_Processes - ModuleWaterProperties - ERR06')

    end subroutine MacroAlgae_Processes

    !--------------------------------------------------------------------------

    subroutine ComputeMacroAlgaeOccupation

        !Local-----------------------------------------------------------------
        real, dimension(:,:  ), pointer         :: WaterColumnZ
        integer                                 :: i, j, k, kbottom
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: STAT_CALL
        real                                    :: Remaining_Length


        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ComputeMacroAlgaeOccupation - ModuleWaterProperties - ERR01')

        call SetMatrixValue(Me%MacroAlgae%Occupation, Me%WorkSize, 0.)

        !if running in 3D
        if(Me%WorkSize%KUB > 1)then

            do j = JLB, JUB
            do i = ILB, IUB

            kbottom = Me%ExternalVar%KFloor_Z(i, j)

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then


                    if(Me%MacroAlgae%Height(i,j) .ge. WaterColumnZ(i,j))then

                        Me%MacroAlgae%Occupation(i,j,kbottom:KUB) = 1.

                    else

                        k = kbottom    ! index for the top sediment layer

                        Remaining_Length = Me%MacroAlgae%Height(i,j)

                        do while(k .LE. KUB)


                            if  (Remaining_Length >= Me%ExternalVar%DWZ(i,j,k))then

                                Me%MacroAlgae%Occupation(i,j,k)   = 1.
                                Remaining_Length                  = Remaining_Length - Me%ExternalVar%DWZ(i,j,k)
                            else if (Remaining_Length .gt. 0.0) then
                                Me%MacroAlgae%Occupation(i,j,k)   = Remaining_Length / Me%ExternalVar%DWZ(i,j,k)
                                Remaining_Length                  = 0.0
                            end if

                             k = k + 1

                        end do

                    end if

                endif

            enddo
            enddo

        else !if running in 2D (this way is faster)

            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    kbottom                 = Me%ExternalVar%KFloor_Z(i, j)

                    if(Me%MacroAlgae%Height(i,j) .ge. WaterColumnZ(i,j))then

                        Me%MacroAlgae%Occupation(i,j,kbottom:KUB) = 1
                    else

                        Me%MacroAlgae%Occupation(i,j,kbottom:KUB) = Me%MacroAlgae%Height(i,j) / &
                                                                    WaterColumnZ(i,j)

                    end if

                endif

            enddo
            enddo

        end if

        call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ComputeMacroAlgaeOccupation - ModuleWaterProperties - ERR01')

    end subroutine ComputeMacroAlgaeOccupation

    !--------------------------------------------------------------------------

    subroutine DistributeMacroAlgae

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: MacroAlgae
        real, dimension(:,:  ), pointer         :: WaterColumnZ
        integer                                 :: i, j, k, kbottom
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: STAT_CALL
        real                                    :: occupation

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !Macroalgae
        call Search_Property(MacroAlgae, PropertyXID = MacroAlgae_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('DistributeMacroAlgae - ModuleWaterProperties - ERR02')

        !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('DistributeMacroAlgae - ModuleWaterProperties - ERR02')

        if(Me%WorkSize%KUB > 1)then

            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    kbottom = Me%ExternalVar%KFloor_Z(i, j)


                    do k = kbottom, KUB

                        !occupation up to 1 to give % of dwz occupied
                        occupation = min(Me%MacroAlgae%Occupation(i,j,k), 1.0)

                        !gC/m3 = gC/m2 * m2 / m3 * m / m
                        MacroAlgae%Concentration(i,j,k) = Me%MacroAlgae%Distribution(i,j)    * &
                                                          Me%ExternalVar%GridCellArea(i,j)   * &
                                                         (occupation                         * &
                                                          Me%ExternalVar%DWZ(i,j,k)          / &
                                                          Me%MacroAlgae%Height(i,j))         / &
                                                          Me%ExternalVar%VolumeZ(i,j,k)

                    enddo

                endif

            enddo
            enddo

        else

            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    kbottom = Me%ExternalVar%KFloor_Z(i, j)

                    do k = kbottom, KUB

                        !gC/m3 = gC/m2 * m2 / m3 * m / m
                        MacroAlgae%Concentration(i,j,k) = Me%MacroAlgae%Distribution(i,j) * &
                                                          Me%ExternalVar%GridCellArea(i,j)/ &
                                                          Me%ExternalVar%VolumeZ(i,j,k)

                    enddo

                endif

            enddo
            enddo

        endif


        call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('DistributeMacroAlgae - ModuleWaterProperties - ERR06')

        nullify(MacroAlgae)

    end subroutine DistributeMacroAlgae

    !--------------------------------------------------------------------------

    subroutine IntegrateMacroAlgae(MacroAlgae)

        !Arguments-------------------------------------------------------------
        type (T_Property),      pointer         :: MacroAlgae

        !Local-----------------------------------------------------------------
        real, dimension(:,:  ), pointer         :: WaterColumnZ
        integer                                 :: i, j, k, kbottom
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: STAT_CALL
        real                                    :: MacroAlgaeMass

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('IntegrateMacroAlgae - ModuleWaterProperties - ERR01')


        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                kbottom = Me%ExternalVar%KFloor_Z(i, j)

                MacroAlgaeMass = 0.

                do k = kbottom, KUB
                    !gC = gC + gC/m3 * m3
                    MacroAlgaeMass = MacroAlgaeMass + Me%ExternalVar%VolumeZ(i,j,k) * &
                                 max(MacroAlgae%MinValue, MacroAlgae%Concentration(i,j,k))

                enddo

                !gC/m2 = g / m2
                Me%MacroAlgae%Distribution(i,j) = MacroAlgaeMass / Me%ExternalVar%GridCellArea(i,j)

            endif

        enddo
        enddo

        call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('IntegrateMacroAlgae - ModuleWaterProperties - ERR02')

    end subroutine IntegrateMacroAlgae

    !--------------------------------------------------------------------------

    subroutine MacroAlgaePhysicalConditions

        !Local-----------------------------------------------------------------
        integer                                 :: i, j
        integer                                 :: ILB, IUB, JLB, JUB, KUB

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                if(Me%ExternalVar%ShearStress(i,j) > Me%MacroAlgae%MaxShearStress(i,j)) then
                    Me%MacroAlgae%MaxShearStress(i,j) = Me%ExternalVar%ShearStress(i,j)
                end if

            endif

        enddo
        enddo


        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                if(Me%ExternalVar%SPMDepositionFlux(i,j) > Me%MacroAlgae%MaxSPMDepFlux(i,j)) then
                    Me%MacroAlgae%MaxSPMDepFlux(i,j) = Me%ExternalVar%SPMDepositionFlux(i,j)
                end if

            endif

        enddo
        enddo

    end subroutine MacroAlgaePhysicalConditions


    !--------------------------------------------------------------------------


    subroutine SeagrassesLeaves_Processes
        !Local-----------------------------------------------------------------
        type (T_Property),       pointer         :: PropertyX
        type (T_WQRate  ), pointer              :: WqRateX
        real, dimension(:,:,:), pointer         :: ShortWaveExtinctionField
        real, dimension(:,:,:), pointer         :: ShortWaveTop
        !real, dimension(:,:,:), pointer :: Volume
        integer                                  :: i, j, k, kbottom
        integer                                  :: ILB, IUB, JLB, JUB,KLB, KUB
        integer                                  :: STAT_CALL
        real, dimension(:,:  ), pointer         :: WaterColumnZ


        !Begin-----------------------------------------------------------------

            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB
            KUB = Me%WorkSize%KUB
            KLB = Me%WorkSize%KLB

        ShortWaveTop => Me%SolarRadiation%ShortWaveTop

        !Short wave light extinction coefficient
        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR01')

        PropertyX => Me%FirstProperty

       do while (associated(PropertyX))

                if (PropertyX%Evolution%SeagrassesLeaves) then

                    if(PropertyX%ID%IDNumber == SeagrassesLeaves_)then

                        call LeavesOccupation(Me%SeagrassesLeaves)
                        call DistributeLeaves(PropertyX, Me%SeagrassesLeaves)

                    end if

                end if

                PropertyX=>PropertyX%Next
       end do

            do k=KLB, KUB
            do j=JLB, JUB
            do i=ILB, IUB

            Me%SeagrassesLeaves%NintFactor3D(i,j,k)=Me%SeagrassesLeaves%NintFactor2D(i,j)
            Me%SeagrassesLeaves%PintFactor3D(i,j,k)=Me%SeagrassesLeaves%PintFactor2D(i,j)

            enddo
            enddo
            enddo



            PropertyX => Me%FirstProperty

        if (Me%ExternalVar%Now .GE. Me%Coupled%SeagrassesLeaves%NextCompute) then




            do while(associated(PropertyX))


            if(PropertyX%ID%IDNumber == SeagrassesLeaves_)then


            Me%SeagrassesLeaves%Volume=>Me%ExternalVar%VolumeZ


                call Modify_Interface(InterfaceID       = Me%ObjSeagrassWaterInteraction,       &
                                      PropertyID        = PropertyX%ID%IDNumber,                 &
                                      Concentration     = PropertyX%Concentration,               &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D,          &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,           &
                                      ShortWaveTop      = ShortWaveTop,                          &
                                      LightExtCoefField = ShortWaveExtinctionField,              &
                                      WaterVolume       = Me%SeagrassesLeaves%Volume,            &
                                      NintFac3D         = Me%SeagrassesLeaves%NintFactor3D,      &
                                      PintFac3D         = Me%SeagrassesLeaves%PintFactor3D,      &
                                      SeagOccupation    = Me%SeagrassesLeaves%Occupation,            &
                                      DWZ               = Me%ExternalVar%DWZ,                    &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                     &
                    call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR02')
            else
                   call Modify_Interface(InterfaceID       = Me%ObjSeagrassWaterInteraction,       &
                                      PropertyID        = PropertyX%ID%IDNumber,                 &
                                      Concentration     = PropertyX%Concentration,               &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D,          &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,           &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                     &
                    call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR02')
            endif
                PropertyX => PropertyX%Next

            end do

            Me%Coupled%SeagrassesLeaves%NextCompute = Me%Coupled%SeagrassesLeaves%NextCompute + &
                                                      Me%Coupled%SeagrassesLeaves%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%SeagrassesLeaves) then

                    if (Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

                        PropertyX%Evolution%SetLimitsTrigger = .true.

                         call Modify_Interface(InterfaceID   = Me%ObjSeagrassWaterInteraction,  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%Concentration,          &
                                          DTProp        = PropertyX%Evolution%DTInterval,   &
                                          WaterPoints3D = Me%ExternalVar%WaterPoints3D,     &
                                          OpenPoints3D  = Me%ExternalVar%OpenPoints3D,      &
                                          STAT          = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                            &
                        call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR03')


            endif

            endif

            PropertyX=>PropertyX%Next

        enddo

        WqRateX => Me%FirstWqRate


        do while (associated(WqRateX))

            if(WqRateX%Model == 'SeagrassWaterInteraction')then

                  call GetRateFlux(InterfaceID    = Me%ObjSeagrassWaterInteraction,          &
                                 FirstProp      = WqRateX%FirstProp%IDNumber,               &
                                 SecondProp     = WqRateX%SecondProp%IDNumber,              &
                                 RateFlux3D     = WqRateX%Field,                            &
                                 WaterPoints3D  = Me%ExternalVar%WaterPoints3D,             &
                                 STAT           = STAT_CALL)
                   if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR04')


                   WqRateX%Field2=>WqRateX%Field

                       if (WqRateX%FirstProp%IDNumber==LeavesUptakeN_) then


                         Me%SeagrassesLeaves%UptakeNH4NO3w3D =WqRateX%Field



                         where (Me%ExternalVar%WaterPoints3D == WaterPoint) &
                                  WqRateX%Field2=  WqRateX%Field2 * Me%ExternalVar%VolumeZ

                            call BoxDif(Me%ObjBoxDif,                                                   &
                                         WqRateX%Field2,                                                  &
                                        trim(WqRateX%ID%Name),                                          &
                                        Me%ExternalVar%WaterPoints3D,                                   &
                                        STAT  = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                                                &
                                call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR05')

                      elseif (WqRateX%FirstProp%IDNumber==LeavesUptakeP_) then


                        Me%SeagrassesLeaves%UptakePO4w3D = WqRateX%Field


                        where (Me%ExternalVar%WaterPoints3D == WaterPoint) &
                                  WqRateX%Field2=  WqRateX%Field2 * Me%ExternalVar%VolumeZ

                            call BoxDif(Me%ObjBoxDif,                                                   &
                                         WqRateX%Field2,                                                  &
                                        trim(WqRateX%ID%Name),                                          &
                                        Me%ExternalVar%WaterPoints3D,                                   &
                                        STAT  = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                                                &
                                call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR05')


                     elseif(WqRateX%FirstProp%IDNumber==LeavesLightFactor_) then


                          Me%SeagrassesLeaves%LightFactor3D = WqRateX%Field

                          call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
                          if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR01')


                                        do j = JLB, JUB
                               do i = ILB, IUB

                                  if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                    kbottom = Me%ExternalVar%KFloor_Z(i, j)
                                       if (Me%WorkSize%KUB > 1) then

                                               do k = kbottom, KUB
                                               ! light factor is calculated in each cell and is varying between 0 and 1
                                               ! and it is multiplied by the percent of plant present in each cell
                                               ! In moduleInterfaceSedimentWater, the factor is summed up over the water column
                                               ! to get the total light factor
                                                Me%SeagrassesLeaves%LightFactor3D(i,j,k)=                           &
                                                                         Me%SeagrassesLeaves%LightFactor3D(i,j,k) * &
                                                                         Me%SeagrassesLeaves%Occupation(i,j,k)    * &
                                                                       ( Me%ExternalVar%DWZ(i, j, k)             /  &
                                                                         Me%SeagrassesLeaves%Length(i,j)  )

                                              enddo
                                       else

                                               Me%SeagrassesLeaves%LightFactor3D(i,j,k) =                           &
                                                                         Me%SeagrassesLeaves%LightFactor3D(i,j,kbottom)

                                       endif

                                  endif

                               enddo
                               enddo

                                call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)


                             if (STAT_CALL /= SUCCESS_)                                 &
                                call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR20')

                     where (Me%ExternalVar%WaterPoints3D == WaterPoint) &
                                  WqRateX%Field2=  WqRateX%Field2 * Me%ExternalVar%VolumeZ

                            call BoxDif(Me%ObjBoxDif,                                                   &
                                         WqRateX%Field2,                                                  &
                                        trim(WqRateX%ID%Name),                                          &
                                        Me%ExternalVar%WaterPoints3D,                                   &
                                        STAT  = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                                                &
                                call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR05')
                    else

                            where (Me%ExternalVar%WaterPoints3D == WaterPoint) &
                                 WqRateX%Field =  WqRateX%Field * Me%ExternalVar%VolumeZ / &
                                                Me%Coupled%SeagrassesLeaves%DT_Compute

                            call BoxDif(Me%ObjBoxDif,                                                   &
                                         WqRateX%Field,                                                  &
                                        trim(WqRateX%ID%Name),                                          &
                                        Me%ExternalVar%WaterPoints3D,                                   &
                                        STAT  = STAT_CALL)
                            if (STAT_CALL .NE. SUCCESS_)                                                &
                                call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR05')
                    endif
            end if

             WqRateX=> WqRateX%Next

        enddo

        nullify( WqRateX)
        nullify(PropertyX)


     call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SeagrassesLeaves_Processes - ModuleWaterProperties - ERR06')


     end   subroutine SeagrassesLeaves_Processes


 !--------------------------------------------------------------------------

    subroutine DistributeLeaves(PropertyX, SeagrassesLeaves)

        !Arguments-------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX
        type (T_SeagrassesLeaves)               :: SeagrassesLeaves

        !Local-----------------------------------------------------------------
        real, dimension(:,:  ), pointer         :: WaterColumnZ
        integer                                 :: i, j, k, kbottom
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('DistributeLeaves - ModuleWaterProperties - ERR02')

        if(Me%WorkSize%KUB > 1)then

            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    kbottom = Me%ExternalVar%KFloor_Z(i, j)

                    SeagrassesLeaves%Length(i,j)=SeagrassesLeaves%Biomass(i,j)*SeagrassesLeaves%LBratio

                    do k = kbottom, KUB
                        !gdw/m3 = gdw/m2 * m2 / m3 * m / m
                        PropertyX%Concentration(i,j,k) = SeagrassesLeaves%Occupation(i,j,k) * &
                                                         SeagrassesLeaves%Biomass(i,j)      * &
                                                         Me%ExternalVar%GridCellArea(i,j)  / &
                                                         Me%ExternalVar%VolumeZ(i,j,k)     * &
                                                        (Me%ExternalVar%DWZ(i,j,k)         / &
                                                         SeagrassesLeaves%Length(i,j))

                    enddo

                endif

            enddo
            enddo

        else

            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    kbottom = Me%ExternalVar%KFloor_Z(i, j)

               SeagrassesLeaves%Length(i,j)=SeagrassesLeaves%Biomass(i,j)*SeagrassesLeaves%LBratio


                    do k = kbottom, KUB

                        !gdw/m3 = gdw/m2 * m2 / m3
                        PropertyX%Concentration(i,j,k) = SeagrassesLeaves%Biomass(i,j) * &
                                                         Me%ExternalVar%GridCellArea(i,j)  / &
                                                         Me%ExternalVar%VolumeZ(i,j,k)

                    enddo

                endif

            enddo
            enddo

        endif


        call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('DistributeLeaves - ModuleWaterProperties - ERR06')

    end subroutine DistributeLeaves

    !---------------------------------------------------------------------------------------------

    subroutine  LeavesOccupation(SeagrassesLeaves)



        !Arguments-------------------------------------------------------------
        type (T_SeagrassesLeaves)                          :: SeagrassesLeaves

        !Local-----------------------------------------------------------------
        real, dimension(:,:  ), pointer         :: WaterColumnZ
        integer                                 :: i, j, k, kbottom
        integer                                 :: ILB, IUB, JLB, JUB, KUB, KLB
        integer                                 :: STAT_CALL
        real                                    :: Remaining_leaves_Length

        !Begin-----------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB
        KLB = Me%WorkSize%KLB

         !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('LeavesOccupation - ModuleWaterProperties - ERR01')


        call SetMatrixValue(SeagrassesLeaves%Occupation, Me%WorkSize, 0.)

        !if running in 3D
        if(Me%WorkSize%KUB > 1)then

            do j = JLB, JUB
            do i = ILB, IUB

            kbottom = Me%ExternalVar%KFloor_Z(i, j)

                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then


                    SeagrassesLeaves%Length(i,j)=SeagrassesLeaves%Biomass(i,j)*SeagrassesLeaves%LBratio
                    if(SeagrassesLeaves%Length(i,j) .ge. WaterColumnZ(i,j))then

                        SeagrassesLeaves%Occupation(i,j,kbottom:KUB) = 1

                        !SeagrassesLeaves%DistFromTop(i,j,kbottom:KUB) = 0.
                        !SeagrassesLeaves%DistFromTop(i,j,kbottom:KUB) = WaterColumnZ(i,j)   !new
                    else

                        k = kbottom    ! index for the top sediment layer

                        Remaining_leaves_Length = SeagrassesLeaves%Length(i,j)

                        do while(k .LE. KUB)


                            if  (Remaining_leaves_Length >= Me%ExternalVar%DWZ(i,j,k))then

                                SeagrassesLeaves%Occupation(i,j,k)   = 1.
                                Remaining_leaves_Length               = Remaining_leaves_Length - Me%ExternalVar%DWZ(i,j,k)
                                !SeagrassesLeaves%DistFromTop(i,j,k) = 0.
                                !SeagrassesLeaves%DistFromTop(i,j,k) = Me%ExternalVar%DWZ(i,j,k)  ! new
                            else
                                SeagrassesLeaves%Occupation(i,j,k)   = Remaining_leaves_Length / Me%ExternalVar%DWZ(i,j,k)
                                !SeagrassesLeaves%DistFromTop(i,j,k) = Me%ExternalVar%DWZ(i,j,k)-Remaining_leaves_Length
                                !SeagrassesLeaves%DistFromTop(i,j,k) = Remaining_leaves_Length  ! new
                            end if
                                k                                   = k + 1
                        end do

                    end if

                endif

            enddo
            enddo

        else !if running in 2D (this way is faster)

            do j = JLB, JUB
            do i = ILB, IUB

                kbottom = Me%ExternalVar%KFloor_Z(i, j)


                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then


                    SeagrassesLeaves%Length(i,j)=SeagrassesLeaves%Biomass(i,j)*SeagrassesLeaves%LBratio

                    if (SeagrassesLeaves%Length(i,j) .ge. WaterColumnZ(i,j))then

                        SeagrassesLeaves%Occupation(i,j,kbottom:KUB) = 1.
                        !SeagrassesLeaves%DistFromTop(i,j,kbottom:KUB) =0.
                        !SeagrassesLeaves%DistFromTop(i,j,kbottom:KUB) =WaterColumnZ(i,j)

                    else

                        SeagrassesLeaves%Occupation(i,j,kbottom:KUB) = SeagrassesLeaves%Length(i,j) / &
                                                                      WaterColumnZ(i,j)
                        ! SeagrassesLeaves%DistFromTop(i,j,kbottom:KUB) = WaterColumnZ(i,j) - SeagrassesLeaves%Length(i,j)
                         !  SeagrassesLeaves%DistFromTop(i,j,kbottom:KUB) = SeagrassesLeaves%Length(i,j)
                    end if

                endif

            enddo
            enddo

        end if

         call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('LeavesOccupation - ModuleWaterProperties - ERR02')

    end  subroutine LeavesOccupation

   !--------------------------------------------------------------------------
    subroutine GetSeagrassesLeavesRates(WaterPropertiesID, RateID, Rateflux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Rateflux
        integer,                      intent(IN)    :: RateID
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            select case(RateID)

            case(LeavesUptakeN_)

            Rateflux => Me%SeagrassesLeaves%UptakeNH4NO3w3D

            case(LeavesUptakeP_)

            Rateflux => Me%SeagrassesLeaves%UptakePO4w3D


            case(LeavesLightFactor_)

            Rateflux => Me%SeagrassesLeaves%LightFactor3D

            end select

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetSeagrassesLeavesRates

    !--------------------------------------------------------------------------
    !   Makes the connection between the Water
    !   Properties module and the WWTP quality
    !   model
    !--------------------------------------------------------------------------
    subroutine WWTPQ_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property),      pointer         :: PropertyX
        type (T_WqRate),        pointer         :: WqRateX
        real, dimension(:,:,:), pointer         :: ShortWaveExtinctionField
        real, dimension(:,:,:), pointer         :: ShortWaveTop

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "WWTPQ_Processes")

        ShortWaveTop => Me%SolarRadiation%ShortWaveTop

        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WWTPQ_Processes - ModuleWaterProperties - ERR01')

        PropertyX => Me%FirstProperty

        if (Me%ExternalVar%Now .GE. Me%Coupled%WWTPQM%NextCompute) then

            do while(associated(PropertyX))

                call Modify_Interface(InterfaceID       = Me%ObjInterface,              &
                                      PropertyID        = PropertyX%ID%IDNumber,        &
                                      Concentration     = PropertyX%Concentration,      &
                                      WaterPoints3D     = Me%ExternalVar%WaterPoints3D, &
                                      OpenPoints3D      = Me%ExternalVar%OpenPoints3D,  &
                                      ShortWaveTop= ShortWaveTop,           &
                                      LightExtCoefField = ShortWaveExtinctionField,     &
                                      DWZ               = Me%ExternalVar%DWZ,           &
                                      STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('WWTPQ_Processes - ModuleWaterProperties - ERR02')

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%WWTPQM%NextCompute = Me%Coupled%WWTPQM%NextCompute + Me%Coupled%WWTPQM%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%WWTPQ) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                   call Modify_Interface(InterfaceID   = Me%ObjInterface,               &
                                         PropertyID    = PropertyX%ID%IDNumber,         &
                                         Concentration = PropertyX%Concentration,       &
                                         DTProp        = PropertyX%Evolution%DTInterval,&
                                         WaterPoints3D = Me%ExternalVar%WaterPoints3D,  &
                                         OpenPoints3D  = Me%ExternalVar%OpenPoints3D,   &
                                         STAT           = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                        &
                        call CloseAllAndStop ('WWTPQ_Processes - ModuleWaterProperties - ERR03')
                endif

            endif

            PropertyX=>PropertyX%Next

        enddo

        nullify(PropertyX)

        !Get rate fluxes, integrate them and write box time series
        WqRateX => Me%FirstWqRate

        do while (associated(WqRateX))

            if(WqRateX%Model == WWTPQModel)then

                call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
                                 FirstProp      = WqRateX%FirstProp%IDNumber,               &
                                 SecondProp     = WqRateX%SecondProp%IDNumber,              &
                                 RateFlux3D     = WqRateX%Field,                            &
                                 WaterPoints3D  = Me%ExternalVar%OpenPoints3D,             &
                                 STAT           = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('WWTPQ_Processes - ModuleWaterProperties - ERR04')

                where (Me%ExternalVar%OpenPoints3D == WaterPoint) &
                        WqRateX%Field = WqRateX%Field * Me%ExternalVar%VolumeZ / Me%Coupled%WWTPQM%DT_Compute

                call BoxDif(Me%ObjBoxDif,                                                   &
                            WqRateX%Field,                                                  &
                            trim(WqRateX%ID%Name),                                          &
                            Me%ExternalVar%OpenPoints3D,                                   &
                            STAT  = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                                &
                    call CloseAllAndStop ('WWTPQ_Processes - ModuleWaterProperties - ERR05')
            end if

            WqRateX=>WqRateX%Next

        enddo

        nullify(WqRateX)

        call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WWTPQ_Processes - ModuleWaterProperties - ERR06')

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "WWTPQ_Processes")


    end subroutine WWTPQ_Processes

    !--------------------------------------------------------------------------

#ifdef _PHREEQC_
    subroutine PhreeqC_Processes (is_starting)

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL
        logical                                 :: is_starting

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
        type (T_Property), pointer              :: Temperature
        type (T_Property), pointer              :: Density
        type (T_Property), pointer              :: Pressure
        type (T_Property), pointer              :: Porosity
        type (T_Property), pointer              :: Saturation
        integer                                 :: i, j, k

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "PhreeqC_Processes")

        if (Me%ExternalVar%Now .GE. Me%Coupled%PhreeqC%NextCompute .or. is_starting) then

            PropertyX => Me%FirstProperty
            do while(associated(PropertyX))

                if (PropertyX%Evolution%PhreeqC) then

                    select case (PropertyX%ID%IDNumber)
                    case (Temperature_)
                        Temperature => PropertyX
                    case (Density_)
                        Density => PropertyX
                        Density%Concentration = Me%Density%Field !WARNING: Must be checked if the Density Field is already defined.
                    case (CellPorosity_)
                        Porosity => PropertyX
                    case (Pressure_)
                        Pressure => PropertyX
                    case (WaterSaturation_)
                        Saturation => PropertyX
                    end select

                end if

                PropertyX => PropertyX%Next

            end do

            PropertyX => Me%FirstProperty
            do while(associated(PropertyX))

                if (PropertyX%Evolution%PhreeqC) then

                    select case (PropertyX%ID%IDNumber)
                    case (Temperature_, Pressure_, Density_, WaterSaturation_, CellPorosity_, &
                          SolutionMapping_,EquilibriumMapping_,ExchangeMapping_,SurfaceMapping_, &
                          GasPhaseMapping_,SolidSolutionMapping_,KineticsMapping_)
                        !Do nothing
                    case default
                        !print *, "1. Property "//trim(PropertyX%ID%Name)
                        call Modify_Interface (InterfaceID       = Me%ObjInterface,                     &
                                               PropertyID        = PropertyX%ID%IDNumber,               &
                                               Concentration     = PropertyX%Concentration,             &
                                               WaterPoints3D     = Me%ExternalVar%WaterPoints3D,        &
                                               OpenPoints3D      = Me%ExternalVar%OpenPoints3D,         &
                                               DWZ               = Me%ExternalVar%DWZ,                  &
                                               Temperature       = Temperature%Concentration,           &
                                               Pressure          = Pressure%Concentration,              &
                                               Density           = Density%Concentration,               &
                                               Porosity          = Porosity%Concentration,              &
                                               WaterSaturation   = Saturation%Concentration,            &
                                               IsPhreeqCStarting = is_starting,                         &
                                               STAT              = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_) &
                            call CloseAllAndStop ('PhreeqC_Processes - ModuleWaterProperties - ERR02')
                    end select

                endif

                PropertyX => PropertyX%Next

            end do

            if (.not. is_starting) &
                Me%Coupled%PhreeqC%NextCompute = Me%Coupled%PhreeqC%NextCompute + Me%Coupled%PhreeqC%DT_Compute

        endif

        PropertyX => Me%FirstProperty
        do while (associated(PropertyX))

            if (PropertyX%Evolution%PhreeqC) then
            if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute .or. is_starting) then

                PropertyX%Evolution%SetLimitsTrigger = .true.

                select case (PropertyX%ID%IDNumber)
                case (Temperature_, Pressure_, Density_, WaterSaturation_, CellPorosity_, &
                      SolutionMapping_,EquilibriumMapping_,ExchangeMapping_,SurfaceMapping_, &
                      GasPhaseMapping_,SolidSolutionMapping_,KineticsMapping_)
                    !Do nothing
                case default
                    call Modify_Interface (InterfaceID       = Me%ObjInterface,                     &
                                           PropertyID        = PropertyX%ID%IDNumber,               &
                                           Concentration     = PropertyX%Concentration,             &
                                           DTProp            = PropertyX%Evolution%DTInterval,      &
                                           WaterPoints3D     = Me%ExternalVar%WaterPoints3D,        &
                                           OpenPoints3D      = Me%ExternalVar%OpenPoints3D,         &
                                           IsPhreeqCStarting = is_starting,                         &
                                           STAT              = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) &
                        call CloseAllAndStop ('PhreeqC_Processes - ModuleWaterProperties - ERR03')

                endselect

            endif
            endif

            PropertyX=>PropertyX%Next

        enddo

        nullify(PropertyX)

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "PhreeqC_Processes")

    end subroutine PhreeqC_Processes
#endif
    !--------------------------------------------------------------------------

    subroutine Bivalve_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property)        , pointer      :: PropertyX

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Bivalve_Processes")

        call UpdateLarvaeDistribution

        if (Me%ExternalVar%Now .GE. Me%Coupled%Bivalve%NextCompute) then

            call CheckListDeadAndListNewborns

            call GetVelocityModulus(HydrodynamicID  = Me%ObjHydrodynamic,               &
                                    VelocityModulus = Me%ExternalVar%VelocityModulus,   &
                                    Compute         = .true.,                           &
                                    STAT            = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Bivalve_Processes - ModuleWaterProperties - ERR01')

            PropertyX => Me%FirstProperty

            do while(associated(PropertyX))

                call Modify_Interface(InterfaceID             = Me%ObjInterfaceBivalve,           &
                                      PropertyID              = PropertyX%ID%IDNumber,            &
                                      Concentration           = PropertyX%Concentration,          &
                                      WaterPoints3D           = Me%ExternalVar%WaterPoints3D,     &
                                      OpenPoints3D            = Me%ExternalVar%OpenPoints3D,      &
                                      WaterVolume             = Me%ExternalVar%VolumeZ,           &
                                      CellArea                = Me%ExternalVar%GridCellArea,      &
                                      VelocityModulus         = Me%ExternalVar%VelocityModulus,   &
                                      STAT                    = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('Bivalve_Processes - ModuleWaterProperties - ERR02')

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%Bivalve%NextCompute = Me%Coupled%Bivalve%NextCompute + Me%Coupled%Bivalve%DT_Compute

            call UnGetHydrodynamic(Me%ObjHydrodynamic, Me%ExternalVar%VelocityModulus, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Bivalve_Processes - ModuleWaterProperties - ERR03')

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if (PropertyX%Evolution%Bivalve) then

                if (Me%ExternalVar%Now .GE.PropertyX%Evolution%NextCompute) then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                   call Modify_Interface(InterfaceID     = Me%ObjInterfaceBivalve,           &
                                         PropertyID      = PropertyX%ID%IDNumber,            &
                                         Concentration   = PropertyX%Concentration,          &
                                         DTProp          = PropertyX%Evolution%DTInterval,   &
                                         WaterPoints3D   = Me%ExternalVar%WaterPoints3D,     &
                                         OpenPoints3D    = Me%ExternalVar%OpenPoints3D,      &
                                         STAT            = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                        &
                        call CloseAllAndStop ('Bivalve_Processes - ModuleWaterProperties - ERR04')

                endif

            endif

            PropertyX=>PropertyX%Next

        enddo

        call TruncateBivalveLowNumber

        if ((Me%Bivalve%OutputHDF) .or. (Me%Bivalve%OutputBoxTimeSerie)) then

            call BivalveOutput

        end if

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Bivalve_Processes")

        nullify(PropertyX)

    end subroutine Bivalve_Processes

    !--------------------------------------------------------------------------

    subroutine TruncateBivalveLowNumber

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                            :: i, j, k
        type (T_Species) , pointer         :: Species
        type (T_Cohort)  , pointer         :: Cohort
        type (T_Property), pointer         :: Property_N, Property_L, Property_MH
        type (T_Property), pointer         :: Property_MV, Property_ME, Property_MR
        character(len=StringLength)        :: PropertyName_N, PropertyName_L, PropertyName_MH
        character(len=StringLength)        :: PropertyName_MV, PropertyName_ME, PropertyName_MR
        integer                            :: STAT_CALL

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "TruncateBivalveLowNumber")

        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

            Cohort  => Species%FirstCohort
            do while (associated(Cohort))

                !number
                PropertyName_N = trim(adjustl(Cohort%ID%Name))//" number"

                call Search_Property(Property_N                                                    , &
                                     PropertyXID = GetDynamicPropertyIDNumber(trim(PropertyName_N)), &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('TruncateBivalveLowNumber - ModuleWaterProperties - ERR10')

                !length
                PropertyName_L = trim(adjustl(Cohort%ID%Name))//" length"

                call Search_Property(Property_L                                                    , &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_L)      , &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('TruncateBivalveLowNumber - ModuleWaterProperties - ERR20')

                !reserves
                PropertyName_ME = trim(adjustl(Cohort%ID%Name))//" reserves"

                call Search_Property(Property_ME                                                   , &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_ME)     , &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('TruncateBivalveLowNumber - ModuleWaterProperties - ERR30')

                !structure
                PropertyName_MV = trim(adjustl(Cohort%ID%Name))//" structure"

                call Search_Property(Property_MV                                                   , &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MV)     , &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('TruncateBivalveLowNumber - ModuleWaterProperties - ERR40')

                !maturity
                PropertyName_MH = trim(adjustl(Cohort%ID%Name))//" maturity"

                call Search_Property(Property_MH                                                   , &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MH)     , &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('TruncateBivalveLowNumber - ModuleWaterProperties - ERR50')

                !reproduction
                PropertyName_MR = trim(adjustl(Cohort%ID%Name))//" reproduction"

                call Search_Property(Property_MR                                                   , &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MR)     , &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('TruncateBivalveLowNumber - ModuleWaterProperties - ERR60')

                do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                    if(Me%ExternalVar%WaterPoints3D(i, j, k) == 1)then

                        !#/m2
                        if(Property_N%Concentration(i,j,k) .ge. -1e-4 .and. Property_N%Concentration(i,j,k) .le. 1e-4)then

                            Property_N%Concentration(i,j,k)  = 0.0
                            Property_MV%Concentration(i,j,k) = 0.0
                            Property_MH%Concentration(i,j,k) = 0.0
                            Property_MR%Concentration(i,j,k) = 0.0
                            Property_ME%Concentration(i,j,k) = 0.0
                            Property_L%Concentration (i,j,k) = 0.0

                        endif

                    endif

                enddo
                enddo
                enddo

                Cohort  => Cohort%Next

            enddo

            Species  => Species%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "TruncateBivalveLowNumber")

    end subroutine TruncateBivalveLowNumber

    !--------------------------------------------------------------------------


    subroutine UpdateLarvaeDistribution

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Species) , pointer         :: Species
        type (T_Cohort)  , pointer         :: Cohort
        type (T_Property), pointer         :: Property_N, Property_L,Property_MH
        type (T_Property), pointer         :: Property_MV, Property_ME, Property_MR
        character(len=StringLength)        :: PropertyName_N, PropertyName_L, PropertyName_MH
        character(len=StringLength)        :: PropertyName_MV, PropertyName_ME, PropertyName_MR

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "UpdateLarvaeDistribution")

        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

            if (Species%LarvaeTransport)  then

                call GetBivalveOtherParameters (Bivalve_ID      = Me%ObjBivalve        , &
                                                SpeciesIDNumber = Species%ID%IDNumber  , &
                                                LarvaeMaxSize   = Species%LarvaeMaxSize, &
                                                STAT            = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR01')

                Cohort  => Species%FirstCohort
                do while (associated(Cohort))

                    if(Cohort%AtLeastOneLarvae)then

                        !length
                        PropertyName_L = trim(adjustl(Cohort%ID%Name))//" length"

                        call Search_Property(Property_L                                                , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_L)  , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR10')

                        !number
                        PropertyName_N = trim(adjustl(Cohort%ID%Name))//" number"

                        call Search_Property(Property_N                                                , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_N)  , &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR10')

                        !maturity
                        PropertyName_MH = trim(adjustl(Cohort%ID%Name))//" maturity"

                        call Search_Property(Property_MH                                              , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MH), &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR10')

                        !structure
                        PropertyName_MV = trim(adjustl(Cohort%ID%Name))//" structure"

                        call Search_Property(Property_MV                                              , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MV), &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR10')

                        !reserves
                        PropertyName_ME = trim(adjustl(Cohort%ID%Name))//" reserves"

                        call Search_Property(Property_ME                                              , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_ME), &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR10')

                        !reproduction
                        PropertyName_MR = trim(adjustl(Cohort%ID%Name))//" reproduction"

                        call Search_Property(Property_MR                                              , &
                                             PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MR), &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('UpdateLarvaeDistribution - ModuleWaterProperties - ERR10')


                        Property_L%Evolution%AdvectionDiffusion  = .true.
                        Property_MV%Evolution%AdvectionDiffusion = .true.
                        Property_ME%Evolution%AdvectionDiffusion = .true.
                        Property_MH%Evolution%AdvectionDiffusion = .true.
                        Property_MR%Evolution%AdvectionDiffusion = .true.
                        Property_N%Evolution%AdvectionDiffusion  = .true.

                        call ComputeCohortLarvaeDistribution(Cohort, Property_L, Property_N, Species%LarvaeMaxSize)

                        !this IF is separated because Cohort%AtLeastOneLarvae can change
                        !after the call to sub ComputeCohortLarvaeDistribution
                        if(.not. Cohort%AtLeastOneLarvae)then
                            Property_L%Evolution%AdvectionDiffusion  = .false.
                            Property_MV%Evolution%AdvectionDiffusion = .false.
                            Property_ME%Evolution%AdvectionDiffusion = .false.
                            Property_MH%Evolution%AdvectionDiffusion = .false.
                            Property_MR%Evolution%AdvectionDiffusion = .false.
                            Property_N%Evolution%AdvectionDiffusion  = .false.

                            write(*,*)"Cohort ", trim(Cohort%ID%Name), " is no longer larvae"

                        endif

                    endif



                    Cohort  => Cohort%Next

                enddo

            end if ! (Species%LarvaeTransport)

            Species  => Species%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "UpdateLarvaeDistribution")

    end subroutine UpdateLarvaeDistribution

    !--------------------------------------------------------------------------

    subroutine ComputeCohortLarvaeDistribution(Cohort, Property_L, Property_N, LarvaeMaxSize)

        !Arguments-------------------------------------------------------------
        type (T_Cohort)  , pointer         :: Cohort
        type (T_Property), pointer         :: Property_L, Property_N
        real, intent(in)                   :: LarvaeMaxSize

        !External--------------------------------------------------------------
        integer                            :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                            :: WorkKLB, WorkKUB
        integer                            :: i,j,k

        !Local-----------------------------------------------------------------
        integer                            :: LarvaeCount

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "ComputeCohortLarvaeDistribution")

        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        LarvaeCount = 0

        do k = WorkKLB, WorkKUB
        do j = WorkJLB, WorkJUB
        do i = WorkILB, WorkIUB

            if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then
                if (Property_L%Concentration(i,j,k) .gt. 0.0           .and. &
                    Property_L%Concentration(i,j,k) .le. LarvaeMaxSize .and. &
                    Property_N%Concentration(i,j,k) .gt. 0.0) then
                    Cohort%Larvae(i,j,k) = 1
                else
                    Cohort%Larvae(i,j,k) = 0
                endif

                LarvaeCount = LarvaeCount + Cohort%Larvae(i,j,k)

            endif

        enddo
        enddo
        enddo

        if(LarvaeCount == 0)then
            Cohort%AtLeastOneLarvae = .false.
        else
            Cohort%AtLeastOneLarvae = .true.  !there is at least one cell with larvae from this cohort
        endif


        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "ComputeCohortLarvaeDistribution")

    end subroutine ComputeCohortLarvaeDistribution

    !--------------------------------------------------------------------------

    subroutine BivalveOutput

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Species) , pointer         :: Species
        type (T_Cohort)  , pointer         :: Cohort
        type (T_Property), pointer         :: Property_N, Property_L
        type (T_Property), pointer         :: Property_MV, Property_ME, Property_MR
        integer                            :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                            :: WorkKLB, WorkKUB
        integer                            :: i, j, k, iClass
        character(len=StringLength)        :: PropertyName_N, PropertyName_L
        character(len=StringLength)        :: PropertyName_MV, PropertyName_ME, PropertyName_MR

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "BivalveOutput")

        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

            Species%TotalDensity = 0.0
            Species%FieldDensity = 0.0
            Species%TotalBiomass = 0.0
            Species%CohortsNumber= 0.0

            if(Species%BySizeOutputHDF .or. Species%BySizeBoxTimeSerie)then

                do iClass = 1, Species%NumberSizeClasses
                    Species%SizeClasses(iClass)%Density = 0.0
                enddo

            end if

            Cohort  => Species%FirstCohort
            do while (associated(Cohort))

                PropertyName_N = trim(adjustl(Cohort%ID%Name))//" number"

                call Search_Property(Property_N,                         &
                                     PropertyXID = GetDynamicPropertyIDNumber(trim(PropertyName_N)), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutput - ModuleWaterProperties - ERR01')

                PropertyName_L = trim(adjustl(Cohort%ID%Name))//" length"

                call Search_Property(Property_L,                         &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_L), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutput - ModuleWaterProperties - ERR10')

                PropertyName_MV = trim(adjustl(Cohort%ID%Name))//" structure"

                call Search_Property(Property_MV,                         &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MV), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutput - ModuleWaterProperties - ERR20')

                PropertyName_ME = trim(adjustl(Cohort%ID%Name))//" reserves"

                call Search_Property(Property_ME,                         &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_ME), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutput - ModuleWaterProperties - ERR30')

                PropertyName_MR = trim(adjustl(Cohort%ID%Name))//" reproduction"

                call Search_Property(Property_MR,                         &
                                     PropertyXID = GetDynamicPropertyIDNumber(PropertyName_MR), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutput - ModuleWaterProperties - ERR40')

do3 :               do k = WorkKLB, WorkKUB
do2 :                do j = WorkJLB, WorkJUB
do1 :                 do i = WorkILB, WorkIUB


                    if (Property_N%Concentration(i,j,k) .gt. 0.0) then !the cohort is not dead

                        Species%TotalDensity(i,j,k) = Species%TotalDensity(i,j,k) +            &
                                                      Property_N%Concentration(i,j,k)

                        if (Property_L%Concentration(i,j,k) .ge. Species%MinObsLength) then

                            Species%FieldDensity(i,j,k) = Species%FieldDensity(i,j,k) + &
                                                          Property_N%Concentration(i,j,k)
                        end if

                        if(Species%BySizeOutputHDF .or. Species%BySizeBoxTimeSerie)then

                            do iClass = 1, Species%NumberSizeClasses

                                if(Property_L%Concentration(i,j,k) .ge. Species%SizeClasses(iClass)%Minimum .and. &
                                   Property_L%Concentration(i,j,k) .lt. Species%SizeClasses(iClass)%Maximum)then

                                    Species%SizeClasses(iClass)%Density(i,j,k) = Species%SizeClasses(iClass)%Density(i,j,k) + &
                                                                                 Property_N%Concentration(i,j,k)

                                endif

                            enddo

                        end if

                        Species%CohortsNumber(i,j,k) = Species%CohortsNumber(i,j,k) + 1

                        Species%TotalBiomass(i,j,k) = Species%TotalBiomass(i,j,k)           +  &
                                                  ( Property_MV%Concentration(i,j,k) +         &
                                                    Property_ME%Concentration(i,j,k) +         &
                                                    Property_MR%Concentration(i,j,k) )   *     &
                                                    Property_N%Concentration(i,j,k) * 12.

                     end if

                  end do do1
                 end do do2
                end do do3

                nullify (Property_N, Property_L, Property_MV, Property_ME, Property_MR)

                Cohort  => Cohort%Next
            enddo

            Species  => Species%Next
        enddo

        if (Me%Bivalve%OutputHDF)then

            call BivalveOutputHDF

        end if

        if (Me%Bivalve%OutputBoxTimeSerie) then

            call BivalveOutputBoxTimeSerie

        end if

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "BivalveOutput")

    end subroutine BivalveOutput

    !--------------------------------------------------------------------------

    subroutine BivalveOutputHDF

        !Arguments-------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Species) , pointer         :: Species
        integer                            :: OutPutNumber, ObjHDF5
        type (T_Time)                      :: CurrentTime, OutTime
        real,    dimension(6    ), target  :: AuxTime
        real,    dimension(:    ), pointer :: TimePtr
        integer                            :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                            :: WorkKLB, WorkKUB
        character(len=StringLength)        :: AuxGroup
        integer                            :: iClass

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "BivalveOutputHDF")

        CurrentTime = Me%ExternalVar%Now

        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB

        ObjHDF5 = Me%Bivalve%ObjHDF5

        !Current output (uses the same as the main HDF output)
        OutPutNumber = Me%OutPut%NextOutPut
        OutTime      = Me%OutPut%OutTime(OutPutNumber)

TOut:   if (CurrentTime >= OutTime) then

            if (Me%EndTime == OutTime) then
                Me%OutPut%Run_End = .true.
            endif

            !Writes current time
            call ExtractDate   (CurrentTime, AuxTime(1), AuxTime(2), AuxTime(3),  &
                                AuxTime(4), AuxTime(5), AuxTime(6))
            TimePtr => AuxTime
            call HDF5SetLimits  (ObjHDF5, 1, 6, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR10')

            call HDF5WriteData  (ObjHDF5, "/Time", "Time", "YYYY/MM/DD HH:MM:SS", &
                                 Array1D = TimePtr, OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR20')

            !Writes SZZ
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB,        &
                                 WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR30')

            call HDF5WriteData  (ObjHDF5, "/Grid/VerticalZ", "Vertical",    &
                                 "m", Array3D = Me%ExternalVar%SZZ,            &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR40')

            !Writes OpenPoints
            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                 &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,        &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR50')

            call HDF5WriteData  (ObjHDF5, "/Grid/OpenPoints", "OpenPoints", &
                                 "-", Array3D = Me%ExternalVar%OpenPoints3D,&
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR60')

            AuxGroup = "/Results/"

            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                     &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,            &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR70')

            Species  => Me%Bivalve%FirstSpecies
            do while (associated(Species))

                call HDF5WriteData(Me%Bivalve%ObjHDF5,                                          &
                                   trim(AuxGroup)//trim(Species%ID%Name)//'/Total Density'    , &
                                   'Total Density',                                             &
                                   '#/m2',                                                      &
                                   Array3D      = Species%TotalDensity,                         &
                                   OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR80')

                call HDF5WriteData(Me%Bivalve%ObjHDF5,                                          &
                                   trim(AuxGroup)//trim(Species%ID%Name)//'/Field Density',     &
                                   'Field Density',                                             &
                                   '#/m2',                                                      &
                                   Array3D      = Species%FieldDensity,                         &
                                   OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR90')

                call HDF5WriteData(Me%Bivalve%ObjHDF5,                                          &
                                   trim(AuxGroup)//trim(Species%ID%Name)//'/Total Biomass',     &
                                   'Total Biomass',                                             &
                                   'gC/m2',                                                     &
                                   Array3D      = Species%TotalBiomass,                         &
                                   OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR100')


                call HDF5WriteData(Me%Bivalve%ObjHDF5,                                          &
                                   trim(AuxGroup)//trim(Species%ID%Name)//'/Cohorts Number',    &
                                   'Cohorts Number',                                            &
                                   '#/m2',                                                      &
                                   Array3D      = Species%CohortsNumber,                        &
                                   OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR101')

                if (Species%BySizeOutputHDF) then

                    do iClass = 1, Species%NumberSizeClasses

                        call HDF5WriteData(Me%Bivalve%ObjHDF5,                                                            &
                         trim(AuxGroup)//trim(Species%ID%Name)//'/SizeClasses/'//trim(Species%SizeClasses(iClass)%Name),  &
                                           trim(Species%SizeClasses(iClass)%Name),                                        &
                                           '#/m2',                                                                        &
                                           Array3D      = Species%SizeClasses(iClass)%Density,                            &
                                           OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR110')

                    enddo

                end if

                Species  => Species%Next
            enddo

            !Writes everything to disk
            call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('BivalveOutputHDF - ModuleWaterProperties - ERR120')

        endif  TOut

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "BivalveOutputHDF")

    end subroutine BivalveOutputHDF

    !--------------------------------------------------------------------------

    subroutine BivalveOutputBoxTimeSerie

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Species),  pointer              :: Species
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: i, j, k, iClass

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "BivalveOutputBoxTimeSerie")

        call BoxDif(Me%Bivalve%ObjBoxDif, Me%ExternalVar%GridCellArea,  &
                    trim('BoxArea'),                                    &
                    Me%ExternalVar%WaterPoints2D,                       &
                    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)  &
            call CloseAllAndStop ('BivalveOutputBoxTimeSerie - ModuleWaterProperties - ERR01')


        Species  => Me%Bivalve%FirstSpecies
        do while (associated(Species))

                !Total Density
                call SetMatrixValue(Me%CellMass, Me%Size, 0.D0)


                do K = KLB, KUB
                do J = JLB, JUB
                do I = ILB, IUB
                    Me%CellMass(i,j,k) = Species%TotalDensity(i, j, k) * &
                                         Me%ExternalVar%GridCellArea(i, j)
                end do
                end do
                end do

                call BoxDif(Me%Bivalve%ObjBoxDif, Me%CellMass,             &
                            trim(Species%ID%Name)//'_'//trim('TotalDensity'),   &
                            Me%ExternalVar%WaterPoints3D,                  &
                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)  &
                    call CloseAllAndStop ('BivalveOutputBoxTimeSerie - ModuleWaterProperties - ERR01')


                !Field Density
                call SetMatrixValue(Me%CellMass, Me%Size, 0.D0)

                do K = KLB, KUB
                do J = JLB, JUB
                do I = ILB, IUB
                    Me%CellMass(i,j,k) = Species%FieldDensity(i, j, k) * &
                                         Me%ExternalVar%GridCellArea(i, j)
                end do
                end do
                end do

                call BoxDif(Me%Bivalve%ObjBoxDif, Me%CellMass,            &
                            trim(Species%ID%Name)//'_'//trim('FieldDensity'),  &
                            Me%ExternalVar%WaterPoints3D,                 &
                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)  &
                    call CloseAllAndStop ('BivalveOutputBoxTimeSerie - ModuleWaterProperties - ERR02')


                !Total Biomass
                call SetMatrixValue(Me%CellMass, Me%Size, 0.D0)

                do K = KLB, KUB
                do J = JLB, JUB
                do I = ILB, IUB
                    Me%CellMass(i,j,k) = Species%TotalBiomass(i, j, k) * &
                                         Me%ExternalVar%GridCellArea(i, j)
                end do
                end do
                end do

                call BoxDif(Me%Bivalve%ObjBoxDif, Me%CellMass,            &
                            trim(Species%ID%Name)//'_'//trim('TotalBiomass'),  &
                            Me%ExternalVar%WaterPoints3D,                 &
                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)  &
                    call CloseAllAndStop ('BivalveOutputBoxTimeSerie - ModuleWaterProperties - ERR03')

                if (Species%BySizeOutputHDF) then

                    do iClass = 1, Species%NumberSizeClasses

                        !ClassDensity
                        call SetMatrixValue(Me%CellMass, Me%Size, 0.D0)


                        do K = KLB, KUB
                        do J = JLB, JUB
                        do I = ILB, IUB
                            Me%CellMass(i,j,k) = Species%SizeClasses(iClass)%Density(i, j, k) * &
                                                 Me%ExternalVar%GridCellArea(i, j)
                        end do
                        end do
                        end do

                        call BoxDif(Me%Bivalve%ObjBoxDif, Me%CellMass                                        , &
                                    trim(Species%ID%Name)//'_'//trim(Species%SizeClasses(iClass)%Name) , &
                                    Me%ExternalVar%WaterPoints3D,                                              &
                                    STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('BivalveOutputBoxTimeSerie - ModuleWaterProperties - ERR05')

                    enddo

                end if

            Species  => Species%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "BivalveOutputBoxTimeSerie")

    end subroutine BivalveOutputBoxTimeSerie

    !--------------------------------------------------------------------------

    subroutine CheckListDeadAndListNewborns

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------

        !to update the cohorts and the property list and build a new mass in teh next time step
        call GetBivalveListDeadIDS(BivalveID         = Me%ObjBivalve         ,  &
                                   ListDeadIDs       = Me%Bivalve%ListDeadIDS,  &
                                   STAT              = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('CheckListDeadAndListNewborns - ModuleWaterProperties - ERR01')


       call GetBivalveNewborns (BivalveID            = Me%ObjBivalve              , &
                                 ListNewbornsIDs     = Me%Bivalve%ListNewbornsIDs , &
                                 MatrixNewborns      = Me%Bivalve%MatrixNewborns  , &
                                 STAT                = STAT_CALL)
       if (STAT_CALL .NE. SUCCESS_) call CloseAllAndStop ('CheckListDeadAndListNewborns - ModuleWaterProperties - ERR02')

       if (associated(Me%Bivalve%ListDeadIDS) .or. associated(Me%Bivalve%ListNewbornsIDs)) then

           call UpdatePropertyList

           call UpdateBivalvePropertyList

           call UpdateInterfaceMass

       end if

       call UnGetBivalve(Me%ObjBivalve, Me%Bivalve%ListDeadIDS, STAT = STAT_CALL)
       if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('CheckListDeadAndListNewborns - ModuleWaterProperties - ERR03')

       call UnGetBivalve(Me%ObjBivalve, Me%Bivalve%ListNewbornsIDs, STAT = STAT_CALL)
       if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('CheckListDeadAndListNewborns - ModuleWaterProperties - ERR04')

       call UnGetBivalve(Me%ObjBivalve, Me%Bivalve%MatrixNewborns, STAT = STAT_CALL)
       if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('CheckListDeadAndListNewborns - ModuleWaterProperties - ERR05')

    end subroutine CheckListDeadAndListNewborns

    !--------------------------------------------------------------------------

    subroutine UpdateInterfaceMass

        !Arguments-----------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: BivalvePropertyList
        integer                                             :: STAT_CALL
        integer                                             :: Index = 0

        Me%Coupled%Bivalve%NumberOfProperties = 0 !reset to recalculate

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%Bivalve)then

                Me%Coupled%Bivalve%NumberOfProperties  = Me%Coupled%Bivalve%NumberOfProperties + 1

            end if

            PropertyX => PropertyX%Next
        enddo

        Index = 0

        !Build List
        nullify (BivalvePropertyList)
        allocate(BivalvePropertyList(1:Me%Coupled%Bivalve%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%Bivalve)then

                Index = Index + 1
                BivalvePropertyList(Index)  = PropertyX%ID%IDNumber

            end if

            PropertyX => PropertyX%Next
        enddo

        nullify(PropertyX)

        call UpdateMassDimensions(InterfaceID         = Me%ObjInterfaceBivalve,        &
                                  PropertiesList      = BivalvePropertyList,           &
                                  STAT = STAT_CALL)
         if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('UpdateInterfaceMass - ModuleWaterProperties - ERR01')

         deallocate(BivalvePropertyList)
         nullify   (BivalvePropertyList)

    end subroutine UpdateInterfaceMass

    !--------------------------------------------------------------------------

    subroutine UpdatePropertyList

        !Arguments-----------------------------------------------------------------

        !Local-----------------------------------------------------------------

        call RemoveDeadIDsFromList

        call AddNewbornsToList

    end subroutine UpdatePropertyList

    !--------------------------------------------------------------------------

    subroutine RemoveDeadIDsFromList
        !Arguments-----------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Species), pointer                   :: Species
        type (T_Cohort), pointer                    :: Cohort
        type (T_Cohort), pointer                    :: CohortToContinue
        integer                                     :: iDeadIDs = 0,nDeadIDs, DynamicCohortID

        nullify(Cohort)
        nullify(Species)
        nullify(CohortToContinue)

        nDeadIDs = size(Me%Bivalve%ListDeadIDS)

        Species  => Me%Bivalve%FirstSpecies
  d1:   do while (associated(Species))

            Cohort  => Species%FirstCohort
       d2:  do while (associated(Cohort))

                iDeadIDs = 1
                DynamicCohortID = GetDynamicPropertyIDNumber(trim(adjustl(Cohort%ID%Name))//" length")

                do iDeadIDs = 1, nDeadIDs

                    if (Me%Bivalve%ListDeadIDS(iDeadIDs) .eq. DynamicCohortID) then

                        nullify(CohortToContinue)

                        CohortToContinue => Cohort%Next

                        call RemoveCohortFromList (Species, Cohort)

                        call RemovePropertyFromList (DynamicCohortID)

                        exit

                    endif

                end do

!                if (associated(Cohort)) Cohort  => Cohort%Next
                if(associated(CohortToContinue)) then
                    Cohort => CohortToContinue
                    nullify(CohortToContinue)
                else
                    if (associated(Cohort)) Cohort  => Cohort%Next
                end if

            end do  d2

            Species  => Species%Next
        enddo  d1

    end subroutine RemoveDeadIDsFromList

    !--------------------------------------------------------------------------

    subroutine RemoveCohortFromList (ObjSpecies, ObjCohort)
        !Arguments-----------------------------------------------------------------
        type (T_Species), pointer                   :: ObjSpecies
        type (T_Cohort), pointer                    :: ObjCohort

        !Local-----------------------------------------------------------------
        type (T_Cohort), pointer                    :: Cohort           => null()
        type (T_Cohort), pointer                    :: PreviousCohort   => null()

        nullify(Cohort, PreviousCohort)

        Cohort  => ObjSpecies%FirstCohort
        do while (associated(Cohort))

            if (Cohort%ID%ID .eq. ObjCohort%ID%ID) then  !this is the cohort to be removed

                if(associated(PreviousCohort))then
                    PreviousCohort%Next      => Cohort%Next
                else
                    ObjSpecies%FirstCohort   => Cohort%Next
                end if

                ObjSpecies%nCohorts  = ObjSpecies%nCohorts - 1

                write(*,*)trim(adjustl(Cohort%ID%Name))// "....weeeggg!!!"

                if(ObjSpecies%LarvaeTransport)then
                    deallocate (Cohort%Larvae     )
                    deallocate (Cohort%AuxLarvaeL )
                    deallocate (Cohort%AuxLarvaeME)
                    deallocate (Cohort%AuxLarvaeMV)
                    deallocate (Cohort%AuxLarvaeMH)
                    deallocate (Cohort%AuxLarvaeMR)
                    deallocate (Cohort%AuxLarvaeN )
                endif

                deallocate    (Cohort)
                nullify       (Cohort)

                cycle

            else

                PreviousCohort => Cohort
                Cohort  => Cohort%Next

            endif

        enddo

        nullify(ObjCohort)

    end subroutine RemoveCohortFromList

    !--------------------------------------------------------------------------
    subroutine RemovePropertyFromList (DynamicCohortID)
        !Arguments-----------------------------------------------------------------
        integer, intent (in)                        :: DynamicCohortID

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: Property         => null()
        type (T_Property), pointer                  :: PreviousProperty => null()
        integer                                     :: PropDynamicID
        integer                                     :: iProp

        nullify(Property, PreviousProperty)

        do iProp = 0, 6

            PropDynamicID = DynamicCohortID + iProp

            Property  => Me%FirstProperty
            do while (associated(Property))

                if (Property%ID%IDNumber .eq. PropDynamicID) then  !this is the cohort to be removed

                    if(Property%Evolution%MinConcentration .or. Property%Evolution%MaxConcentration)then
                        call ComputeAndLogTotalMassError(Property)
                    endif

                    Me%Bivalve%nPropertiesFromBivalve = Me%Bivalve%nPropertiesFromBivalve - 1

                    if(associated(PreviousProperty))then
                        PreviousProperty%Next  => Property%Next
                        Property%Prev          => PreviousProperty
                    else
                        Me%FirstProperty       => Property%Next
                        Me%FirstProperty%Prev  => null()
                    end if

                    if(.not. associated(Property%Next))then
                        Me%LastProperty        => PreviousProperty
                    endif

                    Me%PropertiesNumber = Me%PropertiesNumber - 1

                    deallocate    (Property)
                    nullify       (Property)

                    cycle

                else

                    PreviousProperty => Property
                    Property  => Property%Next

                endif

            enddo

        enddo

    end subroutine RemovePropertyFromList

    !--------------------------------------------------------------------------

    subroutine AddNewbornsToList
        !Arguments-----------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Species), pointer                   :: Species
        type (T_Cohort), pointer                    :: NewCohort
        integer                                     :: iSpeciesID, SpeciesID

        Species  => Me%Bivalve%FirstSpecies
  d1:   do while (associated(Species))

            do iSpeciesID = 1, Me%Bivalve%nSpecies

                SpeciesID = Me%Bivalve%ListNewbornsIDs(iSpeciesID)

                if (Species%ID%IDNumber .eq. SpeciesID) then !this species has new borns

                    allocate(NewCohort)

                    call AddCohort (Species, NewCohort)

                    call ConstructNewBornCohort (Species, NewCohort)

                    nullify(NewCohort)

                end if

            enddo

            Species  => Species%Next
        enddo  d1

    end subroutine AddNewbornsToList

    !--------------------------------------------------------------------------
    !   Makes the connection between the Water
    !   Properties module and the Partition processes

    subroutine Partition_Processes

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PartPropX
        type (T_Property), pointer              :: PropertyX
        type (T_Property), pointer              :: Salinity
        type (T_Property), pointer              :: CohesiveSediment
        real                                    :: DT, MassTransfer
        real                                    :: DissolvedFraction
        real                                    :: ParticulateFraction
        real                                    :: TransferRate
        real                                    :: ReferencePartitionCoef
        real                                    :: PartitionCoef
        real                                    :: b, SalinityConcentration
        real                                    :: RefSedFactor
        integer                                 :: STAT_CALL
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: i, j, k, kbottom
        integer                                 :: Couple_ID
        integer                                 :: CHUNK

        !Begin----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB


        PropertyX => Me%FirstProperty

do0:    do while(associated(PropertyX))
cd0:        if(.not. PropertyX%ID%IsParticulate .and. PropertyX%Evolution%Partitioning) then

cd1:            if(Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

                    Couple_ID = PropertyX%Evolution%Partition%Couple_ID

                    call Search_Property(PartPropX, PropertyXID = Couple_ID, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call CloseAllAndStop ('Partition_Processes - ModuleWaterProperties - ERR02')

                    call Search_Property(CohesiveSediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                      &
                        call CloseAllAndStop ('Partition_Processes - ModuleWaterProperties - ERR03')


                    if (PropertyX%Evolution%Partition%SalinityEffect) then

                        call Search_Property(Salinity, PropertyXID = Salinity_, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('Partition_Processes - ModuleWaterProperties - ERR03')
                    endif


                    DT = PropertyX%Evolution%DtInterval

                    CHUNK = CHUNK_J(JLB, JUB)

                    if (MonitorPerformance) then
                        call StartWatch ("ModuleWaterProperties", "Partition_Processes")
                    endif

                    !$OMP PARALLEL PRIVATE(i,j,k,kbottom,ReferencePartitionCoef,b) &
                    !$OMP PRIVATE(SalinityConcentration,PartitionCoef,DissolvedFraction) &
                    !$OMP PRIVATE(ParticulateFraction,RefSedFactor,TransferRate,MassTransfer)

                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:                do j = JLB, JUB
do2:                do i = ILB, IUB

cd2:                    if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            kbottom = Me%ExternalVar%KFloor_Z(i, j)

do3:                        do k = kbottom, KUB

                                if (PropertyX%Evolution%Partition%SalinityEffect) then

                                    ReferencePartitionCoef = PartPropX%Evolution%Partition%Fraction / &
                                                             PropertyX%Evolution%Partition%Fraction

                                    b                      = PropertyX%Evolution%Partition%EmpiricCoef

                                    if (Salinity%Concentration(i, j, k) > 36.) then

                                        SalinityConcentration = 0.036

                                    else

                                        SalinityConcentration = Salinity%Concentration(i, j, k) / 1000.

                                    endif

                                    PartitionCoef       = (1. + SalinityConcentration)**b *  &
                                                           ReferencePartitionCoef

                                    DissolvedFraction   = 1. / (1. + PartitionCoef)

                                    ParticulateFraction = PartitionCoef / (1. + PartitionCoef)


                                else

                                    DissolvedFraction   = PropertyX%Evolution%Partition%Fraction

                                    ParticulateFraction = PartPropX%Evolution%Partition%Fraction

                                endif

                                if(PropertyX%Evolution%Partition%UseSedimentRefConc)then

                                    RefSedFactor = CohesiveSediment%Concentration(i,j,k) / &
                                                   PropertyX%Evolution%Partition%SedimentRefConc

                                    if(RefSedFactor < 1.)then

                                        TransferRate = PropertyX%Evolution%Partition%Rate * RefSedFactor

                                    else

                                        TransferRate = PropertyX%Evolution%Partition%Rate

                                    end if

                                else

                                    TransferRate = PropertyX%Evolution%Partition%Rate

                                end if

                                ! [mol/l]       =          [s]         * [s^-1]        * [mol/l]
                                MassTransfer    =         DT * TransferRate *          &
                                (DissolvedFraction   * PartPropX%Concentration(i, j, k) -        &
                                 ParticulateFraction * PropertyX%Concentration(i, j, k))

                                PartPropX%Concentration(i, j, k) =                               &
                                                   PartPropX%Concentration(i, j, k) - MassTransfer


                                PropertyX%Concentration(i, j, k) =                               &
                                                   PropertyX%Concentration(i, j, k) + MassTransfer

                               if (PropertyX%Evolution%Partition%NonComplianceCriteria) then
                                 if (PropertyX%Concentration(i, j, k) >= PropertyX%Evolution%Partition%MaxConc) then
                                    write(*,*)'Non Compliance criteria has been reached'
                                    write (*,*) 'In cell -',i,j,k
                                    write(*,*)'Property ', trim(PropertyX%ID%Name)
                                 end if
                               end if


                            enddo do3
                        endif cd2
                    enddo do2
                    enddo do1
                    !$OMP END DO
                    !$OMP END PARALLEL
                    if (MonitorPerformance) then
                        call StopWatch ("ModuleWaterProperties", "Partition_Processes")
                    endif

            endif cd1
            endif cd0

            PropertyX=>PropertyX%Next

        enddo do0


        nullify (PropertyX, PartPropX, Salinity)

    end subroutine Partition_Processes

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing the
    ! free vertical movement processes

    subroutine FreeVerticalMovements_Processes


        !External--------------------------------------------------------------

        type (T_Property), pointer          :: Property, Salinity
        type (T_Property), pointer          :: CohesiveSediment
        integer                             :: STAT_CALL
        integer                             :: ILB, IUB , JLB, JUB, KLB, KUB, i, j, k
        integer                             :: WILB, WIUB , WJLB, WJUB, WKLB, WKUB
        real, dimension(:,:,:), pointer     :: SalinityConcentration
        real, dimension(:,:,:), pointer     :: CohesiveSedimentConcentration
        real                                :: CohesiveSedimentISCoef

        !Local -----------------------------------------------------------------
        logical                             :: NeedsSalinity, NeedsSPM
        integer                             :: CHUNK
        !-----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        WILB = Me%WorkSize%ILB
        WIUB = Me%WorkSize%IUB
        WJLB = Me%WorkSize%JLB
        WJUB = Me%WorkSize%JUB
        WKLB = Me%WorkSize%KLB
        WKUB = Me%WorkSize%KUB


        nullify(Property)
        nullify(Salinity, CohesiveSediment)
        nullify(SalinityConcentration, CohesiveSedimentConcentration)

        call GetFreeVertMovOptions(FreeVerticalMovementID = Me%ObjFreeVerticalMovement, &
                                   Salinity               = NeedsSalinity,              &
                                   SPM                    = NeedsSPM,                   &
                                   STAT                   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            call CloseAllAndStop ('FreeVerticalMovements_Processes - ModuleWaterProperties - ERR01')

        if(NeedsSalinity)then

            call Search_Property(Salinity,PropertyXID = Salinity_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('FreeVerticalMovements_Processes - ModuleWaterProperties - ERR02')

            SalinityConcentration => Salinity%Concentration

        end if

        if(NeedsSPM)then

            call Search_Property(CohesiveSediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
            if(STAT_CALL /= SUCCESS_)then
                write(*,*)'Property Cohesive sediment must be defined if settling'
                write(*,*)'velocity is not defined as constant.'
                call CloseAllAndStop ('FreeVerticalMovements_Processes - ModuleWaterProperties - ERR03')
            end if

            CHUNK = CHUNK_J(WJLB, WJUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleWaterProperties", "FreeVerticalMovements_Processes")
            endif

            !$OMP PARALLEL PRIVATE(I,J,K)
            do k = WKLB,WKUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = WJLB,WJUB
            do i = WILB,WIUB
                if(Me%ExternalVar%WaterPoints3D(i,j,k) == WaterPoint)then

                    !Just a test...
                    if (CohesiveSediment%Concentration(i,j,k) < 0.) then
                        !$OMP CRITICAL (FVMP1_ERR04)
                        write (*,*)
                        write (*,*) 'In cell -',i,j,k
                        write (*,*) 'the Cohesive Sediment concentration is negative.'
                        call CloseAllAndStop ('FreeVerticalMovements_Processes - ModuleWaterProperties - ERR04')
                        !$OMP END CRITICAL (FVMP1_ERR04)
                    end if
                end if

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleWaterProperties", "FreeVerticalMovements_Processes")
            endif

            CohesiveSedimentISCoef        =  CohesiveSediment%IScoefficient

            CohesiveSedimentConcentration => CohesiveSediment%Concentration

        end if


        Property => Me%FirstProperty

do1:    do while (associated(Property))
cd0:        if (Property%Evolution%FreeVerticalMovement) then
cd1:            if (Me%ExternalVar%Now.GE.Property%Evolution%NextCompute) then

                    Property%Evolution%SetLimitsTrigger = .true.

                    call Modify_FreeVerticalMovement(Me%ObjFreeVerticalMovement,        &
                                                     Property%Concentration,            &
                                                     CohesiveSedimentConcentration,     &
                                                     CohesiveSedimentISCoef,            &
                                                     SalinityConcentration,             &
                                                     Property%ID%IDNumber,              &
                                                     Property%IScoefficient,            &
                                                     Property%Evolution%DTInterval,     &
                                                     Me%ExternalVar%Now,                &
                                                     NoFlux  = Me%NoFlux%ON,            &
                                                     NoFluxW = Me%NoFlux%W,             &
                                                     STAT    = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                       call CloseAllAndStop ('FreeVerticalMovements_Processes - ModuleWaterProperties - ERR04')

            end if cd1
            end if cd0

            Property => Property%Next
        end do do1

        nullify(Property        )
        nullify(Salinity        )
        nullify(CohesiveSediment)

    end subroutine FreeVerticalMovements_Processes

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing the
    ! filtration processes
    subroutine Filtration_Processes

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX, ExcretedProperty, GrazedProperty
        real                                    :: DT
        real                                    :: FiltrationRate
        real                                    :: OldConcentration
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: i, j, k, kbottom
        integer                                 :: STAT_CALL, Excreted_Property_ID
        real                                    :: StoichiometricRatio, AssimilationEfficiency
        real                                    :: FilteredMass, AuxConc
        integer                                 :: CHUNK

        !Begin----------------------------------------------------------------------

        ILB             = Me%WorkSize%ILB
        IUB             = Me%WorkSize%IUB
        JLB             = Me%WorkSize%JLB
        JUB             = Me%WorkSize%JUB
        KUB             = Me%WorkSize%KUB

        !l/h = 0.001m3/3600s
        !UnitsCoef = 0.001/3600.

        PropertyX => Me%FirstProperty

do0:    do while(associated(PropertyX))

cd0:        if (PropertyX%Evolution%Filtration%On .and. .not. PropertyX%Evolution%Filtration%Freeze) then

cd1:            if(Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

                    if (PropertyX%Evolution%Filtration%TypeOf == Grazer) then

                        call Search_Property(GrazedProperty,                            &
                                             PropertyXID = PropertyX%Evolution%Filtration%GrazedPropID, &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) then
                            write(*,*)'Cant find property to be grazed by filtration'
                            write(*,*)'Property that  grazes by filtration = ', trim(PropertyX%ID%Name)
                            write(*,*)'Property being grazed by filtration = ', trim(GrazedProperty%ID%Name)
                            call CloseAllAndStop ('Filtration_Processes - ModuleWaterProperties - ERR10')
                        endif

                    endif


                    DT  = PropertyX%Evolution%DtInterval

                    CHUNK = CHUNK_J(JLB, JUB)

                    if (MonitorPerformance) then
                        call StartWatch ("ModuleWaterProperties", "Filtration_Processes")
                    endif

                    !$OMP PARALLEL PRIVATE(i,j,k,kbottom,OldConcentration,FiltrationRate,FilteredMass)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:                do j = JLB, JUB
do2:                do i = ILB, IUB

cd2:                    if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            kbottom = Me%ExternalVar%KFloor_Z(i, j)

do3:                        do k = kbottom, KUB

                                OldConcentration = PropertyX%Concentration(i, j, k)


                                if      (PropertyX%Evolution%Filtration%TypeOf == GrazeD) then
                                    AuxConc = OldConcentration
                                else if (PropertyX%Evolution%Filtration%TypeOf == GrazeR) then
                                    AuxConc = GrazedProperty%Concentration(i, j, k)
                                endif

                                if(AuxConc .gt. PropertyX%Evolution%Filtration%MinConcentrationToFilter)then

                                    !Adapt the filtration rate in a way that the grazeD property concentration
                                    !is consistent with the the grazeR property
                                    FiltrationRate  = PropertyX%Evolution%Filtration%Rate(i, j, k) * &
                                                      PropertyX%Evolution%Filtration%UnitsCoef

                                else

                                    FiltrationRate = 0.

                                end if

                                if      (PropertyX%Evolution%Filtration%TypeOf == GrazeD) then
                                    ! [1/s]
                                    FiltrationRate  = FiltrationRate  / Me%ExternalVar%VolumeZ (i, j, k)
                                    !mg/l = (mg/l)/( s * s-1)
                                    !implicit resolution
                                    PropertyX%Concentration(i, j, k) = OldConcentration / (1 + DT * FiltrationRate)
                                else if (PropertyX%Evolution%Filtration%TypeOf == GrazeR) then
                                    !explicit resolution
                                    PropertyX%Concentration(i, j, k) = OldConcentration + &
                                        GrazedProperty%Concentration(i, j, k) * DT * FiltrationRate
                                endif

                                !g = mg/l * m3
                                FilteredMass = (OldConcentration-PropertyX%Concentration(i, j, k))* &
                                                Me%ExternalVar%VolumeZ (i, j, k)

                                !g/s = g / s
                                PropertyX%Filtration(i, j, k) = FilteredMass / DT

                                If (FilteredMass .ne. 0.)  then

                                    !tons = g/1e6
                                    FilteredMass = FilteredMass/1000000.

                                    !tons = tons + tons
                                    PropertyX%Evolution%Filtration%Cumulative(i,j,k) =              &
                                        PropertyX%Evolution%Filtration%Cumulative(i,j,k)          + &
                                        FilteredMass

                                    !tons/m = tons/m + tons/m
                                    PropertyX%Evolution%Filtration%CumulativePerMeter(i,j,k) =    &
                                        PropertyX%Evolution%Filtration%CumulativePerMeter(i,j,k)  + &
                                        FilteredMass                                              / &
                                        Me%ExternalVar%DWZ(i,j,k)


                                End If

                            enddo do3

                        endif cd2

                    enddo do2
                    enddo do1
                    !$OMP END DO

                    if(PropertyX%Evolution%Filtration%Excretions)then

                        !$OMP MASTER
                        Excreted_Property_ID = PropertyX%Evolution%Filtration%Excreted_Property_ID

                        call Search_Property(ExcretedProperty,                          &
                                             PropertyXID = Excreted_Property_ID,        &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) then
                            write(*,*)'Cant find property to be excreted after filtration'
                            write(*,*)'Property being filtered = ', trim(PropertyX%ID%Name)
                            call CloseAllAndStop ('Filtration_Processes - ModuleWaterProperties - ERR01')
                        endif

                        StoichiometricRatio     = PropertyX%Evolution%Filtration%StoichiometricRatio
                        AssimilationEfficiency  = PropertyX%Evolution%Filtration%AssimilationEfficiency
                        !$OMP END MASTER
                        !$OMP BARRIER

                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = JLB, JUB
                        do i = ILB, IUB

                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                kbottom = Me%ExternalVar%KFloor_Z(i, j)

                                do k = kbottom, KUB

                                    !mg/l = mg/l + mg/s * s / m3
                                    ExcretedProperty%Concentration(i,j,k) =             &
                                                ExcretedProperty%Concentration(i,j,k) + &
                                                PropertyX%Filtration(i, j, k)  * DT   / &
                                                Me%ExternalVar%VolumeZ (i, j, k)      * &
                                                StoichiometricRatio  * (1. - AssimilationEfficiency)

                                enddo

                            endif

                        enddo
                        enddo
                        !$OMP END DO

                    end if
                    !$OMP END PARALLEL

                    if (MonitorPerformance) then
                        call StopWatch ("ModuleWaterProperties", "Filtration_Processes")
                    endif

                endif cd1

            endif cd0

            nullify(ExcretedProperty)

            PropertyX=>PropertyX%Next

        enddo do0


        nullify (PropertyX)


    end subroutine Filtration_Processes

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for reinitialize the solution
    subroutine Reinitialize_Solution

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
        integer                                 :: ILB, IUB, JLB, JUB, KUB, BN
        integer                                 :: i, j, k, kbottom, BoxCells
        integer                                 :: CHUNK

        !Begin----------------------------------------------------------------------

        ILB             = Me%WorkSize%ILB
        IUB             = Me%WorkSize%IUB
        JLB             = Me%WorkSize%JLB
        JUB             = Me%WorkSize%JUB
        KUB             = Me%WorkSize%KUB

        PropertyX => Me%FirstProperty

do0:    do while(associated(PropertyX))

cd0:        if (PropertyX%Evolution%Reinitialize%On) then

cd1:            if(Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

dbn:                do BN = 1, PropertyX%Evolution%Reinitialize%BoxesNumber

cd2:                    if(Me%ExternalVar%Now .GE. PropertyX%Evolution%Reinitialize%Dates(BN)&
                           .and. PropertyX%Evolution%Reinitialize%OnlyOnce(BN)) then

                            CHUNK = CHUNK_J(JLB, JUB)

                            if (MonitorPerformance) then
                                call StartWatch ("ModuleWaterProperties", "Reinitialize_Solution")
                            endif

                            !$OMP PARALLEL PRIVATE(i,j,k,kbottom,BoxCells)
                            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do1:                        do j = JLB, JUB
do2:                        do i = ILB, IUB

cd3:                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                    kbottom = Me%ExternalVar%KFloor_Z(i, j)

do3:                                do k = kbottom, KUB

                                        BoxCells = PropertyX%Evolution%Reinitialize%BoxCells(i, j)

                                        if (BoxCells == BN) then

                                            PropertyX%Concentration(i, j, k) =          &
                                                PropertyX%Evolution%Reinitialize%BoxesValues(BoxCells)

                                        endif

                                    enddo do3

                                endif cd3

                            enddo do2
                            enddo do1
                            !$OMP END DO
                            !$OMP END PARALLEL

                            if (MonitorPerformance) then
                                call StopWatch ("ModuleWaterProperties", "Reinitialize_Solution")
                            endif

                            PropertyX%Evolution%Reinitialize%OnlyOnce(BN) = .false.

                        endif cd2

                    enddo dbn
                endif cd1


            endif cd0

            PropertyX=>PropertyX%Next

        enddo do0


        nullify (PropertyX)

    end subroutine Reinitialize_Solution

    !--------------------------------------------------------------------------

    subroutine ChemicalLinks

        !Arguments-------------------------------------------------------------
        !Local-----------------------------------------------------------------
        integer                                         :: index
        integer                                         :: ILB, IUB, JLB, JUB, KUB
        integer                                         :: i, j, comp_i
        real                                            :: change_in_mass
        type(T_Property), pointer                       :: species
        type(T_Property), pointer                       :: component
        type(T_ChemLink), pointer                       :: link
        real                                            :: n_atoms

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        do index = 1, Me%ChemLinks%NumberOfLinks

            link => Me%ChemLinks%Links(index)
            species => link%Species

            select case (species%ID%IDNumber)
            case (CarbonDioxide_)

                do j=JLB, JUB
                do i=ILB, IUB
                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    !The CO2 Surface Flux is in mmol.m-2.s-1
                    !It is necessary to transform it to mg.
                    !The equation to do this is:
                    !
                    !mg      = mmol.m-2.s-1 * s  *    m2    * mg/mmol
                    !CO2mass =   CO2Flux    * DT * CellArea * GFW
                    !
                    !The GFW is given in g/mol, but the value is the same when you
                    !change it to mg/mmol

                    change_in_mass = species%SurfaceFlux(i,j) * species%Evolution%DTInterval *  &
                                     Me%ExternalVar%gridCellArea(i, j) * species%GFW

                    do comp_i = 1, link%NumberOfComponents

                        component => link%Components(comp_i)%Property
                        n_atoms = real(link%Components(comp_i)%NumberOfAtoms)

                        component%Concentration(i,j,KUB) = component%Concentration(i,j,KUB) - &
                                             (component%GFW * n_atoms / species%GFW) * change_in_mass / &
                                             Me%ExternalVar%VolumeZ(i,j,KUB) / 1000.0


                    enddo

                endif
                enddo
                enddo

            case (Oxygen_)

                do j=JLB, JUB
                do i=ILB, IUB
                if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                    !The O2 Surface Flux is in mg.s-1
                    !It is necessary to transform it to mg.
                    !The equation to do this is:
                    !
                    !mg     =   mg.s-1 * s
                    !O2mass =   O2Flux * DT

                    change_in_mass = species%SurfaceFlux(i,j) * species%Evolution%DTInterval

                    do comp_i = 1, link%NumberOfComponents

                        component => link%Components(comp_i)%Property
                        n_atoms = real(link%Components(comp_i)%NumberOfAtoms)

                        component%Concentration(i,j,KUB) = component%Concentration(i,j,KUB) - &
                                             (component%GFW * n_atoms / species%GFW) * change_in_mass / &
                                             Me%ExternalVar%VolumeZ(i,j,KUB) / 1000.0

                    enddo

                endif
                enddo
                enddo

            case default
                call CloseAllAndStop ('ChemicalLinks - ModuleWaterProperties - ERR010')
            end select

        enddo

    end subroutine ChemicalLinks

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing the
    ! surface processes

    subroutine Surface_Processes


        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: Property, PropTemperature
        type (T_Property), pointer                  :: PropSalinity
        type (T_Time)                               :: Actual
        integer                                     :: STAT_CALL
        integer                                     :: ILB, IUB, JLB, JUB, KUB, i, j
        real                                        :: DOSAT, CO2PP
        real                                        :: Palt, pressure, Aux1, Aux2, Aux3

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Surface_Processes")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        !----------------------------------------------------------------------

        Actual = Me%ExternalVar%Now

        Property => Me%FirstProperty

do1 :   do while (associated(Property))
cd1 :   if (Property%Evolution%SurfaceFluxes) then
cd2 :   if (Actual.GE.Property%Evolution%NextCompute) then

            Property%Evolution%SetLimitsTrigger = .true.


case1 :     select case(Property%ID%IDNumber)

                case(Temperature_)

                    !Because of the radiation penetration in the water column
                    !the heat surface fluxes must be compute in a different way from
                    !the other properties
                    call ComputeSurfaceHeatFluxes (Property)

!                case(Salinity_)


                case (Oxygen_)

                    !Search the temperature
                    call Search_Property(PropTemperature, PropertyXID = Temperature_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*)'Cant calculate oxygen flux through surface without temperature'
                        call CloseAllAndStop ('Surface_Processes - ModuleWaterProperties - ERR04')
                    endif

                    !Search the salinity
                    call Search_Property(PropSalinity, PropertyXID = Salinity_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*)'Cant calculate oxygen flux through surface without salinity'
                        call CloseAllAndStop ('Surface_Processes - ModuleWaterProperties - ERR05')
                    endif


                    if (Me%DoSatType.eq.Apha) then

                        !$OMP PARALLEL PRIVATE(i,j,DOSAT,Aux1,Aux2,Aux3)
                        !$OMP DO SCHEDULE(DYNAMIC, CHUNKJ)
                        do j=JLB, JUB
                        do i=ILB, IUB

                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                DOSAT = OxygenSaturation(PropTemperature%Concentration(i,j,KUB), &
                                                         PropSalinity%Concentration(i,j,KUB))

                                ![s/L] = [s] * [L2] / [L3]
                                Aux1                           = Property%Evolution%DTInterval      * &
                                                                 Me%ExternalVar%gridCellArea(i, j)  / &
                                                                 Me%ExternalVar%VolumeZ(i,j,KUB)

                                ![ ]                          =  [L/s] * [s/L]
                                Aux2                          =  Me%ExtSurface%OxygenFlux(i, j) * Aux1

                                ![Concentration]               = [] * [Concentration]
                                Aux3                           = Aux2 * DOSAT


                                !New Concentration - implicit computation to avoid instability problems
                                Property%Concentration(i, j, KUB) = (Property%Concentration(i, j, KUB) + Aux3) / (1.0 + Aux2)


                                Property%SurfaceFlux(i, j) = Me%ExtSurface%OxygenFlux(i, j) * &
                                                             (DOSAT - Property%Concentration(i,j,KUB))


                            endif
                        enddo
                        enddo
                        !$OMP END DO NOWAIT
                        !$OMP END PARALLEL


                    else if (Me%DoSatType.eq.Henry) then

                        !$OMP PARALLEL PRIVATE(i,j,DOSAT,Aux1,Aux2,Aux3)
                        !$OMP DO SCHEDULE(DYNAMIC, CHUNKJ)
                        do j=JLB, JUB
                        do i=ILB, IUB

                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                DOSAT = OxygenSaturationHenry(PropTemperature%Concentration(i,j,KUB))


                                ![s/L] = [s] * [L2] / [L3]
                                Aux1                           = Property%Evolution%DTInterval      * &
                                                                 Me%ExternalVar%gridCellArea(i, j)  / &
                                                                 Me%ExternalVar%VolumeZ(i,j,KUB)

                                ![ ]                          =  [L/s] * [s/L]
                                Aux2                          =  Me%ExtSurface%OxygenFlux(i, j) * Aux1

                                ![Concentration]               = [] * [Concentration]
                                Aux3                           = Aux2 * DOSAT


                                !New Concentration - implicit computation to avoid instability problems
                                Property%Concentration(i, j, KUB) = (Property%Concentration(i, j, KUB) + Aux3) / (1.0 + Aux2)


                                Property%SurfaceFlux(i, j) = Me%ExtSurface%OxygenFlux(i, j) * &
                                                             (DOSAT - Property%Concentration(i,j,KUB))
                            endif
                        enddo
                        enddo
                        !$OMP END DO NOWAIT
                        !$OMP END PARALLEL

                    else if (Me%DoSatType.eq.Mortimer) then

                        !altitude correction

                        Palt =(1-((Me%Altitude)/1000)/44.3)**5.25

                        !$OMP PARALLEL PRIVATE(i,j,DOSAT,Aux1,Aux2,Aux3)
                        !$OMP DO SCHEDULE(DYNAMIC, CHUNKJ)
                        do j=JLB, JUB
                        do i=ILB, IUB

                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                DOSAT = OxygenSaturationCeQualW2(PropTemperature%Concentration(i,j,KUB), &
                                                                 PropSalinity%Concentration(i,j,KUB), &
                                                                 Palt)


                                ![s/L] = [s] * [L2] / [L3]
                                Aux1                           = Property%Evolution%DTInterval      * &
                                                                 Me%ExternalVar%gridCellArea(i, j)  / &
                                                                 Me%ExternalVar%VolumeZ(i,j,KUB)

                                ![ ]                          =  [L/s] * [s/L]
                                Aux2                          =  Me%ExtSurface%OxygenFlux(i, j) * Aux1

                                ![Concentration]               = [] * [Concentration]
                                Aux3                           = Aux2 * DOSAT


                                !New Concentration - implicit computation to avoid instability problems
                                Property%Concentration(i, j, KUB) = (Property%Concentration(i, j, KUB) + Aux3) / (1 + Aux2)


                                Property%SurfaceFlux(i, j) = Me%ExtSurface%OxygenFlux(i, j) * &
                                                             (DOSAT - Property%Concentration(i,j,KUB))
                            endif
                        enddo
                        enddo
                        !$OMP END DO NOWAIT
                        !$OMP END PARALLEL

                    endif


                case (CarbonDioxide_)

                    !Search the temperature
                    call Search_Property(PropTemperature, PropertyXID = Temperature_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*)'Cant calculate carbon dioxide flux through surface without temperature'
                        call CloseAllAndStop ('Surface_Processes - ModuleWaterProperties - ERR04')
                    endif

                    !Search the salinity
                    call Search_Property(PropSalinity, PropertyXID = Salinity_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*)'Cant calculate carbon dioxide flux through surface without salinity'
                        call CloseAllAndStop ('Surface_Processes - ModuleWaterProperties - ERR05')
                    endif


                    Pressure = 0.01

                    !$OMP PARALLEL PRIVATE(i,j,CO2PP)
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNKJ)
                    do j=JLB, JUB
                    do i=ILB, IUB

                        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            !CO2 partial pressure on water
                            CO2PP = CO2PartialPressure(Property%Concentration(i,j,KUB), &
                                    PropTemperature%Concentration(i,j,KUB),             &
                                    PropSalinity%Concentration(i,j,KUB),                &
                                    Pressure, Me%Density%Field(i,j,KUB))

                            !0.24 * 1E-3 * 1025.  -> units conversion (cm h-1 to m s-1)
                            !CarbonDioxideFlux    -> gas transfer velocity, k (m s-1)
                            !CO2_K0               -> mol kg-1 atm-1)
                            !SurfaceFlux          -> mmol m-2 s-1
                            Property%SurfaceFlux(i, j) =  0.24 * 1E-3 * 1025.                           *  &
                                                          Me%ExtSurface%CarbonDioxideFlux(i, j)         *  &
                                                          CO2_K0(PropTemperature%Concentration(i,j,KUB),   &
                                                                 PropSalinity%Concentration(i,j,KUB))   *  &
                                                          (CO2PP - 387.)

                            !New Concentration
                            !print *, trim(Property%ID%Name)
                            !print *, 'SF - Before (', i, j, KUB, '): ', Property%Concentration(i, j, KUB)
                            Property%Concentration(i, j, KUB) = Property%Concentration(i, j, KUB)       -  &  !in mg l-1
                                                                (Property%SurfaceFlux(i, j)             *  &
                                                                Property%Evolution%DTInterval           *  &
                                                                Me%ExternalVar%gridCellArea(i, j)       /  &
                                                                Me%ExternalVar%VolumeZ(i,j,KUB))        *  &
                                                                (44. / 1000.) !convert mmol m-3 to mg l-1
                            !print *, 'SF - After (', i, j, KUB, '): ', Property%Concentration(i, j, KUB)


                        endif

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    !$OMP END PARALLEL

                case (Ammonia_)

                    !$OMP PARALLEL PRIVATE(i,j)
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNKJ)
                    do j=JLB, JUB
                    do i=ILB, IUB
                        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            Property%SurfaceFlux(i, j) = Me%ExtSurface%AmmoniaFlux(i, j)

                            Property%Concentration(i, j, KUB) = Property%Concentration(i, j, KUB)       +  & !mg l-1
                                                                (Property%SurfaceFlux(i, j)             *  & !mg m-2 s-1 N
                                                                Property%Evolution%DTInterval           *  & !s
                                                                Me%ExternalVar%gridCellArea(i, j)       /  & !m2
                                                                Me%ExternalVar%VolumeZ(i,j,KUB))        *  & !LLP m3  mg m-3
                                                                (1./1000.)!convert mg m-3 to mg l-1
                        endif

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    !$OMP END PARALLEL

                case (Nitrate_)

                    !$OMP PARALLEL PRIVATE(i,j)
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNKJ)
                    do j=JLB, JUB
                    do i=ILB, IUB
                        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            Property%SurfaceFlux(i, j) = Me%ExtSurface%NitrateFlux(i, j)

                            Property%Concentration(i, j, KUB) = Property%Concentration(i, j, KUB)       +  & !mg l-1
                                                                (Property%SurfaceFlux(i, j)             *  & !mg/m2 s N
                                                                Property%Evolution%DTInterval           *  & !
                                                                Me%ExternalVar%gridCellArea(i, j)       /  & !m2
                                                                Me%ExternalVar%VolumeZ(i,j,KUB))        *  & !LLP m3  mg m-3
                                                                (1./1000.)!convert mg m-3 to mg l-1
                        endif

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    !$OMP END PARALLEL

                case default

            end select case1


        end if cd2
        end if cd1

        Property => Property%Next
        end do do1

        nullify(Property)

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Surface_Processes")

        !----------------------------------------------------------------------

    end subroutine Surface_Processes

    !----------------------------------------------------------------------

    subroutine Bottom_Processes

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyX
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, Kbottom
        integer                                     :: CHUNK

        !Begin----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_J(JLB, JUB)

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))
            if (PropertyX%Evolution%BottomFluxes) then
                if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                    if (MonitorPerformance) then
                        call StartWatch ("ModuleWaterProperties", "Bottom_Processes")
                    endif

                    !$OMP PARALLEL PRIVATE(I,J,kbottom)
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do j=JLB, JUB
                    do i=ILB, IUB

                        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            kbottom = Me%ExternalVar%KFloor_Z(i,j)

                            !kg/m3 = kg/m3 + kg/m2s * m2 * s / m3
                            PropertyX%Concentration(i, j, kbottom) = &
                                         PropertyX%Concentration(i,j,kbottom) + &
                                         PropertyX%BottomFlux(i,j)            * &
                                         Me%ExternalVar%GridCellArea(i,j)     * &
                                         PropertyX%Evolution%DTInterval       / &
                                         Me%ExternalVar%VolumeZ(i,j,kbottom)  / &
                                         PropertyX%ISCoefficient
                        endif

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    if (MonitorPerformance) then
                        call StopWatch ("ModuleWaterProperties", "Bottom_Processes")
                    endif

                end if
            end if

            PropertyX => PropertyX%Next
        end do do1

        nullify(PropertyX)

    end subroutine Bottom_Processes

    !----------------------------------------------------------------------
    !--------------------------------------------------------------------------
    ! This subroutine is responsable for computing the
    ! the lagrangian sinks and sources processes
    subroutine SinksSources_Processes(SinksSourcesMass, PropertyID)

        !Arguments-------------------------------------------------------------
        real,   dimension(:,:,:), pointer       :: SinksSourcesMass
        integer,                  intent(IN)    :: PropertyID

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
        real                                    :: DT
        real                                    :: OldConcentration, DC
        integer                                 :: ILB, IUB, JLB, JUB, KUB
        integer                                 :: i, j, k, kbottom, STAT_CALL

        !Begin----------------------------------------------------------------------

        ILB             = Me%WorkSize%ILB
        IUB             = Me%WorkSize%IUB
        JLB             = Me%WorkSize%JLB
        JUB             = Me%WorkSize%JUB
        KUB             = Me%WorkSize%KUB

        nullify(PropertyX)

        call Search_Property(PropertyX, PropertyXID = PropertyID, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterProperties - SinksSources_Processes - ERR10')

        call ReadLockExternalVar

        DT  = PropertyX%Evolution%DtInterval

do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

cd2:        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                kbottom = Me%ExternalVar%KFloor_Z(i, j)

do3:            do k = kbottom, KUB

                    DC = 0.

                    OldConcentration = PropertyX%Concentration(i, j, k)

                    ! [M/L3]       =  [M] / [L3]
                    DC  = SinksSourcesMass(i, j, k) / Me%ExternalVar%VolumeZ (i, j, k)


                    if (PropertyX%Evolution%Filtration%FeederMassON) then
                        if (PropertyX%Evolution%Filtration%FilterFeederMass(i, j, k) > 0.) then
                            ![M/M] = [M/L3] / [M/L3]
                            DC = DC / PropertyX%Evolution%Filtration%FilterFeederMass(i, j, k)
                            !Convert m3 in 100 ml
                            if (PropertyID == Fecal_Coliforms_) DC = DC * 1e4
                        endif
                    endif

                    !mg/l = (mg/l)/( s * s-1)
                    !explicit resolution
                    PropertyX%Concentration(i, j, k) = OldConcentration + DC


                enddo do3

            endif cd2

        enddo do2
        enddo do1

        nullify (PropertyX)

        call ReadUnLockExternalVar

    end subroutine SinksSources_Processes

    !--------------------------------------------------------------------------

    subroutine FirstOrderDecayProcesses

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyX, T90
        real                                        :: T90Aux
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, k, Kbottom, STAT_CALL
        integer                                     :: CHUNK
        character(LEN=StringLength)                 :: AuxName
        !Begin----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_J(JLB, JUB)

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))
            if (PropertyX%Evolution%FirstOrderDecay) then
                if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                    AuxName = GetPropertyName(PropertyX%Evolution%T90PropertyID)

                    call Search_Property(T90, PropertyXID = PropertyX%Evolution%T90PropertyID, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*) trim(PropertyX%ID%Name),' has a first order decay it needs the decay rate named ', trim(AuxName)
                        call CloseAllAndStop ('FirstOrderDecayProcesses - ModuleWaterProperties - ERR10')
                    endif

                    if (MonitorPerformance) then
                        call StartWatch ("ModuleWaterProperties", "FirstOrderDecayProcesses")
                    endif

                    !$OMP PARALLEL PRIVATE(I,J,K,kbottom,T90Aux)
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do j=JLB, JUB
                    do i=ILB, IUB

                        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            kbottom = Me%ExternalVar%KFloor_Z(i,j)

                            do k = kbottom, KUB

                                !The absolute minimum is 1e-6 s
                                T90Aux = max(T90%Concentration(i,j,k), T90%MinValue,1.e-6)

                                if (T90%Concentration(i,j,k) <= 0.) then
                                    !$OMP CRITICAL (FODP1_WARN20)
                                    write(*,*) 'The T90 of property ', trim(PropertyX%ID%Name), ' can not be <= 0'
                                    write(*,*) 'cell I=', i,' J=',j,' k=', k
                                    write(*,*) 'It was assumed a T90 =', T90Aux
                                    write(*,*) 'FirstOrderDecayProcesses - ModuleWaterProperties - WARN20'
                                    !$OMP END CRITICAL (FODP1_WARN20)
                                endif

                                if (T90%evolution%T90Hours) T90Aux = T90Aux * 3600.

                                PropertyX%Concentration(i, j, k) =                          &
                                             PropertyX%Concentration(i,j,k) /               &
                                             (1.0 + PropertyX%Evolution%DTInterval *        &
                                             (log(10.) / T90Aux))
                            enddo
                        endif

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    if (MonitorPerformance) then
                        call StopWatch ("ModuleWaterProperties", "FirstOrderDecayProcesses")
                    endif

                    nullify(T90)

                end if
            end if

            PropertyX => PropertyX%Next
        end do do1

        nullify(PropertyX)

    end subroutine FirstOrderDecayProcesses


    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ModifyImposeDryCells

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyX
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, k, Kbottom
        integer                                     :: CHUNK
        !Begin----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_J(JLB, JUB)

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))
            if (PropertyX%Evolution%ImposeDryCells) then
                if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                    if (MonitorPerformance) then
                        call StartWatch ("ModuleWaterProperties", "ModifyImposeDryCells")
                    endif

                    !$OMP PARALLEL PRIVATE(I,J,K,kbottom)
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do j=JLB, JUB
                    do i=ILB, IUB

                        !If Dry Cell
                        if (Me%ExternalVar%OpenPoints3D (i, j, KUB) /= OpenPoint .and.  &
                            Me%ExternalVar%WaterPoints3D(i, j, KUB) == WaterPoint) then

                            kbottom = Me%ExternalVar%KFloor_Z(i,j)

                            do k = kbottom, KUB
                                PropertyX%Concentration(i, j, k) =  PropertyX%DryCellConcentration
                            enddo

                        endif

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    if (MonitorPerformance) then
                        call StopWatch ("ModuleWaterProperties", "ModifyImposeDryCells")
                    endif


                end if
            end if

            PropertyX => PropertyX%Next
        end do do1

        nullify(PropertyX)

    end subroutine ModifyImposeDryCells

    !--------------------------------------------------------------------------

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !>For each domain checks and starts twoway procedure
    !>@param[in] WaterPropertiesID, CurrentTime
    subroutine Modify_TwoWay_Upscaling (WaterPropertiesID, CurrentTime)
    !External ----------------------------------------------------------------------------
    type (T_Property), pointer                  :: PropertyX
    type (T_Time)                               :: CurrentTime
    integer, intent (IN)                        :: WaterPropertiesID
    integer                                     :: FatherWaterpropertiesID
    !Locals
    integer                                     :: ID, ready_
    !Begin------------------------------------------------------------------------------
    if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Upscaling")

    if(.not. Me%Start2way)then

        PropertyX => Me%FirstProperty

        ID = WaterPropertiesID
        do while (associated(PropertyX))
            if (PropertyX%Submodel%TwoWay) then
                if (CurrentTime - Me%BeginTime .gt. PropertyX%Submodel%TwoWayWaitPeriod)then
                    Me%Start2way = .true.
                    exit
                endif
            endif
            PropertyX => PropertyX%Next
        enddo
        nullify(PropertyX)
    endif

    if (Me%Start2way)then
        do ID = WaterPropertiesID, 2, -1
            if (ID /= WaterPropertiesID) call Ready (ID, ready_) ! points Me% to domain "ID"

            FatherWaterpropertiesID = Me%WPFatherInstanceID    ! Changes ID to Father

            ! ID = sonID ,  FatherWaterpropertiesID = FatherID
            if (FatherWaterpropertiesID > 0) call Compute_wp_upscaling(ID, FatherWaterpropertiesID, WaterPropertiesID)
        enddo
        call Ready (WaterPropertiesID, ready_) ! swithes back to the final Domain
    endif

    if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Upscaling")

    end subroutine Modify_TwoWay_Upscaling

    !--------------------------------------------------------------------------

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Prepares TwoWay external variables, then for each property calls modify twoway
    !>@param[in] SonWaterPropertiesID, FatherWaterPropertiesID, WaterPropertiesID
    subroutine Compute_wp_upscaling(SonWaterPropertiesID, FatherWaterPropertiesID, WaterPropertiesID)
        !Arguments--------------------------------------------------------------------------------------------
        integer, intent(IN)                     :: SonWaterPropertiesID, FatherWaterPropertiesID, WaterPropertiesID
        !Local variables--------------------------------------------------------------------------------------
        type (T_WaterProperties), pointer       :: ObjFather
        type (T_Property), pointer              :: PropertyX, PropertyFather
        real(8), dimension(:,:,:), pointer      :: FatherFlow
        integer, dimension(:,:  ), pointer      :: Connections
        integer                                 :: STAT_CALL
        logical                                 :: FirstTime
        type(T_Time)                            :: CurrentTime
        !Begin------------------------------------------------------------------------------
        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Compute_wp_upscaling")
        FirstTime = .true.

        !Me% is pointing to Son domain!
        PropertyX => Me%FirstProperty
        
        if (SonWaterPropertiesID == WaterPropertiesID) then
            CurrentTime =  PropertyX%Evolution%NextCompute
        else
            CurrentTime =  PropertyX%Evolution%LastCompute
        endif

        call LocateObjFather(ObjFather, FatherWaterPropertiesID) !Gets father solution
        !Tells TwoWay module to get auxiliar variables (volumes, cell conections etc)
        call PrepTwoWay (SonID = SonWaterPropertiesID, CallerID = mWATERPROPERTIES_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Compute_wp_upscaling - failed PrepTwoWay'
        
        if (ObjFather%Coupled%UpscalingDischarge%Yes) then
            !Get matrix from hydrodynamic module
            call GetDischargesFluxes(FatherWaterPropertiesID, Discharges = FatherFlow, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Compute_wp_upscaling - failed getdischargeFluxes matrix'
            !Update the matrix with upscaling flux
            call GetUpscalingDischarge(FatherWaterPropertiesID, FatherFlow, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Compute_wp_upscaling - failed to get upscaling discharge flow'
        endif

        !Assimilates all the properties with twoway option ON
        do while (associated(PropertyX))

            call Search_PropertyFather(ObjFather, PropertyFather, PropertyX%ID%IDNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)then
                write(*,*)'Cant find property in submodel for the 2way algorithm', trim(PropertyX%ID%Name)
                call CloseAllAndStop ('Compute_wp_upscaling - ModuleWaterProperties - ERR01')
            endif

            if (PropertyX%Submodel%TwoWay)then
                if(CurrentTime == PropertyFather%Evolution%LastCompute)then
                !Assimilation of son domain into father domain
                    !Account for change in concentration
                    if (PropertyX%UpscalingSinkSource) &
                        PropertyFather%UpscalingMassLoss(:,:,:) = PropertyFather%UpscalingMassLoss(:,:,:) &
                                                                + PropertyFather%Concentration(:,:,:)

                    call ModifyTwoWay (SonID            = SonWaterPropertiesID,                 &
                                        FatherMatrix     = PropertyFather%Concentration,         &
                                        SonMatrix        = PropertyX%Concentration,              &
                                        CallerID         = mWATERPROPERTIES_,                    &
                                        TD               = PropertyX%Submodel%TwoWayTimeDecay,   &
                                        STAT             = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Compute_wp_upscaling - ModuleWaterProperties - ERR02.'

                    if (ObjFather%Coupled%UpscalingDischarge%Yes) then
                        call GetConnections(Me%ObjHorizontalGrid, Connections_Z = Connections, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'Compute_wp_upscaling - Failed to get Connections matrix'

                        call UpscaleDischarge_WP(FatherID = FatherWaterPropertiesID, Connections_Z = Connections,            &
                                                 Prop = PropertyFather%Concentration, PropVector = PropertyFather%DischConc, &
                                                 Flow = FatherFlow, FlowVector = ObjFather%Discharge%Flow, &
                                                 dI = ObjFather%Discharge%i, dJ = ObjFather%Discharge%j, &
                                                 dK = ObjFather%Discharge%k, Kmin = ObjFather%Discharge%kmin, &
                                                 Kmax = ObjFather%Discharge%kmin, FirstTime = FirstTime)
                        FirstTime = .false.
                    endif

                    if (PropertyX%UpscalingSinkSource) &
                        PropertyFather%UpscalingMassLoss(:,:,:) = PropertyFather%UpscalingMassLoss(:,:,:) &
                                                                - PropertyFather%Concentration(:,:,:)
                endif
            endif

            nullify (PropertyFather)
            PropertyX => PropertyX%Next

        enddo

        nullify (PropertyX)

        call UngetTwoWayExternal_Vars(SonID = SonWaterPropertiesID, &
                                      CallerID = mWATERPROPERTIES_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Compute_wp_upscaling - ModuleWaterProperties - ERR04.'

        if (ObjFather%Coupled%UpscalingDischarge%Yes) then
            call unGetHydrodynamic(FatherWaterPropertiesID, FatherFlow, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Compute_wp_upscaling - ModuleWaterProperties - ERR05.')
        endif

    if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Compute_wp_upscaling")

    end subroutine Compute_wp_upscaling

    !------------------------------------------------------------------------------------

    !------------------------------------------------------------------------------------
    subroutine ModifyDecayRate

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyX, Salinity, Temperature
        real,   dimension(:,:,:), pointer           :: ShortWaveAverage
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, k, Kbottom, STAT_CALL

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "ModifyDecayRate")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))
            if (PropertyX%Evolution%DecayRateProperty) then
                if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                    if (PropertyX%Evolution%T90Variable) then

                        call Search_Property(Temperature, PropertyXID = Temperature_, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) then
                            write(*,*) 'T90 Variale needs temperature'
                            call CloseAllAndStop ('ModifyDecayRate - ModuleWaterProperties - ERR10')
                        endif

                        call Search_Property(Salinity, PropertyXID = Salinity_, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) then
                            write(*,*) 'T90 Variable needs salinity'
                            call CloseAllAndStop ('ModifyDecayRate - ModuleWaterProperties - ERR20')
                        endif

                        ShortWaveAverage => Me%SolarRadiation%ShortWaveAverage

                        if (.not. associated(ShortWaveAverage)) then
                            write(*,*) 'T90 Variable needs solar radiation'
                            call CloseAllAndStop ('ModifyDecayRate - ModuleWaterProperties - ERR30')
                        endif

                    endif

                    if (PropertyX%ID%SolutionFromFile) then

                        call ModifyFillMatrix(FillMatrixID      = PropertyX%ID%ObjFillMatrix,   &
                                              Matrix3D          = PropertyX%Concentration,      &
                                              PointsToFill3D    = Me%ExternalVar%WaterPoints3D, &
                                              STAT              = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) call CloseAllAndStop ('ModifyDecayRate - ModuleWaterProperties - ERR40')

                    elseif (PropertyX%Evolution%T90Variable) then

                        do j=JLB, JUB
                        do i=ILB, IUB

                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                kbottom = Me%ExternalVar%KFloor_Z(i,j)

                                do k = kbottom, KUB

                                    PropertyX%Concentration(i, j, k)  = ComputeT90 (PropertyX, Salinity%Concentration(i,j,k), &
                                                                        Temperature%Concentration(i,j,k), ShortWaveAverage(i,j,k))

                                enddo
                            endif

                        enddo
                        enddo

                        !ACanas(2010): Parallelization removed as a function is used in the cycle iterations
                        !ACanas(2010): and that requires the sequential processing of the code.
                        !ACanas(2010): A critical section would be inefficient since race condition is very frequent.

                        nullify(Temperature       )
                        nullify(Salinity          )
                        nullify(ShortWaveAverage  )

                    endif
                end if
            end if

            PropertyX => PropertyX%Next
        end do do1

        nullify(PropertyX)

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "ModifyDecayRate")

    end subroutine ModifyDecayRate


    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine CalcNewDT (NewDT)

        !Arguments-------------------------------------------------------------
        type(T_NewDT)                               :: NewDT

        !Local-----------------------------------------------------------------

        type (T_Property), pointer                  :: PropertyX
        real(8)                                     :: DAux, DAuxMax
        real                                        :: ModelDT
        logical                                     :: VariableDT
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, k, Kbottom, STAT_CALL !, iaux, jaux, kaux
        !$ integer                                     :: CHUNK, TID
        !$ type(T_NewDT)                               :: StoredDT
        !$ type(T_NewDT), dimension(Me%MaxThreads)     :: NewDTs
        !$ real(8), dimension(Me%MaxThreads)           :: DAuxMaxs
        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "CalcNewDT")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        DAuxMax = 0.0

        call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CalcNewDT - ModuleWaterProperties - ERR10')

        if (VariableDT) then

            call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('CalcNewDT - ModuleWaterProperties - ERR20')

            call GetGeometryVolumes(Me%ObjGeometry,                                     &
                                    VolumeZOld     = Me%ExternalVar%VolumeZOld,         &
                                    STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('CalcNewDT - ModuleWaterProperties - ERR30')

            NewDT%property = 'ModelDT'
            NewDT%DT = ModelDT
            NewDT%i = 0; NewDT%j = 0; NewDT%k = 0;

            PropertyX => Me%FirstProperty

    do1 :   do while (associated(PropertyX))

                !$ StoredDT = NewDT

                if (PropertyX%Evolution%Variable) then
                    if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                        !$CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

                        if (.not.associated(PropertyX%ConcentrationOld)) then

                            allocate(PropertyX%ConcentrationOld(Me%Size%ILB:Me%Size%IUB,&
                                                                Me%Size%JLB:Me%Size%JUB,&
                                                                Me%Size%KLB:Me%Size%KUB))

                            PropertyX%ConcentrationOld(:,:,:) = PropertyX%Concentration(:,:,:)


                        endif

                        !$OMP PARALLEL PRIVATE(Daux,I,J,K,kbottom,TID,NewDT) FIRSTPRIVATE(DAuxMax)

                        !$ NewDT = StoredDT
                        !$ TID = 1 + omp_get_thread_num()

                        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                        do j=JLB, JUB
                        do i=ILB, IUB

                            if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                                kbottom = Me%ExternalVar%KFloor_Z(i,j)

                                do k = kbottom, KUB

                                    if (PropertyX%ConcentrationOld(i, j, k) > 0 .and. Me%ExternalVar%VolumeZOld(i, j, k) > 0) then

                                        !Percentage Variation -> (NewMass - OldMass) / OldMass
                                        DAux = (PropertyX%Concentration   (i, j, k) * Me%ExternalVar%VolumeZ   (i, j, k)) / &
                                               (PropertyX%ConcentrationOld(i, j, k) * Me%ExternalVar%VolumeZOld(i, j, k)) - 1.

                                       !Signal corrected. It was only evaluating mass gains when it should evaluate
                                       !mass losses
                                       !if (DAux > DAuxMax) then
                                        if (DAux < DAuxMax) then

                                            NewDT%property = PropertyX%ID%name
                                            DAuxMax = DAux
                                            NewDT%i = i; NewDT%j = j; NewDT%k = k;

                                        endif

                                    endif

                                   !This should not be here????
                                    PropertyX%ConcentrationOld(i,j,k) = PropertyX%Concentration(i,j,k)

                                enddo

                            endif

                        enddo
                        enddo
                        !$OMP END DO NOWAIT

                        !$ DAuxMaxs(TID) = DAuxMax
                        !$ NewDTs(TID) = NewDT

                        !$OMP END PARALLEL

                        !$ NewDT = StoredDT
                        !$ DAuxMax = 0.0
                        !$ do i = 1, Me%MaxThreads
                        !$    if (DAuxMaxs(i) > DAuxMax) then
                        !$        DAuxMax = DAuxMaxs(i)
                        !$        NewDT = NewDTs(i)
                        !$    endif
                        !$ enddo

                    end if

                end if

                PropertyX => PropertyX%Next

            end do do1

            nullify(PropertyX)

            if (abs(DAuxMax) > .6) NewDT%DT = NewDT%DT / 2.

            if (abs(DAuxMax) < .2) NewDT%DT = NewDT%DT * 1.2

            call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%VolumeZOld, STAT = STAT_CALL)

            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('CalcNewDT - ModuleWaterProperties - ERR40')

            !write(88,*) NewDT, iaux, jaux

        endif

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "CalcNewDT")

    end subroutine CalcNewDT

    !--------------------------------------------------------------------------

    subroutine ModifyOxygenSaturation

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyX, Salinity, Temperature
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, k, Kbottom, STAT_CALL

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "ModifyOxygenSaturation")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))
            if (PropertyX%Evolution%OxygenSaturation) then
                if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                    PropertyX%Evolution%SetLimitsTrigger = .true.

                    call Search_Property(Temperature, PropertyXID = Temperature_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*) 'Oxygen saturation needs temperature'
                        call CloseAllAndStop ('ModifyOxygenSaturation - ModuleWaterProperties - ERR10')
                    endif

                    call Search_Property(Salinity, PropertyXID = Salinity_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) then
                        write(*,*) 'Oxygen saturation needs salinity'
                        call CloseAllAndStop ('ModifyOxygenSaturation - ModuleWaterProperties - ERR20')
                    endif

                    do j=JLB, JUB
                    do i=ILB, IUB

                        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint) then

                            kbottom = Me%ExternalVar%KFloor_Z(i,j)

                            do k = kbottom, KUB

                                PropertyX%Concentration(i, j, k)  = OxygenSaturation(Temperature%Concentration(i,j,k), &
                                                                    Salinity%Concentration(i,j,k))
                            enddo
                        endif

                    enddo
                    enddo
                    !ACanas(2010): Parallelization removed as a function is used in the cycle iterations
                    !ACanas(2010): and that requires the sequential processing of the code.
                    !ACanas(2010): A critical section would be inefficient since race condition is very frequent.

                    nullify(Temperature       )
                    nullify(Salinity          )

                end if
            end if

            PropertyX => PropertyX%Next
        end do do1

        nullify(PropertyX)

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "ModifyOxygenSaturation")

    end subroutine ModifyOxygenSaturation


    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    real function ComputeT90 (PropertyX, Sal, Temp, Radiation)

        !Arguments-------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyX
        real                                        :: Sal, Temp, Radiation
        !Local-----------------------------------------------------------------
        real                                        :: Convert, Light

        !Begin-----------------------------------------------------------------

!______Mortality model selection

        If     (PropertyX%Evolution%T90Var_Method == Canteras) then

            ComputeT90 = ComputeT90_Canteras (Temp,Sal,Radiation)


        elseif (PropertyX%Evolution%T90Var_Method == Chapra) then

            !Converts W in ly/hr
            Convert    = 0.086325
            Light      = Convert * Radiation

            ComputeT90 = ComputeT90_Chapra (Temp, Sal, Light)


        endif

        !if the T90 is defined in hours ComputeT90 must be convert from seconds to hours
        if (PropertyX%Evolution%T90Hours) then
            ComputeT90 = ComputeT90 / 3600.
        endif


    end function ComputeT90

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    ! This subroutine is responsable for imposing the minimum or maximum concentration
    ! of a property
    subroutine SetLimitsConcentration(PhysicalProcesses)

        !Arguments-------------------------------------------------------------
        logical, optional, intent(IN)               :: PhysicalProcesses
        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: Property

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "SetLimitsConcentration")

        if (PhysicalProcesses) then
            Property => Me%FirstProperty
            do while (associated(Property))
                call SetLimitsProperty(Property)
                Property => Property%Next
            enddo
        else
            Property => Me%FirstProperty
            do while (associated(Property))
                if (Property%Evolution%SetLimitsTrigger) then
                    call SetLimitsProperty (Property)
                    Property%Evolution%SetLimitsTrigger = .false.
                endif
                Property => Property%Next
            enddo
        endif

        nullify(Property)

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "SetLimitsConcentration")

        !----------------------------------------------------------------------

    end subroutine SetLimitsConcentration

    !--------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Sets concentration to its min or max value, if needed.
    !>@param[in] Property
    subroutine SetLimitsProperty(Property)

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: Property
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB, Kbottom
        integer                                     :: i, j, k, CHUNK

        !Begin----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "SetLimitsProperty")

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_K(Me%WorkSize%KLB, Me%WorkSize%KUB)

cd1 :       if (Property%Evolution%MinConcentration) then
                !$OMP PARALLEL PRIVATE(I,J,K, Kbottom)
                if (Me%Docycle_method == 1) then
                    CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do j=Me%WorkSize%JLB, Me%WorkSize%JUB
                    do i=Me%WorkSize%ILB, Me%WorkSize%IUB
                        if (Me%ExternalVar%WaterPoints3D(i, j, Me%WorkSize%KUB) == 1) then
                            Kbottom = Me%ExternalVar%KFloor_Z(i, j)
                            do k=Kbottom, Me%WorkSize%KUB

                                if (Property%Concentration(i, j, k) < Property%MinValue) then
                                    ! mass created
                                    Property%Mass_created(i, j, k) = Property%Mass_Created(i, j, k)              +  &
                                                           (Property%MinValue - Property%Concentration(i, j, k)) *  &
                                                            Me%ExternalVar%VolumeZ (i, j, k)

                                    Property%Concentration(i, j, k) = Property%MinValue
                                endif
                            enddo
                        endif
                    enddo
                    enddo
                    !$OMP END DO

                else
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do k=Me%WorkSize%KLB, Me%WorkSize%KUB
                    do j=Me%WorkSize%JLB, Me%WorkSize%JUB
                    do i=Me%WorkSize%ILB, Me%WorkSize%IUB

                        if (Me%ExternalVar%WaterPoints3D(i, j, k) == 1) then

                            if (Property%Concentration(i, j, k) < Property%MinValue) then
                                ! mass created
                                Property%Mass_created(i, j, k) = Property%Mass_Created(i, j, k)              +  &
                                                       (Property%MinValue - Property%Concentration(i, j, k)) *  &
                                                        Me%ExternalVar%VolumeZ (i, j, k)

                                Property%Concentration(i, j, k) = Property%MinValue
                            endif

                        endif
                    enddo
                    enddo
                    enddo
                    !$OMP END DO
                endif
                !$OMP END PARALLEL
            endif cd1

cd2 :       if (Property%Evolution%MaxConcentration) then

                !$OMP PARALLEL PRIVATE(I,J,K, Kbottom)
                CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

                if (Me%Docycle_method == 1) then

                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do j=Me%WorkSize%JLB, Me%WorkSize%JUB
                    do i=Me%WorkSize%ILB, Me%WorkSize%IUB

                        if (Me%ExternalVar%WaterPoints3D(i, j, Me%WorkSize%KUB) == 1) then
                            Kbottom = Me%ExternalVar%KFloor_Z(i, j)

                            do k = Kbottom, Me%WorkSize%KUB
                                if (Property%Concentration(i, j, k) > Property%MaxValue) then
                                    !mass destroid
                                    Property%Mass_Destroid(i, j, k) = Property%Mass_Destroid(i, j, k)            +  &
                                                           (Property%MaxValue - Property%Concentration(i, j, k)) *  &
                                                            Me%ExternalVar%VolumeZ (i, j, k)

                                    Property%Concentration(i, j, k) = Property%MaxValue
                                endif
                            enddo
                        endif
                    enddo
                    enddo
                    !$OMP END DO
                else
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do k=Me%WorkSize%KLB, Me%WorkSize%KUB
                    do j=Me%WorkSize%JLB, Me%WorkSize%JUB
                    do i=Me%WorkSize%ILB, Me%WorkSize%IUB

                        if (Me%ExternalVar%WaterPoints3D(i, j, k) == 1) then

                            if (Property%Concentration(i, j, k) > Property%MaxValue) then

                                !mass destroid
                                Property%Mass_Destroid(i, j, k) = Property%Mass_Destroid(i, j, k)             +  &
                                                       (Property%MaxValue -  Property%Concentration(i, j, k)) *  &
                                                        Me%ExternalVar%VolumeZ (i, j, k)

                                Property%Concentration(i, j, k) = Property%MaxValue
                            endif
                        endif
                    enddo
                    enddo
                    enddo
                    !$OMP END DO
                endif
                !$OMP END PARALLEL

        end if cd2

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "SetLimitsProperty")

        !----------------------------------------------------------------------

    end subroutine SetLimitsProperty
    !--------------------------------------------------------------------------


    subroutine ComputeSurfaceHeatFluxes(Temperature)

        !Arguments-------------------------------------------------------------
        type(T_Property),           pointer :: Temperature
        !Local variables-------------------------------------------------------
        real,   dimension(:,:), pointer     :: WaterColumnZ
        real                                :: TopHeatFlux, BottomHeatFlux
        real                                :: AuxT
        integer                             :: ILB, IUB, JLB, JUB, KUB
        integer                             :: i, j, k, kbottom, STAT_CALL
        real                                :: SpecifHeat
        !Begin----------------------------------------------------------------------
        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ComputeSurfaceHeatFluxes - ModuleWaterProperties - ERR10')

do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

cd1:        if (Me%ExternalVar%OpenPoints3D(i, j, KUB) == OpenPoint .and. WaterColumnZ(i,j) > .5) then

                kbottom = Me%ExternalVar%KFloor_Z(i, j)

do3:            do k = kbottom, KUB

                    TopHeatFlux    = Me%SolarRadiation%ShortWaveTop(i, j, k)   + &
                                     Me%SolarRadiation%LongWaveTop (i, j, k)
                    BottomHeatFlux = Me%SolarRadiation%ShortWaveTop(i, j, k-1) + &
                                     Me%SolarRadiation%LongWaveTop (i, j, k-1)

                    !Boundary condition all the radiation that gets to the bottom is convert in heat.
                    if (k == kbottom) BottomHeatFlux = 0.

                    !The surface flux was already quantified in the surface processes
                    if (k == KUB)then
                         TopHeatFlux = TopHeatFlux + Me%ExtSurface%NonSolarRadiation(i, j)
                    end if

                    if( Me%SpecificHeat%UseField ) then
                        SpecifHeat = Me%SpecificHeat%Field(i, j, k)
                    else
                        SpecifHeat = Me%SpecificHeat%Reference
                    endif

                    !Heat evolution
                    ![Celsius]  =  [Joules / m^2 / s] * [s] / [kg/m^3] / [Joules/kg/Celsius] / [m]
                    AuxT    =   (TopHeatFlux - BottomHeatFlux)     *                    &
                                Temperature%Evolution%DTinterval   /                    &
                                Me%Density%Field(i, j, k)          /                    &
                                SpecifHeat                         /                    &
                                Me%ExternalVar%DWZ(i, j, k)

                    !The water temperature can not be below 0ยบC
                    !unless the ADDOFFSET option is activated
                    !so that the water temperature can take negative values
                    if (AuxT < - Temperature%Concentration(i, j, k))then
                        if(.not. Temperature%AddOffSet)then
                            AuxT = 0.0
                        end if
                    endif

                    ![Celsius]  =  [Celsius]  + [Celsius]
                    Temperature%Concentration(i, j, k) = Temperature%Concentration(i, j, k) + AuxT

                enddo do3

            endif cd1

        enddo do2
        enddo do1

        call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ComputeSurfaceHeatFluxes - ModuleWaterProperties - ERR20')

    end subroutine ComputeSurfaceHeatFluxes


    !--------------------------------------------------------------------------
    !   Makes the connection between the
    !   water properties module and the
    !   discharges module
    subroutine WaterPropDischarges


        !Local-----------------------------------------------------------------
        integer, dimension(:,:  ), pointer          :: KFloor_Z
        type (T_property), pointer                  :: PropertyX
        real                                        :: DischargeConc
        integer                                     :: dis, i, j, k
        type (T_Time)                               :: Actual
!        real, dimension(:,:,:),pointer              :: SZZ
        real, dimension(:, :), pointer              :: WaterLevel, WaterColumnZ
        integer                                     :: STAT_CALL, KUB
        real                                        :: DischargeFlow
        integer                                     :: nProperties
        real, dimension(:), pointer                 :: DataBuffer
        type (T_DischargeTimeSerie), pointer        :: DischargesTimeSerie
        integer                                     :: DischVertical
        real                                        :: WaterLevelByPass
        integer                                     :: ib, jb, kb
        logical                                     :: ByPassON, IgnoreOK, DischargeFromIntakeON, PropFromIntake
        real,    dimension(:    ), pointer          :: DistributionCoef
        integer, dimension(:    ), pointer          :: VectorI, VectorJ, VectorK
        real                                        :: AuxFlowIJ
        integer                                     :: nCells, n, AuxCell, Aux
        integer                                     :: FlowDistribution
        real                                        :: ByPassConcIncrease
        integer                                     :: IntakeI, IntakeJ, IntakeK, kmin, kmax


        !Begin------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "WaterPropDischarges")

        KUB = Me%WorkSize%KUB

        !WaterColumnZ
        call GetGeometryWaterColumn(Me%ObjGeometry, WaterColumn = WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)  call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR10')


        !WaterLevel
        call GetWaterLevel(Me%ObjHydrodynamic, WaterLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR20')

        Actual          =  Me%ExternalVar%Now

        KFloor_Z        => Me%ExternalVar%KFloor_Z

        if (Me%Coupled%DischargesTracking%Yes) then

            !First checks out how many properties will have discharges time series
            PropertyX   => Me%FirstProperty
            nProperties =  1
            do while (associated(PropertyX))
                if (PropertyX%Evolution%DischargesTracking) nProperties = nProperties + 1
                PropertyX=>PropertyX%Next
            enddo

            !Allocates DataBuffer
            allocate(DataBuffer(nProperties), STAT = STAT_CALL)
            if (STAT_CALL /= 0) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR30')

            !Discharges Time Serie Tracking
            DischargesTimeSerie => Me%FirstDischargeTimeSerie

        endif

        AuxCell = 0

        !For all Discharges
dd:     do dis = 1, Me%Discharge%Number
            !Sobrinho
            if (IsUpscaling(Me%ObjDischarges, dis)) then
                
                call GetDischargeFlowDistribuiton(Me%ObjDischarges, dis, nCells, FlowDistribution, &
                                              VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                     &
                call CloseAllAndStop ('WaterPropDischarges - Failed GetDischargeFlowDistribuiton in upscaling')
                ! skips adresses correspondent to upscaling discharges

                if (Me%FirstIteration)then
                    Aux = AuxCell + 1
                    if (AuxCell == 0)Aux = 1 !is this needed ??

                    !need to get i, j , k for adv dif.
                    do n = Aux, nCells + AuxCell
                        Me%Discharge%Flow   (n) = 0.
                        Me%Discharge%i      (n) = VectorI(n - AuxCell)
                        Me%Discharge%j      (n) = VectorJ(n - AuxCell)
                        Me%Discharge%k      (n) = VectorK(n - AuxCell)
                        Me%Discharge%kmin   (n) = kmin
                        Me%Discharge%kmax   (n) = kmax
                    enddo
                endif
                
                if (Me%Coupled%OfflineUpscalingDischarge%Yes) then
                    
                    call Modify_Upscaling_Discharges(VectorI, VectorJ, VectorK, kmin, kmax, AuxCell, nCells)
                   
                endif

                AuxCell = AuxCell + nCells

                Me%Discharge%Vert   (dis) = DischVertical
                cycle
            endif

            call GetDischargeON(Me%ObjDischarges,dis, IgnoreOK, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR40')

            if (IgnoreOK) then
                Me%Discharge%Ignore   (dis) = .true.
                cycle
            endif

            call GetDischargesGridLocalization(Me%ObjDischarges,                        &
                                               dis,                                     &
                                               Igrid         = I,                       &
                                               JGrid         = J,                       &
                                               KGrid         = k,                       &
                                               IByPass       = Ib,                      &
                                               JByPass       = Jb,                      &
                                               KByPass       = Kb,                      &
                                               DischVertical = DischVertical,           &
                                               WaterColumnZ  = WaterColumnZ,            &
                                               Bathymetry    = Me%ExternalVar%Bathymetry,&
                                               OpenPoints3D  = Me%ExternalVar%OpenPoints3D,&
                                               STAT          = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR50')

            !Check if this is a bypass discharge. If it is gives the water level of the bypass end cell
            call GetByPassON(Me%ObjDischarges, dis, ByPassON, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR60')

            if (ByPassON) Me%Discharge%ByPass   (dis) = .true.

            call GetDischargeFromIntakeON(Me%ObjDischarges, dis, DischargeFromIntakeON, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR70')

            if (ByPassON) then
                WaterLevelByPass = WaterLevel(ib, jb)
            else
                WaterLevelByPass = FillValueReal
            endif

            call GetDischargeWaterFlow(Me%ObjDischarges,                                &
                                       Me%ExternalVar%Now,                              &
                                       dis, WaterLevel(i, j), DischargeFlow,            &
                                       SurfaceElevation2 = WaterLevelByPass,            &
                                       STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR80')

            if (Me%Coupled%DischargesTracking%Yes) then
                DataBuffer(:)           = 0
                nProperties             = 1
                DataBuffer(nProperties) = DischargeFlow
            endif

            call GetDischargeFlowDistribuiton(Me%ObjDischarges, dis, nCells, FlowDistribution, &
                                              VectorI, VectorJ, VectorK, kmin, kmax, STAT = STAT_CALL)

            if (STAT_CALL/=SUCCESS_)                                                     &
                call CloseAllAndStop ('Sub. WaterPropDischarges - ModuleWaterProperties - ERR90')

i11:        if (nCells > 1) then
                !allocate(DistributionCoef(1:nCells))
i22:            if      (FlowDistribution == DischByCell_       ) then

                    !DistributionCoef(1:nCells) = 1./float(nCells)

                    call GetDistributionCoefMass(Me%ObjDischarges, dis,                 &
                                                 DistributionCoef, STAT = STAT_CALL)
                    if (STAT_CALL/=SUCCESS_) then
                        stop 'Sub. WaterPropDischarges - ModuleWaterProperties - ERR100'
                    endif

                else i22

                    call CloseAllAndStop ('Sub. WaterPropDischarges - ModuleWaterProperties - ERR110')

                endif i22
            endif i11

            AuxFlowIJ = DischargeFlow

            if (nCells > 1) DischargeFlow = 0.

            Me%Discharge%Vert   (dis) = DischVertical

dn:         do n=1, nCells
                if (nCells > 1) then
                    i         = VectorI(n)
                    j         = VectorJ(n)
                    k         = VectorK(n)

                    call GetDischargeWaterFlow(Me%ObjDischarges,                        &
                                               Me%ExternalVar%Now, dis,                 &
                                               WaterLevel(I, J),                        &
                                               AuxFlowIJ,                               &
                                               SurfaceElevation2 = WaterLevelByPass,    &
                                               FlowDistribution  = DistributionCoef(n), &
                                               STAT              = STAT_CALL)

                    if (STAT_CALL/=SUCCESS_)                                            &
                        call CloseAllAndStop ('Sub. WaterPropDischarges - ModuleWaterProperties - ERR120')

                    DischargeFlow = DischargeFlow + AuxFlowIJ

                    if (Me%Coupled%DischargesTracking%Yes) then
                        if (n == nCells) DataBuffer(1) = DischargeFlow
                    endif

                endif

                AuxCell = AuxCell + 1


                Me%Discharge%Flow   (AuxCell) = AuxFlowIJ
                Me%Discharge%i      (AuxCell) = i
                Me%Discharge%j      (AuxCell) = j
                Me%Discharge%k      (AuxCell) = k
                Me%Discharge%kmin   (AuxCell) = kmin
                Me%Discharge%kmax   (AuxCell) = kmax

                if (DischVertical == DischUniform_) then
                    if (kmin < 0) Me%Discharge%kmin(AuxCell) = KFloor_Z(i, j)
                    if (kmax < 0) Me%Discharge%kmax(AuxCell) = KUB
                    if (k    < 0) k = Me%Discharge%kmax(AuxCell)
                endif

                nProperties = 1
                PropertyX => Me%FirstProperty
 dw:            do while (associated(PropertyX))

 cd1:               if (PropertyX%Evolution%Discharges) then
 cd2:               if (Actual.GE.PropertyX%Evolution%NextCompute) then

                        if (PropertyX%Evolution%DischargesTracking) nProperties = nProperties + 1

 iby:                   if (ByPassON) then

                            if (AuxFlowIJ >= 0.) then

                                call GetByPassConcIncrease(Me%ObjDischarges, dis,       &
                                                           PropertyX%ID%IDNumber,       &
                                                           ByPassConcIncrease,          &
                                                           STAT = STAT_CALL)
                                if (STAT_CALL/=SUCCESS_)                                &
                                    call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR130')

                                PropertyX%DischConc(AuxCell) = PropertyX%Concentration(ib, jb, kb) + ByPassConcIncrease

                            else
                                PropertyX%DischConc(AuxCell) = PropertyX%Concentration(i , j , k)
                            endif

                        else iby

                            !Frank
                            !If the discharge flow is positive (Input) then the concentration
                            !to consider is the concentration supplied in the data file
 i1:                        if (AuxFlowIJ >= 0.) then

                                call GetDischargeConcentration (Me%ObjDischarges,                       &
                                                                Me%ExternalVar%Now,                     &
                                                                dis, DischargeConc,                     &
                                                                PropertyIDNumber=PropertyX%ID%IDNumber, &
                                                                PropertyFromIntake= PropFromIntake,     &
                                                                STAT = STAT_CALL)
                                if (STAT_CALL/=SUCCESS_) then
                                    if (STAT_CALL == NOT_FOUND_ERR_) then
                                        !When a property is not found associated to a discharge
                                        !by default is consider that the concentration is zero
                                        DischargeConc = 0.

                                        !if property is temperature, warn user
                                        if  ((PropertyX%ID%IDNumber == Temperature_) .and. (.not. Me%TempFirstTimeWarning)) then

                                            call SetError(WARNING_, INTERNAL_, &
                                   "Positive discharge without user defined concentration - discharge temperature = 0ยบC", ON)
                                            Me%TempFirstTimeWarning = .true.

                                        endif
                                    else
                                        call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR140')
                                    endif
                                endif

                                if(PropFromIntake)then

                                    call GetIntakePosition (Me%ObjDischarges, dis,          &
                                                            IntakeI, IntakeJ, IntakeK,      &
                                                            STAT = STAT_CALL)
                                    if (STAT_CALL/=SUCCESS_)                            &
                                        call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR150')

                                    !DischargeConc here is the concentration increment
                                    PropertyX%DischConc(AuxCell) = PropertyX%Concentration(IntakeI, IntakeJ, IntakeK) + &
                                                                   DischargeConc
                                else
                                    PropertyX%DischConc(AuxCell) = DischargeConc
                                endif

                            !
                            else

                                PropertyX%DischConc(AuxCell) = PropertyX%Concentration(i , j , k)

                            endif i1

                        endif iby

                        if (PropertyX%Evolution%DischargesTracking) then

                            if (nCells > 1) then
                                Databuffer(nProperties) = Databuffer(nProperties)     + &
                                                          PropertyX%DischConc(AuxCell)* &
                                                          Me%Discharge%Flow(AuxCell)

                                if (n == nCells .and. DischargeFlow /= 0) then
                                    Databuffer(nProperties) = Databuffer(nProperties) / DischargeFlow
                                endif
                            else
                                Databuffer(nProperties) = PropertyX%DischConc(AuxCell)
                            endif

                        endif

                    endif cd2
                    endif cd1

                    PropertyX=>PropertyX%Next

                enddo dw

            enddo dn

            if (nCells > 1) then
                !deallocate(DistributionCoef)
                call UnGetDischarges(Me%ObjDischarges, DistributionCoef, STAT = STAT_CALL)
                if (STAT_CALL/=SUCCESS_)                                                &
                    stop 'WaterPropDischarges - ModuleWaterProperties - ERR160'

            endif


            call UnGetDischarges(Me%ObjDischarges, VectorI, STAT = STAT_CALL)
            if (STAT_CALL/=SUCCESS_)                                                    &
                call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR170')

            call UnGetDischarges(Me%ObjDischarges, VectorJ, STAT = STAT_CALL)
            if (STAT_CALL/=SUCCESS_)                                                    &
                call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR180')

            call UnGetDischarges(Me%ObjDischarges, VectorK, STAT = STAT_CALL)
            if (STAT_CALL/=SUCCESS_)                                                    &
                call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR190')

            !Writes Discharges TimeSerie
            if (Me%Coupled%DischargesTracking%Yes) then
                call WriteTimeSerieLine(DischargesTimeSerie%TimeSerie, DataBuffer, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) &
                    call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR200')

                DischargesTimeSerie => DischargesTimeSerie%Next
            endif

        enddo dd

        !Deallocates DataBuffer
        if (Me%Coupled%DischargesTracking%Yes) then
            deallocate(DataBuffer, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR210')
        endif

        call UnGetGeometry(Me%ObjGeometry, WaterColumnZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR220')

        call UnGetHydrodynamic(Me%ObjHydrodynamic, WaterLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('WaterPropDischarges - ModuleWaterProperties - ERR230')

        nullify(KFloor_Z)

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "WaterPropDischarges")


    end subroutine WaterPropDischarges

    !--------------------------------------------------------------------------
    
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Updates the discharges associated with upscaling domains
    !>@param[in] VectorI, VectorJ, VectorK
    subroutine Modify_Upscaling_Discharges (VectorI, VectorJ, VectorK, kmin, kmax, AuxCell, nCells)
        !Arguments-------------------------------------------------------------
        integer, dimension(:    ), pointer, intent(IN)  :: VectorI, VectorJ, VectorK
        integer                           , intent(IN)  :: AuxCell, nCells, kmin, kmax
        !External--------------------------------------------------------------
        type (T_Property), pointer                      :: Property
        type (T_Time)                                   :: Actual
        !Local -----------------------------------------------------------------
        integer                                         :: PropertyID
        integer                                         :: NumberOfFields, NumberOfFields_Upscaling
        real,    pointer, dimension(:,:,:)              :: PropAssimilation, DischargeFlow
        integer                                         :: N_Field, STAT_CALL
        logical                                         :: SubModelON
        !Begin --------------------------------------------------------------------------------------------
        
            !Get matrix from hydrodynamic module
            call GetDischargesFluxes(Me%ObjHydrodynamic, Discharges = DischargeFlow, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Modify_Upscaling_Discharges - failed getdischargeFluxes matrix'
            
            Property => Me%FirstProperty
            Actual = Me%ExternalVar%Now

            do while (associated(Property))

                if (Property%Evolution%DataAssimilation /= NoNudging) then
                    if (Actual.GE.Property%Evolution%NextCompute) then
                        
                        if (.not. CheckPropertyName   (Property%ID%Name, PropertyID))           &
                        call CloseAllAndStop ('Modify_Upscaling_Discharges; WaterProperties. ERR10')
                        
                        call GetNumberOfPropFields(Property, PropertyID, NumberOfFields, NumberOfFields_Upscaling)
                        
                        do N_Field = 1, NumberOfFields_Upscaling
                            
                            SubModelON = .false.
                            
                            call FillAssimilationField (Property, PropertyID, N_Field, SubModelON, PropAssimilation, &
                                                        Upscaling = .True.)
                            
                            call Offline_Upscaling_Discharge_WP(FatherID = Me%ObjTwoWay,                              &
                                                PropAssimilation = PropAssimilation, Prop = Property%Concentration,   &
                                                PropVector = Property%DischConc,       &
                                                Flow = DischargeFlow, FlowVector = Me%Discharge%Flow,                 &
                                                dI = Me%Discharge%i, dJ = Me%Discharge%j, dK = Me%Discharge%k,        &
                                                Kmin = Me%Discharge%kmin, Kmax = Me%Discharge%kmin, AuxKmin = Kmin,   &
                                                AuxKmax = Kmax, CellID = AuxCell, nCells = nCells, VectorI = VectorI, &
                                                VectorJ = VectorJ, VectorK = VectorK)
                        enddo
                    endif
                endif
                Property => Property%Next
            end do
            
            call unGetHydrodynamic(Me%ObjHydrodynamic,DischargeFlow, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                call CloseAllAndStop ('Modify_Upscaling_Discharges - ModuleWaterProperties - ERR20')
            
    end subroutine Modify_Upscaling_Discharges
    !--------------------------------------------------------------------------

    subroutine DataAssimilationProcesses

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: Property
        type (T_Time)                               :: Actual
        !Local -----------------------------------------------------------------
        integer                                     :: PropertyID
        integer                                     :: NumberOfFields, NumberOfFields_Upscaling
        !Begin--------------------------------------------------------------------

        Property => Me%FirstProperty

        Actual = Me%ExternalVar%Now

        do while (associated(Property))

            if (Property%Evolution%DataAssimilation /= NoNudging) then

                if (Actual.GE.Property%Evolution%NextCompute) then

                    if (.not. CheckPropertyName   (Property%ID%Name, PropertyID))           &
                    call CloseAllAndStop ('DataAssimilationProcesses; WaterProperties. ERR10')

                    !Sobrinho
                    call GetNumberOfPropFields(Property, PropertyID, NumberOfFields, NumberOfFields_Upscaling)

                    !Downscaling + Upscaling
                    call Assimilation_Down_Up(Property, PropertyID, Actual, NumberOfFields, NumberOfFields_Upscaling)

                endif

            endif

            Property => Property%Next

        end do


        nullify(Property)

        !----------------------------------------------------------------------


    end subroutine DataAssimilationProcesses
    !--------------------------------------------------------------------------

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Gets number of assimilation fields (Downcaling and upscaling for propertyID present in the assimilation module
    !>@param[in] PropertyID, NumberOfFields, NumberOfFields_Upscaling
    subroutine GetNumberOfPropFields (Property, PropertyID, NumberOfFields, NumberOfFields_Upscaling)
        !Arguments--------------------------------------------------------------
        type (T_Property), pointer, intent(INOUT)   :: Property
        integer                   , intent(IN)      :: PropertyID
        integer                   , intent(OUT)     :: NumberOfFields, NumberOfFields_Upscaling
        !Local -----------------------------------------------------------------
        integer                                     :: STAT_CALL
        !Begin--------------------------------------------------------------------
        call GetNumberOfFields          (AssimilationID = Me%ObjAssimilation,            &
                                        ID              = PropertyID,                    &
                                        NumberOfFields  = NumberOfFields,                &
                                        STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('GetNumberOfPropFields; WaterProperties. ERR01')

        call GetNumberOfUpscalingFields (AssimilationID = Me%ObjAssimilation,            &
                                        ID              = PropertyID,                    &
                                        NumberOfFields  = NumberOfFields_Upscaling,      &
                                        STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('GetNumberOfPropFields; WaterProperties. ERR02')

        if (NumberOfFields_Upscaling > 0) then
            if (.not. allocated(Property%Assimilation%Field_Upscaling)) &
            allocate(Property%Assimilation%Field_Upscaling( Me%Size%ILB:Me%Size%IUB, Me%Size%JLB:Me%Size%JUB, &
                                                            Me%Size%KLB:Me%Size%KUB))
        endif

    end subroutine GetNumberOfPropFields

    !----------------------------------------------------------------------------------------

    !>@author Maretec
    !>Edited by Joao Sobrinho - +Atlantic - 08/2020
    !>@Brief
    !>Assimilates external downscaling and upscaling fields
    !>@param[in] Property, PropertyID, Actual, NumberOfFields, NumberOfFields_Upscaling
    subroutine Assimilation_Down_Up(Property, PropertyID, Actual, NumberOfFields, NumberOfFields_Upscaling)
        !Arguments--------------------------------------------------------------
        type (T_Property), pointer, intent(INOUT)   :: Property
        integer                   , intent(IN)      :: PropertyID
        type (T_Time)             , intent(IN)      :: Actual
        integer                   , intent(IN)      :: NumberOfFields, NumberOfFields_Upscaling
        !Local -----------------------------------------------------------------
        real,    pointer, dimension(:,:,:)          :: PropAssimilation
        integer                                     :: N_Field, STAT_CALL
        real                                        :: CoefCold, DTProp
        logical                                     :: SubModelON
        !Begin--------------------------------------------------------------------
        DTProp = Property%Evolution%DTInterval
        !--------------------------------------------DOWNSCALING-----------------------------------------------
        do N_Field = 1, NumberOfFields
            !--------------------------------- Construct assimilation field -----------------------------------
            call FillAssimilationField (Property, PropertyID, N_Field, SubModelON, PropAssimilation)

            call Get_Check_AssimilationCoef(Property, PropertyID, N_Field, CoefCold, Actual)

            !---------------------------------------  Assimilate field ----------------------------------------
            if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Assimilation_Down_Up")

            if (Property%Evolution%DataAssimilation == NudgingToRef) then

                call Nudge_To_Ref (Property, DTProp, PropAssimilation, CoefCold, SubModelON)

            else if (Property%Evolution%DataAssimilation == NudgingAdvVert) then

                call Nudge_AdvVert (Property, DTProp, CoefCold)

            end if
            !---------------------------------------  Kill assimilation field ----------------------------------
            if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Assimilation_Down_Up")

            call UnGetAssimilation(Me%ObjAssimilation, Property%Assimilation%DecayTime, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Assimilation_Down_Up; WaterProperties. ERR90')

        enddo

        !--------------------------------------------UPSCALING-------------------------------------------------
        do N_Field = 1, NumberOfFields_Upscaling
            !--------------------------------- Construct assimilation field -----------------------------------
            call FillAssimilationField (Property, PropertyID, N_Field, SubModelON, PropAssimilation, Upscaling = .True.)

            call Get_Check_AssimilationCoef(Property, PropertyID, N_Field, CoefCold, Actual, Upscaling = .True.)

            !---------------------------------------  Assimilate field ----------------------------------------

            if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "Assimilation_Down_Up")

            if (Property%Evolution%DataAssimilation == NudgingToRef) then

                call Nudge_To_Ref (Property, DTProp, PropAssimilation, CoefCold, SubModelON, Upscaling = .true.)

            else if (Property%Evolution%DataAssimilation == NudgingAdvVert) then
                call CloseAllAndStop ('Upscaling is not ready to be computed with hybrid assimilation')
            end if
            !---------------------------------------  Kill assimilation field ----------------------------------
            if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "Assimilation_Down_Up")

            call UnGetAssimilation(Me%ObjAssimilation, Property%Assimilation%DecayTime2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Assimilation_Down_Up; WaterProperties. ERR90')

        enddo

    end subroutine Assimilation_Down_Up

    !----------------------------------------------------------------------------------------
    !>@author Maretec
    !>Edited by Joao Sobrinho - +Atlantic - 08/2020
    !>@Brief
    !>Assimilates external downscaling or upscaling field
    !>@param[in] Property, DTProp, PropAssimilation, CoefCold, SubModelON, Upscaling
    subroutine Nudge_To_Ref(Property, DTProp, PropAssimilation, CoefCold, SubModelON, Upscaling)
        !Arguments--------------------------------------------------------------
        type (T_Property)     , pointer, intent(INOUT)  :: Property
        real, dimension(:,:,:), pointer, intent(IN)     :: PropAssimilation
        real                           , intent(IN)     :: CoefCold, DTProp
        logical                        , intent(IN)     :: SubModelON
        logical, optional              , intent(IN)     :: Upscaling
        !Local -----------------------------------------------------------------
        integer                                         :: i, j, k, ILB, IUB, JLB, JUB, KLB, KUB
        real                                            :: AuxDecay
        integer                                         :: STAT_CALL, CHUNK
        logical                                         :: Upscaling_
        !Begin--------------------------------------------------------------------
        Upscaling_ = .false.
        if (present(Upscaling)) Upscaling_ = Upscaling

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_K(KLB, KUB)
        if (Upscaling_) then
            !Need to find a way to get connection matrix in order to reduce number of iterations. (carefull with MPI)
            !$OMP PARALLEL PRIVATE(I,J,K, AuxDecay)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if (Me%ExternalVar%OpenPoints3D(i, j, k) == 1) then

                    AuxDecay = DTProp / (Property%Assimilation%DecayTime2D(i, j))/ CoefCold

                    ! C(t+dt) = (C(t) + Cref*dt/Tref) / (1 + dt / Tref) -> Implicit
                    Property%Concentration(i, j, k) = (Property%Concentration(i, j, k)                        &
                                                    +  PropAssimilation(i, j, k) * AuxDecay) / (1. + AuxDecay)
                endif
            enddo
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
        else
            !$OMP PARALLEL PRIVATE(I,J,K, AuxDecay)
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if (Me%ExternalVar%OpenPoints3D(i, j, k) == 1) then
                    if (Property%Assimilation%DecayTime(i, j, k)  < 0) then
                        !$OMP CRITICAL (DAP1_ERR70)
                        call CloseAllAndStop ('Nudge_To_Ref; WaterProperties. ERR01')
                        !$OMP END CRITICAL (DAP1_ERR70)
                    endif
                    AuxDecay = DTProp / (Property%Assimilation%DecayTime(i, j, k))/ CoefCold

                    ! C(t+dt) = (C(t) + Cref*dt/Tref) / (1 + dt / Tref) -> Implicit
                    Property%Concentration(i, j, k) = (Property%Concentration(i, j, k)                        &
                                                    +  PropAssimilation(i, j, k) * AuxDecay) / (1. + AuxDecay)
                endif
            enddo
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
        endif

        if(.not. SubModelON)then
            call UnGetAssimilation (Me%ObjAssimilation, PropAssimilation, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Nudge_To_Ref; WaterProperties. ERR02')
        end if
    end subroutine Nudge_To_Ref

    !----------------------------------------------------------------------------------------
    !>@author Maretec
    !>Edited by Joao Sobrinho - +Atlantic - 08/2020
    !>@Brief
    !>Assimilates external downscaling field with implicit vertical advection
    !>@param[in] Property, DTProp, PropAssimilation, CoefCold, SubModelON
    subroutine Nudge_AdvVert(Property, DTProp, CoefCold)
        !Arguments--------------------------------------------------------------
        type (T_Property)     , pointer, intent(INOUT)  :: Property
        real                           , intent(IN)     :: CoefCold, DTProp
        !Local -----------------------------------------------------------------
        integer                                         :: i, j, k, ILB, IUB, JLB, JUB, KLB, KUB
        real                                            :: AuxDecay
        integer                                         :: CHUNK
        !Begin--------------------------------------------------------------------
        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        CHUNK = CHUNK_K(KLB, KUB)
        !$OMP PARALLEL PRIVATE(i,j,k,AuxDecay)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            !Upwelling
            if      (Property%Assimilation%DecayTime(i, j, KUB)  > 0)  then

                do k = KLB, KUB
                    if (Me%ExternalVar%OpenPoints3D (i, j, k  ) == OpenPoint .and.  &
                        Me%ExternalVar%OpenPoints3D (i, j, k-1) == OpenPoint) then

                        AuxDecay = DTProp / (CoefCold * Property%Assimilation%DecayTime(i, j, k))

                        ! C(t+dt,k) = (C(t,k) + C(t+dt,k-1)*dt/Tref) / (1 + dt / Tref)
                        ! Implicit vertical advection
                        Property%Concentration(i, j, k) = (Property%Concentration(i, j, k  )             &
                                                        +  Property%Concentration(i, j, k-1) * AuxDecay) &
                                                        / (1. + AuxDecay)
                    endif
                enddo
            !Downwelling
            else if (Property%Assimilation%DecayTime(i, j, KUB)  < 0)  then

                do k = KUB, KLB, -1

                    if (Me%ExternalVar%OpenPoints3D (i, j, k  ) == OpenPoint .and.  &
                        Me%ExternalVar%OpenPoints3D (i, j, k+1) == OpenPoint) then

                        AuxDecay = DTProp / (CoefCold * abs(Property%Assimilation%DecayTime(i, j, k)))

                        ! C(t+dt,k) = (C(t,k) + C(t+dt,k+1)*dt/Tref) / (1 + dt / Tref)
                        !Implicit vertical advection
                        Property%Concentration(i, j, k) = (Property%Concentration(i, j, k  )             &
                                                        +  Property%Concentration(i, j, k+1) * AuxDecay) &
                                                        / (1. + AuxDecay)
                    endif
                enddo
            endif
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL
    end subroutine Nudge_AdvVert
    !----------------------------------------------------------------------------------------
    !>@author Maretec
    !>Edited by Joao Sobrinho - +Atlantic- 08/2020
    !>@Brief
    !>Fills PropAssimilation matrix according to implementation options
    !>@param[in] Property, PropertyID, N_Field, SubModelON, PropAssimilation
    subroutine FillAssimilationField (Property, PropertyID, N_Field, SubModelON, PropAssimilation, Upscaling)
        !Arguments--------------------------------------------------------------
        type (T_Property)     , pointer, intent(INOUT)   :: Property
        integer                        , intent(IN)      :: N_Field, PropertyID
        logical                        , intent(OUT)     :: SubModelON
        real, dimension(:,:,:), pointer, intent(OUT)     :: PropAssimilation
        logical, optional              , intent(IN)      :: Upscaling
        !Locals-------------------------------------------------------------------
        logical                                          :: Upscaling_
        integer                                          :: STAT_CALL
        !Begin--------------------------------------------------------------------
        SubModelON = OFF

        Upscaling_ = .false.
        if (present(Upscaling)) Upscaling_ = Upscaling

        if (Upscaling_) then
            call GetAssimilationField(  AssimilationID  = Me%ObjAssimilation, &
                                        ID              = PropertyID,         &
                                        N_Field         = N_Field,            &
                                        Field3D         = PropAssimilation,   &
                                        Upscaling       = Upscaling,          &
                                        STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('FillAssimilationField; WaterProperties. ERR10')

            Property%Assimilation%Field_Upscaling(:,:,:) = PropAssimilation(:,:,:)
        else
            if (Property%Evolution%DataAssimilation == NudgingToRef .or.            &
                Property%Evolution%DataAssimilation == Hybrid) then

                if (Property%SubModel%ON .and. N_Field == 1) then

                    PropAssimilation => Property%Assimilation%Field
                    SubModelON = ON
                else
                    SubModelON = OFF
                    call GetAssimilationField(  AssimilationID  = Me%ObjAssimilation, &
                                                ID              = PropertyID,         &
                                                N_Field         = N_Field,            &
                                                Field3D         = PropAssimilation,   &
                                                STAT            = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('FillAssimilationField; WaterProperties. ERR20')

                    call SetMatrixValue(Property%Assimilation%Field, Me%Size, PropAssimilation)
                end if
            end if
        endif

    end subroutine FillAssimilationField

    !---------------------------------------------------------------------------------
    !>@author Maretec
    !>Edited by Joao Sobrinho - +Atlantic- 08/2020
    !>@Brief
    !>Gets assimilation coef and checks for inconsistencies
    !>@param[in] Property, PropertyID, N_Field, CoefCold, Actual
    subroutine Get_Check_AssimilationCoef (Property, PropertyID, N_Field, CoefCold, Actual, Upscaling)
        !Arguments----------------------------------------------------------------------
        type (T_Property), pointer, intent(INOUT)   :: Property
        integer                   , intent(IN)      :: N_Field, PropertyID
        real                      , intent(INOUT)   :: CoefCold
        type (T_Time)             , intent(IN)      :: Actual
        logical, optional         , intent(IN)      :: Upscaling
        !Locals-------------------------------------------------------------------
        logical                                     :: Upscaling_
        integer                                     :: STAT_CALL
        real                                        :: DT_RunPeriod, ColdPeriod, ColdOrder
        !Begin--------------------------------------------------------------------------

        Upscaling_ = .false.
        if (present(Upscaling)) Upscaling_ = Upscaling

        if (Upscaling_) then
            call GetAssimilationCoef (  AssimilationID  = Me%ObjAssimilation,             &
                                        ID              = PropertyID,                     &
                                        N_Field         = N_Field,                        &
                                        ColdRelaxPeriod = ColdPeriod,                     &
                                        ColdOrder       = ColdOrder,                      &
                                        CoefField2D     = Property%Assimilation%DecayTime2D,&
                                        Upscaling       = Upscaling_,                     &
                                        STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Get_Check_AssimilationCoef; WaterProperties. ERR01')
        else
            call GetAssimilationCoef (  AssimilationID  = Me%ObjAssimilation,             &
                                        ID              = PropertyID,                     &
                                        N_Field         = N_Field,                        &
                                        ColdRelaxPeriod = ColdPeriod,                     &
                                        ColdOrder       = ColdOrder,                      &
                                        CoefField3D     = Property%Assimilation%DecayTime,&
                                        Upscaling       = Upscaling_,                     &
                                        STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Get_Check_AssimilationCoef; WaterProperties. ERR02')
        endif

        if (ColdPeriod > 0. .and. Property%Old) then
            write(*,*) 'ColdRelaxPeriod is ON in a HOT START '
            write(*,*) 'Remove from Assimilation_x.dat the keyword COLD_RELAX_PERIOD'
            call CloseAllAndStop ('Get_Check_AssimilationCoef; WaterProperties. ERR02')
        endif

        DT_RunPeriod = Actual - Me%BeginTime

        if (ColdPeriod > (Me%EndTime - Me%BeginTime) .and. Me%FirstIteration) then
            write(*,*) "Cold Assimilation period larger than simulation period for property : ", trim(Property%ID%Name)
        endif

        if (ColdPeriod <= DT_RunPeriod) then
            CoefCold = 1.
        else
            CoefCold = (DT_RunPeriod / ColdPeriod) ** ColdOrder
            if (CoefCold < 1.e-32) CoefCold = 1.e-32
        endif
    end subroutine Get_Check_AssimilationCoef


    !---------------------------------------------------------------------------------
    subroutine ModifyNoFluxMapping

        !Local -----------------------------------------------------------------
        real,    pointer, dimension(:,:,:)          :: RelaxTimeScale
        integer                                     :: ILB, IUB
        integer                                     :: JLB, JUB
        integer                                     :: KLB, KUB
        integer                                     :: I, J, K, STAT_CALL
        !Begin--------------------------------------------------------------------

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        !ComputeFaces3D
        call GetComputeFaces3D(Me%ObjMap,                                           &
                               ComputeFacesU3D = Me%ExternalVar%ComputeFacesU3D,    &
                               ComputeFacesV3D = Me%ExternalVar%ComputeFacesV3D,    &
                               ComputeFacesW3D = Me%ExternalVar%ComputeFacesW3D,    &
                               STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR10')

        !U faces
        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID              = VelocityU_,                         &
                                  CoefField3D     = RelaxTimeScale,                     &
                                  STAT            = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR20')

doku :  do k = KLB, KUB
doju :  do j = JLB, JUB + 1
doiu :  do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesU3D(i, j, k) == 1 .and.                      &
                RelaxTimeScale                (i, j, k) < Me%NoFlux%RelaxTimeScaleLimit) then
                Me%NoFlux%U(i, j, k) = 1
            else
                Me%NoFlux%U(i, j, k) = 0
            endif

        enddo doiu
        enddo doju
        enddo doku


        call UnGetAssimilation(Me%ObjAssimilation, RelaxTimeScale, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR30')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesU3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR40')


        !V faces
        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID              = VelocityV_,                         &
                                  CoefField3D     = RelaxTimeScale,                     &
                                  STAT            = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR50')

dokv :  do k = KLB, KUB
dojv :  do j = JLB, JUB
doiv :  do i = ILB, IUB + 1

            if (Me%ExternalVar%ComputeFacesV3D(i, j, k) == 1 .and.                      &
                RelaxTimeScale                (i, j, k) < Me%NoFlux%RelaxTimeScaleLimit) then
                Me%NoFlux%V(i, j, k) = 1
            else
                Me%NoFlux%V(i, j, k) = 0
            endif

        enddo doiv
        enddo dojv
        enddo dokv


        call UnGetAssimilation(Me%ObjAssimilation, RelaxTimeScale, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR60')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesV3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR70')

        !W faces
        call GetAssimilationCoef (Me%ObjAssimilation,                                   &
                                  ID              = VelocityW_,                         &
                                  CoefField3D     = RelaxTimeScale,                     &
                                  STAT            = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR80')

dokw :  do k = KLB, KUB + 1
dojw :  do j = JLB, JUB
doiw :  do i = ILB, IUB

            if (Me%ExternalVar%ComputeFacesW3D(i, j, k) == 1 .and.                      &
                RelaxTimeScale                (i, j, k) < Me%NoFlux%RelaxTimeScaleLimit) then
                Me%NoFlux%W(i, j, k) = 1
            else
                Me%NoFlux%W(i, j, k) = 0
            endif

        enddo doiw
        enddo dojw
        enddo dokw


        call UnGetAssimilation(Me%ObjAssimilation, RelaxTimeScale, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR90')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesW3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyNoFluxMapping; WaterProperties. ERR100')

        !----------------------------------------------------------------------


    end subroutine ModifyNoFluxMapping

    !--------------------------------------------------------------------------
    subroutine UpdateHybridReferenceField

        !Local -----------------------------------------------------------------
        type (T_Property), pointer                  :: Property
        type (T_Time)                               :: Actual
        real, pointer, dimension(:,:,:)             :: ReferenceSolution
        real, pointer, dimension(:,:,:)             :: FatherSolution
        integer                                     :: ILB, IUB
        integer                                     :: JLB, JUB
        integer                                     :: KLB, KUB
        integer                                     :: I, J, K, STAT_CALL
        integer                                     :: CHUNK

        !Begin--------------------------------------------------------------------

        ILB = Me%WorkSize%ILB;  JLB = Me%WorkSize%JLB;  KLB = Me%WorkSize%KLB
        IUB = Me%WorkSize%IUB;  JUB = Me%WorkSize%JUB;  KUB = Me%WorkSize%KUB

        Property => Me%FirstProperty

        Actual = Me%ExternalVar%Now

d1 :    do while (associated(Property))

i1 :        if (Property%Evolution%DataAssimilation == Hybrid) then

i2 :            if (Actual.GE.Property%Evolution%NextCompute) then

                    call GetAssimilationField(Me%ObjAssimilation,                       &
                                              ID              = Property%ID%IDNumber,   &
                                              Field3D         = ReferenceSolution,      &
                                              STAT            = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call CloseAllAndStop ('UpdateHybridReferenceField - WaterProperties - ERR00')

                    !points solution from the father model
                    FatherSolution => Property%Assimilation%Field

                    CHUNK = CHUNK_J(JLB, JUB)

                    if (MonitorPerformance) then
                        call StartWatch ("ModuleWaterProperties", "UpdateHybridReferenceField")
                    endif

                    !$OMP PARALLEL PRIVATE(i,j,k)

                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (Me%ExternalVar%WaterPoints3D(i, j, k) == WaterPoint) then

                            Property%Assimilation%Field(i,j,k) =                                  &
                                 FatherSolution   (i,j,k) * (1 - Me%HybridWeights%Field(i,j,k)) + &
                                 ReferenceSolution(i,j,k) *      Me%HybridWeights%Field(i,j,k)

                        endif

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    enddo
                    !$OMP END PARALLEL

                    if (MonitorPerformance) then
                        call StopWatch ("ModuleWaterProperties", "UpdateHybridReferenceField")
                    endif

                endif i2

            endif i1

            Property => Property%Next

        end do d1

        nullify(Property)

    end subroutine UpdateHybridReferenceField

    !--------------------------------------------------------------------------
    ! nogueira e guillaume
    subroutine AltimAssimilationProcess

        !External--------------------------------------------------------------
        type (T_Property), pointer                  :: Temperature, Salinity
        type (T_Time)                               :: Actual

        !Local -----------------------------------------------------------------
        real,    pointer, dimension(:,:,:)          :: TemperatureAnalyzed, SalinityAnalyzed
        real,    pointer, dimension(:,:  )          :: WaterLevel
        real                                        :: AltimDecayTime
        integer                                     :: ILB, IUB
        integer                                     :: JLB, JUB
        integer                                     :: KLB, KUB
        integer                                     :: I, J, K, STAT_CALL
        real                                        :: AuxDecay, DT_altim

        !Begin--------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "AltimAssimilationProcess")

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KLB = Me%WorkSize%KLB
        KUB = Me%WorkSize%KUB

        Actual = Me%ExternalVar%Now
        DT_altim = Me%Coupled%AltimetryAssimilation%DT_Compute

        !Testar o tempo a ver se e agora que se assimila
        !Se for entao assimilar (nudge)
        if (Actual .ge. Me%Coupled%AltimetryAssimilation%NextCompute) then

            !Fetch the Temperature and Salinity field
            call Search_Property(Temperature, PropertyXID = Temperature_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR01')
            call Search_Property(Salinity, PropertyXID = Salinity_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR02')

            !Fetch the WaterLevel
            call GetWaterLevel(Me%ObjHydrodynamic, WaterLevel, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR05')

            !Compute the next analyzed temperature and salinity fields
            call ModifyAssimilation(Me%ObjAssimilation,                                     &
                                    Temperature%Concentration,                              &
                                    Salinity%Concentration,                                 &
                                    WaterLevel,                                             &
                                    Me%Density%Method,                                      &
                                    Me%Density%CorrecPress,                                 &
                                    STAT_CALL)

             !Fetch the analyzed temperature and salinity fields
            call GetAssimilationField(Me%ObjAssimilation,        &
                                      ID              = AltimTemperatureAnalyzed_,              &
                                      Field3D         = TemperatureAnalyzed,        &
                                      STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR03')
            call GetAssimilationField(Me%ObjAssimilation,        &
                                      ID              = AltimSalinityAnalyzed_,              &
                                      Field3D         = SalinityAnalyzed,        &
                                      STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR04')

            !Fetch the DecayTime
            call GetAltimetryDecayTime(Me%ObjAssimilation,                          &
                                       AltimDecayTime,             &
                                       STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR05')


            ! C(t+dt) = (C(t) + Cref*dt/Tref) / (1 + dt / Tref) -> Implicit

            !nudging temperature
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, k) == OpenPoint) then

                    AuxDecay = DT_altim / AltimDecayTime

                    Temperature%Concentration(i, j, k) = (Temperature%Concentration(i, j, k) + &
                                                               TemperatureAnalyzed(i, j, k)       * &
                                                               AuxDecay) / (1. + AuxDecay)
                endif


            enddo
            enddo
            enddo

            !nudging salinity
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB

                if (Me%ExternalVar%OpenPoints3D(i, j, k) == OpenPoint) then

                    AuxDecay = DT_altim / AltimDecayTime

                    Salinity%Concentration(i, j, k) = (Salinity%Concentration(i, j, k) + &
                                                               SalinityAnalyzed(i, j, k)       * &
                                                               AuxDecay) / (1. + AuxDecay)
                endif


            enddo
            enddo
            enddo


            Me%Coupled%AltimetryAssimilation%NextCompute =                        &
                Me%Coupled%AltimetryAssimilation%NextCompute  +  DT_altim

            !Unfetch the Water Level
            call UnGetHydrodynamic(Me%ObjHydrodynamic, WaterLevel, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR09')

            !Unfetch the analyzed temperature and salinity fields
            call UnGetAssimilation(Me%ObjAssimilation, TemperatureAnalyzed, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR10')
            call UnGetAssimilation(Me%ObjAssimilation, SalinityAnalyzed, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('AltimAssimilationProcess - ModuleWaterProperties - ERR11')

        endif


        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "AltimAssimilationProcess")

        !----------------------------------------------------------------------


    end subroutine AltimAssimilationProcess

    !--------------------------------------------------------------------------

    subroutine CalculateAge

        !Local--------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyAge
        real                                        :: Coef
        integer                                     :: i, j, k
        integer                                     :: STAT_CALL
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        call Search_Property(PropertyAge, PropertyXID = Age_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('CalculateAge - ModuleWaterProerties - ERR01')

        !computes water age only if the property age solution is not read from file
        if (.not.PropertyAge%ID%SolutionFromFile) then
            !Increase water age
            if (Me%ExternalVar%Now .GE. PropertyAge%Evolution%NextCompute) then

                select case (trim(adjustl(PropertyAge%ID%Units)))
                case ('seconds', 'Seconds', 'SECONDS')
                    Coef = 1.0
                case ('hours', 'Hours', 'HOURS')
                    Coef = 3600.
                case ('days', 'Days', 'DAYS')
                    Coef = 86400.0
                case default
                    write(*,*)'Invalid units of property age'
                    write(*,*)'Use SECONDS, HOURS or DAYS'
                    call CloseAllAndStop ('CalculateAge - ModuleWaterproperties - ERR01')
                end select

                CHUNK = CHUNK_J(Me%WorkSize%JLB, Me%WorkSize%JUB)

                if (MonitorPerformance) then
                    call StartWatch ("ModuleWaterProperties", "CalculateAge")
                endif

                !$OMP PARALLEL PRIVATE(i,j,k)
                if(Me%Age%UseWaterPoints)then

                    do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                    do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                        if (Me%ExternalVar%OpenPoints3D(i, j, k) == OpenPoint) then

                            PropertyAge%Concentration(i, j, k) = PropertyAge%Concentration(i, j, k) +   &
                                                                 PropertyAge%Evolution%DTInterval / Coef
                        endif

                    enddo
                    enddo
                    !$OMP END DO
                    enddo

                else

                    do k = Me%WorkSize%KLB, Me%WorkSize%KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = Me%WorkSize%JLB, Me%WorkSize%JUB
                    do i = Me%WorkSize%ILB, Me%WorkSize%IUB

                        if (Me%ExternalVar%WaterPoints3D(i, j, k) == OpenPoint) then

                            PropertyAge%Concentration(i, j, k) = PropertyAge%Concentration(i, j, k) +   &
                                                                 PropertyAge%Evolution%DTInterval / Coef
                        endif

                    enddo
                    enddo
                    !$OMP END DO
                    enddo

                end if
                !$OMP END PARALLEL

                if (MonitorPerformance) then
                    call StopWatch ("ModuleWaterProperties", "CalculateAge")
                endif

            endif

        endif

        nullify (PropertyAge)

    end subroutine CalculateAge

    !--------------------------------------------------------------------------
    ! This subroutine is responsable for defining
    ! the next time to actualize the value of each
    ! property
    subroutine Actualize_Time_Evolution

        !Local--------------------------------------------------------------
        type (T_Property), pointer :: Property
        type (T_Time    )          :: Actual

        !----------------------------------------------------------------------

        Property => Me%FirstProperty

        Actual = Me%ExternalVar%Now

do1 :   do while (associated(Property))

cd1:        if (Property%Evolution%Variable) then
cd2 :       if (Actual.GE.Property%Evolution%NextCompute) then
                    Property%Evolution%LastCompute = Property%Evolution%NextCompute
                    Property%Evolution%NextCompute = Property%Evolution%NextCompute &
                                                   + Property%evolution%DTInterval
            end if cd2
            end if cd1


            Property => Property%Next
        end do do1

        nullify(Property)

        Me%FirstIteration = .false.

    end subroutine Actualize_Time_Evolution


    !--------------------------------------------------------------------------


    subroutine ModifyDensity(CurrentTime)

        !Arguments-------------------------------------------------------------
        type (T_Time)                           :: CurrentTime

        !Local-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX
        real,    pointer, dimension(:,:,:)      :: S,T
        real, pointer, dimension(:,:,:)         :: SZZ, ZCellCenter
        integer, pointer, dimension(:,:,:)      :: WaterPoints3D
        integer                                 :: STAT_CALL
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: i, j, k
        integer                                 :: icILB, icIUB, icJLB, icJUB
        integer                                 :: di_out, dj_out
        real(8)                                 :: RoRef
        real                                    :: Depth
        integer                                 :: WriteNumber
        integer, parameter                      :: WriteNumberMax = 1000
        !$ integer                                 :: CHUNK
        character(len=PathLength)               :: ModelName

        !Begin-----------------------------------------------------------------

cd10:   if (CurrentTime > Me%Density%LastActualization) then

            ModelName = ' '

            if (Me%DDecomp%MasterOrSlave) then

                icILB = Me%DDecomp%Mapping%ILB
                icIUB = Me%DDecomp%Mapping%IUB
                icJLB = Me%DDecomp%Mapping%JLB
                icJUB = Me%DDecomp%Mapping%JUB

                write(ModelName,*) 'ModelName =', trim(adjustl(Me%ModelName)),' - MPI ID =', Me%DDecomp%MPI_ID, &
                ' - domain corners(imin, imax, jmin, jmax)=',icILB, icIUB, icJLB, icJUB

                di_out = Me%DDecomp%HaloMap%ILB - 1
                dj_out = Me%DDecomp%HaloMap%JLB - 1

            else
                write(ModelName,*) 'ModelName =', trim(adjustl(Me%ModelName))
                di_out = 0
                dj_out = 0
            endif



            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            !$ CHUNK = CHUNK_J(JLB, JUB)

            call Search_Property(PropertyX, PropertyXID = Salinity_, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_)call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR10.')

            S => PropertyX%Concentration

            call Search_Property(PropertyX, PropertyXID = Temperature_, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR20')

            T => PropertyX%Concentration

            !Get the Waterpoints (Here the ExternalVar cannot be used, once this subroutine
            !is also called from the subroutine GetDensity, which does not call ReadLockExternalVar

            call GetWaterPoints3D(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR30')

            call GetGeometryDistances (Me%ObjGeometry, SZZ = SZZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR40')

            call GetGeometryDistances(Me%ObjGeometry,                                   &
                                      ZCellCenter = ZCellCenter,                        &
                                      STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR50')

            if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "ModifyDensity")

            select case(Me%Density%Method)

                Case (WangState_)

                    !$OMP PARALLEL PRIVATE(k,j,i)
                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (WaterPoints3D(i, j, k) == 1) then

                            Me%Density%Sigma(i, j, k) = SigmaWang (T(i, j, k), S(i, j, k))

                        end if

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    enddo
                    !$OMP END PARALLEL

                Case (LeendertseState_)

                    !$OMP PARALLEL PRIVATE(k,j,i)
                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (WaterPoints3D(i, j, k) == 1) then

                            Me%Density%Sigma(i, j, k) = SigmaLeendertse (T(i, j, k), S(i, j, k))

                        end if

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    enddo
                    !$OMP END PARALLEL

                case (UNESCOState_)
                    !Sobrinho
                    WriteNumber = 0
                    !$OMP PARALLEL PRIVATE(k,j,i) FIRSTPRIVATE(WriteNumber)
                    !$OMP DO SCHEDULE(DYNAMIC,ChunkK)
                    do k = KLB, KUB
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (WaterPoints3D(i, j, k) == 1) then

                            if (T(i, j, k)<-20. .or. T(i, j, k)>100. .or. S(i, j, k) < -5 .or. S(i, j, k)>100.) then
                                write(*,'(A256)') trim(ModelName)
                                write(*,*) 'T,S,i,j,k'
                                write(*,*) T(i, j, k), S(i, j, k), i+di_out,j+dj_out,k

                                WriteNumber = WriteNumber + 1

                            endif

                            if (WriteNumber > WriteNumberMax) then
                                write(*,*) 'Too much temperature and/or salinity anomalous values >', WriteNumberMax
                                call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR60')
                            endif

                            Me%Density%Sigma(i, j, k) = SigmaUNESCO     (T(i, j, k), S(i, j, k))

                        end if

                    enddo
                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                case (Mel96State_)

                    !$OMP PARALLEL PRIVATE(k,j,i)
                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (WaterPoints3D(i, j, k) == 1) then

                            Me%Density%Sigma(i, j, k) = SigmaUNESCO (T(i, j, k), S(i, j, k))

                        end if

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    enddo
                    !$OMP END PARALLEL

                case (JMD95State_)

                    !$OMP PARALLEL PRIVATE(k,j,i)
                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (WaterPoints3D(i, j, k) == 1) then

                            Me%Density%Sigma(i, j, k) = SigmaUNESCO(T(i, j, k), S(i, j, k))

                        end if

                    enddo
                    enddo
                    !$OMP END DO NOWAIT
                    enddo
                    !$OMP END PARALLEL

                case (Linear_)

                    !kg/m^3
                    RoRef = 1025. -  dble(SigmaDensityReference)

                    !S0    = 33.75 psu
                    !AlphaS= 0.78 kg/m^3/psu

                    !$OMP PARALLEL PRIVATE(I,J,K)
                    do k = KLB, KUB
                    !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if (WaterPoints3D(i, j, k) == 1) then

                            Me%Density%Sigma(i, j, k) = RoRef + 0.78 * (S(i, j, k) - 33.75)

                        endif

                    enddo
                    enddo
                    !$OMP END DO
                    enddo
                    !$OMP END PARALLEL

                case default

                        write(*,*)'Unknown method to compute density.'
                        call CloseAllAndStop (' ModifyDensity - ModuleWaterProperties - ERR70')

            end select

            if (Me%Density%CorrecPress) then

                Me%Density%SigmaNoPressure(:,:,:) = Me%Density%Sigma(:,:,:)

                select case(Me%Density%Method)

                case (UNESCOState_)

                    !Sobrinho
                    !$OMP PARALLEL PRIVATE(k,j,i,Depth)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do k = KLB, KUB
                        do j = JLB, JUB
                        do i = ILB, IUB

                            if (WaterPoints3D(i, j, k) == 1) then

                                !Simply use the depth from zero reference
                                !Depth = -1.0*(SZZ(i,j,KUB)+ZCellCenter(i,j,k))
                                Depth = -1.*ZCellCenter(i,j,k)

                                Me%Density%Sigma(i, j, k) = SigmaUNESCOPressureCorrection  (T(i, j, k), &
                                                         S(i, j, k),Depth, Me%Density%Sigma(i, j, k))
                            endif

                        enddo
                        enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    case (Mel96State_)

                        !$OMP PARALLEL PRIVATE(k,j,i,Depth)
                        do k = KLB, KUB
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = JLB, JUB
                        do i = ILB, IUB

                            if (WaterPoints3D(i, j, k) == 1) then

                                !Simply use the depth from zero reference
                                !Depth = -1.0*(SZZ(i,j,KUB)+ZCellCenter(i,j,k))
                                Depth = -1.*ZCellCenter(i,j,k)

                                Me%Density%Sigma(i, j, k) = SigmaMel96PressureCorrection (T(i, j, k), &
                                                         S(i, j, k),Depth, Me%Density%Sigma(i, j, k))
                            endif

                        enddo
                        enddo
                        !$OMP END DO NOWAIT
                        enddo
                        !$OMP END PARALLEL

                    case (JMD95State_)

                        !$OMP PARALLEL PRIVATE(k,j,i,Depth)
                        do k = KLB, KUB
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = JLB, JUB
                        do i = ILB, IUB

                            if (WaterPoints3D(i, j, k) == 1) then

                                !Simply use the depth from zero reference
                                Depth = -1.*ZCellCenter(i,j,k)

                                Me%Density%Sigma(i, j, k) = SigmaJMD95PressureCorrection (T(i, j, k), &
                                                         S(i, j, k),Depth, Me%Density%Sigma(i, j, k))
                            endif

                        enddo
                        enddo
                        !$OMP END DO NOWAIT
                        enddo
                        !$OMP END PARALLEL

                end select

            end if

            !$OMP PARALLEL PRIVATE(I,J,K)
            !$OMP DO SCHEDULE(DYNAMIC, ChunkK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB

                if (WaterPoints3D(i, j, k) == 1) then
                    Me%Density%Field(i, j, k) = Me%Density%Sigma(i, j, k) + SigmaDensityReference
                endif

            enddo
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL


            !$OMP PARALLEL PRIVATE(I,J,K)
            !$OMP DO SCHEDULE(DYNAMIC, ChunkK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB

                if (WaterPoints3D(i, j, k) == 1) then

                    !One test to verify if the density value is not stupid
                    if (Me%Density%Field(i, j, k) > 1e5 .or.                 &
                        Me%Density%Field(i, j, k) < 0. )  then
                        !$OMP CRITICAL (MD1WP_ERR04)
                        write(*,*) 'i,j,k'
                        write(*,*) i+di_out,j+dj_out,k
                        write(*,*) 'density,temperature,salinity'
                        write(*,*) trim(ModelName)
                        write(*,*) Me%Density%Field(i, j, k),T(i, j, k),S(i, j, k)
                        call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR80')
                        !$OMP END CRITICAL (MD1WP_ERR04)
                    end if

                endif

            enddo
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "ModifyDensity")

            call UnGetGeometry(Me%ObjGeometry,SZZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR90')

            call UnGetGeometry(Me%ObjGeometry, ZCellCenter, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR100')

            Me%Density%LastActualization = CurrentTime

            nullify (S,T)

            call UnGetMap(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifyDensity - ModuleWaterProperties - ERR110')

        endif cd10

        !if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "ModifyDensity")

    end subroutine ModifyDensity


    !--------------------------------------------------------------------------
    subroutine ModifyDensitySed(CurrentTime)

        !Arguments-------------------------------------------------------------
        type (T_Time)                           :: CurrentTime

        !Local-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX, Cohesive_Sediment
        integer, pointer, dimension(:,:,:)      :: WaterPoints3D
        integer                                 :: STAT_CALL
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: i, j, k
        !$ integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

cd10:   if (CurrentTime > Me%Density%LastActualization) then

            call GetWaterPoints3D(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifyDensitySed - ModuleWaterProperties - ERR01')

            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            !$ CHUNK = CHUNK_J(JLB, JUB)

           if (Me%Density%CorrecSed) then

                call Search_Property(Cohesive_Sediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
                if (STAT_CALL/= SUCCESS_)call CloseAllAndStop ('ModifyDensitySed - ModuleWaterProperties - ERR10.')

                !$OMP PARALLEL PRIVATE(I,J,K)
                do k = KLB, KUB
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB

                    if (WaterPoints3D(i, j, k) == 1) then

                        if(.not.Me%Density%Variable) Me%Density%Sigma(i, j, k) = Me%Density%Reference - SigmaDensityReference

                        Me%Density%Sigma(i, j, k) = Me%Density%Sigma(i, j, k) + Cohesive_Sediment%Concentration(i,j,k)* &
                                                                                Cohesive_Sediment%IScoefficient       * &
                                                    (Me%Density%CohesiveSed - Me%Density%Reference) / Me%Density%Reference
                    endif

                enddo
                enddo
                !$OMP END DO NOWAIT
                enddo
                !$OMP END PARALLEL

                nullify(Cohesive_Sediment)
            endif

            if (Me%Density%CorrecNonCohesiveSed) then

                !It's included the density effect of non_cohesive (sand) sediments in suspension
                PropertyX => Me%FirstProperty

                do while (associated(PropertyX))

                    if (PropertyX%Non_Cohesive) then

                        !$OMP PARALLEL PRIVATE(I,J,K)
                        do k = KLB, KUB
                        !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                        do j = JLB, JUB
                        do i = ILB, IUB

                            if (WaterPoints3D(i, j, k) == 1) then

                                if(.not.Me%Density%Variable) then
                                    Me%Density%Sigma(i, j, k) = Me%Density%Reference - SigmaDensityReference
                                endif

                                Me%Density%Sigma(i, j, k) = Me%Density%Sigma(i, j, k) + PropertyX%Concentration(i,j,k)* &
                                                                                        PropertyX%IScoefficient       * &
                                                            (Me%Density%NonCohesiveSed - Me%Density%Reference) /        &
                                                            Me%Density%Reference
                            endif

                        enddo
                        enddo
                        !$OMP END DO NOWAIT
                        enddo
                        !$OMP END PARALLEL

                        PropertyX=>PropertyX%Next

                    endif

                end do
            endif

                !$OMP PARALLEL PRIVATE(I,J,K)
            do k = KLB, KUB
            !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if (WaterPoints3D(i, j, k) == 1) then
                    Me%Density%Field(i, j, k) = Me%Density%Sigma(i, j, k) + SigmaDensityReference
                endif

            enddo
            enddo
            !$OMP END DO NOWAIT
            enddo
            !$OMP END PARALLEL

            Me%Density%LastActualization = CurrentTime

            call UnGetMap(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifyDensitySed - ModuleWaterProperties - ERR100')

            endif cd10

        end subroutine ModifyDensitySed
    !--------------------------------------------------------------------------


    subroutine ModifySpecificHeat(CurrentTime)

        !Arguments-------------------------------------------------------------
        type (T_Time)                           :: CurrentTime

        !Local-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX
        real,    pointer, dimension(:,:,:)      :: S,T
        integer, pointer, dimension(:,:,:)      :: WaterPoints3D
        real, pointer, dimension(:,:,:)         :: SZZ, ZCellCenter
        integer                                 :: STAT_CALL
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: i, j, k
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

cd10:   if (CurrentTime > Me%SpecificHeat%LastActualization) then


            ILB = Me%WorkSize%ILB
            IUB = Me%WorkSize%IUB
            JLB = Me%WorkSize%JLB
            JUB = Me%WorkSize%JUB
            KLB = Me%WorkSize%KLB
            KUB = Me%WorkSize%KUB

            call Search_Property(PropertyX, PropertyXID = Salinity_, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_)call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR01.')

            S => PropertyX%Concentration

            call Search_Property(PropertyX, PropertyXID = Temperature_, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR02')

            T => PropertyX%Concentration

            !Get the Waterpoints (Here the ExternalVar cannot be used, once this subroutine
            !is also called from the subroutine GetSpecificHeat, which does not call ReadLockExternalVar

            call GetWaterPoints3D(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR03')

            call GetGeometryDistances (Me%ObjGeometry, SZZ = SZZ, ZCellCenter = ZCellCenter, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR03b')


            select case(Me%SpecificHeat%Method)

            case (UNESCOState_)
                !Sobrinho - called a parallelized routine instead of a function inside a
                !Non parallelized cycle
                call ComputeSpecificHeatUNESCO (S, T, SZZ, WaterPoints3D)

            case default

            end select

            !CHUNK = CHUNK_J(JLB, JUB) Sobrinho
            CHUNK = CHUNK_K(KLB, KUB)

            if (MonitorPerformance) then
                call StartWatch ("ModuleWaterProperties", "ModifySpecificHeat")
            endif

            !$OMP PARALLEL PRIVATE(i,j,k)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB

                if (WaterPoints3D(i, j, k) == 1) then

                    !One test to verify if the SpecificHeat value is not stupid
                    if (Me%SpecificHeat%Field(i, j, k) > 1e5 .or.                 &
                        Me%SpecificHeat%Field(i, j, k) < 0. )  then
                        !$OMP CRITICAL (MSH1WP_ERR04)
                        write(*,*) 'i,j,k'
                        write(*,*) i,j,k
                        write(*,*) 'SpecificHeat,temperature,salinity'
                        write(*,*) Me%SpecificHeat%Field(i, j, k),T(i, j, k),S(i, j, k)
                        call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR04')
                        !$OMP END CRITICAL (MSH1WP_ERR04)
                    end if

                endif

            enddo
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) then
                call StopWatch ("ModuleWaterProperties", "ModifySpecificHeat")
            endif

            call UnGetGeometry(Me%ObjGeometry,SZZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR3d')

            call UnGetGeometry(Me%ObjGeometry, ZCellCenter, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR3e')


            Me%SpecificHeat%LastActualization = CurrentTime

            nullify (S,T)

            call UnGetMap(Me%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL/= SUCCESS_) call CloseAllAndStop ('ModifySpecificHeat - ModuleWaterProperties - ERR05')

        endif cd10

    end subroutine ModifySpecificHeat

    !--------------------------------------------------------------------------
    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Computes SpecificHeatUNESCO
    !>@param[in] salinity, temperature, depth
    subroutine ComputeSpecificHeatUNESCO (s, t, Depth, WaterPoints3D)
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real,    pointer, dimension(:,:,:), intent(IN)  :: s, t
        integer, pointer, dimension(:,:,:), intent(IN)  :: WaterPoints3D
        real,    pointer, dimension(:,:,:), intent(IN)  :: Depth
        integer                                         :: i, j, k
        integer                                         :: CHUNK
        real                                            :: a, b, c
        real                                            :: cp0, cp1, cp2
        real                                            :: p, sr
        !Begin-----------------------------------------------------------------
        CHUNK = CHUNK_K(Me%WorkSize%KLB, Me%WorkSize%KUB)

        !$OMP PARALLEL PRIVATE(i,j,k, p, sr, a, b, c, cp0, cp1, cp2)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do k = Me%WorkSize%KLB, Me%WorkSize%KUB
        do j = Me%WorkSize%JLB, Me%WorkSize%JUB
        do i = Me%WorkSize%ILB, Me%WorkSize%IUB

            if (WaterPoints3D(i, j, k) == 1) then

                !Scale pressure in bars from depth
                p = Depth(i, j, k)*0.100650603
                sr = sqrt(abs(s(i, j, k)))

                !specific heat for p=0
                a = (-1.38385e-3*t(i, j, k) + 0.1072763)*t(i, j, k) - 7.643575
                b = (5.148e-5*t(i, j, k) - 4.07718e-3)*t(i, j, k) + 0.1770383
                c = (((2.093236e-5*t(i, j, k) - 2.654387e-3)*t(i, j, k) + 0.1412855)*t(i, j, k) - 3.720283) &
                    * t(i, j, k) + 4217.4
                cp0 = (b*sr + a)*s(i, j, k) + c

                !specific heat for s=0
                a = (((1.7168e-8*t(i, j, k) + 2.0357e-6)*t(i, j, k) - 3.13885e-4)*t(i, j, k) + 1.45747e-2)* &
                     t(i, j, k) - 0.49592
                b = (((2.2956e-11*t(i, j, k)-4.0027e-9)*t(i, j, k) + 2.87533e-7)*t(i, j, k) - 1.08645e-5)* &
                    t(i, j, k) + 2.4931e-4
                c = ((6.136e-13*t(i, j, k) - 6.5637e-11)*t(i, j, k) + 2.6380e-9)*t(i, j, k) - 5.422e-8
                cp1 = ((c*p + b)*p + a)*p

                !specific heat for s>0
                a = (((-2.9179e-10*t(i, j, k) + 2.5941e-8)*t(i, j, k) + 9.802e-7)*t(i, j, k) - 1.28315e-4)*t(i, j, k) + 4.9247e-3
                b = (3.122e-8*t(i, j, k) - 1.517e-6)*t(i, j, k) - 1.2331e-4
                a = (a + b*sr)*s(i, j, k)
                b = ((1.8448e-11*t(i, j, k)-2.3905e-9)*t(i, j, k)+1.17054e-7)*t(i, j, k)-2.9558e-6
                b = (b+9.971e-8*sr)*s(i, j, k)
                c = (3.513e-13*t(i, j, k)-1.7682e-11)*t(i, j, k)+5.540e-10
                c = (c-1.4300e-12*t(i, j, k)*sr)*s(i, j, k)
                cp2 = ((c*p + b)*p + a)*p

                Me%SpecificHeat%Field(i, j, k) = cp0 + cp1 + cp2

            end if

        enddo
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

    end subroutine ComputeSpecificHeatUNESCO

    !--------------------------------------------------------------------------


    subroutine ModifySolarRadiation

        !Local-----------------------------------------------------------------
        real,    dimension(:,:,:), pointer          :: SWRadiation, LWRadiation
        real,    dimension(:,:,:), pointer          :: ShortWaveAverage
        real,    dimension(:,:  ), pointer          :: SurfaceRadiation, Shading
        real,    dimension(:,:,:), pointer          :: ShortWaveExtinctionField
        type (T_Time)                               :: CurrentTime
        real                                        :: Thickness
        integer                                     :: STAT_CALL
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, k, kbottom
        real                                        :: LongWaveExtinctionCoef, SWCoef
        real                                        :: SWPercentage, LWPercentage
        integer                                     :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%WorkSize%ILB
        IUB = Me%WorkSize%IUB
        JLB = Me%WorkSize%JLB
        JUB = Me%WorkSize%JUB
        KUB = Me%WorkSize%KUB

        CurrentTime     =  Me%ExternalVar%Now
        SWRadiation     => Me%SolarRadiation%ShortWaveTop
        ShortWaveAverage=> Me%SolarRadiation%ShortWaveAverage
        LWRadiation     => Me%SolarRadiation%LongWaveTop
        Shading         => Me%SolarRadiation%Shading%Field

        SurfaceRadiation => Me%ExtSurface%SurfaceRadiation

        if (Me%SolarRadiation%ShortWave_Kd_2D%ON) then
            if (.not.Me%SolarRadiation%ShortWave_Kd_2D%Constant) then
                call ModifyFillMatrix (FillMatrixID   = Me%SolarRadiation%ShortWave_Kd_2D%ID%ObjFillMatrix, &
                                       Matrix2D       = Me%SolarRadiation%ShortWave_Kd_2D%Field,            &
                                       PointsToFill2D = Me%ExternalVar%WaterPoints2D,                       &
                                       STAT           = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySolarRadiation - ModuleWaterProperties - ERR10')

                call UpdateLightExtinctionSatellite(LightExtinctionID = Me%ObjLightExtinction,                    &
                                                    SatelliteKd2D     = Me%SolarRadiation%ShortWave_Kd_2D%Field,  &
                                                    STAT              = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySolarRadiation - ModuleWaterProperties - ERR20')
            endif
        else
            call Compute_SWExtCoefField
        endif


        call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySolarRadiation - ModuleWaterProperties - ERR30')

        call GetLongWaveExtinctionCoef(Me%ObjLightExtinction, LongWaveExtinctionCoef,STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySolarRadiation - ModuleWaterProperties - ERR40')

        call GetRadiationPercentages(Me%ObjLightExtinction, SWPercentage, LWPercentage, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySolarRadiation - ModuleWaterProperties - ERR50')

        CHUNK = CHUNK_J(JLB, JUB)

        if (MonitorPerformance) then
            call StartWatch ("ModuleWaterProperties", "ModifySolarRadiation")
        endif

        !$OMP PARALLEL PRIVATE(i,j,k,kbottom,Thickness)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do2 :   do j = JLB, JUB
do3 :   do i = ILB, IUB


cd1 :       if (Me%ExternalVar%WaterPoints3D(i, j, KUB) == WaterPoint) then

                kbottom = Me%ExternalVar%KFloor_Z(i, j)

                if (Me%SolarRadiation%ShortWave_Kd_2D%ON) then

                    SWCoef = ShortWaveExtinctionField(i,j,KUB)

                    SWPercentage           = SWPercentage_PaulsonSimpson1977 (SWCoef)
                    LWPercentage           = 1. - SWPercentage
                    LongWaveExtinctionCoef = LWCoef_PaulsonSimpson1977       (SWCoef)

                endif

                SWRadiation(i, j, KUB) = SurfaceRadiation(i, j) * SWPercentage
                LWRadiation(i, j, KUB) = SurfaceRadiation(i, j) * LWPercentage

do1:            do k= KUB-1, kbottom-1, -1

                    Thickness            = Me%ExternalVar%DWZ(i, j, k+1)

                    SWRadiation(i, j, k) = SWRadiation(i,j,k+1) * exp(-ShortWaveExtinctionField(i,j,k+1) * Thickness)

                    LWRadiation(i, j, k) = LWRadiation(i,j,k+1) * exp(-LongWaveExtinctionCoef * Thickness)

                    SWRadiation(i, j, k) = max(SWRadiation(i, j, k), MinRadiation)
                    LWRadiation(i, j, k) = max(LWRadiation(i, j, k), MinRadiation)

                    ShortWaveAverage(i,j,k+1) = (SWRadiation(i, j, k+1)-SWRadiation(i, j, k)) / &
                                                (ShortWaveExtinctionField(i,j,k+1) * Thickness)

                    ShortWaveAverage(i,j,k+1) = max(ShortWaveAverage(i, j, k+1), MinRadiation)

                end do do1

            end if cd1

        end do do3
        end do do2
        !$OMP END DO

cd2:    if (Me%SolarRadiation%Shading%ON) then

            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
do6 :       do j = JLB, JUB
do7 :       do i = ILB, IUB

cd3 :           if (Me%ExternalVar%WaterPoints3D(i, j, KUB) == WaterPoint) then

                    kbottom = Me%ExternalVar%KFloor_Z(i, j)

do8:                do k=kbottom-1, KUB
                        SWRadiation(i, j, k) = SWRadiation(i, j, k)* Shading(i, j)
                    enddo do8

do9:                do k=kbottom, KUB
                        ShortWaveAverage(i, j, k) = ShortWaveAverage(i, j, k)* Shading(i, j)
                    enddo do9

                end if cd3

            end do do7
            end do do6
            !$OMP END DO

        endif  cd2
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleWaterProperties", "ModifySolarRadiation")
        endif

        call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ModifySolarRadiation - ModuleWaterProperties - ERR60')

        !Nullify auxiliar variables
        nullify(SWRadiation)
        nullify(LWRadiation)

    end subroutine ModifySolarRadiation

    !--------------------------------------------------------------------------

    subroutine Compute_SWExtCoefField

        !External--------------------------------------------------------------
        logical                                         :: NeedsParameters      = .false.
        logical                                         :: NeedsConcentrations  = .false.

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                       :: PropertyX
        integer                                         :: STAT_CALL
        real                                            :: ExtinctionParameter

        !Begin-----------------------------------------------------------------

        call GetLightExtinctionOptions(LightExtinctionID    = Me%ObjLightExtinction,        &
                                       NeedsParameters      = NeedsParameters,              &
                                       NeedsConcentrations  = NeedsConcentrations,          &
                                       STAT                 = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)call CloseAllAndStop ('Compute_SWExtCoefField - ModuleWaterProperties - ERR01')

        if(NeedsConcentrations)then

            PropertyX => Me%FirstProperty

            do while (associated(PropertyX))

                if (PropertyX%Evolution%LightExtinction) then

                    if(NeedsParameters)then

                        ExtinctionParameter = PropertyX%Evolution%Extinction%Coefficient

                        if(PropertyX%ID%IDNumber == MacroAlgae_)then

                            call ModifyLightExtinctionField(LightExtinctionID   = Me%ObjLightExtinction,          &
                                                            WaterPoints3D       = Me%ExternalVar%WaterPoints3D,   &
                                                            CurrentTime         = Me%ExternalVar%Now,             &
                                                            PropertyID          = PropertyX%ID%IDNumber,          &
                                                            Concentration       = PropertyX%Concentration,        &
                                                            UnitsCoef           = PropertyX%IScoefficient,        &
                                                            ExtinctionParameter = ExtinctionParameter,            &
                                                            ProducerOccupation  = Me%MacroAlgae%Occupation,       &
                                                            STAT                = STAT_CALL)
                            if (STAT_CALL/= SUCCESS_)                                   &
                                call CloseAllAndStop ('Compute_SWExtCoefField - ModuleWaterProperties - ERR02')

                        elseif(PropertyX%ID%IDNumber == SeagrassesLeaves_)then


                            call ModifyLightExtinctionField(LightExtinctionID        = Me%ObjLightExtinction,          &
                                                                WaterPoints3D        = Me%ExternalVar%WaterPoints3D,   &
                                                                CurrentTime          = Me%ExternalVar%Now,             &
                                                                PropertyID           = PropertyX%ID%IDNumber,          &
                                                                Concentration        = PropertyX%Concentration,        &
                                                                UnitsCoef            = PropertyX%IScoefficient,        &
                                                                ExtinctionParameter  = ExtinctionParameter,            &
                                                                ProducerOccupation   = Me%SeagrassesLeaves%Occupation, &
                                                                STAT                 = STAT_CALL)
                                if (STAT_CALL/= SUCCESS_)                               &
                                    call CloseAllAndStop ('Compute_SWExtCoefField - ModuleWaterProperties - ERR02.1')


                         else

                                call ModifyLightExtinctionField(LightExtinctionID   = Me%ObjLightExtinction,          &
                                                                WaterPoints3D       = Me%ExternalVar%WaterPoints3D,   &
                                                                CurrentTime         = Me%ExternalVar%Now,             &
                                                                PropertyID          = PropertyX%ID%IDNumber,          &
                                                                Concentration       = PropertyX%Concentration,        &
                                                                ExtinctionParameter = ExtinctionParameter,            &
                                                                UnitsCoef           = PropertyX%IScoefficient,        &
                                                                STAT                = STAT_CALL)
                                if (STAT_CALL/= SUCCESS_)                               &
                                    call CloseAllAndStop ('Compute_SWExtCoefField - ModuleWaterProperties - ERR02.2')

                         endif

                    else

                        call ModifyLightExtinctionField(LightExtinctionID   = Me%ObjLightExtinction,          &
                                                        WaterPoints3D       = Me%ExternalVar%WaterPoints3D,   &
                                                        CurrentTime         = Me%ExternalVar%Now,             &
                                                        PropertyID          = PropertyX%ID%IDNumber,          &
                                                        Concentration       = PropertyX%Concentration,        &
                                                        UnitsCoef           = PropertyX%IScoefficient,        &
                                                        STAT                = STAT_CALL)
                        if (STAT_CALL/= SUCCESS_)                                       &
                            call CloseAllAndStop ('Compute_SWExtCoefField - ModuleWaterProperties - ERR03')

                    end if

                  ! endif

                endif

                PropertyX=>PropertyX%Next

            enddo

            nullify(PropertyX)

        else

            call ModifyLightExtinctionField(LightExtinctionID   = Me%ObjLightExtinction,          &
                                            WaterPoints3D       = Me%ExternalVar%WaterPoints3D,   &
                                            CurrentTime         = Me%ExternalVar%Now,             &
                                            STAT                = STAT_CALL)
            if (STAT_CALL/= SUCCESS_)                                                   &
                call CloseAllAndStop ('Compute_SWExtCoefField - ModuleWaterProperties - ERR04')

        end if


    end subroutine Compute_SWExtCoefField

    !--------------------------------------------------------------------------

    subroutine HydroIntegration_Processes

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_CALL

        !------------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "HydroIntegration_Processes")

        !WaterFluxes
        call GetWaterFluxes(Me%ObjHydrodynamic,                                        &
                            WaterFluxX = Me%ExternalVar%WaterFluxX,                    &
                            WaterFluxY = Me%ExternalVar%WaterFluxY,                    &
                            STAT       = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR01')


        !ComputeFaces3D
        call GetComputeFaces3D(Me%ObjMap,                                               &
                               ComputeFacesU3D = Me%ExternalVar%ComputeFacesU3D,        &
                               ComputeFacesV3D = Me%ExternalVar%ComputeFacesV3D,        &
                               STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR02')

        call GetGeometryVolumes(Me%ObjGeometry,                                         &
                                VolumeZOld     = Me%ExternalVar%VolumeZOld,             &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR03')

        !Gets the DischargeFluxes
        call GetDischargesFluxes(Me%ObjHydrodynamic,                     &
                                 Me%ExternalVar%Discharges,              &
                                 STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR04')



        !Updates the HydroIntegration
        call ModifyHydroIntegration(Me%ObjHydroIntegration,              &
                                    Me%ExternalVar%WaterFluxX,           &
                                    Me%ExternalVar%WaterFluxY,           &
                                    Me%ExternalVar%Discharges,           &
                                    Me%ExternalVar%ComputeFacesU3D,      &
                                    Me%ExternalVar%ComputeFacesV3D,      &
                                    Me%ExternalVar%WaterPoints3D,        &
                                    Me%ExternalVar%VolumeZ,              &
                                    Me%ExternalVar%VolumeZOld,           &
                                    Me%ExternalVar%Now,                  &
                                    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR05')


        call UngetHydrodynamic(Me%ObjHydrodynamic, Me%ExternalVar%WaterFluxX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR06')

        call UngetHydrodynamic(Me%ObjHydrodynamic, Me%ExternalVar%WaterFluxY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR07')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesU3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR08')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%ComputeFacesV3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR09')

        call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%VolumeZOld, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR10')

        !Discharges
        call unGetHydrodynamic(Me%ObjHydrodynamic,Me%ExternalVar%Discharges, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            call CloseAllAndStop ('HydroIntegration_Processes - ModuleWaterProperties - ERR11')

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "HydroIntegration_Processes")


    end subroutine HydroIntegration_Processes

    !--------------------------------------------------------------------------

    subroutine OutPut_Results_HDF(iW, StoppingModel)

        !Arguments-------------------------------------------------------------
        integer, optional                  :: iW
        logical, optional                  :: StoppingModel

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL
        real                               :: Year, Month, Day, Hour, Minute, Second

        !Local-----------------------------------------------------------------
        type (T_Property), pointer         :: PropertyX
        real,   dimension(:,:,:), pointer  :: SettlingVelocity
        logical                            :: FirstTime
        integer                            :: OutPutNumber, ObjHDF5
        type (T_Time)                      :: Actual, OutTime, Aux
        real,    dimension(6    ), target  :: AuxTime
        real,    dimension(:    ), pointer :: TimePtr
        integer                            :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                            :: WorkKLB, WorkKUB
        logical                            :: SimpleOutPut
        character(len=StringLength)        :: AuxGroup
        real(8)                            :: AuxPeriod, TotalTime
        logical                            :: StoppingModel_

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "OutPut_Results_HDF")

        SimpleOutPut = .false.

        if (present(StoppingModel)) then
            StoppingModel_ = StoppingModel
        else
            StoppingModel_ = .false.
        endif

        !Saida das diferentes propriedades
        Actual = Me%ExternalVar%Now

        PropertyX => Me%FirstProperty

        FirstTime = .true.

        !Bounds
        if (present(iW)) then

            WorkILB = Me%OutW%OutPutWindows(iW)%ILB
            WorkIUB = Me%OutW%OutPutWindows(iW)%IUB

            WorkJLB = Me%OutW%OutPutWindows(iW)%JLB
            WorkJUB = Me%OutW%OutPutWindows(iW)%JUB

            WorkKLB = Me%OutW%OutPutWindows(iW)%KLB
            WorkKUB = Me%OutW%OutPutWindows(iW)%KUB

            ObjHDF5 = Me%OutW%ObjHDF5(iW)

            !Current output
            OutPutNumber = Me%OutW%OutPutWindows(iW)%NextOutPut
            OutTime      = Me%OutW%OutPutWindows(iW)%OutTime(OutPutNumber)

            if (Me%OutW%Simple) SimpleOutPut = .true.

        else

            WorkILB = Me%WorkSize%ILB
            WorkIUB = Me%WorkSize%IUB

            WorkJLB = Me%WorkSize%JLB
            WorkJUB = Me%WorkSize%JUB

            WorkKLB = Me%WorkSize%KLB
            WorkKUB = Me%WorkSize%KUB

            ObjHDF5 = Me%ObjHDF5

            !Current output
            OutPutNumber = Me%OutPut%NextOutPut
            OutTime      = Me%OutPut%OutTime(OutPutNumber)

            if (Me%ExternalVar%BackTracking) then
                OutPutNumber = Me%OutPut%TotalOutputs - OutPutNumber + 1
            endif

            if (Me%OutPut%Simple) SimpleOutPut = .true.

        endif

TOut:   if (Actual >= OutTime) then

            if (Me%EndTime == OutTime) then
                Me%OutPut%Run_End = .true.
            endif

PropX:      do while (associated(PropertyX))

                if(PropertyX%OutputHDF)then

First:              if (FirstTime) then

                        if (Me%ExternalVar%BackTracking) then
                            TotalTime = Me%EndTime - Me%BeginTime
                            AuxPeriod = Actual     - Me%BeginTime
                            AuxPeriod = TotalTime  - AuxPeriod

                            Aux = Me%BeginTime + AuxPeriod
                        else
                            Aux = Actual
                        endif

                        !Writes current time
                        call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),  &
                                            AuxTime(4), AuxTime(5), AuxTime(6))
                        TimePtr => AuxTime
                        call HDF5SetLimits  (ObjHDF5, 1, 6, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR10')

                        call HDF5WriteData  (ObjHDF5, "/Time", "Time", "YYYY/MM/DD HH:MM:SS", &
                                             Array1D = TimePtr, OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR20')

                        !Writes SZZ
                        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB,        &
                                             WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR30')

                        call HDF5WriteData  (ObjHDF5, "/Grid/VerticalZ", "Vertical",    &
                                             "m", Array3D = Me%ExternalVar%SZZ,         &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR40')

                        !Writes OpenPoints
                        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                 &
                                             WorkJLB, WorkJUB, WorkKLB, WorkKUB,        &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR50')

                        call HDF5WriteData  (ObjHDF5, "/Grid/OpenPoints", "OpenPoints", &
                                             "-", Array3D = Me%ExternalVar%OpenPoints3D,&
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR60')

sp:                     if (.not. SimpleOutPut) then

                            call HDF5WriteData  (ObjHDF5, "/Results/density", "density",&
                                                 "Kg/m3", Array3D = Me%Density%Field,   &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR70')

                        endif sp
                    endif First

                    AuxGroup = "/Results/"

                    if (PropertyX%ID%IDNumber .EQ. Oxygen_ .AND. Me%OutPut%DO_PercentSat) then

                        AuxGroup =  "/Results/Oxygen/"

                    else if (PropertyX%ID%IDNumber .EQ. CarbonDioxide_ .AND. Me%OutPut%CO2_PartialPressure) then

                        AuxGroup = "/Results/Carbon Dioxide/"

                    endif

                    call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                     &
                                         WorkJLB, WorkJUB, WorkKLB, WorkKUB,            &
                                         STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR80')

                    if (Me%WriteHDFReal4 .and. .not. present(iW))then
                        call SetMatrixValue(Me%Output%Aux3Dreal4, Me%Size, PropertyX%Concentration)

                    call HDF5WriteData(ObjHDF5,                                         &
                                       trim(AuxGroup)//PropertyX%ID%Name,               &
                                       PropertyX%ID%Name,                               &
                                       PropertyX%ID%Units,                              &
                                           Array3D      = Me%Output%Aux3Dreal4,         &
                                           OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR90')
                    else

                        call HDF5WriteData(ObjHDF5,                                     &
                                           trim(AuxGroup)//PropertyX%ID%Name,           &
                                           PropertyX%ID%Name,                           &
                                           PropertyX%ID%Units,                          &
                                       Array3D      = PropertyX%Concentration,          &
                                       OutputNumber = OutPutNumber, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR100')
                    endif

                    if (PropertyX%Evolution%DataAssimilation /= NoNudging .and. .not. SimpleOutPut .and. .not. StoppingModel_) then

    i4 :                if (PropertyX%SubModel%ON) then


                            PropertyX%Assimilation%GroupOutPutName = PropertyX%ID%Name

                        else i4

                            call GetAssimilationField(AssimilationID  = Me%ObjAssimilation,                     &
                                                      ID              = PropertyX%ID%IDNumber,                  &
                                                      N_Field         = 1,                                      &
                                                      GroupOutPutName = PropertyX%Assimilation%GroupOutPutName, &
                                                      STAT            = STAT_CALL)

                            if (STAT_CALL /= SUCCESS_) then
                                call GetAssimilationField(AssimilationID  = Me%ObjAssimilation,                     &
                                                          ID              = PropertyX%ID%IDNumber,                  &
                                                          N_Field         = 1,                                      &
                                                          GroupOutPutName = PropertyX%Assimilation%GroupOutPutName, &
                                                          Upscaling       = .true.,                                 &
                                                          STAT            = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) then
                                    write(*,*) 'Cannot find Property name: ', trim(PropertyX%ID%Name)
                                    write(*,*) 'in module assimilation'
                                    call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR105')
                                endif
                            endif
                        end if i4

                        call HDF5WriteData(ObjHDF5,                                     &
                                           trim(AuxGroup)//'Assimila/'//                &
                                           trim(PropertyX%Assimilation%GroupOutPutName),&
                                           PropertyX%ID%Name,                           &
                                           PropertyX%ID%Units,                          &
                                           Array3D      = PropertyX%Assimilation%Field, &
                                           OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR110')
                    endif

                    if (PropertyX%Evolution%Filtration%On .and. .not. SimpleOutPut) then

                        call HDF5WriteData(ObjHDF5,                                     &
                                           "/Results/Filtration/"//PropertyX%ID%Name,   &
                                           PropertyX%ID%Name,                           &
                                           PropertyX%ID%Units,                          &
                                           Array3D      = PropertyX%Filtration,         &
                                           OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR120')

                    endif


                    if (PropertyX%Evolution%FreeVerticalMovement .and. PropertyX%OutputHDFSedVel) then


                        call Get_FreeVelocity(FreeVerticalMovementID = Me%ObjFreeVerticalMovement,&
                                              PropertyID             = PropertyX%ID%IDNumber,     &
                                              Free_Velocity          = SettlingVelocity,          &
                                              STAT                   = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR130')

                        call HDF5WriteData(ObjHDF5,                                     &
                                           "/Results/SettlingVelocity/"//PropertyX%ID%Name,   &
                                           PropertyX%ID%Name,                           &
                                           "m/s",                                       &
                                           Array3D      = SettlingVelocity,             &
                                           OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR140')


                        call UngetFreeVerticalMovement(FreeVerticalMovementID = Me%ObjFreeVerticalMovement,&
                                                       Array                  = SettlingVelocity,          &
                                                       STAT                   = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR150')
                    endif

                    if (PropertyX%UpscalingSinkSource .and. allocated(PropertyX%UpscalingMassLoss)) then
                        call HDF5WriteData(ObjHDF5,                                     &
                                           "/Results/Upscaling/"//PropertyX%ID%Name,   &
                                           PropertyX%ID%Name,                           &
                                           PropertyX%ID%Units,                          &
                                           Array3D      = GetPointer(PropertyX%UpscalingMassLoss),  &
                                           OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR121')
                    endif

                    if (FirstTime) FirstTime = .false.

                 end if

                PropertyX => PropertyX%Next

            enddo PropX

            if (Me%OutPut%AditionalFields) then
                if (present(iW)) then
sp3:                if (.not. SimpleOutPut) then
                        call OutPutHDF_AditionalFields (OutPutNumber, iW)
                    endif sp3
                else
                    call OutPutHDF_AditionalFields (OutPutNumber)
                endif
            endif

            if (Me%Coupled%MacroAlgae%Yes .and. .not. SimpleOutPut)then

                call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                         &
                                     WorkJLB, WorkJUB, WorkKLB, WorkKUB,                &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR160')

                call HDF5WriteData  (ObjHDF5, "/Results/"//"macroalgae distribution",   &
                                     "macroalgae distribution", "gC/m2",                &
                                     Array2D = Me%MacroAlgae%Distribution,              &
                                     OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR170')

            end if


             if (Me%Coupled%SeagrassesLeaves%Yes .and. .not. SimpleOutPut)then

                       call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                  &
                                             WorkJLB, WorkJUB, WorkKLB, WorkKUB,        &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR142')

                        call HDF5WriteData  (ObjHDF5, "/Results/"//"seagrasses leaves biomass",   &
                                             "seagrasses leaves biomass", "gdw/m2",                &
                                             Array2D = Me%SeagrassesLeaves%Biomass,              &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR144')


           endif


            !Bounds
            if (present(iW)) then
                Me%OutW%OutPutWindows(iW)%NextOutPut = Me%OutW%OutPutWindows(iW)%NextOutPut + 1
            else
                Me%OutPut%NextOutPut                 = Me%OutPut%NextOutPut                 + 1
            endif

            !Writes everything to disk
            call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR180')

        endif  TOut

        nullify(PropertyX)

        if(Me%OutPut%WriteRestartFile .and. .not. Me%OutPut%Run_End)then

            if(Actual >= Me%OutPut%RestartOutTime(Me%OutPut%NextRestartOutput))then

                if (.not. Me%Coupled%AllSolutionFromFile)                               &
                    call Write_FinalWaterProperties_HDF

                Me%OutPut%NextRestartOutput = Me%OutPut%NextRestartOutput + 1

                call ExtractDate(Actual, Year = Year, Month  = Month,  Day    = Day, &
                                         Hour = Hour, Minute = Minute, Second = Second)


                call SetError(WARNING_, INTERNAL_, "Water properties restart file saved    : ", &
                              Year, Month, Day, Hour, Minute, Second)

            end if

        end if

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "OutPut_Results_HDF")

    end subroutine OutPut_Results_HDF

    !--------------------------------------------------------------------------

    subroutine OutPut_SurfaceResults_HDF

        !External--------------------------------------------------------------
        integer                            :: STAT_CALL
        real                               :: Year, Month, Day, Hour, Minute, Second

        !Local-----------------------------------------------------------------
        type (T_Property), pointer         :: PropertyX
        logical                            :: FirstTimeSurface
        integer                            :: SurfaceOutPutNumber
        real(8)                            :: TotalTime, AuxPeriod
        type (T_Time)                      :: Actual, SurfaceOutTime, Aux
        integer, dimension (6)             :: TimeAux
        integer                            :: ILB, IUB, JLB, JUB, KLB, KUB
        real,    dimension(6    ), target  :: AuxTime
        real,    dimension(:    ), pointer :: TimePtr
        integer                            :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                            :: WorkKLB, WorkKUB

        !----------------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "OutPut_SurfaceResults_HDF")


        ILB = Me%Size%ILB
        IUB = Me%Size%IUB

        JLB = Me%Size%JLB
        JUB = Me%Size%JUB

        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB


        !Saida das diferentes propriedades
        Actual = Me%ExternalVar%Now

        PropertyX => Me%FirstProperty


        !surface outputs
        SurfaceOutPutNumber = Me%OutPut%NextSurfaceOutPut
        SurfaceOutTime      = Me%OutPut%SurfaceOutTime(SurfaceOutPutNumber)

        if ( Me%ExternalVar%BackTracking) then
            SurfaceOutPutNumber = Me%OutPut%TotalSurfaceOutputs - SurfaceOutPutNumber + 1
        endif

AO:     if (Actual >= SurfaceOutTime) then

            FirstTimeSurface = .true.

            PropertyX => Me%FirstProperty

            do while (associated(PropertyX))

                if(PropertyX%OutputSurfaceHDF)then

                    call ExtractDate(Actual, Year = Year, Month  = Month,  Day    = Day, &
                                             Hour = Hour, Minute = Minute, Second = Second)

                    TimeAux(1) = int(Year  )
                    TimeAux(2) = int(Month )
                    TimeAux(3) = int(Day   )
                    TimeAux(4) = int(Hour  )
                    TimeAux(5) = int(Minute)
                    TimeAux(6) = int(Second)

                    if (FirstTimeSurface) then

                        if (Me%ExternalVar%BackTracking) then
                            TotalTime = Me%EndTime - Me%BeginTime
                            AuxPeriod = Actual     - Me%BeginTime
                            AuxPeriod = TotalTime  - AuxPeriod

                            Aux = Me%BeginTime + AuxPeriod
                        else
                            Aux = Actual
                        endif

                        !Writes current time
                        call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),    &
                                                 AuxTime(4), AuxTime(5), AuxTime(6))
                        TimePtr => AuxTime

                        call HDF5SetLimits  (Me%ObjSurfaceHDF5, 1, 6, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR10')

                        call HDF5WriteData  (Me%ObjSurfaceHDF5,                         &
                                            "/Time",                                    &
                                            "Time", "YYYY/MM/DD HH:MM:SS",              &
                                             Array1D      = TimePtr,                    &
                                             OutputNumber = SurfaceOutPutNumber,        &
                                             STAT         = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR20')

                       !Writes VerticalZ
                        call HDF5SetLimits  (Me%ObjSurfaceHDF5, WorkILB, WorkIUB,       &
                                             WorkJLB, WorkJUB, WorkKUB-1, WorkKUB, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR30')

                        call HDF5WriteData  (Me%ObjSurfaceHDF5,                         &
                                             "/Grid/VerticalZ",                         &
                                             "Vertical", "m",                           &
                                             Array3D        = Me%ExternalVar%SZZ,       &
                                             OutputNumber   = SurfaceOutPutNumber,      &
                                             STAT           = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR35')

                        !Writes OpenPoints
                        call HDF5SetLimits  (Me%ObjSurfaceHDF5, WorkILB, WorkIUB,       &
                                             WorkJLB, WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR40')


                        call HDF5WriteData  (Me%ObjSurfaceHDF5,                         &
                                             "/Grid/OpenPoints",                        &
                                             "OpenPoints", "-",                         &
                                             Array3D      = Me%ExternalVar%OpenPoints3D,&
                                             OutputNumber = SurfaceOutPutNumber,        &
                                             STAT         = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR50')

                        FirstTimeSurface = .false.

                    endif

                    call HDF5SetLimits  (Me%ObjSurfaceHDF5, WorkILB, WorkIUB,           &
                                         WorkJLB, WorkJUB, WorkKUB, WorkKUB, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)  &
                        call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR60')

                   if (Me%WriteHDFReal4)then
                        call SetMatrixValue(Me%Output%Aux3Dreal4, Me%Size, PropertyX%Concentration)

                        call HDF5WriteData  (Me%ObjSurfaceHDF5,                         &
                                            "/Results/"//PropertyX%ID%Name,             &
                                            PropertyX%ID%Name, PropertyX%ID%Units,      &
                                            Array3D      = Me%Output%Aux3Dreal4,        &
                                            OutputNumber = SurfaceOutPutNumber,         &
                                            STAT         = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR70')

                   else

                        call HDF5WriteData  (Me%ObjSurfaceHDF5,                         &
                                        "/Results/"//PropertyX%ID%Name,                 &
                                        PropertyX%ID%Name, PropertyX%ID%Units,          &
                                        Array3D      = PropertyX%Concentration,         &
                                        OutputNumber = SurfaceOutPutNumber,             &
                                        STAT         = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)  &
                            call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR80')
                   endif


                end if


                PropertyX => PropertyX%Next

                Me%OutPut%NextSurfaceOutPut = SurfaceOutPutNumber + 1

            enddo

            call HDF5FlushMemory (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR90')

        endif AO

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "OutPut_SurfaceResults_HDF")

    end subroutine OutPut_SurfaceResults_HDF

    !--------------------------------------------------------------------------

    subroutine OutPutHDF_AditionalFields (OutPutNumber, iW)

        !Arguments-------------------------------------------------------------
        integer                                     :: OutPutNumber
        integer, optional                           :: iW


        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: PropSalinity, PropTemperature, PropOxygen, PropCO2, PropPhytoplankton
        real,   dimension(:,:,:), pointer           :: ShortWaveAverage, ShortWaveExtinctionField
        character (Len = StringLength)              :: PropName, PropName2, CChla_text
        real                                        :: DOSAT, Palt, CO2PP, Pressure, Chla
        integer                                     :: STAT_CALL, ObjHDF5
        integer                                     :: WILB, WIUB, WJLB, WJUB, WKUB, i, j, k, kbottom

        !Begin----------------------------------------------------------------------

        !Bounds
        if (present(iW)) then

            WILB = Me%OutW%OutPutWindows(iW)%ILB
            WIUB = Me%OutW%OutPutWindows(iW)%IUB

            WJLB = Me%OutW%OutPutWindows(iW)%JLB
            WJUB = Me%OutW%OutPutWindows(iW)%JUB

            ObjHDF5 = Me%OutW%ObjHDF5(iW)

        else

            WILB = Me%WorkSize%ILB
            WIUB = Me%WorkSize%IUB

            WJLB = Me%WorkSize%JLB
            WJUB = Me%WorkSize%JUB

            ObjHDF5 = Me%ObjHDF5

        endif


        WKUB = Me%WorkSize%KUB

        call SetMatrixValue(Me%OutPut%Aux3D, Me%Size, 0.)

        call SetMatrixValue(Me%OutPut%Aux2D, T_Size2D(WILB, WIUB, WJLB, WJUB), 0.)

        if (Me%OutPut%DO_PercentSat .OR. Me%OutPut%CO2_PartialPressure) then
            !Search the temperature
            call Search_Property(PropTemperature, PropertyXID = Temperature_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR10')
            endif

            !Search the salinity
            call Search_Property(PropSalinity, PropertyXID = Salinity_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR20')
            endif

        endif


        if (Me%OutPut%CHLA_WQ) then

            call Search_Property(PropPhytoplankton, PropertyXID = Phytoplankton_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR25')
            endif

            if (Me%OutPut%C_CHLA .LE. 0.0) then
                call CloseAllAndStop ('*** C:CHLA ratio equal or lesser than 0 ***')
            endif


        endif


i1:     if (Me%OutPut%DO_PercentSat) then

            call Search_Property(PropOxygen, PropertyXID = Oxygen_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR30')
            endif


i3:         if (me%DoSatType.eq.Apha) then

                do j=WJLB, WJUB
                do i=WILB, WIUB

                    if (Me%ExternalVar%OpenPoints3D(i, j, WKUB) == OpenPoint) then

                        kbottom = Me%ExternalVar%Kfloor_Z(i,j)

                        do k = kbottom, WKUB

                            DOSAT = OxygenSaturation(PropTemperature%Concentration(i,j,k), &
                                                     PropSalinity%Concentration(i,j,k))

                            !New Concentration
                            Me%OutPut%Aux3D(i, j, k) = PropOxygen%Concentration(i, j, k) / DOSAT * 100.

                        enddo

                        Me%OutPut%Aux2D(i, j) = PropOxygen%SurfaceFlux(i, j)

                    endif
                enddo
                enddo

            else if (me%DoSatType.eq.Henry) then i3

                do j=WJLB, WJUB
                do i=WILB, WIUB

                    if (Me%ExternalVar%OpenPoints3D(i, j, WKUB) == OpenPoint) then

                        kbottom = Me%ExternalVar%Kfloor_Z(i,j)

                        do k = kbottom, WKUB

                            DOSAT = OxygenSaturationHenry(PropTemperature%Concentration(i,j,k))

                            !New Concentration
                            Me%OutPut%Aux3D(i, j, k) = PropOxygen%Concentration(i, j, k) / DOSAT * 100.

                        enddo

                        Me%OutPut%Aux2D(i, j) = PropOxygen%SurfaceFlux(i, j)

                    endif
                enddo
                enddo

            else if (me%DoSatType.eq.Mortimer) then i3
                !altitude correction

                Palt =(1-((me%Altitude)/1000)/44.3)**5.25

                do j=WJLB, WJUB
                do i=WILB, WIUB

                    if (Me%ExternalVar%OpenPoints3D(i, j, WKUB) == OpenPoint) then

                        kbottom = Me%ExternalVar%Kfloor_Z(i,j)

                        do k = kbottom, WKUB

                            DOSAT = OxygenSaturationCeQualW2(PropTemperature%Concentration(i,j,k), &
                                                             PropSalinity%Concentration   (i,j,k), &
                                                             Palt)

                            !New Concentration
                            Me%OutPut%Aux3D(i, j, k) = PropOxygen%Concentration(i, j, k) / DOSAT * 100.

                        enddo

                        Me%OutPut%Aux2D(i, j) = PropOxygen%SurfaceFlux(i, j)

                    endif
                enddo
                enddo
            endif i3

            PropName = trim(GetPropertyName(DissolO2PercentSat_))

            PropName2 = trim(GetPropertyName(SpecificOxygenFlux_))

            call HDF5WriteData  (ObjHDF5, "/Results/Oxygen/"//PropName, PropName,'%',       &
                                 Array3D = Me%OutPut%Aux3D,                             &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR40')


            call HDF5WriteData  (ObjHDF5, "/Results/Oxygen/"//PropName2, PropName2,'mg m-2 s-1',   &
                                Array2D = Me%OutPut%Aux2D,                                         &
                                OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR45')

            nullify(PropOxygen)

        endif i1


i2:     if (Me%OutPut%Radiation) then

            ShortWaveAverage => Me%SolarRadiation%ShortWaveAverage

            call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR50')

             PropName = trim(GetPropertyName(ShortWaveSolarRadiation_))

            call HDF5WriteData  (ObjHDF5, "/Results/"//PropName, PropName,'W/m2', Array3D = ShortWaveAverage, &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR60')

            nullify(ShortWaveAverage)

            PropName = trim(GetPropertyName(ShortWaveSolarRadiationExtin_))

            call HDF5WriteData  (ObjHDF5, "/Results/"//PropName, PropName,'1/m', Array3D = ShortWaveExtinctionField, &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR70')

               call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR80')

        endif i2


 i5:     if (Me%OutPut%CO2_PartialPressure) then

            call Search_Property(PropCO2, PropertyXID = CarbonDioxide_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR120')
            endif

            Pressure = 0.01      ! set to constant

            do j=WJLB, WJUB
            do i=WILB, WIUB

                    if (Me%ExternalVar%OpenPoints3D(i, j, WKUB) == OpenPoint) then

                        kbottom = Me%ExternalVar%Kfloor_Z(i,j)

                        do k = kbottom, WKUB

                            CO2PP = CO2PartialPressure(PropCO2%Concentration(i,j,k),    &
                                    PropTemperature%Concentration(i,j,k),               &
                                    PropSalinity%Concentration(i,j,k),                  &
                                    Pressure, Me%Density%Field(i,j,k))

                            !New Concentration
                            Me%OutPut%Aux3D(i, j, k) = CO2PP

                        enddo

                    Me%OutPut%Aux2D(i, j) = PropCO2%SurfaceFlux(i, j)

                    endif
               enddo
               enddo


          PropName = trim(GetPropertyName(CO2PartialPressure_))

          PropName2 = trim(GetPropertyName(SpecificCarbonDioxideFlux_))


            call HDF5WriteData  (ObjHDF5, "/Results/Carbon Dioxide/"//PropName, PropName,'uatm',       &
                                 Array3D = Me%OutPut%Aux3D,                             &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR100')

            call HDF5WriteData  (ObjHDF5, "/Results/Carbon Dioxide/"//PropName2, PropName2,'mmol m-2 s-1',  &
                                 Array2D = Me%OutPut%Aux2D,                             &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR110')


  ! CO2 flux Ouput in mmol m-2 d-1
                do j=WJLB, WJUB
                do i=WILB, WIUB

                    if (Me%ExternalVar%OpenPoints3D(i, j, WKUB) == OpenPoint) then

                    Me%OutPut%Aux2D(i, j) = Me%OutPut%Aux2D(i, j) * 86400.

                    endif
               enddo
               enddo


            call HDF5WriteData  (ObjHDF5, "/Results/Carbon Dioxide/CO2flux_day", "CO2flux_day",'mmol m-2 d-1',  &
                                 Array2D = Me%OutPut%Aux2D,                             &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR120')


            nullify(PropCO2)

          endif i5



 i6:     if (Me%OutPut%CHLA_WQ) then

            call Search_Property(PropPhytoplankton, PropertyXID = Phytoplankton_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR130')
            endif


            do j=WJLB, WJUB
            do i=WILB, WIUB

                    if (Me%ExternalVar%OpenPoints3D(i, j, WKUB) == OpenPoint) then

                        kbottom = Me%ExternalVar%Kfloor_Z(i,j)

                        do k = kbottom, WKUB

                            ! conversion from mg C L-1 to ug Chla L-1
                            Chla =  PropPhytoplankton%Concentration(i,j,k) /            &
                                    Me%OutPut%C_CHLA *                                  &
                                    1000


                            !New Concentration
                            Me%OutPut%Aux3D(i, j, k) = Chla

                        enddo


                    endif
               enddo
               enddo



          ! output for phytoplankton Chla based on a given C:Chla

          Write (Unit=CChla_text, FMT="(F4.1)") Me%OutPut%C_CHLA

!          PropName = trim(GetPropertyName(PhytoChla_))//" (C:Chla="//trim(CChla_text)//")"

           PropName = trim(GetPropertyName(PhytoChla_))


            call HDF5WriteData  (ObjHDF5, "/Results/"//PropName, PropName,'ug/L',       &
                                 Array3D = Me%OutPut%Aux3D,                             &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPutHDF_AditionalFields - ModuleWaterProperties - ERR120')


            nullify(PropPhytoplankton)

        endif i6


        if (Me%OutPut%DO_PercentSat) then
            nullify(PropTemperature   )
            nullify(PropSalinity      )
        endif

        if (Me%OutPut%CO2_PartialPressure) then
            nullify(PropCO2   )
        endif

        if (Me%OutPut%DO_PercentSat) then
            nullify(PropOxygen   )
        endif

        if (Me%OutPut%CHLA_WQ) then
            nullify(PropPhytoplankton   )
        endif


    end subroutine OutPutHDF_AditionalFields

    !--------------------------------------------------------------------------

    subroutine OutPut_TimeSeries
        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
        real                                    :: DepthLevel
        integer                                 :: STAT_CALL, TimeSerieNumber, dn, id, jd, kd
        logical                                 :: DepthON, IgnoreOK

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "OutPut_TimeSeries")

        !Corrects if necessary the cell of the time serie based in the time serie depth
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR10')

        do dn = 1, TimeSerieNumber

            call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR20')

            if (IgnoreOK) cycle

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                      LocalizationI = id,                               &
                                      LocalizationJ = jd,                               &
                                      DepthLevel    = DepthLevel,                       &
                                      DepthON       = DepthON,                          &
                                      STAT          = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR10')

            if (DepthON) then

                kd = GetLayer4Level(Me%ObjGeometry, id, jd, DepthLevel, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR40')

                call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn,  k = kd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR50')

                if (Me%ExternalVar%WaterPoints3D(id, jd, kd) /= WaterPoint .and. Me%FirstIteration) then

                    write(*,*) 'Time serie station I=',Id, 'J=',Jd,'K=',kd,'is located in land'
                    write(*,*) 'OutPut_TimeSeries - ModuleWaterProperties - WRN100'

                endif
            endif


        enddo

        !Calls Time Serie for every property
        PropertyX   => Me%FirstProperty
        do while (associated(PropertyX))
            if (PropertyX%TimeSerie) then

                call WriteTimeSerie(Me%ObjTimeSerie,                                     &
                                    Data3D = PropertyX%Concentration, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                               &
                    call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR60')

                if (PropertyX%Evolution%Filtration%On) then

                    call WriteTimeSerie(Me%ObjTimeSerie,                                     &
                                        Data3D = PropertyX%Filtration, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                               &
                        call CloseAllAndStop ('OutPut_TimeSeries - ModuleWaterProperties - ERR70')
                endif
            endif

            PropertyX=>PropertyX%Next

        enddo

        if (Me%OutPut%AditionalFields) then

            call Output_Timeseries_AditionalResults()

        endif


        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "OutPut_TimeSeries")


    end subroutine OutPut_TimeSeries

    !--------------------------------------------------------------------------

    subroutine Output_Timeseries_AditionalResults()

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        real,   dimension(:,:,:), pointer       :: ShortWaveExtinctionField


i2:     if (Me%OutPut%Radiation) then


            call GetShortWaveExtinctionField(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Output_Timeseries_AditionalResults - ModuleWaterProperties - ERR80')

            call WriteTimeSerie(Me%ObjTimeSerie,                                     &
                                Data3D = Me%SolarRadiation%ShortWaveAverage, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                               &
                call CloseAllAndStop ('Output_Timeseries_AditionalResults - ModuleWaterProperties - ERR90')


            call WriteTimeSerie(Me%ObjTimeSerie,                                     &
                                Data3D = ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                               &
                call CloseAllAndStop ('Output_Timeseries_AditionalResults - ModuleWaterProperties - ERR100')

            call UnGetLightExtinction(Me%ObjLightExtinction, ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Output_Timeseries_AditionalResults - ModuleWaterProperties - ER110')

        endif i2

    end subroutine Output_Timeseries_AditionalResults

    !-------------------------------------------------------------------------


    subroutine OutPut_Profile

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "OutPut_Profile")


        !Calls Time Serie for every property
        PropertyX   => Me%FirstProperty
        do while (associated(PropertyX))

            if (PropertyX%OutputProfile) then
                call WriteProfile(Me%ObjProfile,                                        &
                                  PropertyX%Concentration,                              &
                                  SZZ    = Me%ExternalVar%SZZ,                          &
                                  STAT   = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call CloseAllAndStop ('OutPut_Profile - ModuleWaterProperties - ERR01')
            endif

            PropertyX=>PropertyX%Next
        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "OutPut_Profile")


    end subroutine OutPut_Profile

    !--------------------------------------------------------------------------

    subroutine OutPut_BoxTimeSeries

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
        integer                                 :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                 :: i, j, k
        !$ integer                              :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%Size%ILB
        IUB = Me%Size%IUB
        JLB = Me%Size%JLB
        JUB = Me%Size%JUB
        KLB = Me%Size%KLB
        KUB = Me%Size%KUB

        if (MonitorPerformance) call StartWatch ("ModuleWaterProperties", "OutPut_BoxTimeSeries")

        !!$ CHUNK = CHUNK_J(JLB, JUB) Sobrinho
        !$ CHUNK = CHUNK_K(KLB, KUB)

        PropertyX  => Me%FirstProperty

        do while (associated(PropertyX))
            if (PropertyX%BoxTimeSerie) then

                Me%CellMass(:,:,:) = 0.

                if(.not. PropertyX%BoxIntegrationByArea) then

                    !$OMP PARALLEL PRIVATE(I,J,K)
                    !$OMP DO SCHEDULE(STATIC, CHUNK)
                    do K = KLB, KUB
                    do J = JLB, JUB
                    do I = ILB, IUB
                        Me%CellMass(i,j,k) = PropertyX%Concentration(i, j, k) * &
                                             Me%ExternalVar%VolumeZ(i, j, k)
                    end do
                    end do
                    end do
                    !$OMP END DO
                    !$OMP END PARALLEL

                else

                    !$OMP PARALLEL PRIVATE(I,J,K)
                    !$OMP DO SCHEDULE(STATIC, CHUNK)
                    do K = KLB, KUB
                    do J = JLB, JUB
                    do I = ILB, IUB
                        Me%CellMass(i,j,k) = PropertyX%Concentration(i, j, k) * &
                                             Me%ExternalVar%GridCellArea(i, j)
                    end do
                    end do
                    end do
                    !$OMP END DO
                    !$OMP END PARALLEL

                endif

                call BoxDif(Me%ObjBoxDif, Me%CellMass,                      &
                            trim(PropertyX%ID%name),                        &
                            Me%ExternalVar%OpenPoints3D,                   &
                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)  &
                    call CloseAllAndStop ('OutPut_BoxTimeSeries - ModuleWaterProperties - ERR01')

                Me%CellMass(:,:,:) = null_real
            endif

            PropertyX=>PropertyX%Next

        enddo

        if (MonitorPerformance) call StopWatch ("ModuleWaterProperties", "OutPut_BoxTimeSeries")

    end subroutine OutPut_BoxTimeSeries


    !--------------------------------------------------------------------------


    subroutine OutPut_Statistics

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
!        real,    dimension(:,:), pointer        :: MLD_Surf
        integer                                 :: MethodStatistic, LayerDefinition
        integer                                 :: Depth, Layer, Value3DStatLayers,      &
                                                   LayersNumber, ln
        integer                                 :: STAT_CALL

        PropertyX   => Me%FirstProperty
        do while (associated(PropertyX))
            if (PropertyX%Statistics) then

                call GetStatisticMethod (PropertyX%StatisticID, MethodStatistic,         &
                                         STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)                                               &
                    call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR01')

                call GetStatisticParameters (PropertyX%StatisticID,                      &
                                             Value3DStatLayers = Value3DStatLayers,      &
                                             Depth             = Depth,                  &
                                             Layer             = Layer,                  &
                                             STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                  &
                    call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR02')



                if (MethodStatistic == Value3DStatLayers) then


!                    nullify(MLD_Surf)

                    call GetStatisticLayersNumber(PropertyX%StatisticID, LayersNumber, STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_)                                              &
                            call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR03')

                    do ln=1, LayersNumber

                        call GetStatisticLayerDef(PropertyX%StatisticID, ln, LayerDefinition, STAT = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_)                                          &
                                call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR04')


                        !Statistic of properties values along the bottom
                        if (LayerDefinition == Layer) then


                            call AddStatisticLayers (StatisticID    = PropertyX%StatisticID,        &
                                                     Value3D        = PropertyX%Concentration,      &
                                                     WaterPoints3D  = Me%ExternalVar%WaterPoints3D, &
                                                     DZ3D           = Me%ExternalVar%DWZ,           &
                                                     LayerNumber    = ln,                           &
                                                     STAT= STAT_CALL)

                            if (STAT_CALL /= SUCCESS_)                                              &
                                call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR06')


                        !Statistic of properties values in the surface mixed layer
                        else if (LayerDefinition == Depth) then

!                            call GetMLD_Surf(Me%ObjTurbulence, MLD_Surf, STAT = STAT_CALL)
!                            if (STAT_CALL /= SUCCESS_)                                      &
!                                call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR07'))

                            call AddStatisticLayers (StatisticID    = PropertyX%StatisticID,        &
                                                     Value3D        = PropertyX%Concentration,      &
                                                     WaterPoints3D  = Me%ExternalVar%WaterPoints3D, &
                                                     DZ3D           = Me%ExternalVar%DWZ,           &
                                                     LayerNumber    = ln,                           &
!                                                     LowerDepth     = MLD_Surf,                     &
                                                     STAT= STAT_CALL)

                            if (STAT_CALL /= SUCCESS_)                                              &
                                call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR08')

                        endif


                    enddo

                endif

                call ModifyStatistic (PropertyX%StatisticID,                             &
                                      Value3D       = PropertyX%Concentration,           &
                                      WaterPoints3D = Me%ExternalVar%WaterPoints3D,      &
                                      STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                               &
                    call SetError (FATAL_, KEYWORD_, 'OutPut_Statistics - ModuleWaterProperties - ERR09')

            endif
            PropertyX=>PropertyX%Next
        enddo


    end subroutine OutPut_Statistics

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine CopyTemperature(WaterPropertiesID, Size3D, Temperature, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Temperature
        type (T_Size3D)                             :: Size3D
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            !call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            call CopyConcentration(WaterPropertiesID, Size3D,                   &
                                   ConcentrationX = Temperature,                &
                                   PropertyXIDNumber = Temperature_, STAT = STAT_)

            !call Read_UnLock?

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyTemperature

    !--------------------------------------------------------------------------

    subroutine CopySalinity(WaterPropertiesID, Size3D, Salinity, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Salinity
        type (T_Size3D)                             :: Size3D
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            !call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            call CopyConcentration(WaterPropertiesID, Size3D,                   &
                                   ConcentrationX = Salinity,                   &
                                   PropertyXIDNumber = Salinity_, STAT = STAT_)

            !call Read_UnLock?

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopySalinity

    !--------------------------------------------------------------------------

    subroutine CopyDensity(WaterPropertiesID, Size3D, Density, SigmaDensity, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        type (T_Size3D)                             :: Size3D
        real, pointer, dimension(:,:,:)             :: Density, SigmaDensity
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            !call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            !density
            call SetMatrixValue(Me%Density%Field, Size3D, Density)

            !sigma density
            call SetMatrixValue(Me%Density%Sigma, Size3D, SigmaDensity)

            STAT_ = SUCCESS_

            !call Read_UnLock?

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyDensity

    !--------------------------------------------------------------------------

    subroutine CopyConcentration(WaterPropertiesID, Size3D, ConcentrationX,     &
                                 PropertyXIDNumber, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: ConcentrationX
        type (T_Size3D)                             :: Size3D
        integer,                      intent(IN )   :: PropertyXIDNumber
        integer, optional, intent(OUT)              :: STAT

        !External--------------------------------------------------------------
        integer :: ready_

        !Local-----------------------------------------------------------------
        integer :: STAT_              !Auxiliar local variable
        integer                                     :: STAT_CALL
        type(T_Property), pointer                   :: PropertyX

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            !call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber,    &
                                 STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                call SetMatrixValue(PropertyX%concentration, Size3D, ConcentrationX)

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if

            !call Read_UnLock?

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine CopyConcentration

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SE

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !--------------------------------------------------------------------------

    subroutine GetWaterPropertiesNumber(WaterPropertiesID, NumberPropertiesX, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,           intent(OUT)              :: NumberPropertiesX
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then


            NumberPropertiesX = Me%PropertiesNumber


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterPropertiesNumber


    !----------------------------------------------------------------------


    subroutine GetWaterPropertyOptions(WaterPropertiesID, PropIDNumber, DTInterval, &
                                       BottomFluxes, FreeVerticalMovement, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,           intent(IN )              :: PropIDNumber
        real,              intent(OUT)              :: DTInterval
        logical,           intent(OUT)              :: BottomFluxes
        logical,           intent(OUT)              :: FreeVerticalMovement
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        type(T_Property), pointer                   :: PropertyX

        !----------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropIDNumber, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                DTInterval           = PropertyX%Evolution%DTInterval

                BottomFluxes         = PropertyX%Evolution%BottomFluxes

                FreeVerticalMovement =  PropertyX%Evolution%FreeVerticalMovement

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if
        else cd1
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_


        !----------------------------------------------------------------------

    end subroutine GetWaterPropertyOptions

    !--------------------------------------------------------------------------

    !----------------------------------------------------------------------

    subroutine GetDensityOptions(WaterPropertiesID, DensityMethod, PressureCorrection, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, intent(OUT)                        :: DensityMethod
        logical, intent(OUT)                        :: PressureCorrection
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            DensityMethod = Me%Density%Method

            PressureCorrection = Me%Density%CorrecPress

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_


        !----------------------------------------------------------------------

    end subroutine GetDensityOptions

    !--------------------------------------------------------------------------

    subroutine GetWaterNeedsFather(WaterPropertiesID, WaterNeedsFather, PropNumber, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        logical,             intent(OUT)            :: WaterNeedsFather
        integer,             intent(OUT)            :: PropNumber
        integer,   optional, intent(OUT)            :: STAT

        !Local-------------------------------------------------------------------
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_
        integer                                     :: ready_

        !Begin------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                            &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            WaterNeedsFather = .false.
            PropNumber       = 0

            PropertyX => Me%FirstProperty


do1 :       do while (associated(PropertyX))

cd2 :           if (PropertyX%SubModel%ON) then

                    WaterNeedsFather = .true.

                    PropNumber = PropNumber + 1

                end if cd2

                PropertyX => PropertyX%Next

            end do do1

            nullify(PropertyX)


            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !------------------------------------------------------------------------

    end subroutine GetWaterNeedsFather

    !----------------------------------------------------------------------------


    subroutine GetPropListNeedsFather(WaterPropertiesID, PropIDNumberList, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, dimension(:), pointer              :: PropIDNumberList
        integer, optional, intent(OUT)              :: STAT

        !Local-------------------------------------------------------------------
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_
        integer                                     :: ready_, Counter

        !Begin------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR. &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            PropertyX => Me%FirstProperty

            Counter = 1


do1 :       do while (associated(PropertyX))

cd2 :           if (PropertyX%SubModel%ON) then

                    PropIDNumberList(Counter) = PropertyX%ID%IDNumber

                    Counter = Counter + 1

                end if cd2

                PropertyX => PropertyX%Next

            end do do1

            nullify(PropertyX)


            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1


        if (present(STAT))                                                               &
            STAT = STAT_

        !------------------------------------------------------------------------

    end subroutine GetPropListNeedsFather


    !----------------------------------------------------------------------------


    subroutine GetConcentration(WaterPropertiesID, ConcentrationX, PropertyXIDNumber, &
                                PropertyXUnits, PropertyXISCoef, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: ConcentrationX
        character(LEN = *), optional, intent(OUT)   :: PropertyXUnits
        integer,                      intent(IN )   :: PropertyXIDNumber
        real,               optional, intent(OUT)   :: PropertyXISCoef
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_CALL
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: UnitsSize
        integer                                     :: STAT_

        !------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then
                ConcentrationX => PropertyX%concentration

                if (present(PropertyXUnits)) then
                   UnitsSize      = LEN (PropertyXUnits)
                   PropertyXUnits = PropertyX%ID%Units(1:UnitsSize)
                end if

                if (present(PropertyXISCoef)) then
                   PropertyXISCoef = PropertyX%IScoefficient
                end if

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if
        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetConcentration


   !--------------------------------------------------------------------------
    subroutine GetShortWaveRadiationAverage(WaterPropertiesID, ShortWaveRadiationAverage, STAT)


        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: ShortWaveRadiationAverage
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        ! this subroutine gets the values of the average shortwave radiation,
        ! to be used by other modules, for example by ModuleInterfaceSedimentWater
        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            ShortWaveRadiationAverage => Me%SolarRadiation%ShortWaveAverage

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetShortWaveRadiationAverage

    !----------------------------------------------------------------------------
    subroutine GetSeagrassArray2D(WaterPropertiesID, Array, ArrayID, STAT)
    !

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:)               :: Array
        integer,            optional, intent(OUT)   :: STAT
        integer,            optional, intent(IN)    :: ArrayID

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

           select case(ArrayID)

           case(SeagrassesLeaves_)

            Array => Me%SeagrassesLeaves%Biomass

          case(NintFactor_)

            Array => Me%SeagrassesLeaves%NintFactor2D

          case(PintFactor_)

            Array => Me%SeagrassesLeaves%PintFactor2D


          end select

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetSeagrassArray2D

    !--------------------------------------------------------------------------

    subroutine GetFiltrationRate (WaterPropertiesID, FiltrationRateX,                   &
                                  DTProp, PropertyXIDNumber, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: FiltrationRateX
        real    ,                     intent(OUT)   :: DTProp
        integer,                      intent(IN )   :: PropertyXIDNumber
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_CALL
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_

        !------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                FiltrationRateX => PropertyX%Evolution%Filtration%Rate
                DTProp          =  PropertyX%Evolution%DTInterval

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if
        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetFiltrationRate

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


    subroutine GetMacroalgaeBiomass(WaterPropertiesID, MacroalgaeBiomass, STAT)
    !

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:)               :: MacroalgaeBiomass
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            MacroalgaeBiomass => Me%Macroalgae%Distribution

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetMacroalgaeBiomass
    !------------------------------------------------------------------------

    subroutine GetDensity(WaterPropertiesID, Density, CurrentTime, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Density
        type(T_Time)                                :: CurrentTime
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)


cd2 :       if (Me%Density%Variable) then

                call ModifyDensity(CurrentTime)

            end if cd2

cd3 :       if (Me%Density%VariableSed) then

                call ModifyDensitySed(CurrentTime)

            end if cd3


            Density => Me%Density%Field


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetDensity

    !--------------------------------------------------------------------------

    subroutine GetSalinity(WaterPropertiesID, Salinity, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Salinity
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            call GetConcentration(WaterPropertiesID, ConcentrationX = Salinity, &
                                  PropertyXIDNumber = Salinity_, STAT = STAT_)

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine GetSalinity

    !--------------------------------------------------------------------------

    subroutine GetTemperature(WaterPropertiesID, Temperature, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Temperature
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                       &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            call GetConcentration(WaterPropertiesID, ConcentrationX = Temperature,  &
                                  PropertyXIDNumber = Temperature_, STAT = STAT_)

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine GetTemperature

    !--------------------------------------------------------------------------

    subroutine GetSigma(WaterPropertiesID, Sigma, CurrentTime, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Sigma
        type(T_Time)                                :: CurrentTime
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)


cd2 :       if (Me%Density%Variable) then

                call ModifyDensity(CurrentTime)

            end if cd2

cd3 :       if (Me%Density%VariableSed) then

                call ModifyDensitySed(CurrentTime)

            end if cd3


            Sigma => Me%Density%Sigma


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

    end subroutine GetSigma

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetSigmaNoPressure(WaterPropertiesID, SigmaNoPressure, CurrentTime, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: SigmaNoPressure
        type(T_Time)                                :: CurrentTime
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)


cd2 :       if (Me%Density%Variable) then

                call ModifyDensity(CurrentTime)

            end if cd2

cd3 :       if (Me%Density%VariableSed) then

                call ModifyDensitySed(CurrentTime)

            end if cd3


            SigmaNoPressure => Me%Density%SigmaNoPressure


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

    end subroutine GetSigmaNoPressure

    !--------------------------------------------------------------------------

    subroutine GetSpecificHeat(WaterPropertiesID, SpecificHeat, CurrentTime, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: SpecificHeat
        type(T_Time)                                :: CurrentTime
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)


cd2 :       if (Me%SpecificHeat%Variable) then

                call ModifySpecificHeat(CurrentTime)

            end if cd2


            SpecificHeat => Me%SpecificHeat%Field


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetSpecificHeat

    !--------------------------------------------------------------------------

    subroutine GetSpecificHeatReference(WaterPropertiesID, SpecificHeatReference, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real,              intent(OUT)              :: SpecificHeatReference
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            SpecificHeatReference = Me%SpecificHeat%Reference


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetSpecificHeatReference


    !--------------------------------------------------------------------------


    subroutine GetSPM(WaterPropertiesID, SPM, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: SPM
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_, STAT_CALL
        type(T_Property), pointer                   :: Cohesive_Sediment

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            call Search_Property(Cohesive_Sediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('GetSPM - ModuleWaterProperties - ERR01')

            SPM => Cohesive_Sediment%Concentration

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_

    end subroutine GetSPM

    !--------------------------------------------------------------------------

    subroutine GetWaterPropertiesSubModulesID(WaterPropertiesID,        &
                                              FreeVerticalMovementID,   &
                                              LightExtinctionID,        &
                                              STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, optional, intent(OUT)              :: FreeVerticalMovementID
        integer, optional, intent(OUT)              :: LightExtinctionID
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then


            if(present(FreeVerticalMovementID)) FreeVerticalMovementID = Me%ObjFreeVerticalMovement
            if(present(LightExtinctionID     )) LightExtinctionID      = Me%ObjLightExtinction


            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_


        !----------------------------------------------------------------------

    end subroutine GetWaterPropertiesSubModulesID


    !----------------------------------------------------------------------

    subroutine GetWaterPropertiesAirOptions(WaterPropertiesID,          &
                                            TemperatureFluxYes,         &
                                            OxygenFluxYes,              &
                                            CarbonDioxideFluxYes,       &
                                            AmmoniaFluxYes,             &
                                            NitrateFluxYes,             &
                                            WQMYes,                     &
                                            T90VariableYes,             &
                                            STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        logical, optional, intent(OUT)              :: TemperatureFluxYes
        logical, optional, intent(OUT)              :: AmmoniaFluxYes, NitrateFluxYes
        logical, optional, intent(OUT)              :: OxygenFluxYes, CarbonDioxideFluxYes, WQMYes
        logical, optional, intent(OUT)              :: T90VariableYes
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        type(T_Property), pointer                   :: PropertyX

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            TemperatureFluxYes   = .false.
            OxygenFluxYes        = .false.
            WQMYes               = .false.
            T90VariableYes       = .false.
            CarbonDioxideFluxYes = .false.
            AmmoniaFluxYes       = .false.
            NitrateFluxYes       = .false.


            PropertyX => Me%FirstProperty

            do while (associated(PropertyX))

                if (PropertyX%ID%IDNumber == Temperature_   ) then

                    if(PropertyX%Evolution%SurfaceFluxes    )TemperatureFluxYes = .true.

                end if

                if (PropertyX%ID%IDNumber == Oxygen_        )then

                    if(PropertyX%Evolution%SurfaceFluxes    )OxygenFluxYes      = .true.

                end if

                !no CeQual o fluxo de CO2 รฉ actualizado no ICarbon. O CO2 nao รฉ variavel de estado
                if (PropertyX%ID%IDNumber == ICarbon_        )then

                    if(PropertyX%Evolution%SurfaceFluxes    )CarbonDioxideFluxYes   = .true.

                end if


                if (PropertyX%ID%IDNumber == CarbonDioxide_  )then

                    if(PropertyX%Evolution%SurfaceFluxes    )CarbonDioxideFluxYes   = .true.

                end if

                if (PropertyX%ID%IDNumber == Ammonia_  )then

                    if(PropertyX%Evolution%SurfaceFluxes    )AmmoniaFluxYes   = .true.

                end if

                if (PropertyX%ID%IDNumber == Nitrate_  )then

                    if(PropertyX%Evolution%SurfaceFluxes    )NitrateFluxYes   = .true.

                end if

                if ((PropertyX%ID%IDNumber == Phytoplankton_ )  .or. &
                    (PropertyX%ID%IDNumber == Diatoms_       )  .or. &
                    (PropertyX%ID%IDNumber == Algae_1_       )  .or. &
                    (PropertyX%ID%IDNumber == Diatom_C_      )  .or. &
                    (PropertyX%ID%IDNumber == Epiphyton_1_   )  .or. &
                    (PropertyX%ID%IDNumber == MacroAlgae_    )  .or. &
                    (PropertyX%ID%IDNumber == SeagrassesLeaves_) ) then

                    if((PropertyX%Evolution%WaterQuality)       .or. &
                       (PropertyX%Evolution%CEQUALW2    )       .or. &
                       (PropertyX%Evolution%Life        )       .or. &
                       (PropertyX%Evolution%MacroAlgae  )       .or. &
                       (PropertyX%Evolution%WWTPQ       )       .or. &
                       (PropertyX%Evolution%SeagrassesLeaves )) WQMYes = .true.

                end if

                if (PropertyX%evolution%T90Variable) then
                    T90VariableYes = .true.
                endif


                PropertyX => PropertyX%Next
            end do

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetWaterPropertiesAirOptions

    !----------------------------------------------------------------------

    subroutine GetWaterPropertiesBottomOptions(WaterPropertiesID, MacroAlgae, STAT)



        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        logical, optional, intent(OUT)              :: MacroAlgae
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            if(present(MacroAlgae)) MacroAlgae = Me%Coupled%MacroAlgae%Yes

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

    end subroutine GetWaterPropertiesBottomOptions

    !----------------------------------------------------------------------


    subroutine GetPropertySurfaceFlux(WaterPropertiesID, OxygenSurfaceFlux, CarbonDioxideSurfaceFlux, AmmoniaSurfaceFlux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                                 :: WaterPropertiesID
        real, pointer, dimension(:,:), optional                 :: OxygenSurfaceFlux
        real, pointer, dimension(:,:), optional                 :: CarbonDioxideSurfaceFlux
        real, pointer, dimension(:,:), optional                 :: AmmoniaSurfaceFlux
        integer,            optional, intent(OUT)               :: STAT

        !Local-------------------------------------------------------------------
        integer                                                 :: ready_
        integer                                                 :: STAT_CALL
        type(T_Property), pointer                               :: PropertyX
        integer                                                 :: STAT_

        !------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                   &
            (ready_ .EQ. READ_LOCK_ERR_)) then

    !        call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            nullify(PropertyX)

            if (present(OxygenSurfaceFlux)) then

                call Search_Property(PropertyX, PropertyXID = Oxygen_, STAT = STAT_CALL)

                if (STAT_CALL == SUCCESS_) then
                     OxygenSurfaceFlux => PropertyX%SurfaceFlux
                endif

            endif


            if (present(CarbonDioxideSurfaceFlux)) then

                call Search_Property(PropertyX, PropertyXID = CarbonDioxide_, STAT = STAT_CALL)

                if (STAT_CALL == SUCCESS_) then
                     CarbonDioxideSurfaceFlux => PropertyX%SurfaceFlux
                endif

             endif

             if (present(AmmoniaSurfaceFlux)) then

                call Search_Property(PropertyX, PropertyXID = Ammonia_, STAT = STAT_CALL)

                if (STAT_CALL == SUCCESS_) then
                     AmmoniaSurfaceFlux => PropertyX%SurfaceFlux
                endif

             endif

           STAT_ = STAT_CALL

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine GetPropertySurfaceFlux





#ifdef _USE_SEQASSIMILATION

    subroutine UngetWaterProperties1D_I4(WaterPropertiesID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, pointer, dimension(:)              :: Array
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mWATERPROPERTIES_, Me%InstanceID,                  &
                             "UngetWaterProperties1D_I4")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                      &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetWaterProperties1D_I4

#endif _USE_SEQASSIMILATION

    !----------------------------------------------------------------------

    subroutine UngetWaterProperties3D(WaterPropertiesID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Array
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mWATERPROPERTIES_, Me%InstanceID, "UngetWaterProperties3D")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetWaterProperties3D

    !--------------------------------------------------------------------------

subroutine UngetWaterProperties2D(WaterPropertiesID, Array, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:)               :: Array
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. READ_LOCK_ERR_) then
            nullify(Array)

            call Read_UnLock(mWATERPROPERTIES_, Me%InstanceID, "UngetWaterProperties2D")

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine UngetWaterProperties2D

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    logical function WaterPropertyExists(WaterPropertiesID, PropIDNumber, STAT)


        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,                    intent (IN)     :: PropIDNumber
        integer         , optional, intent (OUT)    :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        integer                                     :: STAT_CALL
        type(T_Property), pointer                   :: PropertyX

        !----------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then


            WaterPropertyExists = .FALSE.

            call Search_Property(PropertyX, PropertyXID = PropIDNumber, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) WaterPropertyExists =.true.



            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end function WaterPropertyExists

    !----------------------------------------------------------------------

    function WaterPropertyID (name, property) result (res)

        !Arguments--------------------------------------------------------
        character (StringLength)                        :: name
        type (T_Property), pointer, optional            :: property
        integer                                         :: res

        !Local------------------------------------------------------------
        type (T_Property), pointer                      :: property_

        !-----------------------------------------------------------------

        property_ => Me%FirstProperty

        do while (associated(property_))
            if (trim(property_%ID%Name) == trim(name)) then
                exit
            else
                property_ => property_%Next
            end if
        end do

       if (associated(property_)) then
            res = SUCCESS_
            if (present (property)) &
                property => property_
        else
            res = NOT_FOUND_ERR_
            if (present (property)) &
                nullify(property)
        end if

    end function WaterPropertyID

    !----------------------------------------------------------------------

    subroutine Search_Property(PropertyX, PropertyXID, STAT)

        !Arguments-------------------------------------------------------------
        type(T_Property),           pointer             :: PropertyX
        integer         ,           intent (IN)         :: PropertyXID
        integer         , optional, intent (OUT)        :: STAT

        !Local-----------------------------------------------------------------
        integer                                         :: STAT_

        !----------------------------------------------------------------------

        STAT_  = UNKNOWN_

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))
            if (PropertyX%ID%IDNumber==PropertyXID) then
                exit
            else
                PropertyX => PropertyX%Next
            end if
        end do

       if (associated(PropertyX)) then

            STAT_ = SUCCESS_

        else
            STAT_  = NOT_FOUND_ERR_
        end if

        if (present(STAT)) STAT = STAT_

    end subroutine Search_Property

    !--------------------------------------------------------------------------

    subroutine Search_PropertyFather(ObjWaterPropertiesFather, PropertyX, &
                                     PropertyXID, STAT)

        !Arguments-------------------------------------------------------------
        type(T_WaterProperties),    pointer             :: ObjWaterPropertiesFather
        type(T_Property),           pointer             :: PropertyX
        integer         ,           intent (IN)         :: PropertyXID
        integer         , optional, intent (OUT)        :: STAT

        !Local-----------------------------------------------------------------
        integer                                         :: STAT_

        !----------------------------------------------------------------------

        STAT_  = UNKNOWN_

        PropertyX => ObjWaterPropertiesFather%FirstProperty

        do while (associated(PropertyX))
            if (PropertyX%ID%IDNumber==PropertyXID) then
                exit
            else
                PropertyX => PropertyX%Next
            end if
        end do

       if (associated(PropertyX)) then

            STAT_ = SUCCESS_

        else
            STAT_  = NOT_FOUND_ERR_
        end if

        if (present(STAT)) STAT = STAT_

    end subroutine Search_PropertyFather


    !-----------------------------------------------------------------------------

    !-----------------------------------------------------------------------------

    subroutine SetSurfaceFlux(WaterPropertiesID, IDNumber, Flux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:)               :: Flux
        integer,optional, intent(OUT)               :: STAT
        integer                                     :: IDNumber

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            select case (IDNumber)

                case(Evaporation_)

                    Me%ExtSurface%Evaporation           => Flux

                case(Precipitation_)

                    Me%ExtSurface%Precipitation         => Flux

                case(OxygenFlux_)

                    Me%ExtSurface%OxygenFlux            => Flux


                case(CarbonDioxideFlux_)

                    Me%ExtSurface%CarbonDioxideFlux     => Flux

                case(AmmoniaFlux_)

                    Me%ExtSurface%AmmoniaFlux           => Flux

                case(NitrateFlux_)

                    Me%ExtSurface%NitrateFlux           => Flux


                case(NonSolarFlux_)

                    Me%ExtSurface%NonSolarRadiation     => Flux


                case(SurfaceRadiation_)

                    Me%ExtSurface%SurfaceRadiation      => Flux

                case default

            end select

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

    end subroutine SetSurfaceFlux


    !--------------------------------------------------------------------------


    subroutine SetFluxToWaterProperties(WaterPropertiesID, PropertyID, Flux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,                      intent(IN)    :: PropertyID
        real, pointer, dimension(:,:)               :: Flux
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_CALL
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_

        !------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyID, STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                PropertyX%BottomFlux => Flux

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if
        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetFluxToWaterProperties

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------


    subroutine SetLagrangianSinksSources(WaterPropertiesID, PropertyID, LagMass, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,                      intent(IN)    :: PropertyID
        real, pointer, dimension(:,:,:)             :: LagMass
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------


        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            if (Me%Coupled%LagSinksSources%Yes)  then
                call SinksSources_Processes(LagMass, PropertyID)
                STAT_ = SUCCESS_
            else
                STAT_ = NOT_ASSOCIATE_
            endif
        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_

    end subroutine SetLagrangianSinksSources

    !--------------------------------------------------------------------------

    subroutine SetMacroAlgaeParameters(WaterPropertiesID, ShearStress, SPMFlux, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:)               :: ShearStress, SPMFlux
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            Me%ExternalVar%ShearStress       => ShearStress
            Me%ExternalVar%SPMDepositionFlux => SPMFlux

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_



    end subroutine SetMacroAlgaeParameters

    !--------------------------------------------------------------------------

    subroutine ReadLockExternalVar

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        !Now
        call GetComputeCurrentTime(Me%ObjTime, Me%ExternalVar%Now, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR01')

        !WaterPoints3D
        call GetWaterPoints3D(Me%ObjMap, Me%ExternalVar%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR02')

        !OpenPoints3D
        call GetOpenPoints3D(Me%ObjMap, Me%ExternalVar%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR03')

        !XX_IE and YY_IE
        call GetHorizontalGrid (Me%ObjHorizontalGrid,                                   &
                                XX_IE = Me%ExternalVar%XX_IE,                           &
                                YY_IE = Me%ExternalVar%YY_IE,                           &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR04')

        !BoundaryPoints2D
        call GetBoundaries(Me%ObjHorizontalMap, Me%ExternalVar%BoundaryPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR05')

        !SZZ
        call GetGeometryDistances (Me%ObjGeometry, SZZ = Me%ExternalVar%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR06')

        !LandPoints3D
        call GetLandPoints3D(Me%ObjMap, Me%ExternalVar%LandPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR07')

        call GetGeometryVolumes(Me%ObjGeometry,                                         &
                                VolumeZ = Me%ExternalVar%VolumeZ,                       &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR09')

        call GetGeometryDistances (Me%ObjGeometry, DWZ = Me%ExternalVar%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR10')

        call GetGridData(Me%ObjGridData, Me%ExternalVar%Bathymetry, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR11')

        call GetGeometryDistances(Me%ObjGeometry,                                       &
                                  ZCellCenter   = Me%ExternalVar%ZCellCenter,           &
                                  STAT          = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR12')

        call GetGeometryKFloor(Me%ObjGeometry, Z = Me%ExternalVar%KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR13')

        call GetGridCellArea (Me%ObjHorizontalGrid, Me%ExternalVar%GridCellArea , STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR14')

        !WaterPoints2D
        call GetWaterPoints2D(Me%ObjHorizontalMap, Me%ExternalVar%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadLockExternalVar - ModuleWaterProperties - ERR15')

    end subroutine ReadLockExternalVar


    !--------------------------------------------------------------------------


    subroutine ReadUnlockExternalVar

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------


        call UnGetMap(Me%ObjMap, Me%ExternalVar%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR01')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR02')

        call UnGetMap(Me%ObjMap, Me%ExternalVar%LandPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR03')

        call UnGetGeometry(Me%ObjGeometry,Me%ExternalVar%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR04')

        call UnGetGeometry(Me%ObjGeometry,Me%ExternalVar%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR05')

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%ExternalVar%XX_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR06')

        call UnGetHorizontalGrid (Me%ObjHorizontalGrid, Me%ExternalVar%YY_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR07')

        call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%VolumeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR13')

        call UngetHorizontalMap (Me%ObjHorizontalMap, Me%ExternalVar%BoundaryPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR14')

        call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%ZCellCenter, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR15')

        call UnGetGridData(Me%ObjGridData, Me%ExternalVar%Bathymetry, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR16')

        call UnGetGeometry(Me%ObjGeometry, Me%ExternalVar%KFloor_Z, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR17')

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%ExternalVar%GridCellArea, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR18')

        call UngetHorizontalMap (Me%ObjHorizontalMap, Me%ExternalVar%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('ReadUnlockExternalVar - ModuleWaterProperties - ERR19')

        call null_time(Me%ExternalVar%Now)

    end subroutine ReadUnlockExternalVar

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    subroutine GetWaterPropertiesIDArray(WaterPropertiesID, Array, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, pointer, dimension(:)              :: Array
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            Array => Me%PropertiesID

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterPropertiesIDArray

    !--------------------------------------------------------------------------

    subroutine GetWaterSeqAssimilation(WaterPropertiesID, RunSeqAssimilation, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        logical                                     :: RunSeqAssimilation
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then
            !call Read_Lock(mWATERPROPERTIES_, Me%InstanceID)

            RunSeqAssimilation = Me%RunSeqAssimilation

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1


        if (present(STAT))                                                    &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine GetWaterSeqAssimilation

    !--------------------------------------------------------------------------

    subroutine SetDensity(WaterPropertiesID, Density, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: Density
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(Me%Density%Field)

            Me%Density%Field => Density

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetDensity

    !--------------------------------------------------------------------------

    subroutine SetSigma(WaterPropertiesID, SigmaDensity, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: SigmaDensity
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(Me%Density%Sigma)

            Me%Density%Sigma => SigmaDensity

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetSigma

    !--------------------------------------------------------------------------

    subroutine SetConcentration(WaterPropertiesID, ConcentrationX,              &
                                PropertyXIDNumber, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        real, pointer, dimension(:,:,:)             :: ConcentrationX
        integer,                      intent(IN )   :: PropertyXIDNumber
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_CALL

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber,    &
                                 STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                nullify(PropertyX%concentration)

                PropertyX%concentration => ConcentrationX

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_


    end subroutine SetConcentration

    !--------------------------------------------------------------------------

    subroutine SetWaterPropVirtualRun(WaterPropertiesID, VirtualRun, STAT)

        !Arguments---------------------------------------------------------------
        integer                                      :: WaterPropertiesID
        logical                                      :: VirtualRun
        integer, optional, intent(OUT)               :: STAT

        !Local-------------------------------------------------------------------
        integer                                      :: ready_
        integer                                      :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ == IDLE_ERR_)then

            Me%VirtualRun     = VirtualRun

            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

    end subroutine SetWaterPropVirtualRun

    !--------------------------------------------------------------------------

    subroutine ReSetDensity(WaterPropertiesID, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !------------------------------------------------------------------------

        !This is a set for internal memory space: for density field and density sigma

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(Me%Density%Field)

            Me%Density%Field => Me%Density%AuxPointerConc

            nullify(Me%Density%Sigma)

            Me%Density%Sigma => Me%Density%AuxPointerSigma

            STAT_ = SUCCESS_

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

    end subroutine ReSetDensity

    !--------------------------------------------------------------------------

    subroutine ReSetConcentration(WaterPropertiesID, PropertyXIDNumber, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,                      intent(IN )   :: PropertyXIDNumber
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_CALL

        !------------------------------------------------------------------------

        !This is a set for internal memory space

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber,    &
                                 STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                nullify(PropertyX%concentration)

                PropertyX%concentration => PropertyX%AuxPointerConc

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_


    end subroutine ReSetConcentration

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

#ifdef OVERLAP

    subroutine GetWaterOverlap(WaterPropertiesID, Overlap, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        logical                                     :: Overlap
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_
        integer                                     :: ready_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            Overlap = Me%Overlap

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))STAT = STAT_

    end subroutine GetWaterOverlap

    !--------------------------------------------------------------------------

    subroutine SetModelOverlapWater(WaterPropertiesID, OverlapWaterPropertiesID, OverlapCells, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: OverlapWaterPropertiesID
        integer, dimension(:,:),pointer             :: OverlapCells
        integer, optional                           :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: STAT_, STAT_CALL
        integer                                     :: ready_
        type(T_WaterProperties), pointer            :: ObjOverlapWaterProperties
        type(T_Property),        pointer            :: Property, PropertyOverlap
        integer                                     :: n, nOverlapCells, i, j, io, jo, k
        real                                        :: AuxConc

        !------------------------------------------------------------------------


        call Ready          (WaterPropertiesID, ready_)

        call LocateObjFather(ObjOverlapWaterProperties, OverlapWaterPropertiesID)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then


            Property => Me%FirstProperty

            do while(associated(Property))

                call Search_PropertyFather(ObjOverlapWaterProperties, PropertyOverlap,            &
                                           PropertyXID = Property%ID%IDNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('SetModelOverlapWater - ModuleWaterProperties - ERR20')

                if (.not.associated(PropertyOverlap)) then
                    call CloseAllAndStop ('SetModelOverlapWater - ModuleWaterProperties - ERR30')
                endif

                nOverlapCells = size(OverlapCells, dim=1)

                do n = 1, nOverlapCells

                    i   = OverlapCells(n, 1)
                    j   = OverlapCells(n, 2)
                    k   = 1
                    io  = OverlapCells(n, 3)
                    jo  = OverlapCells(n, 4)

                    AuxConc                                 = Property%Concentration(i-1, j, k)

                    Property%Assimilation%Field(i, j, k)    = PropertyOverlap%Concentration(io,jo,k)

                    PropertyOverlap%Assimilation%Field(io,jo,k)     = AuxConc

                enddo

                Property => Property%Next

            enddo


            STAT_ = SUCCESS_
        else cd1

            STAT_ = ready_


        end if cd1

        if(present(STAT)) STAT = STAT_

    end subroutine SetModelOverlapWater


#endif OVERLAP



    !--------------------------------------------------------------------------

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !--------------------------------------------------------------------------

    subroutine CloseAllAndStop (message)

        !Arguments-------------------------------------------------------------
        character(*)                                :: message

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL

        !----------------------------------------------------------------------

        if (Me%OutPut%Yes) &
            call OutPut_Results_HDF(StoppingModel = .true.)

        if (Me%Coupled%TimeSerie%Yes) &
            call KillTimeSerie(Me%ObjTimeSerie, STAT = STAT_CALL)

        write (*,*) message
        stop

    end subroutine CloseAllAndStop

    !--------------------------------------------------------------------------

    subroutine KillWaterProperties(WaterPropertiesID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        type (T_Species),  pointer                  :: Species
        type (T_Cohort) ,  pointer                  :: Cohort
        type (T_Time)                               :: EndTime, BeginTime
        integer                                     :: STAT_CALL, Orlanski
        integer                                     :: STAT_, ready_, nUsers, iW
        type (T_Property),  pointer                 :: PropertyX
        type (T_WQRate  ),  pointer                 :: WQRateX
        type (T_DischargeTimeSerie), pointer        :: DischargeTimeSerieToKill
        type (T_DischargeTimeSerie), pointer        :: DischargeTimeSerie
        integer                                     :: iClass

        !----------------------------------------------------------------------
        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1:    if (ready_ .NE. OFF_ERR_) then

            nUsers = DeassociateInstance(mWATERPROPERTIES_,  Me%InstanceID)

            if (nUsers == 0) then

                call GetComputeTimeLimits(Me%ObjTime, EndTime = EndTime,        &
                                          BeginTime = BeginTime, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                      &
                    call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR10')

                ! Actualized the time
                Me%ExternalVar%Now = EndTime


                call ReadLockExternalVar


                if(Me%OutPut%Yes .and. .not. Me%OutPut%Run_End)                         &
                    call OutPut_Results_HDF

                !Writes the final results in HDF format
                if (.not. Me%Coupled%AllSolutionFromFile)                               &
                    call Write_FinalWaterProperties_HDF

                if(Me%Coupled%OutputProfile%Yes)                                        &
                    call OutPut_Profile

                call ReadUnlockExternalVar

                nUsers = DeassociateInstance(mTIME_,            Me%ObjTime)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR20')

                nUsers = DeassociateInstance(mGRIDDATA_,        Me%ObjGridData)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR30')

                nUsers = DeassociateInstance(mHORIZONTALMAP_,   Me%ObjHorizontalMap)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR40')

                nUsers = DeassociateInstance(mHORIZONTALGRID_,  Me%ObjHorizontalGrid)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR50')

                nUsers = DeassociateInstance(mGEOMETRY_,        Me%ObjGeometry)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR60')

                nUsers = DeassociateInstance(mMAP_,             Me%ObjMap)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR70')

                nUsers = DeassociateInstance(mTURBULENCE_,      Me%ObjTurbulence)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR80')

                nUsers = DeassociateInstance(mHYDRODYNAMIC_,    Me%ObjHydrodynamic)
                if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR90')

                if(Me%ObjTurbGOTM /= 0)then
                    nUsers = DeassociateInstance(mTURBGOTM_,        Me%ObjTurbGOTM)
                    if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR100')
                endif

                if(Me%ObjTwoWay /= 0)then
                    nUsers = DeassociateInstance(mTwoWay_,        Me%ObjTwoWay)
                    if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR101')
                endif

                if(Me%Coupled%HydroIntegration%Yes)then
                    call KillHydroIntegration(Me%ObjHydroIntegration, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR110')
                end if


                if (Me%Coupled%BoxTimeSerie%Yes) then

                    call KillBoxDif(Me%ObjBoxDif, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR120')

                    deallocate(Me%MassFluxesX, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR130')
                    nullify(Me%MassFluxesX)

                    deallocate(Me%MassFluxesY, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR140')
                    nullify(Me%MassFluxesY)

                    deallocate(Me%MassFluxesZ, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR150')
                    nullify(Me%MassFluxesZ)

                    deallocate(Me%CellMass, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR0160')
                    nullify(Me%CellMass)

                end if

                !Kills the TimeSerie
                if (Me%Coupled%TimeSerie%Yes) then
                    call KillTimeSerie(Me%ObjTimeSerie, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR170')
                endif


                !Kills the Profile Outputs
                if (Me%Coupled%OutputProfile%Yes) then
                    call KillProfile(Me%ObjProfile, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR180')
                endif

                !Closes all time series from tracking discharges
                DischargeTimeSerie => Me%FirstDischargeTimeSerie

                do while (associated(DischargeTimeSerie))

                    DischargeTimeSerieToKill => DischargeTimeSerie
                    DischargeTimeSerie       => DischargeTimeSerie%Next

                    call KillTimeSerie(DischargeTimeSerieToKill%TimeSerie, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR190')

                    nullify   (DischargeTimeSerieToKill%Next)

                    deallocate(DischargeTimeSerieToKill)
                    nullify   (DischargeTimeSerieToKill)

                enddo


                if (Me%Coupled%Discharges%Yes)    then
                    nUsers = DeassociateInstance(mDISCHARGES_,    Me%ObjDischarges)
                    if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR200')

                    deallocate(Me%Discharge%Flow    ,                                   &
                               Me%Discharge%i       ,                                   &
                               Me%Discharge%j       ,                                   &
                               Me%Discharge%k       ,                                   &
                               Me%Discharge%kmin    ,                                   &
                               Me%Discharge%kmax    ,                                   &
                               Me%Discharge%Vert    ,                                   &
                               Me%Discharge%Ignore  ,                                   &
                               Me%Discharge%nCells  ,                                   &
                               Me%Discharge%ByPass)

                    nullify   (Me%Discharge%Flow    ,                                   &
                               Me%Discharge%i       ,                                   &
                               Me%Discharge%j       ,                                   &
                               Me%Discharge%k       ,                                   &
                               Me%Discharge%kmin    ,                                   &
                               Me%Discharge%kmax    ,                                   &
                               Me%Discharge%Vert    ,                                   &
                               Me%Discharge%Ignore  ,                                   &
                               Me%Discharge%nCells  ,                                   &
                               Me%Discharge%ByPass)

                end if


                Me%WqRatesNumber = FillValueInt

                WQRateX => Me%FirstWQRate

                do while(associated(WQRateX))

                    deallocate(WQRateX%Field, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR210')

                    WQRateX => WQRateX%Next
                end do


                Me%PropertiesNumber = FillValueInt

                PropertyX => Me%FirstProperty

do1 :           do while(associated(PropertyX))

                    !Kills Statistics
                    if (PropertyX%Statistics) then
                        call KillStatistic (PropertyX%StatisticID, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR220')
                    endif
#ifdef _USE_PAGELOCKED
                    ! FreePageLocked will also nullify the pointers and arrays
                    call FreePageLocked(Me%ObjCuda, PropertyX%ConcentrationPtr, PropertyX%Concentration)
#else
                    deallocate(PropertyX%Concentration, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR230')
                    nullify   (PropertyX%Concentration)
#endif

                    if (PropertyX%Evolution%Filtration%On) then

                        deallocate(PropertyX%Filtration, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR240')
                        nullify   (PropertyX%Filtration)

                        deallocate(PropertyX%Evolution%Filtration%Rate, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR250')
                        nullify   (PropertyX%Evolution%Filtration%Rate)

                        deallocate(PropertyX%Evolution%Filtration%Cumulative, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR260')
                        nullify   (PropertyX%Evolution%Filtration%Cumulative)

                        deallocate(PropertyX%Evolution%Filtration%CumulativePerMeter, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR270')
                        nullify   (PropertyX%Evolution%Filtration%CumulativePerMeter)

                        if (PropertyX%Evolution%Filtration%FeederMassON) then
                            deallocate(PropertyX%Evolution%Filtration%FilterFeederMass, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) &
                                call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR280')
                            nullify   (PropertyX%Evolution%Filtration%Rate)
                        endif

                    endif

                    if (PropertyX%Evolution%Reinitialize%ON) then

                        deallocate(PropertyX%Evolution%Reinitialize%BoxCells, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR283')

                        deallocate(PropertyX%Evolution%Reinitialize%BoxesValues, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR286')

                        deallocate(PropertyX%Evolution%Reinitialize%OnlyOnce, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                      &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR288')
                    endif

                    if (PropertyX%Evolution%MinConcentration) then
                        deallocate(PropertyX%Mass_Created, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR290')
                        nullify   (PropertyX%Mass_Created)
                    endif

                    if (PropertyX%Evolution%MaxConcentration) then
                        deallocate(PropertyX%Mass_Destroid, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR300')
                        nullify   (PropertyX%Mass_Destroid)
                    endif


cd9 :               if (associated(PropertyX%Assimilation%Field)) then
                        deallocate(PropertyX%Assimilation%Field, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR310')
                        nullify   (PropertyX%Assimilation%Field)
                    end if cd9

                    if (PropertyX%SubModel%InterpolTime) then

                        deallocate (PropertyX%SubModel%PreviousField, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR320')

                        deallocate (PropertyX%SubModel%NextField, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR330')
                    endif

                    if (PropertyX%SubModel%ON .and.                              &
                        (PropertyX%SubModel%VertComunic == FatherSonDifDim) .or. &
                        (PropertyX%SubModel%VertComunic == Father3DSon2D)) then

                        deallocate (PropertyX%SubModel%Aux_Field, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR340')
                        nullify   (PropertyX%SubModel%Aux_Field)

                        deallocate (PropertyX%SubModel%Aux_ZCellCenter, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR350')
                        nullify   (PropertyX%SubModel%Aux_ZCellCenter)

                    endif

                    call GetBoundaryConditionList(Orlanski = Orlanski)

                    if (PropertyX%evolution%Advec_Difus_Parameters%BoundaryCondition == Orlanski) then

                        deallocate(PropertyX%evolution%Advec_Difus_Parameters%PropOld, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR360')

                        nullify(PropertyX%evolution%Advec_Difus_Parameters%PropOld)

                    endif

                    if(PropertyX%ID%SolutionFromFile)then
                        call KillFillMatrix(PropertyX%ID%ObjFillMatrix, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) &
                            call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR370')
                    endif

                    if (PropertyX%Evolution%Discharges .and.                            &
                        associated(PropertyX%DischConc)) then

                        deallocate(PropertyX%DischConc)
                        nullify   (PropertyX%DischConc)

                    endif



                    PropertyX => PropertyX%Next

                end do do1

                nullify   (Me%FirstProperty,Me%LastProperty)

                if (associated(Me%OutPut%OutTime)) then
                    deallocate(Me%OutPut%OutTime, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR380')
                    nullify   (Me%OutPut%OutTime)
                end if

                if (associated(Me%OutPut%Aux3D)) then
                    deallocate(Me%OutPut%Aux3D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR385')
                    nullify   (Me%OutPut%Aux3D)
                end if

                if (associated(Me%OutPut%Aux2D)) then
                    deallocate(Me%OutPut%Aux2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR386')
                    nullify   (Me%OutPut%Aux2D)
                end if

                if (associated(Me%OutPut%Aux3Dreal4)) then
                    deallocate(Me%OutPut%Aux3Dreal4, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR387')
                    nullify   (Me%OutPut%Aux3Dreal4)
                end if

                !FreeVerticalMovement
                if (Me%Coupled%FreeVerticalMovement%Yes) then

                    call Kill_FreeVerticalMovement(Me%ObjFreeVerticalMovement, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR390')

                end if

                !AdvectionDiffusion
                if (Me%Coupled%AdvectionDiffusion%Yes  ) then

                    call KillAdvectionDiffusion(Me%ObjAdvectionDiffusion, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR400')

                    call KillDepthsMixing

                end if

                !Interface
                if (Me%Coupled%WQM%Yes  .or. Me%Coupled%CEQUALW2%Yes .or. &
                    Me%Coupled%Life%Yes .or. Me%Coupled%WWTPQM%Yes &
#ifdef _PHREEQC_
                    .or. Me%Coupled%PhreeqC%Yes &
#endif
                    ) then
                    call KillInterface(Me%ObjInterface, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR410')

                end if

                if(Me%Coupled%MacroAlgae%Yes) then
                    call KillInterface(Me%ObjInterfaceMacroAlgae, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR420')

                    deallocate(Me%MacroAlgae%Distribution  )
                    deallocate(Me%MacroAlgae%ShearStress3D )
                    deallocate(Me%MacroAlgae%SPMDepFlux3D  )
                    deallocate(Me%MacroAlgae%Occupation    )
                    deallocate(Me%MacroAlgae%MaxShearStress)
                    deallocate(Me%MacroAlgae%MaxSPMDepFlux )
                    deallocate(Me%MacroAlgae%Height )
                    !deallocate(Me%MacroAlgae%DistFromTop )

                    nullify(Me%MacroAlgae%Distribution     )
                    nullify(Me%MacroAlgae%ShearStress3D    )
                    nullify(Me%MacroAlgae%SPMDepFlux3D     )
                    nullify(Me%MacroAlgae%Occupation       )
                    nullify(Me%MacroAlgae%MaxShearStress   )
                    nullify(Me%MacroAlgae%MaxSPMDepFlux    )
                    nullify(Me%MacroAlgae%Height    )
                    !nullify(Me%MacroAlgae%DistFromTop )

                end if


                if(Me%Coupled%SeagrassesLeaves%Yes) then

                 call KillInterface(Me%ObjSeagrassWaterInteraction, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR424')

                 deallocate(Me%SeagrassesLeaves%Biomass                    )
                 deallocate(Me%SeagrassesLeaves%Length                     )
                 deallocate(Me%SeagrassesLeaves%Occupation                 )
                 deallocate(Me%SeagrassesLeaves%NintFactor3D               )
                 deallocate(Me%SeagrassesLeaves%NintFactor2D               )
                 deallocate(Me%SeagrassesLeaves%PintFactor3D               )
                 !deallocate(Me%SeagrassesLeaves%SeagrassesL3D               )
                 deallocate(Me%SeagrassesLeaves%PintFactor2D               )
                 deallocate(Me%SeagrassesLeaves%UptakeNH4NO3w3D            )
                 deallocate(Me%SeagrassesLeaves%UptakePO4w3D               )
                 deallocate(Me%SeagrassesLeaves%LightFactor3D                )
                 !deallocate(Me%SeagrassesLeaves%DistFromTop )
                 !deallocate(Me%SeagrassesLeaves%Volume                )





                 nullify(Me%SeagrassesLeaves%Biomass                    )
                 nullify(Me%SeagrassesLeaves%Length                     )
                 nullify(Me%SeagrassesLeaves%Occupation                 )
                 nullify(Me%SeagrassesLeaves%NintFactor3D               )
                 nullify(Me%SeagrassesLeaves%NintFactor2D               )
                 nullify(Me%SeagrassesLeaves%PintFactor3D               )
                 nullify(Me%SeagrassesLeaves%PintFactor2D               )
                 nullify(Me%SeagrassesLeaves%UptakeNH4NO3w3D            )
                 nullify(Me%SeagrassesLeaves%UptakePO4w3D               )
                 nullify(Me%SeagrassesLeaves%LightFactor3D                )
                 !nullify(Me%SeagrassesLeaves%DistFromTop )
                 !nullify(Me%SeagrassesLeaves%Volume                )


                endif

                if (Me%Coupled%Bivalve%Yes   ) then

                    nUsers = DeassociateInstance (mBIVALVE_, Me%ObjBivalve)
                    if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR425')

                    Species => Me%Bivalve%FirstSpecies
                    do while (associated(Species))

                        if ((Me%Bivalve%OutputHDF) .or. (Me%Bivalve%OutputBoxTimeSerie)) then

                            !Population variables
                            deallocate(Species%TotalDensity, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) &
                                call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR425a')
                            nullify(Species%TotalDensity)

                            deallocate(Species%FieldDensity, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) &
                                call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR425b')
                            nullify(Species%FieldDensity)

                            deallocate(Species%TotalBiomass, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) &
                                call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR425c')
                            nullify(Species%TotalBiomass)

                            deallocate(Species%CohortsNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) &
                                call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR425d')
                            nullify(Species%CohortsNumber)

                            if(Species%BySizeOutputHDF .or. Species%BySizeBoxTimeSerie)then

                                do iClass = 1, Species%NumberSizeClasses
                                    deallocate(Species%SizeClasses(iClass)%Density)
                                    nullify   (Species%SizeClasses(iClass)%Density)
                                enddo

                                deallocate (Species%SizeClasses)
                                nullify(Species%SizeClasses)

                            endif

                        end if

                        if (Species%LarvaeTransport) then

                            Cohort => Species%FirstCohort
                            do while (associated(Cohort))

                                deallocate (Cohort%Larvae     )
                                deallocate (Cohort%AuxLarvaeL )
                                deallocate (Cohort%AuxLarvaeME)
                                deallocate (Cohort%AuxLarvaeMV)
                                deallocate (Cohort%AuxLarvaeMH)
                                deallocate (Cohort%AuxLarvaeMR)
                                deallocate (Cohort%AuxLarvaeN )


                                Cohort => Cohort%Next
                            end do

                        end if

                        Species => Species%Next
                    end do

                    !Population outputs HDF
                    if (Me%Bivalve%OutputHDF) then
                        call KillHDF5 (Me%Bivalve%ObjHDF5, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR450')
                    endif

                    if (Me%Bivalve%OutputBoxTimeSerie) then

                        call KillBoxDif(Me%Bivalve%ObjBoxDif, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR450')

                        if(associated(Me%CellMass)) then
                            deallocate(Me%CellMass, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) &
                                call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR0450')
                            nullify(Me%CellMass)
                        end if

                    endif

                    call KillInterface(Me%ObjInterfaceBivalve, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) &
                        call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR425a')
                end if

                if(Me%Coupled%HybridReferenceField)then

                    deallocate(Me%HybridWeights%Field)
                    nullify   (Me%HybridWeights%Field)

                end if

                !Assimilation object
                if ( (Me%Coupled%DataAssimilation%Yes .or. Me%Coupled%AltimetryAssimilation%Yes &
                      .or. Me%NoFlux%ON).and. Me%ObjAssimilation /= 0)then

                    nUsers = GetUsersNumber(mASSIMILATION_, Me%ObjAssimilation)

                    if(nUsers == 1) then

                        call KillAssimilation(Me%ObjAssimilation, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR430')

                    elseif(nUsers > 1) then

                        nUsers = DeassociateInstance (mASSIMILATION_, Me%ObjAssimilation)
                        if (nUsers == 0) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR440')

                    end if

                endif


                if (Me%OutPut%Yes) then
                    call KillHDF5 (Me%ObjHDF5, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR450')
                endif

                if (Me%OutW%OutPutWindowsON)  then

                    do iW = 1, Me%OutW%WindowsNumber
                        if (Me%OutW%OutPutWindows(iW)%ON) then
                            call KillHDF5 (Me%OutW%ObjHDF5(iW), STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR455')
                        endif
                    enddo

                endif

                if (Me%OutPut%SurfaceOutputs)then
                    call KillHDF5 (Me%ObjSurfaceHDF5, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('KillWaterProperties - ModuleWaterProperties - ERR460')
                endif

                call KillDensity

                if (Me%SpecificHeat%UseField) call KillSpecificHeat

                if (Me%SolarRadiation%Exists) call KillSolarRadiation

                call KillNoFluxInterior

#ifdef _ENABLE_CUDA
                !Kills ModuleCuda.
                call KillCuda (Me%ObjCuda, STAT = STAT_CALL)
                ! No need to give error yet, Module still has users
#endif _ENABLE_CUDA

                call DeallocateInstance

                WaterPropertiesID  = 0
                STAT_              = SUCCESS_

            end if

        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_


    end subroutine KillWaterProperties


    !--------------------------------------------------------------------------

    subroutine KillDepthsMixing

        !Local-----------------------------------------------------------------

        integer                          :: STAT_CALL

        !Begin-----------------------------------------------------------------

        deallocate (Me%SmallDepths%ON, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_)                                                          &
            call SetError (FATAL_, OUT_OF_MEM_, "KillDepthsMixing - WaterProperties - ERR01")

    end subroutine KillDepthsMixing

    !--------------------------------------------------------------------------

    subroutine DeallocateInstance

        !Local-----------------------------------------------------------------
        type (T_WaterProperties), pointer           :: AuxWaterProperties
        type (T_WaterProperties), pointer           :: PreviousWaterProperties

        !Updates pointers
        if (Me%InstanceID == FirstObjWaterProperties%InstanceID) then
            FirstObjWaterProperties => FirstObjWaterProperties%Next
        else
            PreviousWaterProperties => FirstObjWaterProperties
            AuxWaterProperties      => FirstObjWaterProperties%Next
            do while (AuxWaterProperties%InstanceID /= Me%InstanceID)
                PreviousWaterProperties => AuxWaterProperties
                AuxWaterProperties      => AuxWaterProperties%Next
            enddo

            !Now update linked list
            PreviousWaterProperties%Next => AuxWaterProperties%Next

        endif

        !Deallocates instance
        deallocate (Me)
        nullify    (Me)

    end subroutine DeallocateInstance

    !

    !--------------------------------------------------------------------------
    !   Write the final water properties results in HDF format  !

    subroutine Write_FinalWaterProperties_HDF

        !Local--------------------------------------------------------------
        type(T_Property),           pointer     :: Property
        integer                                 :: ObjHDF5
        character (Len = StringLength)          :: PropertyName
        integer                                 :: WorkILB, WorkIUB
        integer                                 :: WorkJLB, WorkJUB
        integer                                 :: WorkKLB, WorkKUB
        integer                                 :: STAT_CALL
        integer(4)                              :: HDF5_CREATE
        character (Len = Pathlength)            :: filename
        !----------------------------------------------------------------------

        !Bounds
        WorkILB = Me%WorkSize%ILB
        WorkIUB = Me%WorkSize%IUB

        WorkJLB = Me%WorkSize%JLB
        WorkJUB = Me%WorkSize%JUB

        WorkKLB = Me%WorkSize%KLB
        WorkKUB = Me%WorkSize%KUB


        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        !Checks if it's at the end of the run
        !or !if it's supposed to overwrite the final HDF file
        if (Me%Output%Run_End .or. Me%Output%RestartOverwrite) then

            filename = trim(Me%Files%FinalWaterProperties)

        else

            filename =  ChangeSuffix(Me%Files%FinalWaterProperties,            &
                            "_"//trim(TimeToString(Me%ExternalVar%Now))//".fin")

        endif

        ObjHDF5 = 0
        !Opens HDF5 File
        call ConstructHDF5 (ObjHDF5,                                                     &
                            trim(filename)//"5",    &
                            HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR10')


        call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR20')


        !Sets limits for next write operations
        call HDF5SetLimits   (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                        &
                              WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR40')


        !Writes the Grid
        call HDF5WriteData   (ObjHDF5, "/Grid", "Bathymetry", "m",                       &
                              Array2D = Me%ExternalVar%Bathymetry,                       &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR50')

        call HDF5WriteData   (ObjHDF5, "/Grid", "WaterPoints3D", "-",                    &
                              Array3D = Me%ExternalVar%WaterPoints3D,                    &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR60')

        call HDF5SetLimits   (ObjHDF5, WorkILB, WorkIUB+1, WorkJLB,                      &
                              WorkJUB+1, WorkKLB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR70')



        !Writes SZZ
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                         &
                             WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR80')

        call HDF5WriteData  (ObjHDF5, "/Grid", "VerticalZ",                              &
                             "m", Array3D = Me%ExternalVar%SZZ,                          &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR90')

        !Writes OpenPoints
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                                  &
                             WorkJLB, WorkJUB, WorkKLB, WorkKUB,                         &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR100')

        call HDF5WriteData  (ObjHDF5, "/Grid", "OpenPoints",                             &
                             "-", Array3D = Me%ExternalVar%OpenPoints3D,                 &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR110')



        Property => Me%FirstProperty

        do while (associated(Property))

            PropertyName = trim(adjustl(Property%ID%name))

            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                              &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,                     &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                   &
                call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR120')

            !Final concentration
            call HDF5WriteData  (ObjHDF5, "/Concentration/"//Property%ID%Name,          &
                                 Property%ID%Name,                                      &
                                 Property%ID%Units,                                     &
                                 Array3D = Property%Concentration,                      &
                                 STAT    = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR130')

            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                             &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB,                    &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR140')

            if(Me%OutPut%Run_End)then

                if (Property%Evolution%MinConcentration) then

                    !Total mass created due to imposed minimum concentration
                    call HDF5WriteData  (ObjHDF5, "/Mass_Created/"//Property%ID%Name,       &
                                        Property%ID%Name,                                  &
                                        Property%ID%Units,                                 &
                                        Array3D = Property%Mass_Created,                   &
                                        STAT    = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                              &
                        call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR150')

                    call ComputeAndLogTotalMassError(Property)

                endif

                if (Property%Evolution%MaxConcentration) then

                    !Total mass created due to imposed maximum concentration
                    call HDF5WriteData  (ObjHDF5, "/Mass_Destroid/"//Property%ID%Name,  &
                                        Property%ID%Name,                               &
                                        Property%ID%Units,                              &
                                        Array3D = Property%Mass_Destroid,               &
                                        STAT    = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR160')

                    call ComputeAndLogTotalMassError(Property)

                endif
            end if

            if (associated(Property%Assimilation%Field))then


                call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                          &
                                     WorkJLB, WorkJUB, WorkKLB, WorkKUB,                 &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                               &
                    call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR170')

                !Assimilation field
                call HDF5WriteData  (ObjHDF5, "/Assimilation/"//Property%ID%Name,        &
                                     Property%ID%Name,                                   &
                                     Property%ID%Units,                                  &
                                     Array3D = Property%Assimilation%Field,              &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                               &
                    call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR180')

            end if

             if (Property%ID%IDNumber==SeagrassesLeaves_) then

                    call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                             &
                                         WorkJLB, WorkJUB, WorkKLB, WorkKUB,                    &
                                         STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR14')

                    call HDF5WriteData  (ObjHDF5, "/Results/"//"seagrasses leaves biomass",       &
                                         "seagrasses leaves biomass", "gdw/m2",                    &
                                         Array2D = Me%SeagrassesLeaves%Biomass)
                    if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('OutPut_Results_HDF - ModuleWaterProperties - ERR15')



               endif

            if(Property%Evolution%Filtration%On)then

                call HDF5WriteData (ObjHDF5, "/Cumulative_Filtration/"//Property%ID%Name,&
                                     Property%ID%Name,                                   &
                                    'tons',                                              &
                                     Array3D = Property%Evolution%Filtration%Cumulative, &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                               &
                    call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR190')

                call HDF5WriteData (ObjHDF5, "/Cumulative_Filtration_PerMeter/"//Property%ID%Name,  &
                                     Property%ID%Name,                                              &
                                    'tons/m',                                                       &
                                     Array3D = Property%Evolution%Filtration%CumulativePerMeter,    &
                                     STAT    = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                                          &
                    call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR200')


            end if

            Property => Property%Next

        enddo

        nullify (Property)

        !Writes everything to disk
        call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR210')

        call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            call CloseAllAndStop ('Write_FinalWaterProperties_HDF - ModuleWaterProperties - ERR220')

    end subroutine Write_FinalWaterProperties_HDF

    !--------------------------------------------------------------------------

    subroutine ComputeAndLogTotalMassError(Property)

        !Arguments-------------------------------------------------------------
        type(T_Property)                        :: Property

        !Local-----------------------------------------------------------------
        real                                    :: Total_Mass_Created, Total_Mass_Destroid
        character (Len = StringLength)          :: str_mass_created, string_to_be_written, str_mass_destroid
        !----------------------------------------------------------------------

        if (Property%Evolution%MinConcentration) then

            !g/1000 = kg, to avoid big numbers
            Total_Mass_Created = SUM(Property%Mass_Created)/1000.0

            write(str_mass_created, '(f20.8)') Total_Mass_Created

            string_to_be_written = 'Total mass created on property '                //&
                                trim(adjustl(adjustr(Property%id%name)))//' = ' //&
                                trim(adjustl(adjustr(str_mass_created)))

            !Writes total mass created to "Error_and_Messages.log" file
            call SetError(WARNING_, INTERNAL_, string_to_be_written, OFF)

        endif

        if (Property%Evolution%MaxConcentration) then

            !g/1000 = kg, to avoid big numbers
            Total_Mass_Destroid = SUM(Property%Mass_Destroid)/1000.0

            write(str_mass_destroid, '(f20.8)') Total_Mass_destroid

            string_to_be_written = 'Total mass destroid on property '               //&
                                trim(adjustl(adjustr(Property%id%name)))//' = ' //&
                                trim(adjustl(adjustr(str_mass_destroid)))

            !Writes total mass destroid to "Error_and_Messages.log" file
            call SetError(WARNING_, INTERNAL_, string_to_be_written, OFF)

        endif

    end subroutine ComputeAndLogTotalMassError

    !--------------------------------------------------------------------------

    subroutine KillDensity

        !External-------------------------------------------------------------
        integer :: STAT_CALL

        !----------------------------------------------------------------------

        deallocate(Me%Density%Field, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('KillDensity - ModuleWaterProperties - ERR10')
        nullify   (Me%Density%Field)

        deallocate(Me%Density%Sigma, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            call CloseAllAndStop ('KillDensity - ModuleWaterProperties - ERR20')
        nullify   (Me%Density%Sigma)

        if (Me%Density%CorrecPress) then
            deallocate(Me%Density%SigmaNoPressure, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                call CloseAllAndStop ('KillDensity - ModuleWaterProperties - ERR30')
        endif

        nullify   (Me%Density%SigmaNoPressure)

        Me%Density%Variable  = .FALSE.
        Me%Density%Reference = FillValueInt

        !----------------------------------------------------------------------

    end subroutine KillDensity

    !--------------------------------------------------------------------------

    subroutine KillSpecificHeat

        !External-------------------------------------------------------------
        integer :: STAT_CALL

        !----------------------------------------------------------------------

        deallocate(Me%SpecificHeat%Field, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            call CloseAllAndStop ('KillSpecificHeat - ModuleWaterProperties - ERR01')
        nullify   (Me%SpecificHeat%Field)


        Me%SpecificHeat%Variable  = .FALSE.
        Me%SpecificHeat%Reference = FillValueInt

        !----------------------------------------------------------------------

    end subroutine KillSpecificHeat

    !--------------------------------------------------------------------------
    Subroutine KillSolarRadiation

        !Arguments-------------------------------------------------------------
        integer :: STAT_CALL

        !----------------------------------------------------------------------

        call KillLightExtinction(Me%ObjLightExtinction, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR10')

        deallocate (Me%SolarRadiation%ShortWaveTop, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR20')
        nullify    (Me%SolarRadiation%ShortWaveTop)

        deallocate (Me%SolarRadiation%ShortWaveAverage, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR30')
        nullify    (Me%SolarRadiation%ShortWaveAverage)

        deallocate (Me%SolarRadiation%LongWaveTop,  STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR40')
        nullify    (Me%SolarRadiation%LongWaveTop)

        if (Me%SolarRadiation%Shading%ON) then
            deallocate (Me%SolarRadiation%Shading%Field,  STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR50')
            nullify    (Me%SolarRadiation%Shading%Field)
        endif

        if (Me%SolarRadiation%ShortWave_Kd_2D%ON) then

            deallocate(Me%SolarRadiation%ShortWave_Kd_2D%Field,  STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR60')
            nullify    (Me%SolarRadiation%ShortWave_Kd_2D%Field)

            if (.not.Me%SolarRadiation%ShortWave_Kd_2D%Constant) then

                call KillFillMatrix(Me%SolarRadiation%ShortWave_Kd_2D%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) then
                    call CloseAllAndStop ('KillSolarRadiation - ModuleWaterProperties - ERR70')
                endif

            endif
        endif

    end subroutine KillSolarRadiation

    !--------------------------------------------------------------------------

    subroutine KillNoFluxInterior
        !Local-----------------------------------------------------------------
        !----------------------------------------------------------------------
        if (Me%NoFlux%ON) then
            deallocate(Me%NoFlux%U, Me%NoFlux%V, Me%NoFlux%W)
        endif
    end subroutine KillNoFluxInterior

    !--------------------------------------------------------------------------

#ifdef _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

    subroutine NullifyDensityPointer(WaterPropertiesID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

cd1 :   if (ready_ .EQ. IDLE_ERR_) then

            nullify(Me%Density%AuxPointerConc)
            nullify(Me%Density%AuxPointerSigma)

            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT))                                                      &
            STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine NullifyDensityPointer

    !--------------------------------------------------------------------------

    subroutine NullifyConcentrationPointer(WaterPropertiesID, PropertyXIDNumber, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer,                      intent(IN )   :: PropertyXIDNumber
        integer,            optional, intent(OUT)   :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_
        integer                                     :: STAT_
        type(T_Property), pointer                   :: PropertyX
        integer                                     :: STAT_CALL

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(WaterPropertiesID, ready_)

        if (ready_ .EQ. IDLE_ERR_)then

            nullify(PropertyX)

            call Search_Property(PropertyX, PropertyXID = PropertyXIDNumber,    &
                                 STAT = STAT_CALL)

            if (STAT_CALL == SUCCESS_) then

                nullify(PropertyX%AuxPointerConc)

                STAT_ = SUCCESS_
            else
                STAT_ = STAT_CALL
            end if

        else
            STAT_ = ready_
        end if

        if (present(STAT))STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine NullifyConcentrationPointer

#endif _USE_SEQASSIMILATION

    !--------------------------------------------------------------------------

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEME

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !--------------------------------------------------------------------------

    subroutine Ready (WaterPropertiesID, ready_)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (Me)

cd1:    if (WaterPropertiesID > 0) then
            call LocateObjWaterProperties (WaterPropertiesID)
            ready_ = VerifyReadLock (mWATERPROPERTIES_, Me%InstanceID)
        else
            ready_ = OFF_ERR_
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Ready


    !--------------------------------------------------------------------------

    subroutine LocateObjWaterProperties (WaterPropertiesID)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID

        !Local-----------------------------------------------------------------

        Me => FirstObjWaterProperties
        do while (associated (Me))
            if (Me%InstanceID == WaterPropertiesID) exit
            Me => Me%Next
        enddo

        if (.not. associated(Me))                                        &
            call CloseAllAndStop ('ModuleWaterProperties - LocateObjWaterProperties - ERR01')

    end subroutine LocateObjWaterProperties

    !--------------------------------------------------------------------------

    !>@author Joao Sobrinho Maretec
    !>@Brief
    !> Gets Son Object Me%
    subroutine LocateObjSon (ObjWaterPropertiesID, ObjWaterPropertiesSon)

        !Arguments-------------------------------------------------------------
        type (T_WaterProperties), pointer           :: ObjWaterPropertiesSon
        integer                                     :: ObjWaterPropertiesID

        !Local-----------------------------------------------------------------

        nullify (ObjWaterPropertiesSon)

        ObjWaterPropertiesSon => FirstObjWaterProperties

        do while (associated (ObjWaterPropertiesSon))
            if (ObjWaterPropertiesSon%InstanceID == ObjWaterPropertiesID) then
                exit
            endif
            ObjWaterPropertiesSon => ObjWaterPropertiesSon%Next
        enddo

        if (.not. associated(ObjWaterPropertiesSon))then
            call CloseAllAndStop ('ModuleWaterProperties - LocateObjSon - ERR01')
        endif

    end subroutine LocateObjSon

!---------------------------------------------------------------------------------

    subroutine LocateObjFather (ObjWaterPropertiesFather, ObjWaterPropertiesID)
        !Arguments-------------------------------------------------------------
        type (T_WaterProperties), pointer           :: ObjWaterPropertiesFather
        integer                                     :: ObjWaterPropertiesID
        !Local-----------------------------------------------------------------

        nullify (ObjWaterPropertiesFather)
        ObjWaterPropertiesFather => FirstObjWaterProperties
        do while (associated (ObjWaterPropertiesFather))
            if (ObjWaterPropertiesFather%InstanceID == ObjWaterPropertiesID) exit
            ObjWaterPropertiesFather => ObjWaterPropertiesFather%Next
        enddo

        if (.not. associated(ObjWaterPropertiesFather)) call CloseAllAndStop ('ModuleWaterProperties - LocateObjFather - ERR01')

    end subroutine LocateObjFather

#ifdef _OPENMI_

        !--------------------------------------------------------------------------


    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetNumberOfProperties
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETNUMBEROFPROPERTIES"::GetNumberOfProperties
    !DEC$ ENDIF
    !Return the number of Error Messages
    integer function GetNumberOfProperties(WaterPropertiesID)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then
            GetNumberOfProperties = Me%PropertiesNumber
        else
            GetNumberOfProperties = -99
        end if

    end function GetNumberOfProperties


    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetWaterPropertiesPropertyID
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETWATERPROPERTIESPROPERTYID"::GetWaterPropertiesPropertyID
    !DEC$ ENDIF
    !Return the number of Error Messages
    integer function GetWaterPropertiesPropertyID(WaterPropertiesID, idx)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: idx

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_
        type (T_Property), pointer                  :: Property
        integer                                     :: iProp

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then

            Property => Me%FirstProperty
            iProp = 1
            do while (associated (Property))

                 if (iProp == idx) then

                    GetWaterPropertiesPropertyID = Property%ID%IDNumber
                    return

                 endif

                 Property => Property%Next
                 iProp = iProp + 1
            enddo

            GetWaterPropertiesPropertyID = -99
        else
            GetWaterPropertiesPropertyID = -99
        end if

    end function GetWaterPropertiesPropertyID

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetConcentrationAtPoint
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETCONCENTRATIONATPOINT"::GetConcentrationAtPoint
    !DEC$ ENDIF
    real(8) function GetConcentrationAtPoint(WaterPropertiesID, PropertyIDNumber, i, j)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: PropertyIDNumber
        integer                                     :: i, j

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_
        type(T_Property), pointer                   :: PropertyX

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then

            call Search_Property(PropertyX, PropertyXID = PropertyIDNumber, STAT = STAT_CALL)
            if (STAT_CALL == SUCCESS_) then
                GetConcentrationAtPoint = PropertyX%Concentration(i, j, Me%WorkSize%KUB)
            else
                GetConcentrationAtPoint = -99.0
            endif
        else
            GetConcentrationAtPoint = - 99.0
        end if

        return

    end function GetConcentrationAtPoint

    !------------------------------------------------------------------------------------

    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::GetConcentration1D
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_GETCONCENTRATION1D"::GetConcentration1D
    !DEC$ ENDIF
    logical function GetConcentration1D(WaterPropertiesID, PropertyIDNumber, nComputePoints, concentration1D)

        !Arguments-------------------------------------------------------------
        integer                                     :: WaterPropertiesID
        integer                                     :: PropertyIDNumber
        integer                                     :: nComputePoints
        real(8), dimension(nComputePoints)          :: concentration1D

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_
        integer                                     :: i, j, idx
        type(T_Property), pointer                   :: PropertyX

        call Ready(WaterPropertiesID, ready_)

        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then

            !Gets WaterPoints2D
            call GetWaterPoints2D(Me%ObjHorizontalMap, Me%ExternalVar%WaterPoints2D,    &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('GetConcentration1D - ModuleWaterProperties - ERR01')

            !Finds Concentration
            call Search_Property(PropertyX, PropertyXID = PropertyIDNumber, STAT = STAT_CALL)


            idx = 1
            do j = Me%WorkSize%JLB, Me%WorkSize%JUB
            do i = Me%WorkSize%ILB, Me%WorkSize%IUB
                if (Me%ExternalVar%WaterPoints2D(i, j) == WaterPoint) then
                    concentration1D(idx) = PropertyX%Concentration(i, j, Me%WorkSize%KUB)
                    idx = idx + 1
                endif
            enddo
            enddo

            !UnGets WaterPoints2D
            call UnGetHorizontalMap(Me%ObjHorizontalMap, Me%ExternalVar%WaterPoints2D, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) call CloseAllAndStop ('GetConcentration1D - ModuleWaterProperties - ERR02')


            GetConcentration1D = .true.
        else
            GetConcentration1D = .false.
        end if

        return


    end function GetConcentration1D

#endif

end Module ModuleWaterProperties

!----------------------------------------------------------------------------------------------------------
!MOHID Water Modelling System.
!Copyright (C) 1985, 1998, 2002, 2005. Instituto Superior Tรฉcnico, Technical University of Lisbon.
!----------------------------------------------------------------------------------------------------------
