!------------------------------------------------------------------------------
!        IST/MARETEC, Water Modelling Group, Mohid modelling system
!------------------------------------------------------------------------------
!
! TITLE         : Mohid Model
! PROJECT       : Mohid Water
! MODULE        : Lagrangian
! URL           : http://www.mohid.com
! AFFILIATION   : IST/MARETEC, Marine Modelling Group
! DATE          : September 2011
! REVISION      : Paulo Leitão 
! DESCRIPTION   : Three dimensional multinesting lagrangian tracers model
!
!------------------------------------------------------------------------------
!
!This program is free software; you can redistribute it and/or
!modify it under the terms of the GNU General Public License 
!version 2, as published by the Free Software Foundation.
!
!This program is distributed in the hope that it will be useful,
!but WITHOUT ANY WARRANTY; without even the implied warranty of
!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!GNU General Public License for more details.
!
!You should have received a copy of the GNU General Public License
!along with this program; if not, write to the Free Software
!Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
!
!------------------------------------------------------------------------------

Module ModuleLagrangianGlobal

!BOP
!
! !MODULE: ModuleLagrangianGlobal

!    !DESCRIPTION: 
!     This model is responsible Create, Move and Destroy Lagrangian Tracers using a multi-nesting approach
 
! !REVISION HISTORY: 
!    2008   Paulo Leitao  New Lagrangian module (multi-nesting) - Implementation
!
! !FILES USED:   
!  'nomfich.dat' file is where the name files are given .
!  The keywords relevant for the hydrodynamic model are:
!    PARTIC_DATA : data file
!    PARTIC_INI  : restart file
!    PARTIC_FIN  : final output file
!    PARTIC_HDF  : transiente output file
!              
!
! !SEE ALSO:    
!  http://www.mohid.com
!


!
!DataFile
!
!   DT_PARTIC               : sec.                      [DT_Model]              !Particle Time Step    
!   VERT_STEPS              : []                        [10]                    ! number of vertical steps along DT_PARTIC 
!   OUTPUT_TIME             : sec. sec. sec.            []                      !Output Time
!   RESTART_FILE_OUTPUT_TIME: sec. sec. sec.            []                      !Output Time to write restart files
!   RESTART_FILE_OVERWRITE  : 0/1                       [1]                     !Overwrite intermediate restart files    
!   PARTIC_BOX              : char                      []                      !Particle Box definition file
!   MONITOR_BOX             : char                      []                      !Particle Monitoring box
!   next keyword is read if MONITOR_BOX is defined
!   MONITOR_BOX_PROP_MASS   : char                      []                      !Name of property to monitor Mass in a box
!   following 3 keywords are read if MONITOR_BOX_PROP_MASS is defined
!   MONITOR_BOX_MASS_FRACTION : 1/2                     [1]                     !Output Concentration Type of mass monitored in box
!                                                                                  1 - Arithmetic; 2 - geometric
!   MONITOR_BOX_MIN_CONC    : real                      [1]                     !Min. tracer concentration to be included in 
!                                                                               !average concentration
!                                                                               !and contamination probability in each box
!   MONITOR_BOX_CONT_DEPTH  : real                      []                      !Depth considered to contamination probability
!   EULERIAN_MONITOR_BOX    : char                      []                      !Eulerian results monitoring box
!   MONITOR_POLY            : int                       [0]                     !Number of polygons to be use in pure 
!                                                                               !lagrangiam monitorization (no grid)
!   MONITOR_POLY_DT         : real                      [DT_PARTIC]             !Time step use to monitor the particles
!   <BeginMonitorPoly>
!   poly1.xy
!   poly2.xy
!   ........
!   <EndMonitorPoly>
!   ASSOCIATE_BEACH_PROB    : 0/1                       [0]                     !Associates Beaching Probabilities
!   DEFAULT_BEACHING_PROB   : real                      [0.5]                   !Outbox Beaching Probability
!   BEACHING_LIMIT          : real                      [5.0]                   !Maximum distance between particles and coast
                                                                                !for particle beaching
!   BEACHING_BOX_FILENAME   : char                      []                      !Beaching Probability Box definition file
!   BOXES_BEACHING_PROB     : real(Boxes Number)        []                      !List of Inbox Beaching Probability
!   DEFAULT_SHORE_TYPE      : 1-11                      [5]                     !Default shoreline type
!   SHORE_TYPE_BOX_FILENAME : char                      []                      Shoreline types Boxes data file
!   REMOVAL_RATE_COEF        : real                     [0]                     !default removal rate coefficient (in 1/days)
!   BEACHING_LIMIT_SPATIAL  : 1/2                       [1]                     !Spatial definition for Beaching  Limit
                                                                                !1-Constant 2-Shore Type based
!   (next keyword is read if BEACHING_LIMIT_SPATIAL = 2)
!   BEACHING_LIMIT_LIST     : real (Shore types number)                         !List of Beaching Limits for each shore type
!   REMOVAL_RATE_COEF_SPATIAL: 1/2                      [1]                        !Spatial definition for removal rate coef.
                                                                                !1-Constant 2-Shore Type based
!   (next keyword is read if REMOVAL_RATE_COEF_SPATIAL = 2)
!   REMOVAL_RATE_COEF_LIST  : real (Shore types number)                         !List of Removal rates for each shore type
!   OUTPUT_CONC             : 1/2                       [1]                     !OutPut Integration Type
!                                                                               1 - Maximum, 2 - Mean, 3 - Analytic
!   OUTPUT_MAX_TRACER       : 0/1                       [0]                     !Checks if the users wants to output the maximum 
                                                                                ! tracer concentration in each cell
!   OVERLAY_VELOCITY        : 0/1                       [0]                     !If a adicional velocity field is to be added
!   OUTPUT_TRACER_INFO      : 0/1                       [0]                     !Output a file with detailed information for 
!                                                                               !each tracer (extension .tro)
!
!
!   OUTPUT_MASS_TRACER      : 0/1                       [0]                     !Checks if the users wants to output 
                                                                                ! the mass per cell
!   OUTPUT_ORIGIN_ENVELOPE  : 0/1                       [0]                     !output origin envelope
!   WRITE_DUMMY_PART        : 0/1                       [0]                     !Write dummy particle in the start date if 
!                                                                               !start emission > start date
!   COASTLINE_FILE            : char                    []                      !Coastline file
!   THINWALLS_FILE          : char                      []                      !Thin walls file
!   NEW_GRID_CENTER         : Xcoord Ycoord             []                      !Recenter the model grid
!   RUN_ONLINE                : 0/1                     [0]                     !Run module lagrangian online
!   IGNORE_ON                : 0/1                      [0]                     !ignore discharges in land points
!   COMPUTE_AVERAGE_POSITION: 0/1                       [0]                     !This logical option allows to compute the         
!                                                                                average position and the radius of influence of     
!                                                                                of the tracers of each origin                
!   (next keyword is read if COMPUTE_AVERAGE_POSITION = 1)
!   COEF_RADIUS                : real                    [1.645]                ! multiplying factor of particles radius of 
                                                                                ! influence 
!   STOP_WITH_NO_PART       : 0/1                        [0]                    ! stop model if particles number is zero
!
!
!<BeginOrigin>
!   DEFAULT                    : 0/1                    [0]                     !????
!   ORIGIN_NAME             : char                      [Origin_xx]             !Name of the origin
!   OLD                     : 0/1                       [0]                     !Old Origin
!   GROUP_ID                : integer                   [1]                     !Group to which belong Origin
!   EMISSION_SPATIAL        : Point/Accident/Box        [-]                     !Spatial emission type
!   EMISSION_TEMPORAL       : Continuous/Instantaneous  [-]                     !Temporal emission type
!   EMISSION_ON                : 0/1                    [1]                     !Turn on/off emission
!   (next keyword is read if EMISSION_TEMPORAL = Instantaneous)
!   INSTANT_PARTIC_EMIT        : YYYY MM DD HH MM SS    [BeginModel]            !instantaneous emission

!   (following 3 keywords are read if EMISSION_TEMPORAL = Continuous)
!   DT_EMIT                 : sec                       [DT_PARTIC]             !Interval between continuous emissions
!   START_PARTIC_EMIT       : YYYY MM DD HH MM SS       [BeginModel]            !InitialData of the emission
!   STOP_PARTIC_EMIT        : YYYY MM DD HH MM SS       [EndModel]              !FinalData of the emission    

!   (following 13 keywords are read if EMISSION_SPATIAL = Point)
!   FLOW_VARIABLE           : 0/1                       [0]                     !Check if the user wants a variable water flow
!   (following 5 keywords are read if FLOW_VARIABLE = 1)
!   DISCHARGE_FILE          : char                      [ ]                     !Name of the time serie input where is defined 
                                                                                !the variable flow
!   FLOW_COLUMN             : int                       [ ]                     !Column of the time serie input where is defined
                                                                                !a variable flow
!                                                                               (continous emission)
!   ESTIMATE_MIN_VOL        : 0/1                       [0]                     ! ?????
!   (next keyword is read if ESTIMATE_MIN_VOL = 1)
!   MAX_PART                : real                      [10000]                 ! ?????
!   MAX_VOLUME                : real                    []                      ! ?????

!   (next keyword is read if FLOW_VARIABLE = 0)
!   FLOW                    : real                      [-]                     !Flow associated to point origin 

!   MOVING_ORIGIN            : 0/1                      [0]                     !Moving Origin
!   (following 5 keywords are read if MOVING_ORIGIN = 1)
!   MOVING_ORIGIN_FILE        : char                    []                      !FileName with Trajectory of origin
!   MOVING_ORIGIN_UNITS        : char                   [Cells]                 !Time Serie given in meters or in cells
!   MOVING_ORIGIN_COLUMN_X  : int                       []                      !Column to read X coordinate values 
                                                                                !in Moving Origin file
!   MOVING_ORIGIN_COLUMN_Y  : int                       []                      !Column to read Y coordinate values 
                                                                                !in Moving Origin file
!MOVING_ORIGIN_CLOUD_EMISSION:0/1                       [0]                     !Moving Origin Cloud Emission
!   POINT_VOLUME            : real                      [-]                     !Volume of instantanous emission
!                                                                                (point or accident)
!   TVOL200                 : real                      [-]                     !Time to double volume
!   SPLIT_PART              : 0/1                       [0]                     !Split big particles
!   VOLFAC                  : real                      [10]                    !Factor of how many times a particle can grow
!   VOLUME_INCREASE         : Double/Velocity                                   !Type of function to calculate volume increase
!   FLOAT                   : 0/1                       [0]                     !Floating particle
!   ACCIDENT_METHOD         : Fay/Thickness             [Fay]                   !Way to calculate initial area of accident        
!   ACCIDENT_TIME           : YYYY MM DD HH MM SS       [BeginModel]            !Accident time
!   (next keyword is only read if EMISSION_SPATIAL = Accident and ACCIDENT_METHOD = Thickness)
!   THICKNESS_METERS        : meters                    []                      !Thickness of floating particles
!   MOVEMENT                : SullivanAllen/NotRandom/DiffusionCoef   []                      !Random Horizontal Movement
!   (following 5 keywords are read if MOVEMENT = SullivanAllen)
!   VARVELHX                :                           [0.2]                   !
!   VARVELH                 :                           [0.0]                   !
!   TURB_V                  : Constant/Profile          []                      !Vertical turbulence parameterization
!   (following 2 keywords are read if TURB_V = Constant)
!       VARVELVX            :                           [0.0]
!       VARVELV             :                           [0.0]
!   ADVECTION               : 0/1                       [1]                     !Move Particle due horizontal velocity    
!   (next keyword is only read if ADVECTION = 1)
!   ADVECTION_Z             : 0/1                       [1]                     !Move Particle due vertical velocity    
!   KILL_LAND_PARTICLES     : 0/1                       [0]                     !Kills particles which are located in a Waterpoint
!                                                                               !which is not a OpenPoint                   
!   STOKES_DRIFT            : 0/1                       [0]                     !Wave-driven particle velocity (Stokes Drift)
!   STOKES_DRIFT_METHOD     : LonguetHigginsDeep/LonguetHigginsGeneric/Ardhuin  [LonguetHigginsGeneric]  Stokes Drift Method
!   WINDDRIFTCORRECTION     : 0/1/2                     [0]                     ! 0 = no wind drift correction; 
!                                                                               ! 1 = user-defined; 3 = computed (Samuels, 1982)
!   (next keyword is only read if WINDDRIFTCORRECTION = 1)
!   WINDDRIFTANGLE          : real                      [0]                     !Wind Drift Angle Correction due to Coriolis
!   WINDCOEF                : real                      [0.03]                  !Wind transfer Coeficient
!   WINDXY                  : real real                 [0.0 0.0]               !If this keyword is defined than the the wind 
                                                                                !the wind velocity defined in the atmosphere 
                                                                                !module is override nad the wind use by the 
                                                                                !tracers is this one 
!   SLIP_CONDITION          : 0/1                       [1]                     !avoid particles to be kept stuck in the shoreline
                                                                                !due to low velocities
!   SEDIMENTATION  : Stokes/Imposed/Density Dynamic/Secondary Clarifier   []    !Sedimentation type
!   (next keyword is read if SEDIMENTATION = Stokes or Density Dynamic)
!   D50                     : real  (mm)            [0.002-Stokes or 0.00025]   !Median particle diameter
!   (next keyword is read if SEDIMENTATION = Density Dynamic)
!   D50_DENSITY             : real                      [920.]                  !D50 particle density
!   (next keyword is read if SEDIMENTATION = Imposed)
!   SED_VELOCITY            : real                      []                      !Sedimentation Velocity
!   MIN_SED_VELOCITY        : real (m/s)                [0.0]                   !Minimum Sedimention velocity
!   DEPOSITION              : 0/1                       [0]                     !Checks if the tracers can deposited
!   (following 6 keywords are read if DEPOSITION = 1)
!   TAU_ERO                 : real (Pa)                 [0.2]                   !Critical shear stress of erosion
!   TAU_DEP                 : real (Pa)                 [0.1]                   !Critical shear stress of deposition
!   BOTTOM_DISTANCE         : real (m)                  [0.1]                   !Distance from bottom below which the tracer can 
!                                                                               !sediment
!   TIME_DECAY              : real (s)                  [172800.]               !Decay time use to compute a relaxation term that 
                                                                                !makes the critical shear stress of erosion tend to 
                                                                                !the average tracer erosion rate
                                                                                !of the cell where the tracer is deposited. 
                                                                                !This is use to compute 
                                                                                !the shadow effect of the large sediments over the 
                                                                                !smaller ones. 
!   BOTTOM_EMISSION         : 0/1                       [0]                     !Checks if the tracers are emited from the bottom
!   EROSION_RATE            : real (g/m2/s)             [5.e-2]                 !Rate of tracers erosion

!   NBR_PARTIC              : int                       [1]                     !Number of Particles in each emission
!   POSITION_COORDINATES    : Xcoord Ycoord             []                      !X and Y Position of the origin in the grid        
                                                                                !coordinates
!   SURFACE_EMISSION        : 0/1                       [0]                     !Checks if the tracers are emited at the surface
!   (following 3 keywords are read if SURFACE_EMISSION = 0)
!   DEPTH_FROM_FREE_SURFACE : real (m)                  []                      ! Depth from free surface (including water level)
!   (following keywords are read if DEPTH_FROM_FREE_SURFACE is not defined)
!   DEPTH_METERS            : meters (from surface)     []                      !Depth of emission relativ to surface
!   (next keyword is read if DEPTH_METERS is not defined)
!   DEPTH_CELLS             : Cell                      []                      !Depth in Cells (from bottom)
!   MAINTAIN_DEPTH          : 0/1                       [0]                     !Depth is kept constant in the whole simulation
! MAINTAIN_RELATIVE_POSITION: 0/1                       [0]                     !Depth in relation to free surface is kept constant 

!   (following 3 keywords are read if EMISSION_SPATIAL = Box)
!   INCRP                   : int                       [1]                     !Increment of grid cells to fill Boxes
!   BOX_NUMBER              : int                       []                      !Number of box to associate to origin
!   BOXVOLINIC              : real                      [VolumeOfBox]           !Initial Volume of a particle in the box
!   (next keyword is read if EMISSION_TEMPORAL = Instantaneous)
!   KILL_PART_INSIDE_BOX    : logical                   [0]                     !Kill all particles inside the emission boxes.   

!   COMPUTE_PLUME           : 0/1                       [0]                     !Computes Particle Plume due density gradients        
!   (following 4 keywords are read if COMPUTE_PLUME = 1)
!   PLUME_SHEAR             : 0/1                       [1]                     ! Momentum balance in horizontal direction
                                                                                !Increase of volume tracer due to shear effect
!   COEF_INITIAL_MIXING     : real                      []                      !Coefficient used to control volume increase due to 
!                                                                               !velocities gradients between the tracer and the 
!                                                                               !average flow
!   JET_DATA_FILE           : char                      []                      !Data file where the jet properties are defined
!   JET_DT                  : real  (s)                 [600]                   !Time interval between actualizations of the jet 
!                                                                               !properties
!   COMPUTE_BUOYANCY        : 0/1                       [0]                     !Computes Particle vertical velocity evolution
                                                                                !due to density gradients
!   DENSITY_METHOD          : int                       [2]                     !Way to calculate particle density 
                                                                                !(1-LeendertseState_, 
                                                                                ! 2-UNESCOState_)
!   PRESSURE_CORRECTION     : 0/1                       [1]                     ! Change density due to pressure correction
                                                                                ! (works only when DENSITY_METHOD = 2)
!   (following keyword is read when simulating water Quality)
!   WQM_DATA_FILE              : character              []                      !Data File of the WQM module                

!   (following 5 keywords are read when simulating Oil Spills)
!   AREA_METHOD             : int                       [1]                     !Method to compute volume in oil spills
                                                                                ! 1 - GridCells_, 2-VoronoiArea_, 3-FayMethod_
!   CDISP_OIL_OFF           : real                      [1.]                    ! maximum fraction of submerged oil where oil 
                                                                                ! internal processes are computed
!   DROPLETS_D50            : real (m)                  [50e-6]                 ! default median oil or HNS droplet diameter
!   METHOD_BW_DROPLETS_DIAMETER: int                    [1]                     ! method to obtain oil or HNS droplets diameter
                                                                                ! 1-UserDefined_; 2-Computed_Half_D50_; 
                                                                                ! 3-Computed_Classes_Random_
!   METHOD_FLOAT_VEL        : int                       [1]                     ! method to compute rising velocity of 
                                                                                ! submerged droplets
                                                                                ! 1-SoaresDosSantos_; 2-PADM_; 3-Zheng_
!   COMPUTE_AGE             : 0/1                       [0]                     ! compute the age of particles        
!   AGE_LIMIT               : real (days)               []                      ! particle age limit before killing particle

!   ACCIDENT_PROBABILITY    : 0/1                       [0]                     ! Compute Accident Probability
!   (following 3 keywords are read if ACCIDENT_PROBABILITY = 1)
!   DEFAULT_ACCIDENT_PROBABILITY: real                     [4.45238E-05]        ! Default accident probability
!   COMPUTE_RISK            : 0/1                       [0]                     ! Compute Risk
!   AREA_VTS                : 0/1                       [1]                     ! Include VTS area correction factor
!   BEACHING                : 0/1                       [0]                     !Beaching Process                 
!   BEACH_REMOVAL            : 0/1                      [0]                     !include the process of "unbeach" oil

!   FLOATING_OBJECT         : 0/1                       [0]                     ! model the tracers as if they were 
                                                                                ! solid floating objects
                                                                                ! e.g. containers, etc.
!   (following 3 keywords are read when simulating floating objects mif FLOATING_OBJECT = 1)
!   AIR_DRAG_COEF           : real                      [1.0]                   !Air drag coefficient
!   WATER_DRAG_COEF         : real                      [1.0]                   !Water drag coefficient
!   IMMERSION_RATIO         : real (in %)               [50.0]                  !Percentage immersed

!   (following keyword is read when simulating Human Body trajectories)
!   DROWNED            : 0/1                            []                      ! To model sinking drowned human bodies

!<<BeginProperty>>
!   NAME                    : char                      []                      !Name of the property
!   UNITS                   : char                      []                      !Units of the property
!   EQUAL_TO_AMBIENT        : 0/1                       [0]                     !Concentration equal to the ambient concentration
!   CONC_VARIABLE           : 0/1                       [0]                     !Check if the user wants a variable concentration
!   (next 2 keywords are read if CONC_VARIABLE = 1)
!   DISCHARGE_FILE          : char                      []                      !Filename with information about concentration
!   CONC_COLUMN             : int                       [ ]                     !Column of the time serie input where is defined 
                                                                                !a variable concentration
!   (next keyword is read if CONC_VARIABLE = 0)
!   CONCENTRATION           : real                      []                      !Concentration of the property
!   NOWQM                   : 0/1                       [0]                     ! To compute age without running moduleWQM
!   MIN_CONCENTRATION       : real                      [0.0]                   ! Minimum Concentration
!   AMBIENT_CONC            : real                      [0.0]                   !Ambient concentration
!   TIME_SERIE              : 0/1                       [0]                     ! Write Property Concentration to Time Serie Output
!   OUTPUT_HDF            : 0/1                         [0]                     ! Write Property Concentration to HDF output

!   (Following 9 keywords are read if NAME = larvae)
!   VERTICAL_MIGRATION      : 0/1                       [0]                     !include vertical migration in larvae modelling 
!   LARVAE_MAX_DEPTH        : real (m)                  [100]                   !maximum depth of larvae
!   LARVAE_MIN_DEPTH        : real (m)                  [10]                    !minimum depth of larvae
!   LARVAE_VELOCITY         : real (m/s)                [0.001]                 !constant larvae velocity
!   RADIATION_LIMIT        : real                       [0.00]                  !set the radiation limit from where larvae move down
!   LIGHT_RELATION          : 0/1                       [1]                     !????????
!   COMPUTE_LARVAE_VELOCITY : 0/1                       [1]                     ! compute larvae velocity 
!   (next keyword is read if COMPUTE_LARVAE_VELOCITY = 1)
!   MIGRATION_TIME        : real (s)                    [18000]                 ! time spent by larvae in one migration process

!   T90                     : real (s)                  [7200]                  !Coliform Decay rate                
!   T90_NAME                : char                      [T90]

!   (Following 9 keywords are read if NAME = fecal coliforms or escherichia coli)
!   T90_VARIABLE            : 0/1                       [0]                     !Check if the user wants to compute T90 function     
!                                                                                of ambient properties: salinity,temperature,light    
!   (next keyword is read if T90_VARIABLE = 1)
!   T90_VAR_METHOD          : int                       [1]                     !1 - Fecal decay according to Canteras et al. (1995)    
!                                                                               !2 - Fecal decay according to Chapra (1997)
                                                                                !3 - T90 decay from a timeserie            
!   (Following 2 keywords are read if T90_VAR_METHOD = 3)
!   T90_FILE                : char                      []                        !filename with timeserie of T90 values
!   T90_COLUMN              : int                       []                        !number of with T90 values in timeserie

!   PARTITION_WATER         : 0/1                        [0]                     !Checks if the tracers has two phases             
!                                                                               !(adsorbe and dissolved) in the water column.        
!   (Following 3 keywords are read if PARTITION_WATER = 1)
!   PARTITION_COEF_WATER    : real                      [0.9]                   ! partition coefficent in the water column        
!   PARTITION_RATE_WATER    : real  (s-1)               [1e-3]                  !Rate of transfer between the two phases.        
!   PARTITION_COUPLE_WATER  : real  (M/L^3)             [0.0]                   !Concentration of the dissolved phase.             
!                                                                               !The dissolved phase is admitted with a constant     
!                                                                               !concentration                        
!   PARTITION_SED           : 0/1                       [0]                     !Checks if the tracers has two phases             
!                                                                               !(adsorbe and dissolved) in the sediment        
!   (Following 3 keywords are read if PARTITION_SED = 1)
!   PARTITION_COEF_SED     : real                       [0.98]                  ! partition coefficent in the sediment            
!   PARTITION_RATE_SED     : real   (s-1)               [1e-4]                  !Rate of transfer between the two phases.        
!   PARTITION_COUPLE_SED   : real   (M/L^3)             [0]                     !Concentration of the dissolved phase in the         
!                                                                               !intersticial water. The dissolved phase is         
!                                                                               !admitted with a constant concentration.        
!   EXTINCTION_PARAMETER   : real                        [1.]                    !parameter to compute effect of the property in
                                                                                ! light extinction
!   FILTRATION             : 0/1                        [0]                     !property being filtered from the water column
!   MIN_VALUE           : real                           []                        !set a minimum value for the property
!   MAX_VALUE              : real                        []                        !set a maximum value for the property
!   HAS_ODOUR              : 0/1                        [0]                        !compute odour taking this property into account
!   (next keyword is read if HAS_ODOUR = 1)
!   ODOUR_CONC_THRESHOLD   : real  (mg/m3)                [*]                        !*: Methane = 25.16; HydrogenSulfide = 6.58e-4
!                                                                                !   MethylMercaptan_ = 2e-3
!<<EndProperty>>

!  parameters from the Module Oil
!<<BeginOil>>
!<<EndOil>>
!
!<EndOrigin>

!<BeginBooms>
!<<BeginIndividualBoom>>
!   NAME                    : char                        [BOOM X]
!   DESCRIPTION                : char                        [Boom to contain a oil spill]            
!   VEL_THRESHOLD            : m/s                        [0.4]
!   WAVE_THRESHOLD            : m                            [0.6]
!   FILENAME                : char                        []
!   BOOM_HAS_BUFFER         : 0/1                         [0]
!     BOOM_BUFFER_DIST      : real                        [0]
!<<EndIndividualBoom>>
!<EndBooms>

!<BeginMeteoOcean>
!<<BeginProperty>>
!   MASK_DIM  ??????????????????????????
!<<<BeginMeteoOceanFiles<>>
!<<<EndMeteoOceanFiles>>>
!<<EndProperty>>
!<EndMeteoOcean>

!<BeginStatistic>
!<<BeginProperty>>
!NAME                    : char                      []                      !Name of the property
!UNITS                   : char                      []                      !Units of the property
!STATISTICS_FILE         : char                      []                      !File name with the statistics definition
!STATISTICS_LAG          : 0/1                       [0]                     !Do a frequency analysis tracer by tracer.
!<<EndProperty>>
!<EndStatistic>


    use ModuleGlobalData
    use ModuleTriangulation,    only : ConstructTriangulation, GetNumberOfBoundaryNodes,    &
                                       GetBoundaryNodes, CalculateVoronoi,                  &
                                       GetVoronoiAreaNodes, GetNeighborNodesNumber,         &
                                       GetNeighborNodesIndex, KillTriangulation
    use ModuleTime                  
    use ModuleHDF5
    use ModuleFunctions,        only : SigmaUNESCO, SigmaLeendertse, SigmaUNESCOPressureCorrection,&
                                       InterpolateValueInTime, RodaXY,                      &
                                       ComputeT90_Chapra, ComputeT90_Canteras,              &
                                       GetDataOnlineString, SetMatrixValue, TimeToString,   &
                                       ChangeSuffix, ConstructPropertyID,                   &
                                       DistanceBetweenTwoGPSPoints, WGS84toGoogleMaps,      &
                                       SettlingVelSecondaryClarifier,                       &
                                       WaveLengthHuntsApproximation, LinearInterpolation
    use ModuleEnterData,        only : ReadFileName, ConstructEnterData, GetData,           &
                                       ExtractBlockFromBuffer, ExtractBlockFromBlock,       &
                                       Block_Unlock, GetOutPutTime, RewindBuffer,           &
                                       GetKeywordFromLine, GetFullBufferLine,               &
                                       ReplaceFullBufferLine, RewindBlock,                  &
                                       RewindBlockinBlock, ExtractBlockFromBlockFromBlock,  &
                                       GetBlockSize, WriteDataLine, KillEnterData
    use ModuleDrawing,          only : T_Polygon, T_PointF, PointDistanceToPolygon, New,    &
                                       Add, SetLimits, T_Lines, IsVisible, SegIntersectLine,&
                                       SegIntersectPolygon, IsPointInsidePolygon,           &
                                       IsPointInsideCircle, WriteItem,                      &
                                       VertPolygonInsidePolygon, GetPolyLimits,             &
                                       PolygonSphericalTypeArea, PolygonTypeArea
    use ModuleWaterQuality,     only : StartWaterQuality, WaterQuality, GetDTWQM,           &
                                       GetWQPropIndex, KillWaterQuality
    use ModuleGridData,         only : GetGridData, GetMaximumValue, ModifyGridData,        &
                                       UngetGridData, WriteGridData
    use ModuleTimeSerie,        only : StartTimeSerie, StartTimeSerieInput, WriteTimeSerie, &
                                       GetNumberOfTimeSeries, GetTimeSerieLocation,         &
                                       CorrectsCellsTimeSerie, GetTimeSerieIntegral,        &
                                       WriteTimeSerieLine, GetTimeSerieValue, KillTimeSerie,&
                                       TryIgnoreTimeSerie, GetTimeSerieTimeFrameIndexes,    &
                                       GetTimeSerieDataMatrix
                                       
    use ModuleLightExtinction,  only : ConstructLightExtinction, ModifyLightExtinctionField,&
                                       GetLightExtinctionOptions, KillLightExtinction,      &
                                       GetShortWaveExtinctionField, UnGetLightExtinction,   &
                                       GetLongWaveExtinctionCoef, GetRadiationPercentages
    use ModuleHorizontalMap,    only : GetBoundaries, GetWaterPoints2D, UpdateWaterPoints2D,&
                                       UnGetHorizontalMap
    use ModuleHorizontalGrid
    use ModuleAssimilation,     only : StartAssimilation, GetAssimilationField,             &
                                       UnGetAssimilation, KillAssimilation,                 &
                                       GetAssimilationVectorField
    use ModuleGeometry,         only : GetGeometrySize, GetGeometryWaterColumn,             &
                                       GetGeometryDistances, GetGeometryVolumes,            &
                                       GetGeometryKFloor, UnGetGeometry, GetLayer4Level,    &
                                       UpdateKfloor, ComputeInitialGeometry
    use ModuleMap,              only : GetWaterPoints3D, GetLandPoints3D, GetOpenPoints3D,  &
                                       GetComputeFaces3D, UngetMap, UpDateWaterPoints3D,    &
                                       UpdateComputeFaces3D             
    use ModuleBoxDif,           only : StartBoxDif, GetBoxes, GetNumberOfBoxes, UngetBoxDif,&
                                       BoxDif, CheckIfInsideBox, GetIfBoxInsideDomain, KillBoxDif        
    use ModuleTurbulence,       only : GetMixingLengthVertical, GetMixingLengthHorizontal,  &
                                       GetHorizontalViscosity, GetVerticalDiffusivity,      &
                                       UngetTurbulence       
    use ModuleHydrodynamic,     only : StartHydrodynamic,                                   &
                                       GetHorizontalVelocity,                               &
                                       GetVerticalVelocity, GetWaterLevel, UngetHydrodynamic
    use ModuleWaterProperties,  only : Construct_WaterProperties, WaterPropertyExists,      &
                                       GetConcentration, GetDensity, GetSigma,              &
                                       UngetWaterProperties, GetSPM,                        &
                                       GetWaterPropertiesSubModulesID, GetDensityOptions,   &
                                       GetFiltrationRate, SetLagrangianSinksSources
    use ModuleStatistic,        only : ConstructStatistic, ModifyStatistic, KillStatistic,  &
                                       GetStatisticClassesNumber, GetStatisticClasses,      &
                                       UnGetStatistic, GetStatisticMethod,                  &
                                       GetStatisticParameters, GetStatisticLayersNumber,    &
                                       GetStatisticLayerDef, AddStatisticLayers
    use ModuleOil_0D
    use ModuleJet,              only : Construct_Jet, GetPlumeTemperature, GetOutPutMatrix, &
                                       GetPlumeLocation, GetPlumeVelocity, GetPlumeDilution,&
                                       GetPlumeDensity, GetPlumeMixingHorLength,            &
                                       GetPlumeThickness, GetPlumeSalinity, ModifyJet,      &
                                       UnGetJet, KillJet
    use ModuleAtmosphere,       only : GetAtmosphereProperty, AtmospherePropertyExists, UngetAtmosphere
    use ModuleHNS
    
#ifndef _WAVES_
    use ModuleWaves
#endif
    use ModuleField4D,          only : ConstructField4D, ModifyField4DXYZ, GetBathymXY, KillField4D
    
#ifdef _LITTER_    
    use ModuleLitter,           only : ConstructLitter, ModifyLitter, KillLitter
#endif

#ifdef _OUTPUT_GRID_
    use ModuleOutputGrid,       only : ConstructOutputGrid, ModifyOutputGrid, KillOutputGrid
#endif

    !use ModuleVoronoi3D,        only : Voronoi_3D_volume

!#ifdef _CGI_
!    use dflib
!#endif
    
#ifndef _NO_NETCDF                                       
    ! Manages NetCDF files
    use ModuleNetCDF
#ifdef _USE_NIX
    use netcdf
#else
    use netcdf90
#endif
#endif
    

    implicit none 

    private

    !Subroutines---------------------------------------------------------------

    !Constructor
    public  :: AllocateLagrangianGlobal
    public  :: ConstructLagrangianGlobal
    private ::      ConstructGlobalVariables
    private ::      ConstructParticleGrid
    private ::      ConstructOrigins
    private ::          ConstructEmissionType
    private ::          ConstructParticOil
    private ::      VerifyOriginProperties
    private ::          VerifyPropertyList
    private ::      VerifyBeachingProbabilities
    private ::      VerifyShoreTypes
    private ::      ReadFinalPartic
    private ::      MergeOldWithNewOrigins
    private ::      ConstructEmission
    private ::          ConstructEmissionTime
    private ::      ActualizeMeteoOcean        
    private ::      ReadMeteoOceanBathym           
    private ::      ConstructOverlay         
    private ::      ConstructMonitoring
    private ::      ConstructMonitoringLag            
    private ::      ConstructLag2Euler      
    private ::      ConstructTimeSeries
    private ::      ConstructHDF5Output
    private ::      ConstructLog
    private ::      ConstructParticStatistic

    private ::          AllocateNewOrigin
    private ::          InsertOriginToList
    private ::          DeleteOrigin

    private ::          AllocateNewProperty
    private ::          InsertPropertyToList
    private ::          DeleteProperty

    private ::          AllocateNewParticle
    private ::          InsertParticleToList
    private ::          ActualizeJetProperties
    private ::          GiveJetPropertiesToParticle
    private ::          DeleteParticle

    private ::      ConstructParticLightExtinction


    !Modifier
    public  :: ModifyLagrangianGlobal
    private ::      ParticleEmission
    private ::          EmissionBox
    private ::          EmissionPoint
    private ::          EmissionAccident
    private ::          EmissionPoly
    private ::      FillGridThickness
    private ::      FillGridConcentration
    private ::      ParticleDensity
    private ::      UpdateBeachedVolumes
    private ::      VerifyParticleBeaching
    private ::      UpdateRemovedVolumes
    private ::      VerifyBeachRemoval   
    private ::      MovePartic
    private ::          MoveParticHorizontal
    private ::              MoveParticVertical
    private ::                  WD_
    private ::              ParticSlipCondition
    private ::          VerifyRessuspension
    private ::          VerifyDeposition
    private ::      VerifyLandParticles
    private ::      PurgeParticles
    private ::      VolumeVariation
    private ::          VolumeFirstOrderVariation
    private ::          VoronoiVolume
    private ::      Dilution
    private ::          GetAmbientConcCell
    private ::          GetAmbientConcPartic    
    private ::          GetConcPartic    
    private ::      PropertiesEvolution
    private ::      ColiformDecay
    private ::          ComputeT90
    private ::      PartitionDecay
    private ::      ComputeAreaVolume
    private ::      UpdateHNSAreaVolume
    private ::      UpdateHNSMass
    private ::      InternalParticOil
    private ::          OilGridConcentration
    private ::          OilGridConcentration3D
    private ::          OilGridDissolution3D
    private ::      NewParticleMass
    private ::      NewParticleAge
    private ::      MonitorParticle
    private ::      MonitorParticleLag    
    private ::      ModifyParticStatistic
    private ::          ComputeStatisticsLag
    private ::          ActualizesTauErosionGrid

    private ::      LightEvolution

    private ::      ParticleOutput
    private ::          WriteGridConcentration
    private ::          WriteOilGridThickness
    private ::          WriteOilGridConcentration

    private ::      OutputRestartFile


    private :: Convert_XY_CellIJ
    private :: Convert_CellIJ_XY
    private :: Convert_Z_CellK
    private :: Convert_CellK_Z
    private :: Convert_CellK_K

    private :: Locate_ModelDomain

    private :: Search_Property

    !Selector
    public  :: SetLagrangianShearGlobal
    public  :: SetLagrangianAtmPressureGlobal
    public  :: SetLagrangianWindGlobal
    public  :: SetLagrangianAirTemperature
    public  :: GetLagrangianAirOptionsGlobal
    public  :: SetLagSolarRadiationGlobal

    !Destructor
    public  :: DeallocateLagrangianGlobal
    public  :: KillLagrangianGlobal
    private ::      WriteFinalPartic
    private ::      DeallocateOriginList
    private ::      KillParticleStatistic
    private ::          WriteFrequencyLag
    private ::      KillLight

    !Managment
    private :: ReadLockExternalVar
    private :: ReadLockEulerianDensity
    private :: ReadUnLockExternalVar
    private :: ReadUnLockEulerianDensity
    private :: Ready


    !Parameter
    integer, parameter                          :: Continuous_              = 1
    integer, parameter                          :: Instantaneous_           = 2
    integer, parameter                          :: Point_                   = 1
    integer, parameter                          :: Accident_                = 2
    integer, parameter                          :: Box_                     = 3
    integer, parameter                          :: Poly_                    = 4



    !Aleat movement
    integer, parameter                          :: SullivanAllen_           = 1
    integer, parameter                          :: NotRandom_               = 2
    integer, parameter                          :: DiffusionCoef_           = 3

    !Standard deviation
    integer, parameter                          :: VerticalTurbConstant     = 1
    integer, parameter                          :: VerticalTurb             = 2

    !Sedimentation
    integer, parameter                          :: Stokes_                  = 1
    integer, parameter                          :: Imposed_                 = 2
    integer, parameter                          :: DensDynamic_             = 3
    integer, parameter                          :: SecondaryClarifier_      = 4
    integer, parameter                          :: FergusonChurch2004_      = 5
    

    !accident
    integer, parameter                          :: Fay_                     = 1
    integer, parameter                          :: Thickness_               = 2
    
    !Methods to compute slick areas
    integer, parameter                          :: FayMethod_               = 3
    integer, parameter                          :: VoronoiArea_             = 2
    integer, parameter                          :: GridCells_               = 1
      
    !TVolType
    integer, parameter                          :: Velocity_                = 1
    integer, parameter                          :: Double_                  = 2

    !OutputIntegrationType
    integer, parameter                          :: Maximum                  = 1
    integer, parameter                          :: Mean                     = 2
    integer, parameter                          :: Analytic                 = 3

    !Relative position 
    integer, parameter                          :: Cells                    = 1
    integer, parameter                          :: Meters                   = 2

    !T90 Calc Method
    integer, parameter                          :: Canteras                 = 1
    integer, parameter                          :: Chapra                   = 2
    integer, parameter                          :: FromTimeSerie            = 3
    
    !Online Emission options 
    integer, parameter                          :: ParticleOne              = 1
    integer, parameter                          :: Particle100              = 2
    ! Monitorization
    integer, parameter                          :: Arithmetic               = 1
    integer, parameter                          :: Geometric                = 2
    
    !Odours
    real, parameter                             :: PeakFactor               = 0.005833      ! = (60./3600.)^0.35
    
    !Methods to compute buoyancy / floating velocity
    !2-equation approach - Soares dos Santos and Daniel, 2000:
    integer, parameter                          :: SoaresDosSantos_         = 1 
    !same as previous, but with coefficients from PADM (Seatrackweb 2011):
    integer, parameter                          :: PADM_                    = 2 
    !3-equation approach - Zheng and Yapa, 2000:
    integer, parameter                          :: Zheng_                   = 3 
    
    !Methods for Stokes Drift
    integer, parameter                          :: LonguetHigginsDeep       = 1
    integer, parameter                          :: LonguetHigginsGeneric    = 2
    integer, parameter                          :: Ardhuin                  = 3
    
    !Spatial definition for BeachingLimit
    integer, parameter                          :: Constant_                = 1
    integer, parameter                          :: ShoreTypeBased_          = 2
    
    !Wind Drift Correction
    integer, parameter                          :: NoCorrection_            = 0
    !UderDefined_ option already declared
    integer, parameter                          :: Computed_Samuels_        = 2

    integer, parameter                          :: ShoreTypesNbr            = 11
    
    integer, parameter                          :: nDir                     = 36
    
    character(LEN = StringLength), parameter    :: block_begin              = '<BeginOrigin>'
    character(LEN = StringLength), parameter    :: block_end                = '<EndOrigin>'
    character(LEN = StringLength), parameter    :: statistic_begin          = '<BeginStatistic>'
    character(LEN = StringLength), parameter    :: statistic_end            = '<EndStatistic>'
    character(LEN = StringLength), parameter    :: property_begin           = '<<BeginProperty>>'
    character(LEN = StringLength), parameter    :: property_end             = '<<EndProperty>>'
    character(LEN = StringLength), parameter    :: oil_begin                = '<<BeginOil>>'
    character(LEN = StringLength), parameter    :: oil_end                  = '<<EndOil>>'
    character(LEN = StringLength), parameter    :: meteo_ocean_begin        = '<BeginMeteoOcean>'
    character(LEN = StringLength), parameter    :: meteo_ocean_end          = '<EndMeteoOcean>'
    character(LEN = StringLength), parameter    :: meteo_ocean_begin_files  = '<<<BeginMeteoOceanFiles>>>'
    character(LEN = StringLength), parameter    :: meteo_ocean_end_files    = '<<<EndMeteoOceanFiles>>>'

    character(LEN = StringLength), parameter    :: booms_begin              = '<BeginBooms>'
    character(LEN = StringLength), parameter    :: booms_end                = '<EndBooms>'
    character(LEN = StringLength), parameter    :: individual_boom_begin    = '<<BeginIndividualBoom>>'
    character(LEN = StringLength), parameter    :: individual_boom_end      = '<<EndIndividualBoom>>'

    character(LEN = StringLength), parameter    :: hns_begin                = '<<BeginHNS>>'
    character(LEN = StringLength), parameter    :: hns_end                  = '<<EndHNS>>'

    character(LEN = StringLength), parameter    :: block_begin_clone        = '<BeginOrigin_Clone>'
    character(LEN = StringLength), parameter    :: block_end_clone          = '<EndOrigin_Clone>'


    character(LEN = StringLength), parameter    :: Char_Continuous          = 'Continuous'
    character(LEN = StringLength), parameter    :: Char_Instantaneous       = 'Instantaneous'
    character(LEN = StringLength), parameter    :: Char_Point               = 'Point'
    character(LEN = StringLength), parameter    :: Char_Accident            = 'Accident'
    character(LEN = StringLength), parameter    :: Char_Box                 = 'Box'
    character(LEN = StringLength), parameter    :: Char_Poly                = 'Poly' 

    character(LEN = StringLength), parameter    :: Char_SullivanAllen       = 'SullivanAllen'
    character(LEN = StringLength), parameter    :: Char_NotRandom           = 'NotRandom'
    character(LEN = StringLength), parameter    :: Char_DiffusionCoef       = 'DiffusionCoef'    
    character(LEN = StringLength), parameter    :: Char_Profile             = 'Profile'
    character(LEN = StringLength), parameter    :: Char_Constant            = 'Constant'

    character(LEN = StringLength), parameter    :: Char_Stokes              = 'Stokes'
    character(LEN = StringLength), parameter    :: Char_Imposed             = 'Imposed'
    character(LEN = StringLength), parameter    :: Char_DensDynamic         = 'Density Dynamic'    
    character(LEN = StringLength), parameter    :: Char_SecondaryClarifier  = 'Secondary Clarifier'    
    character(LEN = StringLength), parameter    :: Char_FergusonChurch2004  = 'FergusonChurch2004'

    character(LEN = StringLength), parameter    :: Char_Fay                 = 'Fay'
    character(LEN = StringLength), parameter    :: Char_Thickness           = 'Thickness'

    character(LEN = StringLength), parameter    :: Char_Double              = 'Double'
    character(LEN = StringLength), parameter    :: Char_Velocity            = 'Velocity'

    character(LEN = StringLength), parameter    :: Char_Cells               = 'Cells'
    character(LEN = StringLength), parameter    :: Char_Meters              = 'Meters'
    
    character(LEN = StringLength), parameter    :: Char_LonguetHigginsDeep  = 'LonguetHigginsDeep'
    character(LEN = StringLength), parameter    :: Char_LonguetHigginsGeneric = 'LonguetHigginsGeneric'
    character(LEN = StringLength), parameter    :: Char_Ardhuin             = 'Ardhuin'
    
!----------------------------------------------------------------------------
!                                   Eulerian types
!----------------------------------------------------------------------------

    type T_OverLay
        real, dimension(:, :, :), pointer       :: VelUFinal                   => null()
        real, dimension(:, :, :), pointer       :: VelVFinal                   => null()
    end type T_OverLay

    type T_ParticleGrid
        integer                                 :: CoordType                   = null_int 
        logical                                 :: HaveLatLongGrid             = .false.
        logical                                 :: GeoGrid                     = .false.
        real                                    :: LatDefault                  = null_real
        real                                    :: LongDefault                 = null_real
        real, dimension(:, :), pointer          :: ParticXX                    => null()
        real, dimension(:, :), pointer          :: ParticYY                    => null()
    end type T_ParticleGrid

    type T_Light
        integer                                 :: ObjLightExtinction          = 0
                          !i,j,k
        real,    dimension(:,:,:), pointer      :: TopRadiationCells           => null()
        real,    dimension(:,:,:), pointer      :: ShortWaveExtinctionField    => null()
        logical                                 :: Compute                     = OFF
    end type T_Light

    type T_EulerianMonitor
        real(8), dimension(:, :, :), pointer    :: Mass                        => null()
    end type T_EulerianMonitor

    type T_Monitorization
        real(8), dimension(:),    pointer       :: SurfaceBoxVolume            => null()
        real(8), dimension(:),    pointer       :: InstBoxVolume               => null()
        real(8), dimension(:),    pointer       :: InstBoxMass                 => null()
        real(8), dimension(:, :), pointer       :: InstMassByOrigin            => null()
        real(8), dimension(:, :), pointer       :: InstVolumeByOrigin          => null()
        real(8), dimension(:),    pointer       :: IntgBoxVolume               => null()
        real(8), dimension(:, :), pointer       :: IntgVolumeByOrigin          => null()
        integer, dimension(:),    pointer       :: NumberOfCellsPerBox         => null()
        integer, dimension(:, :), pointer       :: NumberOfCellsFromOrigin     => null()
        integer, dimension(:), pointer          :: ObjTimeSerie                => null()
                           !i,j,k
        integer, dimension(:,:,:), pointer      :: Boxes                       => null()
        integer                                 :: NumberOfBoxes               = null_int
        real(8), dimension(:),    pointer       :: InstBoxLogMass              => null()
        real(8), dimension(:),    pointer       :: InstBoxConc                 => null()
        integer, dimension(:), pointer          :: NumberOfTracers             => null()
        real(8), dimension(:, :), pointer       :: InstBoxMassFractionByOrigin => null()
        real(8), dimension(:, :), pointer       :: InstLogMassByOrigin         => null()
        integer, dimension(:, :), pointer       :: NumberOfTracersFromOrigin   => null() 
        integer                                 :: EulerianMonitorBoxType      = Arithmetic
        real(8), dimension(:), pointer          :: ContaminationProbability    => null()
        real(8), dimension(:), pointer          :: AverageBoxContaminatedConc  => null()
        integer, dimension(:), pointer          :: NbrBoxContaminatedTracers   => null()
        real(8), dimension(:), pointer          :: VolBoxContaminatedTracers   => null()
    end type T_Monitorization


    type T_Lag2Euler
                          !i, j, k, p, ig
        real,    dimension(:, :, :, :, :), pointer     :: GridConc              => null()        
        integer, dimension(:, :, :, :   ), pointer     :: GridTracerNumber      => null()
        real,    dimension(:, :, :, :, :), pointer     :: GridMaxTracer         => null()
        real,    dimension(:, :, :, :, :), pointer     :: GridMaxMass           => null()        

        real(8), dimension(:, :, :, :   ), pointer     :: GridVolume            => null()
        real,    dimension(:, :, :, :   ), pointer     :: PercentContamin       => null()
        real,    dimension(:, :, :, :, :), pointer     :: GridMass              => null()

                          !p, ig  
        real,    dimension(:, :),          pointer     :: MeanConc              => null()
        real,    dimension(:, :),          pointer     :: AmbientConc           => null()
        real,    dimension(:, :),          pointer     :: MinConc               => null()
        real,    dimension(:, :),          pointer     :: MassVolCel            => null()

        !Deposition    
        real,    dimension(:, :,    :, :), pointer     :: GridBottomConc        => null()
        real,    dimension(:, :, :, :   ), pointer     :: GridBottomMass        => null()        

        integer, dimension(:, :, :),       pointer     :: GridBottomNumber      => null()
        integer, dimension(:, :, :),       pointer     :: GridWaterColumnNumber => null() 
        
        real,    dimension(:, :, :),       pointer     :: GridBottomVolume      => null()
        real,    dimension(:, :, :),       pointer     :: GridWaterColumnVolume => null()
        
        real,    dimension(:, :, :),       pointer     :: GridBottomSlope       => null()
        real,    dimension(:, :, :),       pointer     :: GridVelSlope_X        => null()
        real,    dimension(:, :, :),       pointer     :: GridVelSlope_Y        => null()
        
        !g/m2
        real,    dimension(:, :, :),       pointer     :: GridWaterColumnSedAreaDensity => null() 
        
        !Deposition & Erosion Sediments
        real,    dimension(:, :, :),       pointer     :: TauErosionGrid        => null()
        real,    dimension(:, :, :),       pointer     :: MassSedGrid           => null()

        
       
        
        !Beached
        real,    dimension(:, :, :),       pointer     :: GridBeachedVolume             => null()
        real,    dimension(:, :, :),       pointer     :: PreviousGridBeachedVolume     => null()
        real,    dimension(:, :, :),       pointer     :: GridBeachedVolVar             => null()
        real,    dimension(:, :, :, :),    pointer     :: GridBeachedVolumeByType       => null()
        real,    dimension(:,:,:),         pointer     :: TheoricBeachedVolAfterRemoval => null()
        real,    dimension(:,:,:),         pointer     :: GridVolToRemove               => null()
        real,    dimension(:,:,:),         pointer     :: GridVolToRemoveFraction       => null()
        real,    dimension(:,:,:),         pointer     :: GridVolRemovedDiff            => null()
        
        !Beached oil presence
        real,    dimension(:, :, :),       pointer     :: GridBeachingTime              => null()

    end type T_Lag2Euler

    type T_PropStatistic
                          !i,j,k,f,ig
        real,    dimension(:,:,:,:,:), pointer :: FrequencyLag                          => null()
                                  !ig
        integer, dimension(        :), pointer :: Statistic1_ID                         => null()
        integer, dimension(        :), pointer :: Statistic2_ID                         => null()
        integer, dimension(        :), pointer :: Statistic3_ID                         => null()
        integer, dimension(        :), pointer :: Statistic4_ID                         => null()

    end type T_PropStatistic

    type T_OilSpreading
        !Oil vectors
        real,    pointer, dimension(:,:  )      :: VelocityX                            => null()
        real,    pointer, dimension(:,:  )      :: VelocityY                            => null()

        !Oil
                          !i, j 
        real,    dimension(:, :),    pointer    :: GridThickness                        => null()
        real,    dimension(:, :),    pointer    :: OilGridConcentration                 => null()
        real,    dimension(:, :, :), pointer    :: OilGridConcentration3D               => null()
        real,    dimension(:, :, :), pointer    :: OilGridDissolution3D                 => null()

        logical, dimension(:,:),     pointer    :: AreaFlag                             => null()
        
        real,    dimension(:,:),     pointer    :: GridOilArrivalTime                   => null()
        
    end type T_OilSpreading

    type T_HNS

                          !i, j, k 
        real,    dimension(:, :, :),    pointer  :: GridDissolvedMass3D                  => null()
        real,    dimension(:, :),       pointer  :: GridDissolvedMass2D                  => null()
        real,    dimension(:, :, :),    pointer  :: GridDissolvedConc3D                   => null()
        real,    dimension(:, :),       pointer  :: GridDissolvedConc2D                   => null()
        real,    dimension(:, :),       pointer  :: GridDissolvedMaxConc2D                => null()
        
        real,    dimension(:, :),       pointer  :: GridAirMass2D                   => null()
        real,    dimension(:, :, :),    pointer  :: GridAirConc3D                   => null()
        real,    dimension(:, :),       pointer  :: GridAirConc2D                   => null()
        real,    dimension(:, :),       pointer  :: GridAirMaxConc2D                => null()

        real,    dimension(:, :),       pointer  :: GridSurfaceFloatingMass2D            => null()

        real,    dimension(:, :, :),    pointer  :: GridDropletsMass3D                   => null()
        real,    dimension(:, :),       pointer  :: GridDropletsMass2D                   => null()
        real,    dimension(:, :, :),    pointer  :: GridDropletsConc3D                   => null()
        real,    dimension(:, :),       pointer  :: GridDropletsConc2D                   => null()
        real,    dimension(:, :),       pointer  :: GridDropletsMaxConc2D                => null()

        real,    dimension(:, :, :),    pointer  :: GridSuspendedParticulateMass3D        => null()
        real,    dimension(:, :),       pointer  :: GridSuspendedParticulateMass2D        => null()
        real,    dimension(:, :, :),    pointer  :: GridSuspendedParticulateConc3D        => null()
        real,    dimension(:, :),       pointer  :: GridSuspendedParticulateConc2D        => null()
        real,    dimension(:, :),       pointer  :: GridSuspendedParticulateMaxConc2D     => null()

        real,    dimension(:, :),       pointer  :: GridDepositedParticulateMass2D        => null()
        real,    dimension(:, :),       pointer  :: GridDepositedParticulateMassPerArea2D => null()


!        real,    dimension(:, :, :), pointer    :: OilGridDissolution3D                 => null()

        logical, dimension(:,:),     pointer    :: AreaFlag                             => null()
       
    end type T_HNS

    type     T_EulerModel

        character(len=StringLength)             :: Name                                 = null_str
        character(len=PathLength  )             :: Path                                 = null_str        

        !ObjBathymetry
        real,    dimension(:, : ), pointer      :: Bathymetry                           => null()
        real,    dimension(:    ), pointer      :: XX                                   => null()
        real,    dimension(:    ), pointer      :: YY                                   => null()

        real,    dimension(:, : ), pointer      :: XX_IE                                => null()
        real,    dimension(:, : ), pointer      :: YY_IE                                => null()
        real,    dimension(:, : ), pointer      :: DZX                                  => null()
        real,    dimension(:, : ), pointer      :: DZY                                  => null()

        real,    dimension(:, : ), pointer      :: GridCellArea                         => null()

        !ObjHorizontalMObj
        integer, pointer, dimension(:,:  )      :: BoundaryPoints2D                     => null()
        integer, pointer, dimension(:,:  )      :: WaterPoints2D                        => null()
  
        !ObjGeometry
        type (T_Size3D)                         :: Size
        type (T_Size3D)                         :: WorkSize
        real,    pointer, dimension(:,:  )      :: WaterColumn                          => null()
        real,    pointer, dimension(:,:,:)      :: SZZ                                  => null()
        real,    pointer, dimension(:,:,:)      :: DWZ                                  => null()
        real,    pointer, dimension(:,:,:)      :: ZCellCenter                          => null()
        real,    pointer, dimension(:,:,:)      :: DWZ_Xgrad                            => null()
        real,    pointer, dimension(:,:,:)      :: DWZ_Ygrad                            => null()
        real(8), pointer, dimension(:,:,:)      :: VolumeZ                              => null()
        integer, pointer, dimension(:,:  )      :: kFloor                               => null()

        !ObjMap
        integer, pointer, dimension(:,:,:)      :: WaterPoints3D                        => null()
        integer, pointer, dimension(:,:,:)      :: LandPoints3D                         => null()
        integer, pointer, dimension(:,:,:)      :: OpenPoints3D                         => null()
        integer, pointer, dimension(:,:,:)      :: ComputeFaces3D_U                     => null()
        integer, pointer, dimension(:,:,:)      :: ComputeFaces3D_V                     => null()

        !ObjTurbulence
        real,    pointer, dimension(:,:,:)      :: Lupward                              => null()
        real,    pointer, dimension(:,:,:)      :: Ldownward                            => null()
        real,    pointer, dimension(:,:,:)      :: MixingLengthX                        => null()
        real,    pointer, dimension(:,:,:)      :: MixingLengthY                        => null()
        real,    pointer, dimension(:,:,:)      :: DiffusionH                           => null()
        real,    pointer, dimension(:,:,:)      :: DiffusionV                           => null()        

        !ObjHydrodynamic
        real,    pointer, dimension(:,:,:)      :: Velocity_U                           => null()
        real,    pointer, dimension(:,:,:)      :: Velocity_V                           => null()
        real,    pointer, dimension(:,:,:)      :: Velocity_W                           => null()

        !ObjInterfaceWaterAir
        real,    pointer, dimension(:,:  )      :: WindX                                => null()
        real,    pointer, dimension(:,:  )      :: WindY                                => null()
        real,    pointer, dimension(:,:  )      :: SurfaceRadiation                     => null()
        real,    pointer, dimension(:,:  )      :: AtmPressure                          => null()
        real,    pointer, dimension(:,:  )      :: WaveHeight                           => null()
        real,    pointer, dimension(:,:  )      :: WavePeriod                           => null()
 

        !ObjInterfaceSedimentWater
        real,    pointer, dimension(:,:  )      :: ShearVelocity                        => null()
        real,    pointer, dimension(:,:  )      :: BottomStress                         => null()    
        real,    pointer, dimension(:,:  )      :: AirTemperature2D                     => null()


        !ObjAssimilation
        real,    pointer, dimension(:,:,:)      :: OverLayU                             => null()
        real,    pointer, dimension(:,:,:)      :: OverLayV                             => null()

        !ObjWaterProperties
        real,    pointer, dimension(:,:,:)      :: Density                              => null()
        real,    pointer, dimension(:,:,:)      :: SigmaDensity                         => null()
        real,    pointer, dimension(:,:,:)      :: Temperature3D                        => null()
        real,    pointer, dimension(:,:,:)      :: Salinity3D                           => null()
        real,    pointer, dimension(:,:,:)      :: FishFood3D                           => null()
        real,    pointer, dimension(:,:,:)      :: SPM3D                                => null()
        
        
        !ObjWaves
        real,    pointer, dimension(:,:  )      :: WaveHeight2D                         => null()
        real,    pointer, dimension(:,:  )      :: WavePeriod2D                         => null()
        real,    pointer, dimension(:,:  )      :: WaveDirection2D                      => null()
        real,    pointer, dimension(:,:  )      :: WaveLength2D                         => null()


        real   , dimension(:,:,:),    pointer   :: BeachingProbability                  => null()
        integer, dimension(:,:  ),    pointer   :: ShoreType                            => null()
        real   , dimension(:,:),      pointer   :: HorizontalBeachHoldingCapacity       => null()
        real   , dimension(:,:  ),    pointer   :: DistanceToCoast                      => null()
        real   , dimension(:,:  ),    pointer   :: BeachingLimit                        => null()
        real   , dimension(:,:  ),    pointer   :: RemovalRateCoef                      => null()
        real   , dimension(:,:  ),    pointer   :: OldSurfaceDepth                      => null()

        integer                                 :: ObjTimeSerie         = 0
        integer                                 :: ObjWaterProperties   = 0
        integer                                 :: ObjTime              = 0
        integer                                 :: ObjGridData          = 0
        integer                                 :: ObjHorizontalGrid    = 0
        integer                                 :: ObjHorizontalMap     = 0 
        integer                                 :: ObjGeometry          = 0 
        integer                                 :: ObjMap               = 0 
        integer                                 :: ObjHydrodynamic      = 0 
        integer                                 :: ObjTurbulence        = 0
        integer                                 :: ObjWaves             = 0
        integer                                 :: ObjBoxDif            = 0
        integer                                 :: ObjMonBox            = 0
        integer                                 :: ObjEulMonBox         = 0
        integer                                 :: ObjBeachingProbBox   = 0
        integer                                 :: ObjShoreTypeBox      = 0
        integer                                 :: ObjAssimilation      = 0
        integer                                 :: ObjAtmosphere        = 0
        


        type(T_ParticleGrid)                    :: Grid
        type(T_EulerianMonitor)                 :: EulerianMonitor

        type(T_Monitorization )                 :: Monitor
        
                          !i, j, k  
        real,    dimension(:, :, :   ), pointer :: RelativeMassFilter   => null() 
        real,    dimension(:, :, :   ), pointer :: MassFiltered         => null()

        type(T_OverLay        )                 :: Overlay
                                !ig
        type(T_Light), dimension(:),pointer     :: Light                => null()
        type(T_Lag2Euler      )                 :: Lag2Euler
                                          !p  
        type(T_PropStatistic  ), dimension(:),pointer :: PropStatistic  => null()
                                          !ig  
        type(T_OilSpreading   ), dimension(:),pointer :: OilSpreading   => null()
        
        real, dimension(:, :, :), pointer       :: MassDissolvedSumParticCell => null()
        real, dimension(:, :, :), pointer       :: MassSumParticCell          => null()

        type(T_HNS   ), dimension(:),pointer          :: HNS            => null()

    end type T_EulerModel
!----------------------------------------------------------------------------
!                                   Lagrangian types
!----------------------------------------------------------------------------

    !Internal states
    type T_State
        logical                                 :: ContCalc             = OFF
        logical                                 :: WQM                  = OFF
        logical                                 :: Larvae               = OFF
        logical                                 :: Wind                 = OFF
        logical                                 :: Sedimentation        = OFF
        logical                                 :: Deposition           = OFF
        logical                                 :: CriticalSlope        = OFF
        logical                                 :: VariableGeom         = OFF
        logical                                 :: ShearVel             = OFF
        logical                                 :: Oil                  = OFF
        logical                                 :: FC                   = OFF
        logical                                 :: Monitor              = OFF
        logical                                 :: MonitorPropMass      = OFF
        logical                                 :: EulerianMonitor      = OFF
        logical                                 :: MonitorLag           = OFF
        logical                                 :: Partition            = OFF
        logical                                 :: AssociateBeachProb   = OFF
        logical                                 :: CalcPartDistToCoast  = OFF
        logical                                 :: HaveBeachingProbBox  = OFF
        logical                                 :: HaveShoreTypeBox     = OFF
        logical                                 :: Statistics           = OFF
        logical                                 :: Age                  = OFF
        logical                                 :: ComputePlume         = OFF
        logical                                 :: PlumeShear           = OFF
        logical                                 :: FarFieldBuoyancy     = OFF
        logical                                 :: T90Variable          = OFF
        logical                                 :: T90Compute           = OFF
        logical                                 :: Filtration           = OFF
        logical                                 :: Boxdif               = OFF
        logical                                 :: OriginDefault        = OFF
        logical                                 :: T90                  = OFF
        logical                                 :: KillPartInsideBox    = OFF
        logical                                 :: StokesDrift          = OFF
        logical                                 :: AccidentProbability  = OFF
        logical                                 :: DistanceToCoast      = OFF
        logical                                 :: ComputeRisk          = OFF
        logical                                 :: Waves                = OFF
        logical                                 :: FloatingObject       = OFF 
        logical                                 :: HumanBody            = OFF
        logical                                 :: MeteoOcean           = OFF
        logical                                 :: Density              = OFF
        logical                                 :: Booms                = OFF
        logical                                 :: OutputTracerInfo     = OFF
        logical                                 :: OilSedimentation     = OFF        
        logical                                 :: Odour                = OFF
        logical                                 :: HNS                  = OFF
        logical                                 :: HNSSedimentation     = OFF
        logical                                 :: HNSEntrainment       = OFF
        logical                                 :: HNSSpreading         = OFF
        logical                                 :: D50                  = OFF
    end type T_State

    !IO
    type T_Files
        character(PathLength)                   :: ConstructData        = null_str
        character(PathLength)                   :: Initial              = null_str
        character(PathLength)                   :: Final                = null_str
        character(PathLength)                   :: TransientHDF         = null_str
        character(PathLength)                   :: BoxDataFile          = null_str
        character(PathLength)                   :: MonitorBox           = null_str
        character(PathLength)                   :: EulerianMonitorBox   = null_str
        character(PathLength)                   :: BeachingBoxFileName  = null_str
        character(PathLength)                   :: ShoreTypeBoxFileName = null_str    
        character(PathLength)                   :: Nomfich              = null_str
    end type T_Files


    type T_Online
        real,    dimension(:,:), pointer        :: StartDate            => null()
        real,    dimension(:),   pointer        :: X                    => null()
        real,    dimension(:),   pointer        :: Y                    => null()
        real,    dimension(:),   pointer        :: WindCoef             => null()
        integer                                 :: EmissionTemporal     = null_int
        real,    dimension(:),   pointer        :: Flow                 => null()
        real,    dimension(:),   pointer        :: Concentration        => null()
        real,    dimension(:),   pointer        :: T90                  => null()
    end type T_Online
    
    type T_IndividualBoom
        type (T_Lines),          pointer        :: Lines                => null()
        type (T_Polygon),        pointer        :: Polygon              => null()
        real                                    :: VelLimit             = null_real
        real                                    :: WaveLimit            = null_real
        logical                                 :: BoomHasBuffer        = .false.     !to create a buffer around boom
        real                                    :: BoomBufferDist       = null_real
        character(Len=StringLength)             :: Name                 = null_str
        character(Len=StringLength)             :: Description          = null_str
    end type T_IndividualBoom
    
    type T_Booms
        logical                                 :: ON                   = .false.
        integer                                 :: Number               = null_int
        type (T_IndividualBoom), dimension(:), pointer :: Individual    => null()
    end type T_Booms
    
    !Output
    type       T_OutPut
         type (T_Time), pointer, dimension(:)   :: OutTime              => null()
         type (T_Time), pointer, dimension(:)   :: RestartOutTime       => null()
         integer                                :: NextOutPut           = null_int
         integer                                :: NextRestartOutPut    = null_int
         integer                                :: TotalOutputs         = null_int
         integer                                :: OutPutConcType       = Maximum
         logical                                :: ConcMaxTracer        = .false.
         logical                                :: MassTracer           = .false. 
         logical                                :: OriginEnvelope       = .false.
         logical                                :: Write_               = .false.
         logical                                :: WriteRestartFile     = .false. 
         logical                                :: RestartOverwrite     = .false.
         logical                                :: DummyParticleStartDate = .false.
         logical                                :: ExportArrvlBeachTimes= .false. 
         character(len=PathLength)              :: RootPath
         logical                                :: OutputEnvelopeTimeSeries   = .false.
         logical                                :: NetCDF               = .false.
         integer                                :: ObjNETCDF            = null_int
         integer                                :: NetCDF_DimID         = null_int
         
    end type T_OutPut

  

  
    !Defines a generic Position
    type T_Position
        integer                                 :: I                        = null_int
        integer                                 :: J                        = null_int
        integer                                 :: K                        = null_int
        real                                    :: X                        = null_real
        real                                    :: Y                        = null_real
        real                                    :: CartX                    = null_real
        real                                    :: CartY                    = null_real
        real                                    :: CoordX                   = null_real
        real                                    :: CoordY                   = null_real
        real                                    :: Z                        = null_real
        real                                    :: CellI                    = null_real
        real                                    :: CellJ                    = null_real
        real                                    :: CellK                    = null_real
        integer                                 :: DepthDefinition          = null_int
        logical                                 :: MaintainDepth            = .false.       
        logical                                 :: MaintainRelative         = .false.
        real                                    :: Depth                    = null_real
        real                                    :: DepthWithWaterLevel      = null_real       
        !Each particle has the eulerian grid index 
        integer                                 :: ModelID                  = null_int
        logical                                 :: Surface                  = .false. 
        logical                                 :: SurfaceEmission          = .false.
        !spreading (radians)
        real                                    :: SpreadingAngle           = null_real
    end type T_Position

    !Defines the movement of a particle
    type T_Movement

        !Horizontal
        integer                                 :: MovType                  = NotRandom_
        real                                    :: VarVelHX                 = 0.2
        real                                    :: VarVelH                  = 0.0
        real                                    :: DiffusionCoefH           = 0.0
        
        logical                                 :: TurbGradK                = .false.

        !Vertical
        integer                                 :: StandardDeviationType    = VerticalTurbConstant
        real                                    :: VarVelVX                 = 0.0
        real                                    :: VarVelV                  = 0.0
        real                                    :: DiffusionCoefV           = 0.0        
        
        logical                                 :: DiffusionCoefHON         = .false. 
        logical                                 :: DiffusionCoefVON         = .false.         

        real                                    :: WindTransferCoef         = 0.03
        integer                                 :: WindDriftCorrection      = NoCorrection_
        real                                    :: WindDriftAngle           = 0.
        logical                                 :: WindOriginON             = .false.
        real                                    :: WindX                    = null_real
        real                                    :: WindY                    = null_real

       
        logical                                 :: SlipCondition            = .true.         
        
        !Sediment stuff
        integer                                 :: SedimentationType        = null_int
        real                                    :: SedVel                   = null_real
        real                                    :: SedVelUncertainty        = null_real
        real                                    :: MinSedVel                = null_real
        real                                    :: D50                      = null_real
        real                                    :: D50sdv                   = null_real
        real                                    :: Density                  = null_real
        logical                                 :: Sediment                 =.FALSE.
        real                                    :: D50min                   = null_real
        real                                    :: D50max                   = null_real        
        integer                                 :: nDiameterClasses         = null_int
        !diameter acumulated percentage
        real,    dimension(:,:), pointer        :: DiameterClasses          => null() 
        

        real                                    :: ThicknessMeters          = null_real

        !movement options
        logical                                 :: Float                    = OFF !Floating particle, does not mix with water
        logical                                 :: Advection                = ON
        logical                                 :: AdvectionZ               = ON
        logical                                 :: KillLandParticles        = OFF
        
        !Volumes / Areas
        real                                    :: TVOL200                  = null_real  !Time to double volume.
        integer                                 :: TVolType                 = Double_
        logical                                 :: SPLIT_PART               = OFF
        real                                    :: VOLFAC                   = null_real  
                                                  !VOLFAC * (Inicial Particle Volume) -> Particle die.

        !Plume definition
        integer                                 :: DensityMethod            = null_int
        logical                                 :: CorrecPress              = OFF
        !real                                    :: ParticleSigmaDensity     = null_real
        real                                    :: CoefInitialMixing        = null_real
        real                                    :: InitialVelocityU         = null_real
        real                                    :: InitialVelocityV         = null_real
        real                                    :: InitialVelocityW         = null_real
        real                                    :: JetDT                    = null_real
        real                                    :: JetSalinity              = null_real
        real                                    :: JetTemperature           = null_real
        real                                    :: PlumeDilution            = null_real
        type (T_Time)                           :: NextJetActualization
        character(PathLength)                   :: JetDataFile              = null_str
        character(PathLength)                   :: JetFileOut               = null_str
        integer                                 :: JetUnit                  = null_int
        integer                                 :: ObjJet                   = 0

        !Stokes Drift
        integer                                 :: StokesDriftMethod        = LonguetHigginsGeneric
!        real                                    :: R_ice                    = null_real
        logical                                 :: WaveLengthFromPeriod     = .false. 

    end type T_Movement

    !Defines the particle Geometry
    type T_ParticleGeometry
        real                                    :: VolumeOil                = null_real
        real                                    :: Volume                   = null_real
        real                                    :: InitialVolume            = null_real
        real                                    :: VolVar                   = null_real
        real                                    :: Thickness                = null_real
        real                                    :: VoronoiArea              = null_real
        real                                    :: DropletsDiameter         = null_real
        real                                    :: Area                     = null_real
    end type T_ParticleGeometry

    !Defines the parameters necessary to compute the fluxes associated to a 
    !partition coefficient
    type T_Partition
        logical                                 :: ON                       = OFF
        real                                    :: Coefficient              = null_real 
        real                                    :: TransferRate             = null_real 
        !By default is assumed that the particle property is particulated and is 
        !transfering mass to a dissolvde property that in the environment was an
        !aproximated constant value
        real                                    :: CoupleProp               = null_real 
    end type T_Partition

    type T_Larvae
        logical                                 :: Vertical_Migration       = OFF
        logical                                 :: Compute_Larvae_Velocity  = ON 
        logical                                 :: Light_Relation           = ON
        real                                    :: Larvae_Max_Depth         = null_real
        real                                    :: Larvae_Min_Depth         = null_real
        real                                    :: Larvae_Velocity          = null_real
        real                                    :: Migration_Time           = null_real
        real                                    :: Radiation_Limit          = null_real
    end type T_Larvae

    !One Property
    type  T_Property
        integer                                 :: ID                       = null_int
        character(StringLength)                 :: Name                     = null_str
        character(StringLength)                 :: units                    = null_str
        real                                    :: concentration            = null_real 
        real                                    :: min_concentration        = 0.0       !Used to cut values in GridConcentration
        real                                    :: AmbientConcentration     = null_real
        logical                                 :: HaveAmbientConcentration = OFF
        logical                                 :: T90Variable              = OFF
        logical                                 :: T90Compute               = OFF
        integer                                 :: T90Var_Method            = null_int
        real                                    :: T90                      = 7200.     !Coliform Bacteria decay time
        type(T_Larvae)                          :: Larvae
        character(StringLength)                 :: T90Name                  = null_str
        logical                                 :: T90ON                    = OFF
        character(PathLength)                   :: T90File                  = null_str
        integer                                 :: T90Column                = null_int
        integer                                 :: TimeSerieT90             = 0
        type(T_Partition)                       :: SedimentPartition
        type(T_Partition)                       :: WaterPartition
        logical                                 :: ConcVariable             = .false.
        integer                                 :: ConcColumn               = null_int
        logical                                 :: NoWQM                    = .false.
        type (T_Property), pointer              :: Next                     => null()
        real                                    :: ExtinctionParameter      = null_real
        logical                                 :: Filtration               = OFF
        logical                                 :: WritesTimeSerie          = OFF
        logical                                 :: WritesPropHDF            = OFF
        real                                    :: MinValue                 = null_real
        real                                    :: MaxValue                 = null_real
        logical                                 :: MinON                    = .false.
        logical                                 :: MaxON                    = .false.
        character(PathLength)                   :: DischargeFile            = null_str
        integer                                 :: TimeSerieInput           = 0
        logical                                 :: EqualToAmbient           = OFF
        real                                    :: Risk                     = null_real  
        logical                                 :: MeteoOceanFiles          = OFF      
        logical                                 :: HasOdour                 = OFF
        real                                    :: OdourConcThreshold       = null_real        
        logical                                 :: Interpolate              = .false.
    end type T_Property


    !Particle List
    type T_Partic
        integer                                 :: ID
        type (T_Position)                       :: Position
        type (T_ParticleGeometry)               :: Geometry
        real, dimension(:), pointer             :: Concentration            => null()
        real, dimension(:), pointer             :: ConcentrationInterpol    => null()
        real, dimension(:), pointer             :: AmbientConc              => null()
        real, dimension(:), pointer             :: Mass                     => null()
        real                                    :: TpercursoH               = -null_real
        real                                    :: TpercursoZ               = -null_real
        real                                    :: UD_old                   = null_real
        real                                    :: VD_old                   = null_real
        real                                    :: WD_old                   = null_real
        logical                                 :: KillPartic               = OFF
        logical                                 :: Freezed                  = OFF
        logical                                 :: Beached                  = OFF
        logical                                 :: Deposited                = OFF        
        logical                                 :: AtTheBottom              = OFF        
        real                                    :: HumanBodySinkingVel      = null_real
        real                                    :: TauErosion               = null_real
        real                                    :: TauErosionMix            = null_real        
        real                                    :: TauDeposition            = null_real        
        real                                    :: ErosionRateProbability   = null_real
        real                                    :: U, V, W                  = null_real
        real                                    :: RelU, RelV               = null_real
        real                                    :: SD                       = null_real
        real                                    :: SigmaDensity             = null_real
        type (T_Partic), pointer                :: Next                     => null()
        type (T_Partic), pointer                :: Prev                     => null()
        real                                    :: Age                      = 0.
        real                                    :: Radiation                = 0.
        real                                    :: ShortWaveExt             = null_real
        real                                    :: T90                      = null_real
        real                                    :: OilMass                  = null_real
        real                                    :: OilDissolvedMass         = null_real
        real                                    :: OilDensity               = null_real
        real                                    :: OilViscosity             = null_real
        real                                    :: OilViscCin               = null_real
        real                                    :: OWInterfacialTension     = null_real
        real                                    :: FMEvaporated             = null_real
        real                                    :: VWaterContent            = null_real
        real                                    :: FMDispersed              = null_real
        real                                    :: AccidentProbability      = null_real
        logical                                 :: ComputeAccidentProb      = .false.
        type (T_Time)                           :: EmissionTime
        real                                    :: WaveHeight               = FillValueReal
        real                                    :: WavePeriod               = FillValueReal
        real                                    :: WaveDirection            = FillValueReal    
        real                                    :: WaveLength               = FillValueReal    
        real                                    :: WindX                    = FillValueReal
        real                                    :: WindY                    = FillValueReal
        real                                    :: CurrentX                 = FillValueReal
        real                                    :: CurrentY                 = FillValueReal
        real                                    :: CurrentZ                 = FillValueReal
        real                                    :: D50vel                   = FillValueReal
        real                                    :: D50                      = FillValueReal
        real                                    :: BottomStress             = FillValueReal
        integer                                 :: SolutionWH               = FillValueInt
        integer                                 :: SolutionWP               = FillValueInt
        integer                                 :: SolutionWD               = FillValueInt
        integer                                 :: SolutionWL               = FillValueInt
        integer                                 :: SolutionWX               = FillValueInt
        integer                                 :: SolutionWY               = FillValueInt
        integer                                 :: SolutionCX               = FillValueInt
        integer                                 :: SolutionCY               = FillValueInt
        integer                                 :: SolutionCZ               = FillValueInt        
        integer                                 :: SolutionS                = FillValueInt
        integer                                 :: SolutionT                = FillValueInt        
        integer                                 :: BeachingOilType          = 2
        integer                                 :: ParticleState            = FillValueInt
        integer                                 :: HNSParticleState         = null_int
        real                                    :: HNSDensity               = null_real
        real                                    :: HNSMass                  = null_real
        real                                    :: HNSInitialMass           = null_real
        real                                    :: HNSSpreadingDiffVel      = null_real
        real                                    :: HNSSpreadingDiffCoef      = null_real
        real                                    :: MDegraded                = null_real
        real                                    :: DistanceToCoast          = null_real
        real                                    :: MinDistanceToCoast       = - null_real
    end type T_Partic

    !Particle deposition
    type  T_Deposition
        real                                    :: BottomDistance           = null_real
        real                                    :: TauErosion               = null_real
        real                                    :: ErosionRate              = null_real
        real                                    :: TauDeposition            = null_real
        real                                    :: TdecayMix                = null_real
        logical                                 :: BottomEmission           = OFF
        real                                    :: TauUncertainty           = null_real
        logical                                 :: MixSedON                 = .false.
        logical                                 :: CriticalSlopeON          = .false.
        real                                    :: CriticalSlope            = null_real
        real                                    :: CriticalThickness        = null_real        
        real                                    :: CriticalSlopeVel         = null_real        
        real                                    :: CriticalSlopeVelUncertainty = null_real
    end type T_Deposition

    type T_FloatingObject
        real                                    :: AirDragCoef            = null_real
        real                                    :: WaterDragCoef          = null_real
        real                                    :: ImmersionRatio         = null_real
    end type T_FloatingObject    
    
    type T_HumanBody
        logical                                 :: Drowned                = OFF
        logical                                 :: AtTheBottom            = OFF
    end type T_HumanBody    

    !Origin list
    type T_Origin
        character(StringLength)                 :: Name                     = null_str
        integer                                 :: ID
        integer                                 :: GroupID                  = 1
        logical                                 :: Old                      = OFF
        type (T_State)                          :: State
        integer                                 :: EmissionSpatial          = null_int
        integer                                 :: EmissionTemporal         = null_int
        logical                                 :: EmissionON               = .false.
        real                                    :: DT_Emit                  = null_real
        real                                    :: Flow                     = null_real
        integer                                 :: NbrParticlesIteration    = 1
        integer                                 :: AccidentMethod           = null_int
        type (T_Time)                           :: AccidentTime
        logical                                 :: AccidentFinished         = .false.
        real                                    :: PointVolume              = null_real
        logical                                 :: FlowVariable             = .false.
        integer                                 :: FlowColumn               = null_int
        real                                    :: FlowScaleFactor          = null_real  
        character(PathLength)                   :: DischargeFile            = null_str
        integer                                 :: TimeSerieInputFlow       = 0
        type (T_Time)                           :: InstantEmission
        type (T_Time)                           :: StartEmission
        type (T_Time)                           :: StopEmission
        type (T_Time)                           :: NextEmission
        integer                                 :: INCRP                    = 1
        integer                                 :: BoxNumber                = 1
        real                                    :: ParticleBoxVolume        = null_real
        type (T_Movement)                       :: Movement
        type (T_Deposition)                     :: Deposition
        type (T_Position)                       :: Position
        real, dimension(:), pointer             :: x                        => null()
        real, dimension(:), pointer             :: y                        => null()
        real, dimension(:), pointer             :: z                        => null()
        integer                                 :: nParticle                = null_int
        integer                                 :: nParticleEmit            = null_int        
        integer                                 :: NbrSubmerged             = 0
        integer                                 :: nProperties              = null_int
        integer                                 :: nPropT90                 = null_int
        integer                                 :: NextParticID             = null_int
        real                                    :: Photoinhibition          = null_real
        real                                    :: ShortWavePercentage      = null_real
        integer                                 :: AreaMethod               = null_int
        logical                                 :: FayTotalArea             = .false.  
        real                                    :: AreaTotal                = null_real
        real                                    :: ParticleArea             = null_real
        real                                    :: VolumeTotal              = null_real
        real                                    :: VolumeTotalIni           = null_real        
        real                                    :: VolumeOilTotal           = null_real
        real                                    :: VolTotOilBeached         = null_real
        real                                    :: MaxVolTotOilBeached      = 0.
        real                                    :: VolTotBeached            = null_real
        logical                                 :: MovingOrigin             = .false.
        character(StringLength)                 :: MovingOriginUnits        = null_str
        integer                                 :: MovingOriginColumnX      = null_int
        integer                                 :: MovingOriginColumnY      = null_int
        character(PathLength)                   :: MovingOriginFile         = null_str
        logical                                 :: MovingOriginCloudEmission = .false.
        character(PathLength)                   :: WQM_DataFile             = null_str
        integer                                 :: ObjTimeSerie             = 0
        integer                                 :: WaterQualityID           = 0
        type (T_Time)                           :: NextWQMCompute
        real                                    :: DTWQM                    = null_real
        integer                                 :: ObjOil                   = 0
        integer                                 :: ObjHNS                   = 0
        logical                                 :: ComputeAge               = .false.
        type (T_Property), pointer              :: FirstProperty            => null()
        type (T_Partic), pointer                :: FirstPartic              => null()
        type (T_Origin), pointer                :: Next                     => null()
        logical                                 :: Beaching                 = OFF
        logical                                 :: CoastlineBeaching        = OFF
        logical                                 :: AreaBeaching             = OFF
        logical                                 :: Filtration               = OFF
        logical                                 :: Default                  = OFF
        logical                                 :: OnlyOnceEmit             = OFF
        logical                                 :: KillPartInsideBox        = OFF
        logical                                 :: EstimateMinVol           = OFF
        integer                                 :: MaxPart                  = null_int
        real                                    :: MaxVol                   = null_real
        real                                    :: AgeLimit                 = null_real
        logical                                 :: AgeFreezeBeach           = .false.
        real                                    :: AccidentProbDefault      = FillValueReal
        logical                                 :: AreaVTS                  = .true.
        type (T_FloatingObject)                 :: FloatingObject        
        type (T_HumanBody)                      :: HumanBody        
        logical                                 :: StartWithTriang          = .false.
        character(PathLength)                   :: OutputTracerInfoFileName = null_str 
        integer                                 :: troUnit                  = null_int
        integer                                 :: NbrParticlesBeached      = 0
        real                                    :: Fdisp                    = 0
        real                                    :: Fblowout                 = 1
        real                                    :: CDispOilOff              = null_real
        real                                    :: DropletsD50              = null_real
        integer                                 :: MethodBWDropletsDiameter = null_int
        integer                                 :: MethodFloatVel           = null_int
        logical                                 :: BeachRemoval             = OFF
        integer                                 :: HNSInitialState          = null_int
        real                                    :: HNSMass                  = null_real
        real                                    :: HNSTotalMass             = null_real
        real                                    :: HNSFractionEvaporated    = null_real
        real                                    :: HNSFractionVolatilized   = null_real
        real                                    :: HNSFractionDissolved     = null_real
        real                                    :: HNSFractionEntrained     = null_real
        real                                    :: HNSFractionSedimented    = null_real
        real                                    :: HNSFractionDeposited     = null_real
        real                                    :: HNSFractionAtSurface     = null_real
        real                                    :: HNSFractionBeached       = null_real
        real                                    :: HNSFractionDegraded      = null_real
        real                                    :: MBeached                 = null_real
        real                                    :: MEvaporated              = null_real
        real                                    :: MVolatilized             = null_real
        real                                    :: MEntrained               = null_real
        real                                    :: MDissolved               = null_real
        real                                    :: MSedimented              = null_real
        real                                    :: MDeposited               = null_real
        real                                    :: MSurface                 = null_real
        real                                    :: MDegraded                = null_real
        character(PathLength)                   :: OutputEnvelopeTimeSerieFileName = null_str 
        integer                                 :: eroUnit                  = null_int
        real                                    :: SectionDepthMax          = null_real
        real                                    :: SectionEndX              = null_real
        real                                    :: SectionEndY              = null_real        
        logical                                 :: SectionEmission          = .false.
        type (T_Polygon), pointer               :: PolyEmission             => null()  
        real                                    :: PolyLeft                 = null_real
        real                                    :: PolyRight                = null_real
        real                                    :: PolyBottom               = null_real
        real                                    :: PolyTop                  = null_real
    end type T_Origin

    type T_OptionsStat

        type(T_PropertyID)                      :: ID
        integer                                 :: PropOrder                = null_int
        
        character(len=PathLength)               :: File                     = null_str
        integer                                 :: nClassesLag              = null_int
        real, dimension(:,:    ), pointer       :: ClassesLag               => null()
        logical                                 :: Lag                      = .false.
        
    end type T_OptionsStat

    type T_Statistic
        integer                                     :: PropNumber           = null_int
        type(T_OptionsStat), dimension(:), pointer  :: OptionsStat          => null()
        logical            , dimension(:), pointer  :: ON                   => null()
    end type T_Statistic

    type T_Field
        character(Len=PathLength)                           :: FileName
        integer                                             :: ID           = 0
        character(Len=PathLength), dimension(:), pointer    :: FileNameList
        integer                                             :: NFilesList        
    end type T_Field

    type T_MetOceanProp
        type (T_PropertyID)                         :: ID
        type(T_Field), dimension(:), pointer        :: Field                => null()
        integer                                     :: FieldNumber          = null_int
        integer                                     :: MaskDim              = null_int
        integer                                     :: LagPropI             = null_int
        logical                                     :: EqualToAmbient       = .false.
        logical                                     :: FileListMode         = .false.  
    end type T_MetOceanProp

    type T_MeteoOcean
        integer                                     :: PropNumber           = null_int
        type(T_MetOceanProp), dimension(:), pointer :: Prop                  => null()
    end type T_MeteoOcean

    !ExternalVar
    type T_ExternalVar

        !ObjOil
        !real,    pointer, dimension(:,:  )      :: SpreadingVelocityX
        !real,    pointer, dimension(:,:  )      :: SpreadingVelocityY
        real                                    :: DiffVelocity             = null_real
        real                                    :: OilDiffCoef              = null_real
        real                                    :: VWaterContent            = null_real
        real                                    :: MWaterContent            = null_real
        real                                    :: AreaTotal                = null_real
        real                                    :: OilDensity               = null_real
        real                                    :: MassINI                  = null_real
        real                                    :: OilViscosity             = null_real
        real                                    :: FMDispersed              = null_real
        real                                    :: FMEvaporated             = null_real
        real                                    :: MDispersed               = null_real
        integer                                 :: ThicknessGradient        = null_int
        integer                                 :: Fay                      = null_int
        integer                                 :: SpreadingMethod          = null_int
        real                                    :: MDissolvedDT             = null_real

        !Time - by default is used the time object of the model with higher priority 
        integer                                 :: ObjTime                  = 0
        type(T_Time)                            :: Now
        type(T_Time     )                       :: BeginTime
        type(T_Time     )                       :: EndTime
        type(T_Time     )                       :: LastConcCompute

        real                                    :: RunPeriod                = null_real
        
        logical                                 :: Backtracking             = .false.           

    end type T_ExternalVar

    type T_MonitorLag
        integer                                 :: NumberOfPoly                = null_int
        type (T_Polygon), dimension(:), pointer :: Poly                        => null()        
        integer, dimension(:,:), pointer        :: NumTracersOrigin            => null() 
        integer, dimension(:  ), pointer        :: ObjTimeSerie                => null()
        real                                    :: DT                          = null_real 
        type (T_Time)                           :: NextOutPut
    end type T_MonitorLag


    type T_Lagrangian
        integer                                 :: InstanceID
        type (T_State)                          :: State
        type (T_Files)                          :: Files
        type (T_OutPut)                         :: Output
        integer                                 :: nOrigins                    = null_int
        integer                                 :: nOldOrigins                 = null_int
        integer                                 :: nGroups                     = null_int
        logical                                 :: RunOnline                   = .false.
        logical                                 :: IgnoreON                    = .false.
        integer, dimension(:    ),  pointer     :: GroupIDs                    => null()
        integer, dimension(:    ),  pointer     :: nOriginsGroup               => null()

        character(StringLength)                 :: MonitorProperty             = null_str
        integer                                 :: MonitorPropertyID           = null_int
        integer                                 :: MonitorMassFractionType     = Arithmetic
        real                                    :: MonitorBox_TracerMinConc    = null_real
        real                                    :: MonitorContaminationDepth   = null_real

        type(T_MonitorLag     )                 :: MonitorLag                

        real                                    :: DT_Partic                   = null_real
        integer                                 :: Vert_Steps                  = null_int
        real                                    :: DefaultBeachingLimit        = null_real 
        integer                                 :: BeachingLimitSpatial        = null_int
        real                                    :: DefaultBeachingProbability  = null_real
        integer                                 :: DefaultShoreType            = null_int
        real                                    :: DefaultRemovalRateCoef      = null_real
        integer                                 :: RemovalRateCoefSpatial      = null_int
        real                                    :: NearCoastDistance           = null_real
        
        logical                                 :: LitterON                    = .false. 
        logical                                 :: OutputGridON                = .false.         

        type(T_Statistic)                       :: Statistic
        type(T_MeteoOcean)                      :: MeteoOcean
        

        type(T_Time)                            :: NextCompute
        type(T_Time)                            :: Now

        type (T_Time)                           :: NextFiltration

        type(T_Origin     ), pointer            :: FirstOrigin          => null()
        type(T_Origin     ), pointer            :: FirstOldOrigin       => null()
        type(T_Origin     ), pointer            :: OriginDefault        => null()

        type(T_ExternalVar)                     :: ExternalVar

        type(T_EulerModel ), pointer, dimension(:) :: EulerModel        => null()
        integer                                 :: EulerModelNumber     = null_int
        
        type (T_Polygon), pointer               :: GridsBounds          => null()        
        type (T_Polygon), pointer               :: CoastLine            => null()
        character(StringLength)                 :: CoastLineFile        = null_str
        logical                                 :: CoastLineON          = .false.
        logical                                 :: RedefineMapping      = .true.
        logical                                 :: BeachAreaON          = .false. 
        type (T_Polygon), pointer               :: BeachArea            => null()
        character(StringLength)                 :: BeachAreaFile        = null_str
        

        type (T_Polygon), pointer               :: ThinWalls            => null()
        character(StringLength)                 :: ThinWallsFile        = null_str
        logical                                 :: ThinWallsON          = .false.

        logical                                 :: NewGridLocation      = .false.
        
        type (T_Booms)                          :: Booms

!#ifdef _CGI_
        type(T_Online)                          :: Online    
!#endif      

        logical                                 :: WritesTimeSerie      = .false.
        logical                                 :: Overlay              = .false.
        logical                                 :: FirstIteration       = .true.
        logical                                 :: ConstructLag         = .true. 
        
        real, dimension(:), pointer             :: AngleList            => null()
        real, dimension(:), pointer             :: DistanceByDirection  => null()
        type (T_PointF),    pointer             :: Point
        
        logical                                 :: AveragePositionON    = .false. 
        real                                    :: CoefRadius           = null_real
        logical                                 :: StopWithNoPart       = .false.

        integer, dimension(:), pointer          :: ObjHDF5              => null()
        character(len=PathLength),                                                      &
                        dimension(:), pointer   :: HDF5FileName         => null()

        integer                                 :: ObjEnterData         = 0
        integer                                 :: ObjEnterDataClone    = 0
        integer                                 :: ObjEnterDataOriginal = 0
        integer                                 :: ObjLitter            = 0
        integer                                 :: ObjOutputGrid        = 0        
        
        logical                                 :: VoronoiVolume        = .false. 

        type(T_Lagrangian     ), pointer        :: Next                 => null()
    end type T_Lagrangian

    !Global Module Variables
    type (T_Lagrangian), pointer                :: FirstLagrangian      => null()
    type (T_Lagrangian), pointer                :: Me                   => null()


    contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR 

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


  !--------------------------------------------------------------------------

    subroutine AllocateLagrangianGlobal(LagrangianID, STAT)


        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        integer, optional, intent(OUT)              :: STAT


        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_


        STAT_ = UNKNOWN_

        !Assures nullification of the global variable
        if (.not. ModuleIsRegistered(mLagrangian_)) then
            nullify (FirstLagrangian)
            call RegisterModule (mLagrangian_) 
        endif

        call Ready(LagrangianID, ready_)

        if (ready_ .EQ. OFF_ERR_) then

            !Allocates a new Instance
            call AllocateInstance
            nullify (Me%FirstOrigin)
            
            !Returns ID
            LagrangianID    = Me%InstanceID
            STAT_           = SUCCESS_

        else

            stop 'AllocateLagrangianGlobal - ModuleLagrangianGlobal - ERR10' 

        endif


        if (present(STAT)) STAT = STAT_       
        
    end subroutine AllocateLagrangianGlobal
             
    
    !--------------------------------------------------------------------------

    subroutine ConstructLagrangianGlobal(LagrangianID,                                  &
                                   Nmodels,                                             &
                                   ModelNames,                                          &
                                   ModelPaths,                                          &   
                                   FileNomfich,                                         &
                                   LagInstance,                                         &
                                   STAT)


        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        integer                                     :: Nmodels
        character(len=*), dimension(:),   pointer   :: ModelNames
        character(len=*), dimension(:),   pointer   :: ModelPaths
        character(len=*)                            :: FileNomfich        
        integer,          dimension(:,:), pointer   :: LagInstance
        integer, optional, intent(OUT)              :: STAT


        !Local-----------------------------------------------------------------
        integer, dimension(TotalLagInst_)           :: TimeID,  GridDataID,             &
                                                       HorizontalGridID,                &
                                                       HorizontalMapID,                 &
                                                       GeometryID,                      &
                                                       MapID,                           &
                                                       AssimilationID,                  &
                                                       HydrodynamicID,                  &
                                                       TurbulenceID,                    &
                                                       WavesID,                         &
                                                       WaterPropertiesID

        type (T_EulerModel), pointer                :: EulerModel
        integer                                     :: STAT_, ready_, em, NmodelsFinal
        integer                                     :: STAT_CALL
        integer, dimension(:), pointer              :: IndexMatch

        !Begin--------------------------------------------------------------------------
        
        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_)

        if (ready_ .EQ. IDLE_ERR_) then
        
em0:        do em =1, Nmodels            
                TimeID           (em) = LagInstance(1,em)
                GridDataID       (em) = LagInstance(2,em)              
                HorizontalGridID (em) = LagInstance(3,em)
                HorizontalMapID  (em) = LagInstance(4,em)
                GeometryID       (em) = LagInstance(5,em)
                MapID            (em) = LagInstance(6,em)
                AssimilationID   (em) = LagInstance(7,em)
                HydrodynamicID   (em) = LagInstance(8,em)  
                TurbulenceID     (em) = LagInstance(9,em) 
                WavesID          (em) = LagInstance(10,em)
                WaterPropertiesID(em) = LagInstance(11,em)
                
            enddo em0
            
            Me%Files%Nomfich  = FileNomfich            

            ! Construct the variable common to all module  
            call ConstructGlobalVariables

            !Construct enter data 
            call ConstructEnterData(Me%ObjEnterData, Me%Files%ConstructData, &
                    ErrorMessage = "ConstructLagrangianGlobal - ModuleLagrangianGlobal", STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR10'

            allocate(IndexMatch(1:Nmodels))

            call ConstructEulerModelsList(ModelNames, IndexMatch, Nmodels, NmodelsFinal)

            Me%EulerModelNumber = NmodelsFinal
            allocate(Me%EulerModel(Me%EulerModelNumber))

em1:        do em =1, Me%EulerModelNumber

                Me%EulerModel(em)%Name              = ModelNames(IndexMatch(em))
                Me%EulerModel(em)%Path              = ModelPaths(IndexMatch(em))

            !External Modules
                Me%EulerModel(em)%ObjTime           = AssociateInstance (mTIME_,           TimeID            (IndexMatch(em)))
                Me%EulerModel(em)%ObjGridData       = AssociateInstance (mGRIDDATA_,       GridDataID        (IndexMatch(em)))
                Me%EulerModel(em)%ObjHorizontalMap  = AssociateInstance (mHORIZONTALMAP_,  HorizontalMapID   (IndexMatch(em)))
                Me%EulerModel(em)%ObjHorizontalGrid = AssociateInstance (mHORIZONTALGRID_, HorizontalGridID  (IndexMatch(em)))
                Me%EulerModel(em)%ObjGeometry       = AssociateInstance (mGEOMETRY_,       GeometryID        (IndexMatch(em)))
                Me%EulerModel(em)%ObjMap            = AssociateInstance (mMAP_,            MapID             (IndexMatch(em)))
                Me%EulerModel(em)%ObjHydrodynamic   = AssociateInstance (mHYDRODYNAMIC_,   HydrodynamicID    (IndexMatch(em)))
                Me%EulerModel(em)%ObjTurbulence     = AssociateInstance (mTURBULENCE_,     TurbulenceID      (IndexMatch(em)))
                Me%EulerModel(em)%ObjWaterProperties= AssociateInstance (mWATERPROPERTIES_,WaterPropertiesID (IndexMatch(em)))

                if(WavesID(IndexMatch(em)) /= 0)then
                    Me%EulerModel(em)%ObjWaves      = AssociateInstance (mWAVES_,          WavesID(IndexMatch(em)))
                end if

                if (em ==1) then
                    !External Modules ObjTime for the higher priority model
                    Me%ExternalVar%ObjTime          = Me%EulerModel(em)%ObjTime

                    !Gets Time
                    call GetComputeTimeLimits(Me%ExternalVar%ObjTime,                   &
                                              BeginTime = Me%ExternalVar%BeginTime,     &
                                              EndTime   = Me%ExternalVar%EndTime,       &
                                              STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR20'

                    ! Actualized the time
                    call GetComputeCurrentTime(Me%ExternalVar%ObjTime,                  &
                                               Me%ExternalVar%Now, STAT = STAT_CALL)                    
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR30'
                    
                    ! Check if the simulation goes backward in time or forward in time (default mode)
                    call GetBackTracking(Me%ExternalVar%ObjTime,                        &
                                         Me%ExternalVar%BackTracking, STAT = STAT_CALL)                    
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR40'


                    call ConstructOuptusFilesNames                    
                
                endif

                !Gets Size
                call GetGeometrySize(Me%EulerModel(em)%ObjGeometry,                     &
                                     Size     = Me%EulerModel(em)%Size,                 &
                                     WorkSize = Me%EulerModel(em)%WorkSize,             &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR50'

            enddo em1

            !Gets Pointer to External modules
            call ReadLockExternalVar()

em4:        do em =1, Me%EulerModelNumber
                ! Constructs the Particle Grid
                EulerModel => Me%EulerModel(em)
                call ConstructParticleGrid(EulerModel)
                nullify(EulerModel)
            enddo em4 
            
            !Constructs the origin list 
            call ConstructOrigins
 
            if (Me%Overlay) then

em2:            do em =1, Me%EulerModelNumber

                    if (AssimilationID(IndexMatch(em)) == 0) then

                        !Associated the Assimilation
                        call StartAssimilation (Me%EulerModel(em)%ObjAssimilation,                       &
                                                Me%EulerModel(em)%ObjTime,                               &
                                                Me%EulerModel(em)%ObjGridData,                           &
                                                Me%EulerModel(em)%ObjHorizontalGrid,                     &
                                                Me%EulerModel(em)%ObjHorizontalMap,                      &
                                                Me%EulerModel(em)%ObjMap,                                &
                                                Me%EulerModel(em)%ObjGeometry,                           &
                                                STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR60'
                    
                        AssimilationID = Me%EulerModel(em)%ObjAssimilation

                    else
                    
                        Me%EulerModel(em)%ObjAssimilation = AssociateInstance (mASSIMILATION_, AssimilationID(IndexMatch(em)))

                    endif

                enddo em2
            endif

            !Verifies the Origin Lists of all Origins
            call VerifyOriginProperties   
            
            !Verifies the Oil-Beaching Probabilities
            if (Me%State%AssociateBeachProb) then
                call AllocateBeaching
                call VerifyBeachingProbabilities
                call VerifyShoreTypes
            end if
            
            if (Me%State%DistanceToCoast) then
                call ComputeDistanceToCoast
            endif
 

            !Reads previuos data
            if (Me%State%ContCalc) then
                call ReadFinalPartic 
            end if
            
            call ReadLockEulerianDensity()
            
            !Starts the Light Extinction
            if (Me%State%WQM .or. Me%State%T90Compute) then
                call ConstructParticLightExtinction
            endif

            !Constructs the Time Series
            if (Me%WritesTimeSerie) then
                call ConstructTimeSeries  
            endif

!            ! Opens Output Tracer Info File, if Needed
!            if (Me%State%OutputTracerInfo) then
!                call ConstructOutputTracerTimeSeries
!            end if

            call ReadParticStatisticOptions   

            call ReadMeteoOceanFields   
            
            call ReadBooms
            
            !Kills EnterData
            call KillEnterData(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR70'
            
            !Redefine coast line
            if(Me%RedefineMapping)then
                call RedefinedCoastLine
            endif
            
            !Merges Old with New Origins
            call MergeOldWithNewOrigins

            !Moves Moving origins
            call MoveOrigin               

            if (Me%State%HNS) then
                call AllocateHNS
                call HNSOptions
                call HNSInitialValues
                call ConstructHNSTimeSerie
            endif

            !Constructs Emission for every origin
            call ConstructEmission 

            call ActualizeMeteoOcean        
            
            call ReadMeteoOceanBathym           

            !Constructs the overlay velocity for every origin
            call ConstructOverlay         

            !Constructs the Monitoring 
            call ConstructMonitoring
            
            !Constructs the MonitoringLag 
            if (Me%State%MonitorLag) then
                call ConstructMonitoringLag () 
                call MonitorParticleLag     ()
            endif
            
            !Allocates all the necessary matrix for integrate lag data in eulerian grids
            call ConstructLag2Euler      
            
            !Starts the HDF Output
            if (Me%OutPut%Write_) call ConstructHDF5Output    
            
           
           
            !Starts the Statistic
            if (Me%State%Statistics) then
                call NewParticleMass            
                call ConstructParticStatistic   
            endif

            if (Me%State%HNS) then
                call HNSInitializeParticleValues
            endif

            if (Me%State%Oil) then
                call AllocateOil
                !Important for the output of particles tickness
                Me%ExternalVar%VWaterContent = 0. 
                call FillGridThickness
                call ComputeAreaVolume
                call GetOilOptions
                if(Me%State%CalcPartDistToCoast)then
                    call CalcParticDistanceToCoast()
                endif
            endif
            
            ! Opens Output Tracer Info File, if Needed
            if (Me%State%OutputTracerInfo) then
                call ConstructOutputTracerTimeSeries
            end if

            ! Opens Output Envelope Info File, if Needed
            if (Me%Output%OutputEnvelopeTimeSeries) then
                call ConstructOutputEnvelopeTimeSeries
            end if

            call LagrangianOutput            

            !Message to the User
            call ConstructLog             

            deallocate(IndexMatch)


            !Frees Pointer to External modules
            call ReadUnLockExternalVar()

            call ReadUnLockEulerianDensity()
            
            Me%ConstructLag = .false. 
            
!            nullify(TimeID, GridDataID, HorizontalGridID, HorizontalMapID, GeometryID)
!            nullify(MapID, AssimilationID, HydrodynamicID, TurbulenceID, WavesID, WaterPropertiesID)

            STAT_           = SUCCESS_

        else

            stop 'ConstructLagrangianGlobal - ModuleLagrangianGlobal - ERR99' 

        endif


        if (present(STAT)) STAT = STAT_


    end subroutine ConstructLagrangianGlobal

    !--------------------------------------------------------------------------

    subroutine GetOilOptions

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: STAT_CALL                          
        logical                                     :: OilSedimentation
        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

             Call GetOilSedimentation(CurrentOrigin%ObjOil,                              &
                                      OilSedimentation        = OilSedimentation,        & 
                                      STAT                    = STAT_CALL)
            
            CurrentOrigin%State%OilSedimentation = OilSedimentation

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

end subroutine GetOilOptions

    !--------------------------------------------------------------------------

    subroutine HNSOptions

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: STAT_CALL                          
        logical                                     :: HNSSedimentation, HNSEntrainment, HNSSpreading
        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

             Call GetHNSSpreading(CurrentOrigin%ObjHNS,                              &
                                      HNSSpreading            = HNSSpreading,        & 
                                      STAT                    = STAT_CALL)
            
            CurrentOrigin%State%HNSSpreading = HNSSpreading

             Call GetHNSEntrainment(CurrentOrigin%ObjHNS,                              &
                                      HNSEntrainment          = HNSEntrainment,        & 
                                      STAT                    = STAT_CALL)
            
            CurrentOrigin%State%HNSEntrainment = HNSEntrainment

             Call GetHNSSedimentation(CurrentOrigin%ObjHNS,                              &
                                      HNSSedimentation        = HNSSedimentation,        & 
                                      STAT                    = STAT_CALL)
            
            CurrentOrigin%State%HNSSedimentation = HNSSedimentation

            call ExportDropletOptions(CurrentOrigin%ObjHNS,                                              &
                                      MethodBWDropletsDiameter = CurrentOrigin%MethodBWDropletsDiameter, &
                                      DropletsD50              = CurrentOrigin%DropletsD50,              &
                                      STAT = STAT_CALL)


            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

end subroutine HNSOptions

    !--------------------------------------------------------------------------

    subroutine AllocateInstance

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Lagrangian), pointer                :: NewLagrangian
        type (T_Lagrangian), pointer                :: PreviousLagrangian

        !Allocates new instance
        allocate (NewLagrangian)
        nullify  (NewLagrangian%Next)

        !Insert New Instance into list and makes Current point to it
        if (.not. associated(FirstLagrangian)) then
            FirstLagrangian    => NewLagrangian
            Me                 => NewLagrangian
        else
            PreviousLagrangian => FirstLagrangian
            Me                 => FirstLagrangian%Next
            do while (associated(Me))
                PreviousLagrangian  => Me
                Me                  => Me%Next
            enddo
            Me                      => NewLagrangian
            PreviousLagrangian%Next => NewLagrangian
        endif

        Me%InstanceID = RegisterNewInstance (mLAGRANGIAN_)

    end subroutine AllocateInstance

   !------------------------------------------------------------------------------

    subroutine AllocateBeaching

        !Local---------------------------------------------------------------------
        integer                                     :: em, STAT_CALL                          

        !Begin---------------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber 

            allocate (Me%EulerModel(em)%HorizontalBeachHoldingCapacity(Me%EulerModel(em)%Size%ILB: &
                                                                       Me%EulerModel(em)%Size%IUB, &
                                                                       Me%EulerModel(em)%Size%JLB: &
                                                                       Me%EulerModel(em)%Size%JUB), &
                                                                       STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateBeaching - ModuleLagrangianGlobal - ERR01'

            Me%EulerModel(em)%HorizontalBeachHoldingCapacity(:,:) = 0.

            allocate (Me%EulerModel(em)%OldSurfaceDepth(Me%EulerModel(em)%Size%ILB: &
                                                        Me%EulerModel(em)%Size%IUB, &
                                                        Me%EulerModel(em)%Size%JLB: &
                                                        Me%EulerModel(em)%Size%JUB), &
                                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateBeaching - ModuleLagrangianGlobal - ERR02'

            Me%EulerModel(em)%OldSurfaceDepth(:,:) = null_real

        enddo d1


    end subroutine AllocateBeaching

    !------------------------------------------------------------------------------
    
    
    subroutine AllocateOil

        !Local---------------------------------------------------------------------
        integer                     :: em, ig, STAT_CALL                          

        !Begin---------------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber 

            allocate (Me%EulerModel(em)%OilSpreading(1: Me%NGroups), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR10'
            
            allocate (Me%EulerModel(em)%MassDissolvedSumParticCell( Me%EulerModel(em)%Size%ILB: &
                                                                    Me%EulerModel(em)%Size%IUB, &
                                                                    Me%EulerModel(em)%Size%JLB: &
                                                                    Me%EulerModel(em)%Size%JUB,&
                                                                    Me%EulerModel(em)%Size%KLB: &
                                                                    Me%EulerModel(em)%Size%KUB),&
                                                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR11'
            
            allocate (Me%EulerModel(em)%MassSumParticCell         ( Me%EulerModel(em)%Size%ILB: &
                                                                    Me%EulerModel(em)%Size%IUB, &
                                                                    Me%EulerModel(em)%Size%JLB: &
                                                                    Me%EulerModel(em)%Size%JUB,&
                                                                    Me%EulerModel(em)%Size%KLB: &
                                                                    Me%EulerModel(em)%Size%KUB),&
                                                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR12'

d2:         do ig = 1, Me%NGroups

            !Allocates GridThickness
            allocate (Me%EulerModel(em)%OilSpreading(ig)%GridThickness(Me%EulerModel(em)%Size%ILB: &
                                                                       Me%EulerModel(em)%Size%IUB, &
                                                                       Me%EulerModel(em)%Size%JLB: &
                                                                       Me%EulerModel(em)%Size%JUB),&
                                                                       STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR20'
            
            Me%EulerModel(em)%OilSpreading(ig)%GridThickness(:,:)=0.


            !Allocates OilGridConcentration
            allocate (Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration(Me%EulerModel(em)%Size%ILB: &
                                                                              Me%EulerModel(em)%Size%IUB, &
                                                                              Me%EulerModel(em)%Size%JLB: &
                                                                              Me%EulerModel(em)%Size%JUB),&
                                                                              STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR30'
            
            Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration(:,:) = 0.

            !Allocates OilGridConcentration3D
            allocate (Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration3D(Me%EulerModel(em)%Size%ILB: &
                                                                              Me%EulerModel(em)%Size%IUB, &
                                                                              Me%EulerModel(em)%Size%JLB: &
                                                                              Me%EulerModel(em)%Size%JUB,&
                                                                              Me%EulerModel(em)%Size%KLB: &
                                                                              Me%EulerModel(em)%Size%KUB),&
                                                                              STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR31'
            
            Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration3D(:,:,:) = 0.

            !Allocates OilGridDissolution3D
            allocate (Me%EulerModel(em)%OilSpreading(ig)%OilGridDissolution3D(Me%EulerModel(em)%Size%ILB: &
                                                                              Me%EulerModel(em)%Size%IUB, &
                                                                              Me%EulerModel(em)%Size%JLB: &
                                                                              Me%EulerModel(em)%Size%JUB,&
                                                                              Me%EulerModel(em)%Size%KLB: &
                                                                              Me%EulerModel(em)%Size%KUB),&
                                                                              STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR32'
            
            Me%EulerModel(em)%OilSpreading(ig)%OilGridDissolution3D(:,:,:) = 0.

            allocate (Me%EulerModel(em)%OilSpreading(ig)%VelocityX(Me%EulerModel(em)%Size%ILB: &
                                                                   Me%EulerModel(em)%Size%IUB, &
                                                                   Me%EulerModel(em)%Size%JLB: &
                                                                   Me%EulerModel(em)%Size%JUB),&
                                                                   STAT = STAT_CALL)
            
            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR40'
            
            Me%EulerModel(em)%OilSpreading(ig)%VelocityX(:,:) = 0.

            allocate (Me%EulerModel(em)%OilSpreading(ig)%VelocityY(Me%EulerModel(em)%Size%ILB: &
                                                                   Me%EulerModel(em)%Size%IUB, &
                                                                   Me%EulerModel(em)%Size%JLB: &
                                                                   Me%EulerModel(em)%Size%JUB),&
                                                                   STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR50'
            
            Me%EulerModel(em)%OilSpreading(ig)%VelocityY(:,:) = 0.

            allocate (Me%EulerModel(em)%OilSpreading(ig)%AreaFlag (Me%EulerModel(em)%Size%ILB: &
                                                                   Me%EulerModel(em)%Size%IUB, &
                                                                   Me%EulerModel(em)%Size%JLB: &
                                                                   Me%EulerModel(em)%Size%JUB),&
                                                                   STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR60'

            Me%EulerModel(em)%OilSpreading(ig)%AreaFlag(:,:) = .true. 
            
            allocate (Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime(Me%EulerModel(em)%Size%ILB: &
                                                                            Me%EulerModel(em)%Size%IUB, &
                                                                            Me%EulerModel(em)%Size%JLB: &
                                                                            Me%EulerModel(em)%Size%JUB),&
                                                                            STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'AllocateOil - ModuleLagrangianGlobal - ERR70'

            Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime(:,:) = 0. 
            enddo d2

        enddo d1

    end subroutine AllocateOil

    !------------------------------------------------------------------------------  
    
    subroutine AllocateHNS

        !Local---------------------------------------------------------------------
        integer                     :: em, ig, STAT_CALL                          
        integer                     :: IUB, ILB, JLB, JUB, KLB, KUB
        
        !Begin---------------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber 

            ILB = Me%EulerModel(em)%WorkSize%ILB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            KUB = Me%EulerModel(em)%WorkSize%KUB

            allocate (Me%EulerModel(em)%HNS(1: Me%NGroups), STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR10'

d2:         do ig = 1, Me%NGroups

                allocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D(ILB:IUB,          &
                                                                       JLB: JUB,         &
                                                                       KLB: KUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR10'
                
                Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D(:,:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D(ILB:IUB,          &
                                                                       JLB: JUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR20'
                
                Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR30'
                
                Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridAirConc3D(ILB:IUB,          &
                                                                       JLB: JUB,         &
                                                                       KLB: KUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR40'
                
                Me%EulerModel(em)%HNS(ig)%GridAirConc3D(:,:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridAirConc2D(ILB:IUB,          &
                                                                       JLB: JUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR50'
                
                Me%EulerModel(em)%HNS(ig)%GridAirConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridAirMaxConc2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR60'
                
                Me%EulerModel(em)%HNS(ig)%GridAirMaxConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(ILB:IUB,          &
                                                                       JLB: JUB,         &
                                                                       KLB: KUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR70'
                
                Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(:,:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D(ILB:IUB,          &
                                                                       JLB: JUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR80'
                
                Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR90'
                
                Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(:,:)=0.


                allocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D(ILB:IUB,          &
                                                                                  JLB: JUB,         &
                                                                                  KLB: KUB),         &
                                                                                 STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR100'
                
                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D(:,:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D(ILB:IUB,          &
                                                                       JLB: JUB),         &
                                                                       STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR110'
                
                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR120'
                
                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridAirMass2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR130'
                
                Me%EulerModel(em)%HNS(ig)%GridAirMass2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridSurfaceFloatingMass2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR140'
                
                Me%EulerModel(em)%HNS(ig)%GridSurfaceFloatingMass2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR150'
                
                Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D(:,:)=0.
                
                allocate (Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR160'
                
                Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(ILB:IUB,          &
                                                                           JLB: JUB,         &
                                                                           KLB: KUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR170'

                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(:,:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR180'
                
                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D(ILB:IUB,          &
                                                                           JLB: JUB,         &
                                                                           KLB: KUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR190'
                
                Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D(:,:,:)=0.
                
                allocate (Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(ILB:IUB,          &
                                                                           JLB: JUB,         &
                                                                           KLB: KUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR200'
                
                Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(:,:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMass2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR210'
                
                Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMass2D(:,:)=0.

                allocate (Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D(ILB:IUB,          &
                                                                           JLB: JUB),         &
                                                                           STAT = STAT_CALL   )
                if (STAT_CALL /= SUCCESS_) stop 'AllocateHNS - ModuleLagrangianGlobal - ERR220'
                
                Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D(:,:)=0.

            enddo d2

        enddo d1

    end subroutine AllocateHNS

    !------------------------------------------------------------------------------

    subroutine ComputeDistanceToCoast

        !Local---------------------------------------------------------------------
        real, dimension(:,:), pointer   :: CoordX, CoordY    
        real, dimension(:), pointer     :: AngleList, DistanceByDirection               
        type (T_PointF),    pointer     :: Point
        real                            :: Distance, IntersectX, IntersectY
        integer                         :: em, i, j, d, STAT_CALL   

        !Begin---------------------------------------------------------------------
        
        allocate(AngleList(Ndir),DistanceByDirection(Ndir))
        allocate(Point)
        AngleList(1) = 0.
        do d=2,Ndir
            AngleList(d) = AngleList(d-1) + 360./real(NDir)
        enddo

d1:     do em =1, Me%EulerModelNumber 

            call GetZCoordinates(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, CoordY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeDistanceToCoast - ModuleLagrangianGlobal - ERR10'
            
             allocate (Me%EulerModel(em)%DistanceToCoast(Me%EulerModel(em)%Size%ILB:    &
                                                         Me%EulerModel(em)%Size%IUB,    &
                                                         Me%EulerModel(em)%Size%JLB:    &
                                                         Me%EulerModel(em)%Size%JUB),   &
                                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeDistanceToCoast - ModuleLagrangianGlobal - ERR20'          
            
            do j=Me%EulerModel(em)%WorkSize%JLB,Me%EulerModel(em)%WorkSize%JUB
            do i=Me%EulerModel(em)%WorkSize%ILB,Me%EulerModel(em)%WorkSize%IUB

                Point%X = CoordX(i, j)
                Point%Y = CoordY(i, j)
                
                call PointDistanceToPolygon (Point, Me%CoastLine, AngleList, DistanceByDirection, Distance, IntersectX, IntersectY)
                
                !The distance is always in meters
                if (Me%EulerModel(em)%Grid%GeoGrid) then
                    Distance = DistanceBetweenTwoGPSPoints(Point%X, Point%Y, IntersectX, IntersectY)
                endif
                
                Me%EulerModel(em)%DistanceToCoast(i, j) = Distance                
                        
            enddo
            enddo

            call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeDistanceToCoast - ModuleLagrangianGlobal - ERR30'

            call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, CoordY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeDistanceToCoast - ModuleLagrangianGlobal - ERR40'

        enddo d1
        
        deallocate(AngleList, DistanceByDirection, Point)

    end subroutine ComputeDistanceToCoast

    !------------------------------------------------------------------------------


    subroutine ConstructGlobalVariables

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        character(len = StringLength)               :: Message

        !----------------------------------------------------------------------

        !Initialize the origin ID   
        Me%nOrigins    = 0
        Me%nOldOrigins = 0

        !Initialize the origin list   
        nullify (Me%FirstOrigin   )
        nullify (Me%FirstOldOrigin)
 
        !Input data file
        Message   ='ASCII file used to construct lagrangian module'
        call ReadFileName('PARTIC_DATA', Me%Files%ConstructData,                        &
                           Message = Message, FilesInput = Me%Files%Nomfich,            &
                           STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructGlobalVariables - ModuleLagrangianGlobal - ERR05'



cd1 :   if      (STAT_CALL .EQ. FILE_NOT_FOUND_ERR_  ) then
            write(*,*)  
            write(*,*) 'Initial file not found.'
        if (STAT_CALL /= SUCCESS_) stop 'ConstructGlobalVariables - ModuleLagrangianGlobal - ERR08'

        else if (STAT_CALL .EQ. KEYWORD_NOT_FOUND_ERR_) then
            write(*,*)  
            write(*,*) 'Keyword for the initial file not found in nomfich.dat.'
            write(*,*) 'ConstructGlobalVariables - ModuleLagrangianGlobal - WRN01'
            write(*,*)  

        else if (STAT_CALL .EQ. SUCCESS_             ) then
            continue
        else
            stop 'ConstructGlobalVariables - ModuleLagrangianGlobal - ERR09'
        end if cd1  

        !----------------------------------------------------------------------

    end subroutine ConstructGlobalVariables

    !--------------------------------------------------------------------------


    !------------------------------------------------------------------------------

    subroutine ConstructOuptusFilesNames

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        character(len = StringLength)               :: Message

        !----------------------------------------------------------------------

        !Transient HDF File
        Message   ='Instant fields of lagrangian particles in HDF format.'
        call ReadFileName('PARTIC_HDF', Me%Files%TransientHDF,                          &
                           Message = Message,                                           &
                           TIME_END = Me%ExternalVar%EndTime,                           &
                           Extension = 'hdf',                                           &
                           FilesInput = Me%Files%Nomfich,                               & 
                           STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOuptusFilesNames - ModuleLagrangianGlobal - ERR06'


        !Final file
        Message   ='Final Particle Conditions.'
        call ReadFileName('PARTIC_FIN', Me%Files%Final,                                 &
                           Message = Message,                                           &
                           TIME_END = Me%ExternalVar%EndTime,                           &
                           Extension = 'ptf',                                           &
                           FilesInput = Me%Files%Nomfich,                               &
                           STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOuptusFilesNames - ModuleLagrangianGlobal - ERR07'


        !Initial Conditions
        Message   ='Initial Particle Conditions.'
        call ReadFileName('PARTIC_INI', Me%Files%Initial,                               &
                           Message = Message, TIME_END = Me%ExternalVar%Now,            &
                           Extension = 'ptf',                                           &
                           FilesInput = Me%Files%Nomfich,                               &  
                           STAT = STAT_CALL)

cd1 :   if      (STAT_CALL .EQ. FILE_NOT_FOUND_ERR_  ) then
            write(*,*)  
            write(*,*) 'Initial file not found.'
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOuptusFilesNames - ModuleLagrangianGlobal - ERR08'

        else if (STAT_CALL .EQ. KEYWORD_NOT_FOUND_ERR_) then
            write(*,*)  
            write(*,*) 'Keyword for the initial file not found in nomfich.dat.'
            write(*,*) 'ConstructOuptusFilesNames - ModuleLagrangianGlobal - WRN01'
            write(*,*)  

        else if (STAT_CALL .EQ. SUCCESS_             ) then
            continue
        else
            stop 'ConstructOuptusFilesNames - ModuleLagrangianGlobal - ERR09'
        end if cd1  

        !----------------------------------------------------------------------

    end subroutine ConstructOuptusFilesNames

    !--------------------------------------------------------------------------
    !------------------------------------------------------------------------------

    subroutine ConstructEulerModelsList(ModelNames, IndexMatch, Nmodels, NmodelsFinal)

        !Arguments-------------------------------------------------------------
        character(len = *), dimension(:), pointer   :: ModelNames
        integer,            dimension(:), pointer   :: IndexMatch
        integer                                     :: Nmodels, NmodelsFinal
        !Local-----------------------------------------------------------------
        character(len=StringLength)                 :: AuxChar
        integer                                     :: STAT_CALL, FirstLine, LastLine,  &
                                                       l, em, Naux, ClientNumber, line, iflag
        logical                                     :: BlockFound, MatchModel
        !----------------------------------------------------------------------

 
        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                      &
                                    '<BeginModelPriority>', '<EndModelPriority>', BlockFound, &
                                    FirstLine = FirstLine, LastLine = LastLine,         &
                                    STAT = STAT_CALL)
    
        if (STAT_CALL /= SUCCESS_) stop 'ConstructEulerModelsList - ModuleLagrangianGlobal - ERR10'

BF:     if (BlockFound) then

            Naux = LastLine - FirstLine - 1

            if (Naux > Nmodels) stop 'ConstructEulerModelsList - ModuleLagrangianGlobal - ERR20'

            if (Naux < Nmodels) then
                write(*,*) 'The langrangian module will only use ',Naux,' from a total of ', Nmodels
                write(*,*) 'ConstructEulerModelsList - ModuleLagrangianGlobal - WRN20'
            endif

            em = 0
            do line = FirstLine + 1, LastLine - 1

                call GetData(AuxChar, EnterDataID = Me%ObjEnterData, flag = iflag, &
                             SearchType = FromBlock, Buffer_Line = line, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'ConstructEulerModelsList - ModuleLagrangianGlobal - ERR30'

                em = em + 1
                MatchModel = .false. 
                do l = 1, Nmodels
                    if (trim(AuxChar) == trim(ModelNames(l))) then
                        IndexMatch(em) = l
                        MatchModel = .true.
                        exit
                    endif
                 enddo

                 if (.not.MatchModel) stop 'ConstructEulerModelsList - ModuleLagrangianGlobal - ERR40'

            enddo

        else
        
            do em = 1, Nmodels
                IndexMatch(em) = Nmodels - em + 1
            enddo 
            
            Naux = Nmodels
          
        endif BF

        NmodelsFinal = Naux


        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructEulerModelsList - ModuleLagrangianGlobal - ERR50'


        !Prepares file for a new block search throughout the entire file
        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructEulerModelsList - ModuleLagrangianGlobal - ERR50'


        !----------------------------------------------------------------------

    end subroutine ConstructEulerModelsList
    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


    subroutine ReadBooms

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        logical                                     :: BoomsFound
        integer                                     :: STAT_CALL, ClientNumber

        !----------------------------------------------------------------------

        Me%Booms%ON = .false.

        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                      &   
                                   booms_begin, booms_end,                  &
                                   BoomsFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadBooms - ModuleLagrangianGlobal - ERR10'

if1:    if (BoomsFound) then

            Me%Booms%ON = .true. 

            call CountIndividualBooms(ClientNumber)

            call ReadIndividualBooms (ClientNumber)
            
            Me%State%Booms = .true.

        else 
            
            Me%State%Booms = .false.

        endif if1

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ReadBooms - ModuleLagrangianGlobal - ERR20'
        

        !Prepares file for a new block search throughout the entire file
        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadBooms - ModuleLagrangianGlobal - ERR30'
        

    end subroutine ReadBooms

    !--------------------------------------------------------------------------

    subroutine CountIndividualBooms(ClientNumber)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber

        !Local-----------------------------------------------------------------
        integer                                         :: STAT_CALL, NBoom
        logical                                         :: BoomFound

        !Begin-----------------------------------------------------------------

        NBoom = 0

DOPROP: do 

            call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                   &
                                       individual_boom_begin, individual_boom_end,      &
                                       BoomFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'CountIndividualBooms - ModuleLagrangianGlobal - ERR10'
            
i1:         if (BoomFound) then

                NBoom = NBoom + 1
 
            else i1
            
                call RewindBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'CountIndividualBooms - ModuleLagrangianGlobal - ERR20'
                exit
            endif i1

        enddo DOPROP
        
        Me%Booms%Number = NBoom

        allocate(Me%Booms%Individual(Me%Booms%Number))

    end subroutine CountIndividualBooms
    !--------------------------------------------------------------------------

    subroutine ReadIndividualBooms(ClientNumber)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber

        !Local-----------------------------------------------------------------
        character (Len = PathLength)                    :: LinesFileName
        logical                                         :: BoomFound
        integer                                         :: STAT_CALL, nBoom, flag
        !Begin-----------------------------------------------------------------
        
DONB:   do nBoom = 1, Me%Booms%Number
 
            call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                   &
                                       individual_boom_begin, individual_boom_end,      &
                                       BoomFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR10'
            
i1:         if (BoomFound) then

                call GetData(Me%Booms%Individual(nBoom)%Name,                       &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='NAME',                                  &
                             default      = 'BOOM X',                               &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR20'
 
                call GetData(Me%Booms%Individual(nBoom)%Description,                &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='DESCRIPTION',                           &
                             default      = 'Boom to contain a oil spill',          &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR30'
 
                call GetData(Me%Booms%Individual(nBoom)%VelLimit,                   &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='VEL_THRESHOLD',                         &
                             default      = 0.4,                                    &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR40'

                call GetData(Me%Booms%Individual(nBoom)%WaveLimit,                  &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='WAVE_THRESHOLD',                        &
                             default      = 0.6,                                    &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR50'

               call GetData(LinesFileName,                                          &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='FILENAME',                              &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR60'
                
                if (flag == 0) then
                    write(*,*) 'Boom named ', trim(Me%Booms%Individual(nBoom)%Name),' needs a ".lin" file'
                    stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR70'                
                endif
                
                nullify(Me%Booms%Individual(nBoom)%Lines)
                
                call New(Me%Booms%Individual(nBoom)%Lines, LinesFileName)                                
               
                !testing - boom is defined by a buffer for the case of boom moving 
                !to trap the particles and do not pass over them
                call GetData(Me%Booms%Individual(nBoom)%BoomHasBuffer,              &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='BOOM_HAS_BUFFER',                       &
                             default      = .false.,                                &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR70'
                
                if (Me%Booms%Individual(nBoom)%BoomHasBuffer) then
                    call GetData(Me%Booms%Individual(nBoom)%BoomBufferDist,             &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='BOOM_BUFFER_DISTANCE',                  &
                                 default      = 0.,                                     &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR80'                 
                endif
                
            else i1
            
                stop 'ReadIndividualBooms - ModuleLagrangianGlobal - ERR90'

            endif i1
            
        enddo DONB
        


    end subroutine ReadIndividualBooms
                
    !--------------------------------------------------------------------------


    subroutine ReadMeteoOceanFields

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        logical                                     :: MeteoOceanFound
        integer                                     :: STAT_CALL, ClientNumber

        !----------------------------------------------------------------------


        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                      &   
                                   meteo_ocean_begin, meteo_ocean_end,                  &
                                   MeteoOceanFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFields - ModuleLagrangianGlobal - ERR10'

if1:    if (MeteoOceanFound) then

            call CountMeteoOceanProperties(ClientNumber)

            call ReadMeteoOceanProperties (ClientNumber)
            
            Me%State%MeteoOcean = .true.

        else 
            
            Me%State%MeteoOcean = .false.

        endif if1

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFields - ModuleLagrangianGlobal - ERR20'
        

        !Prepares file for a new block search throughout the entire file
        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFields - ModuleLagrangianGlobal - ERR30'
        

    end subroutine ReadMeteoOceanFields

    !--------------------------------------------------------------------------

    subroutine CountMeteoOceanProperties(ClientNumber)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber

        !Local-----------------------------------------------------------------
        integer                                         :: STAT_CALL, nProp
        logical                                         :: PropertyFound

        !Begin-----------------------------------------------------------------

        nProp = 0

DOPROP: do 

            call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                   &
                                       property_begin, property_end,                    &
                                       PropertyFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'CountMeteoOceanProperties - ModuleLagrangianGlobal - ERR10'
            
i1:         if (PropertyFound) then

                nProp = nProp + 1
 
            else i1
            
                call RewindBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'CountMeteoOceanProperties - ModuleLagrangianGlobal - ERR20'
                exit
            endif i1

        enddo DOPROP
        
        Me%MeteoOcean%PropNumber = nProp

        allocate(Me%MeteoOcean%Prop(Me%MeteoOcean%PropNumber))

    end subroutine CountMeteoOceanProperties
    !--------------------------------------------------------------------------

    subroutine ReadMeteoOceanProperties(ClientNumber)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber

        !Local-----------------------------------------------------------------
        type(T_Property),   pointer                     :: CurrentProperty
        type(T_PropertyID)                              :: PropertyID
        logical                                         :: PropertyFound
        integer                                         :: STAT_CALL, nProp, flag, iP
        !Begin-----------------------------------------------------------------

DOPROP: do nProp = 1, Me%MeteoOcean%PropNumber
 
            call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                   &
                                       property_begin, property_end,                    &
                                       PropertyFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanProperties - ModuleLagrangianGlobal - ERR10'
            
i1:         if (PropertyFound) then

                call ConstructPropertyID (PropertyID, Me%ObjEnterData, FromBlockInBlock)

                Me%MeteoOcean%Prop(nProp)%ID = PropertyID
                        
                call GetData(Me%MeteoOcean%Prop(nProp)%MaskDim,                     &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='MASK_DIM',                              &
                             default      = 2,                                      &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanProperties - ModuleLagrangianGlobal - ERR20'
                
                if (Me%MeteoOcean%Prop(nProp)%MaskDim /= 2 .and. Me%MeteoOcean%Prop(nProp)%MaskDim /=3 &
                    .and. Me%MeteoOcean%Prop(nProp)%MaskDim /= -99) then
                    stop 'ReadMeteoOceanProperties - ModuleLagrangianGlobal - ERR30'
                endif

                call GetData(Me%MeteoOcean%Prop(nProp)%FileListMode,                &
                             Me%ObjEnterData,                                       &
                             flag,                                                  &
                             SearchType   = FromBlockInBlock,                       &
                             keyword      ='FILE_LIST_MODE',                        &
                             default      = .false.,                                &
                             ClientModule ='ModuleLagrangianGlobal',                &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanProperties - ModuleLagrangianGlobal - ERR30'
                
                call ConstructMeteoOceanProperties(nProp, ClientNumber)                

            else i1
            
                stop 'ReadMeteoOceanProperties - ModuleLagrangianGlobal - ERR40'

            endif i1
            

            iP = 1
            CurrentProperty => Me%FirstOrigin%FirstProperty
dw1:        do while (associated(CurrentProperty))
                if (CurrentProperty%ID == PropertyID%IDNumber) then
                    Me%MeteoOcean%Prop(nProp)%LagPropI       = iP
                    Me%MeteoOcean%Prop(nProp)%EqualToAmbient = CurrentProperty%EqualToAmbient
                    exit
                endif
                iP = iP + 1
                CurrentProperty => CurrentProperty%Next
            enddo dw1            

        enddo DOPROP
        


    end subroutine ReadMeteoOceanProperties
                
    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ConstructMeteoOceanProperties(nProp, ClientNumber)

        !Arguments-------------------------------------------------------------
        integer                                         :: nProp, ClientNumber

        !Local-----------------------------------------------------------------
        real, dimension(1:2,1:2)                        :: WindowLimitsXY
        real                                            :: West, East, South, North
        integer                                         :: STAT_CALL, i, emMax
        !Begin-----------------------------------------------------------------

                
        emMax = Me%EulerModelNumber                     
        
        call GetGridBorderLimits(Me%EulerModel(emMax)%ObjHorizontalGrid,    &
                                 West, East, South, North, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructMeteoOceanProperties - ModuleLagrangianGlobal - ERR10'
        
        
        WindowLimitsXY(2,1) = South
        WindowLimitsXY(2,2) = North
        WindowLimitsXY(1,1) = West
        WindowLimitsXY(1,2) = East
        
        if (Me%MeteoOcean%Prop(nProp)%FileListMode) then

            call ReadMeteoOceanListFiles (ClientNumber, nProp)

 d1:        do i = 1, Me%MeteoOcean%Prop(nProp)%FieldNumber
 
                if (Me%MeteoOcean%Prop(nProp)%Field(i)%NFilesList > 0) then
            
                    call ConstructField4D(Field4DID     = Me%MeteoOcean%Prop(nProp)%Field(i)%ID,        &
                                          EnterDataID   = Me%ObjEnterData,                              &
                                          ExtractType   = FromBlockinBlock,                             &
                                          TimeID        = Me%ExternalVar%ObjTime,                       &   
                                          MaskDim       = Me%MeteoOcean%Prop(nProp)%MaskDim,            &
                                          LatReference  = Me%EulerModel(emMax)%Grid%LatDefault,         &
                                          LonReference  = Me%EulerModel(emMax)%Grid%LongDefault,        & 
                                          WindowLimitsXY= WindowLimitsXY,                               &
                                          Extrapolate   = .false.,                                      &
                                          FileNameList  = Me%MeteoOcean%Prop(nProp)%Field(i)%FileNameList, &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructMeteoOceanProperties - ModuleLagrangianGlobal - ERR20'
                    
                endif
                                                    
            enddo d1
        
        else
        
            call ReadMeteoOceanFiles (ClientNumber, nProp)

d2:         do i = 1, Me%MeteoOcean%Prop(nProp)%FieldNumber
            
                call ConstructField4D(Field4DID     = Me%MeteoOcean%Prop(nProp)%Field(i)%ID,        &
                                      EnterDataID   = Me%ObjEnterData,                              &
                                      ExtractType   = FromBlockinBlock,                             &
                                      FileName      = Me%MeteoOcean%Prop(nProp)%Field(i)%FileName,  &
                                      TimeID        = Me%ExternalVar%ObjTime,                       &   
                                      MaskDim       = Me%MeteoOcean%Prop(nProp)%MaskDim,            &
                                      LatReference  = Me%EulerModel(emMax)%Grid%LatDefault,         &
                                      LonReference  = Me%EulerModel(emMax)%Grid%LongDefault,        & 
                                      WindowLimitsXY= WindowLimitsXY,                               &
                                      Extrapolate   = .false.,                                      &    
                                      STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructMeteoOceanProperties - ModuleLagrangianGlobal - ERR30'
                                    
            enddo d2

        endif

    end subroutine ConstructMeteoOceanProperties
                
    !--------------------------------------------------------------------------

    subroutine ReadMeteoOceanFiles(ClientNumber, nProp)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber, nProp

        !Local-----------------------------------------------------------------
        logical                                         :: BlockInBlockFound
        integer                                         :: STAT_CALL, FirstLine, LastLine, i, iflag 
        !Begin-----------------------------------------------------------------

        call RewindBlockInBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFiles - ModuleLagrangianGlobal - ERR10'

        call ExtractBlockFromBlockFromBlock(Me%ObjEnterData, ClientNumber,              &
                                            meteo_ocean_begin_files,                    &
                                            meteo_ocean_end_files,                      &
                                            BlockInBlockFound,                          &
                                            FirstLine, LastLine,                        &
                                            STAT = STAT_CALL)                                        
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFiles - ModuleLagrangianGlobal - ERR20'
            
i1:     if (BlockInBlockFound) then

            Me%MeteoOcean%Prop(nProp)%FieldNumber = LastLine - FirstLine - 1

            allocate (Me%MeteoOcean%Prop(nProp)%Field(Me%MeteoOcean%Prop(nProp)%FieldNumber))
            
            Me%MeteoOcean%Prop(nProp)%Field(:)%ID = 0

            do i = 1, Me%MeteoOcean%Prop(nProp)%FieldNumber

                call GetData(Me%MeteoOcean%Prop(nProp)%Field(i)%FileName,               &
                             Me%ObjEnterData,  iflag, Buffer_Line  = FirstLine + i,     &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFiles - ModuleLagrangianGlobal - ERR30'

            enddo

        else i1
            if (Me%MeteoOcean%Prop(nProp)%ID%IDNumber == bathymetry_) then        
                Me%MeteoOcean%Prop(nProp)%FieldNumber = 0.
            else
                stop 'ReadMeteoOceanFiles - ModuleLagrangianGlobal - ERR40'
            endif
        endif i1

        call RewindBlockInBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanFiles - ModuleLagrangianGlobal - ERR50'


    end subroutine ReadMeteoOceanFiles
                
    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------

    subroutine ReadMeteoOceanListFiles(ClientNumber, nProp)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber, nProp

        !Local-----------------------------------------------------------------
        logical                                         :: BlockInBlockFound
        integer                                         :: STAT_CALL, FirstLine, LastLine, i, iflag
        integer                                         :: n, FileNumber, FieldNumber 
        !Begin-----------------------------------------------------------------

        call RewindBlockInBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR10'
        
        FieldNumber = 0
        
        do 

            call ExtractBlockFromBlockFromBlock(Me%ObjEnterData, ClientNumber,          &
                                                meteo_ocean_begin_files,                &
                                                meteo_ocean_end_files,                  &
                                                BlockInBlockFound,                      &
                                                FirstLine, LastLine,                    &
                                                STAT = STAT_CALL)                                        
            if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR20'
                
    i1:     if (BlockInBlockFound) then
    
                FieldNumber = FieldNumber + 1

            elseif (FieldNumber == 0) then i1
                if (Me%MeteoOcean%Prop(nProp)%ID%IDNumber == bathymetry_) then        
                    exit
                else
                    stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR30'
                endif
            else i1
                exit                                 
            endif i1
            
        enddo            
        
        Me%MeteoOcean%Prop(nProp)%FieldNumber = FieldNumber
        
        allocate (Me%MeteoOcean%Prop(nProp)%Field(Me%MeteoOcean%Prop(nProp)%FieldNumber))        
        
        call RewindBlockInBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR40'
        
        do i = 1, Me%MeteoOcean%Prop(nProp)%FieldNumber

            call ExtractBlockFromBlockFromBlock(Me%ObjEnterData, ClientNumber,          &
                                                meteo_ocean_begin_files,                &
                                                meteo_ocean_end_files,                  &
                                                BlockInBlockFound,                      &
                                                FirstLine, LastLine,                    &
                                                STAT = STAT_CALL)                                        
            if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR50'
                
            FileNumber = LastLine - FirstLine - 1
            
            Me%MeteoOcean%Prop(nProp)%Field(i)%NFilesList = FileNumber

            allocate(Me%MeteoOcean%Prop(nProp)%Field(i)%FileNameList(FileNumber))
            
            Me%MeteoOcean%Prop(nProp)%Field(i)%ID = 0

            do n = 1, FileNumber

                call GetData(Me%MeteoOcean%Prop(nProp)%Field(i)%FileNameList(n),           &
                             Me%ObjEnterData,  iflag, Buffer_Line  = FirstLine + n, &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR60'

            enddo

        enddo            

        call RewindBlockInBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanListFiles - ModuleLagrangianGlobal - ERR70'

    end subroutine ReadMeteoOceanListFiles
                
    !--------------------------------------------------------------------------

    subroutine ReadParticStatisticOptions

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        logical                                     :: StatisticFound
        integer                                     :: STAT_CALL, ClientNumber

        !----------------------------------------------------------------------


        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                  &
                                   statistic_begin, statistic_end,                  &
                                   StatisticFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadParticStatisticOptions - ModuleLagrangianGlobal - ERR10'

if1:    if (StatisticFound) then

            call ReadStatisticProperties(ClientNumber)

        else 
            
            if (Me%State%Statistics) stop 'ReadParticStatisticOptions - ModuleLagrangianGlobal - ERR20'

        endif if1


        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ReadParticStatisticOptions - ModuleLagrangianGlobal - ERR30'

        !Prepares file for a new block search throughout the entire file
        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadParticStatisticOptions - ModuleLagrangianGlobal - ERR40'

    end subroutine ReadParticStatisticOptions

    !--------------------------------------------------------------------------

    subroutine ReadStatisticProperties(ClientNumber)

        !Arguments-------------------------------------------------------------
        integer                                         :: ClientNumber

        !Local-----------------------------------------------------------------
        type(T_OptionsStat), dimension(:), pointer      :: AuxStatistic
        type(T_Property), pointer                       :: CurrentProperty
        type(T_PropertyID)                              :: PropertyID
        character(Len=PathLength)                       :: AuxChar
        logical                                         :: PropertyFound
        integer                                         :: STAT_CALL, nProp, i, j, flag

        !Begin-----------------------------------------------------------------



        allocate(AuxStatistic(Me%OriginDefault%nProperties+1))

        nProp = 0

DOPROP: do 
 
            call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                   &
                                       property_begin, property_end,                    &
                                       PropertyFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadStatisticProperties - ModuleLagrangianGlobal - ERR10'
            
i1:         if (PropertyFound) then

                call ConstructPropertyID (PropertyID, Me%ObjEnterData, FromBlockInBlock)

                nProp = nProp + 1

                AuxStatistic(nProp)%ID = PropertyID
 
                Me%State%Statistics = .true.

                !StatisticsFile
                call GetData(AuxChar,                                                   &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='STATISTICS_FILE',                           &
                             ClientModule ='ModuleLagrangianGlobal',                          &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadStatisticProperties - ModuleLagrangianGlobal - ERR40'

                AuxStatistic(nProp)%File = AuxChar

                if (flag /= 1) then
                    write(*,*)'No Statistics file definition for the Property : ',trim(CurrentProperty%Name)
                    write(*,*)'Use the KeyWord                                : STATISTICS_FILE'
                    write(*,*)'OR disable STATISTICS'
                    stop      'ReadStatisticProperties - ModuleLagrangianGlobal - ERR50'
                endif

                !Do frequency analysis considering the tracers concentration
                call GetData(AuxStatistic(nProp)%Lag,                                   &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='STATISTICS_LAG',                            &
                             ClientModule ='ModuleLagrangianGlobal',                          &
                             default      = .false.,                                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadStatisticProperties - ModuleLagrangianGlobal - ERR60'
                

            else i1

                !all properties were read
                exit 

            endif i1

        enddo DOPROP
        
        Me%Statistic%PropNumber = nProp

        allocate(Me%Statistic%OptionsStat(Me%Statistic%PropNumber))

        Me%Statistic%OptionsStat(1:Me%Statistic%PropNumber) = AuxStatistic(1:Me%Statistic%PropNumber)

        deallocate(AuxStatistic)
        nullify   (AuxStatistic)

        j = 0
        CurrentProperty => Me%OriginDefault%FirstProperty
        do while(associated(CurrentProperty))
            j = j + 1
            do i=1, Me%Statistic%PropNumber
                if (CurrentProperty%ID == Me%Statistic%OptionsStat(i)%ID%IDNumber) then
                    Me%Statistic%OptionsStat(i)%PropOrder = j
                endif
            enddo
            CurrentProperty => CurrentProperty%Next
        enddo

        nullify(CurrentProperty)

        do i=1, Me%Statistic%PropNumber
            if (IndividualsPerCell_ == Me%Statistic%OptionsStat(i)%ID%IDNumber) then
                Me%Statistic%OptionsStat(i)%PropOrder = -99
            endif

            if (OilThickness_ == Me%Statistic%OptionsStat(i)%ID%IDNumber) then
                Me%Statistic%OptionsStat(i)%PropOrder = -99
            endif
        enddo


        

    end subroutine ReadStatisticProperties
                
    !--------------------------------------------------------------------------

    subroutine ConstructLag2Euler

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                         :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                         :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                         :: WS_KLB, WS_KUB
        integer                                         :: nProp, em
        !Begin------------------------------------------------------------------
                
d1:     do em = 1, Me%EulerModelNumber 

            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB
            KLB    = Me%EulerModel(em)%Size%KLB
            KUB    = Me%EulerModel(em)%Size%KUB
            WS_ILB = Me%EulerModel(em)%WorkSize%ILB
            WS_IUB = Me%EulerModel(em)%WorkSize%IUB
            WS_JLB = Me%EulerModel(em)%WorkSize%JLB
            WS_JUB = Me%EulerModel(em)%WorkSize%JUB
            WS_KLB = Me%EulerModel(em)%WorkSize%KLB
            WS_KUB = Me%EulerModel(em)%WorkSize%KUB


            nProp           =  Me%OriginDefault%nProperties

            !Allocate GridVolume, GridMass    
            allocate (Me%EulerModel(em)%Lag2Euler%GridVolume      (ILB:IUB, JLB:JUB, KLB:KUB         , 1:Me%NGroups))
            allocate (Me%EulerModel(em)%Lag2Euler%GridTracerNumber(ILB:IUB, JLB:JUB, KLB:KUB         , 1:Me%NGroups))
            allocate (Me%EulerModel(em)%Lag2Euler%PercentContamin (ILB:IUB, JLB:JUB, KLB:KUB         , 1:Me%NGroups))

            allocate (Me%EulerModel(em)%Lag2Euler%GridMass        (ILB:IUB, JLB:JUB, KLB:KUB, 1:nProp, 1:Me%NGroups))
            allocate (Me%EulerModel(em)%Lag2Euler%GridConc        (ILB:IUB, JLB:JUB, KLB:KUB, 1:nProp, 1:Me%NGroups))


            allocate (Me%EulerModel(em)%Lag2Euler%MeanConc        (                           1:nProp, 1:Me%NGroups))
            allocate (Me%EulerModel(em)%Lag2Euler%AmbientConc     (                           1:nProp, 1:Me%NGroups))
            allocate (Me%EulerModel(em)%Lag2Euler%MinConc         (                           1:nProp, 1:Me%NGroups))
            allocate (Me%EulerModel(em)%Lag2Euler%MassVolCel      (                           1:nProp, 1:Me%NGroups))

                                                        !i,j,k,p,ig 
            Me%EulerModel(em)%Lag2Euler%GridVolume      (:,:,:,  :) = 0.
            Me%EulerModel(em)%Lag2Euler%GridTracerNumber(:,:,:,  :) = 0.
            Me%EulerModel(em)%Lag2Euler%PercentContamin (:,:,:,  :) = 0.            
            Me%EulerModel(em)%Lag2Euler%GridMass        (:,:,:,:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%GridConc        (:,:,:,:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%MeanConc              (:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%AmbientConc           (:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%MinConc               (:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%MassVolCel            (:,:) = 0.


            if (Me%State%Deposition) then
                allocate (Me%EulerModel(em)%Lag2Euler%GridBottomMass(ILB:IUB, JLB:JUB, 1:nProp, 1:Me%NGroups))
                allocate (Me%EulerModel(em)%Lag2Euler%GridBottomConc(ILB:IUB, JLB:JUB, 1:nProp, 1:Me%NGroups))
                                                          !i,j,p,  ig 
                Me%EulerModel(em)%Lag2Euler%GridBottomMass(:,:,:,  :) = 0.
                Me%EulerModel(em)%Lag2Euler%GridBottomConc(:,:,:,  :) = 0.
                
                allocate (Me%EulerModel(em)%Lag2Euler%GridBottomNumber             (ILB:IUB, JLB:JUB, 1:Me%NGroups))
                allocate (Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber        (ILB:IUB, JLB:JUB, 1:Me%NGroups))
                allocate (Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity(ILB:IUB, JLB:JUB, 1:Me%NGroups))                
                allocate (Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume        (ILB:IUB, JLB:JUB, 1:Me%NGroups))
                allocate (Me%EulerModel(em)%Lag2Euler%GridBottomVolume             (ILB:IUB, JLB:JUB, 1:Me%NGroups))  
                
                Me%EulerModel(em)%Lag2Euler%GridBottomNumber             (:,:,:) = 0
                Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber        (:,:,:) = 0
                Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity(:,:,:) = 0.
                Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume        (:,:,:) = 0.
                Me%EulerModel(em)%Lag2Euler%GridBottomVolume             (:,:,:) = 0.
                
                if (Me%State%CriticalSlope) then
                    allocate (Me%EulerModel(em)%Lag2Euler%GridBottomSlope (ILB:IUB, JLB:JUB, 1:Me%NGroups))  
                    allocate (Me%EulerModel(em)%Lag2Euler%GridVelSlope_X  (ILB:IUB, JLB:JUB, 1:Me%NGroups))  
                    allocate (Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y  (ILB:IUB, JLB:JUB, 1:Me%NGroups))                   
                    
                    Me%EulerModel(em)%Lag2Euler%GridBottomSlope           (:,:,:) = 0.
                    Me%EulerModel(em)%Lag2Euler%GridVelSlope_X            (:,:,:) = 0.
                    Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y            (:,:,:) = 0.               
                    
                endif                
               
            endif

            if (Me%OutPut%ConcMaxTracer) then
                allocate (Me%EulerModel(em)%Lag2Euler%GridMaxTracer(ILB:IUB, JLB:JUB, KLB:KUB, 1:nProp, 1:Me%NGroups))
                                                          !i,j,k,p,ig 
                Me%EulerModel(em)%Lag2Euler%GridMaxTracer (:,:,:,:,:) = 0.
                
                if (Me%OutPut%MassTracer) then
                    allocate (Me%EulerModel(em)%Lag2Euler%GridMaxMass(ILB:IUB, JLB:JUB, KLB:KUB, 1:nProp, 1:Me%NGroups))
                                                              !i,j,k,p,ig 
                    Me%EulerModel(em)%Lag2Euler%GridMaxMass   (:,:,:,:,:) = 0.                
                endif
            endif
            
            if (Me%State%AssociateBeachProb) then
                allocate (Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(:,:,:) = 0.

                allocate (Me%EulerModel(em)%Lag2Euler%PreviousGridBeachedVolume(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%PreviousGridBeachedVolume(:,:,:) = 0.

                allocate (Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar(:,:,:) = 1.

                allocate (Me%EulerModel(em)%Lag2Euler%GridBeachedVolumeByType(ILB:IUB, JLB:JUB, 1:Me%NGroups, 1:3))
                Me%EulerModel(em)%Lag2Euler%GridBeachedVolumeByType(:,:,:,:) = 0.

                allocate (Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval(:,:,:) = 0.

                allocate (Me%EulerModel(em)%Lag2Euler%GridVolToRemove(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%GridVolToRemove(:,:,:) = 0.

                allocate (Me%EulerModel(em)%Lag2Euler%GridVolToRemoveFraction(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%GridVolToRemoveFraction(:,:,:) = 0.

                allocate (Me%EulerModel(em)%Lag2Euler%GridVolRemovedDiff(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%GridVolRemovedDiff(:,:,:) = 0.
                
                allocate (Me%EulerModel(em)%Lag2Euler%GridBeachingTime(ILB:IUB, JLB:JUB, 1:Me%NGroups))
                Me%EulerModel(em)%Lag2Euler%GridBeachingTime(:,:,:) = 0.
            endif
        enddo d1


d2:     do em =1, Me%EulerModelNumber

            ILB = Me%EulerModel(em)%Size%ILB
            IUB = Me%EulerModel(em)%Size%IUB

            JLB = Me%EulerModel(em)%Size%JLB
            JUB = Me%EulerModel(em)%Size%JUB

            KLB = Me%EulerModel(em)%Size%KLB
            KUB = Me%EulerModel(em)%Size%KUB

            if (Me%State%Deposition)  then
        
                allocate   (Me%EulerModel(em)%Lag2Euler%TauErosionGrid (ILB:IUB, JLB:JUB, 1:Me%nGroups))
                allocate   (Me%EulerModel(em)%Lag2Euler%MassSedGrid    (ILB:IUB, JLB:JUB, 1:Me%nGroups))

                Me%EulerModel(em)%Lag2Euler%TauErosionGrid (:,:,:) = 0.
                Me%EulerModel(em)%Lag2Euler%MassSedGrid    (:,:,:) = 0.

            endif

            if (Me%State%Filtration)  then

                if (Me%nGroups > 1) stop 'ConstructLag2Euler - ModuleLagrangianGlobal - ERR10'

                allocate(Me%EulerModel(em)%RelativeMassFilter(ILB:IUB,JLB:JUB,KLB:KUB))

                allocate(Me%EulerModel(em)%MassFiltered      (ILB:IUB,JLB:JUB,KLB:KUB))

                Me%EulerModel(em)%RelativeMassFilter(:,:,:) = 0. 
                Me%EulerModel(em)%MassFiltered      (:,:,:) = 0. 
            
                Me%NextFiltration = Me%Now

            endif

        enddo d2
        
        !----------------------------------------------------------------------

    end subroutine ConstructLag2Euler

    !--------------------------------------------------------------------------

    subroutine ConstructParticleGrid(EulerModel)

        !Arguments-------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel

        !Local-----------------------------------------------------------------
        integer                                     :: ILB, IUB, JLB, JUB
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: i, j, STAT_CALL
        real,    dimension (:, :), pointer          :: XX_IE, YY_IE
        integer                                     :: GEOG, UTM, MIL_PORT, SIMPLE_GEOG
        integer                                     :: GRID_COORD, CoordType, NLRD
        integer, dimension (:, :), pointer          :: DefineCellsMap
        type (T_Polygon), pointer                   :: GridBound

        !Begin-----------------------------------------------------------------



        !Shorten
        ILB    = EulerModel%Size%ILB
        IUB    = EulerModel%Size%IUB
        JLB    = EulerModel%Size%JLB
        JUB    = EulerModel%Size%JUB
        WS_ILB = EulerModel%WorkSize%ILB
        WS_IUB = EulerModel%WorkSize%IUB
        WS_JLB = EulerModel%WorkSize%JLB
        WS_JUB = EulerModel%WorkSize%JUB

        !Gets Coordinate Types List
        call GetCoordTypeList (GEOG = GEOG, UTM = UTM, MIL_PORT = MIL_PORT,             &
                               SIMPLE_GEOG = SIMPLE_GEOG, GRID_COORD = GRID_COORD,      &
                               NLRD = NLRD)

        !Gets Coordinates in use
        call GetGridCoordType(EulerModel%ObjHorizontalGrid, CoordType, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR10'


        EulerModel%Grid%CoordType = CoordType

        if (CoordType == GEOG .or. CoordType == UTM .or. CoordType == SIMPLE_GEOG)      &
            EulerModel%Grid%HaveLatLongGrid = .true.

        if (CoordType == GEOG .or. CoordType == SIMPLE_GEOG)                            &
            EulerModel%Grid%GeoGrid = .true.


        call GetLatitudeLongitude(EulerModel%ObjHorizontalGrid, Latitude  = EulerModel%Grid%LatDefault,  &
                                                                Longitude = EulerModel%Grid%LongDefault, & 
                                                                STAT      = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR20'


        !Gets Horizontal Grid
        call GetHorizontalGrid(EulerModel%ObjHorizontalGrid, XX_IE = XX_IE, YY_IE = YY_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ER30'

        call GetDefineCellsMap(EulerModel%ObjHorizontalGrid, DefineCellsMap, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR40'

        allocate(EulerModel%Grid%ParticXX(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR50'

        allocate(EulerModel%Grid%ParticYY(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR60'


        EulerModel%Grid%ParticXX(:, :) = 0.
        EulerModel%Grid%ParticYY(:, :) = 0.

        do j = WS_JLB, WS_JUB
        do i = WS_ILB,   WS_IUB

            if (DefineCellsMap(i, j) == 1) then

                EulerModel%Grid%ParticXX(i  , j  ) = (XX_IE(i,  j  ) + XX_IE(i+1, j  )) / 2.
                EulerModel%Grid%ParticXX(i  , j+1) = (XX_IE(i,  j+1) + XX_IE(i+1, j+1)) / 2.
                EulerModel%Grid%ParticYY(i  , j  ) = (YY_IE(i,  j  ) + YY_IE(i  , j+1)) / 2.
                EulerModel%Grid%ParticYY(i+1, j  ) = (YY_IE(i+1,j  ) + YY_IE(i+1, j+1)) / 2.
            endif
        
        enddo
        enddo


        call UnGetHorizontalGrid(EulerModel%ObjHorizontalGrid, XX_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR70'

        call UnGetHorizontalGrid(EulerModel%ObjHorizontalGrid, YY_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR80'

        call UnGetHorizontalGrid(EulerModel%ObjHorizontalGrid, DefineCellsMap, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR90'
        
        call GetGridOutBorderPolygon(EulerModel%ObjHorizontalGrid, GridBound)
        
        call Add(Me%GridsBounds, GridBound)
        
        call UngetHorizontalGrid(HorizontalGridID = EulerModel%ObjHorizontalGrid,       &
                                 Polygon          = GridBound,                          &
                                 STAT             = STAT_CALL)                          
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticleGrid - ModuleLagrangianGlobal - ERR100'


    end subroutine ConstructParticleGrid    

    !--------------------------------------------------------------------------

    subroutine ConstructOrigins

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel        
        integer                                     :: flag
        integer                                     :: STAT_CALL
        integer                                     :: ClientNumber, ClientNumberClone
        real                                        :: DT, DT_PARTIC, MinError
        logical                                     :: BlockFound
        type (T_Origin), pointer                    :: NewOrigin, OriginalOrigin
        logical                                     :: FoundCloneOrigin, ClonesExist
        integer                                     :: Nmax, no, em 
        real                                        :: Xcenter, Ycenter
        real, dimension(2)                          :: Aux2

        !Begin-----------------------------------------------------------------

        nullify(Me%OriginDefault)


        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime      = Me%ExternalVar%Now,                       &
                           EndTime          = Me%ExternalVar%EndTime,                   &
                           keyword          = 'OUTPUT_TIME',                            &
                           SearchType       = FromFile,                                 &
                           OutPutsTime      = Me%OutPut%OutTime,                        &
                           OutPutsOn        = Me%OutPut%Write_,                         &
                           OutPutsNumber    = Me%OutPut%TotalOutputs,                   &                           
                           STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR10'

        if (Me%OutPut%Write_) then
            Me%OutPut%NextOutPut = 1
        endif
        
        Me%OutPut%WriteRestartFile = .false. 

        call GetOutPutTime(Me%ObjEnterData,                                             &
                           CurrentTime = Me%ExternalVar%Now,                            &
                           EndTime     = Me%ExternalVar%EndTime,                        &
                           keyword     = 'RESTART_FILE_OUTPUT_TIME',                    &
                           SearchType  = FromFile,                                      &
                           OutPutsTime = Me%OutPut%RestartOutTime,                      &
                           OutPutsOn   = Me%OutPut%WriteRestartFile,                    &
                           STAT        = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR11'

        if(Me%OutPut%WriteRestartFile)then

            Me%OutPut%NextRestartOutput = 1

        end if 

        !Checks wether to overwrite the Restart File OR not
        call GetData(Me%OutPut%RestartOverwrite,                                        &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='RESTART_FILE_OVERWRITE',                            &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .true.,                                             &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR12'

        !Output Concentration Type
        call GetData(Me%OutPut%OutPutConcType,                                          &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='OUTPUT_CONC',                                       &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = Maximum,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR20'

        !Output results in netcdf format
        call GetData(Me%OutPut%NetCDF,                                                  &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='OUTPUT_NETCDF',                                     &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR25'        

        !Checks if the users wants to output the maximum tracer concentration in each cell
        call GetData(Me%OutPut%ConcMaxTracer,                                           &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='OUTPUT_MAX_TRACER',                                 &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR30'


        !Checks if the users wants to output the mass per cell
        call GetData(Me%OutPut%MassTracer,                                              &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='OUTPUT_MASS_TRACER',                                &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR30'

        call GetData(Me%OutPut%OriginEnvelope,                                          & 
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='OUTPUT_ORIGIN_ENVELOPE',                            &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR40'

        !Write origin envelope to text file, in case of origin envelope output is on
        if (Me%OutPut%OriginEnvelope) then
            call GetData(Me%OutPut%OutputEnvelopeTimeSeries,                                 & 
                         Me%ObjEnterData,                                                   &
                         flag,                                                              &
                         SearchType   = FromFile,                                           &
                         keyword      ='OUTPUT_ENVELOPE_TIMESERIE',                         &
                         ClientModule ='ModuleLagrangianGlobal',                            &
                         Default      = .false.,                                            &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR44'
        end if

        !Write dummy particle in the start date if start emission > start date 
        call GetData(Me%OutPut%DummyParticleStartDate,                                  &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='WRITE_DUMMY_PART',                                  &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR45'
        
        !Write arrival and beaching times in grid data format 
        call GetData(Me%OutPut%ExportArrvlBeachTimes,                                   &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='EXPORT_ARRIVAL_BEACH_TIMES',                        &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR46'
        
        call ReadFileName("ROOT_SRT", Me%OutPut%RootPath, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR47'

        call GetComputeTimeStep(Me%ExternalVar%ObjTime, DT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR70'

        !Get time step for particle from file
        DT_PARTIC = null_real
        call GetData(DT_PARTIC,                                                         &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='DT_PARTIC',                                         &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR80'
                          
        !Checks time steps
        if (flag .EQ. 0) then
            DT_PARTIC = DT
        else
            if (DT_PARTIC > DT) then
                if (amod(DT_PARTIC, DT) == 0.0) then
                    !OK
                else
                    write(*,*)'Particle Time step : ', DT_PARTIC
                    write(*,*)'Model    Time step : ', DT
                    write(*,*)'Particle Time step must multiply or submultiply of Model Time step'
                    stop      'ConstructOrigins - ModuleLagrangianGlobal - ERR90'
                endif
            elseif (DT > DT_PARTIC) then
                !if (amod(DT, DT_PARTIC) == 0.0) then
                    !OK
                !else
                !    write(*,*)'Particle Time step : ', DT_PARTIC
                !    write(*,*)'Model    Time step : ', DT
                !    write(*,*)'Particle Time step must multiply or submultiply of Model Time step'
                !    stop      'ConstructOrigins - ModuleLagrangianGlobal - ERR100'
                !endif
            
                !The run period must be a multiple of the model DT
                !The abs function is used, to avoid rounding erros
                !The old way was removed, to be able to run with Timesteps lower tehn 1 sec
                !Frank Dec - 2000
                MinError = min (abs(mod (DT, DT_PARTIC)),                               &
                                abs(DT_PARTIC - mod (DT, DT_PARTIC)))
                if (MinError >= 1.e-5) then
                    write(*,*)' Time step error DT_PARTIC - Run period must be a multiple of DT'
                    stop      'ConstructOrigins - ModuleLagrangianGlobal - ERR110.' 
                endif
            endif
        end if

        !Sets time step
        Me%DT_Partic   = DT_PARTIC
        Me%NextCompute = Me%ExternalVar%Now + Me%DT_Partic
        Me%Now         = Me%ExternalVar%Now
        
        !Get number of vertical time steps along DT_PARTIC
        call GetData(Me%VERT_STEPS,                                                     &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='VERT_STEPS',                                        &
                     default      = 1 ,                                                 &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR230'        
        
        
        !OutputTracerInfo
        call GetData(Me%State%OutputTracerInfo,                                     &
                     Me%ObjEnterData,                                               &
                     flag,                                                          &
                     SearchType   = FromFile,                                       &
                     keyword      ='OUTPUT_TRACER_INFO',                            &
                     ClientModule ='ModuleLagrangianGlobal',                              &
                     Default      = .false.,                                        &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR235'

        call BoxTypeVariablesDefiniton
        
        call PolyMonitorLag
        
        !OVERLAY_VELOCITY
        call GetData(Me%Overlay,                                                        &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='OVERLAY_VELOCITY',                                  &
                     ClientModule ='ModuleLagrangianGlobal',                            &  
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR240'
        

        call GetData(Me%CoastLineFile,                                              &
                     Me%ObjEnterData,                                               &
                     flag,                                                          &
                     SearchType   = FromFile,                                       &
                     keyword      ='COASTLINE_FILE',                                &
                     ClientModule ='ModuleLagrangianGlobal',                        &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR242'
            
        if (flag == 0) then
            Me%CoastLineON  = .false.
        else
            Me%CoastLineON  = .true.
            call New(Me%CoastLine, Me%CoastLineFile, Me%GridsBounds)
        endif       
        

        call GetData(Me%ThinWallsFile,                                              &
                     Me%ObjEnterData,                                               &
                     flag,                                                          &
                     SearchType   = FromFile,                                       &
                     keyword      ='THINWALLS_FILE',                                &
                     ClientModule ='ModuleLagrangianGlobal',                        &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR243'
            
        if (flag == 0) then
            Me%ThinWallsON  = .false.
        else
            Me%ThinWallsON  = .true.
            call New(Me%ThinWalls, Me%ThinWallsFile, Me%GridsBounds)
        endif      
        
        call GetData(Me%BeachAreaFile,                                              &
                     Me%ObjEnterData,                                               &
                     flag,                                                          &
                     SearchType   = FromFile,                                       &
                     keyword      ='BEACH_AREA_FILE',                               &
                     ClientModule ='ModuleLagrangianGlobal',                        &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR243'
            
        if (flag == 0) then
            Me%BeachAreaON  = .false.
        else
            Me%BeachAreaON  = .true.
            call New(Me%BeachArea, Me%BeachAreaFile, Me%GridsBounds)
        endif      
        
 
        call GetData(Aux2,                                                              &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='NEW_GRID_CENTER',                                   &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR244'
            
        if (flag /= 2) then
            Me%NewGridLocation = .false.
        else
            Xcenter = Aux2(1)
            Ycenter = Aux2(2)
            Me%NewGridLocation  = .true.
        endif
        
        if (Me%NewGridLocation) then

em4:        do em =1, Me%EulerModelNumber

                EulerModel => Me%EulerModel(em)

                call ReadUnLockHorizontalGrid(EulerModel)
                
                !Recenter the model grid
                call ReCenterHorizontalGrid(EulerModel%ObjHorizontalGrid, Xcenter, Ycenter, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR245'
                
                call ReadLockHorizontalGrid  (EulerModel)
            enddo em4 
        
        endif
        
        !Prepares file for a new block search throughout the entire file
        call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR250'

        FoundCloneOrigin = .false.
        ClonesExist      = .true.

        Nmax        = 1
!        FirstExtraction = .true. 
        !NFirstExtraction = 0


        !Run module lagrangian online
        call GetData(Me%RunOnline,                                                      &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='RUN_ONLINE',                                        &
                     ClientModule ='ModuleLagrangianGlobal',                            &  
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR260'


!#ifdef _CGI_

        if (Me%RunOnline) then

            call ReadQueryString(Nmax)

        endif

!#endif
        !This option allows the definition of discharges in land points without crashing the model
        !When this happens a message is send to the user and the discharge is not considered 
        !This is something done in the framework of COWAMA project
        call GetData(Me%IgnoreON,                                                       &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='IGNORE_ON',                                         &
                     ClientModule ='ModuleLagrangianGlobal',                            &  
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR270'
        

        call GetData(Me%AveragePositionON,                                              &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='COMPUTE_AVERAGE_POSITION',                          &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR280'

        if (Me%AveragePositionON) then
        
            call GetData(Me%CoefRadius,                                                 &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='COEF_RADIUS',                                   &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         !90% of the particles inside the circle
                         Default      = 1.645,                                          &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR290'
            
        endif     
        
        call GetData(Me%VoronoiVolume,                                                  &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='VORONOI_VOLUME',                                    &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR400'        
        
        call GetData(Me%StopWithNoPart,                                                 &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='STOP_WITH_NO_PART',                                 &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR390'           

        
        call GetData(Me%LitterON,                                                       &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='LITTER_ON',                                         &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR410'    
        
        if (Me%State%AssociateBeachProb .and. Me%LitterON) then
            stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR415' 
        endif
        

        
        !Number of times it read the lagrangian data looking for origins
        !Only when the _CGI_ option is on is able to read several times 
        !the origin blocks
SB:     do no = 1, Nmax

DW:     do  

            if (FoundCloneOrigin) then

                BlockFound      = .true. 

            else 

                call ExtractBlockFromBuffer(Me%ObjEnterData,                            &
                                            ClientNumber,                               &
                                            block_begin, block_end,                     &
                                            BlockFound,                                 &
                                            STAT = STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR300'

            endif

BF:         if (BlockFound) then 

!                if (FirstExtraction) then 
                    !NFirstExtraction = NFirstExtraction + 1
!                endif

                !Done for the COWAMA project. Allows not consider discharges define in land points without stopping the model  
                if (.not.(Me%IgnoreON .and. CheckOriginInLandCell())) then
                    
                    !Allocates a new origin
                    call AllocateNewOrigin(NewOrigin)

                    if (.not. FoundCloneOrigin) then
                        nullify(OriginalOrigin)
                        OriginalOrigin => NewOrigin
                    endif


                    call ConstructOneOrigin(NewOrigin, ClientNumber)              

                    if (NewOrigin%Default) then

                        Me%OriginDefault => NewOrigin

                    else

                        !Insert New Origin to the list of origins    
                        call InsertOriginToList (Me%FirstOrigin, NewOrigin, Me%nOrigins)

                    endif

                endif

                if (ClonesExist) then
                    call CheckForOriginClones(OriginalOrigin%Name, ClientNumber,        &
                                              ClientNumberClone, FoundCloneOrigin, ClonesExist)
                endif
 
            else BF
            
!                FirstExtraction = .false. 

                exit DW !No more blocks

            end if BF

        end do DW

        end do SB

        if (.not. Me%State%OriginDefault) Me%OriginDefault => Me%FirstOrigin


        !Finished reading block -> unlocks block reading
        call Block_Unlock(Me%ObjEnterData,                                              &
                          ClientNumber,                                                 &
                          STAT = STAT_CALL) 
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1600'

        if (Me%ObjEnterDataClone   /= 0)  then
            !Finished reading block -> unlocks block reading
            call Block_Unlock(Me%ObjEnterDataClone,                                     &
                              ClientNumberClone,                                        &
                              STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1610'

            call KillEnterData(Me%ObjEnterDataClone, STAT = STAT_CALL)  

            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1620'
        endif

        if (Me%ObjEnterDataOriginal /= 0) then
            call KillEnterData(Me%ObjEnterDataOriginal, STAT = STAT_CALL)  
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1630'
        endif

!#ifdef _CGI_

        if (Me%RunOnline) then

            call ChangeOriginOnline(Nmax) ! , NFirstExtraction)
        endif

!#endif

        nullify(OriginalOrigin, NewOrigin)

    end subroutine ConstructOrigins

    !--------------------------------------------------------------------------


    subroutine ConstructOneOrigin(NewOrigin, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: NewOrigin
        integer                                     :: ClientNumber

        !Local-----------------------------------------------------------------
        integer                                     :: flag
        integer                                     :: STAT_CALL
        character(3)                                :: Aux
        character(StringLength)                     :: EmissionSpatial
        character(StringLength)                     :: EmissionTemporal
        character(PathLength)                       :: String, String2, RootPath
        real, dimension(:), allocatable             :: Aux2
        real, dimension(1:2)                        :: Position
        real                                        :: Depth , TotalVolume
        logical                                     :: HaveOrigin, PropertyFound, NoDomain
        type (T_Property), pointer                  :: NewProperty
        integer                                     :: i, j, k, KUB
        logical                                     :: ret
        integer                                     :: PropertyID, DensityMethod
        logical                                     :: WP_HaveProperty, SedimentDefined = .false.
        logical                                     :: SalOK = .false., TempOK = .false., PressureCorrection
        integer                                     :: em
        real                                        :: OdourConcThreshold
        logical                                     :: FindWaterLocation, FoundWater
        real                                        :: EmissionDuration
        integer                                     :: dir
        integer                                     :: iLine, FirstLine, LastLine, nClasses 
        logical                                     :: BlockFound
        type (T_Time)                               :: AuxTimeStart, AuxTimeStop

        !Begin-----------------------------------------------------------------

        call GetData(NewOrigin%Default,                                         &
                     Me%ObjEnterData,                                           &
                     flag,                                                      &
                     SearchType   = FromBlock,                                  &
                     keyword      ='DEFAULT',                                   &
                     ClientModule ='ModuleLagrangianGlobal',                    &
                     Default      = OFF,                                        &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR250'

        if (NewOrigin%Default) then
            if  (Me%State%OriginDefault) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR260'
            else
                Me%State%OriginDefault = .true. 
            endif
        endif

        !Gets its name    
        call GetData(NewOrigin%Name,                                            &
                     Me%ObjEnterData,                                           &
                     flag,                                                      &
                     SearchType   = FromBlock,                                  &
                     keyword      ='ORIGIN_NAME',                               &
                     ClientModule ='ModuleLagrangianGlobal',                    &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR270'

        if (flag == 0) then
            Aux = ' '
            write(Aux,'(i3)') Me%nOrigins + 1
            NewOrigin%Name = trim(adjustl('Origin_'//trim(adjustl(Aux))))
        end if

        !Old Origin    
        call GetData(NewOrigin%Old,                                              &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='OLD',                                        &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     Default      = .false.,                                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR280'

        if (NewOrigin%Old) then
            Me%State%ContCalc = .true.
        endif

        !Group ID
        call GetData(NewOrigin%GroupID,                                          &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='GROUP_ID',                                   &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     Default      = 1,                                           &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR290'


        !Gets the spatial emission type
        call GetData(EmissionSpatial,                                            &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='EMISSION_SPATIAL',                           &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR300'

        !Gets the temporal emission type
        call GetData(EmissionTemporal,                                           &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='EMISSION_TEMPORAL',                          &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR310'



        !Gets the temporal emission type
        call GetData(NewOrigin%EmissionON,                                              &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='EMISSION_ON',                                       &
                     default      = ON,                                                 &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR315'


        !Converts Strings to int
        call ConstructEmissionType(NewOrigin, EmissionSpatial, EmissionTemporal)

IT:     if (NewOrigin%EmissionTemporal == Instantaneous_) then

            !Gets the interval between emissions
            call GetData(NewOrigin%InstantEmission,                              &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='INSTANT_PARTIC_EMIT',                    &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         Default      = Me%ExternalVar%BeginTime,                &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR320'
            
            NewOrigin%StartEmission = NewOrigin%InstantEmission

        endif IT
        !
ET:     if (NewOrigin%EmissionTemporal == Continuous_) then

            !Gets the interval between emissions
            call GetData(NewOrigin%DT_Emit,                                      &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='DT_EMIT',                                &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         Default      = Me%DT_Partic,                            &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR325'
            
            !Gets the duration of the emission starting from the simulation initial time
            call GetData(EmissionDuration,                                       &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='EMISSION_DURATION',                      &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         Default      = null_real,                               &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR326'

            if(flag == 1)then
            
                if(EmissionDuration < 0.) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR327'
            
                NewOrigin%StartEmission = Me%ExternalVar%BeginTime
                NewOrigin%StopEmission  = Me%ExternalVar%BeginTime + EmissionDuration

            
            elseif(flag == 0)then
            
                !Gets the interval between emissions
                call GetData(NewOrigin%StartEmission,                            &
                             Me%ObjEnterData,                                    &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='START_PARTIC_EMIT',                  &
                             ClientModule ='ModuleLagrangianGlobal',             &
                             Default      = Me%ExternalVar%BeginTime,            &
                             STAT         = STAT_CALL)        
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR330'
                

                !Gets the interval between emissions
                call GetData(NewOrigin%StopEmission,                             &
                             Me%ObjEnterData,                                    &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='STOP_PARTIC_EMIT',                   &
                             ClientModule ='ModuleLagrangianGlobal',             &
                             Default      = Me%ExternalVar%EndTime,              &
                             STAT         = STAT_CALL)        
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR340'

                if (Me%ExternalVar%Backtracking) then  
                    
                    AuxTimeStart = NewOrigin%StopEmission
                    AuxTimeStop = NewOrigin%StartEmission 
                    
                    call BacktrackingTime(NowIn = AuxTimeStop,  NowOut = NewOrigin%StopEmission)                       
                    call BacktrackingTime(NowIn = AuxTimeStart, NowOut = NewOrigin%StartEmission)                       
                    
                endif                                    
                
                
            endif

            !Gets flow associated to a continuous emission
iP:         if (NewOrigin%EmissionSpatial == Point_) then


                !Flow variable in time
                call GetData(NewOrigin%FlowVariable,                            &
                             Me%ObjEnterData,                                   &
                             flag,                                              &
                             SearchType   = FromBlock,                          &
                             keyword      ='FLOW_VARIABLE',                     &
                             ClientModule ='ModuleLagrangianGlobal',            &
                             STAT         = STAT_CALL)        
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR360'

iFV:            if (NewOrigin%FlowVariable) then

                    !Discharge file name
                    call GetData(NewOrigin%DischargeFile,                               &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='DISCHARGE_FILE',                        &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR370'

                    !flow column
                    call GetData(NewOrigin%FlowColumn,                          &
                                 Me%ObjEnterData,                               &
                                 flag,                                          &
                                 SearchType   = FromBlock,                      &
                                 keyword      ='FLOW_COLUMN',                   &
                                 ClientModule ='ModuleLagrangianGlobal',        &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR373'
                    
                    if (flag == 0) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR375'

                    !flow scale factor
                    call GetData(NewOrigin%FlowScaleFactor,                     &
                                 Me%ObjEnterData,                               &
                                 flag,                                          &
                                 SearchType   = FromBlock,                      &
                                 keyword      ='FLOW_SCALE_FACTOR',             &
                                 Default      = 1.,                             &
                                 ClientModule ='ModuleLagrangianGlobal',        &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR378'

                    call GetData(NewOrigin%EstimateMinVol,                      &
                                 Me%ObjEnterData,                               &
                                 flag,                                          &
                                 SearchType   = FromBlock,                      &
                                 keyword      ='ESTIMATE_MIN_VOL',              &
                                 Default      = .false.,                        &
                                 ClientModule ='ModuleLagrangianGlobal',        &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR380'

iMV:                if (NewOrigin%EstimateMinVol) then

                        call GetData(NewOrigin%MaxPart,                                 &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlock,                          &
                                     keyword      ='MAX_PART',                          &
                                     Default      = 10000,                              &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     STAT         = STAT_CALL)        
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR383'
                    endif iMV ! Rosa

                        call GetData(NewOrigin%MaxVol,                                  &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlock,                          &
                                     keyword      ='MAX_VOLUME',                        &
                                     Default      = -FillValueReal,                     &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     STAT         = STAT_CALL)        
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR385'
                    

iDF:                if (.not. NewOrigin%Default) then
                        call StartTimeSerieInput(NewOrigin%TimeSerieInputFlow,          &
                                                 NewOrigin%DischargeFile,               &
                                                 Me%ExternalVar%ObjTime,                &
                                                 STAT = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR388'

                    endif iDF

                endif iFV

                    !get default flow of the origin
                    call GetData(NewOrigin%Flow,                                &
                                 Me%ObjEnterData,                               &
                                 flag,                                          &
                                 SearchType   = FromBlock,                      &
                                 keyword      ='FLOW',                          &
                                 default      = 1.,                             &
                                 ClientModule ='ModuleLagrangianGlobal',        &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR390'
                    if (flag /= 1 .and. .not. NewOrigin%FlowVariable) then
                        write(*,*)'Keyword FLOW not defined at origin :',trim(adjustl(NewOrigin%Name))
                        stop      'ConstructOneOrigin - ModuleLagrangianGlobal - ERR393'
                
                    endif 

                call GetData(NewOrigin%MovingOrigin,                                    &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             default      = .false.,                                    &
                             keyword      ='MOVING_ORIGIN',                             &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)        
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR400'

                if (NewOrigin%MovingOrigin) then

                    call GetData(NewOrigin%MovingOriginFile,                            &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='MOVING_ORIGIN_FILE',                    &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_ .or. flag /= 1) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR410'

                    call GetData(NewOrigin%MovingOriginUnits,                           &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 default      = 'Cells',                                &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='MOVING_ORIGIN_UNITS',                   &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR420'


                    call GetData(NewOrigin%MovingOriginColumnX,                         &
                                 Me%ObjEnterData,                                       & 
                                 flag,                                                  &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='MOVING_ORIGIN_COLUMN_X',                &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_ .or. flag /= 1) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR430'

                    call GetData(NewOrigin%MovingOriginColumnY,                         &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='MOVING_ORIGIN_COLUMN_Y',                &  
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_ .or. flag /= 1) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR440'

                    call GetData(NewOrigin%MovingOriginCloudEmission,                   &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='MOVING_ORIGIN_CLOUD_EMISSION',          &
                                 default      = .false.,                                &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_ ) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR445'

                    if (.not. NewOrigin%Default) then
                        call StartTimeSerieInput(NewOrigin%ObjTimeSerie,                &
                                                 NewOrigin%MovingOriginFile,            &
                                                 Me%ExternalVar%ObjTime,                &
                                                 STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR450'
                    endif
    

                endif

            endif iP

        endif ET

        if (NewOrigin%EmissionSpatial  == Accident_      .or.                           &
           (NewOrigin%EmissionSpatial  == Point_         .and.                          &
           (NewOrigin%EmissionTemporal == Instantaneous_ .or. NewOrigin%FlowVariable    &
           .or. NewOrigin%MovingOriginCloudEmission))) then
            call GetData(NewOrigin%PointVolume,                                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='POINT_VOLUME',                                  &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR460'
            if (flag /= 1) then
                write(*,*)'Keyword POINT_VOLUME not defined at origin :',trim(adjustl(NewOrigin%Name))
                stop      'ConstructOneOrigin - ModuleLagrangianGlobal - ERR29'
            endif
        endif
        
        if ((NewOrigin%EmissionSpatial  == Box_ .or.                                    &
             NewOrigin%EmissionSpatial  == Poly_) .and.                                 &
             NewOrigin%EmissionTemporal == Instantaneous_) then
            call GetData(NewOrigin%PointVolume,                                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='POINT_VOLUME',                                  &
                         default      = 0.,                                             &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR465'
        endif        

i23:    if (NewOrigin%TimeSerieInputFlow /= 0) then

            if (.not. NewOrigin%Default .and. NewOrigin%EstimateMinVol) then

                TotalVolume = GetTimeSerieIntegral(NewOrigin%TimeSerieInputFlow,        &
                                                   Me%ExternalVar%BeginTime, Me%ExternalVar%EndTime, &
                                                   NewOrigin%FlowColumn, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR384.'
                
                TotalVolume = TotalVolume * NewOrigin%FlowScaleFactor

                if (TotalVolume > 0.) then
                    NewOrigin%PointVolume = max (TotalVolume/real(NewOrigin%MaxPart), NewOrigin%PointVolume)
                    if (NewOrigin%PointVolume > NewOrigin%MaxVol) then
                        write(*,*) 'Particle volume ', NewOrigin%PointVolume, 'larger than maximum volume allowed ',NewOrigin%MaxVol
                        stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR385.'
                    endif
                endif

            endif 
        endif i23

        !Time to double volume
        call GetData(NewOrigin%Movement%TVOL200,                                 &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='TVOL200',                                    &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR470'

        if (flag == 1) then
            NewOrigin%State%VariableGeom = ON
            Me%State%VariableGeom        = ON
        endif

        
        !Split particle
        call GetData(NewOrigin%Movement%SPLIT_PART,                              &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      = 'SPLIT_PART',                                &
                     Default      = OFF,                                         &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR480'


        !Volume Factor when Particle dies
        call GetData(NewOrigin%Movement%VOLFAC,                                  &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      = 'VOLFAC',                                    &
                     Default      = 10.,                                         &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR490'

        !How to calculate volume increase
        call GetData(String2,                                                    &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      = 'VOLUME_INCREASE',                           &
                     Default      = Char_Double,                                 &
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR500'

        select case (trim(adjustl(String2)))

        case (Char_Velocity)

            NewOrigin%Movement%TVolType = Velocity_

        case (Char_Double)

            NewOrigin%Movement%TVolType = Double_

        case default

            write(*,*)'Invalid option for keyword VOLUME_INCREASE'
            write(*,*)
            stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR510'

        end select


        !Floating Particle
        call GetData(NewOrigin%Movement%Float,                                   &
                     Me%ObjEnterData,                                 &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='FLOAT',                                      &
                     Default      = OFF,                                         &
                     ClientModule ='ModuleLagrangianGlobal',                           &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR520'

    
        !Calculates Plume
        call GetData(NewOrigin%State%FarFieldBuoyancy,                                  &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='COMPUTE_BUOYANCY',                                  &
                     Default      = OFF,                                                &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR530'

        
        if (NewOrigin%State%FarFieldBuoyancy) then

            Me%State%FarFieldBuoyancy = .true.

            NewOrigin%Movement%InitialVelocityW = 0.

        endif

   
        !Type of Accident
AC:     if (NewOrigin%EmissionSpatial == Accident_) then

            call GetData(NewOrigin%AccidentMethod,                                      &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='ACCIDENT_METHOD',                               &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = Fay_,                                           &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR670'

            call GetData(NewOrigin%AccidentTime,                                        &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='ACCIDENT_TIME',                                 &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = Me%ExternalVar%BeginTime,                       &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR680'

            NewOrigin%StartEmission = NewOrigin%AccidentTime
        endif AC

        !Particle Thickness                
        if (NewOrigin%Movement%Float) then
            Me%State%Wind = ON

            if (NewOrigin%EmissionSpatial == Accident_ .and.                           &
                 NewOrigin%AccidentMethod == Thickness_) then                         
                call GetData(NewOrigin%Movement%ThicknessMeters,                        &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='THICKNESS_METERS',                          &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR690'
                if (flag /= 1) then
                    write(*,*)'Keyword THICKNESS_METERS not defined at origin :',trim(adjustl(NewOrigin%Name))
                    stop      'ConstructOneOrigin - ModuleLagrangianGlobal - ERR38'
                endif
            endif

        endif


        !Movement type
        call GetData(String,                                                            &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='MOVEMENT',                                          &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR700'

MO:     if (flag == 1) then

            select case(trim(adjustl(String)))
            
            case(Char_DiffusionCoef)
                
                NewOrigin%Movement%DiffusionCoefHON = .false.

                NewOrigin%Movement%MovType = DiffusionCoef_

                ! ---> Definition of the Horizontal and Vertical turbulent diffusion
                call GetData(NewOrigin%Movement%DiffusionCoefH,                         &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      = 'DIFFUSION_H',                              &
                             ClientModule ='ModuleLagrangianGlobal',                    &  
                             Default      = 1.0,                                        &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR705'
                
                if (flag /= 0) then
                    NewOrigin%Movement%DiffusionCoefHON = .true.
                endif        
                
                NewOrigin%Movement%DiffusionCoefVON = .false.

                call GetData(NewOrigin%Movement%DiffusionCoefV,                         &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      = 'DIFFUSION_V',                              &
                             ClientModule ='ModuleLagrangianGlobal',                    &  
                             Default      = 0.001,                                      &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR707'  
                
                if (flag /= 0) then
                    NewOrigin%Movement%DiffusionCoefVON = .true.
                endif                
                
            case(Char_SullivanAllen)
                NewOrigin%Movement%MovType = SullivanAllen_

                ! ---> Definition of the Horizontal and Vertical variance in 
                !      the form of a percentage of the average velocity      
                ! StandardDeviation = VarVelHX * Vel + VarVelH
                call GetData(NewOrigin%Movement%VarVelHX,                        &
                             Me%ObjEnterData,                         &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='VARVELHX',                           &
                             ClientModule ='ModuleLagrangianGlobal',                   &  
                             Default      = 0.2,                                 &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR710'


                call GetData(NewOrigin%Movement%VarVelH,                         &
                             Me%ObjEnterData,                         &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='VARVELH',                            &
                             ClientModule ='ModuleLagrangianGlobal',                   &  
                             Default      = 0.0,                                 &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR720'


                call GetData(String2,                                            &
                             Me%ObjEnterData,                         &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='TURB_V',                             &
                             ClientModule ='ModuleLagrangianGlobal',                   &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR730'

TURB_V:                 if (flag == 1) then   

                    select case(trim(adjustl(String2)))
                    
                    case(Char_Constant)

                        NewOrigin%Movement%StandardDeviationType = VerticalTurbConstant

                        call GetData(NewOrigin%Movement%VarVelVX,                &
                                     Me%ObjEnterData,                 &
                                     flag,                                       &
                                     SearchType   = FromBlock,                   &
                                     keyword      ='VARVELVX',                   &
                                     ClientModule ='ModuleLagrangianGlobal',           &  
                                     Default      = 0.0,                         &
                                     STAT         = STAT_CALL)             
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR740'


                        call GetData(NewOrigin%Movement%VarVelV,                 &
                                     Me%ObjEnterData,                 &
                                     flag,                                       &
                                     SearchType   = FromBlock,                   &
                                     keyword      ='VARVELV',                    &
                                     ClientModule ='ModuleLagrangianGlobal',           &  
                                     Default      = 0.0,                         &
                                     STAT         = STAT_CALL)             
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR750'

                    case(Char_Profile )

                        NewOrigin%Movement%StandardDeviationType = VerticalTurb
                        
                        !Will need shear velocity    
                        Me%State%ShearVel = ON
                        
                        !Sets unused variables to dummy
                        NewOrigin%Movement%VarVelVX  = null_real
                        NewOrigin%Movement%VarVelV   = null_real

                    case default

                        write(*,*)'Invalid option for TURB_V'
                        stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR760'

                    end select

                else TURB_V
                
                    write(*,*)'Keyword TURB_V not found'
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR780'

                endif TURB_V

            case(Char_NotRandom    )

                NewOrigin%Movement%MovType = NotRandom_

            case default

                write(*,*)'Invalid horizontal movement keyword'
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR790'
         
            end select
            
            
            if (NewOrigin%Movement%MovType /= NotRandom_) then

                call GetData(NewOrigin%Movement%TurbGradK,                              &
                                Me%ObjEnterData,                                        &
                                flag,                                                   &
                                SearchType   = FromBlock,                               &
                                keyword      ='TURB_GRADIENT_K',                        &
                                ClientModule ='ModuleLagrangianGlobal',                 &  
                                Default      = .true.,                                  &
                                STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR795'     
                
            endif

        else MO

            write(*,*)'Keyword MOVEMENT not defined at origin', trim(adjustl(NewOrigin%Name))
            stop      'ConstructOneOrigin - ModuleLagrangianGlobal - ERR800'
        end if MO


        !Advection
        call GetData(NewOrigin%Movement%Advection,                               &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='ADVECTION',                                  &
                     ClientModule ='ModuleLagrangianGlobal',                           &  
                     Default      = ON,                                          &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR810'

        if (NewOrigin%Movement%Advection) then

            !Vertical Advection
            call GetData(NewOrigin%Movement%AdvectionZ,                              &
                         Me%ObjEnterData,                                            &
                         flag,                                                       &
                         SearchType   = FromBlock,                                   &
                         keyword      ='ADVECTION_Z',                                &
                         ClientModule ='ModuleLagrangianGlobal',                     &  
                         Default      = ON,                                          &
                         STAT         = STAT_CALL)             
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR815'

        else
        
            NewOrigin%Movement%AdvectionZ = NewOrigin%Movement%Advection
        
        endif

        !Kill Land Particles
        call GetData(NewOrigin%Movement%KillLandParticles,                       &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='KILL_LAND_PARTICLES',                        &
                     ClientModule ='ModuleLagrangianGlobal',                     &  
                     Default      = OFF,                                         &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR820'


        call GetData(NewOrigin%State%StokesDrift,                                       &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='STOKES_DRIFT',                                      &
                     ClientModule ='ModuleLagrangianGlobal',                            &  
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR830'


        if (NewOrigin%State%StokesDrift) then

            Me%State%StokesDrift = .true.

            call GetData(String,                                                            &
                         Me%ObjEnterData,                                                   &
                         flag,                                                              &
                         SearchType   = FromBlock,                                          &
                         keyword      ='STOKES_DRIFT_METHOD',                               &
                         ClientModule ='ModuleLagrangianGlobal',                            &  
                         Default      = Char_LonguetHigginsGeneric,                         &
                         STAT         = STAT_CALL)             
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR831'
            
            select case (trim(adjustl(String)))
            
!            case (Char_Seatrackweb2007)
!                NewOrigin%Movement%StokesDriftMethod = Seatrackweb2007
!                call GetData(NewOrigin%Movement%R_ice,                                      &
!                             Me%ObjEnterData,                                               &
!                             flag,                                                          &
!                             SearchType   = FromBlock,                                      &
!                             keyword      ='R_ICE',                                         &
!                             ClientModule ='ModuleLagrangianGlobal',                        &  
!                             Default      = 1.,                                             &
!                             STAT         = STAT_CALL)             
!                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR832'
            case (Char_LonguetHigginsDeep)
                NewOrigin%Movement%StokesDriftMethod = LonguetHigginsDeep
            case (Char_LonguetHigginsGeneric)
                NewOrigin%Movement%StokesDriftMethod = LonguetHigginsGeneric
            case (Char_Ardhuin)
                NewOrigin%Movement%StokesDriftMethod = Ardhuin

            case default
                write(*,*)'Invalid Stokes Drift method'
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR833'
                       
            end select

        endif 

        !WINDCOEF
        call GetData(NewOrigin%Movement%WindTransferCoef,                        &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='WINDCOEF',                                   &
                     ClientModule ='ModuleLagrangianGlobal',                     &  
                     Default      = 0.03,                                        &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR834'

        if (flag /=0) Me%State%Wind = .true. 

        !WINDDRIFTCORRECTION
        call GetData(NewOrigin%Movement%WindDriftCorrection,                     &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='WINDDRIFTCORRECTION',                        &
                     ClientModule ='ModuleLagrangianGlobal',                     &  
                     Default      = NoCorrection_,                               &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR835'
        
        if (NewOrigin%Movement%WindDriftCorrection /= NoCorrection_ .and.               &
            NewOrigin%Movement%WindDriftCorrection /= UserDefined_  .and.               &
            NewOrigin%Movement%WindDriftCorrection /= Computed_Samuels_)    then
            stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR836'
        endif            

        !WINDDRIFTANGLE
        if (NewOrigin%Movement%WindDriftCorrection .EQ. UserDefined_) then
            call GetData(NewOrigin%Movement%WindDriftAngle,                          &
                         Me%ObjEnterData,                                            &
                         flag,                                                       &
                         SearchType   = FromBlock,                                   &
                         keyword      ='WINDDRIFTANGLE',                             &
                         ClientModule ='ModuleLagrangianGlobal',                     &  
                         Default      = 0.,                                          &
                         STAT         = STAT_CALL)             
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR840'
        end if


        allocate(Aux2(2))

        Aux2(1:2) = 0

        !WINDXY
        call GetData(Aux2,                                                       &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='WINDXY',                                     &
                     ClientModule ='ModuleLagrangianGlobal',                           &  
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR850'

        
        if (flag == 2) then
            NewOrigin%Movement%WindOriginON = .true.
        else if (flag == 0) then
            NewOrigin%Movement%WindOriginON = .false.
        endif

        NewOrigin%Movement%WindX = Aux2(1)
        NewOrigin%Movement%WindY = Aux2(2)

        deallocate(Aux2)
        
        !Slip condition ON/OFF
        call GetData(NewOrigin%Movement%SlipCondition,                           &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='SLIP_CONDITION',                             &
                     ClientModule ='ModuleLagrangianGlobal',                     &  
                     Default      = ON,                                          &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR855'

        !SEDIMENTATION
        call GetData(String,                                                     &
                     Me%ObjEnterData,                                 &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='SEDIMENTATION',                              &
                     ClientModule ='ModuleLagrangianGlobal',                           &  
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR860'

SE:             if (flag == 1) then

            select case(trim(adjustl(String)))
        
            case(Char_Stokes)
            
                NewOrigin%Movement%SedimentationType = Stokes_

                call GetData(NewOrigin%Movement%D50,                             &
                             Me%ObjEnterData,                                    &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='D50',                                &
                             default      = 0.002,                               & 
                             ClientModule ='ModuleLagrangianGlobal',             &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR870'

                NewOrigin%State%Sedimentation = ON

            case(Char_DensDynamic)
            
                NewOrigin%Movement%SedimentationType = DensDynamic_

                call GetData(NewOrigin%Movement%D50,                             &
                             Me%ObjEnterData,                                    &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='D50',                                &
                             !oil droplets diameter coming from oil slicks - average diameter value (Delvigne and Sweeney, 1989))
                             default      = 0.00025,                             & 
                             ClientModule ='ModuleLagrangianGlobal',             &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR872'

 
                call GetData(NewOrigin%Movement%Density,                         &
                             Me%ObjEnterData,                                    &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='D50_DENSITY',                        &
                             !particle density
                             default      = 920.,                                & 
                             ClientModule ='ModuleLagrangianGlobal',             &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR876'


                NewOrigin%State%Sedimentation   = ON
                
                Me%State%Density                = ON
                NewOrigin%State%Density         = ON
                
                
            case(Char_Imposed)
            
                NewOrigin%Movement%SedimentationType = Imposed_

                call GetData(NewOrigin%Movement%SedVel,                          &
                             Me%ObjEnterData,                                    &
                             flag,                                               &
                             SearchType   = FromBlock,                           &
                             keyword      ='SED_VELOCITY',                       &
                             ClientModule ='ModuleLagrangianGlobal',             &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR880'
                if (flag == 0) then
                    write(*,*)'Sedimentation velocity not defined, keyword SED_VELOCITY'
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR890'
                endif
                
                call GetData(NewOrigin%Movement%SedVelUncertainty,                      &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='SED_VELOCITY_UNCERTAINTY',                  &
                             default      = 0.,                                         &   
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR880'
           

                NewOrigin%State%Sedimentation     = ON
             
            case(Char_SecondaryClarifier)
            
                NewOrigin%Movement%SedimentationType = SecondaryClarifier_
                NewOrigin%State%Sedimentation        = ON
                
            case(Char_FergusonChurch2004)
                
                !call GetData(NewOrigin%Movement%D50min,                          &
                !             Me%ObjEnterData,                                    &
                !             flag,                                               &
                !             SearchType   = FromBlock,                           &
                !             keyword      ='D50_MIN',                            &
                !             ClientModule ='ModuleLagrangianGlobal',             &
                !             STAT         = STAT_CALL)             
                !if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR880'
                !if (flag == 0) then
                !    write(*,*)'Sedimentation velocity not defined, keyword D50_MIN'
                !    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR890'
                !endif
                !
                !call GetData(NewOrigin%Movement%D50max,                          &
                !             Me%ObjEnterData,                                    &
                !             flag,                                               &
                !             SearchType   = FromBlock,                           &
                !             keyword      ='D50_MAX',                            &
                !             ClientModule ='ModuleLagrangianGlobal',             &
                !             STAT         = STAT_CALL)             
                !if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR880'
                !if (flag == 0) then
                !    write(*,*)'Sedimentation velocity not defined, keyword D50_MAX'
                !    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR890'
                !endif    
                
                call RewindBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)                  
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR879'

                call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,               &
                                            "<<BeginGranulometricCurve>>",              &
                                            "<<EndGranulometricCurve>>",                &
                                            BlockFound,                                 &
                                            FirstLine = FirstLine,                      &
                                            LastLine  = LastLine,                       &
                                            STAT      = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR880'


                !Reads Classification Data
        cd1:    if (BlockFound) then
                    nClasses = (LastLine-1) - (FirstLine+1) + 1
                    NewOrigin%Movement%nDiameterClasses = nClasses 
                    allocate (NewOrigin%Movement%DiameterClasses(nClasses, 2))
                    nClasses = 0
                    do iLine = FirstLine+1, LastLine-1
                        nClasses = nClasses + 1
                        !Diameter [mm] (ascending order) , accumulated percentage 
                        call GetData(NewOrigin%Movement%DiameterClasses(nClasses, :),   &
                                     Me%ObjEnterData, flag,                             &
                                     Buffer_Line  = iLine,                              & 
                                     STAT         = STAT_CALL)
                        if (flag      /=        2) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR881'
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR882'
                    enddo
                    if (NewOrigin%Movement%DiameterClasses(       1, 2) /= 0.  ) then
                            stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR883'
                    endif                            
                    if (NewOrigin%Movement%DiameterClasses(nClasses, 2) /= 100.) then
                            stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR884'                    
                    endif                                                    
                else  cd1           
            
                    write (*,*)'Sediments classes not defined : ', trim(NewOrigin%Name)
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR883'

                endif cd1    
           
             
                
                call GetData(NewOrigin%Movement%SedVelUncertainty,                      &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='SED_VELOCITY_UNCERTAINTY',                  &
                             default      = 0.,                                         &   
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR880'                
                
                NewOrigin%Movement%SedimentationType = FergusonChurch2004_                
                NewOrigin%State%Sedimentation        = ON  
                NewOrigin%State%D50                  = ON
                
                if (NewOrigin%State%D50) then

                    Me%State%D50 = .true.

                endif                
                
            case default
            
                write(*,*)'Invalid Sedimentaion type, keyword SEDIMENTATION : ', trim(adjustl(String))
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR900'

            end select

        end if SE

       !Particles with deposition 
        call GetData(NewOrigin%State%Deposition,                                 &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   = FromBlock,                                   &
                     keyword      ='DEPOSITION',                                 &
                     default      = .false.,                                     & 
                     ClientModule ='ModuleLagrangianGlobal',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                               &
            call SetError(FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR910')

        if (NewOrigin%State%Deposition .and. .not.NewOrigin%State%Sedimentation) &
            call SetError(FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR920')


DE:     if (NewOrigin%State%Deposition) then

            Me%State%Deposition = ON

            call GetData(NewOrigin%Deposition%TauErosion,                        &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='TAU_ERO',                                &
                         default      = 0.2,                                     &                                  
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                           &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR930')

            call GetData(NewOrigin%Deposition%TauDeposition,                     &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='TAU_DEP',                                &
                         default      = 0.1,                                     &                                  
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                           &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR940')

           call GetData(NewOrigin%Deposition%BottomDistance,                     &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='BOTTOM_DISTANCE',                        &
                         default      = 0.1,                                     &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                           &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR950')

           call GetData(NewOrigin%Deposition%TdecayMix,                          &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='TIME_DECAY',                             &
                         !defaul 2 days
                         default      = 172800.,                                 &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                           &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR960')

           call GetData(NewOrigin%Deposition%BottomEmission,                     &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='BOTTOM_EMISSION',                        &
                         !by default the particle are emitted in the water column
                         default      = .false.,                                 &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                           &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR970')

           call GetData(NewOrigin%Deposition%ErosionRate,                        &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='EROSION_RATE',                           &
                         !by default the erosion rate in 5e-2 g/m2/s             
                         !This value make sense if the concentration is in mg/l = g/m3
                         default      = 5.e-2,                                   &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         STAT         = STAT_CALL)

            if (STAT_CALL /= SUCCESS_)                                           &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR980')
            
            call GetData(NewOrigin%Deposition%TauUncertainty,                           &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='TAU_UNCERTAINTY',                               &
                         default      = 0.0,                                            &                                  
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR985')     

            call GetData(NewOrigin%Deposition%MixSedON,                                 &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='MIX_SED_ON',                                    &
                         default      = .false.,                                        &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR986')  
            
            call GetData(NewOrigin%Deposition%CriticalSlopeON,                          &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='CRITICAL_SLOPE_ON',                             &
                         default      = .false.,                                        &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR987')      
            
            if (NewOrigin%Deposition%CriticalSlopeON) Me%State%CriticalSlope = .true.

            call GetData(NewOrigin%Deposition%CriticalSlope,                            &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='CRITICAL_SLOPE',                                &
                !Need to look for values in literature
                         default      = 0.4,                                            &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR988')               
  
            call GetData(NewOrigin%Deposition%CriticalThickness,                        &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='CRITICAL_THICKNESS',                            &
                         default      = - null_real,                                    &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR989')   
            
            call GetData(NewOrigin%Deposition%CriticalSlopeVel,                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='CRITICAL_SLOPE_VELOCITY',                       &
                         default      = 0.,                                             &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR9890')               
            
            call GetData(NewOrigin%Deposition%CriticalSlopeVelUncertainty,              &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='CRITICAL_SLOPE_VELOCITY_UNCERTAINTY',           &
                         default      = 0.,                                             &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                call SetError(FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR9895')                           

        endif DE


        !Min Sedimentation velocity
        call GetData(NewOrigin%Movement%MinSedVel,                               &
                     Me%ObjEnterData,                                            &
                     flag,                                                       &
                     SearchType   =  FromBlock,                                  &
                     keyword      = 'MIN_SED_VELOCITY',                          &
                     default      =  0.0,                                        &
                     ClientModule = 'ModuleLagrangianGlobal',                    &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR990'



            !Gets the number of particles to emit
            call GetData(NewOrigin%NbrParticlesIteration,                        &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='NBR_PARTIC',                             &
                         ClientModule ='ModuleLagrangianGlobal',                 &
                         Default      = 1,                                       &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1000'

            !checks if it is a surface emission        
            call GetData(NewOrigin%Position%SurfaceEmission,                               &
                         Me%ObjEnterData,                                        &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='SURFACE_EMISSION',                       &
                         Default      = OFF,                                     &
                         ClientModule ='ModuleLagrangianGlobal',                       &
                         STAT         = STAT_CALL)             
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1010'

        !Reads parameter specific to each Spatial emission type
PA:         if (NewOrigin%EmissionSpatial == Point_ .or.                             &
                NewOrigin%EmissionSpatial == Accident_ ) then


            !Horizontal position in meters
            Position(:) = null_real
            HaveOrigin  = .false.
              
NDF:        if (.not. NewOrigin%Default) then
        
                !Horizontal position in coordinates X, Y
                call GetData(Position,                                                  &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='POSITION_COORDINATES',                      &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1020'

                if (flag == 2) then
                    HaveOrigin                      = .true.
                endif
                
                em = Locate_ModelDomain(Position(1), Position(2), NoDomain) 


                if (NoDomain) then
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1023'
                endif
                
                NewOrigin%Position%CoordX = Position(1)                   
                NewOrigin%Position%CoordY = Position(2)
                
                
                
                call Convert_XY_CellIJ(Me%EulerModel(em),NewOrigin%Position, Referential = GridCoord_)

                    
                !Checks if a valid horizontal origin was found
                if (.not. HaveOrigin) then
                    write(*,*)'No Valid Horizontal Location defined for ',trim(adjustl(NewOrigin%Name))
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR66'

                endif
                
                !Check if the model tries to find automaticly alternative locations if the origin position is located in land
                call GetData(FindWaterLocation,                                         &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='FIND_WATER_LOCATION',                       &
                             default      = .false.,                                    &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1025'                

                !Verifies the horizontal location of the origin
                i   = NewOrigin%Position%I
                j   = NewOrigin%Position%J
                KUB = Me%EulerModel(em)%WorkSize%KUB

                if (Me%EulerModel(em)%Waterpoints3D(i, j, KUB) /= WaterPoint) then
                
                    if (FindWaterLocation) then
                        call OriginLocationInWater(NewOrigin%Position,Me%EulerModel(em),FoundWater)
                    else
                        FoundWater = .false.
                    endif                        
                                                
                    if (.not. FoundWater) then                        
                        write(*,*) 'Discharge in a land cell I=',i,' J=',j,'Model name=',trim(Me%EulerModel(em)%Name)

                        write(*,*)'Invalid Location defined for ',trim(adjustl(NewOrigin%Name))
                        write(*,*)'Point [i]:', NewOrigin%Position%I
                        write(*,*)'Point [j]:', NewOrigin%Position%J
                        
                        write(*,*)'Is not a WaterPoint'
                        
                        stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1030'
                    endif                        
                endif                    
 
                NewOrigin%Position%ModelID =  em

                !Vertical position
                Depth      = null_real
                HaveOrigin = .false.

                if (NewOrigin%Position%SurfaceEmission) then

                    NewOrigin%Position%Z = Me%EulerModel(em)%SZZ(i, j, KUB)

                    call Convert_Z_CellK (NewOrigin, Me%EulerModel(em), NewOrigin%Position)
                    call Convert_CellK_K (NewOrigin%Position)

                    NewOrigin%Position%DepthDefinition = Meters

                    HaveOrigin                      = .true.

                else

                    call GetData(Depth,                                                  &
                                 Me%ObjEnterData,                                        &
                                 flag,                                                   &
                                 SearchType   = FromBlock,                               &
                                 keyword      ='DEPTH_FROM_FREE_SURFACE',                &
                                 ClientModule ='ModuleLagrangianGlobal',                       &
                                 STAT         = STAT_CALL)             
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1040'

                    if (flag == 1) then

                        NewOrigin%Position%Z = Me%EulerModel(em)%SZZ(i, j, KUB) + Depth

                        call Convert_Z_CellK (NewOrigin, Me%EulerModel(em), NewOrigin%Position)
                        call Convert_CellK_K (NewOrigin%Position)

                        NewOrigin%Position%DepthDefinition = Meters

                        HaveOrigin                      = .true.

                    else

                        call GetData(Depth,                                                  &
                                     Me%ObjEnterData,                             &
                                     flag,                                                   &
                                     SearchType   = FromBlock,                               &
                                     keyword      ='DEPTH_METERS',                           &
                                     ClientModule ='ModuleLagrangianGlobal',                       &
                                     STAT         = STAT_CALL)             
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1040'

                        if (flag == 1) then

                            NewOrigin%Position%Z = Depth

                            call Convert_Z_CellK (NewOrigin, Me%EulerModel(em), NewOrigin%Position)
                            call Convert_CellK_K (NewOrigin%Position)

                            NewOrigin%Position%DepthDefinition = Meters

                            HaveOrigin                      = .true.

                        else

                            call GetData(Depth,                                              &
                                         Me%ObjEnterData,                         &
                                         flag,                                               &
                                         SearchType   = FromBlock,                           &
                                         keyword      ='DEPTH_CELLS',                        &
                                         ClientModule ='ModuleLagrangianGlobal',                   &
                                         STAT         = STAT_CALL)             
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1050'

                            if (flag == 1) then
        
                                NewOrigin%Position%CellK = Depth

                                call Convert_CellK_Z (Me%EulerModel(em),NewOrigin%Position)
                                call Convert_CellK_K (NewOrigin%Position)
                            
                                HaveOrigin                      = .true.

                                NewOrigin%Position%DepthDefinition = Cells

                            endif

                        endif
                    endif
                endif

                if (NewOrigin%Position%Z .EQ. Me%EulerModel(em)%SZZ(i, j, KUB)) then
                    NewOrigin%Position%Surface          = .true.
                    NewOrigin%Position%SurfaceEmission  = .true.
                else
                    NewOrigin%Position%Surface = .false.                
                endif

                call GetData(NewOrigin%Position%MaintainDepth,                    &
                             Me%ObjEnterData,                                        &
                             flag,                                                   &
                             SearchType   = FromBlock,                               &
                             keyword      ='MAINTAIN_DEPTH',             &
                             Default      = .false.,                                 &
                             ClientModule ='ModuleLagrangianGlobal',                       &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1060'

                if (NewOrigin%Position%MaintainDepth) then
                    NewOrigin%Position%DepthWithWaterLevel = NewOrigin%Position%Z - Me%EulerModel(em)%SZZ(i, j, KUB)
                endif


                call GetData(NewOrigin%Position%MaintainRelative,                    &
                             Me%ObjEnterData,                                        &
                             flag,                                                   &
                             SearchType   = FromBlock,                               &
                             keyword      ='MAINTAIN_RELATIVE_POSITION',             &
                             Default      = .false.,                                 &
                             ClientModule ='ModuleLagrangianGlobal',                       &
                             STAT         = STAT_CALL)             
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1060'

                if (NewOrigin%Position%MaintainRelative) then
            
                    NewOrigin%Position%Depth = Depth

                endif

                !Initial Position of floating Particle close to the surface
                if (NewOrigin%Movement%Float) then

                    i   = NewOrigin%Position%I
                    j   = NewOrigin%Position%J
                    KUB = Me%EulerModel(em)%WorkSize%KUB
                    NewOrigin%Position%Z = Me%EulerModel(em)%SZZ(i, j, KUB)
            
                    call Convert_Z_CellK  (NewOrigin, Me%EulerModel(em), NewOrigin%Position)
                    call Convert_CellK_K  (NewOrigin%Position)

                    HaveOrigin = .true.

                endif

                !Checks if a valid vertical origin was found
                if (.not. HaveOrigin) then

                    write(*,*)'No Valid Vertical Location defined for ',trim(adjustl(NewOrigin%Name))
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1080'

                endif

                !Verifies the location of the origin
                i = NewOrigin%Position%I
                j = NewOrigin%Position%J
                k = NewOrigin%Position%K
                if (Me%EulerModel(em)%Waterpoints3D(i, j, k) /= WaterPoint) then
                    write(*,*)'Invalid Location defined for ',trim(adjustl(NewOrigin%Name))
                    write(*,*)'Point [i]:', NewOrigin%Position%I
                    write(*,*)'Point [j]:', NewOrigin%Position%J
                    write(*,*)'Point [k]:', NewOrigin%Position%K
                    write(*,*)'Is not a WaterPoint'
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1090'
                endif
                
                call ReadSectionEmission(NewOrigin)

            else  NDF

                em = 1

            endif NDF

        endif PA

BX:     if (NewOrigin%EmissionSpatial == Box_) then

            em = BestDomainForBox(NewOrigin)
            
            NewOrigin%Position%ModelID =  em

            call GetData(NewOrigin%INCRP,                                        &
                         Me%ObjEnterData,                             &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='INCRP',                                  &
                         ClientModule ='ModuleLagrangianGlobal',                       &
                         Default      = 1,                                       &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1100'


            !Volume of the particles inside the
            !If not given OneCell _> One particle
            call GetData(NewOrigin%ParticleBoxVolume,                            &
                         Me%ObjEnterData,                             &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='BOXVOLINIC',                             &
                         ClientModule ='ModuleLagrangianGlobal',                       &
                         Default      = null_real,                               &
                         STAT         = STAT_CALL)        
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1110'
            
            if (flag==0) NewOrigin%ParticleBoxVolume = NewOrigin%PointVolume / NewOrigin%NbrParticlesIteration

            !Box Number
            call GetData(NewOrigin%BoxNumber,                                    &
                         Me%ObjEnterData,                             &
                         flag,                                                   &
                         SearchType   = FromBlock,                               &
                         keyword      ='BOX_NUMBER',                             &
                         ClientModule ='ModuleLagrangianGlobal',                       &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1120'
            if (flag /= 1) then
                write(*,*)'Keyword BOX_NUMBER not defined at origin :', trim(adjustl(NewOrigin%Name))
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1130'
            endif

            if (NewOrigin%EmissionTemporal == Instantaneous_) then

                !kill all particles inside the box previous to the box emission 
                call GetData(NewOrigin%KillPartInsideBox,                               &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='KILL_PART_INSIDE_BOX',                      &
                             Default      = OFF,                                        &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1125'

                if (NewOrigin%KillPartInsideBox) Me%State%KillPartInsideBox = .true. 

            endif

        endif BX

PX:     if (NewOrigin%EmissionSpatial == Poly_) then

            call ReadPolyEmission(NewOrigin, em)

        endif PX


        !Calculates Plume
        call GetData(NewOrigin%State%ComputePlume,                                      &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='COMPUTE_PLUME',                                     &
                     Default      = OFF,                                                &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR540'

        !Plume Data
        if (NewOrigin%State%ComputePlume) then


            Me%State%ComputePlume = .true.
            
            if (.not. NewOrigin%State%FarFieldBuoyancy) then
                write(*,*) 'The MOHID JET is ON but'
                write(*,*) 'no buoyancy in the far field is being compute'
                write(*,*) 'ConstructOneOrigin - ModuleLagrangianGlobal - WRN10'
            endif

            !Momentum balance in horizontal direction
            !Increase of volume tracer due to shear effect
            call GetData(NewOrigin%State%PlumeShear,                                    &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='PLUME_SHEAR',                                   &
                         Default      = .false.,                                        &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR550'


                                
            !Plume Friction
            call GetData(NewOrigin%Movement%CoefInitialMixing,                          &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='COEF_INITIAL_MIXING',                           &
                         Default      = 1.0,                                            &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR560'


            !Plume Jet Data file
            call GetData(NewOrigin%Movement%JetDataFile,                                &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='JET_DATA_FILE',                                 &
                         Default      = "********.***",                                 &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR570'
            if (flag == 0)             stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR580'

            !Time interval for the actualization of Plume Jet properties
            call GetData(NewOrigin%Movement%JetDT,                                      &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='JET_DT',                                        &
                         Default      = 600.0,                                          &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR590'


            NewOrigin%Movement%NextJetActualization = Me%ExternalVar%BeginTime

        endif
        
        if (Me%State%FarFieldBuoyancy .or. Me%State%ComputePlume .or. Me%State%Density) then
            !Density Evolution
            call GetData(NewOrigin%Movement%DensityMethod,                              &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='DENSITY_METHOD',                                &
                         Default      = UNESCOState_,                                   &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR600'
            
            call GetData(NewOrigin%Movement%CorrecPress,                                &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='PRESSURE_CORRECTION',                           &
                         Default      = .true.,                                         &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR610'

            call GetDensityOptions(Me%EulerModel(em)%ObjWaterProperties, DensityMethod, &
                                   PressureCorrection, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR620'
            
            if (NewOrigin%Movement%DensityMethod/=DensityMethod) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR630'
            endif
            
            if (.not. (NewOrigin%Movement%CorrecPress .EQV. PressureCorrection)) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR640'
            endif                    
       
        endif

        call RewindBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
    
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR650'

       
        !Searches for Properties
DOPROP: do 
            call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                   &
                                       property_begin, property_end,                    &
                                       PropertyFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1140'
            if (PropertyFound) then

                !Allocates NewProperty
                call AllocateNewProperty(NewProperty)

                !Name of the Property
                call GetData(NewProperty%Name,                                          &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='NAME',                                      &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1150'
                if (flag == 0) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1160'


                !Checks if the property is recognized by the model
                if (.not. CheckPropertyName(trim(NewProperty%Name), NewProperty%ID)) then
                    write (*,*)'Unknown Property : ', trim(NewProperty%Name)
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1170'
                end if

                !Units of the Property
                call GetData(NewProperty%Units,                                         &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='UNITS',                                     &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1180'

                !Concentration variable in time
                call GetData(NewProperty%ConcVariable,                                  &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='CONC_VARIABLE',                             &
                             default      = .false.,                                    &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)        
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1210'

                !Concentration of the Property equal to the ambient concentration
                call GetData(NewProperty%EqualToAmbient,                                &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='EQUAL_TO_AMBIENT',                          &
                             default      = .false.,                                    &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1202'


                if (NewProperty%EqualToAmbient) NewProperty%ConcVariable = .false. 

                if (NewProperty%ConcVariable) then

                    !Discharge file name
                    call GetData(NewProperty%DischargeFile,                             &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='DISCHARGE_FILE',                        &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1212'

                    if (.not. NewOrigin%Default) then
                        call StartTimeSerieInput(NewProperty%TimeSerieInput,            &
                                                 NewProperty%DischargeFile,             &
                                                 Me%ExternalVar%ObjTime,                &
                                                 STAT = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1214'
                    endif

                    !Concentration column
                    call GetData(NewProperty%ConcColumn,                                &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='CONC_COLUMN',                           &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1220'
                    if (flag == 0) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1230'

                else 

                    !Concentration of the Property
                    call GetData(NewProperty%Concentration,                                 &
                                 Me%ObjEnterData,                                           &
                                 flag,                                                      &
                                 SearchType   = FromBlockInBlock,                           &
                                 keyword      ='CONCENTRATION',                             &
                                 ClientModule ='ModuleLagrangianGlobal',                    &
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1190'
                    if (flag == 0) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1200'                    

                endif


                !No WQM
                 call GetData(NewProperty%NoWQM,                                        &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='NOWQM',                                 &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)        
                 if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1240'


                !MinimunConcentration 
                call GetData(NewProperty%Min_concentration,                             &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='MIN_CONCENTRATION',                         &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             Default      = 0.0,                                        &    
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1250'


                !Time series output
                call GetData(NewProperty%WritesTimeSerie,                               &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             Keyword      = 'TIME_SERIE',                               &
                             ClientModule = 'ModuleLagrangianGlobal',                   &
                             Default      = .false.,                                    &
                             STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1255'

                if (NewProperty%WritesTimeSerie) Me%WritesTimeSerie = .true. 


                !Time series output
                call GetData(NewProperty%WritesPropHDF,                                 &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             Keyword      = 'OUTPUT_HDF',                               &
                             ClientModule = 'ModuleLagrangianGlobal',                   &
                             Default      = .false.,                                    &
                             STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR1257'


                !AmbientConcentration 
                call GetData(NewProperty%AmbientConcentration,                          &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='AMBIENT_CONC',                              &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1260'


                if (flag == 1) then
                    NewProperty%HaveAmbientConcentration = ON
                else
                    !Checks if the WP module have this property
                    WP_HaveProperty = WaterPropertyExists (                             &
                                            Me%EulerModel(em)%ObjWaterProperties,       &
                                            NewProperty%ID, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1270'

                    if (.not. WP_HaveProperty) then
                        write(*,*)'No Ambient Concentration for the Property : ',trim(NewProperty%Name)
                        write(*,*)'Use the KeyWord                           : AMBIENT_CONC'
                        write(*,*)'OR define the property in the Eulerian Module'
                        stop      'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1280'
                    endif
                endif


                !Extra Stuff
                ret = CheckPropertyName (NewProperty%Name, PropertyID)
                select case (PropertyID)

                case (Larvae_)
                
                    call GetData(NewProperty%Larvae%Vertical_Migration,                 &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='VERTICAL_MIGRATION',                    &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = .false.,                                &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2000'
                       
                        if (NewProperty%Larvae%Vertical_Migration) then
  
                            call GetData(NewProperty%Larvae%Larvae_Max_Depth,           &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='LARVAE_MAX_DEPTH',                  &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     Default      = 100.,                               &    
                                     STAT         = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2010'
                            
                            call GetData(NewProperty%Larvae%Larvae_Min_Depth,           &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='LARVAE_MIN_DEPTH',                  &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     Default      = 10.,                                &    
                                     STAT         = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2020'
                        
                            call GetData(NewProperty%Larvae%Larvae_Velocity,            &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='LARVAE_VELOCITY',                   &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     Default      = 0.001,                              &    
                                     STAT         = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2030'  
                                                          
                            call GetData(NewProperty%Larvae%Radiation_Limit,            &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='RADIATION_LIMIT',                   &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     Default      = 0.00,                               &    
                                     STAT         = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2040'  
                            
                            call GetData(NewProperty%Larvae%Light_Relation,             &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='LIGHT_RELATION',                    &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     Default      = .true.,                             &    
                                     STAT         = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2045' 
                             
                            call GetData(NewProperty%Larvae%Compute_Larvae_Velocity,    &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='COMPUTE_LARVAE_VELOCITY',           &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                     Default      = .true.,                             &
                                     STAT         = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2050'
                                
                                if (NewProperty%Larvae%Compute_Larvae_Velocity) then
                                
                                     call GetData(NewProperty%Larvae%Migration_Time,    &
                                              Me%ObjEnterData,                          &
                                              flag,                                     &
                                              SearchType   = FromBlockInBlock,          &
                                              keyword      ='MIGRATION_TIME',           &
                                              ClientModule ='ModuleLagrangianGlobal',   &
                                              Default      = 18000.,                    &    
                                              STAT         = STAT_CALL)
                                     if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR2060'  
                                endif
                        endif                        

                !T90
                case (Fecal_Coliforms_,E_Coli_ )

                    Me%State%T90      = ON 

                    NewProperty%T90ON = ON

                    call GetData(NewProperty%T90Variable,                               &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='T90_VARIABLE',                          &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = .false.,                                &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1290'


                    if (NewProperty%T90Variable) then
                        
                        if (NewProperty%T90Variable) Me%State%T90Variable = .true.
                        call GetData(NewProperty%T90Var_Method,                         &
                                     Me%ObjEnterData,                                   &
                                     flag,                                              &
                                     SearchType   = FromBlockInBlock,                   &
                                     keyword      ='T90_VAR_METHOD',                    &
                                     ClientModule ='ModuleLagrangianGlobal',            &
                                    STAT         = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1300'

                        if (flag /= 1) then
                            write(*,*)'Keyword T90_VAR_METHOD not defined at origin :',trim(adjustl(NewOrigin%Name))
                            stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR94b'
                        endif

                        if (NewProperty%T90Var_Method /= FromTimeSerie) then
                            Me%State%T90Compute     = .true. 
                            NewProperty%T90Compute  = .true. 
                        endif

                        if (NewProperty%T90Var_Method == FromTimeSerie) then
                        
                             

                           !T90 time serie file name
                            call GetData(NewProperty%T90File,                           &
                                         Me%ObjEnterData,                               &
                                         flag,                                          &
                                         SearchType   = FromBlockInBlock,               &
                                         keyword      ='T90_FILE',                      &
                                         ClientModule ='ModuleLagrangianGlobal',        &
                                         STAT         = STAT_CALL)        
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1302'
                            if (flag == 0) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1303'

                            if (.not. NewOrigin%Default) then
                                call StartTimeSerieInput(NewProperty%TimeSerieT90,      &
                                                         NewProperty%T90File,           &
                                                         Me%ExternalVar%ObjTime,        &
                                                         STAT = STAT_CALL)

                                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1304'
                            endif

                            !Concentration column
                            call GetData(NewProperty%T90Column,                         &
                                         Me%ObjEnterData,                               &
                                         flag,                                          &
                                         SearchType   = FromBlockInBlock,               &
                                         keyword      ='T90_COLUMN',                    &
                                         ClientModule ='ModuleLagrangianGlobal',        &
                                         STAT         = STAT_CALL)        
                            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1305'
                            if (flag == 0) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1306'

                        endif

                    endif

                    call GetData(NewProperty%T90,                                       &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='T90',                                   &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 7200.,                                  &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1310'

                    call GetData(NewProperty%T90Name,                                   &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='T90_NAME',                              &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 'T90',                                  &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1315'

                    if (flag == 0) then

                        if (PropertyID == Fecal_Coliforms_) NewProperty%T90Name = GetPropertyName(T90_       )

                        if (PropertyID == E_Coli_         ) NewProperty%T90Name = GetPropertyName(T90_E_Coli_)
                    
                    endif

                end select

                call GetData(NewProperty%WaterPartition%ON,                             &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='PARTITION_WATER',                           &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             Default      =.false.,                                     &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1320')

WP:             if (NewProperty%WaterPartition%ON) then

                    Me%State%Partition = ON
                    NewOrigin%State%Partition     = ON

                    call GetData(NewProperty%WaterPartition%Coefficient,                &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='PARTITION_COEF_WATER',                  &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 0.90,                                   &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1330')

                    call GetData(NewProperty%WaterPartition%TransferRate,               &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='PARTITION_RATE_WATER',                  &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 1e-3,                                   &   
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1340')


                    call GetData(NewProperty%WaterPartition%CoupleProp,                 &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='PARTITION_COUPLE_WATER',                &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 0.,                                     &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1350')

                endif WP

                call GetData(NewProperty%SedimentPartition%ON,                          &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='PARTITION_SED',                             & 
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             Default      =.false.,                                     &
                             STAT         = STAT_CALL)                          
                if (STAT_CALL /= SUCCESS_)                                              &
                    call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1360')

                if (NewProperty%SedimentPartition%ON.and..not.NewOrigin%State%Deposition)&
                    call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1370')


SP:             if (NewProperty%SedimentPartition%ON) then

                    Me%State%Partition        = ON
                    NewOrigin%State%Partition = ON

                    call GetData(NewProperty%SedimentPartition%Coefficient,             &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='PARTITION_COEF_SED',                    &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 0.98,                                   &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1380')

                    call GetData(NewProperty%SedimentPartition%TransferRate,            &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='PARTITION_RATE_SED',                    &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 1e-4,                                   &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1390')


                    call GetData(NewProperty%SedimentPartition%CoupleProp,              &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockInBlock,                       &
                                 keyword      ='PARTITION_COUPLE_SED',                  &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 Default      = 0.,                                     &    
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        call SetError (FATAL_, KEYWORD_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1400')

                endif SP

                !This property has an extinction parameter. This parameter can be use 
                !to compute the effect of this property in the light extinction
                call GetData(NewProperty%ExtinctionParameter,                           &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='EXTINCTION_PARAMETER',                      &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             default      = 1.,                                         &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1440'


                !This property is being filter from the water column
                call GetData(NewProperty%Filtration,                                    &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='FILTRATION',                                &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             default      = .false.,                                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1450'

                if (NewProperty%Filtration) NewOrigin%Filtration = .true. 

                call GetData(NewProperty%MinValue,                                      &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='MIN_VALUE',                                 &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1452'

                if (flag > 0) then
                    NewProperty%MinON    = .true. 
                else
                    NewProperty%MinON    = .false. 
                    NewProperty%MinValue = FillValueReal
                endif


                call GetData(NewProperty%MaxValue,                                      &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='MAX_VALUE',                                 &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1452'

                if (flag > 0) then
                    NewProperty%MaxON    = .true. 
                else
                    NewProperty%MaxON    = .false. 
                    NewProperty%MaxValue = -FillValueReal
                endif

                if (PropertyID == Sediment) SedimentDefined = .true.


                call GetData(NewProperty%HasOdour,                                      &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='HAS_ODOUR',                                 &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             Default    = .false.,                                      &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1453'
                
                if (NewProperty%Units /= 'mg/m3' .and. (NewProperty%ID == AmmoniaGas_ .or. & 
                    NewProperty%ID==HydrogenSulfide_ .or. NewProperty%ID==MethylMercaptan_)) then
                    write(*,*) 'Property with odour : ', trim(NewProperty%Name), ' must have units of mg/m3'
                    stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1453'
                endif
                
                if (NewProperty%HasOdour) then
                    
                    NewOrigin%State%Odour = .true.
                    Me%State%Odour        = .true.
                    
                    ! Default values from bibliography
                    ! Given by Enga Lisete Epifaneo, Simarsul, from Metcalf & Eddy (1991)
                    ! Default units are mg/m3 because threshold value are very low.
                    
                    OdourConcThreshold = 0.0
                    select case (NewProperty%ID)                         
                    case (AmmoniaGas_)
                        OdourConcThreshold = 25.16
                    case (HydrogenSulfide_)
                        OdourConcThreshold = 6.58e-4
                    case (MethylMercaptan_)
                        OdourConcThreshold = 2.00e-3
                    end select 
                    
                    call GetData(NewProperty%OdourConcThreshold,                        &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlockInBlock,                           &
                             keyword      ='ODOUR_CONC_THRESHOLD',                      &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             Default    = OdourConcThreshold,                           &
                             STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1454'
                                                    
                endif  ! HasOdour
                
                
                
                !Insert Property into list of properties
                call InsertPropertyToList(NewOrigin, NewProperty, SetStates = .true.)

            else

                exit DOPROP

            endif

        enddo DOPROP

        if (NewOrigin%Filtration) Me%State%Filtration = .true. 


        if (NewOrigin%State%Deposition .and. .not. SedimentDefined)                     &
            call SetError (FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1470')



        !If necessary Starts The WQM module for this origin
        if (NewOrigin%State%WQM) then
            
            !WQM Data File
            call GetData(NewOrigin%WQM_DataFile,                                        &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='WQM_DATA_FILE',                                 &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1480'
            
            if (.not. NewOrigin%Default) then

                call StartWaterQuality(NewOrigin%WaterQualityID,                        &
                                       NewOrigin%WQM_DataFile,                          &
                                       STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1490'

                NewOrigin%NextWQMCompute = Me%ExternalVar%Now
                call GetDTWQM (NewOrigin%WaterQualityID, DTSecond = NewOrigin%DTWQM,    &
                               STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1500'

            endif
            
        endif

        !If neceassary Starts The Oil or HNS module for this origin
        if ((NewOrigin%State%Oil) .OR. (NewOrigin%State%HNS)) then

            call GetData(NewOrigin%AreaMethod,                                          &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='AREA_METHOD',                                   &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = GridCells_,                                     &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1510'
            
            if (NewOrigin%AreaMethod == VoronoiArea_) then            

                call GetData(NewOrigin%FayTotalArea,                                    &
                             Me%ObjEnterData,                                           &
                             flag,                                                      &
                             SearchType   = FromBlock,                                  &
                             keyword      ='FAY_TOTAL_AREA',                            &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             Default      = OFF,                                        &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1513'
            
            
            endif

            if (.not. NewOrigin%Default) then
                if (NewOrigin%State%Oil) then
                call ConstructParticOil (NewOrigin, ClientNumber)
                elseif (NewOrigin%State%HNS) then
                    call ConstructParticHNS (NewOrigin, ClientNumber)
            endif
            endif

            call GetData(NewOrigin%CDispOilOff,                                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='CDISP_OIL_OFF',                                 &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = 1.,                                             &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1511'

            call GetData(NewOrigin%DropletsD50,                                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='DROPLETS_D50',                                  &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         !50 microns
                         Default      = 50e-6,                                          &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1515'

            call GetData(NewOrigin%MethodBWDropletsDiameter,                            &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='METHOD_BW_DROPLETS_DIAMETER',                   &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = UserDefined_,                                   &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1516'
            call GetData(NewOrigin%MethodFloatVel,                                      &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='METHOD_FLOAT_VEL',                              &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = SoaresDosSantos_,                               &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1517'
        endif
        call GetData(NewOrigin%State%Age,                                               &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='COMPUTE_AGE',                                       &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1520'

        if (Me%LitterON         ) NewOrigin%State%Age = .true.  
        
        if (NewOrigin%State%Age) Me%State%Age = .true.

        if (NewOrigin%State%Age) then
        
            !Age limit in days
            call GetData(NewOrigin%AgeLimit,                                            &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='AGE_LIMIT',                                     &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = -FillValueReal,                                 &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1530'
            
            !Age limit in days
            call GetData(NewOrigin%AgeFreezeBeach,                                      &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='AGE_FREEZE_BEACH',                              &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = OFF,                                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1535'
        else
        
            if (Me%OutPut%OutPutConcType == Analytic) then    
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1537'
            endif
                            
        endif 
        
        call GetData(NewOrigin%State%AccidentProbability,                               &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='ACCIDENT_PROBABILITY',                              &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1540'

        if (NewOrigin%State%AccidentProbability) then
        
            if (.not. Me%CoastLineON) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1545'
            endif

            Me%State%AccidentProbability    = .true.
            Me%State%DistanceToCoast        = .true.
                        
            NewOrigin%State%DistanceToCoast = .true.

            !This the the frequency of vessel accidents per annual ship traffic based in the 
            !Lloyd's register database
            !see EROCIPS projects - Interreg - "Methodology for risk assessment of accidents that originate
            !hydrocarbon substances spills at sea, and their potential impact"
            call GetData(NewOrigin%AccidentProbDefault,                                 &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='DEFAULT_ACCIDENT_PROBABILITY',                  &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         !In average a vessel 1 in ~25000 has an accident per year
                         default      = 4.45238E-05,                                    &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1550'
            

            call GetData(NewOrigin%State%ComputeRisk,                                   &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='COMPUTE_RISK',                                  &
                         default      = .false.,                                        &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1580'
            
            if (NewOrigin%State%ComputeRisk) Me%State%ComputeRisk = .true. 

            call GetData(NewOrigin%AreaVTS,                                             &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='AREA_VTS',                                      &
                         default      = .true.,                                         &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1590'
            
        endif            
        
        !Actualizes Variable Flow and concentration
        if (NewOrigin%EmissionTemporal == Continuous_ .and. .not.NewOrigin%Default)  then
            call ActualizeOrigin (NewOrigin)
        endif
        
        if (NewOrigin%State%FarFieldBuoyancy .or. NewOrigin%State%ComputePlume) then

            NewProperty => NewOrigin%FirstProperty
            do while (associated(NewProperty))

                if (NewProperty%ID == Salinity_) then
                    NewOrigin%Movement%JetSalinity = NewProperty%Concentration
                    SalOK = .true.
                endif
                if (NewProperty%ID == Temperature_) then
                    NewOrigin%Movement%JetTemperature = NewProperty%Concentration
                    TempOK = .true.
                endif                

                NewProperty => NewProperty%Next
            enddo

            nullify(NewProperty)

            if (.not.(TempOK .and. SalOK)) then
                call SetError (FATAL_, INTERNAL_, 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1460')
            endif                  
                
        endif
            
        
        if (NewOrigin%State%ComputePlume .and. .not. NewOrigin%Default) then

            call Construct_Jet(JetID            = NewOrigin%Movement%ObjJet,            &
                               FileName         = NewOrigin%Movement%JetDataFile,       &
                               HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,  &                               
                               PositionX        = NewOrigin%Position%CartX,             & 
                               PositionY        = NewOrigin%Position%CartY,             & 
                               Flow             = NewOrigin%Flow,                       &
                               Salinity         = NewOrigin%Movement%JetSalinity,       &
                               Temperature      = NewOrigin%Movement%JetTemperature,    &
                               STAT             = STAT_CALL) 

            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1600'

            call UnitsManager(NewOrigin%Movement%JetUnit, OPEN_FILE,                    &
                              STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1610'
            endif

            call ReadFileName("ROOT_SRT", RootPath, STAT = STAT_CALL)

            NewOrigin%Movement%JetFileOut = trim(RootPath)//trim(NewOrigin%Name)//".jet"

            open (file   = NewOrigin%Movement%JetFileOut,                               &
                  unit   = NewOrigin%Movement%JetUnit,                                  & 
                  status = "unknown",                                                   &
                  form   = "formatted", IOSTAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) then
                write(*,*) 'Error opening time series file ',                           &
                            trim(NewOrigin%Movement%JetFileOut)
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1620'
            endif
            
            call WriteDataLine(NewOrigin%Movement%JetUnit, 'SERIE_INITIAL_DATA', Me%ExternalVar%BeginTime)
            
            write(NewOrigin%Movement%JetUnit,*) 'TIME_UNITS              : SECONDS'           

            write(NewOrigin%Movement%JetUnit,'(A110)')"Time Year Month Day Hour Minutes " &
            // "Seconds Dilution X Y Z Density Temperature "                            &
            // "Salinity U V W MixingHorLength Thickness"
            write(NewOrigin%Movement%JetUnit,*) '<BeginTimeSerie>'


            if (NewOrigin%Old) then


            endif

        endif


        call GetData(NewOrigin%Beaching,                                                &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='BEACHING',                                          &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1630'

        
        if (NewOrigin%State%Oil .or. NewOrigin%State%StokesDrift .or. NewOrigin%State%AccidentProbability .or. &
            NewOrigin%State%HNS .or. Me%Booms%ON) then
            NewOrigin%State%Waves = .true.
            Me%State%Waves        = .true.
        endif
        
        !Shoreline Oil Removal
        call GetData(NewOrigin%BeachRemoval,                                            &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='BEACH_REMOVAL',                                     &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1630'
        
        
        call GetData(NewOrigin%CoastlineBeaching,                                       &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='COASTLINE_BEACHING',                                &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1631'

        if(NewOrigin%CoastlineBeaching)then
        
            allocate(Me%AngleList(Ndir), Me%DistanceByDirection(Ndir))
            allocate(Me%Point)
            Me%AngleList(1) = 0.
            do dir=2, Ndir
                Me%AngleList(dir) = Me%AngleList(dir-1) + 360./real(NDir)
            enddo
        
            NewOrigin%State%CalcPartDistToCoast = ON
        
            Me%State%CalcPartDistToCoast = ON
        
            if (.not. Me%CoastLineON) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1632'
            endif
            
            Me%RedefineMapping = OFF
            
            Me%ThinWallsON  = .true.
            !call New(Me%ThinWalls, Me%CoastLineFile, Me%GridsBounds)
            call Add (Me%ThinWalls, Me%CoastLine)
            
        endif
        

        call GetData(NewOrigin%AreaBeaching,                                            &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='AREA_BEACHING',                                     &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1633'

        if(NewOrigin%AreaBeaching)then
        
            if (.not. Me%BeachAreaON) then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1634'
            endif
            
            if(NewOrigin%CoastlineBeaching)then
                stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1635'
            endif
            
        endif
        


        if (Me%State%OutputTracerInfo) then
            call ReadFileName("ROOT_SRT", RootPath, STAT = STAT_CALL)
            NewOrigin%OutputTracerInfoFileName = trim(RootPath)//trim(NewOrigin%Name)//".tro"
        endif

        if (Me%Output%OutputEnvelopeTimeSeries) then
            call ReadFileName("ROOT_SRT", RootPath, STAT = STAT_CALL)
            NewOrigin%OutputEnvelopeTimeSerieFileName = trim(RootPath)//trim(NewOrigin%Name)//".ero"
        endif

        !model the tracers as if they were solid floating objects (containers, e.g.)
        !call GetData(NewOrigin%State%FloatingObject,                                   &
        !             Me%ObjEnterData,                                                  &
        !             flag,                                                             &
        !             SearchType   = FromBlock,                                         &
        !             keyword      ='FLOATING_OBJECT',                                  &
        !             Default      = OFF,                                               &
        !             ClientModule ='ModuleLagrangianGlobal',                           &
        !             STAT         = STAT_CALL)
        !if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1660'

        if (NewOrigin%State%FloatingObject) then
            call GetData(NewOrigin%FloatingObject%AirDragCoef,                          &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='AIR_DRAG_COEF',                                 &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         !Air drag coeeficients of bluff objects at highr Reynolds number is tipically 1
                         ! (Smith, 1993)
                         Default      = 1.0,                                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1660'


            call GetData(NewOrigin%FloatingObject%WaterDragCoef,                        &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='WATER_DRAG_COEF',                               &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         !Experimental work gives 0.8 < WaterDragCoef < 1.2 
                         ! (Cabioc'h and Aoustin, 1997)
                         Default      = 1.0,                                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1670'

            call GetData(NewOrigin%FloatingObject%ImmersionRatio,                       &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='IMMERSION_RATIO',                               &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = 50.0,                                           &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1680'

        endif
        
        if (NewOrigin%State%HumanBody) then

            call GetData(NewOrigin%HumanBody%Drowned,                                   &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='DROWNED',                                       &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         Default      = OFF,                                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructOneOrigin - ModuleLagrangianGlobal - ERR1710'

                    
            if(NewOrigin%HumanBody%Drowned)then
            
                NewOrigin%State%FloatingObject = OFF
                
            else
                
                NewOrigin%State%FloatingObject = ON
                Me%State%Density               = ON
                NewOrigin%State%Density        = ON
                Me%State%Wind                  = ON
                NewOrigin%State%FloatingObject = ON
                NewOrigin%Movement%Float       = ON

            endif
                    
            
            if(NewOrigin%State%FloatingObject)then
            
                NewOrigin%FloatingObject%AirDragCoef    = 1.

                NewOrigin%FloatingObject%WaterDragCoef  = 1.

                NewOrigin%FloatingObject%ImmersionRatio = 90.
            
            end if
           
        endif

    end subroutine ConstructOneOrigin

    !--------------------------------------------------------------------------
    
    subroutine ReadSectionEmission(NewOrigin)

        !Arguments-------------------------------------------------------------
        type(T_Origin)                  :: NewOrigin

        !Local-----------------------------------------------------------------    
        real, dimension(1:2)            :: Aux1D
        integer                         :: flag, STAT_CALL, em
        logical                         :: NoDomain
        
        !Begin-----------------------------------------------------------------    
        
        call GetData(NewOrigin%SectionEmission,                                         &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='SECTION_EMISSION',                                  &
                     Default      = .false.,                                            &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ReadSectionEmission - ModuleLagrangianGlobal - ERR010'
        
 
        if (NewOrigin%SectionEmission) then
            
            call GetData(NewOrigin%SectionDepthMax,                                     &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='SECTION_DEPTH_MAX',                             &
                         Default      = -99.,                                           &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)             
            if (STAT_CALL /= SUCCESS_) stop 'ReadSectionEmission - ModuleLagrangianGlobal - ERR020'        
                   
            !Horizontal position of section END in coordinates X, Y
            call GetData(Aux1D,                                                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='SECTION_END_XY',                                &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadSectionEmission - ModuleLagrangianGlobal - ERR030'

            if (flag /= 2) then
                stop 'ReadSectionEmission - ModuleLagrangianGlobal - ERR040'
            endif

            em = Locate_ModelDomain(Aux1D(1), Aux1D(2), NoDomain) 
            
            NewOrigin%Position%ModelID = em

            if (NoDomain) then
                write(*,*) 'Discharge outside the domain - ',trim(NewOrigin%Name)
                write (*,*) 'Origin ',trim(NewOrigin%Name),' is outside of the outer model domain'
                stop 'ReadSectionEmission - ModuleLagrangianGlobal - ERR050'
            endif            
            
            NewOrigin%SectionEndX = Aux1D(1)      
            NewOrigin%SectionEndY = Aux1D(2)      
            
        endif    
    
    end subroutine ReadSectionEmission
    
    !--------------------------------------------------------------------------    
    
       !--------------------------------------------------------------------------
    
    subroutine ReadPolyEmission(NewOrigin, em)

        !Arguments-------------------------------------------------------------
        type(T_Origin)                  :: NewOrigin
        integer                         :: em
        !Local-----------------------------------------------------------------    
        type (T_Polygon), pointer       :: ModelDomainPolygon
        character(Len = PathLength)     :: PolyFilename
        integer                         :: flag, STAT_CALL
        logical                         :: InsideDomain
        
        !Begin-----------------------------------------------------------------    
        
        call GetData(PolyFilename,                                                      &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='POLY_EMISSION_FILE',                                &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)             
        if (STAT_CALL /= SUCCESS_) stop 'ReadPolyEmission - ModuleLagrangianGlobal - ERR010'
        if (flag == 0            ) stop 'ReadPolyEmission - ModuleLagrangianGlobal - ERR020'
 

        call New(NewOrigin%PolyEmission, PolyFilename)  
        
        call GetPolyLimits(PolyA    = NewOrigin%PolyEmission,                           &
                           Left     = NewOrigin%PolyLeft,                               &
                           Right    = NewOrigin%PolyRight,                              &
                           Bottom   = NewOrigin%PolyBottom,                             &
                           Top      = NewOrigin%PolyTop)
        
        InsideDomain = .false. 
        
        do em = 1, Me%EulerModelNumber
            
            call GetGridBorderPolygon(Me%EulerModel(em)%ObjHorizontalGrid, ModelDomainPolygon, STAT = STAT_CALL)
        
            if(STAT_CALL /= SUCCESS_) stop 'ReadPolyEmission - ModuleLagrangianGlobal - ERR030'

            InsideDomain = VertPolygonInsidePolygon(NewOrigin%PolyEmission, ModelDomainPolygon)


            if (InsideDomain) then
                NewOrigin%Position%ModelID = em
                exit
            endif

        enddo    
        
        if (.not. InsideDomain) then
            stop 'ReadPolyEmission - ModuleLagrangianGlobal - ERR040'
        endif

    
    end subroutine ReadPolyEmission
    
    !--------------------------------------------------------------------------    
    
    subroutine OriginLocationInWater(Position,EulerModel,FoundWater)
    
        !Arguments-------------------------------------------------------------
        type(T_Position)                :: Position
        type(T_EulerModel)              :: EulerModel  
        logical                         :: FoundWater   
        
        !Local-----------------------------------------------------------------    
        real                            :: distmin, dist, xw, yw, xc, yc, xnew, ynew
        integer                         :: ILB, IUB, JLB, JUB, KUB
        integer                         :: ic, jc, inew, jnew, dij, i, j
        integer                         :: imin, imax, jmin, jmax 
        !Begin-----------------------------------------------------------------

        ILB = EulerModel%WorkSize%ILB
        IUB = EulerModel%WorkSize%IUB
        JLB = EulerModel%WorkSize%JLB
        JUB = EulerModel%WorkSize%JUB
        KUB = EulerModel%WorkSize%KUB
        
        ic  = Position%i
        jc  = Position%j
        xc  = Position%CoordX
        yc  = Position%CoordY
        
        distmin = - FillValueReal

        FoundWater = .false.
        
d1:     do dij = 1, 10

            imin = max(ic-dij, ILB)
            imax = min(ic+dij, IUB)
            jmin = max(jc-dij, JLB)
            jmax = min(jc+dij, JUB)
                        
d2:         do i=imin, imax
d3:         do j=jmin, jmax
                if (EulerModel%Waterpoints3D(i, j, KUB) == WaterPoint) then    
                    FoundWater = .true.
                    xw = FillValueReal
                    yw = FillValueReal
                    if (i==imin) then 
                        xw = (EulerModel%XX_IE(i+1,j) + EulerModel%XX_IE(i+1,j+1))/2.
                        yw = (EulerModel%YY_IE(i+1,j) + EulerModel%YY_IE(i+1,j+1))/2. - 1e-5
                    endif    
                    if (i==imax) then 
                        xw = (EulerModel%XX_IE(i,j) + EulerModel%XX_IE(i,j+1))/2.
                        yw = (EulerModel%YY_IE(i,j) + EulerModel%YY_IE(i,j+1))/2.     + 1e-5
                    endif    
                    if (j==jmin) then 
                        xw = (EulerModel%XX_IE(i,j+1) + EulerModel%XX_IE(i+1,j+1))/2. - 1e-5
                        yw = (EulerModel%YY_IE(i,j+1) + EulerModel%YY_IE(i+1,j+1))/2. 
                    endif    
                    if (j==jmax) then 
                        xw = (EulerModel%XX_IE(i,j) + EulerModel%XX_IE(i+1,j))/2.     + 1e-5
                        yw = (EulerModel%YY_IE(i,j) + EulerModel%YY_IE(i+1,j))/2.     
                    endif                                                           
                    
                    dist = sqrt((xw-xc)**2+(yw-yc)**2)
                    
                    if (dist < distmin) then
                        distmin = dist
                        xnew    = xw
                        ynew    = yw
                        inew    = i
                        jnew    = j
                    endif
                    
                endif    
                                            
            enddo d3
            enddo d2 
            
            if (FoundWater) exit               
            
        enddo d1
        
        if (FoundWater) then
            Position%i      = inew
            Position%j      = jnew
            Position%CoordX = xnew
            Position%CoordY = ynew
        endif
    
    end subroutine OriginLocationInWater
    

    logical function CheckOriginInLandCell ()


        !Local-----------------------------------------------------------------
        type (T_Position)                           :: Position
        character (len = StringLength)              :: OriginName, EmissionSpatial
        real, dimension(1:2)                        :: Aux1D
        character(3)                                :: Aux
        integer                                     :: flag
        integer                                     :: STAT_CALL
        integer                                     :: i, j, k, em
        logical                                     :: Default, HaveOrigin, NoDomain


        !Begin-----------------------------------------------------------------


        CheckOriginInLandCell = .false. 

        !Gets its name    
        call GetData(OriginName,                                                        &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='ORIGIN_NAME',                                       &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'CheckOriginInLandCell - ModuleLagrangianGlobal - ERR10'

        if (flag == 0) then
            Aux = ' '
            write(Aux,'(i3)') Me%nOrigins + 1
            OriginName = trim(adjustl('Origin_'//trim(adjustl(Aux))))
        end if

        call GetData(Default,                                                           &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='DEFAULT',                                           &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     Default      = OFF,                                                &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'CheckOriginInLandCell - ModuleLagrangianGlobal - ERR20'
        
        !Gets the spatial emission type
        call GetData(EmissionSpatial,                                                   &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromBlock,                                          &
                     keyword      ='EMISSION_SPATIAL',                                  &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)        
        if (STAT_CALL /= SUCCESS_) stop 'CheckOriginInLandCell - ModuleLagrangianGlobal - ERR300'        
           
NDF:    if (.not. Default .and.                                                         &
            (trim(adjustl(EmissionSpatial)) /= trim(Char_Box) .and.                     &
             trim(adjustl(EmissionSpatial)) /= trim(Char_Poly))) then
    
            !Horizontal position in coordinates X, Y
            call GetData(Aux1D,                                                         &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromBlock,                                      &
                         keyword      ='POSITION_COORDINATES',                          &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'CheckOriginInLandCell - ModuleLagrangianGlobal - ERR30'

            if (flag == 2) then
                HaveOrigin = .true.
            endif

            em = Locate_ModelDomain(Aux1D(1), Aux1D(2), NoDomain) 

            if (NoDomain) then
                write(*,*) 'Discharge outside the domain - ',trim(OriginName),' - ',trim(Me%EulerModel(Me%EulerModelNumber)%Name)
                write (*,*) 'Origin ',trim(OriginName),' is outside of the outer model domain'
                stop 'CheckOriginInLandCell - ModuleLagrangianGlobal - ERR40'
            endif

            Position%CoordX = Aux1D(1)
            Position%CoordY = Aux1D(2)

            call Convert_XY_CellIJ(Me%EulerModel(em), Position, Referential = GridCoord_)
                
            !Checks if a valid horizontal origin was found
            if (.not. HaveOrigin) then

                write(*,*)'No Valid Horizontal Location defined for ',trim(adjustl(OriginName))
                stop 'CheckOriginInLandCell - ModuleLagrangianGlobal - ERR50'

            endif

            !Verifies the horizontal location of the origin
            i = Position%I
            j = Position%J
            k = Me%EulerModel(em)%WorkSize%KUB

            if (Me%EulerModel(em)%Waterpoints3D(i, j, k) /= WaterPoint) then
                write(*,*) 'Discharge in a land cell I=',i,' J=',j,'Model name=',trim(Me%EulerModel(em)%Name)
                CheckOriginInLandCell = .true.
            endif

            

        endif NDF

    end function CheckOriginInLandCell

    !--------------------------------------------------------------------------


    subroutine BoxTypeVariablesDefiniton

    !Local---------------------------------------------------------------------
    integer                 :: flag, STAT_CALL, em
    !Begin---------------------------------------------------------------------

        !Boxes data file
        call GetData(Me%Files%BoxDataFile,                                              &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='PARTIC_BOX',                                        &
                     ClientModule ='ModuleLagrangianGlobal',                                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR120'
        if (flag == 1) then


            Me%State%BoxDif = .true.
            
        endif

        !Boxes data file
        call GetData(Me%Files%MonitorBox,                                               &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='MONITOR_BOX',                                       &
                     ClientModule ='ModuleLagrangianGlobal',                                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR140'
        if (flag == 1) then

            Me%State%Monitor = .true.


            !Name of the Property
            call GetData(Me%MonitorProperty,                                       &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='MONITOR_BOX_PROP_MASS',                         &
                         ClientModule ='ModuleLagrangianGlobal',                              &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR160'

            if (flag == 1) then

                !Checks if the property is recognized by the model       
                if (.not. CheckPropertyName(trim(Me%MonitorProperty), Me%MonitorPropertyID)) then
                    write (*,*)'Unknown Property : ', trim(Me%MonitorProperty)
                    stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR170'
                end if

                Me%State%MonitorPropMass = .true.
            end if
            if (Me%State%MonitorPropMass) then
            
                !Output Concentration Type
                call GetData(Me%MonitorMassFractionType,                                        &
                             Me%ObjEnterData,                                                   &
                             flag,                                                              &
                             SearchType   = FromFile,                                           &
                             keyword      ='MONITOR_BOX_MASS_FRACTION',                         &
                             ClientModule ='ModuleLagrangianGlobal',                                  &
                             Default      = Arithmetic,                                         &
                             STAT         = STAT_CALL)        
                if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR175'

                ! Minimum Tracer Concentration Value for Average Concentration 
                !and Contamination Probability in Each Monitoring Box

                call GetData(Me%MonitorBox_TracerMinConc,                                   &
                             Me%ObjEnterData,                                               &
                             flag,                                                          &
                             SearchType   = FromFile,                                       &
                             keyword      ='MONITOR_BOX_MIN_CONC',                          &
                             ClientModule ='ModuleLagrangianGlobal',                              &
                             Default      = 1.,                                             &
                             STAT         = STAT_CALL)
               if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR176'

               ! Depth considered to contamination probability
                call GetData(Me%MonitorContaminationDepth,                                  &
                             Me%ObjEnterData,                                               &
                             flag,                                                          &
                             SearchType   = FromFile,                                       &
                             keyword      ='MONITOR_BOX_CONT_DEPTH',                        &
                             ClientModule ='ModuleLagrangianGlobal',                              &
                             Default      = null_real,                                      &
                             STAT         = STAT_CALL)
               if (STAT_CALL /= SUCCESS_) stop 'ConstructOrigins - ModuleLagrangianGlobal - ERR177'
            
            end if

        endif

        !Eulerian boxes data file
        call GetData(Me%Files%EulerianMonitorBox,                                       &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='EULERIAN_MONITOR_BOX',                              &
                     ClientModule ='ModuleLagrangianGlobal',                                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR180'
        
        if (flag == 1) Me%State%EulerianMonitor = .true.

        !Associates Beaching Probabilities 
        call GetData(Me%State%AssociateBeachProb,                                       &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='ASSOCIATE_BEACH_PROB',                              &
                     Default      = .false.,                                            &
                     ClientModule ='ModuleLagrangianGlobal',                                  &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR190'

        if (Me%State%AssociateBeachProb) then

            !Maximum distance between particles and coast for particle beaching 
            call GetData(Me%DefaultBeachingLimit,                                       &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='BEACHING_LIMIT',                                &
                         Default      = 5.0,                                            &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR200'

            !Outbox Beaching Probability
            call GetData(Me%DefaultBeachingProbability,                                 &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='DEFAULT_BEACHING_PROB',                         &
                         Default      = 0.5,                                            &
                         ClientModule ='ModuleLagrangianGlobal',                              &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR210'


            !Beaching Probabilities Boxes data file
            call GetData(Me%Files%BeachingBoxFileName,                                  &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='BEACHING_BOX_FILENAME',                         &
                         ClientModule ='ModuleLagrangianGlobal',                              &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR220'
            if (flag == 1) then

                Me%State%HaveBeachingProbBox = .true.
        
            endif

            call GetData(Me%DefaultShoreType,                                           &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='DEFAULT_SHORE_TYPE',                            &
                         Default      = 5,                                              &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR230'

            !Shoreline types Boxes data file
            call GetData(Me%Files%ShoreTypeBoxFileName,                                 &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='SHORE_TYPE_BOX_FILENAME',                       &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR240'
            if (flag == 1) then

                Me%State%HaveShoreTypeBox = .true.
        
            endif


            call GetData(Me%DefaultRemovalRateCoef,                                     &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='REMOVAL_RATE_COEF',                             &
                         Default      = 0.,                                             &
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR230'

            !Spatial definition for Beaching  Limit
            call GetData(Me%BeachingLimitSpatial,                                           &
                         Me%ObjEnterData,                                                   &
                         flag,                                                              &
                         SearchType   = FromFile,                                           &
                         keyword      ='BEACHING_LIMIT_SPATIAL',                            &
                         Default      = Constant_,                                          &
                         ClientModule ='ModuleLagrangianGlobal',                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR205'
           
            !Spatial definition for Removal Rate Coef
            call GetData(Me%RemovalRateCoefSpatial,                                         &
                         Me%ObjEnterData,                                                   &
                         flag,                                                              &
                         SearchType   = FromFile,                                           &
                         keyword      ='REMOVAL_RATE_COEF_SPATIAL',                         &
                         Default      = Constant_,                                          &
                         ClientModule ='ModuleLagrangianGlobal',                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR206'

        else
            Me%BeachingLimitSpatial = Constant_                       
        endif
            
        if (Me%State%OutputTracerInfo) then
            !Distance to assume tracer is near coastline
            call GetData(Me%NearCoastDistance,                                              &
                         Me%ObjEnterData,                                                   &
                         flag,                                                              &
                         SearchType   = FromFile,                                           &
                         keyword      ='NEAR_COAST_DISTANCE',                               &
                         Default      = 500.,                                               &
                         ClientModule ='ModuleLagrangianGlobal',                            &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR207'
        end if
        
d1:     do em = 1, Me%EulerModelNumber

            if (Me%State%BoxDif) then
                        !Starts BoxDif
                call StartBoxDif(BoxDifID         = Me%EulerModel(em)%ObjBoxDif,        &
                                 TimeID           = Me%EulerModel(em)%ObjTime,          &
                                 HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                 BoxesFilePath    = Me%Files%BoxDataFile,               &
                                 WaterPoints3D    = Me%EulerModel(em)%Waterpoints3D,    &
                                 Size3D           = Me%EulerModel(em)%Size,             &
                                 WorkSize3D       = Me%EulerModel(em)%WorkSize,         &
                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR130'

            endif

            if (Me%State%Monitor) then

                !Starts BoxDif
                call StartBoxDif(BoxDifID         = Me%EulerModel(em)%ObjMonBox,        & 
                                 TimeID           = Me%EulerModel(em)%ObjTime,          &
                                 HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                 BoxesFilePath    = Me%Files%MonitorBox,                &
                                 WaterPoints3D    = Me%EulerModel(em)%Waterpoints3D,    &
                                 Size3D           = Me%EulerModel(em)%Size,             &
                                 WorkSize3D       = Me%EulerModel(em)%WorkSize,         &
                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR150'

            endif


            if (Me%State%HaveBeachingProbBox) then

                !Starts BoxDif
                call StartBoxDif(BoxDifID         = Me%EulerModel(em)%ObjBeachingProbBox,&
                                 TimeID           = Me%EulerModel(em)%ObjTime,           &
                                 HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid, &
                                 BoxesFilePath    = Me%Files%BeachingBoxFileName,       &
                                 WaterPoints3D    = Me%EulerModel(em)%Waterpoints3D,    &
                                 Size3D           = Me%EulerModel(em)%Size,             &
                                 WorkSize3D       = Me%EulerModel(em)%WorkSize,         &
                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR230'

                Me%State%HaveBeachingProbBox = .true.
        
            endif

            if (Me%State%HaveShoreTypeBox) then

                !Starts BoxDif
                call StartBoxDif(BoxDifID         = Me%EulerModel(em)%ObjShoreTypeBox,                  &
                                 TimeID           = Me%EulerModel(em)%ObjTime,                          &
                                 HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,                &
                                 BoxesFilePath    = Me%Files%ShoreTypeBoxFileName,                      &
                                 WaterPoints3D    = Me%EulerModel(em)%Waterpoints3D,                    &
                                 Size3D           = Me%EulerModel(em)%Size,                             &
                                 WorkSize3D       = Me%EulerModel(em)%WorkSize,                         &
                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'BoxTypeVariablesDefiniton - ModuleLagrangianGlobal - ERR170'

                Me%State%HaveBeachingProbBox = .true.
        
            endif

        enddo d1

    end subroutine BoxTypeVariablesDefiniton

    !--------------------------------------------------------------------------

    subroutine PolyMonitorLag

        !Local---------------------------------------------------------------------
        integer                     :: flag, STAT_CALL, ClientNumber
        integer                     :: Naux, LastLine, FirstLine, nP, line
        logical                     :: BlockFound
        character(len=PathLength)   :: AuxChar
        type (T_Polygon), pointer   :: AuxPoly
        !Begin---------------------------------------------------------------------

        !If user want to monitor using polygons instead of boxes
        call GetData(Me%State%MonitorLag,                                               &
                     Me%ObjEnterData,                                                   &
                     flag,                                                              &
                     SearchType   = FromFile,                                           &
                     keyword      ='MONITOR_POLY',                                      &
                     ClientModule ='ModuleLagrangianGlobal',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR10'
        endif

        if (Me%State%MonitorLag) then
            
            call GetData(Me%MonitorLag%DT,                                              &
                         Me%ObjEnterData,                                               &
                         flag,                                                          &
                         SearchType   = FromFile,                                       &
                         keyword      ='MONITOR_POLY_DT',                               &
                         default      = Me%DT_Partic,                                   & 
                         ClientModule ='ModuleLagrangianGlobal',                        &
                         STAT         = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR20'
            endif          
            
            Me%MonitorLag%NextOutPut = Me%ExternalVar%BeginTime
            
            call ExtractBlockFromBuffer(EnterDataID     = Me%ObjEnterData,              &
                                        ClientNumber    = ClientNumber,                 &
                                        block_begin     = '<BeginMonitorPoly>',         &
                                        block_end       = '<EndMonitorPoly>',           &
                                        BlockFound      = BlockFound,                   &
                                        FirstLine       = FirstLine,                    &
                                        LastLine        = LastLine,                     &
                                        STAT            = STAT_CALL)
    
            if (STAT_CALL /= SUCCESS_) stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR30'

    BF:     if (BlockFound) then

                Naux = LastLine - FirstLine - 1

                Me%MonitorLag%NumberOfPoly = Naux
                
                allocate(Me%MonitorLag%ObjTimeSerie    (Naux))
                allocate(Me%MonitorLag%Poly            (Naux))
                

  
                nP = 0
                do line = FirstLine + 1, LastLine - 1

                    call GetData(value          = AuxChar,                              &
                                 EnterDataID    = Me%ObjEnterData,                      &
                                 flag           = flag,                                 &
                                 SearchType     = FromBlock,                            &
                                 Buffer_Line    = line,                                 &
                                 STAT           = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_) then
                        stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR40'
                    endif
                    
                    nP = nP + 1
                    
                    nullify(AuxPoly)
                    
                    call New(AuxPoly, trim(AuxChar), Me%GridsBounds)
                    
                    Me%MonitorLag%Poly(nP) = AuxPoly

                enddo

            else BF
        
                if (STAT_CALL /= SUCCESS_) then
                    stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR50'
                endif

            endif BF

            call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) then
                stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR60'
            endif

            !Prepares file for a new block search throughout the entire file
            call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'PolyMonitorLag - ModuleLagrangianGlobal - ERR70'
            endif

        endif            

    end subroutine PolyMonitorLag

    !--------------------------------------------------------------------------
        


    subroutine CheckForOriginClones(OriginName, ClientNumber, ClientNumberClone,        &
                                    FoundCloneOrigin, ClonesExist)


        !Arguments-------------------------------------------------------------
        character(len=*), intent(IN)                :: OriginName
        integer         , intent(IN)                :: ClientNumber
        integer         , intent(OUT)               :: ClientNumberClone
        logical         , intent(OUT)               :: FoundCloneOrigin, ClonesExist

        !Local-----------------------------------------------------------------
        character(len=StringLength)                 :: OriginNameClone
        logical                                     :: BlockFound
        integer                                     :: STAT_CALL, flag
        integer                                     :: StartLine, EndLine 
        integer, save                               :: PreviousStart


        !Begin-----------------------------------------------------------------

        !first time check if exist "clone" blocks
i1:     if (Me%ObjEnterDataClone == 0) then

            !Construct enter data "clone"
            call ConstructEnterData(Me%ObjEnterDataClone, Me%Files%ConstructData,       &
                ErrorMessage = "CheckForOriginClones - ModuleLagrangianGlobal", STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR10'

            call ExtractBlockFromBuffer(Me%ObjEnterDataClone,                           &
                                        ClientNumberClone,                              &
                                        block_begin_Clone, block_end_Clone,             &
                                        BlockFound,                                     &
                                        STAT = STAT_CALL)  
            if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR20'

i2:         if (BlockFound) then
    
                !Construct enter data original again
                call ConstructEnterData(Me%ObjEnterDataOriginal, Me%Files%ConstructData,&
                                        ErrorMessage = "CheckForOriginClones - ModuleLagrangianGlobal", STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR30'

                PreviousStart  = FillValueInt

                call RewindBuffer(Me%ObjEnterDataClone,                                 &
                                  STAT = STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR40'


            else  i2

                ClonesExist = .false. 

                !Finished reading block -> unlocks block reading
                call Block_Unlock(Me%ObjEnterDataClone,                                 &
                                  ClientNumberClone,                                    &
                                  STAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR50'

                call KillEnterData(Me%ObjEnterDataClone, STAT = STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR60'

            endif i2

        endif i1

i3:     if (ClonesExist) then

d2:     do
 
            call ExtractBlockFromBuffer(Me%ObjEnterDataClone,                           &
                                        ClientNumberClone,                              &
                                        block_begin_Clone, block_end_Clone,             &
                                        BlockFound,                                     &
                                        STAT = STAT_CALL)  
            if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR70'


i4:         if (BlockFound) then 

                call GetBlockSize(Me%ObjEnterDataClone, ClientNumberClone, StartLine, EndLine, STAT= STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR80'

i5:             if (StartLine > PreviousStart) then

                    call GetData(OriginNameClone,                                       &
                                 Me%ObjEnterDataClone,                                  &
                                 flag,                                                  &
                                 SearchType   = FromBlock,                              &
                                 keyword      ='CLONE',                                 &
                                 ClientModule ='ModuleLagrangianGlobal',                      &
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR90'

                    if (flag == 0) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR100'


i6:                if (trim(OriginNameClone) == trim(OriginName)) then
                        FoundCloneOrigin = .true.

                        call ReplaceKeywordsInClone(ClientNumber, ClientNumberClone, StartLine, EndLine)

                        PreviousStart = StartLine

                        exit

                    endif i6

                endif i5

            else i4

                PreviousStart  = FillValueInt

                call RewindBuffer(Me%ObjEnterDataClone, STAT = STAT_CALL)  
                if (STAT_CALL /= SUCCESS_) stop 'CheckForOriginClones - ModuleLagrangianGlobal - ERR110'

                FoundCloneOrigin = .false.

                exit

            endif i4

        enddo d2

        endif i3

    end subroutine CheckForOriginClones

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    subroutine ReplaceKeywordsInClone(ClientNumber, ClientNumberClone, StartClone, EndClone)


        !Arguments-------------------------------------------------------------
        integer                                     :: ClientNumber, ClientNumberClone, StartClone, EndClone

        !Local-----------------------------------------------------------------
        character(len=PathLength)                   :: FullBufferLine
        character(len=StringLength)                 :: KeywordClone, KeywordOriginal
        logical                                     :: ExistKeywordClone, ExistKeywordOriginal
        logical                                     :: BlockInBlockOn, BlockPropON
        integer                                     :: StartLine, EndLine
        integer                                     :: lineC, lineO
        integer                                     :: STAT_CALL


        !Begin-----------------------------------------------------------------

        call GetBlockSize(Me%ObjEnterData, ClientNumber, StartLine, EndLine, STAT = STAT_CALL)  
        if (STAT_CALL /= SUCCESS_) stop 'ReplaceKeywordsInClone - ModuleLagrangianGlobal - ERR10'

        BlockPropON    = .false.
        BlockInBlockOn = .false. 

d1:     do lineC = StartClone, EndClone

            call GetFullBufferLine    (Me%ObjEnterDataClone, lineC, FullBufferLine, STAT = STAT_CALL)  
            if (STAT_CALL /= SUCCESS_) stop 'ReplaceKeywordsInClone - ModuleLagrangianGlobal - ERR20'

            if (trim(FullBufferLine) == property_begin) then
                BlockInBlockOn = .true.
                BlockPropON    = .true.
            endif

            if (trim(FullBufferLine) == property_end) then 
                BlockInBlockOn = .false.
                cycle 
            endif

            if (BlockInBlockOn) cycle

            call GetKeywordFromLine(Me%ObjEnterDataClone, lineC, ExistKeywordClone, KeywordClone, STAT = STAT_CALL)  
            if (STAT_CALL /= SUCCESS_) stop 'ReplaceKeywordsInClone - ModuleLagrangianGlobal - ERR20'

i1:         if (ExistKeywordClone) then
                             
i2:             if (trim(KeywordClone) /= 'CLONE') then

d2:                 do lineO = StartLine, EndLine                

                        call GetKeywordFromLine(Me%ObjEnterDataOriginal, lineO,         &
                                                ExistKeywordOriginal, KeywordOriginal, STAT = STAT_CALL)  
                        if (STAT_CALL /= SUCCESS_) stop 'ReplaceKeywordsInClone - ModuleLagrangianGlobal - ERR30'
                    
i3:                     if (ExistKeywordOriginal) then

i4:                         if (trim(KeywordClone) == trim(KeywordOriginal)) then

                                call GetFullBufferLine    (Me%ObjEnterDataClone, lineC, FullBufferLine, STAT = STAT_CALL)  
                                if (STAT_CALL /= SUCCESS_) stop 'ReplaceKeywordsInClone - ModuleLagrangianGlobal - ERR40'

                                call ReplaceFullBufferLine(Me%ObjEnterData,      lineO, FullBufferLine, STAT = STAT_CALL)  
                                if (STAT_CALL /= SUCCESS_) stop 'ReplaceKeywordsInClone - ModuleLagrangianGlobal - ERR50'

                                exit

                            endif i4
                        endif i3
                    enddo d2
                endif i2
            endif i1

        enddo d1
        
        if (BlockPropON) call ReplacePropInClone(ClientNumber, ClientNumberClone)


    end subroutine ReplaceKeywordsInClone


    !--------------------------------------------------------------------------

    subroutine ReplacePropInClone(ClientNumber, ClientNumberClone)


        !Arguments-------------------------------------------------------------
        integer                                     :: ClientNumber, ClientNumberClone

        !Local-----------------------------------------------------------------
        character(len=PathLength)                   :: FullBufferLine
        character(len=StringLength)                 :: PropNameClone, PropName, KeywordClone, KeywordOriginal
        logical                                     :: ExistKeywordClone, ExistKeywordOriginal
        logical                                     :: PropertyCloneFound, PropertyFound
        integer                                     :: StartLine, EndLine
        integer                                     :: StartClone, EndClone
        integer                                     :: lineC, lineO, flag
        integer                                     :: STAT_CALL


        !Begin-----------------------------------------------------------------

d1:     do 
 
            call ExtractBlockFromBlock(Me%ObjEnterDataClone, ClientNumberClone,         &
                                       property_begin, property_end,                    &
                                       PropertyCloneFound, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR10'
            
i1:         if (PropertyCloneFound) then

                call GetData(PropNameClone,                                             &
                             Me%ObjEnterDataClone,                                      &
                             flag,                                                      &
                             SearchType   = FromBlockinBlock,                           &
                             keyword      ='NAME',                                      &
                             ClientModule ='ModuleLagrangianGlobal',                    &
                             STAT         = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR20'

                if (flag == 0) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR30'


                call RewindBlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)  
            
                if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR140'

d2:             do 
 
                    call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,           &
                                               property_begin, property_end,            &
                                               PropertyFound, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR30'

                    if (.not. PropertyFound) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR40'

                    call GetData(PropName,                                              &
                                 Me%ObjEnterData,                                       &
                                 flag,                                                  &
                                 SearchType   = FromBlockinBlock,                       &
                                 keyword      ='NAME',                                  &
                                 ClientModule ='ModuleLagrangianGlobal',                &
                                 STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR50'

                    if (flag == 0) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR60'


i2:                 if (trim(PropNameClone) == trim(PropName)) then

                        call GetBlockSize(Me%ObjEnterData, ClientNumber,                &
                                          StartLine, EndLine, SearchType = FromBlockInBlock, STAT = STAT_CALL)  
                        if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR70'

                        call GetBlockSize(Me%ObjEnterDataClone, ClientNumberClone,      &
                                          StartClone, EndClone, SearchType = FromBlockinBlock, STAT = STAT_CALL)  
                        if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR80'

d3:                     do lineC = StartClone, EndClone

                            call GetFullBufferLine    (Me%ObjEnterDataClone, lineC, FullBufferLine, STAT = STAT_CALL)  
                            if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR90'

                            call GetKeywordFromLine(Me%ObjEnterDataClone, lineC, &
                                                    ExistKeywordClone, KeywordClone, STAT = STAT_CALL)  
                            if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR100'

i3:                         if (ExistKeywordClone) then
                             
i4:                             if (trim(KeywordClone) /= 'NAME') then

d4:                                 do lineO = StartLine, EndLine                

                                        call GetKeywordFromLine(Me%ObjEnterDataOriginal, lineO,         &
                                                                ExistKeywordOriginal, KeywordOriginal, STAT = STAT_CALL)  
                                        if (STAT_CALL /= SUCCESS_) stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR110'
                    
i5:                                     if (ExistKeywordOriginal) then

i6:                                         if (trim(KeywordClone) == trim(KeywordOriginal)) then

                                                call GetFullBufferLine    (Me%ObjEnterDataClone, lineC, &
                                                                           FullBufferLine, STAT = STAT_CALL)
                                                if (STAT_CALL /= SUCCESS_)              &
                                                    stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR120'

                                                call ReplaceFullBufferLine(Me%ObjEnterData,      lineO, &
                                                                           FullBufferLine, STAT = STAT_CALL)  
                                                if (STAT_CALL /= SUCCESS_)              &
                                                    stop 'ReplacePropInClone - ModuleLagrangianGlobal - ERR130'

                                                exit

                                            endif i6
                                        endif i5
                                    enddo d4
                                endif i4
                            endif i3

                        enddo d3
                        
                        exit

                    endif i2
                    
                enddo d2


            else i1

                exit

            endif i1

        enddo d1

        

    end subroutine ReplacePropInClone
    !--------------------------------------------------------------------------

!#ifdef _CGI_

    !--------------------------------------------------------------------------
    subroutine ReadQueryString(Nmax)


        !Arguments-------------------------------------------------------------
        integer                                     :: Nmax

        !Local-----------------------------------------------------------------
        real,  dimension(:), pointer                :: AuxReal
        !character(Len=1024)                         :: Online_St, Online_St2
        integer                                     :: i !, j, k, no
        !integer                                     :: STAT_CALL
        !integer(2)                                  :: STAT2


        !Begin-----------------------------------------------------------------

        call GetDataOnlineString ('LAG_NORIGINS', IntData = Nmax)

        call GetDataOnlineString ('EMISSION',     IntData = Me%Online%EmissionTemporal)


        allocate(Me%Online%X(1:Nmax), Me%Online%Y(1:Nmax))
        allocate(Me%Online%WindCoef(1:Nmax))
        allocate(Me%Online%StartDate    (1:Nmax,6))
        allocate(Me%Online%Flow         (1:Nmax  ))        
        allocate(Me%Online%Concentration(1:Nmax  ))                
        allocate(Me%Online%T90          (1:Nmax  ))                

        
        allocate(AuxReal(1:2*Nmax))

        call GetDataOnlineString ('LAG_XY', ArrayData = AuxReal)

        do i = 1, Nmax
            Me%Online%X(i) = AuxReal(2*i-1)
            Me%Online%Y(i) = AuxReal(2*i  )
        enddo

        deallocate(AuxReal)

        allocate(AuxReal(1:6*Nmax))

        call GetDataOnlineString ('LAG_START', ArrayData = AuxReal)
         
        do i=1,Nmax
            !1 - Year, 2 - Month, 3 - Day, 4 - Hours, 5 - Minutes, 6 - seconds, 7 - miliseconds
            Me%Online%StartDate(i,1:6) = AuxReal(i*6-5:i*6)
        enddo

        deallocate(AuxReal)

        call GetDataOnlineString ('WIND_COEF',     ArrayData = Me%Online%WindCoef     )
        
        if (Me%Online%EmissionTemporal == Continuous_) then

            call GetDataOnlineString ('FLOW',          ArrayData = Me%Online%Flow         )        

            call GetDataOnlineString ('CONCENTRATION', ArrayData = Me%Online%Concentration)        

            call GetDataOnlineString ('T90',           ArrayData = Me%Online%T90          )                

        endif
        
    end subroutine ReadQueryString

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ChangeOriginOnline(Nmax) !, NFirstExtraction)


        !Arguments-------------------------------------------------------------
        integer                                     :: Nmax !, NFirstExtraction

        !Local-----------------------------------------------------------------
        type (T_Origin),   pointer                  :: NewOrigin
        type (T_Property), pointer                  :: CurrentProperty
        character(Len=PathLength)                   :: String
        integer                                     :: i, em
        logical                                     :: NoDomain


        !Begin-----------------------------------------------------------------

!        if (Me%Online%ON) then

        NewOrigin=> Me%FirstOrigin            
        
        do i=1, Nmax
 !       do j=1, NFirstExtraction

            NewOrigin%Position%ModelID =  Locate_ModelDomain(Me%Online%X(i), Me%Online%Y(i), NoDomain) 
            if (NoDomain) then
                stop 'ChangeOriginOnline - ModuleLagrangianGlobal - ERR10'
            endif

            em = NewOrigin%Position%ModelID

            NewOrigin%Position%CoordX = Me%Online%X(i)
            NewOrigin%Position%CoordY = Me%Online%Y(i)

            call Convert_XY_CellIJ(Me%EulerModel(em), NewOrigin%Position, Referential = GridCoord_)

            !Change Origin name
            write(String,*) i
            NewOrigin%Name = trim(NewOrigin%Name)//'_'//trim(adjustl(String))

            Me%Online%StartDate(i,6) = Me%Online%StartDate(i,6)

            call SetDate (NewOrigin%StartEmission, Me%Online%StartDate(i,1), Me%Online%StartDate(i,2), &
                                                   Me%Online%StartDate(i,3), Me%Online%StartDate(i,4), &
                                                   Me%Online%StartDate(i,5), Me%Online%StartDate(i,6))


             NewOrigin%Movement%WindTransferCoef = Me%Online%WindCoef(i)
           
            NewOrigin%EmissionTemporal = Me%Online%EmissionTemporal
            
            if (NewOrigin%EmissionTemporal == Instantaneous_)                           &
                NewOrigin%StopEmission = NewOrigin%StartEmission

            if (NewOrigin%EmissionTemporal == Continuous_) then
                NewOrigin%Flow = Me%Online%Flow(i)
                
                CurrentProperty => NewOrigin%FirstProperty
                do while (associated(CurrentProperty))
                    if (CurrentProperty%ID == Fecal_Coliforms_) then
                        
                        CurrentProperty%Concentration = Me%Online%Concentration(i)
                        CurrentProperty%T90           = Me%Online%T90          (i)
                        exit
                            
                    endif
                    
                    CurrentProperty => CurrentProperty%Next
                enddo
            endif

!        enddo
        
        NewOrigin => NewOrigin%Next        
        
        enddo

!        endif

        deallocate(Me%Online%X, Me%Online%Y)
        deallocate(Me%Online%StartDate     )
        deallocate(Me%Online%WindCoef      )
        deallocate(Me%Online%Flow          )
        deallocate(Me%Online%Concentration )
        deallocate(Me%Online%T90           )


    end subroutine ChangeOriginOnline

    !--------------------------------------------------------------------------
!#endif
    !--------------------------------------------------------------------------
    subroutine ConstructEmissionType(NewOrigin, EmissionSpatial, EmissionTemporal)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: NewOrigin
        character(len=*)                            :: EmissionSpatial
        character(len=*)                            :: EmissionTemporal

        !Local-----------------------------------------------------------------


        !Spatial Emission type
        select case (trim(adjustl(EmissionSpatial)))

        case (trim(adjustl(Char_Point)))

            NewOrigin%EmissionSpatial = Point_

        case (trim(adjustl(Char_Box)))

            NewOrigin%EmissionSpatial = Box_

        case (trim(adjustl(Char_Accident)))

            NewOrigin%EmissionSpatial = Accident_
            
         case (trim(adjustl(Char_Poly)))

            NewOrigin%EmissionSpatial = Poly_           

        case default
            
            write(*,*)'Unknown Spatial Emission type ', trim(adjustl(EmissionSpatial))
            write(*,*)'Valid option [1] :',trim(adjustl(Char_Point))
            write(*,*)'Valid option [2] :',trim(adjustl(Char_Box))
            write(*,*)'Valid option [3] :',trim(adjustl(Char_Accident))
            write(*,*)'Valid option [4] :',trim(adjustl(Char_Poly))            
            write(*,*)'Origin           :',trim(adjustl(NewOrigin%Name))
            stop 'ConstructEmissionType - ModuleLagrangianGlobal - ERR01'

        end select


        !Temporal Emission type
        select case (trim(adjustl(EmissionTemporal)))

        case (trim(adjustl(Char_Continuous)))

            NewOrigin%EmissionTemporal = Continuous_

        case (trim(adjustl(Char_Instantaneous)))

            NewOrigin%EmissionTemporal = Instantaneous_

        case default

            write(*,*)'Unknown Temporal Emission type ', trim(adjustl(EmissionTemporal))
            write(*,*)'Valid option [1] :',trim(adjustl(Char_Continuous))
            write(*,*)'Valid option [2] :',trim(adjustl(Char_Instantaneous))
            write(*,*)'Origin           :',trim(adjustl(NewOrigin%Name))
            stop 'ConstructEmissionType - ModuleLagrangianGlobal - ERR01'

        end select

        
        !Verifies consistency
        if (NewOrigin%EmissionTemporal == Continuous_ .and. NewOrigin%EmissionSpatial == Accident_) then
            write(*,*)'Cant emit particle in continous as accident'
            write(*,*)'Origin :',trim(adjustl(NewOrigin%Name))
            stop 'ConstructEmissionType - ModuleLagrangianGlobal - ERR02'
        endif

        !If BoxDif isnt associated keyword Partic PARTIC_BOX wasnt found
        if (NewOrigin%EmissionSpatial == Box_ .and. Me%EulerModel(1)%ObjBoxDif == 0) then
            write(*,*)'Cant emit particle in a box, once keyword PARTIC_BOX wasnt given'
            write(*,*)'Origin :',trim(adjustl(NewOrigin%Name))
            stop 'ConstructEmissionType - ModuleLagrangianGlobal - ERR03'
        endif


    end subroutine ConstructEmissionType

    !--------------------------------------------------------------------------

    subroutine ConstructEmission 

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            !Constructs the Temporal emission 
            if (CurrentOrigin%EmissionTemporal == Continuous_) then

                call ConstructEmissionTime          (CurrentOrigin)

            endif

            if (CurrentOrigin%EmissionTemporal == Instantaneous_) then

                CurrentOrigin%OnlyOnceEmit = .true.

            endif
    
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

        call ParticleEmission ()

    end subroutine ConstructEmission

    !--------------------------------------------------------------------------

    subroutine ConstructOverlay

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        integer                                     :: SizeILB, SizeIUB
        integer                                     :: SizeJLB, SizeJUB
        integer                                     :: SizeKLB, SizeKUB, em

        !Begin-----------------------------------------------------------------
        
em1:    do em =1, Me%EulerModelNumber

            !Shorten Size
            SizeILB     = Me%EulerModel(em)%Size%ILB   
            SizeIUB     = Me%EulerModel(em)%Size%IUB   
            SizeJLB     = Me%EulerModel(em)%Size%JLB   
            SizeJUB     = Me%EulerModel(em)%Size%JUB   
            SizeKLB     = Me%EulerModel(em)%Size%KLB   
            SizeKUB     = Me%EulerModel(em)%Size%KUB   
        
            if (Me%OverLay) then

                allocate (Me%EulerModel(em)%OverLay%VelUFinal (SizeILB:SizeIUB, SizeJLB:SizeJUB, SizeKLB:SizeKUB))
                allocate (Me%EulerModel(em)%OverLay%VelVFinal (SizeILB:SizeIUB, SizeJLB:SizeJUB, SizeKLB:SizeKUB))

            else
        
                nullify (Me%EulerModel(em)%OverLay%VelUFinal)
                nullify (Me%EulerModel(em)%OverLay%VelVFinal)

            endif

        enddo em1


    end subroutine ConstructOverlay

    !--------------------------------------------------------------------------

    subroutine ConstructMonitoring 

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                    :: EulerModel
        integer                                         :: nB
        integer                                         :: NumberOfOrigins, iO
        integer                                         :: STAT_CALL
        character(StringLength), dimension(:), pointer  :: PropertyList
        character(StringLength)                         :: AuxChar
        type (T_Property), pointer                      :: CurrentProperty
        integer                                         :: iProp
        integer                                         :: ILB, IUB
        integer                                         :: JLB, JUB
        integer                                         :: KLB, KUB, em, NumberOfBoxes

        !Begin-----------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber
        
            EulerModel => Me%EulerModel(em)
        
            if (Me%State%Monitor) then

                call GetNumberOfBoxes(EulerModel%ObjMonBox, NumberOfBoxes3D = EulerModel%Monitor%NumberOfBoxes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructMonitoring - ModuleLagrangianGlobal - ERR01'

                NumberOfOrigins = Me%nOrigins

                NumberOfBoxes   = EulerModel%Monitor%NumberOfBoxes

                allocate (EulerModel%Monitor%SurfaceBoxVolume           (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%InstBoxVolume              (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%InstVolumeByOrigin         (NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%IntgBoxVolume              (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%IntgVolumeByOrigin         (NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%InstBoxMass                (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%InstMassByOrigin           (NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%NumberOfCellsPerBox        (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%NumberOfCellsFromOrigin    (NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%ObjTimeSerie               (NumberOfBoxes                  ))            

                allocate (EulerModel%Monitor%InstBoxLogMass             (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%InstBoxConc                (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%NumberOfTracers            (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%InstLogMassByOrigin        (NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%NumberOfTracersFromOrigin  (NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%InstBoxMassFractionByOrigin(NumberOfBoxes, NumberOfOrigins ))
                allocate (EulerModel%Monitor%NbrBoxContaminatedTracers  (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%VolBoxContaminatedTracers  (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%AverageBoxContaminatedConc (NumberOfBoxes                  ))
                allocate (EulerModel%Monitor%ContaminationProbability   (NumberOfBoxes                  ))
                EulerModel%Monitor%IntgBoxVolume      = 0.
                EulerModel%Monitor%IntgVolumeByOrigin = 0.
                EulerModel%Monitor%ObjTimeSerie       = 0
            
            !Shorten
            ILB    = Me%EulerModel(em)%WorkSize%ILB
            IUB    = Me%EulerModel(em)%WorkSize%IUB
            JLB    = Me%EulerModel(em)%WorkSize%JLB
            JUB    = Me%EulerModel(em)%WorkSize%JUB
            KLB    = Me%EulerModel(em)%WorkSize%KLB
            KUB    = Me%EulerModel(em)%WorkSize%KUB

            !Get the boxes
            call GetBoxes(Me%EulerModel(em)%ObjMonBox, Me%EulerModel(em)%Monitor%Boxes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'MonitorParticle - ModuleLagrangianGlobal - ERR01'

            !Calculates the volume of each monitoring boxes
            Me%EulerModel(em)%Monitor%InstBoxVolume = 0.
 
             Me%EulerModel(em)%Monitor%InstVolumeByOrigin = 0.

 
                If (Me%State%MonitorPropMass) then
                allocate (PropertyList (2 + 4*(NumberOfOrigins + 1)))
                    
                    Me%EulerModel(em)%Monitor%InstBoxMass                 (:)   = 0.
                    Me%EulerModel(em)%Monitor%InstMassByOrigin                  = 0.

                Else
                    allocate (PropertyList (2*(NumberOfOrigins + 1)))
                End If

                do nB = 1, NumberOfBoxes

                    PropertyList (1) = "Inst. Volume"
                    do iO = 1, NumberOfOrigins
                        write(AuxChar, fmt=*)iO
                        PropertyList (iO+1) = "Inst. VolFrOrigin_"//trim(adjustl(AuxChar))
                    enddo

                    PropertyList ((NumberOfOrigins + 1) + 1) = "Intg. Volume"
                    do iO = 1, NumberOfOrigins
                        write(AuxChar, fmt=*)iO
                        PropertyList ((NumberOfOrigins + 1) + 1 + iO) = "Intg. VolFrOrigin_"//trim(adjustl(AuxChar))
                    enddo

                    If (Me%State%MonitorPropMass) then

                        PropertyList (2 * (NumberOfOrigins + 1) + 1) = "Inst. Mass"
                        do iO = 1, NumberOfOrigins
                            write(AuxChar, fmt=*)iO
                            PropertyList (2 * (NumberOfOrigins + 1) + 1 + iO) = "Inst. MassFrOrigin_"//trim(adjustl(AuxChar))
                        enddo

                    if (Me%MonitorMassFractionType .EQ. Arithmetic) then
                        PropertyList (3 * (NumberOfOrigins + 1) + 1) = "Inst. Arit. Conc."
                        PropertyList (3 * (NumberOfOrigins + 1) + 2) = "Cont. Arit. Conc."
                    else
                        PropertyList (3 * (NumberOfOrigins + 1) + 1) = "Inst. Geom. Conc."
                        PropertyList (3 * (NumberOfOrigins + 1) + 2) = "Cont. Geom. Conc."
                    end if
                        PropertyList (3 * (NumberOfOrigins + 1) + 3) = "Contam. Prob."

                    do iO = 1, NumberOfOrigins
                        write(AuxChar, fmt=*)iO
                        PropertyList (3 * (NumberOfOrigins + 1) + 3 + iO) = "Inst. RelMassFrOrigin_"//trim(adjustl(AuxChar))
                    enddo

                    End If

                    write(AuxChar, fmt=*)nB
                    call StartTimeSerie (EulerModel%Monitor%ObjTimeSerie(nB),                   &
                                         EulerModel%ObjTime,                                    &
                                         Me%Files%ConstructData,                                &
                                         PropertyList,                                          &
                                         Extension   = "LMB",                                   &
                                         ResultFileName = "MonitorBox_"//trim(adjustl(AuxChar)) &
                                                            //"_"//trim(EulerModel%Name),       &
                                         STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructMonitoring - ModuleLagrangianGlobal - ERR02'
                    
                                       

                enddo
                deallocate (PropertyList)

            else

                nullify  (EulerModel%Monitor%SurfaceBoxVolume           )
                nullify  (EulerModel%Monitor%InstBoxVolume              )
                nullify  (EulerModel%Monitor%InstVolumeByOrigin         )
                nullify  (EulerModel%Monitor%IntgBoxVolume              )
                nullify  (EulerModel%Monitor%IntgVolumeByOrigin         )
                nullify  (EulerModel%Monitor%InstBoxMass                )
                nullify  (EulerModel%Monitor%InstMassByOrigin           )
                nullify  (EulerModel%Monitor%NumberOfCellsPerBox        )   
                nullify  (EulerModel%Monitor%NumberOfCellsFromOrigin    )
                nullify  (EulerModel%Monitor%ObjTimeSerie               )
                nullify  (EulerModel%Monitor%InstLogMassByOrigin        )
                nullify  (EulerModel%Monitor%NumberOfTracersFromOrigin  )
                nullify  (EulerModel%Monitor%InstBoxMassFractionByOrigin)
                nullify  (EulerModel%Monitor%InstBoxLogMass             )         
                nullify  (EulerModel%Monitor%InstBoxConc                )
                nullify  (EulerModel%Monitor%NumberOfTracers            )
                nullify  (EulerModel%Monitor%InstBoxMassFractionByOrigin)
                nullify  (EulerModel%Monitor%InstLogMassByOrigin        )
                nullify  (EulerModel%Monitor%NumberOfTracersFromOrigin  )
                nullify  (EulerModel%Monitor%ContaminationProbability   )    
                nullify  (EulerModel%Monitor%AverageBoxContaminatedConc )
                nullify  (EulerModel%Monitor%NbrBoxContaminatedTracers  )
                nullify  (EulerModel%Monitor%VolBoxContaminatedTracers  )

            endif

            if (Me%State%EulerianMonitor) then

                ILB     = EulerModel%Size%ILB   
                IUB     = EulerModel%Size%IUB   
                JLB     = EulerModel%Size%JLB   
                JUB     = EulerModel%Size%JUB   
                KLB     = EulerModel%Size%KLB   
                KUB     = EulerModel%Size%KUB   

                !This test is done for simply reason
                if (Me%nGroups > 1) then
                    write(*,*)'Cannot write Eulerian Box Time Series for simulation with more then one Group'
                    stop 'ConstructMonitoring - ModuleLagrangianGlobal - ERR40'
                endif

                !Counts Number of properties
                iProp = 0
                CurrentProperty => Me%OriginDefault%FirstProperty
                do while (associated(CurrentProperty))
                    iProp = iProp + 1    
                    CurrentProperty => CurrentProperty%Next
                enddo

                allocate (PropertyList(1:iProp))

                !Counts Number of properties
                iProp = 0
                CurrentProperty => Me%OriginDefault%FirstProperty
                do while (associated(CurrentProperty))
                    iProp               = iProp + 1
                    PropertyList(iProp) = "Lagrangian_"//trim(CurrentProperty%Name)
                    CurrentProperty => CurrentProperty%Next
                enddo

                allocate(EulerModel%EulerianMonitor%Mass(ILB:IUB, JLB:JUB, KLB:KUB))

                call SetMatrixValue(EulerModel%EulerianMonitor%Mass, EulerModel%Size, &
                                    dble(0.), EulerModel%Waterpoints3D)
            
                !Starts BoxDif
                call StartBoxDif(BoxDifID         = EulerModel%ObjEulMonBox,            &
                                 TimeID           = EulerModel%ObjTime,                 &
                                 HorizontalGridID = EulerModel%ObjHorizontalGrid,       &
                                 BoxesFilePath    = Me%Files%EulerianMonitorBox,        &
                                 ScalarOutputList = PropertyList,                       &
                                 WaterPoints3D    = EulerModel%Waterpoints3D,           &
                                 Size3D           = EulerModel%Size,                    &
                                 WorkSize3D       = EulerModel%WorkSize,                &
                                 STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructMonitoring - ModuleLagrangianGlobal - ERR050'
            
                deallocate (PropertyList)

            end if

        enddo d1

        nullify(EulerModel)


    end subroutine ConstructMonitoring

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ConstructMonitoringLag 

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        integer                                         :: nP, iO
        integer                                         :: NumberOfOrigins
        integer                                         :: NumberOfPoly        
        integer                                         :: STAT_CALL
        character(StringLength), dimension(:), pointer  :: PropertyList
        character(StringLength)                         :: AuxChar
        
        !Begin-----------------------------------------------------------------

        NumberOfOrigins = Me%nOrigins
        NumberOfPoly    = Me%MonitorLag%NumberOfPoly
        
        allocate(PropertyList                  (               1:NumberOfOrigins*2))
        allocate(Me%MonitorLag%ObjTimeSerie    (1:NumberOfPoly                    ))
        allocate(Me%MonitorLag%NumTracersOrigin(1:NumberOfPoly,1:NumberOfOrigins  ))

        do nP = 1, NumberOfPoly

            do iO = 1, NumberOfOrigins
                write(AuxChar, fmt=*)iO
                PropertyList (iO) = "NumberOfParcelsOrigin_"//trim(adjustl(AuxChar))
            enddo
            
            do iO = NumberOfOrigins +1, 2*NumberOfOrigins
                write(AuxChar, fmt=*) iO
                PropertyList (iO) = "TotalEmitted_ParcelsOrigin_"//trim(adjustl(AuxChar))
            enddo            
            
            
            write(AuxChar, fmt=*) nP
            
            Me%MonitorLag%ObjTimeSerie(nP) = 0
            
            call StartTimeSerie (TimeSerieID        = Me%MonitorLag%ObjTimeSerie(nP),   &
                                 ObjTime            = Me%ExternalVar%ObjTime,           &
                                 TimeSerieDataFile  = Me%Files%ConstructData,           &
                                 PropertyList       = PropertyList,                     &
                                 Extension          = "LMP",                            &
                                 ResultFileName     = "MonitorPoly_"//                  &
                                 trim(adjustl(AuxChar)),                                &
                                 STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'ConstructMonitoringLag - ModuleLagrangianGlobal - ERR10'
            endif        
        enddo
        
        deallocate (PropertyList)

    end subroutine ConstructMonitoringLag

    !--------------------------------------------------------------------------    

    subroutine ConstructHNSTimeSerie 

        !Arguments-------------------------------------------------------------


        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                        :: CurrentOrigin
        integer                                         :: STAT_CALL
        character(StringLength), dimension(:), pointer  :: PropertyList

        !Begin-----------------------------------------------------------------

        allocate(PropertyList(21))
        PropertyList(1)  = "Area at Surface"
        PropertyList(2)  = "Total Mass"
        PropertyList(3)  = "Mass"
        PropertyList(4)  = "Mass Degraded"
        PropertyList(5)  = "Mass Beached"
        PropertyList(6)  = "Mass Surface"
        PropertyList(7)  = "Mass Evaporated"
        PropertyList(8)  = "Mass Volatilized"
        PropertyList(9)  = "Mass Entrained"
        PropertyList(10)  = "Mass Dissolved"
        PropertyList(11) = "Mass Sedimented"
        PropertyList(12) = "Mass Deposited"
        PropertyList(13) = "Fraction Degraded"
        PropertyList(14) = "Fraction Beached"
        PropertyList(15) = "Fraction Surface"
        PropertyList(16) = "Fraction Evaporated"
        PropertyList(17) = "Fraction Volatilized"
        PropertyList(18) = "Fraction Entrained"
        PropertyList(19) = "Fraction Dissolved"
        PropertyList(20) = "Fraction Sedimented"
        PropertyList(21) = "Fraction Deposited"

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
               
            call StartTimeSerie (CurrentOrigin%ObjTimeSerie,                            &
                                 Me%ExternalVar%ObjTime,                                &
                                 Me%Files%ConstructData,                                &
                                 PropertyList,                                          &
                                 Extension   = "hns",                                   &
                                 ResultFileName = "MassBalance_"//trim(CurrentOrigin%Name), &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMonitoring - ModuleLagrangianGlobal - ERR02'

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        nullify(PropertyList)
        
    end subroutine ConstructHNSTimeSerie

    !--------------------------------------------------------------------------

    subroutine ConstructTimeSeries

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        character(len = StringLength), dimension(:), pointer    :: PropertyList
        integer, pointer, dimension(:, :, :)                    :: WaterPoints3D
        type (T_Property), pointer                              :: CurrentProperty
        integer                                                 :: iProp
        real                                                    :: CoordX, CoordY
        integer                                                 :: STAT_CALL
        integer                                                 :: iflag, em, dn, Id, Jd, TimeSerieNumber
        character(len=PathLength)                               :: TimeSerieLocationFile
        character(len=PathLength)                               :: NomfichFile, RootPath
        logical                                                 :: CoordON, IgnoreOK
        type (T_Polygon), pointer                               :: ModelDomainLimit
        
        !Begin-----------------------------------------------------------------

        !This test is done for simply reason
        if (Me%nGroups > 1) then
            write(*,*)'Cannot write Time Series for simulation with more then one Group'
            stop 'ConstructTimeSeries - ModuleLagrangianGlobal - ERR10'
        endif

        !Counts Number of properties
        iProp = 0
        CurrentProperty => Me%OriginDefault%FirstProperty
        do while (associated(CurrentProperty))
            if (CurrentProperty%WritesTimeSerie) then
                iProp = iProp + 1
                if (CurrentProperty%T90ON) iProp = iProp + 1
            endif
            CurrentProperty => CurrentProperty%Next
        enddo


        !Allocates Property List
        if (iProp > 0) then
            allocate(PropertyList(iProp+3))
        else
            Me%WritesTimeSerie = .false.
            write(*,*)'No Properties defined'
            write(*,*)'Particle Time Series Disabled'
            return
        endif
        
            
        !Fills Property List
        iProp = 0
        CurrentProperty => Me%OriginDefault%FirstProperty
        do while (associated(CurrentProperty))
            if (CurrentProperty%WritesTimeSerie) then
                iProp = iProp + 1    
                PropertyList(iProp) = trim(adjustl(CurrentProperty%Name))
                if (CurrentProperty%T90ON) then
                    iProp = iProp + 1
                    PropertyList(iProp) = trim(adjustl(CurrentProperty%T90Name))
                endif
            endif
            CurrentProperty => CurrentProperty%Next
        enddo
        
        PropertyList(iProp+1) = trim(GetPropertyName (VelocityU_      ))
        PropertyList(iProp+2) = trim(GetPropertyName (VelocityV_      ))        
        PropertyList(iProp+3) = trim(GetPropertyName (VelocityW_      ))  
        
d1:     do em = 1, Me%EulerModelNumber

            !Gets the position of the water points in the Map Module
            call GetWaterPoints3D(Me%EulerModel(em)%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR20'
            
            call GetGridOutBorderPolygon(HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                         Polygon          = ModelDomainLimit,           &
                                         STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR25'
            endif                
        
            call GetData(TimeSerieLocationFile,                                         &
                         Me%ObjEnterData ,iflag,                                        &
                         SearchType   = FromFile,                                       &
                         keyword      = 'TIME_SERIE_LOCATION',                          &
                         ClientModule = 'ModuleLagrangianGlobal',                       &
                         Default      = Me%Files%ConstructData,                         &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                &
                stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR30' 
            
            NomfichFile =  trim(Me%EulerModel(em)%Path)//'/nomfich.dat'
                
            call ReadFileName(keyword       = "ROOT_SRT",                               &
                              FILE_NAME     = RootPath,                                 &
                              FilesInput    = NomfichFile,                              &
                              STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR35' 
            endif                

            !Constructs TimeSerie
            call StartTimeSerie(Me%EulerModel(em)%ObjTimeSerie, Me%EulerModel(em)%ObjTime,&
                                TimeSerieLocationFile,                                  &
                                PropertyList, "srl",                                    &
                                WaterPoints3D = WaterPoints3D,                          &
                                ModelName     = Me%EulerModel(em)%Name,                 &
                                ModelDomain   = ModelDomainLimit,                       &
                                ReplacePath   = RootPath,                            &  
                                STAT = STAT_CALL)
            if (STAT_CALL /= 0) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR40'

            !Ungets the WaterPoints 
            call UnGetMap (Me%EulerModel(em)%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR50'
            
            call UngetHorizontalGrid(HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                     Polygon          = ModelDomainLimit,               &
                                     STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR55'
            endif                

            !Corrects if necessary the cell of the time serie based in the time serie coordinates
            call GetNumberOfTimeSeries(Me%EulerModel(em)%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR60'

            do dn = 1, TimeSerieNumber
            
                call TryIgnoreTimeSerie(Me%EulerModel(em)%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR90'

                if (IgnoreOK) cycle       

                call GetTimeSerieLocation(Me%EulerModel(em)%ObjTimeSerie, dn,           &  
                                          CoordX   = CoordX,                            &
                                          CoordY   = CoordY,                            & 
                                          CoordON  = CoordON,                           &
                                          STAT     = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR70'

                if (CoordON) then
                    call GetXYCellZ(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, CoordY,&
                                    Id, Jd, STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                        stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR80'
                    endif                            
                    !
                    !if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then
                    !
                    !    call TryIgnoreTimeSerie(Me%EulerModel(em)%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                    !    if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR90'
                    !
                    !    if (IgnoreOK) then
                    !        cycle
                    !    else
                    !        stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR100'
                    !    endif
                    !
                    !endif


                    call CorrectsCellsTimeSerie(Me%EulerModel(em)%ObjTimeSerie, dn, Id, Jd, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleLagrangianGlobal - ERR110'
                endif

            enddo


        enddo d1

        deallocate (PropertyList)


    end subroutine ConstructTimeSeries

    !--------------------------------------------------------------------------
    
    subroutine ConstructOutputTracerTimeSeries
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                                :: CurrentOrigin
        integer                                                 :: STAT_CALL
        real                                                    :: OilDensity, OilAPI, OilMass
        character   (StringLength)                              :: OilType, Name
        real                                                    :: Year, Month, Day, Hour, Minute, Second

        if (Me%nGroups > 1) then
            write(*,*)'Cannot write Time Series for simulation with more then one Group'
            stop 'ConstructOutputTracerTimeSeries - ModuleLagrangianGlobal - ERR999'
        endif

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
                    call UnitsManager(CurrentOrigin%troUnit, OPEN_FILE,             &
                                      STAT = STAT_CALL)
            OPEN (FILE  = trim(CurrentOrigin%OutputTracerInfoFileName), &
                  UNIT  = CurrentOrigin%troUnit, &
                  STATUS= "unknown", &
                  FORM  = "formatted", IOSTAT = STAT_CALL)

                 Name = trim(CurrentOrigin%Name)

                call ExtractDate(Me%ExternalVar%BeginTime, Year, Month, Day, Hour, Minute, Second)            
                10 format(A15, f5.0, 1x, f3.0, 1x, f3.0, 1x, f3.0, 1x, f3.0, 1x, f4.0)

                Write(CurrentOrigin%troUnit,*) "MOHID Individual Particle Output Time Serie"
                Write(CurrentOrigin%troUnit,"(A15, 2X, A30)") "Name         : ", Name
                Write(CurrentOrigin%troUnit,"(A15, F11.6)") "Latitude     : ", CurrentOrigin%Position%CoordY               
                Write(CurrentOrigin%troUnit,"(A15, F11.6)") "Longitude    : ", CurrentOrigin%Position%CoordX               
                Write(CurrentOrigin%troUnit,"(A15, F11.3)") "Volume       : ", CurrentOrigin%PointVolume
                Write(CurrentOrigin%troUnit,10) "Begin Time   : ", Year, Month, Day, Hour, Minute, Second
                if (Me%State%Oil) then
                    call GetOilMainConfigurations(OilID      = CurrentOrigin%ObjOil,        &
                                                  OilVolume  = CurrentOrigin%PointVolume,   &
                                                  OilDensity = OilDensity,                  &
                                                  OilAPI     = OilAPI,                      &
                                                  OilMass    = OilMass,                     &
                                                  OilType    = OilType,                     &
                                                  STAT       = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructOutputTracerTimeSeries - ModuleLagrangianGlobal - ERR977'
                    Write(CurrentOrigin%troUnit,"(A15, F11.3)") "Density      : ", OilDensity
                    Write(CurrentOrigin%troUnit,"(A15, 2X, A30)") "Oil Type     : ", OilType
                    Write(CurrentOrigin%troUnit,"(A15, F11.3)") "API          : ", OilAPI
                    Write(CurrentOrigin%troUnit,"(A15, F11.3)") "Mass         : ", OilMass
                endif
                Write(CurrentOrigin%troUnit,*)
            If (CurrentOrigin%State%Oil) then
            151 format(4X, A6,4X,A12, 4X, A12, 4X, A12, 4X, A3, 4X, A6, 4X, A7, 4X,  &
                       A3, 4X, A3, 4X, A3, 4X, A12, 4X, A12, 4X, A6, 4X, A6, 4X, A3, 4X, A3, 4X, A6, 4X, A12, 4X, A7, 4X, A12)
                Write(CurrentOrigin%troUnit,151) "Number", &
                        "Time",     &
                        "Lat",      &   
                        "Lon",      &
                        "Status",   &
                        "Thick",    &
                        "OilMass",  &   
                        "%ev",      &
                        "%em",      &
                        "%di",      &
                        "visc",     &
                        "dens",     &
                        "Wd",       &
                        "Cur",      &
                        "SST",      &
                        "Err",      &
                        "Depth",    &
                        "Area",     &
                        "Mass",     &
                        "Volume"
            Else
            152 format(4X, A6,4X,A12, 4X, A12, 4X, A12, 4X, A3, 4X, A3, 4X, A3, 4X, A6, 4X, &
                       A6, 4X, A3, 4X, A3, 4X, A6, 4X, A12)
                Write(CurrentOrigin%troUnit,152) "Number", &
                        "Time",     &
                        "Lat",      &   
                        "Lon",      &
                        "I",        &   
                        "J",        &
                        "Status",   &
                        "Wd",       &
                        "Cur",      &
                        "SST",      &
                        "Err",      &
                        "Depth",    & 
                        "Volume"
                
                  if (STAT_CALL /= SUCCESS_) then
                      write(*,*) 'Error opening ouput tracers info file ', &
                                  trim(CurrentOrigin%OutputTracerInfoFileName)
                      stop 'ConstructOutputTracerTimeSeries - ModuleLagrangianGlobal - ERR978'
                  endif
            endif 

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine ConstructOutputTracerTimeSeries

    !--------------------------------------------------------------------------

    subroutine ConstructOutputEnvelopeTimeSeries
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                                :: CurrentOrigin
        integer                                                 :: STAT_CALL
        character   (StringLength)                              :: Name
        real                                                    :: Year, Month, Day, Hour, Minute, Second


        if (Me%nGroups > 1) then
            write(*,*)'Cannot write Time Series for simulation with more then one Group'
            stop 'ConstructOutputEnvelopeTimeSeries - ModuleLagrangianGlobal - ERR0001a'
        endif

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
                call UnitsManager(CurrentOrigin%eroUnit, OPEN_FILE,             &
                                STAT = STAT_CALL)
                OPEN (FILE  = trim(CurrentOrigin%OutputEnvelopeTimeSerieFileName),   &
                    UNIT  = CurrentOrigin%eroUnit,                              &
                    STATUS= "unknown",                                          &
                    FORM  = "formatted", IOSTAT = STAT_CALL)

                Name = trim(CurrentOrigin%Name)

                call ExtractDate(Me%ExternalVar%BeginTime, Year, Month, Day, Hour, Minute, Second)                   
                
10              format(A15, f5.0, 1x, f3.0, 1x, f3.0, 1x, f3.0, 1x, f3.0, 1x, f4.0)
                Write(CurrentOrigin%eroUnit,*) "MOHID Particle Envelope Output Time Serie"
                Write(CurrentOrigin%eroUnit,"(A15, 2X, A30)") "Name         : ", Name
                Write(CurrentOrigin%eroUnit,10) "Begin Time   : ", Year, Month, Day, Hour, Minute, Second
                Write(CurrentOrigin%eroUnit,*)

                
            CurrentOrigin => CurrentOrigin%Next
        enddo CurrOr

    end subroutine
    
    !--------------------------------------------------------------------------

    subroutine VerifyOriginProperties 

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Origin), pointer                    :: FirstInGroup, NextInGroup
        logical                                     :: Equal
        integer, dimension(:), allocatable          :: AuxGroups, AuxGroupsIDs
        integer                                     :: iO, i
        logical                                     :: HaveID
          
        !Checks how many different Groups exists
        Me%nGroups = 0
        allocate (AuxGroups    (Me%nOrigins))
        allocate (AuxGroupsIDs (Me%nOrigins))
        CurrentOrigin => Me%FirstOrigin
        iO            =  1
        if (.not. associated(Me%FirstOrigin)) Me%nGroups = 1
         
        do while (associated(CurrentOrigin))
        
            HaveID = .false.
            do i = 1, iO - 1
                if (AuxGroups(i) == CurrentOrigin%GroupID) then
                    HaveID = .true.
                endif
            enddo

            if (.not. HaveID) then
                Me%nGroups               = Me%nGroups + 1
                AuxGroupsIDs(Me%nGroups) = CurrentOrigin%GroupID
            endif

            AuxGroups(iO) =  CurrentOrigin%GroupID
            CurrentOrigin => CurrentOrigin%Next
            iO            =  iO + 1

        enddo


        !Origins per Group
        allocate   (Me%nOriginsGroup  (Me%nGroups))
        Me%nOriginsGroup = 0



        !Group IDs
        allocate   (Me%GroupIDs       (Me%nGroups))
 
        if (associated(Me%FirstOrigin)) then

            do i = 1, Me%nGroups
                Me%GroupIDs (i) = AuxGroupsIDs(i)
            enddo

        else
            Me%GroupIDs (1) = 1
        endif

        deallocate (AuxGroups   )
        deallocate (AuxGroupsIDs)


        !Checks if origins within the same group have the same properties
        do i = 1, Me%nGroups
        
            nullify (FirstInGroup, NextInGroup)
            CurrentOrigin => Me%FirstOrigin
            do while (associated (CurrentOrigin))

                if (CurrentOrigin%GroupID == Me%GroupIDs(i)) then

                    Me%nOriginsGroup (i) = Me%nOriginsGroup (i) + 1
                
                    if (.not. associated(FirstInGroup)) then
                        FirstInGroup => CurrentOrigin
                    else
                        NextInGroup  => CurrentOrigin
                        call VerifyPropertyList (FirstInGroup, NextInGroup, Equal)
                        if (.not. Equal) then
                            
                            write (*,*)'Origins in the same Group but with different properties'
                            write (*,*)'First   Origin :', trim(adjustl(FirstInGroup%Name))
                            write (*,*)'Current Origin :', trim(adjustl(NextInGroup%Name))
                            write (*,*)'Group ID       :', CurrentOrigin%GroupID
                            stop 'VerifyOriginProperties - ModuleLagrangianGlobal - ERR20'
                        endif
                    endif

                endif

                CurrentOrigin => CurrentOrigin%Next
            enddo

        enddo

    end subroutine VerifyOriginProperties

    !--------------------------------------------------------------------------

    subroutine MergeOldWithNewOrigins

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Origin), pointer                    :: CurrentOldOrigin
        logical                                     :: Equal
        integer                                     :: ObjAux
        

        CurrentOrigin => Me%FirstOrigin
        do while (associated(CurrentOrigin))

            if (CurrentOrigin%Old) then
            
                CurrentOldOrigin => Me%FirstOldOrigin
OldOrigin:      do while (associated(CurrentOldOrigin))

                    if (trim (adjustl(CurrentOldOrigin%Name)) ==                         &
                        trim (adjustl(CurrentOrigin%Name   ))) then

                        !Verifies Property List
                        call VerifyPropertyList (CurrentOldOrigin, CurrentOrigin, Equal)
                        if (.not. Equal) then
                            write (*,*) 'The Properties from the Old and Current Origin are different'
                            write (*,*) 'Old Origin Name: ',trim(CurrentOldOrigin%Name)
                            stop 'MergeOldWithNewOrigins - ModuleLagrangianGlobal - ERR10'
                        endif

                        CurrentOrigin%nParticle    =  CurrentOldOrigin%nParticle
                        CurrentOrigin%FirstPartic  => CurrentOldOrigin%FirstPartic
                        
                        ObjAux                     =  CurrentOrigin%ObjOil
                        CurrentOrigin%ObjOil       =  CurrentOldOrigin%ObjOil
                        CurrentOldOrigin%ObjOil    =  ObjAux                        
                        
                        CurrentOrigin%NextParticID = CurrentOldOrigin%NextParticID

                        nullify (CurrentOldOrigin%FirstPartic)

                        exit OldOrigin
                    endif

                    CurrentOldOrigin => CurrentOldOrigin%Next
                enddo OldOrigin

            endif
            
            CurrentOrigin => CurrentOrigin%Next
        enddo

        call DeallocateOriginList (Me%FirstOldOrigin, Me%nOldOrigins)

    end subroutine MergeOldWithNewOrigins

    !--------------------------------------------------------------------------

    subroutine VerifyPropertyList (OriginOne, OriginTwo, Equal)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: OriginOne
        type (T_Origin), pointer                    :: OriginTwo
        logical                                     :: Equal

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: PropertyOne
        type (T_Property), pointer                  :: PropertyTwo

        !Begin-----------------------------------------------------------------
        
        Equal = .true.

        !Same amount of properties
        if (OriginOne%nProperties /= OriginTwo%nProperties) then
            write(*,*) '1', OriginOne%nProperties, OriginTwo%nProperties
            Equal = .false.
        else
            PropertyOne => OriginOne%FirstProperty
            PropertyTwo => OriginTwo%FirstProperty
            do while (associated(PropertyOne) .and. associated(PropertyTwo))
                
                if (trim(PropertyOne%Name) /= trim(PropertyTwo%Name)) then
                    Equal = .false.
                    write(*,*) '2', trim(PropertyOne%Name), trim(PropertyTwo%Name)
                    exit
                endif

                PropertyOne => PropertyOne%Next
                PropertyTwo => PropertyTwo%Next

            enddo
        endif
        
    end subroutine VerifyPropertyList

    !--------------------------------------------------------------------------
    
    integer function BestDomainForBox(CurrentOrigin) 

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL, em
        logical                                     :: BoxInsideDomain
            
        BestDomainForBox = Me%EulerModelNumber

        do em = 1, Me%EulerModelNumber

            BoxInsideDomain = GetIfBoxInsideDomain(Me%EulerModel(em)%ObjBoxDif, CurrentOrigin%BoxNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'BestDomainForBox - ModuleLagrangianGlobal - ERR10'

            if (BoxInsideDomain) then
                BestDomainForBox = em
                exit
            endif

        enddo    
        
    end function BestDomainForBox         
    
    !--------------------------------------------------------------------------    

    subroutine EmissionBox (CurrentOrigin)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------
        type (T_EulerModel),  pointer               :: EulerModel
        real                                        :: FACTOR
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k
        real                                        :: VOLCEL, AreaCel
        real                                        :: DPPX, DPPY, DPPZ
        integer                                     :: KPP, LP
        type (T_Partic), pointer                    :: NewParticle
        real                                        :: XI, YI, ZI
        real                                        :: auxX, auxY, auxZ, BoxThickness, DepthPartic
        integer, pointer, dimension(:,:,:)          :: Boxes
        integer                                     :: STAT_CALL, BoxCell, emBox
        type (T_Position)                           :: PositionAux
        type (T_PointF),                pointer     :: Point        
        

        !Begin------------------------------------------------------------------

        emBox = BestDomainForBox(CurrentOrigin)

        EulerModel => Me%EulerModel(emBox)

        CurrentOrigin%Position%ModelID = emBox

        
        ILB = EulerModel%WorkSize%ILB
        IUB = EulerModel%WorkSize%IUB

        JLB = EulerModel%WorkSize%JLB
        JUB = EulerModel%WorkSize%JUB

        KLB = EulerModel%WorkSize%KLB
        KUB = EulerModel%WorkSize%KUB

        if (Me%ThinWallsON) then
            allocate(Point)
        endif     


        !Get the boxes
        call GetBoxes(EulerModel%ObjBoxDif, Boxes, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'EmissionBox - ModuleLagrangianGlobal - ERR20'
        
        !Compute box area
        if (CurrentOrigin%Movement%Float .OR. CurrentOrigin%Position%SurfaceEmission) then
        
            CurrentOrigin%AreaTotal = 0.
        
             do j = JLB, JUB
             do i = ILB, IUB
        
                if (EulerModel%OpenPoints3D(i, j, KUB) == OpenPoint) then
                    if (Boxes(i, j, KUB)==CurrentOrigin%BoxNumber) then
                        CurrentOrigin%AreaTotal = CurrentOrigin%AreaTotal + &
                                                  EulerModel%GridCellArea(i, j)
                    endif
                endif
        
             enddo
             enddo
             
             CurrentOrigin%ParticleArea = CurrentOrigin%AreaTotal / real(CurrentOrigin%NbrParticlesIteration)
        
        endif

                       
        !Distribui Floating particle
FLOAT:  if (CurrentOrigin%Movement%Float            .or.    &
            CurrentOrigin%Deposition%BottomEmission .or.    &
            CurrentOrigin%Position%SurfaceEmission) then

            FACTOR = 0.0

            if (CurrentOrigin%Movement%Float .or. CurrentOrigin%Position%SurfaceEmission) then

                if (CurrentOrigin%AreaTotal > 0.) then
                    BoxThickness = CurrentOrigin%PointVolume / CurrentOrigin%AreaTotal
                else
                    BoxThickness = 0.
                endif

            else if (CurrentOrigin%Deposition%BottomEmission) then

                BoxThickness = CurrentOrigin%Deposition%BottomDistance

            endif
            

            do j = JLB, JUB, CurrentOrigin%INCRP 
            do i = ILB, IUB, CurrentOrigin%INCRP 

OP1:            if (EulerModel%OpenPoints3D(i, j, KUB) == OpenPoint) then

                if (CurrentOrigin%Movement%Float .or. CurrentOrigin%Position%SurfaceEmission) then
                
                    BoxCell     = Boxes(i, j, KUB)

                    DepthPartic = EulerModel%SZZ(i, j, KUB)

                else if (CurrentOrigin%Deposition%BottomEmission) then

                    BoxCell     = Boxes(i, j, EulerModel%KFloor(i, j))


                    DepthPartic = EulerModel%SZZ(i, j, EulerModel%KFloor(i, j)-1) +               &
                                               CurrentOrigin%Deposition%BottomDistance / 2.

                endif

BOX2D:          if (BoxCell == CurrentOrigin%BoxNumber) then

                if (CurrentOrigin%ParticleBoxVolume > 0.0) then

                    if (CurrentOrigin%Movement%Float .or. CurrentOrigin%Position%SurfaceEmission) then

                        AreaCel = EulerModel%GridCellArea(i, j) + FACTOR

                        KPP     = INT(AreaCel / CurrentOrigin%ParticleArea)

                        FACTOR  = AreaCel - CurrentOrigin%ParticleArea * KPP

                    
                    else

                        VOLCEL = EulerModel%GridCellArea(i, j) *                         &
                                 BoxThickness + FACTOR

                        KPP    = INT(VOLCEL / CurrentOrigin%ParticleBoxVolume)

                        FACTOR = VOLCEL - CurrentOrigin%ParticleBoxVolume * KPP
                        
                    endif

                else
                                              
                    KPP = 1                         

                end if

                XI  = j - 1.0                                      
                YI  = i - 1.0                                       

                if (KPP >= 1) then
                    DPPX = 1.0 / KPP                                       
                    DPPY = 1.0 / KPP                                       
                
                    do LP = 1, KPP

                        call RANDOM_NUMBER(auxX)
                        call RANDOM_NUMBER(auxY)

                        PositionAux%CellJ = XI + DPPX * KPP * auxX
                        PositionAux%CellI = YI + DPPY * KPP * auxY

                        call Convert_CellIJ_XY(EulerModel, PositionAux)
                        
                        if (Me%ThinWallsON) then
                            Point%X = PositionAux%CoordX
                            Point%Y = PositionAux%CoordY
                            if (IsVisible(Me%ThinWalls, Point)) then
                                cycle    
                            endif
                        endif                        
                        
                        call AllocateNewParticle (NewParticle, CurrentOrigin%nProperties, &
                                                  CurrentOrigin%NextParticID)            
                                                  
                        NewParticle%Position = PositionAux
                                                  
                        !Z position
                        NewParticle%Position%Z = DepthPartic

                        call Convert_Z_CellK  (CurrentOrigin, EulerModel, NewParticle%Position)
                        call Convert_CellK_K  (               NewParticle%Position)

                        NewParticle%Geometry%VolVar = 0.0

                        
                        if (CurrentOrigin%ParticleBoxVolume > 0.0) then
                            NewParticle%Geometry%Volume     = CurrentOrigin%ParticleBoxVolume
                        else
                            NewParticle%Geometry%Volume =                                                   &
                                (EulerModel%Grid%ParticXX(i, j+1) - EulerModel%Grid%ParticXX(i, j)) * &
                                (EulerModel%Grid%ParticYY(i+1, j) - EulerModel%Grid%ParticYY(i, j)) * &
                                 BoxThickness
                        endif

                        !Stores initial Volume
                        NewParticle%Geometry%InitialVolume = NewParticle%Geometry%Volume
                        
                        if (CurrentOrigin%State%Oil)                                    &
                            NewParticle%Geometry%VolumeOil     = NewParticle%Geometry%Volume

                        NewParticle%Position%ModelID = emBox
                       
                        !Inserts Particle to list
                        call InsertParticleToList (CurrentOrigin, NewParticle, .true.)

                    enddo
                endif    

            endif BOX2D

            endif OP1

            enddo
            enddo

        else FLOAT
    
            FACTOR = 0.0
            do k = KLB, KUB
            do j = JLB, JUB, CurrentOrigin%INCRP 
            do i = ILB, IUB, CurrentOrigin%INCRP 

OP:         if ((EulerModel%OpenPoints3D(i, j, k) == OpenPoint) .and. &
                (Boxes(i, j, k) == CurrentOrigin%BoxNumber)) then
 
                if (CurrentOrigin%ParticleBoxVolume > 0.0) then                                 

                    VOLCEL = EulerModel%VolumeZ(I,J,K) + FACTOR    
                                                       
                    KPP    = INT(VOLCEL / CurrentOrigin%ParticleBoxVolume)       
                                                
                    FACTOR = VOLCEL - CurrentOrigin%ParticleBoxVolume * KPP  

                else
                                              
                    KPP = 1                         

                end if
                                                

                ! ---> Considera-se que a particula no ponto X=1,Y=1, Z=1, se encontra
                !      no centro da celula I=1, J=1 , K=1                             
                XI  = j - 1.0                                      
                YI  = i - 1.0                                       
                ZI  = k - 1.0                                       


                ! ---> Distribui aleatoriamente segundo uma distribuicao uniforme   
                !      os tracadores em cada celula X=XI+RANDOM(0:1) (ver NEWPART)  
               if (KPP .GE. 1) then
                    DPPX = 1.0 / KPP                                       
                    DPPY = 1.0 / KPP                                       
                    DPPZ = 1.0  
                
                    do LP = 1, KPP

                        call RANDOM_NUMBER(auxX)
                        call RANDOM_NUMBER(auxY)

                        PositionAux%CellJ = XI + DPPX * KPP * auxX
                        PositionAux%CellI = YI + DPPY * KPP * auxY

                        call Convert_CellIJ_XY(EulerModel, PositionAux)
                        
                        if (Me%ThinWallsON) then
                            Point%X = PositionAux%CoordX
                            Point%Y = PositionAux%CoordY
                            if (IsVisible(Me%ThinWalls, Point)) then
                                cycle    
                            endif
                        endif                        
                        
                        call AllocateNewParticle (NewParticle, CurrentOrigin%nProperties, &
                                                  CurrentOrigin%NextParticID)            
                                                  
                        NewParticle%Position = PositionAux                        

                        !Random Z position
                        call RANDOM_NUMBER(auxZ)
                        NewParticle%Position%CellK = ZI + DPPZ * auxZ 
                        call Convert_CellK_Z  (EulerModel,NewParticle%Position)
                        call Convert_CellK_K  (NewParticle%Position)

                        NewParticle%Geometry%VolVar     = 0.0
                        
                        if (CurrentOrigin%ParticleBoxVolume > 0.0) then
                            NewParticle%Geometry%Volume        = CurrentOrigin%ParticleBoxVolume
                        else
                            NewParticle%Geometry%Volume        =                             &
                                   EulerModel%VolumeZ(NewParticle%Position%I, &
                                                                     NewParticle%Position%J, &
                                                                     NewParticle%Position%K)
                        endif

                        !Stores initial Volume
                        NewParticle%Geometry%InitialVolume = NewParticle%Geometry%Volume

                        if (CurrentOrigin%State%Oil)                                    &
                            NewParticle%Geometry%VolumeOil     = NewParticle%Geometry%Volume

                        NewParticle%Position%ModelID = emBox

                        !Inserts Particle to list
                        call InsertParticleToList (CurrentOrigin, NewParticle, .true.)
                                                              
                    enddo
                endif
            endif OP
            enddo
            enddo
            enddo

        endif FLOAT


        !Unget The Boxes
        call UngetBoxDif(EulerModel%ObjBoxDif, Boxes, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'EmissionBox - ModuleLagrangianGlobal - ERR30'

        nullify(EulerModel)

        if (Me%ThinWallsON) then
            deallocate(Point)
        endif     


    end subroutine EmissionBox

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------    

    subroutine EmissionPoly (CurrentOrigin)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------
        type (T_EulerModel),  pointer               :: EulerModel
        integer                                     :: KLB, KUB
        integer                                     :: i, j
        type (T_Partic), pointer                    :: NewParticle
        real                                        :: auxX, auxY, DepthPartic
        real                                        :: ParticleVolume
        integer                                     :: em, nc
        type (T_Position)                           :: PositionAux
        type (T_PointF),                pointer     :: Point        
        

        !Begin------------------------------------------------------------------

        !Actualizes Variable Flow
        if (CurrentOrigin%EmissionTemporal == Continuous_)  then
            call ActualizeOrigin (CurrentOrigin, ParticleVolume)
        endif
        

        !!Compute box area
        if (CurrentOrigin%Movement%Float .OR. CurrentOrigin%Position%SurfaceEmission) then
        
                
            if (Me%EulerModel(1)%Grid%GeoGrid) then
                CurrentOrigin%AreaTotal =  PolygonSphericalTypeArea(CurrentOrigin%PolyEmission)
            else
                CurrentOrigin%AreaTotal = PolygonTypeArea          (CurrentOrigin%PolyEmission)                
            endif
            
             CurrentOrigin%ParticleArea = CurrentOrigin%AreaTotal / real(CurrentOrigin%NbrParticlesIteration)
        
        endif
        
        em =  CurrentOrigin%Position%ModelID       
        
        EulerModel => Me%EulerModel(em)        

        KLB = EulerModel%WorkSize%KLB
        KUB = EulerModel%WorkSize%KUB        

        allocate(Point)
                       
        !2D emission
FLOAT:  if (CurrentOrigin%Movement%Float            .or.    &
            CurrentOrigin%Deposition%BottomEmission .or.    &
            CurrentOrigin%Position%SurfaceEmission) then

            nc = 0 
            
            do while (CurrentOrigin%NbrParticlesIteration > nc)

                call RANDOM_NUMBER(auxX)
                call RANDOM_NUMBER(auxY)

                PositionAux%CoordX = CurrentOrigin%PolyLeft   * auxX + CurrentOrigin%PolyRight * (1 - auxX)
                PositionAux%CoordY = CurrentOrigin%PolyBottom * auxY + CurrentOrigin%PolyTop   * (1 - auxY)
                
                Point%X = PositionAux%CoordX
                Point%Y = PositionAux%CoordY
                
                if (.not. IsVisible(CurrentOrigin%PolyEmission, Point)) then
                    cycle    
                endif                 
                
                if (Me%ThinWallsON) then
                    if (IsVisible(Me%ThinWalls, Point)) then
                        cycle    
                    endif              
                endif
                
                !Convert Coordinates
                call Convert_XY_CellIJ(Me%EulerModel(em), PositionAux, Referential = GridCoord_)

                i = PositionAux%I
                j = PositionAux%J
                        
                if (EulerModel%OpenPoints3D(i, j, KUB) /= OpenPoint) cycle
                         
                call AllocateNewParticle (NewParticle, CurrentOrigin%nProperties, &
                                            CurrentOrigin%NextParticID)            
                                                  
                NewParticle%Position = PositionAux

                if (CurrentOrigin%Movement%Float .or. CurrentOrigin%Position%SurfaceEmission) then


                    DepthPartic = EulerModel%SZZ(i, j, KUB)

                else if (CurrentOrigin%Deposition%BottomEmission) then

                    DepthPartic = EulerModel%SZZ(i, j, EulerModel%KFloor(i, j)-1) +               &
                                                CurrentOrigin%Deposition%BottomDistance / 2.

                endif
                                                                          
                !Z position
                NewParticle%Position%Z = DepthPartic

                call Convert_Z_CellK  (CurrentOrigin, EulerModel, NewParticle%Position)
                call Convert_CellK_K  (               NewParticle%Position)

                NewParticle%Geometry%VolVar = 0.0

                !Volume
                select case (CurrentOrigin%EmissionTemporal)

                case (Continuous_)

                    if (CurrentOrigin%FlowVariable) then
                        !Volume of the Seed Particle
                        !See subroutine ActualizeOrigin 
                        NewParticle%Geometry%Volume = ParticleVolume
                    else

                        NewParticle%Geometry%Volume = CurrentOrigin%Flow     *              &
                                                      CurrentOrigin%DT_EMIT  /              &
                                                      CurrentOrigin%NbrParticlesIteration

                    endif

                case (Instantaneous_)
 
                    !Volume of the Seed Particle
                    NewParticle%Geometry%Volume = CurrentOrigin%PointVolume /                &
                                                  CurrentOrigin%NbrParticlesIteration

                end select            

                !Stores initial Volume
                NewParticle%Geometry%InitialVolume = NewParticle%Geometry%Volume
                        
                if (CurrentOrigin%State%Oil)                                    &
                    NewParticle%Geometry%VolumeOil     = NewParticle%Geometry%Volume

                NewParticle%Position%ModelID = em
                       
                !Inserts Particle to list
                call InsertParticleToList (CurrentOrigin, NewParticle, .true.)
            
                nc = nc + 1

            enddo

        else FLOAT

            stop 'EmissionPoly - ModuleLagrangianGlobal - ERR10' 

        endif FLOAT

        deallocate(Point)

        nullify(EulerModel)

    end subroutine EmissionPoly

    !--------------------------------------------------------------------------

    subroutine EmissionPoint (CurrentOrigin)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------
        integer                                     :: nP, emp
        type (T_Partic), pointer                    :: NewParticle
        real                                        :: ParticleVolume, random
        integer                                     :: STAT_CALL
        real                                        :: AreaTotal, AreaParticle

        !Begin-----------------------------------------------------------------

        emp = CurrentOrigin%Position%ModelID  

        !Actualizes Variable Flow
        if (CurrentOrigin%EmissionTemporal == Continuous_)  then
            call ActualizeOrigin (CurrentOrigin, ParticleVolume)
        endif

        if (CurrentOrigin%State%HNS) then   

            !Volume
            select case (CurrentOrigin%EmissionTemporal)

            case (Instantaneous_)

                call GetInitialArea(CurrentOrigin%ObjHNS,                                      &
                                        VolInic                = CurrentOrigin%PointVolume,    &
                                        AreaTotal              = AreaTotal,                    &
                                        STAT = STAT_CALL)
            case (Continuous_)

                call GetInitialArea(CurrentOrigin%ObjHNS,                                      &
                                        VolInic                = CurrentOrigin%Flow *          &
                                                                 CurrentOrigin%DT_EMIT,        &
                                        AreaTotal              = AreaTotal,                    &
                                        STAT = STAT_CALL)           
            end select

        endif
                
        do nP = 1, CurrentOrigin%NbrParticlesIteration

            !Allocates a new Particle
            call AllocateNewParticle (NewParticle, CurrentOrigin%nProperties,            &
                                      CurrentOrigin%NextParticID)
                                      
            if (CurrentOrigin%MovingOriginCloudEmission) then
            
                
                if (trim(CurrentOrigin%MovingOriginUnits) == trim(Char_Cells)) then

                    CurrentOrigin%Position%CellI = CurrentOrigin%y(nP)
                    CurrentOrigin%Position%CellJ = CurrentOrigin%x(nP)

                    !Convert Coordinates
                    call Convert_CellIJ_XY(Me%EulerModel(emp), CurrentOrigin%Position)

                else
                
                    CurrentOrigin%Position%CoordX = CurrentOrigin%x(nP)
                    CurrentOrigin%Position%CoordY = CurrentOrigin%y(nP)

                    !Convert Coordinates
                    call Convert_XY_CellIJ(Me%EulerModel(emp),CurrentOrigin%Position, Referential = GridCoord_)

                endif
            endif
            
            !Sets Initial Position
            NewParticle%Position = CurrentOrigin%Position
            
            if (CurrentOrigin%Position%MaintainRelative .and. CurrentOrigin%Position%DepthDefinition == Cells) then

                NewParticle%Position%CellK = NewParticle%Position%Depth

                call Convert_CellK_Z (Me%EulerModel(CurrentOrigin%Position%ModelID), NewParticle%Position)
                call Convert_CellK_K (NewParticle%Position)


            endif
            
            if (CurrentOrigin%SectionEmission) then
                call EmissionAlongSection (CurrentOrigin, NewParticle) 
            endif
            

            NewParticle%Geometry%VolVar     = 0.0

            !Volume
            select case (CurrentOrigin%EmissionTemporal)

            case (Continuous_)

                if (CurrentOrigin%FlowVariable) then
                    !Volume of the Seed Particle
                    !See subroutine ActualizeOrigin 
                    NewParticle%Geometry%Volume = ParticleVolume
                else

                    NewParticle%Geometry%Volume = CurrentOrigin%Flow     *              &
                                                  CurrentOrigin%DT_EMIT  /              &
                                                  CurrentOrigin%NbrParticlesIteration

                endif
                
                if (CurrentOrigin%MovingOriginCloudEmission) then
                    !Volume of the Seed Particle
                    NewParticle%Geometry%Volume = CurrentOrigin%PointVolume                
                endif

            case (Instantaneous_)

                !Volume of the Seed Particle
                NewParticle%Geometry%Volume = CurrentOrigin%PointVolume /                &
                                              CurrentOrigin%NbrParticlesIteration
                                              
                if(CurrentOrigin%State%HumanBody)then

                    if(CurrentOrigin%HumanBody%Drowned)then

                        call random_number(random)

                        if(random < 0.5)then
                            NewParticle%HumanBodySinkingVel = -1. * random 
                        else
                            NewParticle%HumanBodySinkingVel = 0.
                        endif

                    else
                        NewParticle%HumanBodySinkingVel = 0.0
                    end if
                endif

            end select            

            !Stores initial Volume
            NewParticle%Geometry%InitialVolume = NewParticle%Geometry%Volume

            if (CurrentOrigin%State%Oil)                                                 &
               NewParticle%Geometry%VolumeOil     = NewParticle%Geometry%Volume

            if (CurrentOrigin%State%HNS) then   

                !Calcula a area ocupada por cada tracador
                AreaParticle = AreaTotal / float(CurrentOrigin%NbrParticlesIteration)

                NewParticle%Geometry%Area       = AreaParticle

                !next step is needed since ModuleHNS is all controlled by mass variation                             
                call GetHNSInitialMass(CurrentOrigin%ObjHNS,                        &
                                       Volume = NewParticle%Geometry%InitialVolume, & 
                                       InitialMass = NewParticle%HNSInitialMass,    &
                                       STAT = STAT_CALL)
               
                NewParticle%HNSMass = NewParticle%HNSInitialMass
            endif

            !Inserts Particle to list
            call InsertParticleToList (CurrentOrigin, NewParticle, .true.)


            !If simulating a plume give initial velocity and density to the tracer
            if (CurrentOrigin%State%ComputePlume) then
                
                if (Me%Now >= CurrentOrigin%Movement%NextJetActualization) then

                    if (CurrentOrigin%Flow >0) then
                    call ActualizeJetProperties(CurrentOrigin)
                    endif

                    CurrentOrigin%Movement%NextJetActualization = CurrentOrigin%Movement%NextJetActualization + &
                                                                  CurrentOrigin%Movement%JetDT
                endif

                if (CurrentOrigin%Flow >0) then

                call GiveJetPropertiesToParticle (CurrentOrigin, NewParticle)

            endif

            endif

            if (CurrentOrigin%State%FarFieldBuoyancy) then

                NewParticle%W = CurrentOrigin%Movement%InitialVelocityW                

            endif
            
        enddo

!        endif ic


    end subroutine EmissionPoint
    
    !--------------------------------------------------------------------------

    subroutine EmissionAlongSection (CurrentOrigin, NewParticle)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin    
        type (T_Partic), pointer                    :: NewParticle
        
        !Local-----------------------------------------------------------------
        integer                                     :: emp        
        real                                        :: randomXY, randomZ
        real                                        :: X1, X2, X3, Y1, Y2, Y3, dx, dy, m
        real                                        :: dDepth, DepthMax, DepthMin
        integer                                     :: KUB, KFloor, i, j

        !Begin-----------------------------------------------------------------    
    
        emp = CurrentOrigin%Position%ModelID  
    
        X1 = CurrentOrigin%Position%CoordX
        Y1 = CurrentOrigin%Position%CoordY 
        
        X2 = CurrentOrigin%SectionEndX
        Y2 = CurrentOrigin%SectionEndY
        
        dx = X2 - X1
        dy = Y2 - Y1
        
        call RANDOM_NUMBER(randomXY)
        
        if (abs(dx) > 1e-9) then
            m  = dy/dx
            X3 = X1 + dx * randomXY
            Y3 = Y1 + m * (X3 - X1)
        else
            X3 = X1
            Y3 = Y1 + dy * randomXY
        endif
        
        NewParticle%Position%CoordX = X3
        NewParticle%Position%CoordY = Y3

        !Convert Coordinates
        call Convert_XY_CellIJ(Me%EulerModel(emp), NewParticle%Position, Referential = GridCoord_)
        
        i = NewParticle%Position%I
        j = NewParticle%Position%J
        
        if (i < 0 .or. j < 0) then
                
            NewParticle%Position%CoordX = CurrentOrigin%Position%CoordX
            NewParticle%Position%CoordY = CurrentOrigin%Position%CoordY
            
           !Convert Coordinates
            call Convert_XY_CellIJ(Me%EulerModel(emp), NewParticle%Position, Referential = GridCoord_)            
            
            write(*,*)  'EmissionAlongSection - ModuleLagrangianGlobal - WRN10' 
            
        endif
        
        KUB = Me%EulerModel(emp)%WorkSize%KUB

        if (CurrentOrigin%Position%Depth < -90.) then
            DepthMin = Me%EulerModel(emp)%SZZ(i, j, KUB)
        else
            DepthMin = CurrentOrigin%Position%Depth
        endif    
        
        if (CurrentOrigin%SectionDepthMax < -90.) then
            kFloor   = Me%EulerModel(emp)%kFloor(i, j)
            if (kFloor < 1) then
                 write(*,*) 'i, j, kFloor', i, j, KFloor   
                 stop 'EmissionAlongSection - ModuleLagrangianGlobal - ERR10' 
            endif
            DepthMax = Me%EulerModel(emp)%SZZ(i, j, kFloor - 1)
        else
            DepthMax = CurrentOrigin%SectionDepthMax
        endif  
        
        dDepth = DepthMax - DepthMin
        
        call RANDOM_NUMBER(randomZ)
        
        NewParticle%Position%Z =  DepthMin + dDepth * randomZ

        call Convert_Z_CellK (CurrentOrigin, Me%EulerModel(emp), NewParticle%Position)
        call Convert_CellK_K (NewParticle%Position)

    end subroutine EmissionAlongSection
    
    !--------------------------------------------------------------------------

    subroutine ActualizeOrigin (CurrentOrigin, ParticleVolume)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        real,   intent(OUT), optional               :: ParticleVolume

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty
        type (T_Time)                               :: Time1, Time2, StartTime, EndTime
        real                                        :: Value1, Value2, TotalVolume
        logical                                     :: TimeCycle
        integer                                     :: STAT_CALL
        real                                        :: ParticleVolume_

        !Begin-----------------------------------------------------------------

        if (CurrentOrigin%FlowVariable) then
            
            !Gets Flow values that limited the current instant
            call GetTimeSerieValue(CurrentOrigin%TimeSerieInputFlow,                        &
                                   Me%Now,                                                  &
                                   CurrentOrigin%FlowColumn,                                &
                                   Time1, Value1, Time2, Value2, TimeCycle,                 &
                                   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ActualizeOrigin - ModuleLagrangianGlobal - ERR10.'
            
            Value1 = Value1 * CurrentOrigin%FlowScaleFactor
            Value2 = Value2 * CurrentOrigin%FlowScaleFactor

            if (TimeCycle) then
                CurrentOrigin%Flow = Value1
            else
                !Interpolates Value for current instant
                call InterpolateValueInTime(Me%ExternalVar%Now, Time1,               &
                                            Value1, Time2, Value2, CurrentOrigin%Flow)

            endif

                StartTime = Me%Now 
                EndTime   = Me%Now + CurrentOrigin%DT_EMIT
            
                if (EndTime > Me%ExternalVar%EndTime) then
                    CurrentOrigin%NbrParticlesIteration = 0
                else

                    TotalVolume = GetTimeSerieIntegral(CurrentOrigin%TimeSerieInputFlow,        &
                                                       StartTime, EndTime,                      &
                                                       CurrentOrigin%FlowColumn, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ActualizeOrigin - ModuleLagrangianGlobal - ERR20.'
                    
                    TotalVolume = TotalVolume * CurrentOrigin%FlowScaleFactor

                    if (TotalVolume == 0.) then
                        CurrentOrigin%NbrParticlesIteration = 0
                    else
                        CurrentOrigin%NbrParticlesIteration = int (TotalVolume / CurrentOrigin%PointVolume)
                         
                        if (CurrentOrigin%NbrParticlesIteration < 1) CurrentOrigin%NbrParticlesIteration = 1
                        
                    ParticleVolume_                    = TotalVolume / real(CurrentOrigin%NbrParticlesIteration)
                        
                    if (ParticleVolume_ > CurrentOrigin%MaxVol) then
                        write(*,*) 'Particle volume ', ParticleVolume_, 'larger than maximum volume allowed ', &
                                       CurrentOrigin%MaxVol
                            stop 'ActualizeOrigin - ModuleLagrangianGlobal - ERR20.'
                        endif
                        
                    endif
                endif

            if (present(ParticleVolume)) ParticleVolume = ParticleVolume_

        endif

        CurrentProperty => CurrentOrigin%FirstProperty
        do while (associated(CurrentProperty))

            if (CurrentProperty%ConcVariable) then
                
                call ActualizeConcentration (CurrentProperty)
                
            endif

            CurrentProperty => CurrentProperty%Next
        enddo

        nullify(CurrentProperty)


    end subroutine ActualizeOrigin 

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    subroutine ActualizeOriginDefault 

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty


        !Begin-----------------------------------------------------------------
        if (associated(Me%OriginDefault)) then
            CurrentProperty => Me%OriginDefault%FirstProperty
            do while (associated(CurrentProperty))

                if (CurrentProperty%T90Variable .and. CurrentProperty%T90Var_Method == FromTimeSerie) then
                    call ActualizeT90           (CurrentProperty)
                endif

                CurrentProperty => CurrentProperty%Next
            enddo

            nullify(CurrentProperty)
        endif

    end subroutine ActualizeOriginDefault  

    !--------------------------------------------------------------------------
    
    subroutine ActualizeConcentration (CurrentProperty)

        !Arguments-------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty

        !Local-----------------------------------------------------------------
        type (T_Time)                               :: Time1, Time2
        real                                        :: Value1, Value2
        logical                                     :: TimeCycle
        integer                                     :: STAT_CALL

        !Begin-----------------------------------------------------------------

        !Gets Flow values that limited the current instant
        call GetTimeSerieValue(CurrentProperty%TimeSerieInput,                          &
                               Me%Now,                                      &
                               CurrentProperty%ConcColumn,                              &
                               Time1, Value1, Time2, Value2, TimeCycle,                 &
                               STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeOrigin - ModuleLagrangianGlobal - ERR10.'

        if (TimeCycle) then
            CurrentProperty%Concentration = Value1
        else
            !Interpolates Value for current instant
            call InterpolateValueInTime(Me%Now, Time1,                      &
                                        Value1, Time2, Value2,                          &
                                        CurrentProperty%Concentration)
        endif

    end subroutine ActualizeConcentration        

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    
    subroutine ActualizeT90 (CurrentProperty)

        !Arguments-------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty

        !Local-----------------------------------------------------------------
        type (T_Time)                               :: Time1, Time2
        real                                        :: Value1, Value2
        logical                                     :: TimeCycle
        integer                                     :: STAT_CALL

        !Begin-----------------------------------------------------------------

        !Gets Flow values that limited the current instant
        call GetTimeSerieValue(CurrentProperty%TimeSerieT90,                            &
                               Me%Now,                                      &
                               CurrentProperty%T90Column,                               &
                               Time1, Value1, Time2, Value2, TimeCycle,                 &
                               STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeT90 - ModuleLagrangianGlobal - ERR10.'

        if (TimeCycle) then
            CurrentProperty%T90 = Value1
        else
            !Interpolates Value for current instant
            call InterpolateValueInTime(Me%Now, Time1,                      &
                                        Value1, Time2, Value2,                          &
                                        CurrentProperty%T90)
        endif

    end subroutine ActualizeT90        

    !--------------------------------------------------------------------------

    subroutine ActualizeJetProperties(CurrentOrigin)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------
        type (T_Property  ), pointer                :: CurrentProperty
                
        real,   dimension(:,:,:), pointer           :: Temperature3D, Salinity3D
        real                                        :: PlumeDilution, PlumeX, PlumeY, PlumeZ,        &
                                                       PlumeDensity, PlumeTemperature, PlumeSalinity,&
                                                       PlumeU, PlumeV, PlumeW, PlumeMixingHorLength, &
                                                       PlumeThickness 
        real                                        :: Year, Month, Day, Hour, Minutes, Seconds
        integer                                     :: STAT_CALL, I, J, OutPutNumber, em
        logical                                     :: OutPutJet
        real                                        :: SecondsFromStart
        !Begin-----------------------------------------------------------------

        I = CurrentOrigin%Position%I
        J = CurrentOrigin%Position%J

        em = CurrentOrigin%Position%ModelID

        
        !Gets the temperature and the Salinity from the Eulerian model
        call GetConcentration(Me%EulerModel(em)%ObjWaterProperties,                                    &
                              ConcentrationX    = Temperature3D,                        &
                              PropertyXIDNumber = Temperature_,                         &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR01'

        call GetConcentration(Me%EulerModel(em)%ObjWaterProperties,                                    &
                              ConcentrationX    = Salinity3D,                           &
                              PropertyXIDNumber = Salinity_,                            &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR02'

        OutPutNumber = Me%OutPut%NextOutPut

        if (Me%Output%Write_) then 
            if (Me%Now >= Me%OutPut%OutTime(OutPutNumber)) then 
                OutPutJet = .true.
            else
                OutPutJet = .false.
            endif

        else
            OutPutJet = .false.
        endif
        

        CurrentProperty => CurrentOrigin%FirstProperty
        do while (associated(CurrentProperty))

            if (CurrentProperty%ConcVariable) then
                if (CurrentProperty%ID == Salinity_) then
                    CurrentOrigin%Movement%JetSalinity = CurrentProperty%Concentration
                endif
                if (CurrentProperty%ID == Temperature_) then
                    CurrentOrigin%Movement%JetTemperature = CurrentProperty%Concentration
                endif                
            endif

            CurrentProperty => CurrentProperty%Next
        enddo

        nullify(CurrentProperty)
      
            
        call ModifyJet(JetID          = CurrentOrigin%Movement%ObjJet,                  &
                       Salinity       = Salinity3D,                                     &
                       Temperature    = Temperature3D,                                  &
                       VelU           = Me%EulerModel(em)%Velocity_U,                   &
                       VelV           = Me%EulerModel(em)%Velocity_V,                   &
                       VelW           = Me%EulerModel(em)%Velocity_W,                   &
                       SZZ            = Me%EulerModel(em)%SZZ,                          &
                       I              = I,                                              &
                       J              = J,                                              &
                       BottomLayer    = Me%EulerModel(em)%kFloor(I, J),                 &
                       SurfaceLayer   = Me%EulerModel(em)%WorkSize%KUB,                 &
                       OutPutOK       = .true.,                                         &
                       JetFlow        = CurrentOrigin%Flow,                             &
                       JetSalinity    = CurrentOrigin%Movement%JetSalinity,             &
                       JetTemperature = CurrentOrigin%Movement%JetTemperature,          &
                       STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR03'

        !UnGets the temperature and the Salinity from the Eulerian model
        call UnGetWaterProperties(Me%EulerModel(em)%ObjWaterProperties,                                &
                                  Temperature3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR04'

        call UnGetWaterProperties(Me%EulerModel(em)%ObjWaterProperties,                                &
                                  Salinity3D,  STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR05'


        call ExtractDate(Me%Now, Year, Month, Day, Hour, Minutes, Seconds)


        call GetPlumeDilution(CurrentOrigin%Movement%ObjJet, PlumeDilution, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR07'

        call GetPlumeLocation(CurrentOrigin%Movement%ObjJet, PlumeX, PlumeY, PlumeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR08'

        call GetPlumeDensity(CurrentOrigin%Movement%ObjJet, PlumeDensity, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR09'

        call GetPlumeTemperature(CurrentOrigin%Movement%ObjJet, PlumeTemperature, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR10'

        call GetPlumeSalinity(CurrentOrigin%Movement%ObjJet, PlumeSalinity, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR11'

        call GetPlumeVelocity(CurrentOrigin%Movement%ObjJet, PlumeU, PlumeV, PlumeW, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR12'

        call GetPlumeMixingHorLength(CurrentOrigin%Movement%ObjJet, PlumeMixingHorLength, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR13'

        call GetPlumeThickness(CurrentOrigin%Movement%ObjJet, PlumeThickness, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ActualizeJetProperties - ModuleLagrangianGlobal - ERR14'
        
        SecondsFromStart = Me%Now - Me%ExternalVar%BeginTime 
        
        


        write(CurrentOrigin%Movement%JetUnit,'(F16.0, 7F8.0, 2F14.3, F12.3, F16.6, 2F8.4,3F12.5, F10.2, F8.3)') &
                                                SecondsFromStart,                                        &
                                                Year, Month, Day, Hour, Minutes, Seconds, PlumeDilution, &
                                                PlumeX, PlumeY, PlumeZ, PlumeDensity, PlumeTemperature,  &
                                                PlumeSalinity, PlumeU, PlumeV, PlumeW,                   &
                                                PlumeMixingHorLength, PlumeThickness

    end subroutine ActualizeJetProperties
    !--------------------------------------------------------------------------


    subroutine GiveJetPropertiesToParticle(CurrentOrigin, NewParticle)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin    ), pointer                :: CurrentOrigin
        type (T_Partic    ), pointer                :: NewParticle
        type (T_Property  ), pointer                :: CurrentProperty

        !Local-----------------------------------------------------------------
        real                                        :: AmbientConcentration
        integer                                     :: iP, em
        integer                                     :: STAT_CALL
        !Begin-----------------------------------------------------------------

        em = NewParticle%Position%ModelID


        call GetPlumeVelocity(JetID     = CurrentOrigin%Movement%ObjJet,                 &
                              PlumeVelU = CurrentOrigin%Movement%InitialVelocityU,       &
                              PlumeVelV = CurrentOrigin%Movement%InitialVelocityV,       &
                              PlumeVelW = CurrentOrigin%Movement%InitialVelocityW,       &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'GiveJetPropertiesToParticle - ModuleLagrangianGlobal - ERR01'

        NewParticle%U = CurrentOrigin%Movement%InitialVelocityU
        NewParticle%V = CurrentOrigin%Movement%InitialVelocityV
        NewParticle%W = CurrentOrigin%Movement%InitialVelocityW

        call GetPlumeDilution(JetID         = CurrentOrigin%Movement%ObjJet,             &
                              PlumeDilution = CurrentOrigin%Movement%PlumeDilution,      &
                              STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'GiveJetPropertiesToParticle - ModuleLagrangianGlobal - ERR02'

        !Initial volume Dilution 
        NewParticle%Geometry%Volume        = CurrentOrigin%Movement%PlumeDilution * NewParticle%Geometry%Volume  

        NewParticle%Geometry%VolVar = 0.0

        iP = 1

        CurrentProperty => CurrentOrigin%FirstProperty
        do while (associated(CurrentProperty))

            if      (CurrentProperty%ID == Salinity_) then

                call GetPlumeSalinity (JetID         = CurrentOrigin%Movement%ObjJet,    &
                                       PlumeSalinity = NewParticle%Concentration(iP),    &
                                       STAT          = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'GiveJetPropertiesToParticle - ModuleLagrangianGlobal - ERR03'
               


            else if (CurrentProperty%ID == Temperature_) then
                
                call GetPlumeTemperature (JetID            = CurrentOrigin%Movement%ObjJet,&
                                          PlumeTemperature = NewParticle%Concentration(iP),&
                                          STAT             = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'GiveJetPropertiesToParticle - ModuleLagrangianGlobal - ERR04'

            else

                call GetAmbientConcPartic (CurrentProperty, iP, em, NewParticle, AmbientConcentration)
            
                NewParticle%Concentration(iP) =(CurrentProperty%Concentration +                                     &
                                                AmbientConcentration * (CurrentOrigin%Movement%PlumeDilution - 1)) / &
                                                CurrentOrigin%Movement%PlumeDilution

            endif

            NewParticle%Mass         (iP) = NewParticle%Concentration(iP) *              &
                                            NewParticle%Geometry%Volume
  
            iP = iP + 1
            CurrentProperty => CurrentProperty%Next

        enddo

        !Location after initial dilution
        call GetPlumeLocation(JetID  = CurrentOrigin%Movement%ObjJet,                    &
                              PlumeX = NewParticle%Position%CartX,                       &
                              PlumeY = NewParticle%Position%CartY,                       &
                              PlumeZ = NewParticle%Position%Z,                           &
                              STAT   = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'GiveJetPropertiesToParticle - ModuleLagrangianGlobal - ERR05'

        call Convert_Z_CellK   (CurrentOrigin, Me%EulerModel(em), NewParticle%Position)
        call Convert_CellK_K   (NewParticle%Position)

        call Convert_XY_CellIJ (Me%EulerModel(em), NewParticle%Position, Referential = Cartesian_)


        if (Me%EulerModel(em)%OpenPoints3D(NewParticle%Position%i,                      &
                                                   NewParticle%Position%j,              &
                                                   NewParticle%Position%k) /= OpenPoint) then
            
            !Sets Horizontal Position equal to origin
            NewParticle%Position%X = CurrentOrigin%Position%X
            NewParticle%Position%Y = CurrentOrigin%Position%Y
            
            NewParticle%Position%I = CurrentOrigin%Position%I
            NewParticle%Position%J = CurrentOrigin%Position%J

            call Convert_XY_CellIJ (Me%EulerModel(em), NewParticle%Position, Referential = AlongGrid_)

            write(*,*) 'The jet of Origin = ', trim(CurrentOrigin%Name), ' intersected land' 

        endif

    end subroutine GiveJetPropertiesToParticle

    !--------------------------------------------------------------------------

    subroutine EmissionAccident (CurrentOrigin)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------
        type (T_Partic), pointer                    :: NewParticle
        real                                        :: AreaTotal, AreaParticle, AreaSum
        real                                        :: AccRad
        integer                                     :: II, JJ
        real                                        :: aux, ang
        real                                        :: Dist, XDif, YDif
        real                                        :: Density
        integer                                     :: STAT_CALL
        integer                                     :: i, j, k, KUB, em
        logical                                     :: Emited, OutsideWalls
        type (T_Position)                           :: NewPosition
        type (T_PointF),                pointer     :: Point        
        logical                                     :: DensityInAPI
        
        !Begin-----------------------------------------------------------------


        !Cell of the Accident
        JJ = CurrentOrigin%position%J
        II = CurrentOrigin%position%I         

        em = CurrentOrigin%Position%ModelID
        
        allocate(Point)
        
        select case (CurrentOrigin%AccidentMethod)

        case (Fay_)

            !Total Area given by the F_Fay Method
            if ((CurrentOrigin%ObjOil == 0) .AND. (CurrentOrigin%ObjHNS == 0)) then
                write(*,*)'Origin : ', trim(CurrentOrigin%Name)
                write(*,*)'The Fay Method can only be used with Oil Accident'
                write(*,*)'Use ACCIDENT_METHOD : Thickness'
                write(*,*)'or intialize the oil property'
            else
                if (CurrentOrigin%ObjOil /= 0) then
                    DensityInAPI = .true.
                    call GetOilAPI (CurrentOrigin%ObjOil, API = Density, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'EmissionAccident - ModuleLagrangianGlobal - ERR01'

                    AreaTotal = F_FayArea(VolInic          = CurrentOrigin%PointVolume,        & 
                                          Density          = Density,                          & 
                                          WaterDensity     = GetFirstParticDens(CurrentOrigin),& 
                                          WaterTemperature = GetFirstParticTemp(CurrentOrigin),&
                                          DensityInAPI     = DensityInAPI)

                elseif (CurrentOrigin%ObjHNS/= 0) then
                    DensityInAPI = .false.
                    call GetHNSDensity(CurrentOrigin%ObjHNS, Density = Density, STAT = STAT_CALL)
                    
                    call GetInitialArea(CurrentOrigin%ObjHNS,                                   &
                                         VolInic                = CurrentOrigin%PointVolume,    &
                                         AreaTotal              = AreaTotal,                    &
                                         STAT = STAT_CALL)
                endif
            endif

            
            
        case (Thickness_)

            AreaTotal = CurrentOrigin%PointVolume / CurrentOrigin%Movement%ThicknessMeters

        end select


        !Calcula a area ocupada por cada tracador
        AreaParticle = AreaTotal / float(CurrentOrigin%NbrParticlesIteration)

        !Allocates the first Particle
        call AllocateNewParticle (NewParticle, CurrentOrigin%nProperties,                &
                                  CurrentOrigin%NextParticID)

        !Stores first particle / from the center of the cell
        NewParticle%Position                = CurrentOrigin%Position
        NewParticle%Geometry%Volume         = CurrentOrigin%PointVolume /                &
                                              float(CurrentOrigin%NbrParticlesIteration)

        NewParticle%Geometry%VolVar         = 0.0

        !Stores initial Volume
        NewParticle%Geometry%InitialVolume = NewParticle%Geometry%Volume
     
        if (CurrentOrigin%State%Oil)                                    &
            NewParticle%Geometry%VolumeOil     = NewParticle%Geometry%Volume

        if (CurrentOrigin%State%HNS) then   
            NewParticle%Geometry%Area       = AreaParticle
            !next step is needed since ModuleHNS is all controlled by mass variation                             
            call GetHNSInitialMass(CurrentOrigin%ObjHNS,                        &
                                   Volume = NewParticle%Geometry%Volume,        & 
                                   InitialMass = NewParticle%HNSInitialMass,    &
                                   STAT = STAT_CALL)
           
            NewParticle%HNSMass = NewParticle%HNSInitialMass
        endif
        
        !Inserts Particle to list
        call InsertParticleToList (CurrentOrigin, NewParticle, .true.)


        !Radius of the Accident
        AccRad = sqrt(AreaTotal / PI)

        !Area Ocupied until know
        AreaSum = AreaParticle
        do while (abs(AreaTotal - (AreaParticle/2.)) > AreaSum)

            !Allocates new particle
            call AllocateNewParticle (NewParticle, CurrentOrigin%nProperties,            &
                                      CurrentOrigin%NextParticID)
                
            !While it doesnt hit a waterpoint, try emitting
            Emited =.FALSE.
            do while(.NOT. Emited)

                !Aleatory Angle [0, 2PI]
                call RANDOM_NUMBER(aux)
                Ang = aux * PI * 2.0

                !Aleatory Distance [0, AccRad]
                call RANDOM_NUMBER(aux)
                Dist = aux * AccRad

                !Distance from origin in meters
                Xdif = Dist * cos(Ang)
                Ydif = Dist * sin(Ang)

                !New Position
                NewPosition%X = CurrentOrigin%Position%X + Xdif
                NewPosition%Y = CurrentOrigin%Position%Y + Ydif
                NewPosition%Z = CurrentOrigin%Position%Z

                !call LocateEulerModel(NewParticle)

                em = CurrentOrigin%Position%ModelID
                
                NewPosition%I = null_int
                NewPosition%J = null_int

                !Converts Horizontal Position
                call Convert_XY_CellIJ (Me%EulerModel(em), NewPosition, Referential = AlongGrid_)

                i   = NewPosition%I
                j   = NewPosition%J
                KUB = Me%EulerModel(em)%WorkSize%KUB
                
                OutsideWalls = .true.
                if (Me%ThinWallsON) then
                    Point%X = NewPosition%CoordX
                    Point%Y = NewPosition%CoordY
                    if (IsVisible(Me%ThinWalls, Point)) then
                        OutsideWalls = .false. 
                    endif
                endif
                
                !Stores the Particle
                if (Me%EulerModel(em)%OpenPoints3D(i, j, KUB) == OpenPoint .and. OutsideWalls) then


                    NewPosition%ModelID = Locate_ModelDomain(NewPosition%CoordX, NewPosition%CoordY) 


                    !If the vertical position of the Particle isnt a waterpoint, put it 
                    !close to the suface
                    call Convert_Z_CellK (CurrentOrigin, Me%EulerModel(em), NewPosition)
                    call Convert_CellK_K (               NewPosition)


                    k = NewPosition%K
                    if (Me%EulerModel(em)%OpenPoints3D(i, j, k) == OpenPoint) then
                        NewParticle%Position = NewPosition
                    else
                        NewPosition%Z = Me%EulerModel(em)%SZZ(i, j, KUB)
                        call Convert_Z_CellK (CurrentOrigin, Me%EulerModel(em), NewPosition)
                        call Convert_CellK_K (               NewPosition)
                        NewParticle%Position = NewPosition
                    endif

                    NewParticle%Geometry%Volume = CurrentOrigin%PointVolume /            &
                                                  float(CurrentOrigin%NbrParticlesIteration)

                    NewParticle%Geometry%VolVar = 0.0

                    !Stores initial Volume
                    NewParticle%Geometry%InitialVolume = NewParticle%Geometry%Volume

                    if (CurrentOrigin%State%Oil)                                    &
                        NewParticle%Geometry%VolumeOil     = NewParticle%Geometry%Volume

                    if (CurrentOrigin%State%HNS) then
                        NewParticle%Geometry%Area       = AreaParticle
                                    
                        call GetHNSInitialMass(CurrentOrigin%ObjHNS,                        &
                                               Volume = NewParticle%Geometry%Volume,        & 
                                               InitialMass = NewParticle%HNSInitialMass,    &
                                               STAT = STAT_CALL)
                        NewParticle%HNSMass = NewParticle%HNSInitialMass
                    endif

                    !Inserts Particle to List
                    call InsertParticleToList (CurrentOrigin, NewParticle, .true.)

                    AreaSum = AreaSum + AreaParticle
                    Emited  =.true.

                else

                    Emited = .false.

                endif

            enddo

        enddo


        CurrentOrigin%AccidentFinished = .true.

        deallocate(Point)

    end subroutine EmissionAccident

    !--------------------------------------------------------------------------

    subroutine ConstructEmissionTime (CurrentOrigin)
        
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Local-----------------------------------------------------------------

        !Next Emission time
        if (CurrentOrigin%Old) then
            CurrentOrigin%NextEmission = Me%Now +                 &
                                         CurrentOrigin%DT_Emit
        else
            CurrentOrigin%NextEmission = Me%Now
        endif

        if (CurrentOrigin%NextEmission < CurrentOrigin%StartEmission) then
            CurrentOrigin%NextEmission = CurrentOrigin%StartEmission
        endif

    end subroutine ConstructEmissionTime
    
    !--------------------------------------------------------------------------

    subroutine ConstructParticOil (NewOrigin, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Origin),     pointer                :: NewOrigin
        integer                                     :: ClientNumber

        !Local-----------------------------------------------------------------
        logical                                     :: OilSectionFound
        integer                                     :: STAT_CALL, em


        !Extracts the Oil Section from the Origin
        call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                       &
                                   oil_begin, oil_end,                                  &
                                   OilSectionFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticOil - ModuleLagrangianGlobal - ERR10'


!i1:     if (OilSectionFound .and. .not. NewOrigin%Old) then
i1:     if (OilSectionFound) then

            em = NewOrigin%Position%ModelID
            

            !Starts Oil
            call StartOil(OilID             = NewOrigin%ObjOil,                     &     
                          TimeID            = Me%EulerModel(em)%ObjTime,            &     
                          EnterDataID       = Me%ObjEnterData,                      &
                          DT                = Me%DT_PARTIC,                         &     
                          ContCalc          = .false.,                              &
                          ExtractType       = FromBlockInBlock,                     &
                          STAT              = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructParticOil - ModuleLagrangianGlobal - ERR10'

        elseif (.not. OilSectionFound) then i1

            write (*,*)'Oil Section not defined for Origin : ', trim(NewOrigin%Name)
            stop       'ConstructParticOil - ModuleLagrangianGlobal - ERR40'

        endif i1
  
    end subroutine ConstructParticOil

    !--------------------------------------------------------------------------

    subroutine ConstructParticHNS (NewOrigin, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Origin),     pointer                :: NewOrigin
        integer                                     :: ClientNumber

        !Local-----------------------------------------------------------------
        logical                                     :: HNSSectionFound
        integer                                     :: STAT_CALL, em


        !Extracts the Oil Section from the Origin
        call ExtractBlockFromBlock(Me%ObjEnterData, ClientNumber,                       &
                                   hns_begin, hns_end,                                  &
                                   HNSSectionFound, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructParticHNS - ModuleLagrangianGlobal - ERR10'


i1:     if (HNSSectionFound .and. .not. NewOrigin%Old) then

            em = NewOrigin%Position%ModelID
            

            !Starts HNS
            call StartHNS(HNSID             = NewOrigin%ObjHNS,                     &     
                          TimeID            = Me%EulerModel(em)%ObjTime,            &     
                          EnterDataID       = Me%ObjEnterData,                      &
                          DT                = Me%DT_PARTIC,                         &     
                          ContCalc          = NewOrigin%Old,                        &
                          ExtractType       = FromBlockInBlock,                     &
                          STAT              = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructParticHNS - ModuleLagrangianGlobal - ERR10'

        elseif (.not. HNSSectionFound) then i1

            write (*,*)'HNS Section not defined for Origin : ', trim(NewOrigin%Name)
            stop       'ConstructParticHNS - ModuleLagrangianGlobal - ERR40'

        endif i1
  
    end subroutine ConstructParticHNS

    !--------------------------------------------------------------------------



    !--------------------------------------------------------------------------

    subroutine VerifyBeachingProbabilities

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real,    pointer, dimension(:)              :: BoxesBeachingProbability
        integer, pointer, dimension(:,:,:)          :: BeachingProbBoxes
        integer                                     :: flag
        integer                                     :: NumberOfBoxes
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, Box, em
        integer                                     :: STAT_CALL

        !-----------------------------------------------------------------------
        
        if (Me%State%HaveBeachingProbBox) then        
            !Get the boxes only
            em = 1
            call GetNumberOfBoxes(Me%EulerModel(em)%ObjBeachingProbBox, NumberOfBoxes3D = NumberOfBoxes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'VerifyBeachingProbabilities - ModuleLagrangianGlobal - ERR03'

            allocate (BoxesBeachingProbability(NumberOfBoxes))

            call GetData(BoxesBeachingProbability,                                  &
                         Me%ObjEnterData,                                           &
                         flag,                                                      &
                         SearchType = FromFile,                                     &
                         keyword    = 'BOXES_BEACHING_PROB',                        &
                         ClientModule = 'ModuleLagrangianGlobal',                         &
                         STAT       = STAT_CALL)
            if       (STAT_CALL .EQ. SIZE_ERR_)  then
                write(*,*) 
                write(*,*) 'Error calling GetData.  '
                write(*,*) 'Number of box values is incorrect:'
                write(*,*) '    NumberOfBoxes =', NumberOfBoxes
                write(*,*) '    BoxesData   =', flag
                stop       'Subroutine VerifyBeachingProbabilities - ModuleLagrangianGlobal. ERR04.'

            else if ((STAT_CALL .NE. SIZE_ERR_) .AND.                               &
                     (STAT_CALL .NE. SUCCESS_)) then                                                                        
                stop 'Subroutine VerifyBeachingProbabilities - ModuleLagrangianGlobal. ERR05.'
            end if               

            if (flag==0) then
                write(*,*) 
                write(*,*) 'Error do not have the box beaching probability.'           
                stop       'Subroutine VerifyBeachingProbabilities - ModuleLagrangianGlobal. ERR06.'
            end if

        endif

d1:     do em = 1, Me%EulerModelNumber
        
            allocate (Me%EulerModel(em)%BeachingProbability(Me%EulerModel(em)%Size%ILB: &
                                                            Me%EulerModel(em)%Size%IUB, &
                                                            Me%EulerModel(em)%Size%JLB: &
                                                            Me%EulerModel(em)%Size%JUB, &
                                                            Me%EulerModel(em)%Size%KLB: &
                                                            Me%EulerModel(em)%Size%KUB),&
                                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'VerifyBeachingProbabilities - ModuleLagrangianGlobal - ERR01'
        
            if ( .NOT. Me%State%HaveBeachingProbBox) then

                Me%EulerModel(em)%BeachingProbability = Me%DefaultBeachingProbability

            else if (Me%State%HaveBeachingProbBox) then

                !Shorten
                ILB    = Me%EulerModel(em)%WorkSize%ILB
                IUB    = Me%EulerModel(em)%WorkSize%IUB
                JLB    = Me%EulerModel(em)%WorkSize%JLB
                JUB    = Me%EulerModel(em)%WorkSize%JUB
                KLB    = Me%EulerModel(em)%WorkSize%KLB
                KUB    = Me%EulerModel(em)%WorkSize%KUB
        

                call GetBoxes(Me%EulerModel(em)%ObjBeachingProbBox, BeachingProbBoxes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'VerifyBeachingProbabilities - ModuleLagrangianGlobal - ERR02'

                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB
                    Box = BeachingProbBoxes(i, j, k)
            
                    if (Box .GE. 0 ) then
            
                        Me%EulerModel(em)%BeachingProbability (i,j,k) = BoxesBeachingProbability(Box)
                     
                    else if (Box .LT. 0 ) then
            
                        Me%EulerModel(em)%BeachingProbability (i,j,k) = Me%DefaultBeachingProbability
            
                    endif
                enddo
                enddo
                enddo

                deallocate (BoxesBeachingProbability)

                !Unget The Boxes
                call UngetBoxDif(Me%EulerModel(em)%ObjBeachingProbBox, BeachingProbBoxes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'VerifyBeachingProbabilities - ModuleLagrangianGlobal - ERR07'

            end if

        enddo d1

    end subroutine VerifyBeachingProbabilities

     !--------------------------------------------------------------------------

    subroutine VerifyShoreTypes

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real,    pointer, dimension(:)              :: BoxesShoreType
        real,    pointer, dimension(:)              :: BeachingLimitList
        real,    pointer, dimension(:)              :: RemovalRateCoefList       
        integer, pointer, dimension(:,:)            :: ShoreTypeBoxes
        integer                                     :: flag
        integer                                     :: NumberOfBoxes
        integer                                     :: ILB, IUB, JLB, JUB
        integer                                     :: i, j, Box, em
        integer                                     :: STAT_CALL

        !-----------------------------------------------------------------------
        
        if (Me%State%HaveShoreTypeBox) then        
            !Get the boxes only
            em = 1
            call GetNumberOfBoxes(Me%EulerModel(em)%ObjShoreTypeBox, NumberOfBoxes2D = NumberOfBoxes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR03'

            allocate (BoxesShoreType(NumberOfBoxes))

            call GetData(BoxesShoreType,                                            &
                         Me%ObjEnterData,                                           &
                         flag,                                                      &
                         SearchType = FromFile,                                     &
                         keyword    = 'BOXES_SHORE_TYPE',                           &
                         ClientModule = 'ModuleLagrangianGlobal',                   &
                         STAT       = STAT_CALL)
            if       (STAT_CALL .EQ. SIZE_ERR_)  then
                write(*,*) 
                write(*,*) 'Error calling GetData.  '
                write(*,*) 'Number of box values is incorrect:'
                write(*,*) '    NumberOfBoxes =', NumberOfBoxes
                write(*,*) '    BoxesData   =', flag
                stop       'Subroutine VerifyShoreTypes - ModuleLagrangianGlobal. ERR04.'

            else if ((STAT_CALL .NE. SIZE_ERR_) .AND.                               &
                     (STAT_CALL .NE. SUCCESS_)) then                                                                        
                stop 'Subroutine VerifyShoreTypes - ModuleLagrangianGlobal. ERR05.'
            end if               

            if (flag==0) then
                write(*,*) 
                write(*,*) 'Error do not have the box beaching probability.'           
                stop       'Subroutine VerifyShoreTypes - ModuleLagrangianGlobal. ERR06.'
            end if

        endif

        if (Me%BeachingLimitSpatial .EQ. ShoreTypeBased_) then

            allocate (BeachingLimitList(ShoreTypesNbr))

            call GetData(BeachingLimitList,                                         &
                         Me%ObjEnterData,                                           &
                         flag,                                                      &
                         SearchType = FromFile,                                     &
                         keyword    = 'BEACHING_LIMIT_LIST',                        &
                         ClientModule = 'ModuleLagrangianGlobal',                   &
                         STAT       = STAT_CALL)
            if       (STAT_CALL .EQ. SIZE_ERR_)  then
                write(*,*) 
                write(*,*) 'Error calling GetData.  '
                write(*,*) 'Number of values defined is incorrect:'
                write(*,*) '    Number of Shore Types =', ShoreTypesNbr
                write(*,*) '    Number of Values defined   =', flag
                stop       'Subroutine BoxTypeVariablesDefiniton - ModuleLagrangianGlobal. ERR04.'

            else if ((STAT_CALL .NE. SIZE_ERR_) .AND.                               &
                     (STAT_CALL .NE. SUCCESS_)) then                                                                        
                stop 'Subroutine BoxTypeVariablesDefiniton - ModuleLagrangianGlobal. ERR05.'
            end if               

            if (flag==0) then
                write(*,*) 
                write(*,*) 'Error do not have the beaching limit list.'           
                stop       'Subroutine BoxTypeVariablesDefiniton - ModuleLagrangianGlobal. ERR06.'
            end if

        endif

        if (Me%RemovalRateCoefSpatial .EQ. ShoreTypeBased_) then

            allocate (RemovalRateCoefList(ShoreTypesNbr))

            call GetData(RemovalRateCoefList,                                       &
                         Me%ObjEnterData,                                           &
                         flag,                                                      &
                         SearchType = FromFile,                                     &
                         keyword    = 'REMOVAL_RATE_COEF_LIST',                     &
                         ClientModule = 'ModuleLagrangianGlobal',                   &
                         STAT       = STAT_CALL)
            if       (STAT_CALL .EQ. SIZE_ERR_)  then
                write(*,*) 
                write(*,*) 'Error calling GetData.  '
                write(*,*) 'Number of values defined is incorrect:'
                write(*,*) '    Number of Shore Types =', ShoreTypesNbr
                write(*,*) '    Number of Values defined   =', flag
                stop       'Subroutine BoxTypeVariablesDefiniton - ModuleLagrangianGlobal. ERR07.'

            else if ((STAT_CALL .NE. SIZE_ERR_) .AND.                               &
                     (STAT_CALL .NE. SUCCESS_)) then                                                                        
                stop 'Subroutine BoxTypeVariablesDefiniton - ModuleLagrangianGlobal. ERR08.'
            end if               

            if (flag==0) then
                write(*,*) 
                write(*,*) 'Error do not have the removal rate coef list.'           
                stop       'Subroutine BoxTypeVariablesDefiniton - ModuleLagrangianGlobal. ERR09.'
            end if

        endif



d1:     do em = 1, Me%EulerModelNumber
        
            allocate (Me%EulerModel(em)%ShoreType(Me%EulerModel(em)%Size%ILB: &
                                                  Me%EulerModel(em)%Size%IUB, &
                                                  Me%EulerModel(em)%Size%JLB: &
                                                  Me%EulerModel(em)%Size%JUB),&
                                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR01'
        
            allocate (Me%EulerModel(em)%BeachingLimit(Me%EulerModel(em)%Size%ILB: &
                                                      Me%EulerModel(em)%Size%IUB, &
                                                      Me%EulerModel(em)%Size%JLB: &
                                                      Me%EulerModel(em)%Size%JUB),&
                                                      STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR11'

            allocate (Me%EulerModel(em)%RemovalRateCoef(Me%EulerModel(em)%Size%ILB: &
                                                       Me%EulerModel(em)%Size%IUB, &
                                                       Me%EulerModel(em)%Size%JLB: &
                                                       Me%EulerModel(em)%Size%JUB),&
                                                       STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR12'
            
            if ( .NOT. Me%State%HaveShoreTypeBox) then
                Me%EulerModel(em)%ShoreType       = Me%DefaultShoreType

                if (Me%BeachingLimitSpatial .EQ. ShoreTypeBased_) then
                    Me%EulerModel(em)%BeachingLimit = BeachingLimitList(Me%DefaultShoreType)
                elseif (Me%BeachingLimitSpatial .EQ. Constant_) then
                    Me%EulerModel(em)%BeachingLimit   = Me%DefaultBeachingLimit
                end if
                
                if (Me%RemovalRateCoefSpatial .EQ. ShoreTypeBased_) then
                    Me%EulerModel(em)%RemovalRateCoef = RemovalRateCoefList(Me%DefaultShoreType) 
                elseif (Me%BeachingLimitSpatial .EQ. Constant_) then
                    Me%EulerModel(em)%RemovalRateCoef = Me%DefaultRemovalRateCoef
                end if
                            
            else if (Me%State%HaveShoreTypeBox) then

                !Shorten
                ILB    = Me%EulerModel(em)%WorkSize%ILB
                IUB    = Me%EulerModel(em)%WorkSize%IUB
                JLB    = Me%EulerModel(em)%WorkSize%JLB
                JUB    = Me%EulerModel(em)%WorkSize%JUB
        

                call GetBoxes(Me%EulerModel(em)%ObjShoreTypeBox, ShoreTypeBoxes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR02'

                do j = JLB, JUB
                do i = ILB, IUB
                    Box = ShoreTypeBoxes(i, j)
            
                    if (Box .GE. 0 ) then

                        if (BoxesShoreType(Box) > ShoreTypesNbr) then
                            write(*,*) "A shore type value in box ", Box, &
                                       " is greater than the number of shore types defined in model."
                            write(*,*) "Number of shore types defined in the model: ", ShoreTypesNbr                               
                            stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR07'
                        end if
            
                        Me%EulerModel(em)%ShoreType (i,j) = BoxesShoreType(Box)
                     
                    else if (Box .LT. 0 ) then
            
                        Me%EulerModel(em)%ShoreType (i,j) = Me%DefaultShoreType
            
                    endif
                enddo
                enddo
                
                if (Me%BeachingLimitSpatial .EQ. Constant_) then
                    Me%EulerModel(em)%BeachingLimit = Me%DefaultBeachingLimit
                elseif (Me%BeachingLimitSpatial .EQ. ShoreTypeBased_) then

                    do j = JLB, JUB
                    do i = ILB, IUB
                        Box = ShoreTypeBoxes(i, j)
                
                        if (Box .GE. 0 ) then
                                                   
                            !assigns value based on shore type value
                            Me%EulerModel(em)%BeachingLimit (i,j) = BeachingLimitList(Me%EulerModel(em)%ShoreType (i,j))
                         
                        else if (Box .LT. 0 ) then
                
                            Me%EulerModel(em)%BeachingLimit (i,j) = Me%DefaultBeachingLimit
                
                        endif
                    enddo
                    enddo

                    deallocate (BeachingLimitList)
                end if                          

                if (Me%RemovalRateCoefSpatial .EQ. Constant_) then
                    Me%EulerModel(em)%RemovalRateCoef = Me%DefaultRemovalRateCoef
                elseif (Me%RemovalRateCoefSpatial .EQ. ShoreTypeBased_) then

                    do j = JLB, JUB
                    do i = ILB, IUB
                        Box = ShoreTypeBoxes(i, j)
                
                        if (Box .GE. 0 ) then
                                                   
                            !assigns value based on shore type value
                            Me%EulerModel(em)%RemovalRateCoef (i,j) = RemovalRateCoefList(Me%EulerModel(em)%ShoreType (i,j))
                                                                      
                         
                        else if (Box .LT. 0 ) then
                
                            Me%EulerModel(em)%RemovalRateCoef (i,j) = Me%DefaultRemovalRateCoef
                
                        endif
                    enddo
                    enddo

                    deallocate (RemovalRateCoefList)
                end if                          
                
                deallocate (BoxesShoreType)
                
                !Unget The Boxes
                call UngetBoxDif(Me%EulerModel(em)%ObjShoreTypeBox, ShoreTypeBoxes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'VerifyShoreTypes - ModuleLagrangianGlobal - ERR08'

            end if

        enddo d1

    end subroutine VerifyShoreTypes

   !--------------------------------------------------------------------------

    subroutine ConstructHDF5Output

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel
        real, pointer, dimension(:, :)              :: Bathymetry
        integer, pointer, dimension(:, :, :)        :: WaterPoints3D
        integer                                     :: STAT_CALL
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: HDF5_CREATE, em, ic, emMax
        character(len = PathLength)                 :: FileName

 
        !Begin-----------------------------------------------------------------

        allocate(Me%ObjHDF5(Me%EulerModelNumber))
        allocate(Me%HDF5FileName(Me%EulerModelNumber))

        Me%ObjHDF5(:) = 0

em1:    do em =1, Me%EulerModelNumber

            EulerModel => Me%EulerModel(em)

            !Bounds
            ILB = EulerModel%WorkSize%ILB
            IUB = EulerModel%WorkSize%IUB

            JLB = EulerModel%WorkSize%JLB
            JUB = EulerModel%WorkSize%JUB

            KLB = EulerModel%WorkSize%KLB
            KUB = EulerModel%WorkSize%KUB

            !Gets File Access Code
            call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

            ic = len(trim(Me%Files%TransientHDF))
            
            FileName(:) = ' '
            
            if (Me%EulerModelNumber == 1) then
                FileName = trim(Me%Files%TransientHDF(1:ic-4))//".hdf5"
            else
                FileName = trim(Me%Files%TransientHDF(1:ic-4))//"_"//trim(Me%EulerModel(em)%Name)//".hdf5"
            endif
            
            Me%HDF5FileName(em) = FileName

            !Opens HDF File
            call ConstructHDF5      (Me%ObjHDF5(em), trim(FileName), HDF5_CREATE, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR05'


            !Write the Horizontal Grid
            call WriteHorizontalGrid(EulerModel%ObjHorizontalGrid, Me%ObjHDF5(em),  &
                                     STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR06'

            !Gets a pointer to Bathymetry
            call GetGridData        (EulerModel%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR01'
            

            !Gets WaterPoints3D
            call GetWaterPoints3D   (EulerModel%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR03'


            !Sets limits for next write operations
            call HDF5SetLimits   (Me%ObjHDF5(em), ILB, IUB, JLB, JUB,               &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR17'


            !Writes the Grid
            call HDF5WriteData   (Me%ObjHDF5(em), "/Grid", "Bathymetry", "m",       &
                                  Array2D = Bathymetry,                             &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR18'

            if (Me%State%DistanceToCoast) then

                !Writes distance of each cell to the coast 
                call HDF5WriteData   (Me%ObjHDF5(em), "/Grid", "Distance to the coast", "m", &
                                      Array2D = Me%EulerModel(em)%DistanceToCoast,     &
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR18'

            endif

            !Sets limits for next write operations
            call HDF5SetLimits   (Me%ObjHDF5(em), ILB, IUB, JLB, JUB, KLB, KUB,     &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR17'


            call HDF5WriteData   (Me%ObjHDF5(em), "/Grid", "WaterPoints3D", "-",    &
                                  Array3D = WaterPoints3D,                          &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR19'
            


            if (associated(Me%GridsBounds)) then
                call WriteHDF5Polygons(ObjHDF5          = Me%ObjHDF5(em),                   &
                                       Polygons         = Me%GridsBounds,                   & 
                                       DataFieldName    = 'GridBoundary')
            
                call WriteItem(Polygon  = Me%GridsBounds,                               &
                               FilePath = trim(Me%OutPut%RootPath)//'GridsBounds.xy')
            endif
                                                    
                                   
            if (associated(Me%CoastLine)) then
                call WriteHDF5Polygons(ObjHDF5          = Me%ObjHDF5(em),                   &
                                       Polygons         = Me%CoastLine,                     & 
                                       DataFieldName    = 'CoastLine')                
                call WriteItem(Polygon  = Me%CoastLine,                                 &
                               FilePath = trim(Me%OutPut%RootPath)//'CoastLine.xy')
            endif                


            if (associated(Me%ThinWalls)) then
                
                call WriteHDF5Polygons(ObjHDF5          = Me%ObjHDF5(em),                   &
                                       Polygons         = Me%ThinWalls,                     & 
                                       DataFieldName    = 'ThinWalls')                
                
                call WriteItem(Polygon  = Me%ThinWalls,                                 &
                               FilePath = trim(Me%OutPut%RootPath)//'ThinWalls.xy')
            endif
            
            !Flushes All pending HDF5 commands
            call HDF5FlushMemory (Me%ObjHDF5(em), ErrorMessage =                    &
                                'ConstructHDF5Output - ModuleLagrangianGlobal - ERR23', STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR23'

            !Ungets the Bathymetry
            call UngetGridData (EulerModel%ObjGridData, Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR24'

            !Ungets the Waterpoints3D
            call UnGetMap        (EulerModel%ObjMap, WaterPoints3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR25'



!            endif

        enddo em1

        nullify(EulerModel)

#ifdef _LITTER_
        if (Me%LitterON) then
                
            emMax = Me%EulerModelNumber
                
            call ConstructLitter(ObjLitterID    = Me%ObjLitter,                         &
                                 TimeID         = Me%ExternalVar%ObjTime,               &
                                 Nomfich        = Me%Files%Nomfich,                     &
                                 ModelDomain    = Me%GridsBounds,                       &
                                 ResultsHDF     = Me%HDF5FileName(emMax),               &
                                 STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR80'
        endif  
#else
        if (Me%LitterON) then
            write(*,*) 'executable not compile with the Module ModuleLitter'
            write(*,*) 'this executable do not run the option LITTER_ON : 1'
            stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR90'
        endif                    
#endif              
                    

#ifdef _OUTPUT_GRID_
        call ConstructOutputGrid(ObjOutputGridID    = Me%ObjOutputGrid,                 &
                                 TimeID             = Me%ExternalVar%ObjTime,           &
                                 ConstructData      = Me%Files%ConstructData,           &
                                 block_begin        = '<BeginOutputGrid>',              &
                                 block_end          = '<EndOutputGrid>',                &
                                 FromWathBlock      = FromBlock,                        &
                                 OutputGridON       = Me%OutputGridON,                  &
                                 STAT               = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructHDF5Output - ModuleLagrangianGlobal - ERR100'
#endif      
                    

    end subroutine ConstructHDF5Output
  
    !--------------------------------------------------------------------------

    subroutine WriteHDF5Polygons(ObjHDF5, Polygons, DataFieldName)

        !Arguments-------------------------------------------------------------
        integer                                     :: ObjHDF5
        type (T_Polygon), pointer                   :: Polygons
        character (len=*)                           :: DataFieldName
        
        !Local-----------------------------------------------------------------
        type (T_Polygon), pointer                   :: AuxPolygon
        integer                                     :: count, i, STAT_CALL
        character(len = StringLength)               :: AuxFieldName, PolygonName, GroupName
        character(len=6)                            :: NumberName        
        real(8), dimension(:), pointer              :: Matrix1DX, Matrix1DY
#ifdef _GOOGLEMAPS          
        real(8), dimension(:), pointer              :: Aux1DX, Aux1DY                
#endif       
        !Begin-----------------------------------------------------------------

        ! Write each polygon
        AuxPolygon => Polygons
        i = 1         
        do while (associated(AuxPolygon))

            Count = AuxPolygon%Count
            
            !Do not write polygons with less three vertices 
            if (count < 3) then
                AuxPolygon => AuxPolygon%Next
                cycle 
            endif                
            
            NumberName = "      "
            
            write(NumberName,'(I6)') i
            PolygonName = 'Polygon'//trim(adjustl(NumberName))
            
            !Sets limits for next write operations
            call HDF5SetLimits   (ObjHDF5, 1, count, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteHDF5Polygons - ModuleLagrangianGlobal - ERR10'

            allocate(Matrix1DX(1:Count))
            allocate(Matrix1DY(1:Count))            
            
            Matrix1DX(1:Count) = AuxPolygon%VerticesF(1:Count)%X
            
            GroupName = "/Grid/Polygons/"//trim(DataFieldName)//'/'//trim(PolygonName)

            AuxFieldName = 'Longitude'

            !Writes the Grid
            call HDF5WriteData   (HDF5ID        = ObjHDF5,                              &
                                  GroupName     = trim(GroupName),                      &
                                  Name          = trim(AuxFieldName),                   &
                                  Units         = "-",                                  &
                                  Array1D       = Matrix1DX,                            &
                                  STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteHDF5Polygons - ModuleLagrangianGlobal - ERR20'

            Matrix1DY(1:Count) = AuxPolygon%VerticesF(1:Count)%Y
        
            AuxFieldName = 'Latitude'

            !Writes the Grid
            call HDF5WriteData   (HDF5ID        = ObjHDF5,                              &
                                  GroupName     = trim(GroupName),                      &
                                  Name          = trim(AuxFieldName),                   &
                                  Units         = "-",                                  &
                                  Array1D       = Matrix1DY,                            &
                                  STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteHDF5Polygons - ModuleLagrangianGlobal - ERR30'
            
            
#ifdef _GOOGLEMAPS  

            allocate(Aux1DX(1:Count))
            allocate(Aux1DY(1:Count))            
    
            call WGS84toGoogleMaps (Matrix1DX, Matrix1DY, Count, Aux1DX, Aux1DY)
            
            AuxFieldName = 'googlemaps_x'

            !Writes the Grid
            call HDF5WriteData   (HDF5ID        = ObjHDF5,                              &
                                  GroupName     = trim(GroupName),                      &
                                  Name          = trim(AuxFieldName),                   &
                                  Units         = "-",                                  &
                                  Array1D       = Aux1DX,                               &
                                  STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteHDF5Polygons - ModuleLagrangianGlobal - ERR40'

            AuxFieldName = 'googlemaps_y'

            !Writes the Grid
            call HDF5WriteData   (HDF5ID        = ObjHDF5,                              &
                                  GroupName     = trim(GroupName),                      &
                                  Name          = trim(AuxFieldName),                   &
                                  Units         = "-",                                  &
                                  Array1D       = Aux1DY,                               &
                                  STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteHDF5Polygons - ModuleLagrangianGlobal - ERR50'
                            

            deallocate(Aux1DX)
            deallocate(Aux1DY)                            

#endif             

            deallocate(Matrix1DX)
            deallocate(Matrix1DY)               
        
            i = i + 1
            
            AuxPolygon => AuxPolygon%Next
            
        enddo

        nullify(AuxPolygon)


    end subroutine WriteHDF5Polygons
  
    !--------------------------------------------------------

    subroutine ConstructParticStatistic

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        character (StringLength)                        :: GroupName, AuxChar, AuxChar2
        integer                                         :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                         :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                         :: WS_KLB, WS_KUB
        integer                                         :: nProp, em, nP, ig, STAT_CALL
        !Begin------------------------------------------------------------------
                
d1:     do em = 1, Me%EulerModelNumber 

            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB
            KLB    = Me%EulerModel(em)%Size%KLB
            KUB    = Me%EulerModel(em)%Size%KUB
            WS_ILB = Me%EulerModel(em)%WorkSize%ILB
            WS_IUB = Me%EulerModel(em)%WorkSize%IUB
            WS_JLB = Me%EulerModel(em)%WorkSize%JLB
            WS_JUB = Me%EulerModel(em)%WorkSize%JUB
            WS_KLB = Me%EulerModel(em)%WorkSize%KLB
            WS_KUB = Me%EulerModel(em)%WorkSize%KUB

            nProp           =  Me%Statistic%PropNumber

        !Fills Grid concentration
        !if (Me%Now > Me%ExternalVar%LastConcCompute)  call FillGridConcentration  

            allocate(Me%EulerModel(em)%PropStatistic(1:nProp))

            do nP = 1, nProp

            allocate(Me%EulerModel(em)%PropStatistic(nP)%Statistic1_ID(1:Me%NGroups))

            Me%EulerModel(em)%PropStatistic(nP)%Statistic1_ID(1:Me%NGroups) = 0

            if (Me%OutPut%ConcMaxTracer) then

                allocate(Me%EulerModel(em)%PropStatistic(nP)%Statistic2_ID(1:Me%NGroups))

                Me%EulerModel(em)%PropStatistic(nP)%Statistic2_ID(1:Me%NGroups) = 0

            endif

            if (Me%OutPut%MassTracer) then

                allocate(Me%EulerModel(em)%PropStatistic(nP)%Statistic3_ID(1:Me%NGroups))

                Me%EulerModel(em)%PropStatistic(nP)%Statistic3_ID(1:Me%NGroups) = 0

                if (Me%OutPut%ConcMaxTracer) then

                    allocate(Me%EulerModel(em)%PropStatistic(nP)%Statistic4_ID(1:Me%NGroups))

                    Me%EulerModel(em)%PropStatistic(nP)%Statistic4_ID(1:Me%NGroups) = 0

                endif

            endif
            
         
            
            do ig = 1, Me%NGroups
            
                !Writes the Group to an auxiliar string
                write (AuxChar, fmt='(i3)') ig

                if (Me%NGroups == 1) then

                    AuxChar2 = trim(Me%EulerModel(em)%Name)

                else

                    AuxChar2 = trim(Me%EulerModel(em)%Name)//"/Group_"//trim(adjustl(AuxChar))

                endif               
                
                GroupName = trim(AuxChar2)//"_"
            
                call ConstructStatistic (Me%EulerModel(em)%PropStatistic(nP)%Statistic1_ID(ig),     &
                                         ObjTime          = Me%EulerModel(em)%ObjTime,              &
                                         ObjHDF5          = Me%ObjHDF5(em),                         &
                                         Size             = Me%EulerModel(em)%Size,                 &
                                         WorkSize         = Me%EulerModel(em)%WorkSize,             &
                                         DataFile         = Me%Statistic%OptionsStat(nP)%File,      &
                                         Name             = Me%Statistic%OptionsStat(nP)%ID%Name, &
                                         GroupName        = trim(GroupName),                        &
                                         STAT             = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'ConstructParticStatistic - ModuleLagrangianGlobal - ERR10'

                if (OilThickness_ == Me%Statistic%OptionsStat(nP)%ID%IDNumber) cycle

                if (Me%OutPut%ConcMaxTracer) then

                    GroupName = trim(AuxChar2)//"_"//"MaxTracer_"

                    call ConstructStatistic (Me%EulerModel(em)%PropStatistic(nP)%Statistic2_ID(ig), &
                                             ObjTime      = Me%EulerModel(em)%ObjTime,              &
                                             ObjHDF5      = Me%ObjHDF5(em),                         &
                                             Size         = Me%EulerModel(em)%Size,                 &
                                             WorkSize     = Me%EulerModel(em)%WorkSize,             &
                                             DataFile     = Me%Statistic%OptionsStat(nP)%File,      &
                                             Name         = Me%Statistic%OptionsStat(nP)%ID%Name,   &
                                             GroupName    = GroupName,                              &
                                             STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ConstructParticStatistic - ModuleLagrangianGlobal - ERR20'

                endif

                if (Me%OutPut%MassTracer) then

                    GroupName = trim(AuxChar2)//"_"//"MassTracer_"

                    call ConstructStatistic (Me%EulerModel(em)%PropStatistic(nP)%Statistic3_ID(ig), &
                                             ObjTime      = Me%EulerModel(em)%ObjTime,              &
                                             ObjHDF5      = Me%ObjHDF5(em),                         &
                                             Size         = Me%EulerModel(em)%Size,                 &
                                             WorkSize     = Me%EulerModel(em)%WorkSize,             &
                                             DataFile     = Me%Statistic%OptionsStat(nP)%File,      &
                                             Name         = Me%Statistic%OptionsStat(nP)%ID%Name,   &
                                             GroupName    = GroupName,                              &
                                             STAT         = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ConstructParticStatistic - ModuleLagrangianGlobal - ERR30'


                    if (Me%OutPut%ConcMaxTracer) then

                        GroupName = trim(AuxChar2)//"_"//"MaxMassTracer_"

                        call ConstructStatistic (Me%EulerModel(em)%PropStatistic(nP)%Statistic4_ID(ig), &
                                                 ObjTime      = Me%EulerModel(em)%ObjTime,              &
                                                 ObjHDF5      = Me%ObjHDF5(em),                         &
                                                 Size         = Me%EulerModel(em)%Size,                 &
                                                 WorkSize     = Me%EulerModel(em)%WorkSize,             &
                                                 DataFile     = Me%Statistic%OptionsStat(nP)%File,      &
                                                 Name         = Me%Statistic%OptionsStat(nP)%ID%Name,   &
                                                 GroupName    = GroupName,                              &
                                                 STAT         = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                          &
                            stop 'ConstructParticStatistic - ModuleLagrangianGlobal - ERR40'

                    endif


                endif

            enddo
            enddo

            do nP = 1, nProp
            do ig = 1, Me%NGroups

                if (Me%Statistic%OptionsStat(nP)%Lag) then
                    
                    call GetStatisticClassesNumber(Me%EulerModel(em)%PropStatistic(nP)%Statistic1_ID(ig),&
                                                   Me%Statistic%OptionsStat(nP)%nClassesLag, STAT= STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ConstructParticStatistic - ModuleLagrangianGlobal - ERR50'

                    allocate(Me%EulerModel(em)%PropStatistic(nP)%FrequencyLag           &
                                   (ILB:IUB,JLB:JUB,KLB:KUB,                            &
                                    1:Me%Statistic%OptionsStat(nP)%nClassesLag,         &
                                    1:Me%NGroups))

                    Me%EulerModel(em)%PropStatistic(nP)%FrequencyLag(:,:,:,:,:) = 0.
                
                endif
            enddo
            enddo
        enddo d1


    end subroutine ConstructParticStatistic

    !--------------------------------------------------------------------------

    subroutine ConstructParticLightExtinction
        
        !Local-----------------------------------------------------------------
        integer                                     :: ig, STAT_CALL  
        integer                                     :: LightExtinctionID, em
          
        !Begin-----------------------------------------------------------------

d1:     do em = 1, Me%EulerModelNumber

            allocate (Me%EulerModel(em)%Light(Me%nGroups))

            do ig = 1, Me%nGroups

                Me%EulerModel(em)%Light(ig)%ObjLightExtinction = 0

                allocate(Me%EulerModel(em)%Light(ig)%TopRadiationCells(Me%EulerModel(em)%Size%ILB: &
                                                                       Me%EulerModel(em)%Size%IUB, &
                                                                       Me%EulerModel(em)%Size%JLB: &
                                                                       Me%EulerModel(em)%Size%JUB, &
                                                                       Me%EulerModel(em)%Size%KLB: &
                                                                       Me%EulerModel(em)%Size%KUB))

            enddo

            call GetWaterPropertiesSubModulesID(WaterPropertiesID      = Me%EulerModel(em)%ObjWaterProperties, &
                                                LightExtinctionID      = LightExtinctionID,                    &
                                                STAT                   = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructParticLightExtinction - Lagrangian - ERR00'


            if(LightExtinctionID == 0)then

                Me%EulerModel(em)%Light(:)%Compute = ON
          
                do ig = 1, Me%nGroups

                    call ConstructLightExtinction (Me%EulerModel(em)%Light(ig)%ObjLightExtinction, &
                                                   Me%EulerModel(em)%ObjTime, Me%ObjEnterData,         &
                                                   Me%EulerModel(em)%Size, Me%EulerModel(em)%WorkSize, &
                                                   STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ConstructParticLightExtinction - Lagrangian - ERR01'
                enddo

            else

                Me%EulerModel(em)%Light(:)%Compute = OFF

                do ig = 1, Me%nGroups
                    Me%EulerModel(em)%Light(ig)%ObjLightExtinction = AssociateInstance(mLIGHTEXTINCTION_,LightExtinctionID)
                enddo

            end if

        enddo d1




    end subroutine ConstructParticLightExtinction

    !--------------------------------------------------------------------------

    subroutine ConstructLog

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ig


        write(*, *)"----------------------- LAGRANGIAN -----------------------"
        write(*, *)
        write(*, *)"Number of Origins : ", Me%nOrigins
        write(*, *)"Number of Groups  : ", Me%nGroups
        write(*, *)

        do ig = 1, Me%nGroups
            write(*, *)"GroupID           : ", Me%GroupIDs(ig)
            write(*, *)"---Number of Orig.: ", Me%nOriginsGroup(ig)
            write(*, *)
        enddo

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            write(*, *)"Origin            : ", trim(CurrentOrigin%Name)
            write(*, *)"---Group ID       : ", CurrentOrigin%GroupID
            write(*, *)"---Number of Part.: ", CurrentOrigin%nParticle
            write(*, *)"---Number of Prop.: ", CurrentOrigin%nProperties
            write(*, *)

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine ConstructLog

    !--------------------------------------------------------------------------

    subroutine AllocateNewOrigin (NewOrigin)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: NewOrigin

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL

        nullify  (NewOrigin)
        allocate (NewOrigin, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'AllocateNewOrigin - ModuleLagrangianGlobal - ERR01'
        nullify  (NewOrigin%Next)
        nullify  (NewOrigin%FirstPartic)
        nullify  (NewOrigin%FirstProperty)

        NewOrigin%nProperties  = 0
        NewOrigin%nPropT90     = 0
        NewOrigin%nParticle    = 0
        NewOrigin%nParticleEmit = 0
        NewOrigin%NextParticID = 1

    end subroutine AllocateNewOrigin

    !--------------------------------------------------------------------------

    subroutine InsertOriginToList(FirstOrigin, NewOrigin, nOrigins)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: FirstOrigin
        type (T_Origin), pointer                    :: NewOrigin
        integer                                     :: nOrigins

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin  => null()
        type (T_Origin), pointer                    :: PreviousOrigin => null()


        !Inserts a new origin to the list if origins
        if (.not. associated(FirstOrigin)) then
            FirstOrigin => NewOrigin
        else
            PreviousOrigin => FirstOrigin
            CurrentOrigin  => PreviousOrigin%Next
            do while (associated(CurrentOrigin))
                PreviousOrigin => CurrentOrigin
                CurrentOrigin  => PreviousOrigin%Next
            enddo
            PreviousOrigin%Next => NewOrigin
        endif

        !Increments origin number by one
        nOrigins           = nOrigins + 1 
        NewOrigin%ID       = nOrigins

    end subroutine InsertOriginToList

    !--------------------------------------------------------------------------

    subroutine DeleteOrigin (FirstOrigin, OriginToDelete, nOrigins)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: FirstOrigin
        type (T_Origin), pointer                    :: OriginToDelete
        integer                                     :: nOrigins

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin    => null()
        type (T_Origin), pointer                    :: NextOrigin       => null()
        type (T_Origin), pointer                    :: PreviousOrigin   => null()
        type (T_Partic), pointer                    :: CurrentParticle  => null()
        type (T_Property), pointer                  :: CurrentProperty  => null()
        integer                                     :: STAT_CALL

        nullify (PreviousOrigin)
        CurrentOrigin => FirstOrigin

        do 
            if (CurrentOrigin%ID == OriginToDelete%ID) then

                NextOrigin => CurrentOrigin%Next
 
                !Updates first origin
                if (OriginToDelete%ID == FirstOrigin%ID) then
                    FirstOrigin => NextOrigin
                endif
                
                if (OriginToDelete%MovingOriginCloudEmission) then
                    deallocate(CurrentOrigin%x)
                    deallocate(CurrentOrigin%y)
                endif

                !Kill oil
                if (OriginToDelete%ObjOil /= 0) then
                
                    call KillOil (OriginToDelete%ObjOil, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR10'
                endif

                !Kill HNS
                if (OriginToDelete%ObjHNS /= 0) then
                    call KillHNS (OriginToDelete%ObjHNS, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR15'
                    call KillTimeSerie(OriginToDelete%ObjTimeSerie, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR30'
                endif

                !Kill WaterQuality
                if (OriginToDelete%State%WQM) then
                    call KillWaterQuality (OriginToDelete%WaterQualityID, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR20'
                endif

                ! Closes Output Tracer Info File
                if (Me%State%OutputTracerInfo) then
                    call UnitsManager(OriginToDelete%troUnit, CLOSE_FILE, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR02.5'
                end if

                ! Closes Output Envelope File
                if (Me%Output%OutputEnvelopeTimeSeries) then
                    call UnitsManager(OriginToDelete%eroUnit, CLOSE_FILE, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR02.6'
                end if

                !Kill TimeSerie
                if (OriginToDelete%MovingOrigin) then
                    call KillTimeSerie(OriginToDelete%ObjTimeSerie, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR30'
                endif

                !Kills ObjJet
                if (OriginToDelete%Movement%ObjJet /= 0) then
                   

                    write(OriginToDelete%Movement%JetUnit,*) '<EndTimeSerie>'

                    call UnitsManager(OriginToDelete%Movement%JetUnit, CLOSE_FILE, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR40'

                    call KillJet (JetID = OriginToDelete%Movement%ObjJet,  STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR50'
                endif

                
                if (OriginToDelete%FlowVariable) then
                    call KillTimeSerie(OriginToDelete%TimeSerieInputFlow, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR60'
                endif
                
                if (associated(OriginToDelete%PolyEmission)) then
                    deallocate(OriginToDelete%PolyEmission)
                    nullify   (OriginToDelete%PolyEmission)
                endif



                !Kill PropertyList
                CurrentProperty => OriginToDelete%FirstProperty
                do while (associated(CurrentProperty))
                    if (CurrentProperty%ConcVariable) then
                        call KillTimeSerie(CurrentProperty%TimeSerieInput, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'DeleteOrigin - ModuleLagrangianGlobal - ERR70'
                    endif
                    call DeleteProperty (OriginToDelete, CurrentProperty)
                    CurrentProperty => OriginToDelete%FirstProperty
                enddo

                !Kill ParticleList
                CurrentParticle => OriginToDelete%FirstPartic
                do while (associated(CurrentParticle))
                    call DeleteParticle (OriginToDelete, CurrentParticle)
                    CurrentParticle => OriginToDelete%FirstPartic
                enddo
                    
                !Update Previous Next
                if (associated(PreviousOrigin)) then
                    PreviousOrigin%Next => NextOrigin
                endif

                !Deallocate Origin
                nullify       (OriginToDelete%Next)
                deallocate    (OriginToDelete)
                nullify       (OriginToDelete)

                !Decreases number of origins
                nOrigins = nOrigins - 1

                if (nOrigins == 0) then
                    nullify (FirstOrigin) 
                endif

                return
            endif

            PreviousOrigin => CurrentOrigin
            CurrentOrigin  => CurrentOrigin%Next

        enddo
        

    end subroutine DeleteOrigin

    !--------------------------------------------------------------------------

    subroutine AllocateNewProperty(NewProperty)

        !Arguments-------------------------------------------------------------
        type (T_Property), pointer                  :: NewProperty

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL

        nullify  (NewProperty)
        allocate (NewProperty, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'AllocateNewProperty - ModuleLagrangianGlobal - ERR01'
        nullify  (NewProperty%Next)

    end subroutine AllocateNewProperty

    !--------------------------------------------------------------------------

    subroutine InsertPropertyToList(Origin, NewProperty, SetStates)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: Origin
        type (T_Property), pointer                  :: NewProperty
        logical                                     :: SetStates

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty   => null()
        type (T_Property), pointer                  :: PreviousProperty  => null()

        !Inserts a new property to the list of properties
        if (.not. associated(Origin%FirstProperty)) then
            Origin%FirstProperty => NewProperty
        else
            PreviousProperty => Origin%FirstProperty
            CurrentProperty  => PreviousProperty%Next
            do while (associated(CurrentProperty))
                PreviousProperty => CurrentProperty
                CurrentProperty  => PreviousProperty%Next
            enddo
            PreviousProperty%Next => NewProperty
        endif

        Origin%nProperties      = Origin%nProperties + 1

        if(NewProperty%T90ON) then
            Origin%nPropT90 = Origin%nPropT90 + 1
        endif

        if (SetStates) then

            select case (NewProperty%ID)

            case (Phytoplankton_                  )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON
                                            
            case (Zooplankton_                    )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON
                                            
            case (Larvae_                         )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON
                Origin%State%Larvae     = ON
                Me%State%Larvae         = ON

            case (Age_                            )
                if(.not.NewProperty%NoWQM) then
                 Origin%State%WQM        = ON
                 Me%State%WQM            = ON
                endif
                  
                                            

            case (PON_)
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (DONRefractory_                  )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON
           
            case (DONNon_Refractory_              )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON
           
            case (Ammonia_                        )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (Nitrate_                        )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (Nitrite_                        )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (BOD_                            )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (Oxygen_                         )
                if(.not.NewProperty%NoWQM) then
                Origin%State%WQM        = ON
                Me%State%WQM            = ON
                endif

            case (Ciliate_                        )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (Bacteria_                       )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (POP_                            )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (DOPRefractory_                  )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (DOPNon_Refractory_              )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (Inorganic_Phosphorus_           )
                Origin%State%WQM        = ON
                Me%State%WQM            = ON

            case (Oil_                            )
                Origin%State%Oil        = ON
                Me%State%Oil            = ON
                Me%State%Density        = ON
                Origin%State%Density    = ON
                Me%State%Wind           = ON
                
            case (HNS_                            )
                Origin%State%HNS        = ON
                Me%State%HNS            = ON
                Me%State%Wind           = ON
                Me%State%Density        = ON
                Origin%State%Density    = ON

            case (FloatingObject_                 )
                Me%State%FloatingObject = ON
                Origin%State%FloatingObject    = ON
                Origin%Movement%Float   = ON
                Me%State%Density        = ON
                Origin%State%Density    = ON
                Me%State%Wind           = ON

            case (HumanBody_                      )
                Me%State%HumanBody      = ON
                Origin%State%HumanBody  = ON
                

            case (Fecal_Coliforms_, E_Coli_       )
                Origin%State%FC         = ON
                Me%State%FC             = ON

            end select

        endif


    end subroutine InsertPropertyToList

    !--------------------------------------------------------------------------

    subroutine DeleteProperty (Origin, PropertyToDelete)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: Origin
        type (T_Property), pointer                  :: PropertyToDelete

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty    => null()
        type (T_Property), pointer                  :: PreviousProperty   => null()
        type (T_Property), pointer                  :: NextProperty       => null()

        nullify (PreviousProperty)
        CurrentProperty => Origin%FirstProperty

        do 
            if (CurrentProperty%ID == PropertyToDelete%ID) then

                NextProperty     => CurrentProperty%Next
 
                !Updates first origin
                if (PropertyToDelete%ID == Origin%FirstProperty%ID) then
                    Origin%FirstProperty => NextProperty
                endif

                !Updates Previous Next
                if (associated(PreviousProperty)) then
                    PreviousProperty%Next => NextProperty
                endif

                !Deallocate properties
                nullify       (PropertyToDelete%Next)
                deallocate    (PropertyToDelete)
                nullify       (PropertyToDelete)

                !Decreases number of properties
                Origin%nProperties = Origin%nProperties - 1

                if (Origin%nProperties == 0) then
                    nullify (Origin%FirstProperty) 
                endif

                return
            endif

            PreviousProperty  => CurrentProperty
            CurrentProperty   => CurrentProperty%Next

        enddo

    end subroutine DeleteProperty

    !--------------------------------------------------------------------------

    subroutine AllocateNewParticle (NewPartic, nProp, NextParticID, DefineID)

        !Arguments-------------------------------------------------------------
        type (T_Partic), pointer                    :: NewPartic
        integer                                     :: nProp
        integer                                     :: NextParticID
        logical, optional                           :: DefineID
        
        !Local-----------------------------------------------------------------
        logical                                     :: DefineID_
        
        !Begin-----------------------------------------------------------------        

        nullify  (NewPartic)
        allocate (NewPartic)
        nullify  (NewPartic%Next)
        nullify  (NewPartic%Prev)

        if (nProp > 0) then
            allocate(NewPartic%Concentration (nProp))
            allocate(NewPartic%AmbientConc   (nProp))
            allocate(NewPartic%Mass          (nProp))
            
            NewPartic%Concentration (:) = FillValueReal
            NewPartic%AmbientConc   (:) = FillValueReal
            NewPartic%Mass          (:) = FillValueReal                        
        else
            nullify (NewPartic%Concentration        )
            nullify (NewPartic%AmbientConc          )
            nullify (NewPartic%Mass                 )
        endif

        NewPartic%KillPartic = OFF

        NewPartic%TpercursoH = abs(null_real)
        NewPartic%TpercursoZ = abs(null_real)
        
        NewPartic%EmissionTime = Me%Now
        
        if (present(DefineID)) then
            DefineID_ = DefineID
        else
            DefineID_ = .true.  
        endif                
        
        if (DefineID_) then
            NewPartic%ID         = NextParticID
            NextParticID         = NextParticID + 1
        endif


    end subroutine AllocateNewParticle

    !--------------------------------------------------------------------------

    subroutine InsertParticleToList (Origin, NewParticle, InitConcentration)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: Origin
        type (T_Partic), pointer                    :: NewParticle
        logical                                     :: InitConcentration

        !Local-----------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentParticle  => null()
        type (T_Partic), pointer                    :: PreviousParticle => null()
        type (T_Property), pointer                  :: CurrentProperty  => null()
        integer                                     :: iP, emp
        integer                                     :: i, j, WS_KUB
        real                                        :: Concentration


        emp = NewParticle%Position%ModelID

        !Initializes Mass and Concentration of the new particle
        if (InitConcentration) then

            iP = 1
            CurrentProperty => Origin%FirstProperty
            do while (associated(CurrentProperty))
                

                if (CurrentProperty%EqualToAmbient) then
                    

                    call GetAmbientConcPartic (CurrentProperty, iP, emp, NewParticle, Concentration)

                else

                    Concentration = CurrentProperty%Concentration
                endif


                NewParticle%Concentration(iP) = Concentration
                NewParticle%Mass         (iP) = Concentration * NewParticle%Geometry%Volume
        
                iP = iP + 1
                CurrentProperty => CurrentProperty%Next
            enddo

        endif


        if (Origin%State%Deposition) then
        
            NewParticle%TauErosion    = Origin%Deposition%TauErosion
            NewParticle%TauDeposition = Origin%Deposition%TauDeposition
            NewParticle%Deposited     = Origin%Deposition%BottomEmission

        endif
        
        WS_KUB = Me%EulerModel(emp)%WorkSize%KUB
    
        !Grid Cell of the particle
        i        = NewParticle%Position%I
        j        = NewParticle%Position%J


        !check if the particle is near the surface
        if (Origin%Movement%Float) then 
            NewParticle%Position%Surface = .true.
        else
            if (NewParticle%Position%Z < Me%EulerModel(emp)%SZZ(i, j,  WS_KUB)) then
            
                !Particle is above surface; and is sent to surface
                NewParticle%Position%Z = Me%EulerModel(emp)%SZZ(i, j,  WS_KUB)
            
                NewParticle%Position%Surface = .true.
                
            elseif (( NewParticle%Position%Z - Me%EulerModel(emp)%SZZ(i, j,  WS_KUB)) .LE. 0.1) then                
                ! particle is near the surface; is considered to be in the surface
                 NewParticle%Position%Surface = .true.
            else
                ! particle is below the surface
                NewParticle%Position%Surface = .false.                                
                Origin%NbrSubmerged = Origin%NbrSubmerged + 1
            end if    
            
        endif         


        !Inserts a new property to the list of properties
        if (.not. associated(Origin%FirstPartic)) then
            Origin%FirstPartic => NewParticle
        else
            PreviousParticle => Origin%FirstPartic
            CurrentParticle  => PreviousParticle%Next
            do while (associated(CurrentParticle))
                PreviousParticle => CurrentParticle
                CurrentParticle  => PreviousParticle%Next
            enddo
            PreviousParticle%Next => NewParticle
            NewParticle%Prev      => PreviousParticle
        endif
        

        Origin%nParticle = Origin%nParticle + 1
        Origin%nParticleEmit = Origin%nParticleEmit + 1


    end subroutine InsertParticleToList

    !--------------------------------------------------------------------------

    subroutine DeleteParticle (Origin, ParticleToDelete)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: Origin
        type (T_Partic), pointer                    :: ParticleToDelete

        !Local-----------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentPartic => null()
        type (T_Partic), pointer                    :: NextParticle  => null()
        type (T_Partic), pointer                    :: PrevParticle  => null()

        logical                                     :: ParticleDeleted
        !Begin-----------------------------------------------------------------

        ParticleDeleted = .false. 

        CurrentPartic => Origin%FirstPartic

d1:     do while (associated(CurrentPartic)) 
                     
i1:         if (CurrentPartic%ID == ParticleToDelete%ID) then


                PrevParticle => CurrentPartic%Prev
                NextParticle => CurrentPartic%Next

 
                !Updates foward pointer
                if (associated(CurrentPartic%Prev)) then
                    if (associated(NextParticle)) then
                        PrevParticle%Next => NextParticle
                    else
                        nullify(PrevParticle%Next)
                    endif
                endif

                !Updates backward pointer
                if (associated(CurrentPartic%Next)) then
                    if (associated(PrevParticle)) then
                        NextParticle%Prev => PrevParticle
                    else
                        nullify(NextParticle%Prev)
                    endif
                endif

                !Updates first origin
                if (ParticleToDelete%ID == Origin%FirstPartic%ID) then
                    Origin%FirstPartic => NextParticle
                endif


                !Delete Concentration and Mass Buffer
                if (associated(ParticleToDelete%Concentration)) then
                    deallocate(ParticleToDelete%Concentration)
                    nullify   (ParticleToDelete%Concentration)
                endif

                if (associated(ParticleToDelete%Mass         )) then
                    deallocate(ParticleToDelete%Mass         )
                    nullify   (ParticleToDelete%Mass         )
                endif

                !Deallocate Particle
!                nullify       (ParticleToDelete%Next)
!                nullify       (ParticleToDelete%Prev)
                deallocate    (ParticleToDelete)
                nullify       (ParticleToDelete, CurrentPartic)

                !Decreases number of particle
                Origin%nParticle = Origin%nParticle - 1

                if (Origin%nParticle == 0) then
                    nullify (Origin%FirstPartic) 
                endif

                ParticleDeleted = .true. 

                exit

            endif i1

            CurrentPartic => CurrentPartic%Next

        enddo d1

        if (.not. ParticleDeleted) then
            stop 'DeleteParticleDeleted - ModuleLagrangianGlobal - ERR10'
        endif

    end subroutine DeleteParticle
    
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SE

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !----------------------------------------------------------------------------
    
    subroutine SetLagrangianAtmPressureGlobal(LagrangianID, ModelName, AtmPressure, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: LagrangianID
        character(len=*)                            :: ModelName
        real, pointer, dimension(:,:)               :: AtmPressure
        integer, optional, intent(OUT)              :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_, ModelID          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            ModelID = ReturnModelIndex (ModelName)

            Me%EulerModel(ModelID)%AtmPressure => AtmPressure
                        
            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetLagrangianAtmPressureGlobal

    !----------------------------------------------------------------------------
    
    subroutine SetLagSolarRadiationGlobal(LagrangianID, ModelName, SolarRadiation, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: LagrangianID
        character(len=*)                            :: ModelName
        real, pointer, dimension(:,:)               :: SolarRadiation
        integer, optional, intent(OUT)              :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_, ModelID          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            ModelID = ReturnModelIndex (ModelName)

            Me%EulerModel(ModelID)%SurfaceRadiation => SolarRadiation
                        
            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetLagSolarRadiationGlobal

    !----------------------------------------------------------------------------
    
    subroutine SetLagrangianWindGlobal(LagrangianID, ModelName, WindX, WindY, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: LagrangianID
        character(len=*)                            :: ModelName
        real, pointer, dimension(:,:)               :: WindX, WindY
        integer, optional, intent(OUT)              :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_, ModelID          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

            if(Me%State%Wind)then

                ModelID = ReturnModelIndex (ModelName)

                Me%EulerModel(ModelID)%WindX => WindX
                Me%EulerModel(ModelID)%WindY => WindY
            end if


            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetLagrangianWindGlobal


    !----------------------------------------------------------------------

!----------------------------------------------------------------------------
    
    subroutine SetLagrangianAirTemperature(LagrangianID, ModelName, AirTemperature, STAT)

        !Arguments---------------------------------------------------------------
        integer                                     :: LagrangianID
        character(len=*)                            :: ModelName
        real, pointer, dimension(:,:)               :: AirTemperature
        integer, optional, intent(OUT)              :: STAT

        !Local-------------------------------------------------------------------
        integer                                     :: ready_, ModelID          
        integer                                     :: STAT_    

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_) 
        
        if (ready_ .EQ. IDLE_ERR_)then

                ModelID = ReturnModelIndex (ModelName)

                Me%EulerModel(ModelID)%AirTemperature2D => AirTemperature

            STAT_ = SUCCESS_  

        else
            STAT_ = ready_
        end if


        if (present(STAT))STAT = STAT_
            
    end subroutine SetLagrangianAirTemperature

    !----------------------------------------------------------------------
    subroutine SetLagrangianShearGlobal(LagrangianID, ModelName, ShearStress, ShearVelocity, STAT)

        !Arguments-------------------------------------------------------------
        integer                         :: LagrangianID
        character(len=*)                :: ModelName
        real, dimension(:,:), pointer   :: ShearStress, ShearVelocity
        integer, optional, intent(OUT)  :: STAT

        !External--------------------------------------------------------------
        integer                         :: ready_, ModelID             
        
        !Local-----------------------------------------------------------------
        integer                         :: STAT_            

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_)  
        
cd1 :   if (ready_ == IDLE_ERR_)then

            ModelID = ReturnModelIndex (ModelName)

            if(Me%State%Deposition) Me%EulerModel(ModelID)%BottomStress  => ShearStress            
            if(Me%State%ShearVel  ) Me%EulerModel(ModelID)%ShearVelocity => ShearVelocity 
            
            STAT_ = SUCCESS_

        else cd1

            STAT_ = ready_

        end if cd1

        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine SetLagrangianShearGlobal


    !----------------------------------------------------------------------

    subroutine GetLagrangianAirOptionsGlobal(LagrangianID, Oil, HNS, Wind, WaterQuality, T90Variable, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        logical, optional, intent(OUT)              :: Oil, HNS, Wind, WaterQuality, T90Variable
        integer, optional, intent(OUT)              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: ready_          
        integer                                     :: STAT_ 

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_) 
        
cd1 :   if ((ready_ .EQ. IDLE_ERR_     ) .OR.                                 &
            (ready_ .EQ. READ_LOCK_ERR_)) then

            Oil             = Me%State%Oil
            HNS             = Me%State%HNS
            Wind            = Me%State%Wind
            WaterQuality    = Me%State%WQM
            T90Variable     = Me%State%T90Variable

            STAT_ = SUCCESS_
        else 
            STAT_ = ready_
        end if cd1


        if (present(STAT)) STAT = STAT_            


    end subroutine GetLagrangianAirOptionsGlobal  

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODI

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    !--------------------------------------------------------------------------

    subroutine ModifyLagrangianGlobal(LagrangianID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_    
        
        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_)

        if (ready_ .EQ. IDLE_ERR_) then

            call ReadLockExternalVar

            do while (Me%ExternalVar%Now >= Me%NextCompute)
                
                Me%Now = Me%NextCompute
                
                if (Me%OverLay) then
                    call OverLayProcess
                endif
                
                call ReadLockEulerianDensity
                
                call ActualizeMeteoOcean    ()

                !Emits new particles in all origins
                call ParticleEmission       ()
                
                !Only compute emission for particle that~were just emitted
                if (Me%State%AccidentProbability) then
                    call ComputeAccidentProbability
                endif                

                !Calculates the Particle Density
                call ParticleDensity        ()

                !Calculates the GridThickness
                if (Me%State%Oil) then                
                    call FillGridThickness      ()             
                endif
                
                if ( Me%State%Larvae ) then
                    call LightEvolution      ()
                endif   
               
                !Moves the Origins
                call MoveOrigin             ()

                if (Me%State%HNS) then
                    call SubmergeSurfaceHeavyParticles()
                    call UpdateHNSAreaVolume(UpdateParticleAreas = .false.)
                    call InternalParticHNS()
                endif

                !Moves the Particles
                call MovePartic             ()
                call CheckSurfaceParticles  ()
                call UpdateParticleState    ()
               
                if (Me%State%HNS) then
                    call UpdateHNSAreaVolume(UpdateParticleAreas = .true.)
                    call UpdateHNSMass      ()
                    call ComputeHNSGridProperties() 
                endif

                !Removes Particles in intertidal areas
                call VerifyLandParticles    ()  

                !Eliminates Particles
                call PurgeParticles         ()

                !Increases Volume
                call VolumeVariation        ()

                !Eliminates Particles
                call PurgeParticles         ()
                
!                call CheckSurfaceParticles  ()

!                !Verifies is a particle is beached
!                if (Me%State%AssociateBeachProb) then
!!                    call GetOilProperties   ()                 
!                    call VerifyParticleBeaching()
!                    call UpdateRemovedVolumes()                  
!                    call VerifyBeachRemoval()
!                endif

                !Dilute Particle with Ambiente Concentration
                call Dilution                ()

                if ( .not. Me%State%Larvae ) then
                    if (Me%State%WQM .or. Me%State%T90Compute) then
                        call LightEvolution      ()
                    endif
                end if
                
                !Calculates Sinks and Sources due WQM
                if (Me%State%WQM) then
                    call PropertiesEvolution ()
                endif

                !Applies T90 to Coliform Particle
                if (Me%State%FC) then
                    call ColiformDecay       ()
                endif

                if (Me%State%Partition) then
                    call PartitionDecay      ()
                endif
                

                !Internal Oil Processes
                if (Me%State%Oil) then

                    call ComputeAreaVolume  ()
                    call InternalParticOil   ()

                    !Verifies is a particle is beached
                    if (Me%State%AssociateBeachProb) then
    !                    call GetOilProperties   ()                 
!                        !update beached volumes after volume variation (weathering processes)

                        if(Me%State%CalcPartDistToCoast)then
                            call CalcParticDistanceToCoast()
                        endif

                        call UpdateBeachHoldingCapacity
                        call UpdateBeachedVolumes()
                        call VerifyParticleBeaching()
                        call UpdateRemovedVolumes()                  
                        call VerifyBeachRemoval()
                        
                    endif
!                    if (Me%State%AssociateBeachProb) then
!                        !update beached volumes after volume variation (weathering processes)
!                        call UpdateBeachedVolumes()
!                    endif

                endif
                


                !Check the concentration limits
                call CheckConcLimits        ()

                !Eliminates Particles
                call PurgeParticles         ()

                !Calculates the Mass of each Particle
                call NewParticleMass        ()

                !Compue Age evolution
                if (Me%State%Age)  then
                    call NewParticleAge ()
                endif
                
                !Compute beaching processes specific of litter
                if (Me%LitterON) then
                    call ProcessLitter      ()
                endif
                
                if (Me%OutputGridON) then
                    call ProcessOutputGrid  ()
                endif
                 
                !Eliminates Particles
                call PurgeParticles         ()                    

                !Monitorization Lag
                if (Me%State%MonitorLag) then
                    call MonitorParticleLag ()
                endif                

                !Monitorization
                if (Me%State%Monitor) then
                    call MonitorParticle    ()
                endif

                if (Me%State%EulerianMonitor)then
                    call MonitorEulerian    ()
                end if

                call ReadUnLockEulerianDensity


                if (Me%State%Filtration) then
                    call ActualizesMassFilterGrid()
                endif
                

                !Statistic
                if (Me%State%Statistics) then
                    call ModifyParticStatistic ()
                endif

                if (Me%State%Deposition) then
                    call ActualizesTauErosionGrid()
                endif
                
!                call UpdateParticleState()
                !Writes Time Series
                if (Me%State%OutputTracerInfo) then
                    call WriteIndividualTracerOutput()
                endif

                call LagrangianOutput
                
            

                Me%NextCompute = Me%NextCompute + Me%DT_Partic

                Me%FirstIteration = .false. 

            enddo
            !endif

            call ReadUnLockExternalVar  ()

            
            STAT_ = SUCCESS_

        else

            STAT_ = ready_

        endif

        if (present(STAT)) STAT = STAT_
        

    end subroutine ModifyLagrangianGlobal

    !--------------------------------------------------------------------------
    
    subroutine CheckSurfaceParticles
    
    
        !Local-----------------------------------------------------------------        
        type (T_Origin), pointer                    :: CurrentOrigin 
        type (T_Partic), pointer                    :: CurrentPartic 
        integer                                     :: i, j, k, WS_KUB, emp
        real                                        :: WaterDensity, ParticleDensity
        integer                                     :: STAT_CALL
        !Begin-----------------------------------------------------------------    


        
        CurrentOrigin => Me%FirstOrigin
d1:     do while (associated(CurrentOrigin))

            CurrentOrigin%NbrSubmerged = 0
            
            CurrentPartic => CurrentOrigin%FirstPartic
d2:         do while (associated (CurrentPartic))

                emp    = CurrentPartic%Position%ModelID
                WS_KUB = Me%EulerModel(emp)%WorkSize%KUB
            
                !Grid Cell of the particle
                i        = CurrentPartic%Position%I
                j        = CurrentPartic%Position%J
                k        = CurrentPartic%Position%K
                
                !check if the particle is near the surface
                if (CurrentOrigin%Movement%Float) then 
                    CurrentPartic%Position%Surface = .true.
                else
                    if (CurrentPartic%Position%Z < Me%EulerModel(emp)%SZZ(i, j,  WS_KUB)) then
                    
                        !Particle is above surface; and is sent to surface
                        CurrentPartic%Position%Z = Me%EulerModel(emp)%SZZ(i, j,  WS_KUB)
                    
                        CurrentPartic%Position%Surface = .true.
                        
                    elseif (( CurrentPartic%Position%Z - Me%EulerModel(emp)%SZZ(i, j,  WS_KUB)) .LE. 0.1) then                
                        ! particle is near the surface; is considered to be in the surface
                         CurrentPartic%Position%Surface = .true.
                    else
                        ! particle is below the surface
                        CurrentPartic%Position%Surface = .false.                                
                        CurrentOrigin%NbrSubmerged = CurrentOrigin%NbrSubmerged + 1
                    end if    
                    
                endif  
                
                if (CurrentOrigin%State%HNS) then
                    !only previously floating or entrained particles lighter than water are allowed 
                    !to stay at surface slick
                    
                    if (CurrentPartic%Position%Surface) then
                        if ((CurrentPartic%HNSParticleState .EQ. WaterColumn_Droplet_) .OR.  &
                            (CurrentPartic%HNSParticleState .EQ. Surface_) &
                           ) then
                            WaterDensity        = Me%EulerModel(emp)%Density (i, j, k)

                            call GetHNSDensity(CurrentOrigin%ObjHNS, ParticleDensity, STAT = STAT_CALL)

                            if (ParticleDensity .LT. WaterDensity) then 
                                CurrentPartic%HNSParticleState = Surface_
                            else
                                CurrentPartic%HNSParticleState = WaterColumn_Droplet_
                            endif
                        endif
                    endif
                endif
                CurrentPartic => CurrentPartic%Next              

            enddo d2
                      
            if (CurrentOrigin%NParticle > 0) then
                CurrentOrigin%Fblowout = real(CurrentOrigin%NbrSubmerged)/ real(CurrentOrigin%NParticle)
            else
                CurrentOrigin%Fblowout = 1.
            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo d1                
        
    end subroutine CheckSurfaceParticles
                
    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------
    
    subroutine RedefinedCoastLine()    

        !Arguments-------------------------------------------------------------
        
        !Local-----------------------------------------------------------------        
        integer,    dimension(:,:,:),   pointer     :: WaterPoints3D
        real,       dimension(:,:),     pointer     :: Bathymetry, CoordX, CoordY,      &
                                                       BathymetryDefault, SurfaceElevation
        type (T_PointF),                pointer     :: Point        
        integer                                     :: i, j, em
        integer                                     :: STAT_CALL
        integer                                     :: WorkSizeILB, WorkSizeIUB, WorkSizeJLB, WorkSizeJUB
        
        !Begin-----------------------------------------------------------------    

rdf:     if (Me%CoastLineON) then


            call ReadUnLockExternalVar

dem:        do em = 1, Me%EulerModelNumber        

                !Shorten
                WorkSizeILB = Me%EulerModel(em)%WorkSize%ILB
                WorkSizeIUB = Me%EulerModel(em)%WorkSize%IUB
                WorkSizeJLB = Me%EulerModel(em)%WorkSize%JLB
                WorkSizeJUB = Me%EulerModel(em)%WorkSize%JUB

                call GetGridData(Me%EulerModel(em)%ObjGridData, BathymetryDefault, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR10' 

                allocate    (Bathymetry(Me%EulerModel(em)%Size%ILB:                     &
                                        Me%EulerModel(em)%Size%IUB,                     &
                                        Me%EulerModel(em)%Size%JLB:                     &
                                        Me%EulerModel(em)%Size%JUB))        

                Bathymetry(:,:) =  BathymetryDefault(:,:)

                call UnGetGridData(Me%EulerModel(em)%ObjGridData, BathymetryDefault, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR20' 


                call GetZCoordinates(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, CoordY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR30'
                
                
                allocate(Point)
                do j = WorkSizeJLB, WorkSizeJUB       
                do i = WorkSizeILB, WorkSizeIUB  
                    Point%X = CoordX(i,j)
                    Point%Y = CoordY(i,j)
                    if (IsVisible(Me%CoastLine, Point)) then
                        Bathymetry(i,j) = -99.
                    endif
                enddo
                enddo            
                deallocate(Point)

                !Ungets CoordX and CoordY
                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleOpenBoundary - ERR40'

                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, CoordY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleOpenBoundary - ERR45'

                call ModifyGridData(Me%EulerModel(em)%ObjGridData, Bathymetry, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR50' 
                
                call UpdateWaterPoints2D(Me%EulerModel(em)%ObjHorizontalMap, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR60' 

                call GetWaterLevel(Me%EulerModel(em)%ObjHydrodynamic, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR70'

                call UpdateKfloor(Me%EulerModel(em)%ObjGeometry, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR80'
                
                call UpDateWaterPoints3D(Me%EulerModel(em)%ObjMap, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR90'

                !Update the moving boundary (boundary of the tidal areas covered)
                call UpdateComputeFaces3D(Map_ID            = Me%EulerModel(em)%ObjMap, &
                                          SurfaceElevation  = SurfaceElevation,         &
                                          ActualTime        = Me%ExternalVar%BeginTime, &
                                          STAT              = STAT_CALL)      
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR110'
                
                call GetWaterPoints3D(Map_ID            = Me%EulerModel(em)%ObjMap,     &
                                      WaterPoints3D     = WaterPoints3D,                &
                                      STAT              = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR100'
                
                call ComputeInitialGeometry(Me%EulerModel(em)%ObjGeometry,              &
                                            WaterPoints3D, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR120'              
                
                call UnGetMap(Map_ID           = Me%EulerModel(em)%ObjMap,              &
                              Array            = WaterPoints3D,                         &
                              STAT             = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR130'


                call UnGetHydrodynamic(Me%EulerModel(em)%ObjHydrodynamic, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'RedefinedCoastLine - ModuleLagrangianGlobal - ERR140'

                deallocate    (Bathymetry)      
            
            enddo dem
            
            call ReadLockExternalVar            

        endif rdf   
                         
    end subroutine RedefinedCoastLine    

    !--------------------------------------------------------------------------
    
    
    subroutine ReadMeteoOceanBathym()    

        !Arguments-------------------------------------------------------------
        
        !Local-----------------------------------------------------------------        
        integer,    dimension(:,:,:),   pointer     :: WaterPoints3D
        real,       dimension(:,:),     pointer     :: Bathymetry, CoordX, CoordY,      &
                                                       BathymetryDefault, SurfaceElevation
        real,       dimension(:  ),     pointer     :: Matrix1DX
        real,       dimension(:  ),     pointer     :: Matrix1DY        
        real,       dimension(:  ),     pointer     :: Prop1D
        logical,    dimension(:  ),     pointer     :: NoData
        !type (T_PointF),                pointer     :: Point        
        integer                                     :: ic, nCellT, nF, nFiles_total, i, j, em
        integer                                     :: nMOP, nMOPtotal, STAT_CALL
        integer                                     :: WorkSizeILB, WorkSizeIUB, WorkSizeJLB, WorkSizeJUB
        logical                                     :: ReadBathym
        
        !Begin-----------------------------------------------------------------    
        ReadBathym = .false.
        
        nMOPtotal = Me%MeteoOcean%PropNumber
        
do3:    do nMOP = 1, nMOPtotal
            if (Me%MeteoOcean%Prop(nMOP)%ID%IDNumber == bathymetry_) then
                ReadBathym = .true.
                exit
            endif    
        enddo do3
        
rb:     if (ReadBathym) then

            call ReadUnLockExternalVar
        
dem:        do em = 1, Me%EulerModelNumber

                !Shorten
                WorkSizeILB = Me%EulerModel(em)%WorkSize%ILB
                WorkSizeIUB = Me%EulerModel(em)%WorkSize%IUB
                WorkSizeJLB = Me%EulerModel(em)%WorkSize%JLB
                WorkSizeJUB = Me%EulerModel(em)%WorkSize%JUB


                call GetGridData(Me%EulerModel(em)%ObjGridData, BathymetryDefault, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR10' 

                allocate    (Bathymetry(Me%EulerModel(em)%Size%ILB:                     &
                                        Me%EulerModel(em)%Size%IUB,                     &
                                        Me%EulerModel(em)%Size%JLB:                     &
                                        Me%EulerModel(em)%Size%JUB))        

                Bathymetry(:,:) =  BathymetryDefault(:,:)

                call UnGetGridData(Me%EulerModel(em)%ObjGridData, BathymetryDefault, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR20' 

                nCellT = (WorkSizeIUB-WorkSizeILB + 1) * (WorkSizeJUB-WorkSizeJLB + 1)

                allocate    (Matrix1DX(nCellT))
                allocate    (Matrix1DY(nCellT))

                Matrix1DX(:) = FillValueReal
                Matrix1DY(:) = FillValueReal

                call GetZCoordinates(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, CoordY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR30'
                
                ic = 1
                do j = WorkSizeJLB, WorkSizeJUB       
                do i = WorkSizeILB, WorkSizeIUB                   
                    Matrix1DX(ic)  =  CoordX(i,j)
                    Matrix1DY(ic)  =  CoordY(i,j)
                    ic = ic + 1
                enddo
                enddo
                
                !Ungets CoordX and CoordY
                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, CoordX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR32'

                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, CoordY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR35'                

                if (Me%MeteoOcean%Prop(nMOP)%FieldNumber > 0) then

                    allocate    (Prop1D   (nCellT))     
                    allocate    (NoData   (nCellT))

                    Prop1D   (:) = FillValueReal  
                    NoData   (:) = .true.

                
                    nFiles_total = Me%MeteoOcean%Prop(nMOP)%FieldNumber
                    
                    NoData   (:) = .true.
 do4:               do nF = 1, nFiles_total
                        call GetBathymXY(Field4DID        = Me%MeteoOcean%Prop(nMOP)%Field(nF)%ID, &
                                         PropertyIDNumber = Me%MeteoOcean%Prop(nMOP)%ID%IDNumber,  &
                                         X                = Matrix1DX,                      &
                                         Y                = Matrix1DY,                      &
                                         Bathym           = Prop1D,                         &
                                         NoData           = NoData,                         &
                                         STAT             = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR40' 
                    enddo do4
                    
                    ic = 1
                    do j = WorkSizeJLB, WorkSizeJUB       
                    do i = WorkSizeILB, WorkSizeIUB                   
                        if (.not.NoData(ic)) then
                            if (Prop1D(ic) > -50.) then
                                Bathymetry(i,j) = Prop1D(ic)
                            endif
                        endif
                        ic = ic + 1
                    enddo
                    enddo
                        
                    deallocate    (Prop1D    )     
                    deallocate    (NoData    )                     
                
                endif
                
!                if (Me%CoastLineON) then
!                    allocate(Point)
!                    ic = 1
!                    do j = WorkSizeJLB, WorkSizeJUB       
!                    do i = WorkSizeILB, WorkSizeIUB  
!                        Point%X = Matrix1DX(ic)
!                        Point%Y = Matrix1DY(ic)                
!                        if (IsVisible(Me%CoastLine, Point)) then
!                            Bathymetry(i,j) = -99.
!                        endif
!                        ic = ic + 1
!                    enddo
!                    enddo            
!                    deallocate(Point)
!                endif
                
                call ModifyGridData(Me%EulerModel(em)%ObjGridData, Bathymetry, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR50' 
                
                call UpdateWaterPoints2D(Me%EulerModel(em)%ObjHorizontalMap, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR60' 

                call GetWaterLevel(Me%EulerModel(em)%ObjHydrodynamic, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR70'

                call UpdateKfloor(Me%EulerModel(em)%ObjGeometry, SurfaceElevation, BathymNotCorrect = .true., STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR80'
                
                call UpDateWaterPoints3D(Me%EulerModel(em)%ObjMap, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR90'

                !Update the moving boundary (boundary of the tidal areas covered)
                call UpdateComputeFaces3D(Map_ID            = Me%EulerModel(em)%ObjMap, &
                                          SurfaceElevation  = SurfaceElevation,         &
                                          ActualTime        = Me%ExternalVar%BeginTime, &
                                          STAT              = STAT_CALL)      
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR110'
                
                call GetWaterPoints3D(Map_ID            = Me%EulerModel(em)%ObjMap,     &
                                      WaterPoints3D     = WaterPoints3D,                &
                                      STAT              = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR100'
                
                call ComputeInitialGeometry(Me%EulerModel(em)%ObjGeometry,              &
                                            WaterPoints3D, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR120'              
                
                call UnGetMap(Map_ID           = Me%EulerModel(em)%ObjMap,              &
                              Array            = WaterPoints3D,                         &
                              STAT             = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR130'


                call UnGetHydrodynamic(Me%EulerModel(em)%ObjHydrodynamic, SurfaceElevation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadMeteoOceanBathym - ModuleLagrangianGlobal - ERR140'

                deallocate    (Matrix1DX )
                deallocate    (Matrix1DY )
                deallocate    (Bathymetry)      
            
            enddo dem
            
            call ReadLockExternalVar            
            
        endif rb
                    
    end subroutine ReadMeteoOceanBathym    

    !--------------------------------------------------------------------------

    
    
    subroutine ActualizeMeteoOcean()    

        !Arguments-------------------------------------------------------------
        
        !Local-----------------------------------------------------------------        
        type (T_Origin), pointer                    :: CurrentOrigin 
        type (T_Partic), pointer                    :: CurrentPartic 
        type (T_Property), pointer                  :: CurrentProperty
        real,       dimension(:), pointer           :: Matrix1DX
        real,       dimension(:), pointer           :: Matrix1DY        
        real,       dimension(:), pointer           :: Matrix1DZ  
        real,       dimension(:), pointer           :: Prop1D
        logical,    dimension(:), pointer           :: NoData
        integer,    dimension(:), pointer           :: Solution  
        integer                                     :: nP, nPtotal, nF, nFiles_total
        integer                                     :: nMOP, nMOPtotal, STAT_CALL
        integer                                     :: iP
        !Begin-----------------------------------------------------------------    

        !Reset particles meteo-ocean values
        nPtotal = 0
        CurrentOrigin => Me%FirstOrigin
d1:     do while (associated(CurrentOrigin))
            nPtotal = nPtotal + CurrentOrigin%nParticle
                CurrentPartic   => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                
                    CurrentPartic%CurrentX      = FillValueReal
                    CurrentPartic%CurrentY      = FillValueReal
                    CurrentPartic%CurrentZ      = FillValueReal
                    CurrentPartic%WindX         = FillValueReal
                    CurrentPartic%WindY         = FillValueReal
                    CurrentPartic%WaveHeight    = FillValueReal
                    CurrentPartic%WavePeriod    = FillValueReal
                    CurrentPartic%WaveDirection = FillValueReal
                    CurrentPartic%WaveLength    = FillValueReal

                    CurrentPartic%SolutionCX    = FillValueInt
                    CurrentPartic%SolutionCY    = FillValueInt
                    CurrentPartic%SolutionCZ    = FillValueInt
                    CurrentPartic%SolutionWX    = FillValueInt
                    CurrentPartic%SolutionWY    = FillValueInt
                    CurrentPartic%SolutionWH    = FillValueInt
                    CurrentPartic%SolutionWP    = FillValueInt
                    CurrentPartic%SolutionWD    = FillValueInt
                    CurrentPartic%SolutionWL    = FillValueInt
                    CurrentPartic%SolutionS     = FillValueInt
                    CurrentPartic%SolutionT     = FillValueInt    
                    
                    CurrentProperty => CurrentOrigin%FirstProperty
                    iP = 1
                    do while (associated(CurrentProperty))

                        !Define Ambient conc
                        call GetAmbientConcCell(Property      = CurrentProperty,                   &
                                                ModelID       = CurrentPartic%Position%ModelID,    &
                                                Position      = CurrentPartic%Position,            &    
                                                Concentration = CurrentPartic%AmbientConc(iP))
                        iP = iP + 1
                        CurrentProperty => CurrentProperty%Next
                    enddo                    

                    CurrentPartic               => CurrentPartic%Next
                enddo
            CurrentOrigin => CurrentOrigin%Next
        enddo d1
        
        if (Me%State%MeteoOcean) then
        
            nMOPtotal = Me%MeteoOcean%PropNumber        
       
            allocate    (Matrix1DX(nPtotal))
            allocate    (Matrix1DY(nPtotal))
            allocate    (Matrix1DZ(nPtotal)) 
            allocate    (Solution (nPtotal))             
            allocate    (Prop1D   (nPtotal))     
            allocate    (NoData   (nPtotal))                                 
                         
            Matrix1DX(:) = FillValueReal
            Matrix1DY(:) = FillValueReal
            Matrix1DZ(:) = FillValueReal  
             
            nP = 1
            CurrentOrigin => Me%FirstOrigin
    d2:     do while (associated(CurrentOrigin))
                CurrentPartic   => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                
                    Matrix1DX(nP)  =  CurrentPartic%Position%CoordX
                    Matrix1DY(nP)  =  CurrentPartic%Position%CoordY 
                    Matrix1DZ(nP)  =  CurrentPartic%Position%Z          
                         
                    CurrentPartic => CurrentPartic%Next
                    nP = nP + 1
                enddo

                if (CurrentOrigin%State%StokesDrift) then
                    CurrentOrigin%Movement%WaveLengthFromPeriod = .true.
                    do nMOP = 1, nMOPtotal
                        if (Me%MeteoOcean%Prop(nMOP)%ID%IDNumber == WaveLength_) then
                            CurrentOrigin%Movement%WaveLengthFromPeriod = .false.        
                            exit
                        endif
                     enddo                               
                endif
                
                CurrentOrigin => CurrentOrigin%Next
            enddo d2
            
            
                
                
            
    do3:    do nMOP = 1, nMOPtotal
                if (Me%MeteoOcean%Prop(nMOP)%ID%IDNumber == bathymetry_) cycle 
                
                nFiles_total = Me%MeteoOcean%Prop(nMOP)%FieldNumber
                
                NoData   (:) = .true.
                Solution (:) = 0  
                Prop1D   (:) = FillValueReal                                

    do4:        do nF = 1, nFiles_total
    
                    if (Me%MeteoOcean%Prop(nMOP)%FileListMode) then
                        if (Me%MeteoOcean%Prop(nMOP)%Field(nF)%NFilesList < 1) cycle
                    endif
    
                    call ModifyField4DXYZ(Field4DID             = Me%MeteoOcean%Prop(nMOP)%Field(nF)%ID, &
                                          PropertyIDNumber      = Me%MeteoOcean%Prop(nMOP)%ID%IDNumber,  &
                                          !CurrentTime           = Me%ExternalVar%Now,               &
                                          CurrentTime           = Me%NextCompute,                   &
                                          X                     = Matrix1DX,                        &
                                          Y                     = Matrix1DY,                        &
                                          Z                     = Matrix1DZ,                        &
                                          Field                 = Prop1D,                           &
                                          NoData                = NoData,                           &
                                          STAT                  = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ActualizeMeteoOcean - ModuleLagrangianGlobal - ERR10' 
                    
                    do nP = 1, nPtotal
                        if (.not. NoData(nP) .and. Solution (nP) == 0) then
                            Solution (nP) = nF
                        endif
                    enddo
                enddo do4
                
                nP = 1
                CurrentOrigin => Me%FirstOrigin
        d5:     do while (associated(CurrentOrigin))
                    CurrentPartic   => CurrentOrigin%FirstPartic
                    do while (associated(CurrentPartic))
                    
                        if (NoData(nP)) Prop1D(nP) = FillValueReal
                    
                        call ActualizeMeteoOceanPartic(CurrentPartic,                       &
                                                       Me%MeteoOcean%Prop(nMOP)%ID%IDNumber,&
                                                       Prop1D(nP),                          &
                                                       Me%MeteoOcean%Prop(nMOP)%LagPropI,   &
                                                       Me%MeteoOcean%Prop(nMOP)%EqualToAmbient,&
                                                       Solution(nP))
                             
                        CurrentPartic => CurrentPartic%Next
                        nP = nP + 1
                    enddo
                    CurrentOrigin => CurrentOrigin%Next
                enddo d5

                
            enddo do3
            

            deallocate    (Matrix1DX)
            deallocate    (Matrix1DY)
            deallocate    (Matrix1DZ) 
            deallocate    (Solution )
            deallocate    (Prop1D   )     
            deallocate    (NoData   )        
            
        endif            
                    
    end subroutine ActualizeMeteoOcean    

    !--------------------------------------------------------------------------

    subroutine ActualizeMeteoOceanPartic(CurrentPartic, PropIDNumber, PropValue,        &
                                         LagPropI, EqualToAmbient, Solution)
                                                   
        !Arguments-------------------------------------------------------------
        type (T_Partic), pointer                :: CurrentPartic 
        integer                                 :: PropIDNumber
        real                                    :: PropValue
        integer                                 :: LagPropI
        logical                                 :: EqualToAmbient
        integer                                 :: Solution

        !Local-----------------------------------------------------------------        
        
        !Begin-----------------------------------------------------------------                                                                   

        if      (PropIDNumber == VelocityU_     ) then
        
            CurrentPartic%CurrentX   = PropValue
            CurrentPartic%SolutionCX = Solution
        
        elseif  (PropIDNumber == VelocityV_     ) then 

            CurrentPartic%CurrentY   = PropValue
            CurrentPartic%SolutionCY = Solution

        elseif  (PropIDNumber == VelocityW_     ) then 

            CurrentPartic%CurrentZ   = PropValue
            CurrentPartic%SolutionCZ = Solution

        elseif  (PropIDNumber == WindVelocityX_ ) then 

            !During the passage of Tropical Cyclone Olivia on 10 April 1996, 
            !an automatic weather station on Barrow Island, Australia, registered a maximum wind gust of 113 m/s
            !Source : wikipedia
            if (PropValue > HalfFillValueReal .and. abs(PropValue)>150 ) PropValue = 0

            CurrentPartic%WindX      = PropValue
            CurrentPartic%SolutionWX = Solution

        elseif  (PropIDNumber == WindVelocityY_ ) then

            !During the passage of Tropical Cyclone Olivia on 10 April 1996, 
            !an automatic weather station on Barrow Island, Australia, registered a maximum wind gust of 113 m/s
            !Source : wikipedia
            if (PropValue > HalfFillValueReal .and. abs(PropValue)>150 ) PropValue = 0
            
            CurrentPartic%WindY      = PropValue
            CurrentPartic%SolutionWY = Solution

        elseif  (PropIDNumber == WaveAmplitude_ ) then  

            CurrentPartic%WaveHeight = PropValue
            CurrentPartic%SolutionWH = Solution            

        elseif  (PropIDNumber == WavePeriod_    ) then  

            CurrentPartic%WavePeriod = PropValue
            CurrentPartic%SolutionWP = Solution            

        elseif  (PropIDNumber == WaveDirection_ ) then  

            CurrentPartic%WaveDirection = PropValue

            if (CurrentPartic%WaveDirection > 360. .and. CurrentPartic%WaveDirection <= 720.) then                        
                CurrentPartic%WaveDirection = CurrentPartic%WaveDirection - 360.
            endif
            
            if (CurrentPartic%WaveDirection >= -360. .and. CurrentPartic%WaveDirection < 0.) then                        
                CurrentPartic%WaveDirection = CurrentPartic%WaveDirection + 360.
            endif            
                                    
            CurrentPartic%SolutionWD    = Solution
            
        elseif  (PropIDNumber == WaveLength_ ) then  

            CurrentPartic%WaveLength    = PropValue
            CurrentPartic%SolutionWL    = Solution

        else
            if (PropValue > FillValueReal/100) then 
                CurrentPartic%AmbientConc(LagPropI) = PropValue
                
                if (PropIDNumber == Temperature_) then
                    CurrentPartic%SolutionT    = Solution
                endif
                
                if (PropIDNumber == Salinity_   ) then
                    CurrentPartic%SolutionS    = Solution
                endif
                
                
                if (EqualToAmbient) then
                    CurrentPartic%Concentration(LagPropI) = CurrentPartic%AmbientConc(LagPropI)
                endif
            endif
        endif
        
        
        
    end subroutine ActualizeMeteoOceanPartic
    
    !--------------------------------------------------------------------------    
    
    subroutine LagrangianOutput ()
    
        !Arguments-------------------------------------------------------------
        
        !Begin-----------------------------------------------------------------    
        
        
            !Writes Particle Output
            call ParticleOutput         ()
    
            if (Me%State%HNS) then
                call OutPut_HNSTimeSerie
            endif
            
            !Writes Time Series !FM
            if (Me%WritesTimeSerie) then
               call OutPut_TimeSeries   ()
            endif

            if(Me%Output%WriteRestartFile)then
                call OutputRestartFile
            end if
            
    end subroutine LagrangianOutput
    
    !--------------------------------------------------------------------------    
    
    subroutine OverLayProcess ()

        !Arguments-------------------------------------------------------------
        
        !Local-----------------------------------------------------------------
        integer                                     :: WorkSizeILB, WorkSizeIUB
        integer                                     :: WorkSizeJLB, WorkSizeJUB
        integer                                     :: WorkSizeKLB, WorkSizeKUB
        integer                                     :: i, j, k
        integer                                     :: STAT_CALL, em

        do em = 1, Me%EulerModelNumber

            !Shorten
            WorkSizeILB = Me%EulerModel(em)%WorkSize%ILB
            WorkSizeIUB = Me%EulerModel(em)%WorkSize%IUB
            WorkSizeJLB = Me%EulerModel(em)%WorkSize%JLB
            WorkSizeJUB = Me%EulerModel(em)%WorkSize%JUB
            WorkSizeKLB = Me%EulerModel(em)%WorkSize%KLB
            WorkSizeKUB = Me%EulerModel(em)%WorkSize%KUB


            !call GetAssimilationField(Me%EulerModel(em)%ObjAssimilation,                 &
            !                          ID          = VelocityU_,                      &
            !                          Field3D     = Me%EulerModel(em)%OverLayU,  &
            !                          STAT        = STAT_CALL)
                                      
            !It is important to read vector fields in agreggated way to allow the 
            !rotation of the meridional/zonal velocities to be align with the grid/cell orientation
            call GetAssimilationVectorField                                             &
                                 (AssimilationID    = Me%EulerModel(em)%ObjAssimilation,&
                                  VectorX_ID        = VelocityU_,                       &
                                  VectorY_ID        = VelocityV_,                       & 
                                  VectorX_3D        = Me%EulerModel(em)%OverLayU,       & 
                                  VectorY_3D        = Me%EulerModel(em)%OverLayV,       &
                                  STAT              = STAT_CALL)                                      
            if (STAT_CALL /= SUCCESS_) stop 'OverLayProcess - ModuleLagrangianGlobal - ERR01' 

            !call GetAssimilationField(Me%EulerModel(em)%ObjAssimilation,                 &
            !                          ID          = VelocityV_,                      &
            !                          Field3D     = Me%EulerModel(em)%OverLayV,  &
            !                          STAT        = STAT_CALL)
            !if (STAT_CALL /= SUCCESS_) stop 'OverLayProcess - ModuleLagrangianGlobal - ERR02' 

            Me%EulerModel(em)%OverLay%VelUFinal = 0.
            Me%EulerModel(em)%OverLay%VelVFinal = 0.

            do k = WorkSizeKLB, WorkSizeKUB
            do j = WorkSizeJLB, WorkSizeJUB
            do i = WorkSizeILB, WorkSizeIUB

                Me%EulerModel(em)%OverLay%VelUFinal(i, j, k) = Me%EulerModel(em)%OverLayU   (i, j  , k)  +   &
                                                               Me%EulerModel(em)%Velocity_U (i, j  , k)

                Me%EulerModel(em)%OverLay%VelVFinal(i, j, k) = Me%EulerModel(em)%OverLayV   (i  , j, k)  +   &
                                                               Me%EulerModel(em)%Velocity_V (i  , j, k)
            enddo
            enddo
            enddo

            call UngetAssimilation (Me%EulerModel(em)%ObjAssimilation, Me%EulerModel(em)%OverLayU, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OverLayProcess - ModuleLagrangianGlobal - ERR03' 

            call UngetAssimilation (Me%EulerModel(em)%ObjAssimilation, Me%EulerModel(em)%OverLayV, &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OverLayProcess - ModuleLagrangianGlobal - ERR04' 

        enddo


    end subroutine OverLayProcess

    !--------------------------------------------------------------------------

    subroutine ParticleEmission ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin

        !Begin-----------------------------------------------------------------

        if (Me%State%KillPartInsideBox) then
            call KillParticInsideBoxes ()

            call PurgeParticles        ()
        endif

        call ActualizeOriginDefault


        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

iON:        if (CurrentOrigin%EmissionON) then

                !Constructs the Temporal emission 
                select case (CurrentOrigin%EmissionTemporal)

                case (Continuous_)


                    if (Me%Now >= CurrentOrigin%NextEmission .and.    &
                        Me%Now <= CurrentOrigin%StopEmission) then

                        select case (CurrentOrigin%EmissionSpatial)

                        case (Point_)

                            call EmissionPoint      (CurrentOrigin)

                        case (Box_)

                            call EmissionBox        (CurrentOrigin)

                        case (Poly_)

                            call EmissionPoly       (CurrentOrigin)                            

                        end select

                        CurrentOrigin%NextEmission  = CurrentOrigin%NextEmission +           &
                                                      CurrentOrigin%DT_EMIT

                    endif


                case (Instantaneous_)

                    if (.not. CurrentOrigin%Old) then

                        if (Me%Now >= CurrentOrigin%InstantEmission .and. CurrentOrigin%OnlyOnceEmit) then

                            !Realizes only one emission
                            select case (CurrentOrigin%EmissionSpatial)

                            case (Box_)

                                call EmissionBox           (CurrentOrigin)
                                
                            case (Poly_)

                                call EmissionPoly          (CurrentOrigin)       

                            case (Point_)

                                call EmissionPoint         (CurrentOrigin)

                            case (Accident_)

                                If ((CurrentOrigin%ObjHNS/= 0) .AND. &
                                    (CurrentOrigin%HNSInitialState .EQ. WaterColumn_Droplet_) &
                                   )  then
                                   ! if particles are emitted below the surface, they will not have initial area
                                    call EmissionPoint         (CurrentOrigin)
                                else
                                call EmissionAccident      (CurrentOrigin)
                                endif
    
                            end select

                            CurrentOrigin%OnlyOnceEmit = .false.

                        endif

                    endif

                end select

            endif iON

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        

    end subroutine ParticleEmission

   !--------------------------------------------------------------------------

    subroutine FillGridThickness ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, em, ig

        !Begin-----------------------------------------------------------------
        
                !Fills Grid concentration
        if (Me%Now > Me%ExternalVar%LastConcCompute) then
            
            call FillGridConcentration 

d1:         do em = 1, Me%EulerModelNumber

                ILB = Me%EulerModel(em)%WorkSize%ILB
                JLB = Me%EulerModel(em)%WorkSize%JLB
                IUB = Me%EulerModel(em)%WorkSize%IUB
                JUB = Me%EulerModel(em)%WorkSize%JUB
                KUB = Me%EulerModel(em)%WorkSize%KUB

d2:             do ig = 1, Me%NGroups 
d3:             do j  = JLB, JUB
d4:             do i  = ILB, IUB
                                 
i1:                 if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 

                    !Calculates the GridThickness
                        Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i, j) =            &
                            Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, KUB, ig) /         &
                            Me%EulerModel(em)%GridCellArea(i, j)

                    endif i1

                enddo d4
                enddo d3
                enddo d2

            enddo d1

        endif
        

    end subroutine FillGridThickness

    !--------------------------------------------------------------------------

   subroutine OilGridPresence (CurrentOrigin)
    
        !Arguments-------------------------------------------------------------
        type(T_Origin), pointer                     :: CurrentOrigin

        !Local-----------------------------------------------------------------
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, em, ig

        !Begin-----------------------------------------------------------------
                
        if (Me%State%Oil) then

            !em = CurrentOrigin%Position%ModelID
d1:         do em = 1, Me%EulerModelNumber                         
                ig = CurrentOrigin%GroupID

                ILB = Me%EulerModel(em)%WorkSize%ILB
                JLB = Me%EulerModel(em)%WorkSize%JLB
                IUB = Me%EulerModel(em)%WorkSize%IUB
                JUB = Me%EulerModel(em)%WorkSize%JUB
                KUB = Me%EulerModel(em)%WorkSize%KUB
                
                do j  = JLB, JUB
                do i  = ILB, IUB
                
                    
                    if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then
                    
                        if(Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime(i, j) == 0.)then

                            if(Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration3D(i, j, KUB) > 0.)then

                                Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime(i, j) =  Me%Now - CurrentOrigin%StartEmission
                                
                            end if
                        endif
                    endif

                enddo
                enddo

            enddo d1

        endif


    end subroutine OilGridPresence

    !--------------------------------------------------------------------------
    subroutine OilGridConcentration (CurrentOrigin, WaveHeight, WaterDensity)

        !Arguments-------------------------------------------------------------
        type(T_Origin), pointer                     :: CurrentOrigin
        real                                        :: WaveHeight
        real                                        :: WaterDensity

        !Local-----------------------------------------------------------------
        real                                        :: WaveHeightAux
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i, j, em, ig

        !Begin-----------------------------------------------------------------
                !Fills Grid concentration
i1:     if (Me%State%Oil) then

            !em = CurrentOrigin%Position%ModelID
d1:         do em = 1, Me%EulerModelNumber                         
                ig = CurrentOrigin%GroupID

                ILB = Me%EulerModel(em)%WorkSize%ILB
                JLB = Me%EulerModel(em)%WorkSize%JLB
                IUB = Me%EulerModel(em)%WorkSize%IUB
                JUB = Me%EulerModel(em)%WorkSize%JUB
                KUB = Me%EulerModel(em)%WorkSize%KUB

d3:             do j  = JLB, JUB
d4:             do i  = ILB, IUB
                         
i2:                 if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 

                        WaveHeightAux = max(WaveHeight, 0.01)

                        !Calculates the Concentration
                        
i3:                     if (Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i, j) == 0.) then
                            Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration(i, j) = 0.
                        else                           
                            ! CurrentOrigin%OilGridConcentration = (Specific_MSurface + Specific_MDispersed) / (MixingDepth * WaterDensity)
                            Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration(i, j) =                     &
                                          1.e6 * ((Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i, j) * &
                                          Me%ExternalVar%OilDensity) + & 
                                          (Me%ExternalVar%MDispersed / max(AllmostZero,Me%ExternalVar%AreaTotal))) / & 
                                          (1.5 * WaveHeightAux * WaterDensity)                      
                        endif i3
                    endif i2

                enddo d4
                enddo d3

            enddo d1

        endif i1


    end subroutine OilGridConcentration

    !--------------------------------------------------------------------------
    
    subroutine OilGridConcentration3D (CurrentOrigin)

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, STAT_CALL, em, ig
        logical                                     :: HaveDomain

        !Begin-----------------------------------------------------------------
        
        !em = CurrentOrigin%Position%ModelID
d1:     do em = 1, Me%EulerModelNumber                         
        
            ig = CurrentOrigin%GroupID
            
            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB


            !Adds the mass of all particles in the every cell
            call SetMatrixValue(Me%EulerModel(em)%MassSumParticCell, Me%EulerModel(em)%Size, 0., &
                                Me%EulerModel(em)%Waterpoints3D)
            
            
            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                if (em == CurrentPartic%Position%ModelID) then
                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                    k = CurrentPartic%Position%k
                    
                    HaveDomain = .true.
                else
                
                    HaveDomain = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid,     &
                                                   CurrentPartic%Position%CoordX,           &
                                                   CurrentPartic%Position%CoordY,           &
                                                   Referential= GridCoord_,                 &
                                                   STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'OilGridConcentration3D - ModuleLagrangianGlobal - ERR20'
                
                    if (HaveDomain) then

                        call GetXYCellZ(HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                        XPoint           = CurrentPartic%Position%CoordX,      &
                                        YPoint           = CurrentPartic%Position%CoordY,      &
                                        I                = I,                                  &
                                        J                = J,                                  &
                                        Referential      = GridCoord_,                         &
                                        STAT             = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OilGridConcentration3D - ModuleLagrangianGlobal- ERR30'  
                        
                        k = GetLayer4Level(Me%EulerModel(em)%ObjGeometry, i, j,         &
                                           CurrentPartic%Position%Z, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OilGridConcentration3D - ModuleLagrangianGlobal- ERR40'  

                    endif
                                        
                endif                
                
                if (HaveDomain) then

                    Me%EulerModel(em)%MassSumParticCell(i, j, k) = Me%EulerModel(em)%MassSumParticCell(i, j, k) + &
                                                                   CurrentPartic%OilMass

                endif                    

                CurrentPartic => CurrentPartic%Next
            enddo

            !Calculates the OilGridConcentration3D
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
               if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 
                     Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration3D(i, j,k) =     &
                     Me%EulerModel(em)%MassSumParticCell(i,j,k) / Me%EulerModel(em)%VolumeZ(i,j,k)  
                end if
            enddo
            enddo
            enddo
        enddo d1

    end subroutine OilGridConcentration3D

  !--------------------------------------------------------------------------
    
    subroutine OilGridDissolution3D (CurrentOrigin)

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, STAT_CALL, em, ig
        logical                                     :: HaveDomain
        
        !Begin-----------------------------------------------------------------
        
        !em = CurrentOrigin%Position%ModelID
d1:     do em = 1, Me%EulerModelNumber                         
        
            ig = CurrentOrigin%GroupID
            
            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB


            !Adds the mass of all particles in the every cell
            call SetMatrixValue(Me%EulerModel(em)%MassDissolvedSumParticCell, Me%EulerModel(em)%Size, 0.,  &
                                Me%EulerModel(em)%Waterpoints3D) 
            
            
            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                if (em == CurrentPartic%Position%ModelID) then
                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                    k = CurrentPartic%Position%k
                    
                    HaveDomain = .true.
                else
                
                    HaveDomain = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid,     &
                                                   CurrentPartic%Position%CoordX,           &
                                                   CurrentPartic%Position%CoordY,           &
                                                   Referential= GridCoord_,                 &
                                                   STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'OilGridDissolution3D - ModuleLagrangianGlobal - ERR20'
                
                    if (HaveDomain) then

                        call GetXYCellZ(HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                        XPoint           = CurrentPartic%Position%CoordX,      &
                                        YPoint           = CurrentPartic%Position%CoordY,      &
                                        I                = I,                                  &
                                        J                = J,                                  &
                                        Referential      = GridCoord_,                         &
                                        STAT             = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OilGridDissolution3D - ModuleLagrangianGlobal- ERR30'  
                        
                        k = GetLayer4Level(Me%EulerModel(em)%ObjGeometry, i, j,         &
                                           CurrentPartic%Position%Z, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OilGridDissolution3D - ModuleLagrangianGlobal- ERR40'  

                    endif
                                        
                endif                
                
                if (HaveDomain) then
                    Me%EulerModel(em)%MassDissolvedSumParticCell(i, j, k) = &
                                                       Me%EulerModel(em)%MassDissolvedSumParticCell(i, j, k) + & 
                                                       CurrentPartic%OilDissolvedMass
                endif
                
                CurrentPartic => CurrentPartic%Next
            enddo
            
            !Calculates the OilGridDissolution3D
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB               
               if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 
                    Me%EulerModel(em)%OilSpreading(ig)%OilGridDissolution3D(i,j,k) =                &
                    Me%EulerModel(em)%MassDissolvedSumParticCell(i,j,k) /     &
                    Me%EulerModel(em)%VolumeZ(i,j,k) 
                end if
            enddo
            enddo
            enddo


        enddo d1

    end subroutine OilGridDissolution3D

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    
    subroutine HNSGridConc3D (CurrentOrigin)

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, em, ig, STAT_CALL
        logical                                     :: HaveDomain
        !Begin-----------------------------------------------------------------
        
        !em = CurrentOrigin%Position%ModelID
d1:     do em = 1, Me%EulerModelNumber                         
        
            ig = CurrentOrigin%GroupID

            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB

    !        allocate (Droplets_MassSumParticCell (ILB:IUB,                &
    !                                     JLB:JUB,                &
    !                                     KLB:KUB),               &
    !                                     STAT = STAT_CALL)
    !        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR02'
    !
    !        allocate (Dissolved_MassSumParticCell (ILB:IUB,                &
    !                                     JLB:JUB,                &
    !                                     KLB:KUB),               &
    !                                     STAT = STAT_CALL)
    !        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR03'
    !
    !        allocate (SuspendedParticulates_MassSumParticCell (ILB:IUB,                &
    !                                     JLB:JUB,                &
    !                                     KLB:KUB),               &
    !                                     STAT = STAT_CALL)
    !        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR04'

            Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D(:,:,:)            = 0.
            Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(:,:,:)             = 0.
            Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(:,:,:) = 0.
            Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D(:,:,:)            = 0.
            Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(:,:,:)             = 0.
            Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D(:,:,:) = 0.
            
    !        Dissolved_MassSumParticCell             = 0.
    !        Droplets_MassSumParticCell              = 0.
    !        SuspendedParticulates_MassSumParticCell  = 0.
            
            !Adds the mass of all particles in the every cell
            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                if (em == CurrentPartic%Position%ModelID) then
                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                    k = CurrentPartic%Position%k
                    
                    HaveDomain = .true.
                else
                
                    HaveDomain = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid,     &
                                                   CurrentPartic%Position%CoordX,           &
                                                   CurrentPartic%Position%CoordY,           &
                                                   Referential= GridCoord_,                 &
                                                   STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal - ERR20'
                
                    if (HaveDomain) then

                        call GetXYCellZ(HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                        XPoint           = CurrentPartic%Position%CoordX,      &
                                        YPoint           = CurrentPartic%Position%CoordY,      &
                                        I                = I,                                  &
                                        J                = J,                                  &
                                        Referential      = GridCoord_,                         &
                                        STAT             = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR30'  
                        
                        k = GetLayer4Level(Me%EulerModel(em)%ObjGeometry, i, j,         &
                                           CurrentPartic%Position%Z, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR40'  

                    endif
                                        
                endif                
                
                if (HaveDomain) then
                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Dissolved_) then
                        Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D(i,j,k) = &
                        Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D (i,j,k)+ CurrentPartic%HNSMass
        !                Dissolved_MassSumParticCell(i, j, k) = Dissolved_MassSumParticCell(i, j, k) +              & 
        !                                             CurrentPartic%HNSMass
                        
                    end if                                             
                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Droplet_) then
                        Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(i,j,k) =  & 
                        Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(i,j,k) + CurrentPartic%HNSMass
        !                Droplets_MassSumParticCell(i, j, k) = Droplets_MassSumParticCell(i, j, k) +              & 
        !                                             CurrentPartic%HNSMass
                    end if                                             
                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Sedimented_) then
                        Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(i,j,k) =  &
                        Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(i,j,k) + CurrentPartic%HNSMass
        !                SuspendedParticulates_MassSumParticCell(i, j, k) =      &
        !                                        SuspendedParticulates_MassSumParticCell(i, j, k) + CurrentPartic%HNSMass
                    end if                                             
                endif
                CurrentPartic => CurrentPartic%Next
            enddo

    !       Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D = Dissolved_MassSumParticCell
    !       Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D = Droplets_MassSumParticCell
    !       Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D = SuspendedParticulates_MassSumParticCell

            !Calculates the HNS Grid Concentration (3D)
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
               if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 
                     if (Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D(i,j,k) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D (i, j,k) = 1.E6 *  &
                         Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D(i,j,k) / (Me%EulerModel(em)%VolumeZ(i,j,k))  
                     else
                         Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D (i, j,k) = 0.0
                     endif
                     if (Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(i,j,k) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(i,j,k) = 1.E6 *  &
                         Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D(i,j,k) / (Me%EulerModel(em)%VolumeZ(i,j,k))
                     else
                         Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(i,j,k) = 0.0
                     endif
                     if (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(i,j,k) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D (i, j,k) = 1.E6 *  &
                         Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D(i,j,k) / (Me%EulerModel(em)%VolumeZ(i,j,k))
                     else
                         Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D (i, j,k) = 0.0
                     endif
                end if
            enddo
            enddo
            enddo

    !        deallocate (Dissolved_MassSumParticCell, STAT = STAT_CALL)
    !        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR21'
    !        deallocate (Droplets_MassSumParticCell, STAT = STAT_CALL)
    !        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR22'
    !        deallocate (SuspendedParticulates_MassSumParticCell, STAT = STAT_CALL)
    !        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc3D - ModuleLagrangianGlobal- ERR23'

        enddo d1
        
    end subroutine HNSGridConc3D

  !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    
    subroutine HNSGridConc2D (CurrentOrigin)

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        real, dimension(:,:), pointer               :: Air_MassSumParticCell, Droplets_MassSumParticCell
        real, dimension(:,:), pointer               :: SurfaceFloating_MassSumParticCell, DepositedParticulates_MassSumParticCell
        real, dimension(:,:), pointer               :: Dissolved_MassSumParticCell, SuspendedParticulates_MassSumParticCell
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, STAT_CALL, em, ig
        real                                        :: IntegratedVolume
        logical                                     :: HaveDomain

        !Begin-----------------------------------------------------------------
        
        !em = CurrentOrigin%Position%ModelID
d1:     do em = 1, Me%EulerModelNumber                         
        
            ig = CurrentOrigin%GroupID

            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB

            allocate (Air_MassSumParticCell (ILB:IUB,                &
                                         JLB:JUB),                &
                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR01'

            allocate (SurfaceFloating_MassSumParticCell (ILB:IUB,                &
                                         JLB:JUB),                &
                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR02'

            allocate (Droplets_MassSumParticCell (ILB:IUB,                &
                                         JLB:JUB),                &
                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR03'

            allocate (Dissolved_MassSumParticCell (ILB:IUB,                &
                                         JLB:JUB),                &
                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR04'

            allocate (SuspendedParticulates_MassSumParticCell (ILB:IUB,                &
                                         JLB:JUB),                &
                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR05'

            allocate (DepositedParticulates_MassSumParticCell (ILB:IUB,                &
                                         JLB:JUB),                &
                                         STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR06'

            Air_MassSumParticCell                   = 0.
            SurfaceFloating_MassSumParticCell       = 0.
            Dissolved_MassSumParticCell             = 0.
            Droplets_MassSumParticCell              = 0.
            SuspendedParticulates_MassSumParticCell = 0.
            DepositedParticulates_MassSumParticCell = 0.
                   

            !Adds the mass of all particles in the every cell
            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                if (em == CurrentPartic%Position%ModelID) then
                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                   
                    HaveDomain = .true.
                else
                
                    HaveDomain = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid,     &
                                                   CurrentPartic%Position%CoordX,           &
                                                   CurrentPartic%Position%CoordY,           &
                                                   Referential= GridCoord_,                 &
                                                   STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal - ERR07'
                
                    if (HaveDomain) then

                        call GetXYCellZ(HorizontalGridID = Me%EulerModel(em)%ObjHorizontalGrid,&
                                        XPoint           = CurrentPartic%Position%CoordX,      &
                                        YPoint           = CurrentPartic%Position%CoordY,      &
                                        I                = I,                                  &
                                        J                = J,                                  &
                                        Referential      = GridCoord_,                         &
                                        STAT             = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR08'  
                        
                    endif
                                        
                endif                
                
                if (HaveDomain) then

                    if ( (CurrentPartic%HNSParticleState .EQ. Air_Evaporated_) .OR. &
                         (CurrentPartic%HNSParticleState .EQ. Air_Volatilized_) ) then
                        Air_MassSumParticCell(i, j) = Air_MassSumParticCell(i, j) +              & 
                                                     CurrentPartic%HNSMass
                    end if                                             

                    if (CurrentPartic%HNSParticleState .EQ. Surface_) then
                        SurfaceFloating_MassSumParticCell(i, j) = SurfaceFloating_MassSumParticCell(i, j) +              & 
                                                     CurrentPartic%HNSMass
                    end if                                             

                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Dissolved_) then
                        Dissolved_MassSumParticCell(i, j) = Dissolved_MassSumParticCell(i, j) +              & 
                                                     CurrentPartic%HNSMass
                    end if                                             
                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Droplet_) then
                        Droplets_MassSumParticCell(i, j) = Droplets_MassSumParticCell(i, j) +              & 
                                                     CurrentPartic%HNSMass
                    end if                                             
                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Sedimented_) then
                        SuspendedParticulates_MassSumParticCell(i, j) = SuspendedParticulates_MassSumParticCell(i, j) +  & 
                                                     CurrentPartic%HNSMass
                    end if                                             
                    if (CurrentPartic%HNSParticleState .EQ. Bottom_Deposited_) then
                        DepositedParticulates_MassSumParticCell(i, j) = DepositedParticulates_MassSumParticCell(i, j) +  & 
                                                     CurrentPartic%HNSMass
                    end if                                             

                endif
                
                CurrentPartic => CurrentPartic%Next
            enddo

           Me%EulerModel(em)%HNS(ig)%GridAirMass2D                              = Air_MassSumParticCell
           Me%EulerModel(em)%HNS(ig)%GridSurfaceFloatingMass2D                  = SurfaceFloating_MassSumParticCell
           Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D                        = Dissolved_MassSumParticCell
           Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D                         = Droplets_MassSumParticCell
           Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D             = SuspendedParticulates_MassSumParticCell
           Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMass2D             = DepositedParticulates_MassSumParticCell

            !Calculates the HNS Grid Concentration (2D)
            do j = JLB, JUB
            do i = ILB, IUB
                IntegratedVolume = 0.
                do k = KLB, KUB
                    if (Me%EulerModel(em)%VolumeZ(i,j,k) > 0.0) then
                        IntegratedVolume = IntegratedVolume + Me%EulerModel(em)%VolumeZ(i,j,k)
                    endif
                enddo

               if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 
                     if (Air_MassSumParticCell(i, j) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridAirConc2D (i, j) = 1.E6 *  &
                         Air_MassSumParticCell(i,j) / (Me%EulerModel(em)%GridCellArea (i, j) * 2.)  
                         ! the value of 2(m) above is the surface layer where there would be exposure 
                         ! to humans and wildlife
                     else
                         Me%EulerModel(em)%HNS(ig)%GridAirConc2D (i, j) = 0.0
                     endif
                     if (Dissolved_MassSumParticCell(i, j) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D (i, j) = 1.E6 *  &
                         Dissolved_MassSumParticCell(i,j) / IntegratedVolume
                     else
                         Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D (i, j) = 0.0
                     endif
                     if (Droplets_MassSumParticCell(i, j) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D (i, j) = 1.E6 *  &
                         Droplets_MassSumParticCell(i,j) / IntegratedVolume
                     else
                         Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D (i, j) = 0.0
                     endif
                     if (SuspendedParticulates_MassSumParticCell(i, j) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D (i, j) = 1.E6 *  &
                         SuspendedParticulates_MassSumParticCell(i,j) / IntegratedVolume    
                     else
                         Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D (i, j) = 0.0
                     endif
                     if (DepositedParticulates_MassSumParticCell(i, j) > 0.) then
                         Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D (i, j) = 1.E6 *  &
                         DepositedParticulates_MassSumParticCell(i,j) / Me%EulerModel(em)%GridCellArea (i, j)    
                     else
                         Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D (i, j) = 0.0
                     endif
                end if

            enddo
            enddo

            deallocate (Air_MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR20'
            nullify(Air_MassSumParticCell)
            deallocate (SurfaceFloating_MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR21'
            nullify(SurfaceFloating_MassSumParticCell)
            deallocate (Dissolved_MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR22'
            nullify(Dissolved_MassSumParticCell)
            deallocate (Droplets_MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR23'
            nullify(Droplets_MassSumParticCell)
            deallocate (SuspendedParticulates_MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR24'
            nullify(SuspendedParticulates_MassSumParticCell)
            deallocate (DepositedParticulates_MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridConc2D - ModuleLagrangianGlobal- ERR25'
            nullify(DepositedParticulates_MassSumParticCell)
        
        enddo d1

    end subroutine HNSGridConc2D

    !--------------------------------------------------------------------------
    
    subroutine HNSGridMaxConc2D (CurrentOrigin)

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        real, dimension(:, :), pointer           :: MaxDissolvedMassSumParticCell
        real, dimension(:, :), pointer           :: MaxDropletsMassSumParticCell
        real, dimension(:, :), pointer           :: MaxSuspendedParticulateMassSumParticCell
        integer, dimension(:, :), pointer           :: KMax_Dissolved,KMax_Droplets 
        integer, dimension(:, :), pointer           :: KMax_SuspendedParticulates
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, STAT_CALL, em, ig

        !Begin-----------------------------------------------------------------
        
        !em = CurrentOrigin%Position%ModelID

d1:     do em = 1, Me%EulerModelNumber                         

        
            ig = CurrentOrigin%GroupID

            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB

            allocate (MaxDissolvedMassSumParticCell (ILB:IUB,             &
                                            JLB:JUB),            &
                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR01'

            allocate (MaxDropletsMassSumParticCell (ILB:IUB,             &
                                            JLB:JUB),            &
                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR02'

            allocate (MaxSuspendedParticulateMassSumParticCell (ILB:IUB,             &
                                            JLB:JUB),            &
                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR03'

            allocate (KMax_Dissolved(ILB:IUB,             &
                                            JLB:JUB),             &
                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR04'

            allocate (KMax_Droplets(ILB:IUB,             &
                                            JLB:JUB),             &
                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR05'

            allocate (KMax_SuspendedParticulates(ILB:IUB,             &
                                            JLB:JUB),             &
                                            STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR06'

                  
            MaxDissolvedMassSumParticCell(:,:) = 0.
            MaxDropletsMassSumParticCell(:,:) = 0.
            MaxSuspendedParticulateMassSumParticCell(:,:) = 0.
            KMax_Dissolved(:,:) = 0.
            KMax_Droplets(:,:) = 0.
            KMax_SuspendedParticulates(:,:) = 0.
            
            Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(:,:) = 0.
            Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(:,:) = 0.
            Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(:,:) = 0.

            !!Calculates the HNS Grid Vertical Max Concentration (2D)
            do j = JLB, JUB
            do i = ILB, IUB
                do k = KLB, KUB
                    if (Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(i,j) <           &
                        Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D(i, j, k)) then
                        Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(i,j) =           &
                            Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D(i, j, k)
                    endif
                    if (Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(i,j) <            &
                        Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(i, j, k)) then
                        Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(i,j) =            &
                            Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D(i, j, k)
                    endif
                    if (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(i,j) < &
                        Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D(i, j, k)) then
                        Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(i,j) = &
                            Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D(i, j, k)
                    endif
                enddo
            enddo
            enddo

            
            
            !do j = JLB, JUB
            !do i = ILB, IUB
            !    do k = KLB, KUB
            !        if (MaxDissolvedMassSumParticCell(i, j) < Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D(i, j)) then
            !            MaxDissolvedMassSumParticCell(i, j) = Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D(i, j)
            !            KMax_Dissolved(i,j) = k
            !        end if
            !        if (MaxDropletsMassSumParticCell(i, j) < Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D(i, j)) then
            !            MaxDropletsMassSumParticCell(i, j) = Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D(i, j)
            !            KMax_Droplets(i,j) = k
            !        end if
            !        if (MaxSuspendedParticulateMassSumParticCell(i, j) <    &
            !            Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D(i, j)) then
            !            MaxSuspendedParticulateMassSumParticCell(i, j) =                &
            !                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D(i, j)
            !            KMax_SuspendedParticulates(i,j) = k
            !        end if
            !    enddo
            !enddo
            !enddo
            !
            !!Calculates the HNS Grid Max Concentration (2D)
            !do j = JLB, JUB
            !do i = ILB, IUB
            !       if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 
            !            if (MaxDissolvedMassSumParticCell(i, j) > 0. .AND. Me%EulerModel(em)%VolumeZ(i,j,KMax_Dissolved(i,j)) > 0.0) then
            !                 Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(i,j) = 1.E6 * &
            !                 MaxDissolvedMassSumParticCell(i, j) / Me%EulerModel(em)%VolumeZ(i,j,KMax_Dissolved(i,j))  
            !            else
            !                 Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D(i,j) = 0.0
            !            endif
            !            if (MaxDropletsMassSumParticCell(i, j) > 0.) then
            !                 Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(i,j) = 1.E6 * &
            !                 MaxDropletsMassSumParticCell(i, j) / Me%EulerModel(em)%VolumeZ(i,j,KMax_Droplets(i,j))  
            !            else
            !                 Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D(i,j) = 0.0
            !            endif
            !            if (MaxSuspendedParticulateMassSumParticCell(i, j) > 0. .AND. &
            !                Me%EulerModel(em)%VolumeZ(i,j,KMax_SuspendedParticulates(i,j)) > 0.0) then
            !                 Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(i,j) = 1.E6 * &
            !                 MaxSuspendedParticulateMassSumParticCell(i, j) /           &
            !                 Me%EulerModel(em)%VolumeZ(i,j,KMax_SuspendedParticulates(i,j))  
            !            else
            !                Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D(i,j) = 0.0
            !            endif
            !       end if
            !enddo
            !enddo

            deallocate (MaxDissolvedMassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR10'
            nullify(MaxDissolvedMassSumParticCell)

            deallocate (MaxDropletsMassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR11'
            nullify(MaxDropletsMassSumParticCell)

            deallocate (MaxSuspendedParticulateMassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR12'
            nullify(MaxSuspendedParticulateMassSumParticCell)

            deallocate (KMax_Dissolved, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR13'
            nullify(KMax_Dissolved)

            deallocate (KMax_Droplets, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR14'
            nullify(KMax_Droplets)

            deallocate (KMax_SuspendedParticulates, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HNSGridMaxConc2D - ModuleLagrangianGlobal- ERR15'
            nullify(KMax_SuspendedParticulates)

        enddo d1

    end subroutine HNSGridMaxConc2D

  !--------------------------------------------------------------------------

     subroutine ParticleDensity () 
    
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin),   pointer                  :: CurrentOrigin
        type (T_Partic),   pointer                  :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: TemperatureID, SalinityID, emp, iProp
        real                                        :: T, S, Depth

        !Begin-----------------------------------------------------------------

        nullify(CurrentOrigin)
        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
                    
id:         if (CurrentOrigin%State%FarFieldBuoyancy) then

                iProp = 0
                
                nullify(CurrentProperty)

                !Finds Temperature and Salinity
                CurrentProperty => CurrentOrigin%FirstProperty

                do while (associated(CurrentProperty))

                    iProp = iProp + 1

                    select case (CurrentProperty%ID)
                        case (Temperature_)
                            TemperatureID = iProp
                                                            
                        case (Salinity_   )
                            SalinityID    = iProp
                    end select

                    CurrentProperty => CurrentProperty%Next

                enddo
                
                nullify(CurrentProperty)
                
                nullify(CurrentPartic)
      

                if (associated(CurrentOrigin%FirstPartic)) then
                    CurrentPartic => CurrentOrigin%FirstPartic
                else
                    nullify(CurrentPartic)                    
                endif
                
                do while (associated(CurrentPartic))
                    T = CurrentPartic%Concentration (TemperatureID)
                    S = CurrentPartic%Concentration (SalinityID   )
                    
                    if (CurrentOrigin%Movement%DensityMethod == UNESCOState_) then
                        CurrentPartic%SigmaDensity = SigmaUNESCO     (T, S)

                    elseif (CurrentOrigin%Movement%DensityMethod == LeendertseState_) then
                        CurrentPartic%SigmaDensity = SigmaLeendertse (T, S)

                    else 
                        write(*,*)'Invalid Density Method'
                        stop      'ParticleDensity - ModuleLagrangianGlobal - ERR10'
                    endif
                    
pc:                 if (CurrentOrigin%Movement%CorrecPress) then

                        emp   =   CurrentPartic%Position%ModelID
                        
                        Depth = - Me%EulerModel(emp)%ZCellCenter(CurrentPartic%Position%I, &
                                                                 CurrentPartic%Position%J, &
                                                                 CurrentPartic%Position%K)

                        if (CurrentOrigin%Movement%DensityMethod == UNESCOState_) then
                            CurrentPartic%SigmaDensity = SigmaUNESCOPressureCorrection (T, S, Depth,CurrentPartic%SigmaDensity)
               
                        elseif (CurrentOrigin%Movement%DensityMethod == LeendertseState_) then
                            write(*,*)'Invalid Density Method'
                            stop      'ParticleDensity - ModuleLagrangianGlobal - ERR20'

                        else 
                            write(*,*)'Invalid Density Method'
                            stop      'ParticleDensity - ModuleLagrangianGlobal - ERR30'
                        endif                   

                    endif pc                     
                    CurrentPartic => CurrentPartic%Next
                enddo
            endif id

            CurrentOrigin => CurrentOrigin%Next
        enddo CurrOr

        nullify(CurrentPartic)
        nullify(CurrentOrigin)
       
     
    end subroutine ParticleDensity
       
    !--------------------------------------------------------------------------

    subroutine ActualizesTauErosionGrid ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin),   pointer                  :: CurrentOrigin
        type (T_Partic),   pointer                  :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        real,   dimension(:,:,:), pointer           :: MassSedGrid, TauErosionGrid       
        integer                                     :: i, j, ILB, IUB, JLB, JUB, &
                                                       Sediment_ID, em, ig, emp
        logical                                     :: FoundSediment

        !Begin-----------------------------------------------------------------

d1:     do em = 1, Me%EulerModelNumber        

            Me%EulerModel(em)%Lag2Euler%TauErosionGrid(:, :, :) = 0.
            Me%EulerModel(em)%Lag2Euler%MassSedGrid   (:, :, :) = 0.

        enddo d1

d2:     do ig = 1, Me%NGroups 

            CurrentOrigin => Me%FirstOrigin
CurrOr:         do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif
    
                !Sediment Property 
                Sediment_ID      = 0
                FoundSediment = .false.
                CurrentProperty => CurrentOrigin%FirstProperty
                do while (associated(CurrentProperty) .and. .not. FoundSediment)
                    Sediment_ID = Sediment_ID + 1
                    if (CurrentProperty%ID == Sediment) FoundSediment = .true.
                    CurrentProperty => CurrentProperty%Next
                enddo

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i  = CurrentPartic%Position%I
                    j  = CurrentPartic%Position%J

                    emp = CurrentPartic%Position%ModelID

                    if (CurrentPartic%Deposited) then

                        Me%EulerModel(emp)%Lag2Euler%TauErosionGrid (i, j, ig) =     &
                            Me%EulerModel(emp)%Lag2Euler%TauErosionGrid (i, j, ig) + &
                            CurrentPartic%Mass(Sediment_ID) * CurrentPartic%TauErosion

                        Me%EulerModel(emp)%Lag2Euler%MassSedGrid(i, j, ig) =                                  &
                            Me%EulerModel(emp)%Lag2Euler%MassSedGrid(i, j, ig) + CurrentPartic%Mass(Sediment_ID) 

                    endif


                    CurrentPartic => CurrentPartic%Next
                enddo

                CurrentOrigin => CurrentOrigin%Next

            enddo CurrOr

            !Compute the probability of each tracer of being eroded
            !function of the Origin Erosion rate 
            CurrentOrigin => Me%FirstOrigin
CurrOr1:    do while (associated(CurrentOrigin))
    

                !Sediment Property 
                Sediment_ID      = 0
                FoundSediment = .false.
                CurrentProperty => CurrentOrigin%FirstProperty
                do while (associated(CurrentProperty) .and. .not. FoundSediment)
                    Sediment_ID = Sediment_ID + 1
                    if (CurrentProperty%ID == Sediment) FoundSediment = .true.
                    CurrentProperty => CurrentProperty%Next
                enddo

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J

                    emp= CurrentPartic%Position%ModelID

                    if (CurrentPartic%Deposited .and. Me%EulerModel(emp)%Lag2Euler%MassSedGrid(i, j, ig) > 1e-12) then
                    
                        CurrentPartic%ErosionRateProbability =                      &
                            min (1., CurrentOrigin%Deposition%ErosionRate *         &
                                     Me%DT_Partic              /                    &
                                    (Me%EulerModel(emp)%Lag2Euler%MassSedGrid(i, j, ig) / &
                                     Me%EulerModel(emp)%GridCellArea(i,j)))

                    else 
                        CurrentPartic%ErosionRateProbability = 0. 
                    endif

                    CurrentPartic => CurrentPartic%Next
                enddo

                CurrentOrigin => CurrentOrigin%Next

            enddo CurrOr1
            

        enddo d2

        
d3:     do em = 1, Me%EulerModelNumber
            
            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB

            MassSedGrid    => Me%EulerModel(em)%Lag2Euler%MassSedGrid
            TauErosionGrid => Me%EulerModel(em)%Lag2Euler%TauErosionGrid 


            do ig =   1, Me%nGroups
            do j  = JLB, JUB
            do i  = ILB, IUB
                
                if (MassSedGrid(i, j, ig) > 1e-12) then

                    TauErosionGrid (i, j, ig) = TauErosionGrid (i, j, ig) / MassSedGrid(i, j, ig)

                else

                    TauErosionGrid (i, j, ig) = 0.

                endif

            enddo
            enddo
            enddo

            nullify(MassSedGrid   )
            nullify(TauErosionGrid)

        enddo d3


    end subroutine ActualizesTauErosionGrid

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    subroutine ActualizesMassFilterGrid ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin),   pointer                  :: CurrentOrigin
        type (T_Partic),   pointer                  :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        real,   dimension(:,:,:), pointer           :: FiltrationRateX
        real                                        :: DTEulerian, AuxFilter
        integer                                     :: i, j, k, ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: FilterProp_ID, STAT_CALL, em, emp

        !Begin-----------------------------------------------------------------

i1:     if (Me%Now >= Me%NextFiltration) then

            !Begin-----------------------------------------------------------------
d1:         do em = 1, Me%EulerModelNumber

                ILB = Me%EulerModel(em)%WorkSize%ILB
                JLB = Me%EulerModel(em)%WorkSize%JLB
                IUB = Me%EulerModel(em)%WorkSize%IUB
                JUB = Me%EulerModel(em)%WorkSize%JUB
                KLB = Me%EulerModel(em)%WorkSize%KLB
                KUB = Me%EulerModel(em)%WorkSize%KUB

                Me%EulerModel(em)%RelativeMassFilter(:,:,:) = 0. 

                call GetFiltrationRate (Me%EulerModel(em)%ObjWaterProperties, FiltrationRateX,             &
                                        DTEulerian, Fecal_Coliforms_, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop "Lagrangian - ActualizesMassFilterGrid - ERR10"

                if (DTEulerian < Me%DT_Partic) then
                    stop "Lagrangian - ActualizesMassFilterGrid - ERR20"
                endif


                do k = KLB, KUB
                do j = JLB, JUB
                do i = ILB, IUB

                    if (Me%EulerModel(em)%Waterpoints3D(i, j, k) == WaterPoint .and.           &
                        FiltrationRateX(i, j, k) > 0.) then
                        ![ ] = [1/T] * [T] / [L3]
                        Me%EulerModel(em)%RelativeMassFilter(i,j,k) = FiltrationRateX(i, j, k) * &
                                                                  Me%DT_Partic               

                        if (Me%EulerModel(em)%RelativeMassFilter(i,j,k) > 1.)                   &
                            stop "Lagrangian - ActualizesMassFilterGrid - ERR30"
                    endif

                enddo
                enddo
                enddo

                call UnGetWaterProperties (Me%EulerModel(em)%ObjWaterProperties, FiltrationRateX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop "Lagrangian - ActualizesMassFilterGrid - ERR50"

            enddo d1

        endif i1

        !Every lagrangian time step (Me%DT_Partic) computes the mass removed by the eulerian filter feeders. 

            CurrentOrigin => Me%FirstOrigin
        
CurrOr:     do while (associated(CurrentOrigin))
                
                !Filter Property 
                FilterProp_ID      = 0
                CurrentProperty => CurrentOrigin%FirstProperty
                do while (associated(CurrentProperty))
                    FilterProp_ID = FilterProp_ID + 1
                    if (CurrentProperty%Filtration) then
                        if (CurrentProperty%ID /= Fecal_Coliforms_) then
                            write(*,*) "The filtration process in the lagrangian model is only ready for fecal coliforms"
                            stop "Lagrangian - ActualizesMassFilterGrid - ERR40"
                        endif
                        exit
                    endif

                    CurrentProperty => CurrentProperty%Next
                enddo

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                    k = CurrentPartic%Position%K

                    emp = CurrentPartic%Position%ModelID

                    if (Me%EulerModel(emp)%RelativeMassFilter(i,j,k) > 0.) then

                        AuxFilter = Me%EulerModel(emp)%RelativeMassFilter(i,j,k) * CurrentPartic%Mass(FilterProp_ID)

                        Me%EulerModel(emp)%MassFiltered(i, j, k) = Me%EulerModel(emp)%MassFiltered(i, j, k) + AuxFilter

                        CurrentPartic%Mass(FilterProp_ID) = CurrentPartic%Mass(FilterProp_ID) - AuxFilter
                    endif

                    CurrentPartic => CurrentPartic%Next
                enddo

                CurrentOrigin => CurrentOrigin%Next

            enddo CurrOr

i2:     if (Me%Now >= Me%NextFiltration) then

d2:         do em = 1, Me%EulerModelNumber

                call SetLagrangianSinksSources(Me%EulerModel(em)%ObjWaterProperties, Fecal_Coliforms_,     &
                                               Me%EulerModel(em)%MassFiltered, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop "Lagrangian - ActualizesMassFilterGrid - ERR60"

                Me%EulerModel(em)%MassFiltered      (:,:,:) = 0.                 

            enddo d2

            Me%NextFiltration = Me%NextFiltration + DTEulerian

        endif i2


    end subroutine ActualizesMassFilterGrid

    !--------------------------------------------------------------------------

    subroutine UpdateBeachedVolumes
    
    
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: i, j, em, emp, ig, ILB, IUB, JLB, JUB
        logical                                     :: InsideDomain
      

        do em = 1, Me%EulerModelNumber 

            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB
            
            do ig = 1, Me%nGroups
            
            do j = JLB, JUB
            do i = ILB, IUB

                Me%EulerModel(em)%Lag2Euler%GridBeachedVolumeByType(i,j,ig,:) = 0.
                
                Me%EulerModel(em)%Lag2Euler%PreviousGridBeachedVolume(i,j,ig) = & 
                        Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(i,j,ig)
                
                Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(i, j, ig) = 0.
                
                Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar(i, j, ig) = 1.
            
            enddo
            enddo 
            
            enddo
            
        end do
        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

           ig = CurrentOrigin%GroupID

IfBeaching: if (CurrentOrigin%Beaching) then
                    
                CurrentOrigin%VolTotBeached     = 0.
                CurrentOrigin%VolTotOilBeached  = 0.
                
                CurrentPartic => CurrentOrigin%FirstPartic
CurrPart:       do while (associated(CurrentPartic))
                   
                    ! since oil was weathered, oil type is updated
                    CurrentPartic%BeachingOilType = F_BeachingOilType(CurrentPartic%OilViscCin)

                    !Grid Cell of the particle
                    i     = CurrentPartic%Position%I
                    j     = CurrentPartic%Position%J
                                      
                    emp    = CurrentPartic%Position%ModelID
    
                    InsideDomain = .true.

                    if (CurrentPartic%Beached .AND. InsideDomain ) then
                                                                                              
                        Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, CurrentPartic%BeachingOilType) = &
                        Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, CurrentPartic%BeachingOilType) + &
                            CurrentPartic%Geometry%Volume   

                        Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) =                               &
                                        Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) +               &
                                        CurrentPartic%Geometry%Volume   

                        CurrentOrigin%VolTotBeached     = CurrentOrigin%VolTotBeached +         &
                                                          CurrentPartic%Geometry%Volume

                        CurrentOrigin%VolTotOilBeached  = CurrentOrigin%VolTotOilBeached +      &
                                                          CurrentPartic%Geometry%VolumeOil

                    end if

                    CurrentPartic => CurrentPartic%Next

                enddo CurrPart

            end if IfBeaching
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        
        ! finding the variation ratio on beached oil, due to weathering processes
        ! later this ratio is used to correct theorical removed oil
        
        do em = 1, Me%EulerModelNumber 
            !Shorten
            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB
            
            do ig = 1, Me%nGroups
                do j = JLB, JUB
                    do i = ILB, IUB
                        if (Me%EulerModel(em)%Lag2Euler%PreviousGridBeachedVolume(i,j,ig) > 0.) then
                            Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar(i,j,ig) =                     &
                                            Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(i,j,ig) /     &
                                            Me%EulerModel(em)%Lag2Euler%PreviousGridBeachedVolume(i,j,ig)
                        else
                            Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar(i,j,ig) = 1.
                        end if            
                    end do
                end do
            end do
        end do

    end subroutine UpdateBeachedVolumes

    !--------------------------------------------------------------------------

    subroutine VerifyParticleBeaching()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: i, j, k, emp, ig
        real                                        :: CellI, CellJ, CellK
        real                                        :: BalX, BalY
        real                                        :: Rand1
        logical                                     :: InsideDomain
        logical                                     :: FreshlyBeached = .False.
        real                                        :: SpecificHoldingCapacity
        type (T_PointF),    pointer                 :: Point        

        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

           ig = CurrentOrigin%GroupID

IfBeaching: if (CurrentOrigin%Beaching) then

                if (CurrentOrigin%AreaBeaching) then
                    allocate(Point)
                endif
                    
                CurrentPartic => CurrentOrigin%FirstPartic
CurrPart:       do while (associated(CurrentPartic))

                    CurrentPartic%BeachingOilType = F_BeachingOilType(CurrentPartic%OilViscCin)
                    
                    !Grid Cell of the particle
                    i     = CurrentPartic%Position%I
                    j     = CurrentPartic%Position%J
                    k     = CurrentPartic%Position%K
                    
                    emp    = CurrentPartic%Position%ModelID
                    
                    InsideDomain = .true.
                    
                    if (j <= Me%EulerModel(emp)%WorkSize%JLB + 1) InsideDomain = .false.
                    if (i <= Me%EulerModel(emp)%WorkSize%ILB + 1) InsideDomain = .false.
                    
                    if (j >= Me%EulerModel(emp)%WorkSize%JUB - 1) InsideDomain = .false.
                    if (i >= Me%EulerModel(emp)%WorkSize%IUB - 1) InsideDomain = .false.

                    !Cell Position
                    CellI = CurrentPartic%Position%CellI
                    CellJ = CurrentPartic%Position%CellJ
                    CellK = CurrentPartic%Position%CellK

                    !Fraction of the cell
                    BALX  = CellJ - int(CellJ)
                    BALY  = CellI - int(CellI)

                    FreshlyBeached = .false.
                    
IfParticNotBeached: if (.NOT. CurrentPartic%Beached .and. InsideDomain) then

                        if(CurrentOrigin%CoastlineBeaching)then

                            if(CurrentPartic%DistanceToCoast <= Me%EulerModel(emp)%BeachingLimit(i,j))then

                                call RANDOM_NUMBER(Rand1)
                                
                                if ((Me%EulerModel(emp)%BeachingProbability(i,j,k) .GT. Rand1) .OR.   &
                                    (Me%EulerModel(emp)%BeachingProbability(i,j,k) .EQ. 1)) then  
                                    CurrentPartic%Beached = ON
                                    FreshlyBeached = .true.
                                endif
                             endif
                             
                        elseif (CurrentOrigin%AreaBeaching) then

                            Point%X = CurrentPartic%Position%CoordX
                            Point%Y = CurrentPartic%Position%CoordY

                            if (IsVisible(Me%BeachArea, Point)) then

                                call RANDOM_NUMBER(Rand1)
                                
                                if ((Me%EulerModel(emp)%BeachingProbability(i,j,k) .GT. Rand1) .OR.   &
                                    (Me%EulerModel(emp)%BeachingProbability(i,j,k) .EQ. 1)) then  
                                    CurrentPartic%Beached = ON
                                    FreshlyBeached = .true.
                                endif
                                                                
                            endif
                            
                        else
                        
                            SpecificHoldingCapacity =  &
                                F_AverageBeachHoldingCapacity(CurrentPartic%Geometry%Volume,           &
                                    CurrentPartic%BeachingOilType,                                     &
                                    Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, 1), &
                                    Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, 2), &
                                    Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, 3), &
                                    Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig),          &
                                    Me%EulerModel(emp)%ShoreType(i,j),                                 &
                                    Me%EulerModel(emp)%HorizontalBeachHoldingCapacity(i,j))
                        
                            if (Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) + &
                                CurrentPartic%Geometry%Volume <= SpecificHoldingCapacity) then
                            
                                call RANDOM_NUMBER(Rand1)

                                if ((Me%EulerModel(emp)%OpenPoints3D(i, j+1, k).NE. OpenPoint)  .AND. &
                                   ((1-BALX) *  (Me%EulerModel(emp)%Grid%ParticXX(i, j+1) - &
                                    Me%EulerModel(emp)%Grid%ParticXX(i, j)) .LT. Me%EulerModel(emp)%BeachingLimit(i,j+1))) then

                                    if((Me%EulerModel(emp)%BeachingProbability(i,j+1,k) .GT. Rand1)    &
                                        .OR. (Me%EulerModel(emp)%BeachingProbability(i,j+1,k) .EQ. 1)) &  
                                       CurrentPartic%Beached = ON
                                       FreshlyBeached = .true.
               
                                elseif((Me%EulerModel(emp)%OpenPoints3D(i, j-1, k).NE. OpenPoint)  .AND.  &
                                       (BALX *  (Me%EulerModel(emp)%Grid%ParticXX(i, j+1) - &
                                        Me%EulerModel(emp)%Grid%ParticXX(i, j)).LT. Me%EulerModel(emp)%BeachingLimit(i,j-1))) then


                                    if((Me%EulerModel(emp)%BeachingProbability(i,j-1,k) .GT. Rand1)    &
                                        .OR. (Me%EulerModel(emp)%BeachingProbability(i,j-1,k) .EQ. 1)) &  
                                       CurrentPartic%Beached = ON
                                       FreshlyBeached = .true.
                 
                                elseif((Me%EulerModel(emp)%OpenPoints3D(i+1, j, k).NE. OpenPoint)  .AND. &
                                      ((1-BALY) *  (Me%EulerModel(emp)%Grid%ParticYY(i+1, j) - &
                                       Me%EulerModel(emp)%Grid%ParticYY(i, j)).LT. Me%EulerModel(emp)%BeachingLimit(i+1,j))) then

                                    if ((Me%EulerModel(emp)%BeachingProbability(i+1,j,k) .GT. Rand1) &
                                        .OR. (Me%EulerModel(emp)%BeachingProbability(i+1,j,k) .EQ. 1)) &  
                                       CurrentPartic%Beached = ON
                                       FreshlyBeached = .true.
                   
                                elseif((Me%EulerModel(emp)%OpenPoints3D(i-1, j, k).NE. OpenPoint)  .AND. &
                                      (BALY *  (Me%EulerModel(emp)%Grid%ParticYY(i+1, j) -            &
                                       Me%EulerModel(emp)%Grid%ParticYY(i, j)) .LT. Me%EulerModel(emp)%BeachingLimit(i-1,j))) then

                                    if((Me%EulerModel(emp)%BeachingProbability(i-1,j,k) .GT. Rand1)   &
                                        .OR. (Me%EulerModel(emp)%BeachingProbability(i-1,j,k) .EQ. 1)) &  
                                       CurrentPartic%Beached = ON
                                       FreshlyBeached = .true.

                                end if

                            endif
                        
                        endif 
                        
                    endif IfParticNotBeached

                    if (CurrentPartic%Beached) then
                        if (InsideDomain) then
                            if (FreshlyBeached) then
                                
                                CurrentPartic%MinDistanceToCoast = 0.0
                            
                                if(Me%EulerModel(emp)%Lag2Euler%GridBeachingTime(i, j, ig) == 0.)then
                                    Me%EulerModel(emp)%Lag2Euler%GridBeachingTime(i, j, ig) = Me%Now - CurrentOrigin%StartEmission
                                endif

                                Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, CurrentPartic%BeachingOilType) = &
                                Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, CurrentPartic%BeachingOilType) + &
                                    CurrentPartic%Geometry%Volume   
                                                      
                                Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) =               &
                                Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) +  CurrentPartic%Geometry%Volume   

                                CurrentOrigin%VolTotBeached     = CurrentOrigin%VolTotBeached +         &
                                                                  CurrentPartic%Geometry%Volume

                                CurrentOrigin%VolTotOilBeached  = CurrentOrigin%VolTotOilBeached +      &
                                                                  CurrentPartic%Geometry%VolumeOil
                            end if
                        end if
                    end if

                
                    CurrentPartic => CurrentPartic%Next

                enddo CurrPart
                
                if(CurrentOrigin%VolTotOilBeached > CurrentOrigin%MaxVolTotOilBeached)then
                    CurrentOrigin%MaxVolTotOilBeached = CurrentOrigin%VolTotOilBeached
                endif
                
               if (CurrentOrigin%AreaBeaching) then
                    deallocate(Point)
                endif
                                    

            end if IfBeaching
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine VerifyParticleBeaching


    !--------------------------------------------------------------------------

    subroutine UpdateRemovedVolumes()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, ILB, IUB, JLB, JUB,  em, ig
        real                                        :: TheoricBeachedVolAfterRemoval, GridVoltoRemove, GridVoltoRemoveFraction
        real                                        :: GridBeachedVolume, GridVolRemovedDiff, GridBeachedVolVar
        
DoEM:   do em =1, Me%EulerModelNumber

            !Shorten
            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB

            
Group:      do ig = 1, Me%nGroups

                Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval(:,:,ig) = 0.
                Me%EulerModel(em)%Lag2Euler%GridVoltoRemove(:, :, ig)             = 0.
                Me%EulerModel(em)%Lag2Euler%GridVoltoRemoveFraction(:, :, ig)     = 0.
!                Me%EulerModel(em)%GridVolRemovedDiff(:, :, ig)                   = 0.

                do j = JLB, JUB
                do i = ILB, IUB
                        
                    TheoricBeachedVolAfterRemoval = Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval(i,j, ig)
                    GridBeachedVolume             = Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(i, j, ig)
                    GridVoltoRemove               = Me%EulerModel(em)%Lag2Euler%GridVoltoRemove(i, j, ig)
                    GridVoltoRemoveFraction       = Me%EulerModel(em)%Lag2Euler%GridVoltoRemoveFraction(i, j, ig)
                    GridVolRemovedDiff            = Me%EulerModel(em)%Lag2Euler%GridVolRemovedDiff(i, j, ig)
                    GridBeachedVolVar             = Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar(i,j,ig)
                    
                    !next value is corrected with gridbeachedvolvar, since weathering processes also changed the 
                    ! beached oil volume
                    TheoricBeachedVolAfterRemoval = (GridBeachedVolume + (GridVolRemovedDiff * GridBeachedVolVar)) * &
                                                     exp(-Me%EulerModel(em)%RemovalRateCoef(i,j) * (Me%DT_Partic/86400.))
                    TheoricBeachedVolAfterRemoval = max(0.,  TheoricBeachedVolAfterRemoval)
                    GridVoltoRemove               = max(0.,GridBeachedVolume - TheoricBeachedVolAfterRemoval)
                    if (GridBeachedVolume > 0.) then
                        GridVoltoRemoveFraction       = GridVoltoRemove / GridBeachedVolume
                    end if
                    Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval(i,j, ig) = TheoricBeachedVolAfterRemoval
                    Me%EulerModel(em)%Lag2Euler%GridVoltoRemove(i, j, ig)              = GridVoltoRemove
                    Me%EulerModel(em)%Lag2Euler%GridVoltoRemoveFraction(i, j, ig)      = GridVoltoRemoveFraction                
                enddo
                enddo                        

            enddo Group
        enddo DoEM

    end subroutine UpdateRemovedVolumes

    !--------------------------------------------------------------------------

    subroutine VerifyBeachRemoval()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer    :: CurrentOrigin
        type (T_Partic), pointer    :: CurrentPartic
        integer                     :: i, j, KUB, em, emp, ig, IUB, ILB, JUB, JLB
        logical                     :: InsideDomain, FreshlyRemoved
        real                        :: TheoricBeachedVolAfterRemoval, GridVoltoRemove, GridVoltoRemoveFraction, Rand2
        real                        :: GridBeachedVolume, GridVolRemovedDiff
               
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

           ig = CurrentOrigin%GroupID

IfBeaching: if (CurrentOrigin%Beaching) then
                    
                CurrentPartic => CurrentOrigin%FirstPartic
CurrPart:       do while (associated(CurrentPartic))
                   
                    !Grid Cell of the particle
                    i     = CurrentPartic%Position%I
                    j     = CurrentPartic%Position%J
                                      
                    emp    = CurrentPartic%Position%ModelID
                    ILB   = Me%EulerModel(emp)%WorkSize%ILB
                    IUB   = Me%EulerModel(emp)%WorkSize%IUB
                    JLB   = Me%EulerModel(emp)%WorkSize%JLB
                    JUB   = Me%EulerModel(emp)%WorkSize%JUB
                    KUB   = Me%EulerModel(emp)%WorkSize%KUB

                    TheoricBeachedVolAfterRemoval = Me%EulerModel(emp)%Lag2Euler%TheoricBeachedVolAfterRemoval(i,j, ig)
                    GridBeachedVolume             = Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig)
                    GridVoltoRemove               = Me%EulerModel(emp)%Lag2Euler%GridVoltoRemove(i, j, ig)
                    GridVolRemovedDiff            = Me%EulerModel(emp)%Lag2Euler%GridVolRemovedDiff(i, j, ig)
                    GridVoltoRemoveFraction       = Me%EulerModel(emp)%Lag2Euler%GridVoltoRemoveFraction(i, j, ig)
                    
                    InsideDomain = .true.

                    if (j <= Me%EulerModel(emp)%WorkSize%JLB + 1) InsideDomain = .false.
                    if (i <= Me%EulerModel(emp)%WorkSize%ILB + 1) InsideDomain = .false.
                    
                    if (j >= Me%EulerModel(emp)%WorkSize%JUB - 1) InsideDomain = .false.
                    if (i >= Me%EulerModel(emp)%WorkSize%IUB - 1) InsideDomain = .false.

                    FreshlyRemoved = .false.

                    if (CurrentPartic%Beached .AND. InsideDomain) then
                                                                                              
                        call RANDOM_NUMBER(Rand2)

                            ! if tide is rising -> oil can be removed
                        if ( (Me%EulerModel(emp)%OldSurfaceDepth(i,j) .NE. null_real) .AND. &
                             (Me%EulerModel(emp)%SZZ(i, j, KUB) >=  Me%EulerModel(emp)%OldSurfaceDepth(i,j)) ) then
                            ! if random number  < volume fraction to be removed, particle will be "unbeached"
                            if (Rand2 < GridVoltoRemoveFraction) then
                                CurrentPartic%Beached = OFF                            
                                FreshlyRemoved = .true.
                            end if
                                                            
                        end if

                    end if
                    
                    if ((.NOT. CurrentPartic%Beached) .AND. InsideDomain) then
                        if (FreshlyRemoved) then
                            !Update volumes, subtracting unbeached particles
                            Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, CurrentPartic%BeachingOilType) =  &
                            Me%EulerModel(emp)%Lag2Euler%GridBeachedVolumeByType(i, j, ig, CurrentPartic%BeachingOilType) -  &
                                CurrentPartic%Geometry%Volume   

                            Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) =               &
                            Me%EulerModel(emp)%Lag2Euler%GridBeachedVolume(i, j, ig) -  CurrentPartic%Geometry%Volume   

                            CurrentOrigin%VolTotBeached     = CurrentOrigin%VolTotBeached -         &
                                                              CurrentPartic%Geometry%Volume

                            CurrentOrigin%VolTotOilBeached  = CurrentOrigin%VolTotOilBeached -      &
                                                              CurrentPartic%Geometry%VolumeOil

                        end if
                    end if

                    Me%EulerModel(emp)%OldSurfaceDepth(i,j)    =   Me%EulerModel(emp)%SZZ(i, j, KUB)

                    CurrentPartic => CurrentPartic%Next

                enddo CurrPart

            end if IfBeaching
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        
        
DoEM:   do em =1, Me%EulerModelNumber         

            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB

Group:      do ig = 1, Me%nGroups
                do j = JLB, JUB
                    do i = ILB, IUB
                        Me%EulerModel(em)%Lag2Euler%GridVolRemovedDiff(i, j, ig)    =                  &
                                Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval(i,j, ig) -   &
                                Me%EulerModel(em)%Lag2Euler%GridBeachedVolume(i, j, ig) 
                    enddo
                enddo                        
            enddo Group
        enddo DoEM
        

    end subroutine VerifyBeachRemoval

    !--------------------------------------------------------------------------
    
    subroutine CalcParticDistanceToCoast()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer        :: CurrentOrigin
        type (T_Partic), pointer        :: CurrentPartic
        
        real                            :: Distance, IntersectX, IntersectY
        
        !----------------------------------------------------------------------


               
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

IfBeaching: if (CurrentOrigin%State%CalcPartDistToCoast) then
                    
                CurrentPartic => CurrentOrigin%FirstPartic
CurrPart:       do while (associated(CurrentPartic))
                   
                    Me%Point%X = CurrentPartic%Position%CoordX
                    Me%Point%Y = CurrentPartic%Position%CoordY
                
                    call PointDistanceToPolygon (Me%Point, Me%CoastLine,                &
                                                 Me%AngleList, Me%DistanceByDirection,  &
                                                 Distance, IntersectX, IntersectY)
                
                    !If the first eulerian model is defined in geo. coord. 
                    if (Me%EulerModel(1)%Grid%GeoGrid) then
                        Distance = DistanceBetweenTwoGPSPoints(Me%Point%X, Me%Point%Y, IntersectX, IntersectY)
                    endif
                    
                    CurrentPartic%DistanceToCoast = Distance
                    
                    if(CurrentPartic%DistanceToCoast < CurrentPartic%MinDistanceToCoast)then
                        CurrentPartic%MinDistanceToCoast = CurrentPartic%DistanceToCoast
                    endif       
                    
                    CurrentPartic => CurrentPartic%Next

                enddo CurrPart

            end if IfBeaching
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine CalcParticDistanceToCoast

    !--------------------------------------------------------------------------
    
    subroutine UpdateBeachHoldingCapacity()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        integer                                     :: em             
        real, dimension(:, :), pointer              :: DXX, DYY               
        integer                                     :: ILB, IUB, JLB, JUB, KUB
        integer                                     :: i,j, ShoreType
        integer                                     :: STAT_CALL
        real                                        :: WidthFractionX1, WidthFractionX2, WidthFractionX
        real                                        :: WidthFractionY1, WidthFractionY2, WidthFractionY
        real                                        :: RemainingWidthFractionX, RemainingWidthFractionY
        real                                        :: RemainingAreaFraction
        
        !Begin---------------------------------------------------------------------

        
d1:     do em =1, Me%EulerModelNumber 
            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB
            
            call GetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DXX = DXX, DYY = DYY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'UpdateBeachHoldingCapacity - ModuleLagrangianGlobal - ERR01'

d3:         do j  = JLB, JUB
d4:         do i  = ILB, IUB
                !only checks holding capacity for waterpoints             
i1:             if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then 
                        WidthFractionX1 = 0.
                        WidthFractionX2 = 0.
                        WidthFractionY1 = 0.
                        WidthFractionY2 = 0.
                        
                        !take width fraction of cells with any land cells at the neighborhood
                        if (Me%EulerModel(em)%OpenPoints3D(i, j+1, KUB).NE. OpenPoint) then
                            ShoreType = Me%EulerModel(em)%ShoreType(i,j+1)
                            WidthFractionX1   = min(1., Me%EulerModel(em)%BeachingLimit(i,j) / DXX (i, j))
                        endif
                        if (Me%EulerModel(em)%OpenPoints3D(i, j-1, KUB).NE. OpenPoint) then
                            ShoreType = Me%EulerModel(em)%ShoreType(i,j-1)
                            WidthFractionX2   = min(1.,Me%EulerModel(em)%BeachingLimit(i,j) / DXX (i, j))
                        endif
                        if (Me%EulerModel(em)%OpenPoints3D(i+1, j, KUB).NE. OpenPoint) then
                            ShoreType = Me%EulerModel(em)%ShoreType(i+1,j)
                            WidthFractionY1   = min(1.,Me%EulerModel(em)%BeachingLimit(i,j) / DYY (i, j))
                        endif
                        if (Me%EulerModel(em)%OpenPoints3D(i-1, j, KUB).NE. OpenPoint) then
                            ShoreType = Me%EulerModel(em)%ShoreType(i-1,j)
                            WidthFractionY2   = min(1.,Me%EulerModel(em)%BeachingLimit(i,j) / DYY (i, j))
                        endif
                            !Sums Width Fractions for X and Y (maximum fraction is obviously 1)
                            WidthFractionX = min(1., WidthFractionX1 + WidthFractionX2)
                            WidthFractionY = min(1., WidthFractionY1 + WidthFractionY2)
                            RemainingWidthFractionX  = 1. - WidthFractionX
                            RemainingWidthFractionY  = 1. - WidthFractionY
                            
                            !Area without any holding capacity
                            RemainingAreaFraction    = RemainingWidthFractionX * RemainingWidthFractionY
                            
                            ! Holding capacity is based on Area fraction capable of holding beached particles
                            Me%EulerModel(em)%HorizontalBeachHoldingCapacity(i,j) = &
                                Me%EulerModel(em)%GridCellArea(i, j) * (1 - RemainingAreaFraction)  
                endif i1

            enddo d4
            enddo d3
            
            !UnGets Horizontal Grid
            call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DXX, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'UpdateBeachHoldingCapacity - ModuleLagrangianGlobal - ERR10'

            !UnGets Horizontal Grid
            call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DYY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'UpdateBeachHoldingCapacity - ModuleLagrangianGlobal - ERR20'

            
        enddo d1


    end subroutine UpdateBeachHoldingCapacity

    !--------------------------------------------------------------------------

    subroutine MoveOrigin ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        real,  dimension(:,:), pointer              :: DataMatrix
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Time)                               :: Time1, Time2
        real                                        :: Value1, Value2
        real                                        :: NewValueX, NewValueY
        logical                                     :: TimeCycle
        integer                                     :: STAT_CALL, emp, iStart, iEnd

        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%MovingOrigin) then
            
                if (CurrentOrigin%MovingOriginCloudEmission) then
                
                    Time1 = Me%Now
                    Time2 = Me%Now + CurrentOrigin%DT_Emit
                
                    call GetTimeSerieTimeFrameIndexes(CurrentOrigin%ObjTimeSerie,       &
                                                      StartTime = Time1, EndTime = Time2, &
                                                      StartIndex = iStart, EndIndex = iEnd, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'MoveOrigin - ModuleLagrangianGlobal - ERR10'
                    
                    CurrentOrigin%NbrParticlesIteration = iEnd - iStart + 1
                    
                    if (associated(CurrentOrigin%x)) deallocate(CurrentOrigin%x)
                    if (associated(CurrentOrigin%y)) deallocate(CurrentOrigin%y)                    
                    
                    allocate(CurrentOrigin%x(CurrentOrigin%NbrParticlesIteration))
                    allocate(CurrentOrigin%y(CurrentOrigin%NbrParticlesIteration))    
                    
                    call GetTimeSerieDataMatrix (CurrentOrigin%ObjTimeSerie, DataMatrix, STAT  = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'MoveOrigin - ModuleLagrangianGlobal - ERR20'     
                    
                    CurrentOrigin%x(:)= DataMatrix(iStart:iEnd, CurrentOrigin%MovingOriginColumnX)
                    CurrentOrigin%y(:)= DataMatrix(iStart:iEnd, CurrentOrigin%MovingOriginColumnY)
                
                else

                    !Gets Value arround current instant     
                    call GetTimeSerieValue(CurrentOrigin%ObjTimeSerie,                       &
                                           Me%Now,                    &
                                           CurrentOrigin%MovingOriginColumnX,                &
                                           Time1, Value1, Time2, Value2, TimeCycle,          &
                                           STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'MoveOrigin - ModuleLagrangianGlobal - ERR40'

                    if (TimeCycle) then
                        NewValueX = Value1
                    else
                        !Interpolates Value for current instant
                        call InterpolateValueInTime(Me%Now, Time1,    &
                                                    Value1, Time2, Value2, NewValueX)
                    endif
                                    

                    !Gets Value arround current instant    
                    call GetTimeSerieValue(CurrentOrigin%ObjTimeSerie,                       &
                                           Me%Now,                    &
                                           CurrentOrigin%MovingOriginColumnY,                &
                                           Time1, Value1, Time2, Value2, TimeCycle,          &
                                           STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'MoveOrigin - ModuleLagrangianGlobal - ERR50'

                    if (TimeCycle) then
                        NewValueY = Value1
                    else
                        !Interpolates Value for current instant
                        call InterpolateValueInTime(Me%Now, Time1,    &
                                                    Value1, Time2, Value2, NewValueY)
                    endif


                    emp = CurrentOrigin%Position%ModelID
                     
                    if (trim(CurrentOrigin%MovingOriginUnits) == trim(Char_Cells)) then

                        CurrentOrigin%Position%CellI = NewValueY
                        CurrentOrigin%Position%CellJ = NewValueX

                        !Convert Coordinates
                        call Convert_CellIJ_XY(Me%EulerModel(emp), CurrentOrigin%Position)


                    else
                    
                        CurrentOrigin%Position%CoordX = NewValueX
                        CurrentOrigin%Position%CoordY = NewValueY

                        !Convert Coordinates
                        call Convert_XY_CellIJ(Me%EulerModel(emp),CurrentOrigin%Position, Referential = GridCoord_)


                    endif
                endif
                


            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine MoveOrigin

    !--------------------------------------------------------------------------

    subroutine MovePartic ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        real, dimension(:, :, :), pointer           :: Temperature3D
        real                                        :: TemperatureX, DensityX
        real                                        :: VolInic, CoefVelMancha
        integer                                     :: STAT_CALL
        integer                                     :: i, j, k, em, ig
        integer                                     :: ILB, JLB, IUB, JUB, KUB
        integer                                     :: ThicknessGradient, Fay
        integer                                     :: SpreadingMethod
        type (T_Time)                               :: LagrangianTime
        logical                                     :: Continuous

        !Begin-----------------------------------------------------------------

        LagrangianTime = Me%Now


        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            !Calls Oil Active Processes to calculate Spreading Velocity
            if (CurrentOrigin%State%Oil .and. CurrentOrigin%nParticle > 0) then

                i            = CurrentOrigin%FirstPartic%Position%I
                j            = CurrentOrigin%FirstPartic%Position%J
                k            = CurrentOrigin%FirstPartic%Position%K
                em           = CurrentOrigin%FirstPartic%Position%ModelID
                
                ig           = CurrentOrigin%GroupID
                
                ILB          = Me%EulerModel(em)%WorkSize%ILB
                JLB          = Me%EulerModel(em)%WorkSize%JLB

                IUB          = Me%EulerModel(em)%WorkSize%IUB
                JUB          = Me%EulerModel(em)%WorkSize%JUB
                
                KUB          = Me%EulerModel(em)%WorkSize%KUB

                !Gets the temperature and the Density from the Eulerian model
                call GetConcentration(Me%EulerModel(em)%ObjWaterProperties,             &
                                      ConcentrationX    = Temperature3D,                &
                                      PropertyXIDNumber = Temperature_,                 &
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    write (*,*)'The Lagrangian Module needs the Water Temperature from the eulerian module'
                    stop 'MovePartic - ModuleLagrangianGlobal - ERR10'
                endif


                TemperatureX = Temperature3D (i, j, k)

                call UngetWaterProperties (Me%EulerModel(em)%ObjWaterProperties, Temperature3D,  &
                                           STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'MovePartic - ModuleLagrangianGlobal - ERR70'


                DensityX     = Me%EulerModel(em)%Density (i, j, k)


                !Calculates area and total volume    
                call ComputeAreaVolume ()

                !If it is a ccident the volume to be considered is the 
                !CurrentOrigin%PointVolume, on the other hand its
                !
                select case (CurrentOrigin%EmissionTemporal)

                case (Continuous_)

                    !VolInic = CurrentOrigin%Flow * (CurrentOrigin%StopEmission - CurrentOrigin%StartEmission)
                    VolInic    =  CurrentOrigin%VolumeTotalIni
                    Continuous = .true. 

                case (Instantaneous_)

                    VolInic    = CurrentOrigin%PointVolume
                    Continuous = .false.                     

                end select
                
                !Calculates the Oil Active Processes    
                call OilActiveProcesses(OilID              = CurrentOrigin%ObjOil,      &
                                        LagrangianTime     = LagrangianTime,            & 
                                        WaterTemperature   = TemperatureX,              &
                                        WaterDensity       = DensityX,                  &
                                        VolInic            = VolInic,                   &
                                        DT                 = Me%DT_PARTIC,              &
                                        AreaTotal          = CurrentOrigin%AreaTotal,   &
                                        Continuous         = Continuous,                &
                                        STAT               = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'MovePartic - ModuleLagrangianGlobal - ERR20'

                !Gets Oil Spreading Parameters
                call GetOilSpreadingList(ThicknessGradient = ThicknessGradient,          &
                                         Fay               = Fay)
                call GetOilSpreading(CurrentOrigin%ObjOil,                               &    
                                     SpreadingMethod       = SpreadingMethod,            &
                                     STAT                  = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'MovePartic - ModuleLagrangianGlobal - ERR30'

                if     (SpreadingMethod == ThicknessGradient) then

                    call GetOilSpreadingVelocity(CurrentOrigin%ObjOil,                  &
                         CoefVelMancha   = CoefVelMancha,                               &
                         STAT           = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'MovePartic - ModuleLagrangianGlobal - ERR40'

                    do j = JLB, JUB + 1
                    do i = ILB, IUB

                        if (Me%EulerModel(em)%ComputeFaces3D_U(i, j, KUB) == Compute) then

                            Me%EulerModel(em)%OilSpreading(ig)%VelocityX(i, j) =  CoefVelMancha  *  &
                                    (Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i, j-1) - &
                                     Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i, j)) /  &
                                     Me%EulerModel(em)%DZX(i,  j-1)
                        else

                            Me%EulerModel(em)%OilSpreading(ig)%VelocityX(i, j) = 0.

                        endif

                    enddo
                    enddo

                    do j = JLB, JUB
                    do i = ILB, IUB + 1

                        if (Me%EulerModel(em)%ComputeFaces3D_V(i, j, KUB) == Compute) then

                            Me%EulerModel(em)%OilSpreading(ig)%VelocityY(i, j) =  CoefVelMancha  *  &
                                    (Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i-1, j) - &
                                     Me%EulerModel(em)%OilSpreading(ig)%GridThickness(i, j)) /  &
                                     Me%EulerModel(em)%DZY(i-1,  j)
                        else

                            Me%EulerModel(em)%OilSpreading(ig)%VelocityY(i, j) = 0.

                        endif

                    enddo
                    enddo


                elseif (SpreadingMethod == Fay              ) then

                    call GetOilSpreadingVelocity(CurrentOrigin%ObjOil,                  &
                         DiffVelocity   = Me%ExternalVar%DiffVelocity,                  &
                         DiffCoef       = Me%ExternalVar%OilDiffCoef,                   &
                         STAT           = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'MovePartic - ModuleLagrangianGlobal - ERR40'
                end if
            
            elseif (CurrentOrigin%State%HNS .and. CurrentOrigin%nParticle > 0) then

                call UpdateHNSAreaVolume(UpdateParticleAreas = .false.)
         

                
                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                    if (CurrentOrigin%State%HNSSpreading) then
                        if (CurrentOrigin%Position%SurfaceEmission) then
                            if ((CurrentOrigin%AreaTotal > 0.) .AND. (CurrentPartic%HNSParticleState .EQ. Surface_)) then
                                call GetHNSSpreadingDiffVel (CurrentOrigin%ObjHNS,                        &
                                     DT                     = Me%DT_Partic,                               &
                                     AreaTotal              = CurrentOrigin%AreaTotal,                    &
                                     AreaParticle           = CurrentPartic%Geometry%Area,                &
                                     VolumeParticle         = CurrentPartic%Geometry%Volume,              &
                                     SpreadingDiffCoef      = CurrentPartic%HNSSpreadingDiffCoef,         &
                                     SpreadingDiffVel       = CurrentPartic%HNSSpreadingDiffVel,          &
                                     STAT                   = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'MovePartic - ModuleLagrangianGlobal - ERR41'
                            else
                                !if particle is currently underwater, spreading is disabled;
                                !also if there are no particles at surface, there is no spreading process;
                                CurrentPartic%HNSSpreadingDiffCoef  = 0.0
                                CurrentPartic%HNSSpreadingDiffVel   = 0.0
            endif
                        else
                            !ROD: underwater spill disconnets spreading; this can be reviewed in the future
                            CurrentPartic%HNSSpreadingDiffCoef  = 0.0
                            CurrentPartic%HNSSpreadingDiffVel   = 0.0
                        endif
                    else
                        CurrentPartic%HNSSpreadingDiffCoef  = 0.0
                        CurrentPartic%HNSSpreadingDiffVel   = 0.0
                    endif
                CurrentPartic => CurrentPartic%Next
            enddo
            
            endif
            
            call CheckDepositionCriticalSlope

            !Moves the particles horizontaly
            call MoveParticHorizontal(CurrentOrigin, ThicknessGradient, Fay, SpreadingMethod)

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine MovePartic

    !--------------------------------------------------------------------------

    subroutine MoveParticHorizontal (CurrentOrigin, ThicknessGradient, Fay, SpreadingMethod)

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ThicknessGradient, Fay
        integer                                     :: SpreadingMethod

        !Local-----------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: i, j, k
        real                                        :: CellI, CellJ, CellK
        real                                        :: BalX, BalY, BalZ
        real                                        :: U        = 0.
        real                                        :: V        = 0.
        real                                        :: UINT     = 0.
        real                                        :: VINT     = 0.
        real                                        :: UWind_   = 0.
        real                                        :: VWind_   = 0.
        real                                        :: UWind    = 0.
        real                                        :: VWind    = 0.
        real                                        :: WindDriftAngle = 0.
        real                                        :: U1       = 0.
        real                                        :: V1       = 0.
        real                                        :: UD       = 0.
        real                                        :: VD       = 0.
        real                                        :: DX       = 0.
        real                                        :: DY       = 0.
        real                                        :: DXrand   = 0.
        real                                        :: DYrand   = 0.        
        real                                        :: UOil     = 0.
        real                                        :: VOil     = 0.
        real                                        :: VelOil   = 0.
        real                                        :: UHNS     = 0.
        real                                        :: VHNS     = 0.
        real                                        :: VelHNS   = 0.
        real                                        :: UPlume   = 0.
        real                                        :: VPlume   = 0.
        integer                                     :: Layers
        real                                        :: EspSup, Esp, EspInf
        real, dimension(:, :, :), pointer           :: Velocity_U, Velocity_V
        real                                        :: VelModH
        real                                        :: StandardDeviation, MixingLength, HD, TlagrangeH
        real                                        :: RAND, R1, R2
        type (T_Position)                           :: NewPosition, AuxPosition
        integer                                     :: NewI, NewJ, KUB
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB, WS_KLB, WS_KUB
        logical                                     :: PositionCorrected
        real                                        :: TauAux
        integer                                     :: ID_Group, emp, em, STAT_CALL
        real                                        :: Radius, Area
        real                                        :: VolOld, VolNew, dVol
        real                                        :: Modulus = 0., WindX = 0., WindY = 0.
        real                                        :: GradDWx = 0., GradDWy = 0.
        logical                                     :: NoIntU, NoIntV, ComputeTrajectory, HaveDomain, MovePartic
        logical                                     :: ConvertOK
        real                                        :: WavePeriod, WaveHeight, WaveDirection,UStokesDrift, VStokesDrift
        real                                        :: WavePeriodAux
        real                                        :: AngFrequency, WaveNumber, VelStokesDrift, Depth
        real                                        :: WaterDensity, UDrift = 0., VDrift = 0.
        logical                                     :: InterpolVel3D
        integer                                     :: Npi, Npj, ts
        real                                        :: DXn, DYn
        !new method for stokes drift
        real                                        :: WaveLength
!        real                                        :: Celerity
!        character                                   :: WaveType
        real                                        :: WaterDepth
        real                                        :: WaveAmplitude
!        real                                        :: WaveLength_Deep, WaveLength_Shallow
        real                                        :: C_Term
        real                                        :: OilViscCin, OWInterfacialTension
        real                                        :: Wind
        logical                                     :: exitDoCycle
        real                                        :: DiffusionCoefH

        !Begin-----------------------------------------------------------------------------------------
        
        if (Me%State%Oil) then
            call GetOilViscCin(OilID         = CurrentOrigin%ObjOil,                    &
                               OilViscCin    = OilViscCin,                              &              
                                 STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR01'
            
            !next property needed for rising velocity, method Zheng 
            If (CurrentOrigin%MethodFloatVel .EQ. Zheng_) then                              
                call GetOWInterfacialTension(CurrentOrigin%ObjOil,                          &
                                             OWInterfacialTension   = OWInterfacialTension, &
                                             STAT                   = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR02'
               
            endif
        end if
        CurrentPartic => CurrentOrigin%FirstPartic
CP:     do while (associated (CurrentPartic))


            

            if (Me%State%Oil) then
                CurrentPartic%OilViscCin = OilViscCin
                If (CurrentOrigin%MethodFloatVel .EQ. Zheng_) then
                    CurrentPartic%OWInterfacialTension = OWInterfacialTension
                end if
            end if
            
            
            ComputeTrajectory = .true. 

CT:         do while (ComputeTrajectory) 

                emp    = CurrentPartic%Position%ModelID

                WS_ILB = Me%EulerModel(emp)%WorkSize%ILB
                WS_IUB = Me%EulerModel(emp)%WorkSize%IUB
                WS_JLB = Me%EulerModel(emp)%WorkSize%JLB
                WS_JUB = Me%EulerModel(emp)%WorkSize%JUB
                WS_KLB = Me%EulerModel(emp)%WorkSize%KLB
                WS_KUB = Me%EulerModel(emp)%WorkSize%KUB
            
                !Grid Cell of the particle
                i        = CurrentPartic%Position%I
                j        = CurrentPartic%Position%J
                k        = CurrentPartic%Position%K

                ID_Group = CurrentOrigin%GroupID

                !Shorten Var
                if (Me%OverLay) then
                    Velocity_U => Me%EulerModel(emp)%OverLay%VelUFinal
                    Velocity_V => Me%EulerModel(emp)%OverLay%VelVFinal
                else
                    Velocity_U => Me%EulerModel(emp)%Velocity_U
                    Velocity_V => Me%EulerModel(emp)%Velocity_V
                endif

                if (CurrentOrigin%State%Deposition) then
                
                    CurrentPartic%BottomStress =                                                    &
                        FromGrid2DToParticleXY(CurrentPartic    = CurrentPartic,                    &
                                               Matrix2D         = Me%EulerModel(emp)%BottomStress,  &
                                               WaterPoints2D    = Me%EulerModel(emp)%WaterPoints2D)
                endif                        

BD:             if (CurrentPartic%Beached .or. CurrentPartic%Deposited .or. CurrentPartic%AtTheBottom &
                    .or. (CurrentPartic%HNSParticleState .EQ. Bottom_Deposited_)) then

                    if (CurrentPartic%Deposited) then
                        
                        if (CurrentOrigin%Deposition%MixSedON) then

                            TauAux = CurrentPartic%TauErosion + (Me%EulerModel(emp)%Lag2Euler%TauErosionGrid( i, j, ID_Group) - &
                                     CurrentPartic%TauErosion) * Me%DT_Partic / CurrentOrigin%Deposition%TdecayMix

                            CurrentPartic%TauErosionMix = max (CurrentPartic%TauErosion, TauAux)
                            
                        else
                            
                            CurrentPartic%TauErosionMix = CurrentPartic%TauErosion
                            
                        endif                            


                        if (VerifyRessuspension(CurrentPartic, CurrentOrigin)) then
                            CurrentPartic%Deposited = .false. 
                            !The effect of other sediment classes ends when the particle is ressuspended
                            CurrentPartic%TauErosionMix = CurrentPartic%TauErosion
                        endif

                    endif

                    ComputeTrajectory = .false.
                    
                    exit
            
                endif BD
                
                !Cell Postition
                CellI = CurrentPartic%Position%CellI
                CellJ = CurrentPartic%Position%CellJ
                CellK = CurrentPartic%Position%CellK

                !Fraction of the cell
                BALX  = CellJ - int(CellJ)
                BALY  = CellI - int(CellI)
                BALZ  = CellK - int(CellK)
                
                if (CurrentPartic%CurrentX < HalfFillValueReal) then
                    !Linear Interpolation to obtain the velocity of the Water
                    CurrentPartic%CurrentX = LinearInterpolationCell(Velocity_U(i,  j  ,k), Velocity_U(i,  j+1,k), Balx)
                endif

                if (CurrentPartic%CurrentY < HalfFillValueReal) then
                    !Linear Interpolation to obtain the velocity of the Water
                    CurrentPartic%CurrentY = LinearInterpolationCell(Velocity_V(i,  j  ,k), Velocity_V(i+1,j  ,k), Baly)
                endif
                
                U = CurrentPartic%CurrentX                
                V = CurrentPartic%CurrentY 
                
                if (CurrentOrigin%Movement%Float) then   
                    !Equal probability to go in any horizontal direction
                    GradDWx = 0.0
                    GradDWy = 0.0
                else
                    !Spagnol et al. (Mar. Ecol. Prog. Ser., 235, 299-302, 2002).                        
                    !Linear Interpolation to obtain the thickness gradient
                    GradDWx = LinearInterpolationCell(Me%EulerModel(emp)%DWZ_Xgrad(i,  j  ,k),  &
                                                  Me%EulerModel(emp)%DWZ_Xgrad(i,  j+1,k), Balx)
                    GradDWy = LinearInterpolationCell(Me%EulerModel(emp)%DWZ_Ygrad(i,  j  ,k),  &
                                                  Me%EulerModel(emp)%DWZ_Ygrad(i+1,j  ,k), Baly)
                endif                                              
                                              
                                              
                UStokesDrift = 0.
                VStokesDrift = 0.

                !Floating particle 
MF:             if (CurrentPartic%Position%Surface) then 

                    !Velocity due Water
                    UINT = U                        
                    VINT = V   
                    
                    if (CurrentPartic%WindX < HalfFillValueReal) then
                        !Velocity due wind  
                        if (CurrentOrigin%Movement%WindOriginON) then
                            CurrentPartic%WindX = CurrentOrigin%Movement%WindX
                        else
                            if (associated(Me%EulerModel(emp)%WindX)) then
                                if (Me%EulerModel(emp)%WindX(i, j) > FillValueReal) then
                                    CurrentPartic%WindX = Me%EulerModel(emp)%WindX(i, j)
                                else
                                    CurrentPartic%WindX = 0.
                                endif                                    
                            else
                                CurrentPartic%WindX = 0.
                            endif
                            
                        endif

                    endif

                    if (CurrentPartic%WindY < HalfFillValueReal) then
                        !Velocity due wind  
                        if (CurrentOrigin%Movement%WindOriginON) then
                            CurrentPartic%WindY = CurrentOrigin%Movement%WindY
                        else
                            if (associated(Me%EulerModel(emp)%WindY)) then
                                if (Me%EulerModel(emp)%WindY(i, j) > FillValueReal) then
                                    CurrentPartic%WindY = Me%EulerModel(emp)%WindY(i, j)
                                else
                                    CurrentPartic%WindY = 0.
                                endif                                    
                            else
                                CurrentPartic%WindY = 0.
                            endif
                        endif

                    endif
                    
                    WindX = CurrentPartic%WindX
                    WindY = CurrentPartic%WindY
                    
                    UWind_ = CurrentOrigin%Movement%WindTransferCoef * WindX
                    VWind_ = CurrentOrigin%Movement%WindTransferCoef * WindY
                    
                    if      (CurrentOrigin%Movement%WindDriftCorrection == NoCorrection_) then
                    
                        UWind =   UWind_ 
                        VWind =   VWind_                         
                        
                    else 
                        if (CurrentOrigin%Movement%WindDriftCorrection == Computed_Samuels_) then
                            Wind    = abs(cmplx(WindX, WindY))

                            !Samuels, 1982 - deflection angle is inversely proportional to wind speed
                            WindDriftAngle = 25. * exp(-10.e-8 * (Wind**3) / ( WaterCinematicVisc * gravity) )
                        elseif (CurrentOrigin%Movement%WindDriftCorrection == UserDefined_) then
                            WindDriftAngle = CurrentOrigin%Movement%WindDriftAngle 
                        endif

                        UWind =   UWind_ * cos(WindDriftAngle * (Pi / 180.)) + VWind_ * sin(WindDriftAngle * (Pi / 180.))
                        VWind = - UWind_ * sin(WindDriftAngle * (Pi / 180.)) + VWind_ * cos(WindDriftAngle * (Pi / 180.))
                    endif                        
                    
                    if (Me%ExternalVar%BackTracking) then
                        UWind = - UWind
                        VWind = - VWind
                    endif                          

                    !Plume velocity
                    UPlume = 0.
                    VPlume = 0.
                    
                    UDrift = 0.
                    VDrift = 0.

                    ! Velocity due Stokes Drift
                    if (CurrentOrigin%State%StokesDrift .or. Me%Booms%ON) then    

                        if (CurrentPartic%WaveHeight    < 0 .and. associated(Me%EulerModel(emp)%WaveHeight2D) ) then
                            CurrentPartic%WaveHeight    = Me%EulerModel(emp)%WaveHeight2D(i, j)
                        endif

                    endif
                                            
                    if (CurrentOrigin%State%StokesDrift) then


                        if (CurrentPartic%WavePeriod    <= 0) then
                            CurrentPartic%WavePeriod    = Me%EulerModel(emp)%WavePeriod2D(i, j)
                        endif

                        if (abs(CurrentPartic%WaveDirection) > 360. ) then                        
                            CurrentPartic%WaveDirection = Me%EulerModel(emp)%WaveDirection2D(i, j)
                        endif

                        if (CurrentPartic%WaveLength    < 0) then
                            CurrentPartic%WaveLength    = Me%EulerModel(emp)%WaveLength2D(i, j)
                        endif

                        WaveHeight      = CurrentPartic%WaveHeight
                        WavePeriod      = CurrentPartic%WavePeriod
                        WaveDirection   = CurrentPartic%WaveDirection

                        WavePeriodAux   = max (WavePeriod, 0.01)
                        AngFrequency    = 2 * Pi / WavePeriodAux
                        
                        if (WavePeriod == 0 .and. WaveHeight>0) then
                            write(*,*) 'Can not have a null wave period and a positive wave height'
                            !stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR10'
                            CurrentPartic%WavePeriod = 0.01
                        endif

                        Depth               = CurrentPartic%Position%Z-             &
                                              Me%EulerModel(emp)%SZZ(i, j, WS_KUB)
                                              
                        if (Depth < 0.)       Depth = 0. 

                        WaterDepth         = Me%EulerModel(emp)%WaterColumn(i, j)
                        WaveAmplitude      = CurrentPartic%WaveHeight / 2.
                        
                        if (CurrentOrigin%Movement%WaveLengthFromPeriod) then
                            if (WavePeriod < 1e-3) then 
                                CurrentPartic%WaveLength = 0.
                            else
                                CurrentPartic%WaveLength = WaveLengthHuntsApproximation(WavePeriod, WaterDepth)
                            end if
                        endif
                        
                        WaveLength         = CurrentPartic%WaveLength                        
                        
                        If (WaveLength > 0.) then
                            WaveNumber     = 2 * Pi / WaveLength
                        Else
                            WaveNumber     = 0.
                        End If
                        
                        If ((WaveNumber *  WaterDepth == 0.) .OR. (WaveNumber == 0.)                             & 
                           .OR. (WaterDepth == 0.)) then
                            VelStokesDrift = 0.
                        Else
if_stm:                     If (CurrentOrigin%Movement%StokesDriftMethod == LonguetHigginsGeneric) then 
                                If (WaterDepth > (WaveLength / 2.)) then
                                    write(*,*) 'Can not compute Stokes Drift with generic formulation '
                                    write(*,*) '(potential floating overflow).'
                                    write(*,*) 'Since (WaterDepth > WaveLength / 2), deep water approach is adequate '
                                    write(*,*) '- change Stokes Drift Method to LonguetHigginsDeep'
                                    stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR11'
                                endif
                                
                                C_Term             = - (WaveAmplitude * WaveAmplitude * AngFrequency *           &
                                                       sinh(2 * WaveNumber *  WaterDepth)) / &
                                                       ( 4 * WaterDepth * sinh(WaveNumber * WaterDepth)**2)
                                
                                VelStokesDrift     = WaveAmplitude * WaveAmplitude * AngFrequency * WaveNumber * &
                                                     ( ( cosh(2 * WaveNumber * (Depth - WaterDepth)) ) /         &
                                                       ( 2 * (sinh(WaveNumber * WaterDepth)*                     &
                                                        sinh(WaveNumber * WaterDepth))      )   )     +  C_Term 
                                
                            elseif (CurrentOrigin%Movement%StokesDriftMethod == LonguetHigginsDeep) then   if_stm

                                VelStokesDrift     = WaveAmplitude * WaveAmplitude * AngFrequency * WaveNumber * &
                                                     exp(-2* WaveNumber * Depth)
                                                                               
                            elseif (CurrentOrigin%Movement%StokesDriftMethod == Ardhuin) then             if_stm
                                ! Approximation from Ardhuin et al, 2009 (DOI: 10.1175/2009JPO4169.1)
                                Wind               = abs(cmplx(WindX, WindY))
                                VelStokesDrift     = 0.0005 * (1.25 - 0.25 * ((0.5 * WavePeriod)**1.3)) * Wind * &
                                                     min(Wind, 14.5) + 0.025 * (WaveHeight - 0.4)
                                If (VelStokesDrift .LT. 0.) then 
                                    VelStokesDrift = 0.
                                endif
                                

                            end if if_stm
                        
                        End If
                        
                                                                      
                        if (VelStokesDrift > 10) then
                            write(*,*) 'Stokes drift velocity > 10, null value is assumed'
                            write(*,*) 'i j =',i, j
                            write(*,*)'WaveHeight  =', WaveHeight
                            write(*,*)'WavePeriod  =', WavePeriod
                            write(*,*)'WaveDirection  =', WaveDirection
                            write(*,*)'WaveLength  =', WaveLength
                            write(*,*) 'MoveParticHorizontal - ModuleLagrangianGlobal - WRN10'
                            VelStokesDrift = 0
                        endif
                                              
                        UStokesDrift        = cos(WaveDirection * (Pi / 180.)) * VelStokesDrift
                        VStokesDrift        = sin(WaveDirection * (Pi / 180.)) * VelStokesDrift
                        
                  
                        if (Me%ExternalVar%BackTracking) then
                            UStokesDrift = - UStokesDrift
                            VStokesDrift = - VStokesDrift
                        endif                            

                    end if

                    UOil  = 0.0
                    VOil  = 0.0 

                    if (CurrentOrigin%State%Oil) then
                    
                        if      (SpreadingMethod == ThicknessGradient) then
                            if  (emp == CurrentOrigin%Position%ModelID) then
                
                                UOil = LinearInterpolationCell(                                      &
                                        Me%EulerModel(emp)%OilSpreading(ID_Group)%VelocityX(i, j  ),    &
                                        Me%EulerModel(emp)%OilSpreading(ID_Group)%VelocityX(i, j+1),    &
                                        Balx)

                                VOil = LinearInterpolationCell(                                      &
                                        Me%EulerModel(emp)%OilSpreading(ID_Group)%VelocityY(i, j  ),    &
                                        Me%EulerModel(emp)%OilSpreading(ID_Group)%VelocityY(i+1, j),    &
                                        Baly)
                            endif
                           
                                            
                        elseif  (SpreadingMethod == Fay              ) then

                            call RANDOM_NUMBER(R1)
                            if (CurrentPartic%Position%SpreadingAngle < HalfFillValueReal) then
                                call RANDOM_NUMBER(R2)
                                R2 = 2.0*Pi*R2
                                VelOil  = Me%ExternalVar%DiffVelocity
                            else                                
                                R2 = CurrentPartic%Position%SpreadingAngle
                                !VelOil = 2 * Me%ExternalVar%OilDiffCoef /sqrt(Pi * CurrentOrigin%AreaTotal)
                                if (CurrentOrigin%nParticle > 100) then
                                    VelOil = Me%ExternalVar%DiffVelocity / (2.08*log(real(CurrentOrigin%nParticle))-8.5)
                                else
                                    VelOil = Me%ExternalVar%DiffVelocity
                                endif
                            endif

                            UOil = R1 * cos(R2) * VelOil
                            VOil = R1 * sin(R2) * VelOil

                        endif

                    end if
                    
                    UHNS = 0.
                    VHNS = 0.
                    if (CurrentOrigin%State%HNS) then
                        call RANDOM_NUMBER(R1)
                        call RANDOM_NUMBER(R2)
                        !uniform Distribution (Al-Rabeh, 2000)
                        VelHNS = CurrentPartic%HNSSpreadingDiffVel
                        UHNS = R1 * cos(2.0*Pi*R2) * VelHNS
                        VHNS = R1 * sin(2.0*Pi*R2) * VelHNS                   
                    endif

                    if (CurrentOrigin%State%FloatingObject) then
                    
                        WaterDensity        = Me%EulerModel(emp)%Density(i, j, k)

                        UDrift = GetDriftVelocity(Air_Density,                                  &
                                                  CurrentOrigin%FloatingObject%AirDragCoef,     &
                                                  CurrentOrigin%FloatingObject%ImmersionRatio,  &
                                                  WindX,                                        &
                                                  WaterDensity,                                 &
                                                  CurrentOrigin%FloatingObject%WaterDragCoef,   &
                                                  UINT)
                                                  
                        VDrift = GetDriftVelocity(Air_Density,                                  &
                                                  CurrentOrigin%FloatingObject%AirDragCoef,     &
                                                  CurrentOrigin%FloatingObject%ImmersionRatio,  &
                                                  WindY,                                        &
                                                  WaterDensity,                                 &
                                                  CurrentOrigin%FloatingObject%WaterDragCoef,   &
                                                  VINT)

                   
                        if (Me%ExternalVar%BackTracking) then
                            UDrift = - UDrift
                            VDrift = - VDrift
                        endif     
                    else                                                                        
                        UDrift = 0.
                        VDrift = 0.
                    end if
                    

                else MF

                    UWind = 0.0
                    VWind = 0.0

                    UOil  = 0.0
                    VOil  = 0.0
                        
                    UHNS  = 0.0
                    VHNS  = 0.0
                        
                    if (CurrentPartic%CurrentX < HalfFillValueReal .or. CurrentPartic%CurrentY < HalfFillValueReal) then
                        InterpolVel3D = .true.
                    else
                        InterpolVel3D = .false.                                            
                    endif


                    !Interpolate horizontal velocities in the vertical
                    Layers = WS_KUB - WS_KLB + 1 

i3D:                if (InterpolVel3D) then
                    if (Layers > 1) then  !More than 1 layer

                        EspSup = Me%EulerModel(emp)%DWZ(i, j, k+1)
                        Esp    = Me%EulerModel(emp)%DWZ(i, j, k  )
                        EspInf = Me%EulerModel(emp)%DWZ(i, j, k-1)

                        NoIntU = .false.
                        NoIntV = .false. 

                        if (Me%EulerModel(emp)%ComputeFaces3D_U(i, j,   k) /= Covered .or.  &
                            Me%EulerModel(emp)%ComputeFaces3D_U(i, j+1, k) /= Covered ) then
                           !No vertical interpolation
                            NoIntU = .true.
                        endif

                        if (Me%EulerModel(emp)%ComputeFaces3D_V(i, j, k  ) /= Covered .or.  &
                            Me%EulerModel(emp)%ComputeFaces3D_V(i+1, j, k) /= Covered ) then
                           !No vertical interpolation
                            NoIntV = .true.
                        endif


                        !Not Close to the bottom
                        if (k /= Me%EulerModel(emp)%kFloor(i, j) .and. BALZ < 0.5) then
                    
                            if (NoIntU) then 
                                UINT = U
                            else

                                U1 = LinearInterpolationCell(Velocity_U(I,  J  ,K-1),       &
                                                         Velocity_U(I,  J+1,K-1), Balx)

                                UINT = 2.0 * (U1 * (0.5-BALZ) * Esp + U * BALZ * Esp +  &
                                       U * 0.5 * EspInf) / (Esp + EspInf)
                            endif

                            if (NoIntV) then 
                                VINT = V
                            else

                                V1 = LinearInterpolationCell(Velocity_V(I,  J  ,K-1),       &
                                                         Velocity_V(I+1,J  ,K-1), Baly)

                                VINT = 2.0 * (V1 * (0.5-BALZ) * Esp + V * BALZ * Esp +  &
                                       V * 0.5 * EspInf) / (Esp + EspInf)
                            endif

                        !Not Close to the surface
                        else if ((K /= WS_KUB) .and. (BALZ > 0.5 )) then

                            if (NoIntU) then 
                                UINT = U
                            else
                                U1 = LinearInterpolationCell(Velocity_U(I,  J  ,K+1),       &
                                                         Velocity_U(I,  J+1,K+1), Balx)

                                UINT = 2.0 * (U * 0.5 * EspSup + U * (1.0-BALZ) * Esp + &
                                       U1 * (BALZ-0.5) * Esp) / (Esp + EspSup)
                            endif

                            if (NoIntV) then 
                                VINT = V
                            else
                                V1 = LinearInterpolationCell(Velocity_V(I,  J  ,K+1),       &
                                                         Velocity_V(I+1,J  ,K+1), Baly)

                                VINT = 2.0 * (V * 0.5 * EspSup + V * (1.0-BALZ) * Esp + &
                                       V1 * (BALZ-0.5) * Esp) / (Esp + EspSup)
                            endif

                        !Close to surface / Bottom
                        else

                            UINT = U      
                            VINT = V      

                        end if

                    !1 Layer 
                    else 

                        UINT = U          
                        VINT = V               

                    end if
                        CurrentPartic%CurrentX = UINT
                        CurrentPartic%CurrentY = VINT
                    else i3D
                        UINT = CurrentPartic%CurrentX
                        VINT = CurrentPartic%CurrentY
                    end if i3D

                end if MF
                
                if (Me%ExternalVar%BackTracking) then
                    UINT = - UINT
                    VINT = - VINT
                endif


MT:             if (CurrentOrigin%Movement%MovType == SullivanAllen_) then 
        
                    VelModH  = abs(cmplx(U, V))

                    StandardDeviation = CurrentOrigin%Movement%VarVelHX * VelModH +     &
                                        CurrentOrigin%Movement%VarVelH

                    if (CurrentPartic%Position%Surface) then
                        StandardDeviation = StandardDeviation + CurrentOrigin%Movement%VarVelHX * sqrt(UWind**2. + VWind**2.)
                    endif
                                         
                    if (CurrentOrigin%State%StokesDrift) then
                        StandardDeviation = StandardDeviation + CurrentOrigin%Movement%VarVelHX * VelStokesDrift
                    endif


                    !MixingLength =abs(cmplx(Me%EulerModel(emp)%MixingLengthX(i, j, k),  &
                    !                        Me%EulerModel(emp)%MixingLengthY(i, j, k)))
                    
                    MixingLength =(Me%EulerModel(emp)%MixingLengthX(i, j, k)+           &
                                   Me%EulerModel(emp)%MixingLengthY(i, j, k))/2.

                    if (StandardDeviation > 0.0) then
                        TlagrangeH = MixingLength / StandardDeviation
                    else
                        TlagrangeH = 0.0     
                    endif

                    if (CurrentPartic%TpercursoH >= TlagrangeH) then  
                        
                        ! First step - compute the modulus of turbulent vector
                        
                        call random_number(RAND)
                        !SQRT(3.0)=1.732050808 
                        HD                       = 1.732050808 * StandardDeviation * RAND

                        ! Second step - Compute the modulus of each component of the turbulent vector
                        call random_number(RAND)

                        !   From 0 to Pi/2 cos and sin have positive values
                        UD                       = HD * cos(2 * Pi * RAND)
                        VD                       = HD * sin(2 * Pi * RAND)

                        !Third step - Compute the direction of the the turbulent vector taking in consideration the layers thickness gradients
                        ! Spagnol et al. (Mar. Ecol. Prog. Ser., 235, 299-302, 2002).
                        
                        if (CurrentOrigin%Movement%TurbGradK) then
                            ![m/s] = [m/s] + [m] * [m/s] * [1/m] 
                            ! K = Turbulent Diffusion Coefficent = MixingLength * Stdev of turbulent velocity / 2. 
                            UD = UD + MixingLength * 1.732050808 * StandardDeviation / 2. * GradDWx
                            VD = VD + MixingLength * 1.732050808 * StandardDeviation / 2. * GradDWy

                        endif                                    
                        
                        CurrentPartic%TpercursoH = Me%DT_Partic
                        CurrentPartic%UD_old     = UD
                        CurrentPartic%VD_old     = VD
                    
                    else
                        UD                       = CurrentPartic%UD_old
                        VD                       = CurrentPartic%VD_old
                        CurrentPartic%TpercursoH = CurrentPartic%TpercursoH + Me%DT_Partic
                    end if

                else if (CurrentOrigin%Movement%MovType .EQ. DiffusionCoef_    ) then MT     
    
                    if (CurrentOrigin%Movement%DiffusionCoefHON) then
                        DiffusionCoefH = CurrentOrigin%Movement%DiffusionCoefH
                    else
                        DiffusionCoefH = Me%EulerModel(emp)%DiffusionH(i, j, k)
                    endif

                    ! First step - compute the modulus of turbulent vector
                        
                    call random_number(RAND)
                        
                    !(m^2/s/s)^0.5  du = sqrt(2*D/dt) - standard approach
                    HD                       = sqrt(2.* DiffusionCoefH / Me%DT_Partic)  * RAND

                    ! Second step - Compute the modulus of each component of the turbulent vector
                    call random_number(RAND)

                    !   From 0 to Pi/2 cos and sin have positive values
                    UD                       = HD * cos(2 * Pi * RAND)
                    VD                       = HD * sin(2 * Pi * RAND)

                    !Third step - Compute the direction of the the turbulent vector taking in consideration the layers thickness gradients
                    ! Spagnol et al. (Mar. Ecol. Prog. Ser., 235, 299-302, 2002).                        

                    if (CurrentOrigin%Movement%TurbGradK) then
                        ![m/s] = [m/s] + [m^2/s] * [1/m] 
                        UD = UD + DiffusionCoefH * GradDWx
                        VD = VD + DiffusionCoefH * GradDWy
                    endif                                    
                        
                   
                else if (CurrentOrigin%Movement%MovType .EQ. NotRandom_    ) then MT

                    UD = 0.0   
                    VD = 0.0    

                end if MT

                !Velocity due plume
                if (CurrentOrigin%State%PlumeShear) then    
                    Radius = (0.75 * CurrentPartic%Geometry%Volume/Pi) ** 0.33333
                    Area   = Pi * Radius ** 2.
                    VolOld = CurrentPartic%Geometry%Volume - CurrentPartic%Geometry%VolVar
                    VolNew = CurrentPartic%Geometry%Volume
                    dVol   = CurrentPartic%Geometry%VolVar

                    !Acceleration due drag force
                    Modulus = sqrt((UINT - CurrentPartic%U)**2. + (VINT - CurrentPartic%V)**2.)

                
                                       !Momentum diffusion by small scale turbulence
                    CurrentPartic%U =  CurrentPartic%U * VolOld / VolNew + dVol * UINT / VolNew 

                                       !Momentum diffusion by small scale turbulence
                    CurrentPartic%V =  CurrentPartic%V * VolOld / VolNew + dVol * VINT / VolNew 


                    CurrentPartic%RelU = CurrentPartic%U - UINT
                    CurrentPartic%RelV = CurrentPartic%V - VINT

                    !aqui MJ
                    
                    if (CurrentOrigin%Movement%MovType .NE. NotRandom_ ) then
                    
                        CurrentPartic%SD   = StandardDeviation
                    
                    endif    

                endif


                if (CurrentOrigin%Movement%Advection) then

                    if (CurrentOrigin%State%PlumeShear) then    
                        DX = CurrentPartic%U *  Me%DT_Partic
                        DY = CurrentPartic%V *  Me%DT_Partic
                        !large scale turbulence
                        DX = DX + UD *  Me%DT_Partic
                        DY = DY + VD *  Me%DT_Partic
                    elseif (CurrentOrigin%State%FloatingObject) then
                        DX = (UDrift + UD) * Me%DT_Partic
                        DY = (VDrift + VD) * Me%DT_Partic
                    else
                        DX = (UINT + UD + UWIND + UOIL + UHNS + UStokesDrift) * Me%DT_Partic
                        DY = (VINT + VD + VWIND + VOIL + VHNS + VStokesDrift) * Me%DT_Partic
                    endif
                else
                    DX         =  UD           * Me%DT_Partic
                    DY         =  VD           * Me%DT_Partic
                    DXrand     =  DX
                    DYrand     =  DY
                endif

                
                HaveDomain = .false. 

d1:             do em = 1, Me%EulerModelNumber
               
                    HaveDomain = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid, &
                                   CurrentPartic%Position%CoordX,                       &
                                   CurrentPartic%Position%CoordY,                       &
                                   Referential= GridCoord_, STAT = STAT_CALL)
                    
                    if (STAT_CALL /= SUCCESS_ ) then
                        stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR20'
                    endif                        

                    if (HaveDomain .and. em == emp) then
                    
                        !do not change domain 
                        ComputeTrajectory   = .false.
                        !NewPosition%ModelID = emp                 
                        exit
                    endif
                    

                
iHD:                if (HaveDomain) then

                        AuxPosition = CurrentPartic%Position

                        !Convert Coordinates
                        call Convert_XY_CellIJ(Me%EulerModel(em), AuxPosition, Referential = GridCoord_)

iOpen2D:                if  (Me%EulerModel(em)%OpenPoints3D(AuxPosition%i, AuxPosition%j, &
                                                            Me%EulerModel(em)%WorkSize%KUB) == OpenPoint) then


                            call Convert_Z_CellK (CurrentOrigin, Me%EulerModel(em), AuxPosition, PositionCorrected)
                            call Convert_CellK_K (                                  AuxPosition)

                            CurrentPartic%Position         = AuxPosition
                            
                            CurrentPartic%Position%ModelID = em                            

                            ComputeTrajectory = .true.

                        else iOpen2D

                            !If a particle doesnt move the Freezed state is ON
                            CurrentPartic%Freezed    = ON

                            CurrentPartic%TpercursoH = abs(null_real)

                            ComputeTrajectory = .false.

                        endif iOpen2D

                        exit
                    endif iHD

                enddo d1

                if (.not. HaveDomain) then                            
                    ComputeTrajectory        = .false. 
                    CurrentPartic%KillPartic = ON 
                endif

            enddo CT

            MovePartic = .true.

            if (CurrentPartic%Beached           .or.                                    &
                CurrentPartic%Deposited         .or.                                    &
                CurrentPartic%AtTheBottom       .or.                                    &
                (CurrentPartic%HNSParticleState .EQ. Bottom_Deposited_)      .or.       &
                CurrentPartic%KillPartic) then
                MovePartic = .false.
            endif 
            
!            if (MovePartic .and. NewPosition%ModelID < 0) then
!                MovePartic = .false.
!            endif
            ! A two steps approach:
            !   1 - first the particles makes a jump considering all the processes. 
            !   2 - Only the random components are considered
dts:        do ts = 1, 2

                if     (ts == 1) then
                    !New Position
                    NewPosition%X = CurrentPartic%Position%X + DX 
                    NewPosition%Y = CurrentPartic%Position%Y + DY 
                    
                    DXn           = DX
                    DYn           = DY
                    
                elseif (ts == 2) then
                    !New Position
                    NewPosition%X = CurrentPartic%Position%X + DXrand 
                    NewPosition%Y = CurrentPartic%Position%Y + DYrand   
                    
                    DXn           = DXrand
                    DYn           = DYrand                              
                endif    
                
                !As a first approach
                NewPosition%ModelID = CurrentPartic%Position%ModelID
                NewPosition%I       = CurrentPartic%Position%I
                NewPosition%J       = CurrentPartic%Position%J
                
                call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),NewPosition,  &
                                       Referential = AlongGrid_, ConvertOK = ConvertOK)                 
                                           
                if (ConvertOK) then
                    Npi = 1
                else
                    Npi = 100
                endif
                
                !New Position
                NewPosition%X = CurrentPartic%Position%X 
                NewPosition%Y = CurrentPartic%Position%Y               
                
    dnp:        do Npj = 1, Npi
                
                    !New Position
                    NewPosition%X = NewPosition%X + DXn / real(Npi)
                    NewPosition%Y = NewPosition%Y + DYn / real(Npi)   
                    
                    NewPosition%I = CurrentPartic%Position%I
                    NewPosition%J = CurrentPartic%Position%J
                    
                    !Convert Coordinates
                    call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),NewPosition,  &
                                                         Referential = AlongGrid_,          &
                                                         ConvertOK   = ConvertOK)                 
                    if (.not.ConvertOK) then
                        !stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR30'
                        !If it is not possible to convert it is assumed an anomaly related with land points + plus nesting model interface
                        !In this case the particle do not move from the original position 
                        !If a particle doesnt move the Freezed state is ON
                        CurrentPartic%Freezed    = ON
                        CurrentPartic%TpercursoH = abs(null_real)
                        write(*,*) 'Particle ID=', CurrentPartic%ID
                        write(*,*) 'New model domain =',NewPosition%ModelID  
                        write(*,*) 'Anomalous movement was detected' 
                        write(*,*) 'New position = land point + nesting model interface' 
                        write(*,*) 'Freezed condition is assumed'
                        exit
                    endif

                    HaveDomain = .false. 
                    
    d11:            do em = 1, Me%EulerModelNumber
                   
                        HaveDomain = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid, &
                                       NewPosition%CoordX,                                  &
                                       NewPosition%CoordY,                                  &
                                       Referential= GridCoord_, STAT = STAT_CALL)
                        
                        if (STAT_CALL /= SUCCESS_ ) then
                            stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR40'
                        endif       
                        
                        if (HaveDomain) then
                            
                            NewPosition%ModelID = em
                            NewPosition%I       = null_int
                            NewPosition%J       = null_int
                        
                            !Needs to change to along grid referential
                            call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),NewPosition,  &
                                                                 Referential = GridCoord_,          &
                                                                 ConvertOK   = ConvertOK)                
                                                                 
                            if (.not. ConvertOK) then                                                        
                                stop 'MoveParticHorizontal - ModuleLagrangianGlobal - ERR60'
                            endif               
                                         
                            exit                 
                            
                        endif
                            
                    enddo d11
                    
                    if (.not.HaveDomain) then
                        MovePartic               = .false. 
                        CurrentPartic%KillPartic = ON 
                        exit
                    endif                      
                                     
iMP:                if (MovePartic) then

                        exitDoCycle = .false. 

                        call CheckThinStructures(CurrentOrigin, CurrentPartic, NewPosition, MovePartic, exitDoCycle)
                        
                        if (exitDoCycle) exit dts
                    
                    endif iMP
                    
    iFKP:           if (MovePartic) then

                        CurrentPartic%Freezed = .false. 
                        
                        !NewPosition%I = CurrentPartic%Position%I
                        !NewPosition%J = CurrentPartic%Position%J
                        
                        !Convert Coordinates
                        !call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),NewPosition,  &
                        !                                     Referential = AlongGrid_, ConvertOK = ConvertOK)

                        !Verifies new position
                        NewI = NewPosition%i
                        NewJ = NewPosition%j
                        KUB  = Me%EulerModel(NewPosition%ModelID)%WorkSize%KUB                   
                        
                        !It assumes that is no water point
    ie:                 if  (Me%EulerModel(NewPosition%ModelID)%OpenPoints3D(NewI, NewJ, KUB) /= OpenPoint) then

                            !If it isnt a OpenPoint, reset TPercurso
                            CurrentPartic%TpercursoH = abs(null_real)
                            
                            
    isc:                    if (CurrentOrigin%Movement%SlipCondition .and.              &
                                CurrentPartic%Position%ModelID == NewPosition%ModelID) then
                                !Slip condition should not be used when there as jump between domains
                                call ParticSlipCondition(CurrentPartic, NewPosition)

                             else isc
                            
                                !If a particle doesnt move the Freezed state is ON
                                CurrentPartic%Freezed    = ON
                             endif isc    

                        !else Moves it 
                        
                        endif ie
                        
        ie1:            if (CurrentPartic%Freezed) then
                            
                            CurrentPartic%TpercursoH = abs(null_real)

                         else  ie1                   
                         
                            do i=1, Me%Vert_Steps

                                call MoveParticVertical  (CurrentOrigin, CurrentPartic, NewPosition, VelModH)

                                call Convert_Z_CellK (CurrentOrigin, Me%EulerModel(NewPosition%ModelID), &
                                                                     NewPosition, PositionCorrected)
                                call Convert_CellK_K (               NewPosition)
                            
                                !If PositionCorrected initialize the vertical random dispersion in the next step
                                if (PositionCorrected) then
                                    CurrentPartic%TpercursoZ = abs(null_real)
                                    !CurrentPartic%W = 0.
                                endif
                           

                                !If a particle moved the Freezed state is OFF
                                CurrentPartic%Freezed   = OFF

                                !Stores New Position
                                CurrentPartic%Position  = NewPosition
                                
                                if(CurrentOrigin%State%HumanBody .and. CurrentOrigin%HumanBody%Drowned)then
                                    if (PositionCorrected) then
                                    
                                        CurrentPartic%AtTheBottom = ON
                                        
                                    endif
                                endif

                                if (CurrentOrigin%State%Deposition) then
                            
                                    CurrentPartic%Deposited = VerifyDeposition(CurrentOrigin, CurrentPartic)

                                endif
                                
                            enddo

                        endif ie1

                    endif iFKP

                enddo dnp
                
                if (ts == 1) then
                    if (MovePartic .and. .not. CurrentPartic%Freezed) exit 
                endif
                
            enddo dts                
            
            CurrentPartic => CurrentPartic%Next

        enddo CP

    end subroutine MoveParticHorizontal

    !--------------------------------------------------------------------------
    
    subroutine CheckThinStructures(CurrentOrigin, CurrentPartic, NewPosition, MovePartic, exitDoCycle)
    
        !Arguments----------------------------------------------------------------------
        type (T_Origin),   pointer                  :: CurrentOrigin
        type (T_Partic),   pointer                  :: CurrentPartic        
        type (T_Position)                           :: NewPosition
        logical                                     :: MovePartic
        logical                                     :: exitDoCycle
        
        !Local--------------------------------------------------------------------------
        integer                                     :: nn, lp
        real                                        :: LineAngle, AuxAngle, IntersectVel
        real                                        :: CurrentIntensity
        type (T_PointF),   pointer                  :: ParticPoint, LinePoint
        type (T_Lines),    pointer                  :: CurrLine
        logical                                     :: ParticleInsideBuffer
        integer                                     :: it, jt, kt, emt
        real                                        :: Rand1
        
        !Begin--------------------------------------------------------------------------        
        
        exitDoCycle = .false. 
    
        if ((Me%Booms%ON .and. CurrentPartic%Position%Surface) .or. Me%ThinWallsON) then
    
            !if (ConvertOK) then                                                         

            if (Me%Booms%ON .and. CurrentPartic%Position%Surface) then
    
donn:           do nn = 1, Me%Booms%Number
                    !if has buffer check if particle movement intersects buffer around boom points
                    !this is usefull if boom moves and/or between time steps particles go trough the boom
ifbuf:              if (Me%Booms%Individual(nn)%BoomHasBuffer) then
                        
                        ParticleInsideBuffer = .false.
                        allocate(ParticPoint)
                        allocate(LinePoint)
             
                        CurrLine => Me%Booms%Individual(nn)%Lines
                        
                        !go for all line points and check if particle is inside the buffer
dolp:                   do lp = 1, CurrLine%nNodes
                            
                            LinePoint%X = CurrLine%X(lp)
                            LinePoint%Y = CurrLine%Y(lp)
                            ParticPoint%X = CurrentPartic%Position%CoordX
                            ParticPoint%Y = CurrentPartic%Position%CoordY
                            
                            if(IsPointInsideCircle(ParticPoint, LinePoint, &
                                                   Me%Booms%Individual(nn)%BoomBufferDist))then 
                                ParticleInsideBuffer = .true.
                                exit dolp                                               
                            else
                                
                                ParticPoint%X = NewPosition%CoordX
                                ParticPoint%Y = NewPosition%CoordY
                                
                                if(IsPointInsideCircle(ParticPoint, LinePoint, &
                                                       Me%Booms%Individual(nn)%BoomBufferDist))then
                                    ParticleInsideBuffer = .true.
                                    exit dolp                                                   
                                endif                                                
                            
                            endif
                            
                        enddo dolp
                                                             
                        deallocate(ParticPoint)
                        deallocate(LinePoint)
                        nullify(CurrLine)
                        
                        if (ParticleInsideBuffer) then
                        
                            if (CurrentPartic%WaveHeight < Me%Booms%Individual(nn)%WaveLimit) then
                                MovePartic = .false.
                                exit donn
                            endif   
                        endif
                            
                    else !intersect old and new particle position segment with boom segments                                               
                        
                        if (SegIntersectLine(                               &
                            x1      = CurrentPartic%Position%CoordX,        &
                            y1      = CurrentPartic%Position%CoordY,        &
                            x2      = NewPosition%CoordX,                   &
                            y2      = NewPosition%CoordY,                   &
                            LineX   = Me%Booms%Individual(nn)%Lines,        &    
                            LineAng = LineAngle)) then                                            
                            
                            CurrentIntensity = sqrt(CurrentPartic%CurrentX**2 + CurrentPartic%CurrentY**2)
                            
                            if (CurrentIntensity > 0.) then
                                AuxAngle         = atan2(CurrentPartic%CurrentY,CurrentPartic%CurrentX) - (LineAngle+Pi/2.)
                            else
                                AuxAngle         = 0.
                            endif                   
                                         
                            IntersectVel     = abs(cos(AuxAngle) * CurrentIntensity)
                        
                            if (CurrentPartic%WaveHeight < Me%Booms%Individual(nn)%WaveLimit .and. &
                                IntersectVel             < Me%Booms%Individual(nn)%VelLimit) then
                                MovePartic = .false.
                                exit donn
                            endif 
                       endif
                    endif ifbuf
                enddo donn
            endif
            
            if (MovePartic .and. Me%ThinWallsON) then
    
                if (SegIntersectPolygon(                                        &
                    x1              = CurrentPartic%Position%CoordX,            &
                    y1              = CurrentPartic%Position%CoordY,            &
                    x2              = NewPosition%CoordX,                       &
                    y2              = NewPosition%CoordY,                       &
                    PolygonX        = Me%ThinWalls,                             &
                    AreaOfInterest  = Me%GridsBounds)) then
                    
                    MovePartic  = .false.

                    if(CurrentOrigin%Beaching .and. .not. CurrentOrigin%CoastlineBeaching)then

                        call RANDOM_NUMBER(Rand1)
                        
                        it  = CurrentPartic%Position%i
                        jt  = CurrentPartic%Position%j                        
                        kt  = CurrentPartic%Position%k                        
                        emt = CurrentPartic%Position%ModelID
                        
                        if ((Me%EulerModel(emt)%BeachingProbability(it,jt,kt) .GT. Rand1) .OR.   &
                            (Me%EulerModel(emt)%BeachingProbability(it,jt,kt) .EQ. 1)) then  
                            CurrentPartic%Beached = ON
                        endif

                    endif
                    
                    exitDoCycle = .true.
                    
                endif
            endif

        endif                                        

    end subroutine CheckThinStructures

    !----------------------------------------------------------------------
    
    
    subroutine ParticSlipCondition(CurrentPartic, NewPosition)

        !Arguments-------------------------------------------------------------
   
        type (T_Partic),   pointer                  :: CurrentPartic
        type (T_Position)                           :: NewPosition        
        !Local-----------------------------------------------------------------
        type (T_Position)                           :: OldPosition, AuxPosition        
        logical                                     :: SlipConditionX, SlipConditionY, HaveDomain
        integer                                     :: NewI, NewJ, KUB, emX, emY, STAT_CALL

        !Begin-----------------------------------------------------------------
    
        OldPosition            = CurrentPartic%Position
        AuxPosition            = NewPosition
       
        !Tries to use the non slip condition
        
        !Freaze the X direction
        AuxPosition%X      = OldPosition%X
        AuxPosition%CartX  = OldPosition%CartX                    
        AuxPosition%CoordX = OldPosition%CoordX                                        
        AuxPosition%J      = OldPosition%J
        AuxPosition%CellJ  = OldPosition%CellJ            
        
        SlipConditionX = .false.
        
d33:    do emX = 1, Me%EulerModelNumber
    
            HaveDomain = GetXYInsideDomain(Me%EulerModel(emX)%ObjHorizontalGrid, &
                           AuxPosition%CoordX, AuxPosition%CoordY,              &
                           Referential= GridCoord_, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ParticSlipCondition - ModuleLagrangianGlobal - ERR10'

            if (HaveDomain .and. NewPosition%ModelID == emX) then
                SlipConditionX = .true.
                exit
            endif
        enddo d33
        
scx:    if (SlipConditionX) then

            !Convert Coordinates
            call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),AuxPosition, Referential = GridCoord_)

            !Verifies new position
            NewI = AuxPosition%i
            NewJ = AuxPosition%j
            KUB  = Me%EulerModel(NewPosition%ModelID)%WorkSize%KUB
            
ix:         if  (Me%EulerModel(NewPosition%ModelID)%OpenPoints3D(NewI, NewJ, KUB) == OpenPoint) then
            
                NewPosition = AuxPosition
                
            else ix
            
                AuxPosition = NewPosition

               !Freaze the Y direction
                AuxPosition%Y      = OldPosition%Y
                AuxPosition%CartY  = OldPosition%CartY
                AuxPosition%CoordY = OldPosition%CoordY
                AuxPosition%I      = OldPosition%I
                AuxPosition%CellI  = OldPosition%CellI
                
                SlipConditionY = .false.
                
d34:            do emY = 1, Me%EulerModelNumber
            
                    HaveDomain = GetXYInsideDomain(Me%EulerModel(emY)%ObjHorizontalGrid, &
                                   AuxPosition%CoordX, AuxPosition%CoordY,              &
                                   Referential= GridCoord_, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ParticSlipCondition - ModuleLagrangianGlobal - ERR10'

                    if (HaveDomain .and. NewPosition%ModelID == emY) then
                        SlipConditionY = .true.
                        exit
                    endif
                    
                enddo d34
                
scy:            if (SlipConditionY) then
                
                    !Convert Coordinates
                    call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),AuxPosition, Referential = GridCoord_)

                    !Verifies new position
                    NewI = AuxPosition%i
                    NewJ = AuxPosition%j

iy:                 if  (Me%EulerModel(NewPosition%ModelID)%OpenPoints3D(NewI, NewJ, KUB) == OpenPoint) then
                    
                        NewPosition = AuxPosition
                    
                    else iy

                        !If a particle doesnt move the Freezed state is ON
                        CurrentPartic%Freezed    = ON
                      
                    endif iy
                    
                else scy
                    !If a particle doesnt move the Freezed state is ON
                    CurrentPartic%Freezed    = ON
                endif scy
                
            endif ix
            
        else scx
            !If a particle doesnt move the Freezed state is ON
            CurrentPartic%Freezed    = ON
        endif scx
                                            
    end subroutine ParticSlipCondition
    
    !--------------------------------------------------------------------------    

    logical function VerifyRessuspension(CurrentPartic, CurrentOrigin)

        !Arguments-------------------------------------------------------------
   
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Origin), pointer                    :: CurrentOrigin
        
        !Local-----------------------------------------------------------------
        real, save                                  :: Ranval
        logical                                     :: VerifyShearStress, VerifyErosionRate
        integer                                     :: i, j, emp
        real                                        :: TauStress, dS, r1        
        !Begin-----------------------------------------------------------------

        i = CurrentPartic%Position%I
        j = CurrentPartic%Position%J
        emp= CurrentPartic%Position%ModelID

        VerifyRessuspension = OFF

        VerifyShearStress   = OFF
        VerifyErosionRate   = OFF

        !Partheniades, E., 1965. Erosion and deposition of cohesive soils.
        !J. Hydr. Div., ASCE 91 HY1 , 105139.
     
        !The ressuspension of a tracer is function of the bottom shear stress
        !and of the erosion rate. The erosion rate (Er) is quantifiied in the form of
        !a probability that is equal to  min (1, Er * dt / MassSedTotal(i,j))

        !TauStress = Me%EulerModel(emp)%BottomStress(CurrentPartic%Position%I,           &
        !                                            CurrentPartic%Position%J)   
        
        TauStress = CurrentPartic%BottomStress
        
        if (CurrentOrigin%Deposition%TauUncertainty > 0) then
                            
            call random_number(r1)                            
                            
            dS = CurrentOrigin%Deposition%TauUncertainty *  2 * r1 + (1 - CurrentOrigin%Deposition%TauUncertainty)
                            
            TauStress = TauStress * dS
                            
        endif           
        
        
cd1:    if (TauStress >= CurrentPartic%TauErosionMix) then

            VerifyShearStress = ON

         endif cd1

        if (VerifyShearStress) then

            call random_number(Ranval)

            if (CurrentPartic%ErosionRateProbability > RanVal) VerifyErosionRate = ON


        endif

        if (VerifyShearStress .and. VerifyErosionRate) VerifyRessuspension = ON
       
    end function VerifyRessuspension

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------    

    logical function VerifyDeposition(CurrentOrigin, CurrentPartic)

        !Arguments-------------------------------------------------------------
   
        type (T_Origin),     pointer                :: CurrentOrigin
        type (T_Partic),     pointer                :: CurrentPartic
        !Local-----------------------------------------------------------------
        real                                        :: Aux
        real, save                                  :: Ranval
        integer                                     :: i, j, kbottom, emp
        real                                        :: TauStress, dS, r1
        !Begin-----------------------------------------------------------------        

        i = CurrentPartic%Position%I
        j = CurrentPartic%Position%J
        !k = CurrentPartic%Position%K
        emp= CurrentPartic%Position%ModelID

        kbottom = Me%EulerModel(emp)%KFloor(i, j)

        VerifyDeposition = OFF

cd1:    if (CurrentOrigin%Deposition%BottomDistance    >=                               &
            (Me%EulerModel(emp)%SZZ(i, j, kbottom -1)- CurrentPartic%Position%Z)) then

!Odd, N.V.M., Owen, M.W., 1972. A two-layer model of mud transport in the Thames estuary. 
!In: Proceedings. Institution of Civil Engineers, London, pp. 195-202.
    
            !TauStress = Me%EulerModel(emp)%BottomStress(i,j)
            
            TauStress = CurrentPartic%BottomStress
    
            if (CurrentOrigin%Deposition%TauUncertainty > 0) then
                            
                call random_number(r1)                            
                            
                dS = CurrentOrigin%Deposition%TauUncertainty *  2 * r1 + (1 - CurrentOrigin%Deposition%TauUncertainty)
                            
                TauStress = TauStress * dS
            endif                            
    
    
cd2:        if (TauStress < CurrentOrigin%Deposition%TauDeposition) then
                            
                call random_number(Ranval)

                Aux = (CurrentOrigin%Deposition%TauDeposition - TauStress) /            &
                       CurrentOrigin%Deposition%TauDeposition

                !if BottomStress = 0 => Aux = 1 and Aux is always > Randval
                !In this case the probability of the particle be deposited is 100%
                if (Aux > Ranval) VerifyDeposition = ON

            endif cd2

        endif cd1

    end function VerifyDeposition


    real function LinearInterpolationCell(Val1, Val2, Coef)
        
        !Arguments-------------------------------------------------------------
        real                                        :: Val1, Val2, Coef
            
        !Begin-----------------------------------------------------------------

        LinearInterpolationCell = Val1 * (1.0-Coef) +  Val2 * Coef

    end function LinearInterpolationCell    

    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------
    !Drift velocity based on an analytical solution proposed by Daniel, Pierre, 2002,
    !"Drift Modelling of Cargo Containers" (Spill Science & Technology Bulletin);
    ! but without the assumption of a null water current;
    !(In the next few months a numerical solution will also be implemented)
    real function GetDriftVelocity(var_a, var_b, var_c,var_d,var_e,var_f,var_g)
        
        !Arguments-------------------------------------------------------------
        real                                        :: var_a, var_b, var_c, var_d, var_e, var_f, var_g
        real                                        :: First, Second, Third, Forth, Fifth, Sixth, Seventh 

        !Begin-----------------------------------------------------------------
        First  = - 2 * var_a * var_b * var_c  * var_d + 200 * var_a * var_b * var_d - 2 * var_c * var_e * var_f * var_g
        Second = var_a * var_b * var_c - 100 * var_a * var_b + var_c * var_e * var_f
        Third  = var_a * var_b * var_c * var_d * var_d - 100 * var_a * var_b * var_d * var_d + var_c * var_e * var_f * var_g * var_g
        Forth  = var_a * var_b * var_c * var_d
        Fifth  = var_a * var_b * var_d
        Sixth  = var_c * var_e * var_f * var_g
        Seventh= var_a * var_b * var_c - 100 * var_a * var_b + var_c * var_e * var_f

        If (var_d > var_g) then
                GetDriftVelocity =  (SQRT(abs(First*First-4*Second*Third)) + 2*Forth - 200*Fifth + 2*Sixth)/(2*Seventh)
        else
                GetDriftVelocity =  (-SQRT(abs(First*First-4*Second*Third)) + 2*Forth - 200*Fifth + 2*Sixth)/(2*Seventh)
        end if


    end function GetDriftVelocity    
    
    !--------------------------------------------------------------------------
   

    subroutine MoveParticVertical(CurrentOrigin, CurrentPartic,           &
                                  NewPosition, VelModH)

        !Arguments-------------------------------------------------------------
   
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Position)                           :: NewPosition
        real, intent (IN )                          :: VelModH

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: i, j, k, KUB, emp, kFloor, iP
        real                                        :: CellK, BALZ, SST
        real                                        :: CompZ_Up, CompZ_Down
        real                                        :: CompZ1_Up, CompZ1_Down
        real                                        :: AuxCompMisturaZ_Up, AuxCompMisturaZ_Down
        real                                        :: EspSup, Esp, EspInf
        real                                        :: VELQZ, D50M, VQ1, VELFLOAT, VELLARVAE, VELBODY, VELHNS
        real                                        :: WStandardDeviation
        real                                        :: W, WD
        real                                        :: Radius, Area, VolOld, VolNew, dVol
        real                                        :: ai, dw, Cd, DeltaD, AuxW
        real                                        :: r1, r2, correction
        real                                        :: WaveHeight, WavePeriod, Wind
        real                                        :: DT_Vert        
        integer                                     :: Light_Index 
        real                                        :: BottomDepth, SurfaceDepth
        type(T_Larvae), pointer                     :: LarvaePtr
        real                                        :: SPMDensity, WaterDensity
        integer                                     :: STAT_CALL
        real                                        :: DistSurface, DistBottom, RAND
        real                                        :: SedVel, dS
        real                                        :: DiffusionCoefV
        real                                        :: TauCritic, dx1, dx2

        !------------------------------------------------------------------------

        i       = CurrentPartic%Position%I
        j       = CurrentPartic%Position%J
        emp     = CurrentPartic%Position%ModelID
        KUB     = Me%EulerModel(emp)%WorkSize%KUB

        SurfaceDepth = Me%EulerModel(emp)%SZZ(i, j, KUB)

MD:     if (CurrentOrigin%Position%MaintainDepth) then
            NewPosition%Z = SurfaceDepth + CurrentOrigin%Position%DepthWithWaterLevel
        else MD
    MF:     if (CurrentOrigin%Movement%Float) then

                NewPosition%Z = Me%EulerModel(emp)%SZZ(i, j, KUB)

            else MF
            
                kFloor  = Me%EulerModel(emp)%kFloor(i, j)
                
                if (kFloor < 1) then
                    write(*,*) 'Domain =', emp
                    write(*,*) 'Cell I =', i
                    write(*,*) 'Cell J =', j
                    stop 'MoveParticVertical - ModuleLagrangianGlobal - ERR10'
                endif            

                BottomDepth     =   Me%EulerModel(emp)%WaterColumn(i, j)
                DistSurface     =   CurrentPartic%Position%Z - SurfaceDepth
                DistBottom      =   Me%EulerModel(emp)%SZZ(i, j, kFloor) - CurrentPartic%Position%Z

                k       = CurrentPartic%Position%K
                CellK   = CurrentPartic%Position%CellK
                BALZ    = CellK - int(CellK)
                
                DT_Vert = Me%DT_Partic / real(Me%Vert_Steps)
            
    SA:         if (CurrentOrigin%Movement%MovType == SullivanAllen_) then

                    CompZ_Up   = Me%EulerModel(emp)%Lupward  (i, j, k)
                    CompZ_Down = Me%EulerModel(emp)%Ldownward(i, j, k)

                    if ((CompZ_Up < 0.0) .OR. (CompZ_Down < 0.0)) then
                        CompZ_Up   = 0.0
                        CompZ_Down = 0.0
                    end if
        
                    if ((Me%EulerModel(emp)%WorkSize%KUB -                                     &
                         Me%EulerModel(emp)%WorkSize%KLB + 1) > 1) then 

                        EspSup = Me%EulerModel(emp)%DWZ(i, j, k+1)
                        Esp    = Me%EulerModel(emp)%DWZ(i, j, k  )
                        EspInf = Me%EulerModel(emp)%DWZ(i, j, k-1)

                        if ((K /= Me%EulerModel(emp)%WorkSize%KLB) .AND.              &
                            (BALZ < 0.5)) then       !Close to the bottom

                            CompZ1_Up   = Me%EulerModel(emp)%Lupward  (i, j, k-1)
                            CompZ1_Down = Me%EulerModel(emp)%Ldownward(i, j, k-1)

                            AuxCompMisturaZ_Up   = 2.0 * (CompZ1_Up * (0.5 - BALZ) * Esp +   &
                                                   CompZ_Up * BALZ * Esp + CompZ_Up * 0.5 *  &
                                                   EspInf) / (Esp + EspInf)

                            AuxCompMisturaZ_Down = 2.0 * (CompZ1_Down * (0.5 - BALZ) * Esp + &
                                                   CompZ_Down * BALZ * Esp + CompZ_Down *    &
                                                   0.5 * EspInf) / (Esp + EspInf)
                     
                        else if ((K /= Me%EulerModel(emp)%WorkSize%KUB) .AND.                  &
                                 (BALZ .GT. 0.5 )) then !Close to the surface

                            CompZ1_Up   = Me%EulerModel(emp)%Lupward  (i, j, k+1)
                            CompZ1_Down = Me%EulerModel(emp)%Ldownward(i, j, k+1)

                            AuxCompMisturaZ_Up   = 2.0 * (CompZ1_Up * (0.5 - BALZ) * Esp +   &
                                                   CompZ_Up * BALZ * Esp + CompZ_Up * 0.5 *  &
                                                   EspInf) / (Esp + EspInf)

                            AuxCompMisturaZ_Down = 2.0 * (CompZ1_Down * (0.5 - BALZ) * Esp + &
                                                   CompZ_Down * BALZ * Esp + CompZ_Down *    &
                                                   0.5 * EspInf) / (Esp + EspInf)
                        else

                            AuxCompMisturaZ_Up   = CompZ_Up
                            AuxCompMisturaZ_Down = CompZ_Down           

                        endif

                    else !1 Layer

                        AuxCompMisturaZ_Up   = CompZ_Up
                        AuxCompMisturaZ_Down = CompZ_Down           

                    endif

                endif SA



    DP:         if (CurrentOrigin%State%Sedimentation) then

                    if (CurrentOrigin%Movement%SedimentationType .EQ. Stokes_ ) then

                        D50M  =  CurrentOrigin%Movement%D50 / 1000.0 ! passagem para metros 
                        VQ1   =  0.4949 * LOG10(D50M)**2.0 + 2.1795 * LOG10(D50M) + 3.7394  
                        VELQZ =  -1.0 / (10.0**VQ1)                                          

                        if (abs(CurrentOrigin%Movement%MinSedVel) > ABS(VELQZ))              &
                            VELQZ =  -1. * CurrentOrigin%Movement%MinSedVel

                    else if (CurrentOrigin%Movement%SedimentationType .EQ. Imposed_) then

                        if (CurrentOrigin%Movement%SedVelUncertainty > 0) then
                            
                            call random_number(r1)                            
                            
                            dS = CurrentOrigin%Movement%SedVelUncertainty *  2 * r1 + (1 - CurrentOrigin%Movement%SedVelUncertainty)
                            
                            SedVel = CurrentOrigin%Movement%SedVel * dS
                            
                            VELQZ =  -1. * SedVel
                            
                        else
                            VELQZ =  -1. * CurrentOrigin%Movement%SedVel
                        endif  
                        
                    else if (CurrentOrigin%Movement%SedimentationType .EQ. FergusonChurch2004_) then
                        
                        if (CurrentPartic%D50vel == FillValueReal) then
                        
                            call random_number(r1)
                            
                            r1 = r1 * 100
                            
                            do i=1, CurrentOrigin%Movement%nDiameterClasses
                            
                                if (r1 < CurrentOrigin%Movement%DiameterClasses(i, 2)) then
                                    exit
                                endif
                            enddo
                            
                            dx1 = r1 - CurrentOrigin%Movement%DiameterClasses(i-1, 2)
                            dx2 = CurrentOrigin%Movement%DiameterClasses(i, 2) - r1
                            
                            ! mm                            
                            D50M =  (dx1 * CurrentOrigin%Movement%DiameterClasses(i  , 1) +  &
                                     dx2 * CurrentOrigin%Movement%DiameterClasses(i-1, 1)) / (dx1 + dx2)
                            
                            !from mm to m
                            D50M = D50M / 1000.         
                            
                            SedVel = 1.65*9.8*D50M**2/(18*1e-6+SQRT(0.75*1.65*9.8*D50M**3))                            
                            
                            CurrentPartic%D50vel = SedVel                            

                            CurrentPartic%D50    = D50M
                            
                            TauCritic = 0.035 * Gravity * 1650. * D50M
                            
                            CurrentPartic%TauDeposition = max (TauCritic, CurrentOrigin%Deposition%TauDeposition)
                            CurrentPartic%TauErosion    = max (TauCritic, CurrentOrigin%Deposition%TauErosion)
                            
                        else
                            
                            SedVel = CurrentPartic%D50vel
                        
                        endif                            
                        
                        

                        if (CurrentOrigin%Movement%SedVelUncertainty > 0) then
                            
                            call random_number(r1)                            
                            
                            dS = CurrentOrigin%Movement%SedVelUncertainty *  2 * r1 + (1 - CurrentOrigin%Movement%SedVelUncertainty)
                            
                            SedVel = SedVel * dS
                            
                        endif                            
                            
                        VELQZ =  -1. * SedVel
                            

                    else if (CurrentOrigin%Movement%SedimentationType .EQ. DensDynamic_) then   
                    
                        VELQZ = DropletsFloatVel(ParticleDensity = CurrentOrigin%Movement%Density, &
                                                 WaterDensity    = Me%EulerModel(emp)%Density(i, j, k), &
                                                 Diameter        = CurrentOrigin%Movement%D50, &
                                                 MethodFloatVel  = CurrentOrigin%MethodFloatVel, &
                                                 InterfTension   = CurrentPartic%OWInterfacialTension)
                        
                        CurrentPartic%D50vel = VELQZ 
                        CurrentPartic%D50    = CurrentOrigin%Movement%D50
                        
                    else if (CurrentOrigin%Movement%SedimentationType .EQ. SecondaryClarifier_) then 
                    
                        CurrentProperty => CurrentOrigin%FirstProperty
                        iP = 1
                        do while (associated(CurrentProperty))

                            if (CurrentProperty%ID == Cohesive_Sediment_) then

                                call GetAmbientConcPartic (CurrentProperty, iP, emp, CurrentPartic, SST)
                                SST = SST / 1000.
                                VELQZ = - SettlingVelSecondaryClarifier (SST, WithCompression = .true.)
                                exit
                                
                            endif
                            iP = iP + 1
                            CurrentProperty => CurrentProperty%Next
                        enddo 
                        
                        nullify(CurrentProperty)
                        
                    else

                        VELQZ = 0.0

                    end if

                else

                    VELQZ = 0.0

                end if DP


    MT:         if (CurrentOrigin%Movement%MovType .EQ. SullivanAllen_) then
    
                    !To avoid particles to concentrated in the surface
                    if (AuxCompMisturaZ_Up > DistSurface) then
                        if (DistSurface > 0.) then
                            AuxCompMisturaZ_Up = DistSurface
                        else
                            AuxCompMisturaZ_Up = 0.         
                        endif
                    endif
                    !To avoid particles to concentrated in the bottom                                                                           
                     if (AuxCompMisturaZ_Down > DistBottom) then
                        if (DistBottom > 0.) then
                            AuxCompMisturaZ_Down = DistBottom
                        else
                            AuxCompMisturaZ_Down = 0.         
                        endif
                    endif

                    select case (CurrentOrigin%Movement%StandardDeviationType)
                    
                    case (VerticalTurbConstant) 

                        WStandardDeviation = CurrentOrigin%Movement%VarVelVX * VelModH +     &
                                             CurrentOrigin%Movement%VarVelV

                        WD = WD_(CurrentPartic, WStandardDeviation, AuxCompMisturaZ_Up,      &
                                 AuxCompMisturaZ_Down, DT_Vert)

                    case (VerticalTurb)

                        WStandardDeviation = 1.0975 * Me%EulerModel(emp)%ShearVelocity(i, j) 

                        WD = WD_(CurrentPartic, WStandardDeviation, AuxCompMisturaZ_Up,      &
                                 AuxCompMisturaZ_Down, DT_Vert)

                    end select

                else if (CurrentOrigin%Movement%MovType .EQ. DiffusionCoef_    ) then MT  
        
                    if (CurrentOrigin%Movement%DiffusionCoefVON) then
                        DiffusionCoefV = CurrentOrigin%Movement%DiffusionCoefV
                    else
                        DiffusionCoefV = Me%EulerModel(emp)%DiffusionV(i, j, k)
                    endif
                    
                    call random_number(RAND)
                        
                    !(m^2/s/s)^0.5  wd = sqrt(2*D/dt) - standard approach
                    WD  = sqrt(2.* DiffusionCoefV / DT_Vert)  * (1.0 - 2.0 * RAND)
                
                else if (CurrentOrigin%Movement%MovType .EQ. NotRandom_    ) then MT

                    WD = 0.0

                end if MT


                if (CurrentOrigin%Movement%AdvectionZ) then

                    if (Me%EulerModel(emp)%WorkSize%KUB -                             &
                        Me%EulerModel(emp)%WorkSize%KLB + 1 == 1) then

                        W = 0.

                    else

                        if (CurrentPartic%CurrentZ < HalfFillValueReal) then

                        W = Me%EulerModel(emp)%Velocity_W(i, j, k  ) * (1.0 - BALZ) + &
                            Me%EulerModel(emp)%Velocity_W(i, j, k+1) * BALZ 
                        else
                            W = CurrentPartic%CurrentZ
                        endif
                        
                        CurrentPartic%CurrentZ = W

                    endif

                else
                    
                    W = 0.0

                end if

                VELLARVAE = 0.0
                
                nullify(LarvaePtr)

                if ( findLarvaeInOrigin(CurrentOrigin, LarvaePtr) ) then
                                                      
                    if(LarvaePtr%Vertical_Migration) then
                           
                        if (LarvaePtr%Compute_Larvae_Velocity) then
                    
                            VELLARVAE = (LarvaePtr%Larvae_Max_Depth - LarvaePtr%Larvae_Min_Depth)/LarvaePtr%Migration_Time
                   
                        else
                    
                            VELLARVAE = LarvaePtr%Larvae_Velocity
                        
                        endif
                        
                        !Are we between the depth max and min limits?
                        if (CurrentPartic%Position%Z.GE.LarvaePtr%Larvae_Min_Depth .AND. &
                            CurrentPartic%Position%Z.LE.LarvaePtr%Larvae_Max_Depth) then
                            
                            !We are? Then check the radiation limits and light relation
                            
                            if (LarvaePtr%Light_Relation) then 
                            
                                Light_Index = 2
                                
                            else
                            
                                Light_Index = 1
                                
                            endif
                            
                            !Are we above the maximum radiation?
                            if (CurrentPartic%Radiation.GE.LarvaePtr%Radiation_Limit) then
                        
                                !We are? Then go down, run away from too much radiation.
                                VELLARVAE = -1*ABS(VELLARVAE)*(-1)**(Light_Index)
                            
                            else 
                                
                                !We're not? Then we can go up, closer to the minimum depth
                                !because we like being closest to the surface.
                                VELLARVAE = ABS(VELLARVAE)*(-1)**(Light_Index)   
                                
                            endif                 
                        
                        !We're not? Then move towards the nearest limit.
                        else
                            
                            !Are we above min depth? 
                            if (CurrentPartic%Position%Z.LT.LarvaePtr%Larvae_Min_Depth) then
                        
                                !Yes we are, so please go down.
                                VELLARVAE = -1*ABS(VELLARVAE)
                        
                            else
                                
                                !No we're not. Hence we must be
                                !below max depth, so please go up.
                                VELLARVAE = ABS(VELLARVAE)
                        
                            endif
                        
                        endif
                                                                                                   
                    endif     
                    ! If radiation has a low value Larvae goes up to a higher deep
    !                   if (CurrentPartic%Radiation.GE.RADIATION_LIMIT) then
    !                        w(t)=LARVAE_VELOCITY
    !                    else
    !                        w(t)=-1*LARVAE_VELOCITY
    !                    endif
                    ! If radiation has a higth value Larvae goes down to a lower deep
                    ! If Larvae goes out the fixed deep values vertical velocity take an oposite value 
    !                    if (CurrentPartic%Position%Z.LT.LarvaePtr%Larvae_Min_Depth) then
    !                         w(t)=LARVAE_VELOCITY
    !                    endif
    !                    if (CurrentPartic%Position%Z.GT.LarvaePtr%Larvae_Max_Depth) then
    !                         w(t)=-1*LARVAE_VELOCITY
    !                    endif


                endif
                
                VELFLOAT      = 0


OIL:            if (CurrentOrigin%State%Oil) then    
               
                    !correction number of particle submerged
                    CurrentOrigin%Fdisp = dble(CurrentOrigin%Nbrsubmerged) / dble(CurrentOrigin%NbrParticlesIteration);
                    correction = Me%ExternalVar%FMdispersed - CurrentOrigin%Fdisp;
                    
                        
    SU1:                 if (CurrentPartic%Position%Surface) then 
    !                                CurrentPartic%Position%Z = SurfaceDepth
                                
                                WaveHeight       = Me%EulerModel(emp)%WaveHeight2D(i, j)
                                WavePeriod       = Me%EulerModel(emp)%WavePeriod2D(i, j)
                                Wind             = abs(cmplx(Me%EulerModel(emp)%WindX(i,j), Me%EulerModel(emp)%WindY(i,j)))

                                !It is assumed that there is no vertical advection for surface oil particles
                                W = 0.0
                        
                                call random_number(r1)
                            
                            ! submerged particle aleatorie and position of particle
                                
                                if (r1 .LT. correction) then
                                    call random_number(r2)
!                                    BreakingWaveHeight = 1.5 * WaveHeight
                                    NewPosition%Z = min(r2 * 1.5 * WaveHeight + SurfaceDepth, BottomDepth)
                                    
                                    !CurrentPartic%Geometry%OilDropletsD50 = CurrentOrigin%OilDropletsD50

                                    call GetDropletDiameterOrQdTotal(&
                                                  MethodBWDropletsDiameter    = CurrentOrigin%MethodBWDropletsDiameter, &
                                                  D50                         = CurrentOrigin%DropletsD50, &
                                                  ParticleViscCin             = CurrentPartic%OilViscCin, &
                                                  WaveHeight                  = WaveHeight, &
                                                  WaterDensity                = Me%EulerModel(emp)%Density(i, j, k), &
                                                  Wind                        = Wind, &
                                                  WavePeriod                  = WavePeriod, &
                                                  DropletDiameter             = CurrentPartic%Geometry%DropletsDiameter)

                                    !VELFLOAT = gravity * CurrentPartic%Geometry%OilDropletsD50 & 
                                    !           * CurrentPartic%Geometry%OilDropletsD50 & 
                                    !           * (1. - (CurrentPartic%OilDensity/Me%EulerModel(emp)%Density (i, j, k)) ) &
                                    !           / (18. * WaterCinematicVisc)
                                               

                                    VELFLOAT = DropletsFloatVel(ParticleDensity = CurrentPartic%OilDensity, &
                                                                WaterDensity    = Me%EulerModel(emp)%Density (i, j, k), &
                                                                Diameter        = CurrentPartic%Geometry%DropletsDiameter, &
                                                                MethodFloatVel  = CurrentOrigin%MethodFloatVel, &
                                                                InterfTension   = CurrentPartic%OWInterfacialTension)
                                    
                                else
                                     NewPosition%Z = SurfaceDepth
                                     VELFLOAT      = 0.0
                                     ! Surface Oil particles with density lower than water
                                     ! will not submerge by turbulence; they will float
                                     if (CurrentPartic%OilDensity .LT. Me%EulerModel(emp)%Density (i, j, k)) then
                                         WD            = 0.0
                                     endif

                               end if
                               CurrentPartic%Position%Z = NewPosition%Z
                           
                            CurrentPartic%W    = 0.
                        else SU1
                            CurrentPartic%W    = 0.                  
                            !VELFLOAT = gravity * CurrentPartic%Geometry%OilDropletsD50 * CurrentPartic%Geometry%OilDropletsD50 &
                            !           * (1. - (CurrentPartic%OilDensity/Me%EulerModel(emp)%Density (i, j, k)) ) &
                            !           / (18. * WaterCinematicVisc)

                            !This situation can be verified in the case of a underwater release of oil
                            if (CurrentPartic%Geometry%DropletsDiameter < 0.) then
                                CurrentPartic%Geometry%DropletsDiameter = CurrentOrigin%DropletsD50
                            endif
                            
                            !This situation can be verified in the case of a underwater release of oil
                            !The particle oil density is only initialized if the particle is at some point has the float condition
                            if (CurrentPartic%OilDensity < 0.) then
                                call GetOilDensityOil(OilID      = CurrentOrigin%ObjOil,&
                                                      OilDensity = CurrentPartic%OilDensity,&
                                                      STAT       = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'MoveParticVertical - ModuleLagrangianGlobal - ERR20'
                            endif                                

                            VELFLOAT = DropletsFloatVel(ParticleDensity = CurrentPartic%OilDensity, &
                                                        WaterDensity    = Me%EulerModel(emp)%Density (i, j, k), &
                                                        Diameter        = CurrentPartic%Geometry%DropletsDiameter, &
                                                        MethodFloatVel  = CurrentOrigin%MethodFloatVel, &
                                                        InterfTension   = CurrentPartic%OWInterfacialTension)
                                      
                        endif SU1                       
                                      
                endif OIL
                
                VELBODY = 0.0
                if(CurrentOrigin%State%HumanBody)then
                
                    VELBODY = CurrentPartic%HumanBodySinkingVel

                endif

                VELHNS = 0.0
                if (CurrentOrigin%State%HNS)  then
                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Droplet_) then
                        If (CurrentOrigin%MethodFloatVel .EQ. Zheng_) then
                            write(*,*)'Zheng method not available for HNS yet. Change METHOD_FLOAT_VEL to other option.'
                            stop      'MoveParticVertical - ModuleLagrangianGlobal - ERR30'
                        
                        endif
                        VELHNS = DropletsFloatVel(ParticleDensity = CurrentPartic%HNSDensity, &
                                                        WaterDensity    = Me%EulerModel(emp)%Density (i, j, k), &
                                                        Diameter        = CurrentPartic%Geometry%DropletsDiameter, &
                                                        MethodFloatVel  = CurrentOrigin%MethodFloatVel, &
                                                        InterfTension   = CurrentPartic%OWInterfacialTension)
                    elseif (CurrentPartic%HNSParticleState .EQ. WaterColumn_Sedimented_) then
                    !ROD: futurely this should be adapted to compute as sedimentation
                    
                        !median diameter of SPM (m)
                        D50M = 50.e-6
                        
                        !median density of SPM (kg/m3)
                        SPMDensity      = 1051.2
                        
                        WaterDensity    = Me%EulerModel(emp)%Density (i, j, k)
                        
                        VELHNS = -1. * (Gravity * (D50M**2.) * (SPMDensity - WaterDensity)) &
                                 / (18. * WaterDynamicVisc)
                        
                    endif
                endif

                !Velocity due plume
    PL:         if (CurrentOrigin%State%FarFieldBuoyancy) then    
                    Radius = (0.75 * CurrentPartic%Geometry%Volume/Pi) ** 0.33333
                    Area   = 4 * Pi * Radius ** 2.
                    VolOld = CurrentPartic%Geometry%Volume - CurrentPartic%Geometry%VolVar
                    VolNew = CurrentPartic%Geometry%Volume
                    dVol   = CurrentPartic%Geometry%VolVar
                    

                    if (CurrentPartic%SigmaDensity > 0) then
                        CurrentPartic%SigmaDensity = CurrentPartic%SigmaDensity                          + & 
                                                     DT_Vert * (Me%EulerModel(emp)%SigmaDensity(i, j, k) - &
                                                     CurrentPartic%SigmaDensity)  / (172800.+86400.)
                    else
                        CurrentPartic%SigmaDensity = SigmaUNESCO(CurrentPartic%Concentration (1), CurrentPartic%Concentration (2))
                    endif    

                    !Acceleration due density gradient
                    DeltaD = Me%EulerModel(emp)%SigmaDensity(i, j, k) - CurrentPartic%SigmaDensity

                

                    !Buoyancy is consider null for low density gradients 
                    if (abs(DeltaD) > 0.1) then
                        ai     = Gravity * DeltaD / (Me%EulerModel(emp)%SigmaDensity(i, j, k) + &
                                                     SigmaDensityReference)
                                                     
                        dw     = CurrentPartic%W - W

                        ! Taken from CORMIX
                        Cd = 0.055 
                        
                        ![T-1] = [] * [L/T] * [L^2]/[L^3]    
                        AuxW = Cd * abs(dw) * Area / VolNew
                        
                                           !Momentum diffusion by small scale turbulence

                        if (CurrentPartic%W > 0) then
                            CurrentPartic%W =  (CurrentPartic%W * VolOld / VolNew + dVol * W / VolNew + &
                                                !buoyancy + shear friction 
                                                DT_Vert * (ai + W * AuxW)) / (1 + DT_Vert * AuxW)
                        else
                            CurrentPartic%W =   CurrentPartic%W * VolOld / VolNew + dVol * W / VolNew + &
                                                !buoyancy + shear friction 
                                                DT_Vert * (ai - dw * AuxW)
                        endif

                        !dwt = Me%EulerModel(emp)%DWZ(i, j, k) / DT_Vert

                        !if (abs(CurrentPartic%W) > dwt  .and. abs(CurrentPartic%W) > 10. * WD) then
                        
                        !    CurrentPartic%W = CurrentPartic%W * 10. * abs(WD) / abs(CurrentPartic%W) 

                        !endif
                        
                                                    
                    else                
                        ai              = 0.
                        CurrentPartic%W = W
                    endif

                    if (ai > 0) then
                    CurrentPartic%W = sqrt(ai * 0.0004) + W
                    else
                        stop      'MoveParticVertical - ModuleLagrangianGlobal - ERR40'
                    endif



                                                              !tracer vel. + large scale turbulence 
                    NewPosition%Z = CurrentPartic%Position%Z - (CurrentPartic%W + WD) *  DT_Vert

                else PL

                    CurrentPartic%W    = 0.
                    
                    if (Me%ExternalVar%Backtracking) then
                        VELLARVAE = - VELLARVAE
                    endif

                    NewPosition%Z = CurrentPartic%Position%Z - (W + WD + VELQZ + VELFLOAT + VELLARVAE + VELBODY + VELHNS) *  DT_Vert
                endif PL

                !verify HNS deposition
                if (CurrentOrigin%State%HNS)  then
                        i       = NewPosition%I
                        j       = NewPosition%J
                        kFloor  = Me%EulerModel(emp)%kFloor(i, j)

                    if (CurrentPartic%HNSParticleState .EQ. WaterColumn_Sedimented_) then
                        if (NewPosition%Z >= Me%EulerModel(emp)%SZZ(i, j, kFloor-1)) then
                            NewPosition%Z = Me%EulerModel(emp)%SZZ(I, J, KFloor-1) -  0.1 / 2.
                            CurrentPartic%HNSParticleState = Bottom_Deposited_
                        endif
                    endif
                endif
            endif MF

        endif MD

        !------------------------------------------------------------------------

    end subroutine MoveParticVertical
    
    !--------------------------------------------------------------------------    
    
    real function DropletsFloatVel(ParticleDensity, WaterDensity, Diameter, MethodFloatVel, InterfTension)
    
        !Arguments----------------------------------------------------------------------
        real, intent (IN)                 :: ParticleDensity, WaterDensity, Diameter
        integer, intent (IN)              :: MethodFloatVel
        real, intent (IN)                 :: InterfTension
        
        !Local--------------------------------------------------------------------------
        real            :: DensRel, dc, dpx, Reynolds
        real            :: alfa, beta
        real            :: M_, Eo, H_, J_
        !Begin--------------------------------------------------------------------------
            
        DensRel = ParticleDensity/WaterDensity

        if (MethodFloatVel == SoaresDosSantos_) then
            alfa = 9.52
            beta = 8./3.
        elseif (MethodFloatVel == PADM_) then
            alfa = 5.47
            beta = 0.711*0.711
        endif

        if ((MethodFloatVel == SoaresDosSantos_) .OR. (MethodFloatVel == PADM_)) then
            if (DensRel <1) then
            
                dc = ((alfa * WaterCinematicVisc**2)/(Gravity*(1-DensRel)))**0.333
                
                dpx = Diameter
                
                if (dpx < dc) then
                    DropletsFloatVel = Gravity*dpx**2*(1-DensRel)/18./WaterCinematicVisc
                else
                    DropletsFloatVel = sqrt(beta*Gravity*dpx*(1-DensRel))
                endif   
            
            else
                ! in this case, particles will sink
                DropletsFloatVel = -1. * (Gravity * (Diameter**2.) * (ParticleDensity - WaterDensity)) &
                         / (18. * WaterDynamicVisc)

!                DropletsFloatVel = 0.
                
            endif
        elseif (MethodFloatVel == Zheng_) then
            if (Diameter < 1E-3) then
                !regime of spherical shape (small size range)
                
                Reynolds = F_Reynolds(ParticleDensity, DensRel, Diameter)

                DropletsFloatVel = (WaterDynamicVisc * Reynolds) / &
                                   (ParticleDensity * Diameter)
            elseif (Diameter > 1E-3) then              
                Eo = Gravity * DensRel * (Diameter **2.) / InterfTension
                M_ = Gravity * (WaterDynamicVisc **4.) * DensRel / &
                     ( (ParticleDensity**2) * (InterfTension**3) ) 
                if ((M_ < 1E-3) .AND. (Eo < 40.)) then
                    !regime of ellipsoidal shape (intermediate size range)
                    
                    H_ = (4/3) * Eo * (M_**(-0.149))
                    ! original previous formula multiplies by:
                    ! (ambient fluid viscosity / WaterDynamicVisc)**-0.14
                    ! but it is assumed that
                    ! ambient fluid viscosity = WaterDynamicVisc
                    If (H_ > 59.3) then
                        J_ = 3.42 * (H_**0.441)
                    ElseIf ((H_ > 2) .AND. (H_ <= 59.3)) then
                        J_ = 0.94 * (H_**0.757) 
                    Else
                        write(*,*)'Error computing rising velocity (H < 2)'
                        stop 'Lagrangian - DropletsFloatVel - ERR01'
                    End If            
                                 
                    DropletsFloatVel = (WaterDynamicVisc / (  ParticleDensity * Diameter)) * &
                                        M_**(-0.149) * (J_ - 0.857)
                                                        
                elseif (Eo > 40.) then
                    !regime of spherical-cap (large size range)
                    
                    DropletsFloatVel = 0.711 * sqrt(Gravity * Diameter * DensRel / ParticleDensity)
               
                else
                    write(*,*)'Error computing rising velocity (Eo <=40 and M >=1E-3)'
                    stop 'Lagrangian - DropletsFloatVel - ERR02'
                endif    
            end if
        endif        
        
    end function DropletsFloatVel                         

    !--------------------------------------------------------------------------    
    
    real function F_Reynolds(ParticleDensity, DensRel, Diameter)
    !Correlation for Reynolds (Clift et al., 1978 from  Zheng & Yapa 2000)
        !Arguments----------------------------------------------------------------------
        real, intent (IN)       :: ParticleDensity, DensRel, Diameter
        
        !Local--------------------------------------------------------------------------
        real            :: Nd, W_
        !Begin--------------------------------------------------------------------------

        Nd = 4 * ParticleDensity * DensRel * Gravity * (Diameter**3.) / (3 * WaterDynamicVisc * WaterDynamicVisc)
        W_  = log(Nd)
        If (Nd <= 73.) then

            F_Reynolds = (Nd / 24.) - (1.7569E-4 * Nd**2) + (6.9252E-7 * Nd**3) - (2.3027E-10* Nd**4)

        ElseIf ( (Nd > 73. ) .AND. (Nd <= 580.)) then

            F_Reynolds = exp( -1.7095 + 1.33438 * W_ - 0.11591 * W_**2)

        ElseIf ( (Nd > 580.) .AND. (Nd <= 1.55E7)) then

            F_Reynolds = exp( -1.81391 + 1.34671 * W_ - 0.12427 * W_**2 + 0.006344 * W_**3)

        Else
            write(*,*)'Error computing Reynolds Number (Nd > 1.55E7)'
            stop 'Lagrangian - F_Reynolds - ERR01'
        End If          
        
    end function F_Reynolds                         

!    !--------------------------------------------------------------------------
!    real function OilDropletDiameter(MethodBWDropletsDiameter, D50, ParticleViscCin, WaveHeight, WaterDensity, Wind, WavePeriod)
!    
!        !Arguments----------------------------------------------------------------------
!        integer, intent(IN)            :: MethodBWDropletsDiameter
!        real,    intent(IN)            :: D50, ParticleViscCin
!        real,    intent(IN)            :: WaveHeight, WaterDensity, Wind, WavePeriod
!
!        !Local--------------------------------------------------------------------------
!        !type (T_Origin), pointer                    :: CurrentOrigin
!        real            :: ComputedD50
!        integer         :: i
!        real, parameter :: EWave = 5000. ! energy dissipation rate per unit volume (J/m3-s) between 1000 and 10000 - Delvigne 1988
!        real            :: DropletDiameter(5) ! mean droplet diameter per size class
!        real            :: Qd(5) ! Entrainment rate per size class
!        real            :: QdTotal ! Total entrainment rate
!        real            :: RandVal
!        real            :: CumulativeFraction(5)
!        !Begin--------------------------------------------------------------------------
!        select case (MethodBWDropletsDiameter)
!        
!        case (UserDefined_)
!            OilDropletDiameter = D50
!            
!        case (Computed_Half_D50_)
!            call GetDropletDiameterParameters(ParticleViscCin      = ParticleViscCin, &
!                                              ComputedD50          = ComputedD50)
!            OilDropletDiameter  = 0.5 * ComputedD50 
!                  
!        case (Computed_Classes_Random_)
!          
!            call GetEntrainedClasses(ParticleViscCin, WaveHeight, WaterDensity, Wind, WavePeriod, 5, QdTotal, Qd, DropletDiameter)
!                                  
!            call random_number(RandVal)
!
!            CumulativeFraction(1) = (Qd(1) / QdTotal)
!            do i = 2,5
!                CumulativeFraction(i) =  CumulativeFraction(i-1) + (Qd(i) / QdTotal)
!            end do
!
!            If (RandVal <= CumulativeFraction(1)) then
!                    OilDropletDiameter = DropletDiameter(1)
!            else
!                do i = 2,5 
!                    if ((RandVal <= CumulativeFraction(i)) .and. (RandVal > CumulativeFraction(i-1))) then
!                        OilDropletDiameter = DropletDiameter(i)
!                        exit
!                    endif        
!                end do             
!            Endif
!        
!        end select       
!       
!        
!    end function OilDropletDiameter                         

    !--------------------------------------------------------------------------

    real function WD_(CurrentPartic, WStandardDeviation, AuxCompMisturaZ_Up,             &
                      AuxCompMisturaZ_Down, DT_Partic)

        !Arguments-------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentPartic
        real,    intent(IN)                         :: WStandardDeviation
        real,    intent(IN)                         :: AuxCompMisturaZ_Up
        real,    intent(IN)                         :: AuxCompMisturaZ_Down
        real,    intent(IN)                         :: DT_Partic

        !Local-----------------------------------------------------------------
        real                                        :: TlagrangeZ
        real                                        :: RAND
        

        !Calculate TlagrangeZ
        if (WStandardDeviation > 0.0) then
            if (CurrentPartic%WD_old > 0.0) then 

                TlagrangeZ = AuxCompMisturaZ_Up   / WStandardDeviation

            else

                TlagrangeZ = AuxCompMisturaZ_Down / WStandardDeviation

            end if 

        else 

            TlagrangeZ = 0.0

        end if 


        if (CurrentPartic%TpercursoZ >= TlagrangeZ) then
            call random_number(RAND)
                                                                   !SQRT(3.0)=1.732050808 
            WD_                      = (1.0 - 2.0 * RAND) * 1.732050808 * WStandardDeviation
            CurrentPartic%TpercursoZ = DT_Partic
            CurrentPartic%WD_old     = WD_       
                                                          
        else

            WD_                      = CurrentPartic%WD_old                             
            CurrentPartic%TpercursoZ = CurrentPartic%TpercursoZ + DT_Partic
        end if

        !----------------------------------------------------------------------

    end function WD_

    !--------------------------------------------------------------------------
    

    subroutine VolumeVariation ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        if (Me%VoronoiVolume) then
            call VoronoiVolume
        else
            call VolumeFirstOrderVariation    
        endif
      

        

    end subroutine VolumeVariation

    !--------------------------------------------------------------------------

    !This subroutine aims to be a first effort to compute particles volumes 
    !based in their relative positions using voronoi concept to clouds of particles

    subroutine VoronoiVolume


        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        real, dimension(:), pointer                 :: NodeX, NodeY, Depth, Volume
        integer                                     :: ip, NumberOfNodes 
        real                                        :: VolumeMax

        !Begin-----------------------------------------------------------------

        iP = 0        

        CurrentOrigin => Me%FirstOrigin

Or1:    do while (associated(CurrentOrigin))

            iP = iP + CurrentOrigin%nParticle
            CurrentOrigin => CurrentOrigin%Next

        enddo Or1

        NumberOfNodes = iP
                
        allocate(NodeX (NumberOfNodes), NodeY (NumberOfNodes))
        allocate(Depth (NumberOfNodes), Volume(NumberOfNodes))

        iP = 0
        
        Volume(:) = FillValueReal

        CurrentOrigin => Me%FirstOrigin
Or2:    do while (associated(CurrentOrigin))                
            CurrentPartic => CurrentOrigin%FirstPartic                      
            
            do while (associated(CurrentPartic))

                iP          = iP + 1                                    
                NodeX  (iP) = CurrentPartic%Position%CartX
                NodeY  (iP) = CurrentPartic%Position%CartY
                Depth  (iP) = CurrentPartic%Position%Z

                CurrentPartic => CurrentPartic%Next                        
                                            
            enddo 
            
            CurrentOrigin => CurrentOrigin%Next

        enddo Or2
            

        !call Voronoi_3D_volume(npoints  = NumberOfNodes,                                &
        !                       x        = NodeX,                                        &
        !                       y        = NodeY,                                        &
        !                       z        = Depth,                                        &
        !                       volume   = Volume)
                               
        VolumeMax = MaxVal(Volume)  
        
i1:     if (VolumeMax > 0.) then
        
            iP = 0
            CurrentOrigin => Me%FirstOrigin
    Or4:    do while (associated(CurrentOrigin))                
                CurrentPartic => CurrentOrigin%FirstPartic                      
                
                do while (associated(CurrentPartic))
                    iP          = iP + 1            

                    if (Volume(iP) < 0.) then
                        Volume(iP) = VolumeMax
                    endif
                    
                    if (Volume(iP) < CurrentPartic%Geometry%InitialVolume) then
                        Volume(iP) = CurrentPartic%Geometry%InitialVolume
                    endif
                    
                    CurrentPartic%Geometry%VolVar = Volume(iP) - CurrentPartic%Geometry%Volume
                    CurrentPartic%Geometry%Volume = Volume(iP)                       
                            
                    CurrentPartic => CurrentPartic%Next                        
                                                
                enddo 
                
                CurrentOrigin => CurrentOrigin%Next

            enddo Or4    
        
        endif i1


        nullify(CurrentOrigin)                                     
        nullify(CurrentPartic)
        
        deallocate(NodeX, NodeY, Depth, Volume) 
        nullify   (NodeX, NodeY, Depth, Volume) 
        
    end subroutine VoronoiVolume                     
    
    !--------------------------------------------------------------------------

    subroutine VolumeFirstOrderVariation ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: i, j, k, emp
        real                                        :: CellI, CellJ
        real                                        :: Balx, Baly
        real                                        :: U, V, VelQ
        real                                        :: FKK
        real                                        :: VolOld
        real                                        :: PlumeCoef, RelativeVel, VarianceTurb
        real, dimension(:, :, :), pointer           :: Velocity_U, Velocity_V

      

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%State%VariableGeom) then

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

DB:                 if (.not. CurrentPartic%Deposited .and.                             &
                        .not. CurrentPartic%Beached   .and.                             &
                        .not. CurrentPartic%Freezed        ) then
    
                        !Grid Cell of the particle
                        i     = CurrentPartic%Position%I
                        j     = CurrentPartic%Position%J
                        k     = CurrentPartic%Position%K

                        emp    = CurrentPartic%Position%ModelID

                        !Shorten Var
                        if (Me%OverLay) then
                            Velocity_U => Me%EulerModel(emp)%OverLay%VelUFinal
                            Velocity_V => Me%EulerModel(emp)%OverLay%VelVFinal
                        else
                            Velocity_U => Me%EulerModel(emp)%Velocity_U
                            Velocity_V => Me%EulerModel(emp)%Velocity_V
                        endif

                        !Cell Postition
                        CellI = CurrentPartic%Position%CellI
                        CellJ = CurrentPartic%Position%CellJ

                        !Fraction of the cell
                        BALX  = CellJ - int(CellJ)
                        BALY  = CellI - int(CellI)

                        !Linear Interpolation to obtain the velocity of the Water
                        U = LinearInterpolationCell(Velocity_U(i,  j  ,k), Velocity_U(i,  j+1,k), Balx)
                        V = LinearInterpolationCell(Velocity_V(i,  j  ,k), Velocity_V(i+1,j  ,k), Baly)

                        !Velocity ^ 2
                        VelQ    = U**2. + V**2.
                    
                        !ZKMIN    =  0.0
                        !HREF     = 10.0
                        !VSQRREF  = 1*1   ! quadrado da velocidade
                        !ZKVOL    = LOG(2.)/TVOL200
                        !FK = ZKMIN + ZKVOL * (H/HREF) * (VSQR/VSQRREF)
                        select case (CurrentOrigin%Movement%TVolType)

                        case (Double_)

                            FKK     = (log(2.)/ CurrentOrigin%Movement%TVOL200)

                        case (Velocity_)

                            FKK     = (log(2.)/ CurrentOrigin%Movement%TVOL200) *                &  !ZKVOL
                                      (Me%EulerModel(emp)%WaterColumn(i, j)/10.0) *       &  !(H/HREF)
                                      (VelQ)                                                        !(VSQR/VSQRREF)

                        end select

                        if (CurrentOrigin%State%PlumeShear) then
                        
                            !The vertical velocity is not considerer because in cases
                            !where buoancy is very high the Vertical velocity 
                            !is artificially high 
                            !In the far field is assumed that the turbulence is mainly horizontal
                            RelativeVel  = CurrentPartic%RelU**2 + CurrentPartic%RelV**2
                            RelativeVel  = RelativeVel * CurrentOrigin%Movement%CoefInitialMixing
                            
                            !aqui MJ
                            
                            if (CurrentOrigin%Movement%MovType .EQ. NotRandom_ ) then
                                
                                VarianceTurb = 0.0
                            
                            else 
                                
                                VarianceTurb = CurrentPartic%SD
                            
                            endif    

                            if (VarianceTurb> abs(null_real)) then
                                write(*,*)'CurrentPartic%SD - horizontal turbulent velocity standard deviation', CurrentPartic%SD
                                stop 'Lagrangian - VolumeVariation - ERR01'
                            endif 
  
                           ! 10% of the horizontal velocity
                            if (VarianceTurb == 0) then
                               ! 10% of the horizontal velocity
                                VarianceTurb = max(1e-3,0.01 * VelQ)
                            endif

                            PlumeCoef = (RelativeVel + VarianceTurb) / VarianceTurb

                            FKK = FKK * PlumeCoef

                        endif 

                        !Old Volume
                        VolOld  = CurrentPartic%Geometry%Volume
                    
                        !New Volume
                        CurrentPartic%Geometry%Volume = CurrentPartic%Geometry%Volume *      &
                                                        (1. + Me%DT_Partic * FKK) ! Explicito

                        !Volume Variation
                        CurrentPartic%Geometry%VolVar = CurrentPartic%Geometry%Volume - VolOld

                        !Verifies dead volume
                        if (CurrentPartic%Geometry%Volume >                                  &
                            CurrentPartic%Geometry%InitialVolume * CurrentOrigin%Movement%VOLFAC) then
                        
                            CurrentPartic%KillPartic = ON
                        endif

                    endif DB

                    CurrentPartic => CurrentPartic%Next

                enddo

            endif
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

        

    end subroutine VolumeFirstOrderVariation

    !--------------------------------------------------------------------------
    

    subroutine Dilution ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Property), pointer                  :: CurrentProperty
        type (T_Partic), pointer                    :: CurrentPartic
        real                                        :: Concentration
        integer                                     :: nProp, emp
        real                                        :: OldVolume

        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%State%VariableGeom) then

                nProp = 1
                CurrentProperty => CurrentOrigin%FirstProperty
dw2:            do while (associated(CurrentProperty))

                    CurrentPartic => CurrentOrigin%FirstPartic
dw3:                do while (associated(CurrentPartic))

DB:                     if (.not. CurrentPartic%Deposited .and.                         &
                            .not. CurrentPartic%Beached   .and.                         &
                            .not. CurrentPartic%Freezed        ) then

                            emp = CurrentPartic%Position%ModelID

                            call GetAmbientConcPartic (CurrentProperty, nProp, emp, CurrentPartic, Concentration)
                                                          
                            OldVolume = CurrentPartic%Geometry%Volume -                 &
                                        CurrentPartic%Geometry%VolVar


                            !Calculates New Concentration
                            CurrentPartic%Concentration(nProp) =                        &
                                (CurrentPartic%Concentration(nProp) * OldVolume +       &
                                 Concentration * CurrentPartic%Geometry%VolVar) /       &
                                 CurrentPartic%Geometry%Volume

                        endif DB
                    
                        CurrentPartic => CurrentPartic%Next
                    
                    enddo dw3
        
                    nProp = nProp + 1
                    CurrentProperty => CurrentProperty%Next
                    
                enddo dw2

            endif
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr


    end subroutine Dilution

    !--------------------------------------------------------------------------

    subroutine GetAmbientConcCell (Property, ModelID, Position, Concentration)

        !Arguments-------------------------------------------------------------
   
        type (T_Property), pointer                  :: Property
        integer                                     :: ModelID
        type (T_Position)                           :: Position
        real                                        :: Concentration

        !Local-----------------------------------------------------------------
        real, dimension(:, :, :), pointer           :: ConcentrationX
        integer                                     :: STAT_CALL
        
        
        
        !If the property have a given ambient concentration, use it, else
        !try to get it from the Waterproperties module
        if (Property%HaveAmbientConcentration) then
            Concentration = Property%AmbientConcentration
        else

            call GetConcentration(Me%EulerModel(ModelID)%ObjWaterProperties,            &
                                  ConcentrationX    = ConcentrationX,                   &
                                  PropertyXIDNumber = Property%ID,                      &
                                  STAT              = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                
                write(*,*)'AmbientConcentration not given for : ', trim(Property%Name)
                stop 'GetAmbientConcCell - ModuleLagrangianGlobal - ERR10'

            endif

            Concentration = ConcentrationX(Position%I, Position%J, Position%K)

            call UngetWaterProperties(Me%EulerModel(ModelID)%ObjWaterProperties,        &
                                      ConcentrationX,                                   &
                                      STAT              = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) then
                
                stop 'GetAmbientConcCell - ModuleLagrangianGlobal - ERR20'

            endif

        endif
        
    end subroutine GetAmbientConcCell

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine GetAmbientConcPartic (Property, iP, ModelID, Partic, Concentration)

        !Arguments-------------------------------------------------------------
   
        type (T_Property), pointer                  :: Property
        integer                                     :: iP
        integer                                     :: ModelID
        type (T_Partic)                             :: Partic
        real                                        :: Concentration

        !Local-----------------------------------------------------------------
        
        if (Partic%AmbientConc(iP) < HalfFillValueReal) then
             call GetAmbientConcCell (Property, ModelID, Partic%Position, Partic%AmbientConc(iP))
        endif
        
        Concentration = Partic%AmbientConc(iP)
        
    end subroutine GetAmbientConcPartic

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------

    real function GetConcPartic (CurrentOrigin, CurrentPartic, PropertyID)

        !Arguments-------------------------------------------------------------
        type (T_Origin  ), pointer                  :: CurrentOrigin      
        type (T_Partic  ), pointer                  :: CurrentPartic  
        integer                                     :: PropertyID

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: nProp

        !Begin-----------------------------------------------------------------        
        
        CurrentProperty => CurrentOrigin%FirstProperty
        nProp = 1
        do while (associated(CurrentProperty))

          if (CurrentProperty%ID==PropertyID) then
               GetConcPartic = CurrentPartic%Concentration(nprop)
               exit
          endif
          nProp=nProp + 1
          CurrentProperty => CurrentProperty%Next
        enddo    
        
    end function GetConcPartic

    !--------------------------------------------------------------------------    

    subroutine VerifyLandParticles ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: i, j, k, emp


        !Set KILL state of all particle which are in intertidal areas to ON

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
                
            if (CurrentOrigin%Movement%KillLandParticles) then

                CurrentPartic  => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                    k = CurrentPartic%Position%K
                    emp= CurrentPartic%Position%ModelID

                    if (Me%EulerModel(emp)%OpenPoints3D(i, j, k)  /= OpenPoint .and. &
                        Me%EulerModel(emp)%Waterpoints3D(i, j, k) == WaterPoint) then

                        CurrentPartic%KillPartic = ON

                    endif

                    CurrentPartic => CurrentPartic%Next

                enddo

            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr


    end subroutine VerifyLandParticles 

    !--------------------------------------------------------------------------

    subroutine PurgeParticles ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin    => null()
        type (T_Partic), pointer                    :: CurrentPartic    => null()
        type (T_Partic), pointer                    :: ParticToDelete   => null()
        type (T_Partic), pointer                    :: ParticToContinue => null()

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
                
            CurrentPartic  => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                !Deletes all Particle with KillPartic State on
                if (CurrentPartic%KillPartic) then
                
                    ParticToContinue => CurrentPartic%Next
                    ParticToDelete   => CurrentPartic
 
                    if(associated(CurrentPartic%Prev))then
                        CurrentPartic%Prev%Next   => CurrentPartic%Next
                    else
                        CurrentOrigin%FirstPartic => CurrentPartic%Next
                    end if

                    if(associated(CurrentPartic%Next))then
                        CurrentPartic%Next%Prev   => CurrentPartic%Prev
                    end if

                    !Delete Concentration and Mass Buffer
                    if (associated(CurrentPartic%Concentration)) then
                        deallocate(CurrentPartic%Concentration)
                        nullify   (CurrentPartic%Concentration)
                    endif

                    if (associated(CurrentPartic%Mass         )) then
                        deallocate(CurrentPartic%Mass         )
                        nullify   (CurrentPartic%Mass         )
                    endif
                    
                    if (associated(CurrentPartic%AmbientConc))   then
                        deallocate(CurrentPartic%AmbientConc)
                        nullify   (CurrentPartic%AmbientConc)
                    endif                    

                    deallocate    (CurrentPartic)
                    nullify       (CurrentPartic)

                    !Decreases number of particle
                    CurrentOrigin%nParticle = CurrentOrigin%nParticle - 1

                    if (CurrentOrigin%nParticle == 0) then
                        nullify (CurrentOrigin%FirstPartic) 
                    endif


                    !call DeleteParticle (CurrentOrigin, ParticToDelete)

                    !Restarts search
                    CurrentPartic  => ParticToContinue

                else

                    CurrentPartic => CurrentPartic%Next

                endif

            enddo

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine PurgeParticles

       
    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine KillParticInsideBoxes ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: BoxOrigin, CurrentOrigin   
        type (T_Partic), pointer                    :: CurrentPartic 
        logical                                     :: Inside
        integer                                     :: em, STAT_CALL   
        !Begin-----------------------------------------------------------------


        BoxOrigin => Me%FirstOrigin
BoxOr:  do while (associated(BoxOrigin))

            if (BoxOrigin%KillPartInsideBox) then

                if (Me%Now >= BoxOrigin%InstantEmission .and. BoxOrigin%OnlyOnceEmit) then

                    CurrentOrigin => Me%FirstOrigin
CurrOr:             do while (associated(CurrentOrigin))                    
                
                        CurrentPartic  => CurrentOrigin%FirstPartic
                        do while (associated(CurrentPartic))

                            em = CurrentPartic%Position%ModelID

                            Inside = CheckIfInsideBox (Me%EulerModel(em)%ObjBoxDif,     &
                                                       BoxOrigin%BoxNumber,             &
                                                       CurrentPartic%Position%CoordX,   &
                                                       CurrentPartic%Position%CoordY,   &
                                                       STAT = STAT_CALL)
                
                            if (STAT_CALL /= SUCCESS_) stop 'KillParticInsideBoxes - ModuleLagrangianGlobal - ERR10'

                            !Deletes all Particle with KillPartic State on
                            if (Inside) CurrentPartic%KillPartic = ON

                            CurrentPartic => CurrentPartic%Next


                        enddo

                        CurrentOrigin => CurrentOrigin%Next

                    enddo CurrOr

                endif

            endif

            BoxOrigin => BoxOrigin%Next

        enddo BoxOr

    end subroutine KillParticInsideBoxes

       
    !--------------------------------------------------------------------------
    
    real function GetFirstParticTemp (CurrentOrigin)
    
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin   
        

        !Local-----------------------------------------------------------------
        real,   dimension(:,:,:), pointer           :: Temperature3D        
        integer                                     :: i, j, k, em, STAT_CALL   
        !Begin-----------------------------------------------------------------    

        if (associated(CurrentOrigin%FirstPartic)) then

            i            = CurrentOrigin%FirstPartic%Position%I
            j            = CurrentOrigin%FirstPartic%Position%J
            k            = CurrentOrigin%FirstPartic%Position%K
            em           = CurrentOrigin%FirstPartic%Position%ModelID
            

            !Gets the temperature and the Density from the Eulerian model
            call GetConcentration(Me%EulerModel(em)%ObjWaterProperties,                     &
                                  ConcentrationX    = Temperature3D,                        &
                                  PropertyXIDNumber = Temperature_,                         &
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                write (*,*)'The Lagrangian Module needs the Water Temperature from the eulerian module'
                stop 'GetFirstParticTemp - ModuleLagrangianGlobal - ERR10'
            endif


            GetFirstParticTemp = Temperature3D (i, j, k)

            call UngetWaterProperties (Me%EulerModel(em)%ObjWaterProperties, Temperature3D, &
                                       STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'GetFirstParticTemp - ModuleLagrangianGlobal - ERR20'

        else
        
            GetFirstParticTemp = 15. 
        
        endif                

    end function GetFirstParticTemp                
    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    
    real function GetFirstParticDens (CurrentOrigin)
    
        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin   

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k, em   
        !Begin-----------------------------------------------------------------    
        
        if (associated(CurrentOrigin%FirstPartic)) then

            i                    = CurrentOrigin%FirstPartic%Position%I
            j                    = CurrentOrigin%FirstPartic%Position%J
            k                    = CurrentOrigin%FirstPartic%Position%K
            em                   = CurrentOrigin%FirstPartic%Position%ModelID
            

            GetFirstParticDens   = Me%EulerModel(em)%Density (i, j, k)
                
        else
            GetFirstParticDens   = 1027.
        endif                

    end function GetFirstParticDens
                    
    !--------------------------------------------------------------------------

    subroutine LightEvolution ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentParticle
        type (T_Property), pointer                  :: CurrentProperty

        real,    dimension(:, :, :   ), pointer     :: Concentration
        real                                        :: UnitsCoef, dh1, CenterRadiation, SWPercentage
        integer                                     :: ig, STAT_CALL, iProp, i, j, k, em
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB, Kbottom
        logical                                     :: NeedsParameters, NeedsConcentrations, &
                                                       NeedsPhyto, NeedsSPM, FoundPhyto, FoundSed, ValidProp
        !Begin-----------------------------------------------------------------


        !Updates light
d1:     do em     = 1, Me%EulerModelNumber

            !Shorten
            ILB    = Me%EulerModel(em)%WorkSize%ILB
            IUB    = Me%EulerModel(em)%WorkSize%IUB
            JLB    = Me%EulerModel(em)%WorkSize%JLB
            JUB    = Me%EulerModel(em)%WorkSize%JUB
            KLB    = Me%EulerModel(em)%WorkSize%KLB
            KUB    = Me%EulerModel(em)%WorkSize%KUB


            !Allocates auxiliar variable
            allocate (Concentration (Me%EulerModel(em)%Size%ILB:Me%EulerModel(em)%Size%IUB, &
                                     Me%EulerModel(em)%Size%JLB:Me%EulerModel(em)%Size%JUB, &
                                     Me%EulerModel(em)%Size%KLB:Me%EulerModel(em)%Size%KUB))
            
d2:         do ig = 1, Me%nGroups

                call GetRadiationPercentages (Me%EulerModel(em)%Light(ig)%ObjLightExtinction,   &
                                              SWPercentage = SWPercentage, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_)stop 'LightEvolution - ModuleLagrangianGlobal - ERR01'
            
        
i0:             if(Me%EulerModel(em)%Light(ig)%Compute)then

                    call GetLightExtinctionOptions(LightExtinctionID    = Me%EulerModel(em)%Light(ig)%ObjLightExtinction,& 
                                                   NeedsParameters      = NeedsParameters,       &
                                                   NeedsConcentrations  = NeedsConcentrations,   &
                                                   NeedsPhyto           = NeedsPhyto,            &
                                                   NeedsSPM             = NeedsSPM,              &
                                                   STAT                 = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)stop 'LightEvolution - ModuleLagrangianGlobal - ERR10'

                    !call GetRadiationPercentages (Me%EulerModel(em)%Light(ig)%ObjLightExtinction,           &
                    !                              SWPercentage = SWPercentage, STAT = STAT_CALL)

                    !if (STAT_CALL /= SUCCESS_)stop 'LightEvolution - ModuleLagrangianGlobal - ERR20'


    i1:             if(NeedsConcentrations)then

                        if (Me%Now > Me%ExternalVar%LastConcCompute) call FillGridConcentration

                        if (associated(Me%FirstOrigin)) then
                            CurrentOrigin => Me%FirstOrigin 
                        else
                            CurrentOrigin => Me%OriginDefault
                        endif

    Catch:              do while (associated(CurrentOrigin))
                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentProperty  => CurrentOrigin%FirstProperty
                                exit Catch
                            endif
                            CurrentOrigin => CurrentOrigin%Next
                        enddo Catch

                        iProp = 1

                        FoundPhyto = .false.
                        FoundSed   = .false.

    dw1:                do while (associated(CurrentProperty))

                            if (CurrentProperty%ID == Phytoplankton_    ) FoundPhyto = .true.
                            if (CurrentProperty%ID == Cohesive_Sediment_) FoundSed   = .true.

                            if (CurrentProperty%ID == Phytoplankton_ .or. CurrentProperty%ID == Cohesive_Sediment_) then
                                ValidProp = .true.
                            else
                                ValidProp = .false.
                            endif

    i2:                     if ((NeedsPhyto.and.FoundPhyto).or.(NeedsSPM.and.FoundSed).and.ValidProp) then

                                UnitsCoef = 1e-3
                         
                                Concentration(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridConc(:,:,:,iProp,ig)

    i3:                         if(NeedsParameters)then

                            
                                    call ModifyLightExtinctionField                            &
                                        (LightExtinctionID   = Me%EulerModel(em)%Light(ig)%ObjLightExtinction,&
                                         WaterPoints3D       = Me%EulerModel(em)%Waterpoints3D,&
                                         CurrentTime         = Me%Now,             &
                                         PropertyID          = CurrentProperty%ID,             &
                                         Concentration       = Concentration,                  &
                                         UnitsCoef           = UnitsCoef,                      &
                                         ExtinctionParameter = CurrentProperty%ExtinctionParameter,&
                                         STAT                = STAT_CALL)
                                    if (STAT_CALL/= SUCCESS_) stop 'LightEvolution - ModuleLagrangianGlobal - ERR30'

                                else i3

                                    call ModifyLightExtinctionField                            &
                                        (LightExtinctionID   = Me%EulerModel(em)%Light(ig)%ObjLightExtinction,&
                                         WaterPoints3D       = Me%EulerModel(em)%Waterpoints3D,&
                                         CurrentTime         = Me%Now,             &
                                         PropertyID          = CurrentProperty%ID,             &
                                         Concentration       = Concentration,                  &
                                         UnitsCoef           = UnitsCoef,                      &
                                         STAT                = STAT_CALL)
                                    if (STAT_CALL/= SUCCESS_) stop 'LightEvolution - ModuleLagrangianGlobal - ERR40'

                                end if i3


                            endif i2

                            CurrentProperty => CurrentProperty%Next
                            iProp = iProp + 1

                        enddo dw1

                        if (NeedsPhyto.and..not.FoundPhyto) then

                            stop 'LightEvolution - ModuleLagrangianGlobal - ERR50'

                        endif
                
                        if (NeedsSPM.and..not. FoundSed) then

                            stop 'LightEvolution - ModuleLagrangianGlobal - ERR60'

                        endif

                    else i1

                        call ModifyLightExtinctionField(LightExtinctionID   = Me%EulerModel(em)%Light(ig)%ObjLightExtinction,&
                                                        WaterPoints3D       = Me%EulerModel(em)%Waterpoints3D,   &
                                                        CurrentTime         = Me%Now,             &
                                                        STAT                = STAT_CALL)
                        if (STAT_CALL/= SUCCESS_) stop 'LightEvolution - ModuleLagrangianGlobal - ERR70'

                    end if i1

                end if i0



            call GetShortWaveExtinctionField(Me%EulerModel(em)%Light(ig)%ObjLightExtinction, &
                   Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'LightEvolution - ModuleLagrangianGlobal - ERR80'

d3:         do j = JLB, JUB
d4:         do i = ILB, IUB

                
i5:             if (Me%EulerModel(em)%Waterpoints3D(i, j, KUB) == WaterPoint) then 
                    
                    kbottom = Me%EulerModel(em)%KFloor(i, j)

                    Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, KUB) =          &
                        Me%EulerModel(em)%SurfaceRadiation(i, j) * SWPercentage
                   
d5:                 do k= KUB-1, kbottom - 1, -1

                        Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, k) =        &
                            Me%EulerModel(em)%Light(ig)%TopRadiationCells   (i,j,k+1) * &
                            exp(-Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i,j,k+1)* &
                            Me%EulerModel(em)%DWZ(i, j, k + 1))

                        Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, k)=         &
                            max(Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, k), 0.001)

                    end do d5

                end if i5

            end do d4
            end do d3

        enddo d2

        deallocate(Concentration)

        enddo d1


        CurrentOrigin => Me%FirstOrigin 
dw2:    do while (associated(CurrentOrigin))
                        
            ig = CurrentOrigin%GroupID

            !It is admited that the tracers thickness is always smaller than the cells thickness
            CurrentParticle => CurrentOrigin%FirstPartic
dw3:            do while (associated(CurrentParticle))

                i  = CurrentParticle%Position%I
                j  = CurrentParticle%Position%J
                k  = CurrentParticle%Position%K

                em = CurrentParticle%Position%ModelID


                dh1 = CurrentParticle%Position%Z - Me%EulerModel(em)%SZZ(i, j, k)
                
                dh1 = max(0.,dh1)

                !Radiation in the center of the particle (I2)
                !I2 = I1*exp(-K * Thickness/2) <=> I1 = I2 / exp(-K * Thickness/2)
                !I1 = top particle face
                !I3 = bottom particle face
                !I3 = I2*exp(-K * Thickness/2)
                CenterRadiation =  Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, k) *    &
                                   exp( - Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i,j,k) * dh1)

                !dh2 = CurrentParticle%Geometry%Thickness

                !Iaverage = (I1 - I3) / (K * Thickness) = I2 / (K * Thickness) * 
                !           (1/exp(-K * Thickness/2) - exp(-K * Thickness/2))
                !Iaverage = I2 / (K * Thickness) * (exp(K * Thickness/2) - exp(-K * Thickness/2)) 
                !AverageRadiation = CenterRadiation / Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i,j,k) / dh2 * &
                !                   (exp(  Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i,j,k) * dh2/2)         - &
                !                    exp(- Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i,j,k) + dh2/2)) 

                CurrentParticle%Radiation    = CenterRadiation  
                CurrentParticle%ShortWaveExt = Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i, j, k)

                CurrentParticle => CurrentParticle%Next
            enddo dw3


            CurrentOrigin => CurrentOrigin%Next
        enddo dw2


d10:    do em     = 1, Me%EulerModelNumber
        do ig = 1, Me%NGroups
            call UnGetLightExtinction(Me%EulerModel(em)%Light(ig)%ObjLightExtinction, &
                                      Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'LightEvolution - ModuleLagrangianGlobal - ERR100'
        enddo
        enddo d10

    end subroutine LightEvolution

!--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


    subroutine PropertiesEvolution ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        real, dimension(:), pointer                 :: TemperatureX
        real, dimension(:), pointer                 :: SalinityX
        real, dimension(:), pointer                 :: SWRadiationX
        real, dimension(:), pointer                 :: LightExtCoefX
        real, dimension(:), pointer                 :: Thickness
        real, dimension(:), pointer                 :: FishFoodX
        real, dimension(:, :), pointer              :: WQMMass
        integer                                     :: nParticle
        integer                                     :: i, j, k, nProp, em, emp
        integer                                     :: ZooWQM
        integer                                     :: LarvaeWQM
        integer                                     :: AgeWQM
        integer                                     :: PhytoWQM
        integer                                     :: AmmoniaWQM
        integer                                     :: NitrateWQM
        integer                                     :: NitriteWQM
        integer                                     :: DONRefractoryWQM
        integer                                     :: DONNonRefractoryWQM
        integer                                     :: PartOrganicNitrogenWQM
        integer                                     :: OxygenWQM
        integer                                     :: BODWQM
        integer                                     :: BacteriaWQM
        integer                                     :: CiliateWQM
        integer                                     :: DOPRefractoryWQM
        integer                                     :: DOPNonRefractoryWQM
        integer                                     :: PartOrganicPhosphorusWQM
        integer                                     :: InorganicPhosphorusWQM
        integer                                     :: STAT_CALL, iP
        real                                        :: ScaleRelationHV, Diameter
        type (T_TIME)                               :: Actual


        !Begin-----------------------------------------------------------------


        !Actual Time
        Actual = Me%Now

d1:     do em =1, Me%EulerModelNumber

            !Gets the FishFood from the Eulerian model
            if (Me%State%Larvae) then
                call GetConcentration(Me%EulerModel(em)%ObjWaterProperties,             &
                                      ConcentrationX    = Me%EulerModel(em)%FishFood3D, &
                                      PropertyXIDNumber = FishFood_,                    &
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR10'
            end if

        enddo d1

        !In this version the lagrangian model calls the WQM for each origin once,
        !so origins with different inicial conditions can be studied at the same
        !time.
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
                
            if (CurrentOrigin%State%WQM .and. Actual .ge. CurrentOrigin%NextWQMCompute) then


                !Gets the indexes from the WQM
                call GetWQPropIndex(CurrentOrigin%WaterQualityID,                                       &      
                                  Zoo                             = ZooWQM,                             &      
                                  Larvae                          = LarvaeWQM,                          &      
                                  Age                             = AgeWQM,                             &      
                                  Phyto                           = PhytoWQM,                           &      
                                  Ammonia                         = AmmoniaWQM,                         &      
                                  Nitrate                         = NitrateWQM,                         &      
                                  Nitrite                         = NitriteWQM,                         &      
                                  DissOrganicNitrogenRefractory   = DONRefractoryWQM,                   &      
                                  DONNonRefractory                = DONNonRefractoryWQM,                &      
                                  PartOrganicNitrogen             = PartOrganicNitrogenWQM,             &      
                                  Oxygen                          = OxygenWQM,                          &      
                                  BOD                             = BODWQM,                             &      
                                  Bacteria                        = BacteriaWQM,                        &      
                                  Ciliate                         = CiliateWQM,                         &      
                                  DissOrganicPhosphorusRefractory = DOPRefractoryWQM,                   &      
                                  DOPNonRefractory                = DOPNonRefractoryWQM,                &      
                                  PartOrganicPhosphorus           = PartOrganicPhosphorusWQM,           &      
                                  InorganicPhosphorus             = InorganicPhosphorusWQM,             &      
                                  STAT                            = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR20'


                !Allocates the temporary matrixes
                allocate (TemperatureX        (CurrentOrigin%nParticle), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR30'

                allocate (SalinityX           (CurrentOrigin%nParticle), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR40'

                allocate (SWRadiationX        (CurrentOrigin%nParticle), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR50'

                allocate (LightExtCoefX       (CurrentOrigin%nParticle), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR60'

                allocate (Thickness           (CurrentOrigin%nParticle), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR70'

                allocate (WQMMass(CurrentOrigin%nProperties, CurrentOrigin%nParticle), STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR80'

                if (CurrentOrigin%State%Larvae)  then            
                    allocate (FishFoodX       (CurrentOrigin%nParticle), STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR90'
                end if


                CurrentPartic  => CurrentOrigin%FirstPartic
                nParticle      = 1
                do while (associated(CurrentPartic))

                    i = CurrentPartic%Position%I
                    j = CurrentPartic%Position%J
                    k = CurrentPartic%Position%K

                    emp= CurrentPartic%Position%ModelID

                    iP = 1

                    CurrentProperty => CurrentOrigin%FirstProperty
                    do while (associated(CurrentProperty))

                        if      (CurrentProperty%ID == Salinity_) then

                            !Stores Salinity
                            call GetAmbientConcPartic (CurrentProperty, iP, emp, CurrentPartic, SalinityX (nParticle))
                           
                        else if (CurrentProperty%ID == Temperature_) then
                            
                            !Stores Temperature
                            call GetAmbientConcPartic (CurrentProperty, iP, emp, CurrentPartic, TemperatureX (nParticle))
    
                        endif

                        iP = iP + 1
                        CurrentProperty => CurrentProperty%Next

                    enddo
 

                   !Stores FishFood
                    if (CurrentOrigin%State%Larvae)                                        &            
                        FishFoodX (nParticle) = Me%EulerModel(emp)%FishFood3D (i, j, k)
                    

                    !
                    !Pina, 2001
                    !
                    !Radiation at the point of the Particle
                    ScaleRelationHV = 100. 
                    !The tracer geometry is addimited equal to a cilinder
                    Diameter = 2 * (ScaleRelationHV * CurrentPartic%Geometry%Volume / Pi) 
                    !The relation between the tracer Diameter and is thickness is consider 
                    !proportional to the relation of turbulence scales H/V. 
                    Thickness     (nParticle)   = Diameter / ScaleRelationHV 
                    SWRadiationX  (nParticle)   = CurrentPartic%Radiation
                    LightExtCoefX (nParticle)   = CurrentPartic%ShortWaveExt

                    !Stores Mass 
                    nProp = 1
                    CurrentProperty => CurrentOrigin%FirstProperty
                    do while (associated(CurrentProperty))

                        select case (CurrentProperty%ID)

                        case (Phytoplankton_                  )
                            WQMMass(PhytoWQM,            nParticle) = &
                            CurrentPartic%Concentration (nProp)
                                                            
                        case (Zooplankton_                    )
                            WQMMass(ZooWQM,              nParticle) = &
                            CurrentPartic%Concentration (nProp)
                                                            
                        case (Larvae_                         )
                            WQMMass(LarvaeWQM,           nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Age_                         )
                            WQMMass(AgeWQM,              nParticle) = &
                            CurrentPartic%Concentration (nProp)                                                           
 
                        case (PON_                            )
                            WQMMass(PartOrganicNitrogenWQM, nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (DONRefractory_                  )
                            WQMMass(DONRefractoryWQM,    nParticle) = &
                            CurrentPartic%Concentration (nProp)
                           
                        case (DONNon_Refractory_              )
                            WQMMass(DONNonRefractoryWQM, nParticle) = &
                            CurrentPartic%Concentration (nProp)
                           
                        case (Ammonia_                        )
                            WQMMass(AmmoniaWQM,          nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Nitrate_                        )
                            WQMMass(NitrateWQM,          nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Nitrite_                        )
                            WQMMass(NitriteWQM,          nParticle) = &
                            CurrentPartic%Concentration (nProp)
     
                        case (BOD_                            )
                            WQMMass(BODWQM,              nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Oxygen_                         )
                            WQMMass(OxygenWQM,           nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Ciliate_                        )
                            WQMMass(CiliateWQM,          nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Bacteria_                       )
                            WQMMass(BacteriaWQM,         nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (POP_                            )
                            WQMMass(PartOrganicPhosphorusWQM,nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (DOPRefractory_                  )
                            WQMMass(DOPRefractoryWQM,    nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (DOPNon_Refractory_              )
                            WQMMass(DOPNonRefractoryWQM, nParticle) = &
                            CurrentPartic%Concentration (nProp)

                        case (Inorganic_Phosphorus_           )
                            WQMMass(InorganicPhosphorusWQM, nParticle) = &
                            CurrentPartic%Concentration (nProp)
    
                        end select

                        nProp           = nProp + 1
                        CurrentProperty => CurrentProperty%Next
                    enddo

                    CurrentPartic => CurrentPartic%Next
                    nParticle     = nParticle + 1
                enddo
                
                if (CurrentOrigin%State%Larvae)then

                    !Runs the WaterQualityModel    
                    call WaterQuality(CurrentOrigin%WaterQualityID,                            &
                                      Salinity                      = SalinityX,               &
                                      Temperature                   = TemperatureX,            &
                                      ShortWaveRadiation            = SWRadiationX,            &
                                      LightExtCoefField             = LightExtCoefX,           &
                                      Thickness                     = Thickness,               &
                                      Mass                          = WQMMass,                 &
                                      WQArrayLB                     = 1,                       &
                                      WQArrayUB                     = CurrentOrigin%nParticle, &
                                      FishFood                      = FishFoodX,               &
                                      STAT                          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR100'

                else

                    !Runs the WaterQualityModel    
                    call WaterQuality(CurrentOrigin%WaterQualityID,                            &
                                      Salinity                      = SalinityX,               &
                                      Temperature                   = TemperatureX,            &
                                      ShortWaveRadiation            = SWRadiationX,            &
                                      LightExtCoefField             = LightExtCoefX,           &
                                      Thickness                     = Thickness,               &
                                      Mass                          = WQMMass,                 &
                                      WQArrayLB                     = 1,                       &
                                      WQArrayUB                     = CurrentOrigin%nParticle, &
                                      STAT                          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR110'

                end if
                !Restores Mass
                CurrentPartic  => CurrentOrigin%FirstPartic
                nParticle      = 1
                do while (associated(CurrentPartic))

                    !Stores Mass 
                    nProp           = 1
                    CurrentProperty => CurrentOrigin%FirstProperty
                    do while (associated(CurrentProperty))

                        select case (CurrentProperty%ID)

                        case (Phytoplankton_                  )
                            CurrentPartic%Concentration (nProp) = WQMMass(PhytoWQM,  nParticle)
                                                            
                        case (Zooplankton_                    )
                            CurrentPartic%Concentration (nProp) = WQMMass(ZooWQM,    nParticle)
                                                            
                        case (Larvae_                         )
                            CurrentPartic%Concentration (nProp) = WQMMass(LarvaeWQM, nParticle)
                                                            
                        case (Age_                            )
                            CurrentPartic%Concentration (nProp) = WQMMass(AgeWQM,    nParticle)

                        case (PON_   )
                            CurrentPartic%Concentration (nProp) = WQMMass(PartOrganicNitrogenWQM, nParticle)

                        case (DONRefractory_                  )
                            CurrentPartic%Concentration (nProp) = WQMMass(DONRefractoryWQM,    nParticle)
                           
                        case (DONNon_Refractory_              )
                            CurrentPartic%Concentration (nProp) = WQMMass(DONNonRefractoryWQM, nParticle)
                           
                        case (Ammonia_                        )
                            CurrentPartic%Concentration (nProp) = WQMMass(AmmoniaWQM, nParticle)

                        case (Nitrate_                        )
                            CurrentPartic%Concentration (nProp) = WQMMass(NitrateWQM, nParticle)

                        case (Nitrite_                        )
                            CurrentPartic%Concentration (nProp) = WQMMass(NitriteWQM, nParticle)
     
                        case (BOD_                            )
                            CurrentPartic%Concentration (nProp) = WQMMass(BODWQM,     nParticle)

                        case (Oxygen_                         )
                            CurrentPartic%Concentration (nProp) = WQMMass(OxygenWQM,  nParticle)

                        case (Ciliate_                        )
                            CurrentPartic%Concentration (nProp) = WQMMass(CiliateWQM, nParticle)

                        case (Bacteria_                       )
                            CurrentPartic%Concentration (nProp) = WQMMass(BacteriaWQM,nParticle)

                        case (POP_ )
                            CurrentPartic%Concentration (nProp) = WQMMass(PartOrganicPhosphorusWQM, nParticle)

                        case (DOPRefractory_                  )
                            CurrentPartic%Concentration (nProp) = WQMMass(DOPRefractoryWQM,         nParticle)

                        case (DOPNon_Refractory_              )
                            CurrentPartic%Concentration (nProp) = WQMMass(DOPNonRefractoryWQM,      nParticle)

                        case (Inorganic_Phosphorus_           )
                            CurrentPartic%Concentration (nProp) = WQMMass(InorganicPhosphorusWQM,   nParticle) 
    
                        end select

                        nProp           = nProp + 1
                        CurrentProperty => CurrentProperty%Next
                    enddo

                    CurrentPartic => CurrentPartic%Next
                    nParticle     = nParticle + 1
                enddo


                !Deallocates the temporary matrixes
                deallocate (TemperatureX,           STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR120'
                nullify (TemperatureX) 

                deallocate (SalinityX,              STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR130'
                nullify (SalinityX)

                deallocate (SWRadiationX,           STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR140'
                nullify (SWRadiationX)

                deallocate (LightExtCoefX,          STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR150'
                nullify (LightExtCoefX)

                deallocate (Thickness,               STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR160'
                nullify (Thickness)

                deallocate (WQMMass,                STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR170'
                nullify (WQMMass)

                if (CurrentOrigin%State%Larvae)  then            
                    deallocate (FishFoodX,           STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR180'
                    nullify (FishFoodX) 
                end if
                

                CurrentOrigin%NextWQMCompute = CurrentOrigin%NextWQMCompute + CurrentOrigin%DTWQM

            end if

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

d2:     do em =1, Me%EulerModelNumber

            !Ungets Concentration from the eulerian module
            if (Me%State%Larvae)  then            
                call UngetWaterProperties (Me%EulerModel(em)%ObjWaterProperties,        &
                                           Me%EulerModel(em)%FishFood3D,                &
                                           STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'PropertiesEvolution - ModuleLagrangianGlobal - ERR190'
            end if

        enddo d2

    end subroutine PropertiesEvolution

    !--------------------------------------------------------------------------

    subroutine ColiformDecay ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: nProp, iSal, iTemp
        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%State%FC) then

P1:             if (Me%State%T90Compute) then

                    CurrentProperty => CurrentOrigin%FirstProperty
                    nProp =   1
                    iSal  = -99
                    iTemp = -99
                    do while (associated(CurrentProperty))

                        if (CurrentProperty%ID == Salinity_   ) iSal  = nProp
                        if (CurrentProperty%ID == Temperature_) iTemp = nProp

                        nProp           =  nProp + 1
                        CurrentProperty => CurrentProperty%Next

                    enddo

                    if (iSal == -99) then

                        write(*,*) 'The origin ='//trim(CurrentOrigin%Name)// &
                                    ' must have a salinity property to compute a variable T90' 
                        stop 'ColiformDecay - ModuleLagrangianGlobal - ERR01'

                    endif

                    if (iTemp == -99) then

                        write(*,*) 'The origin ='//trim(CurrentOrigin%Name)// &
                                    ' must have a temperature property to compute a variable T90'
                        stop 'ColiformDecay - ModuleLagrangianGlobal - ERR02'

                    endif


                endif P1


                nProp = 1
                CurrentProperty => CurrentOrigin%FirstProperty
CurrProp:       do while (associated(CurrentProperty))

                    if (CurrentProperty%ID == Fecal_Coliforms_ .or.CurrentProperty%ID == E_Coli_) then

                        CurrentPartic => CurrentOrigin%FirstPartic
                        do while (associated(CurrentPartic))

                            if (CurrentProperty%T90Compute) then

  
                                CurrentPartic%T90 = ComputeT90(CurrentPartic%Concentration(iSal),&
                                                               CurrentPartic%Concentration(iTemp),&
                                                               CurrentPartic%Radiation, CurrentProperty%T90Var_Method)
                            else

                                CurrentPartic%T90 = CurrentProperty%T90

                            endif
                    
                            CurrentPartic%Concentration(nProp) = CurrentPartic%Concentration(nProp) / &
                                                                 (1.0 + Me%DT_Partic *     &
                                                                 (log(10.) / CurrentPartic%T90))

                            CurrentPartic => CurrentPartic%Next
                        enddo

                        exit CurrProp

                    else
                        nProp           =  nProp + 1
                        CurrentProperty => CurrentProperty%Next
                    endif
                enddo CurrProp


            endif
    
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine ColiformDecay

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    real function ComputeT90 (Sal, Temp, Radiation, Method)

        !Arguments-------------------------------------------------------------
        real                                        :: Sal, Temp, Radiation
        integer                                     :: Method
        !Local-----------------------------------------------------------------
        real                                        :: Convert, Light

        !Begin-----------------------------------------------------------------

 


!______Mortality model selection

        If (Method .eq. Canteras) then

            ComputeT90 = ComputeT90_Canteras (Temp,Sal,Radiation)
            

        elseif (Method .eq. Chapra) then

            !Converts W in ly/hr
            Convert    = 0.086325
            Light      = Convert * Radiation

            ComputeT90 = ComputeT90_Chapra (Temp, Sal, Light)  

        else

            write (*,*) 'T90 calculation method unknown'
            stop 'ComputeT90 - ModuleLagrangianGlobal - ERR10'
        
        endif


    end function ComputeT90

    !--------------------------------------------------------------------------
    subroutine ComputeT90Matrix (em, ig, CurrentProperty, GridConc3D)

        !Arguments----------------------------------------------------------------------
        integer                                     :: em, ig
        type (T_Property), pointer                  :: CurrentProperty
        real,   dimension(:,:,:), pointer           :: GridConc3D
        !Local--------------------------------------------------------------------------
        real                                        :: Sal, Temp, Radiation, Thickness
        integer                                     :: iSal, iTemp, nProp, i, j, k, STAT_CALL
        type (T_Property), pointer                  :: AuxProperty

        !Begin--------------------------------------------------------------------------

        if (CurrentProperty%T90Compute) then

            AuxProperty => Me%OriginDefault%FirstProperty
            nProp =   1
            iSal  = -99
            iTemp = -99
            do while (associated(AuxProperty))

                if (AuxProperty%ID == Salinity_   ) iSal  = nProp
                if (AuxProperty%ID == Temperature_) iTemp = nProp

                nProp       =  nProp + 1
                AuxProperty => AuxProperty%Next

            enddo

            call GetShortWaveExtinctionField(Me%EulerModel(em)%Light(ig)%ObjLightExtinction, &
                                             Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeT90Matrix - ModuleLagrangianGlobal - ERR10'

        endif
         
        do k = Me%EulerModel(em)%WorkSize%KLB, Me%EulerModel(em)%WorkSize%KUB
        do j = Me%EulerModel(em)%WorkSize%JLB, Me%EulerModel(em)%WorkSize%JUB
        do i = Me%EulerModel(em)%WorkSize%ILB, Me%EulerModel(em)%WorkSize%IUB
            
i1:         if (Me%EulerModel(em)%Waterpoints3D (i, j, k) == WaterPoint) then
                                
i2:             if (CurrentProperty%T90Compute) then

                    Sal       = Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, iSal,  ig)

                    Temp      = Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, iTemp, ig)

                    Thickness = Me%EulerModel(em)%DWZ(i, j, k)

                    Radiation = (Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, k) - &
                                 Me%EulerModel(em)%Light(ig)%TopRadiationCells(i, j, k-1))/&
                                (Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField(i, j, k) * Thickness)
                
                    GridConc3D(i, j, k) = ComputeT90 (Sal, Temp, Radiation, CurrentProperty%T90Var_Method)

   
                else i2

                    GridConc3D(i, j, k) =  CurrentProperty%T90       
    
                endif i2
                
            else i1
            
                    GridConc3D(i, j, k) =  FillValueReal
            
            endif i1

        enddo
        enddo
        enddo                    


        if (CurrentProperty%T90Compute) then

            call UnGetLightExtinction(Me%EulerModel(em)%Light(ig)%ObjLightExtinction, &
                                      Me%EulerModel(em)%Light(ig)%ShortWaveExtinctionField, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeT90Matrix - ModuleLagrangianGlobal - ERR20'

        endif

    end subroutine ComputeT90Matrix
    !--------------------------------------------------------------------------

    subroutine PartitionDecay ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        real                                        :: kd, rp, rd, ConcP, ConcD, Kdp, dt, DC
        integer                                     :: nProp
        
        !Begin-----------------------------------------------------------------
        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%State%Partition) then

                nProp = 1
                CurrentProperty => CurrentOrigin%FirstProperty
CurrProp:       do while (associated(CurrentProperty))

                    if (CurrentProperty%WaterPartition%ON .or. CurrentProperty%SedimentPartition%ON) then

                        CurrentPartic => CurrentOrigin%FirstPartic
                        do while (associated(CurrentPartic))

                            if (CurrentProperty%WaterPartition%ON .and. .not. CurrentPartic%Deposited) then
                            
                                kd = CurrentProperty%WaterPartition%Coefficient 

                                rp = kd / (1 + kd)
                                rd =  1 / (1 + kd)
                                ConcP = CurrentPartic%Concentration(nProp)
                                ConcD = CurrentProperty%WaterPartition%CoupleProp
                              
                                Kdp   = CurrentProperty%WaterPartition%TransferRate
                                dt    = Me%DT_Partic

                                DC    = rp * ConcD - rd * ConcP

                                if (DC > 0.) then
                                ConcP = ConcP + dt * Kdp * (rp * ConcD - rd * ConcP)
                                else
                                    ConcP = (ConcP + dt * Kdp * rp * ConcD) / (1 + dt * Kdp * rd)
                                endif

                                CurrentPartic%Concentration(nProp) = ConcP

                            endif

                            if (CurrentProperty%SedimentPartition%ON .and. CurrentPartic%Deposited) then
                    
                                kd = CurrentProperty%SedimentPartition%Coefficient 

                                rp = kd / (1 + kd)
                                rd =  1 / (1 + kd)
                                ConcP = CurrentPartic%Concentration(nProp)
                                ConcD = CurrentProperty%SedimentPartition%CoupleProp
                              
                                Kdp   = CurrentProperty%SedimentPartition%TransferRate
                                dt    = Me%DT_Partic

                                DC    = rp * ConcD - rd * ConcP

                                if (DC > 0.) then
                                ConcP = ConcP + dt * Kdp * (rp * ConcD - rd * ConcP)
                                else
                                    ConcP = (ConcP + dt * Kdp * rp * ConcD) / (1 + dt * Kdp * rd)
                                endif


                                CurrentPartic%Concentration(nProp) = ConcP

                            endif


                            CurrentPartic => CurrentPartic%Next
                        enddo
                    endif

                        nProp           =  nProp + 1
                        CurrentProperty => CurrentProperty%Next
                    

!                        exit CurrProp

!                    else
!                        nProp           =  nProp + 1
 !                       CurrentProperty => CurrentProperty%Next
 !                   endif
                enddo CurrProp


            endif
    
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine PartitionDecay

    !--------------------------------------------------------------------------

    subroutine SubmergeSurfaceHeavyParticles()
    
        !Arguments-------------------------------------------------------------
!        logical, intent(IN)                         :: UpdateParticleAreas

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        integer                                     :: i, j, k, emp
        real                                        :: WaterDensity
        real                                        :: ParticleDensity
        integer                                     :: STAT_CALL

        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                i   = CurrentPartic%Position%I
                j   = CurrentPartic%Position%J
                k   = CurrentPartic%Position%K
                emp = CurrentPartic%Position%ModelID

                WaterDensity        = Me%EulerModel(emp)%Density (i, j, k)

                call GetHNSDensity(CurrentOrigin%ObjHNS, ParticleDensity, STAT = STAT_CALL)
                
                if (CurrentPartic%HNSParticleState .EQ. Surface_) then
                    if (ParticleDensity .GE. WaterDensity) then
                        CurrentPartic%HNSParticleState = WaterColumn_Droplet_
                    endif
                endif
                
                CurrentPartic => CurrentPartic%Next
            enddo

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine SubmergeSurfaceHeavyParticles

    !--------------------------------------------------------------------------

    subroutine UpdateHNSAreaVolume(UpdateParticleAreas)
    
        !Arguments-------------------------------------------------------------
        logical, intent(IN)                         :: UpdateParticleAreas

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        integer                                     :: i, j

        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            CurrentOrigin%AreaTotal        = 0.
            CurrentOrigin%VolumeTotal      = 0.
            CurrentOrigin%VolumeTotalIni   = 0.

            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                i = CurrentPartic%Position%I
                j = CurrentPartic%Position%J
                
                if (.NOT. CurrentPartic%Beached) then
                    if (UpdateParticleAreas) then
                        CurrentPartic%Geometry%Area = CurrentPartic%Geometry%Area + &
                                                      CurrentPartic%HNSSpreadingDiffCoef * Me%DT_Partic
                    endif

                    CurrentOrigin%VolumeTotal       = CurrentOrigin%VolumeTotal +       &
                                                        CurrentPartic%Geometry%Volume
                                                  
                    CurrentOrigin%VolumeTotalIni   = CurrentOrigin%VolumeTotalIni +     &
                                                        CurrentPartic%Geometry%InitialVolume

                    !total area at surface (which is used for spreading) only from surface particles
                    if (CurrentPartic%Position%Surface) then
                        CurrentOrigin%AreaTotal     = CurrentOrigin%AreaTotal  +                &
                                                      CurrentPartic%Geometry%Area
                    endif
                end if
                
                CurrentPartic => CurrentPartic%Next
            enddo

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine UpdateHNSAreaVolume

    !--------------------------------------------------------------------------

    subroutine HNSInitializeParticleValues
        
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        integer                                     :: i, j

        !Begin-----------------------------------------------------------------


        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            CurrentOrigin%AreaTotal        = 0.
            CurrentOrigin%VolumeTotal      = 0.

            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                i = CurrentPartic%Position%I
                j = CurrentPartic%Position%J
                
                CurrentPartic%HNSParticleState   = CurrentOrigin%HNSInitialState
                CurrentPartic%MDegraded          = 0.
               
                CurrentOrigin%HNSMass = CurrentOrigin%HNSMass + CurrentPartic%HNSMass

                CurrentPartic => CurrentPartic%Next
            enddo

                CurrentOrigin%HNSTotalMass = CurrentOrigin%HNSMass +  CurrentOrigin%MDegraded

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine HNSInitializeParticleValues

    !--------------------------------------------------------------------------

    subroutine ComputeAreaVolume ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        real, dimension(:), pointer                 :: NodeX, NodeY, VoronoiArea, Thickness
        integer, dimension(:), pointer              :: BoundaryNodes

        real                                        :: VolInic, AverageThickness, TotalArea
        real                                        :: Density
        integer, dimension(:), pointer              :: NeighborNodesIndex
        integer                                     :: i, j, em, ig, emp, ObjTriangulation, ip, NumberOfNodes, iN, iT        
        integer                                     :: STAT_CALL, NNi, NeighborNodesNumber, ni, ic, NumberOfBoundaryNodes
        real                                        :: dx, dy, dt, Angle, Grad, vx, vy, Aux, x1, y1, t1, AuxT, RAND, dist
        real                                        :: ThicknessLimit, FayArea

        !Begin-----------------------------------------------------------------
        
        do em = 1, Me%EulerModelNumber
            do ig = 1, Me%NGroups
                Me%EulerModel(em)%OilSpreading(ig)%AreaFlag(:,:)           = .true. 
            enddo
        enddo

        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            CurrentOrigin%AreaTotal        = 0.
            CurrentOrigin%VolumeTotal      = 0.
            CurrentOrigin%VolumeOilTotal   = 0.
            CurrentOrigin%VolumeTotalIni   = 0.

            ig = CurrentOrigin%GroupID
            iP = 0
       

            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                i = CurrentPartic%Position%I
                j = CurrentPartic%Position%J
                emp= CurrentPartic%Position%ModelID
                
                if (.NOT. CurrentPartic%Beached) then

                    if (CurrentOrigin%AreaMethod == GridCells_) then
                        if (Me%EulerModel(emp)%OilSpreading(ig)%AreaFlag(i, j)) then
                            CurrentOrigin%AreaTotal = CurrentOrigin%AreaTotal +              &
                                                      Me%EulerModel(emp)%GridCellArea (i, j)
                            Me%EulerModel(emp)%OilSpreading(ig)%AreaFlag(i, j) = .false.
                        endif
                    endif
                    
                    CurrentOrigin%VolumeTotalIni = CurrentOrigin%VolumeTotalIni +       &
                                                        CurrentPartic%Geometry%InitialVolume
                    
                    CurrentOrigin%VolumeTotal    = CurrentOrigin%VolumeTotal    +       &
                                                        CurrentPartic%Geometry%Volume

                    CurrentOrigin%VolumeOilTotal = CurrentOrigin%VolumeOilTotal +       &
                                                        CurrentPartic%Geometry%VolumeOil
                                                        
                    iP = iP + 1
                    !      
                    
!                    if (CurrentOrigin%AreaMethod == VoronoiArea_) then
!                        if (CurrentOrigin%Position%CartX == CurrentPartic%Position%CartX .or. &
!                            CurrentOrigin%Position%CartY == CurrentPartic%Position%CartY) then
                             
!                            call RANDOM_NUMBER(RAND)
!                            CurrentPartic%Position%CartX = CurrentPartic%Position%CartX + (2.-RAND)
!                            call RANDOM_NUMBER(RAND)
!                            CurrentPartic%Position%CartY = CurrentPartic%Position%CartY + (2.-RAND)

!                        endif                            
!                    endif                        
                end if
                
                CurrentPartic => CurrentPartic%Next
            enddo

            NumberOfNodes = iP
            
            
ifay:       if (CurrentOrigin%AreaMethod == FayMethod_ .or.                             &
                CurrentOrigin%AreaMethod == VoronoiArea_ ) then

                call GetOilAPI (CurrentOrigin%ObjOil, API = Density)

                select case (CurrentOrigin%EmissionTemporal)
                case (Continuous_)
                    VolInic = CurrentOrigin%VolumeTotalIni
                case (Instantaneous_)
                    VolInic = CurrentOrigin%PointVolume
                end select            

                FayArea= F_FayArea(VolInic          = VolInic,                          & 
                                   Density          = Density,                          & 
                                   WaterDensity     = GetFirstParticDens(CurrentOrigin),& 
                                   WaterTemperature = GetFirstParticTemp(CurrentOrigin),&
                                   DensityInAPI     = .true.)

            endif ifay                 

iAM:        if (CurrentOrigin%AreaMethod == FayMethod_ .or.                             &
               (CurrentOrigin%AreaMethod == VoronoiArea_ .and. NumberOfNodes < 20)) then
               
               CurrentOrigin%AreaTotal = FayArea

                if (.not. CurrentOrigin%StartWithTriang) then

                    CurrentPartic => CurrentOrigin%FirstPartic    
                   
                    do while (associated(CurrentPartic))
                        if (CurrentOrigin%AreaTotal>0.) then
                            if (NumberOfNodes > 0) then
                                CurrentPartic%Geometry%Thickness = CurrentOrigin%VolumeTotal /    &
                                                                   CurrentOrigin%AreaTotal / real(NumberOfNodes)
                            endif                                    
                        else
                            CurrentPartic%Geometry%Thickness = 0.
                        endif

                        CurrentPartic => CurrentPartic%Next
                    enddo 
                    
                endif

            elseif (CurrentOrigin%AreaMethod == VoronoiArea_ .and. NumberOfNodes >= 20) then iAM

                
                allocate(NodeX      (NumberOfNodes), NodeY      (NumberOfNodes))
                allocate(VoronoiArea(NumberOfNodes), Thickness  (NumberOfNodes))
                VoronoiArea(:) = 0.

                iP = 0
                CurrentPartic => CurrentOrigin%FirstPartic                      
                
                do while (associated(CurrentPartic))

                    if (.not. CurrentPartic%Beached) then
                        iP          = iP + 1                                    
                        NodeX  (iP) = CurrentPartic%Position%CartX
                        NodeY  (iP) = CurrentPartic%Position%CartY
                    endif

                    CurrentPartic => CurrentPartic%Next                        
                                                
                enddo 
                

                CurrentOrigin%StartWithTriang = .true.
                
                ObjTriangulation = 0
                
                !Guarantees no duplicate nodes
                iN = 1
                do while (iN <= NumberOfNodes)
                    iT = iN + 1
                    do while (iT <= NumberOfNodes)
                        dist = sqrt((NodeX(iN)-NodeX(iT))**2.+(NodeY(iN)-NodeY(iT))**2.)
                        if (dist <= 0.) then
                            call RANDOM_NUMBER(RAND)
                            NodeX (iT) = NodeX (iT) + (2.-RAND)
                            call RANDOM_NUMBER(RAND)
                            NodeY (iT) = NodeY (iT) + (2.-RAND)
                        endif
                        iT = iT + 1
                    enddo
                    iN = iN + 1
                enddo                

                call ConstructTriangulation(ObjTriangulation,                           &
                                            NumberOfNodes = NumberOfNodes, NodeX = NodeX,  &
                                            NodeY = NodeY, NodeZ = VoronoiArea,         &
                                            Tolerance = 0., STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR10'   
                
                call CalculateVoronoi (ObjTriangulation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR20'                     

                call GetVoronoiAreaNodes (ObjTriangulation, VoronoiArea, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR30' 
                
                call GetNumberOfBoundaryNodes(ObjTriangulation, NumberOfBoundaryNodes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR40'  
                
                allocate(BoundaryNodes(NumberOfBoundaryNodes))                     
                
                call GetBoundaryNodes(ObjTriangulation, BoundaryNodes, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR50'                    
                
                iP = 0
                CurrentPartic => CurrentOrigin%FirstPartic                      
                
                do while (associated(CurrentPartic))
                
                    if (.not. CurrentPartic%Beached) then                    
                        iP = iP + 1
                        if (VoronoiArea(iP)>0.) then
                            Thickness(iP) = CurrentPartic%Geometry%Volume / VoronoiArea(iP)
                        else
                            Thickness(iP) = null_real
                        endif
                        
                    endif
                    CurrentPartic => CurrentPartic%Next
                    
                enddo    
                
                do iP = 1, NumberOfBoundaryNodes
                    Thickness(BoundaryNodes(iP)) = null_real
                enddo 
                
                nullify(CurrentPartic)
                iP = 0
                CurrentPartic => CurrentOrigin%FirstPartic
                
                AverageThickness = 0.   
                TotalArea        = 0.   
                
                do while (associated(CurrentPartic))
                
ib2:                if (.not. CurrentPartic%Beached) then
                    
                        iP = iP + 1
                        
                        if (iP  > NumberOfNodes) then
                            CurrentPartic%Position%SpreadingAngle = null_real
                            CurrentPartic%Geometry%Thickness      = 0.
                            CurrentPartic => CurrentPartic%Next                             
                            cycle
                        endif
                        
                        call  GetNeighborNodesNumber(ObjTriangulation, iP, NeighborNodesNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR40' 
                        
                        if (abs(NeighborNodesNumber) > 100) then
                            CurrentPartic%Position%SpreadingAngle = null_real
                            CurrentPartic%Geometry%Thickness      = 0.
                            CurrentPartic => CurrentPartic%Next                             
                            cycle
                        endif

                        allocate(NeighborNodesIndex(NeighborNodesNumber))
                        
                        call  GetNeighborNodesIndex(ObjTriangulation, iP, NeighborNodesIndex, STAT = STAT_CALL)
                        
                        if (STAT_CALL /= SUCCESS_) then
                            CurrentPartic%Geometry%Thickness = 0.
                        else                        
                            ic  = 0
                            Aux = 0
                            if (Thickness(iP) > 0) then
                                Aux = Thickness(iP)
                                ic = ic + 1
                            endif
                            ! filter thickness
                            do ni=1, NeighborNodesNumber
                                NNi   = NeighborNodesIndex(ni)
                                if (Thickness(NNi) > 0) then
                                    Aux  = Aux + Thickness(NNi)
                                    ic = ic + 1
                               endif
                            enddo          
                            
                            if (ic > 0) then
                                AuxT = Aux / real(ic)
                                !The thickness of a particle can not decrease more than 50% in one time step
                                !The thickness of a particle can not increase more than 100% in one time step
                                !The thickness of the particle can not be greater than 50 cm. 
                                !This is important when booms and beaching processes induce rapid variations to the slick geometry
                                if (CurrentPartic%Geometry%Thickness > 0) then
                                    CurrentPartic%Geometry%Thickness = min(0.5,CurrentPartic%Geometry%Thickness * 2., &
                                                                        max(CurrentPartic%Geometry%Thickness / 2., AuxT))
                                else
                                    CurrentPartic%Geometry%Thickness = min(0.5,AuxT)
                                endif                                          
                            else
                                CurrentPartic%Geometry%Thickness = 0.
                            endif
                        
                        endif
                        
                        AverageThickness = AverageThickness + CurrentPartic%Geometry%Thickness / real(NumberOfNodes)
                        
                        call GetOilThicknessLimit(CurrentOrigin%ObjOil, ThicknessLimit)
                        
                        if (CurrentPartic%Geometry%Thickness > ThicknessLimit) then
                            TotalArea    = TotalArea    + CurrentPartic%Geometry%Volume / CurrentPartic%Geometry%Thickness
                        endif
                        
                        if (CurrentPartic%Geometry%Thickness > 0) then
                            x1 = NodeX(iP)
                            y1 = NodeY(iP)
                            t1 = CurrentPartic%Geometry%Thickness
                            vx = 0
                            vy = 0

                            do ni=1, NeighborNodesNumber
                                NNi   = NeighborNodesIndex(ni)
                                if (NNi > 0 .and. NNi <= NumberOfNodes) then
                                    if (Thickness(NNi) > 0) then
                                        dx    = NodeX    (NNi) - x1
                                        dy    = NodeY    (NNi) - y1
                                        dt    = Thickness(NNi) - t1
                                        if (dy == 0. .and. dx == 0.) cycle
                                        Angle = atan2(dy,dx)
                                        Grad  = - dt / sqrt(dx**2+dy**2)
                                        vx    = vx + Grad * cos(Angle)
                                        vy    = vy + Grad * sin(Angle)
                                    endif
                                endif                                    
                            enddo
                            if (vy == 0. .and. vx == 0.) then
                                CurrentPartic%Position%SpreadingAngle = null_real
                            else
                                CurrentPartic%Position%SpreadingAngle = atan2(vy,vx)
                            endif
                        else
                            CurrentPartic%Position%SpreadingAngle = null_real
                        endif                            
                        
                        deallocate(NeighborNodesIndex)    
                        
                    endif ib2
                    
                    CurrentPartic => CurrentPartic%Next                        
                enddo   
                                     
                nullify(CurrentPartic)
                
                deallocate(NodeX, NodeY, VoronoiArea, Thickness, BoundaryNodes) 
                nullify   (NodeX, NodeY, VoronoiArea, Thickness, BoundaryNodes) 
                
                call KillTriangulation(ObjTriangulation, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ComputeAreaVolume - ModuleLagrangianGlobal - ERR40'   

                if (CurrentOrigin%FayTotalArea) then
                    CurrentOrigin%AreaTotal= FayArea
                else
                    CurrentOrigin%AreaTotal= max (TotalArea, FayArea)
                endif
                
            endif iAM

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        

    end subroutine ComputeAreaVolume

    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------

    subroutine CheckDepositionCriticalSlope ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        real,   dimension(:,:), pointer             :: DUX, DVY
        integer                                     :: i, j, em, ig
        integer                                     :: WS_JLB, WS_JUB, WS_ILB, WS_IUB, WS_KUB
        real                                        :: dBottom_dxy, Bathym2, Bathym1, dBottom_dx, dBottom_dy
        real                                        :: Vel_Dir, Vel_dBottom_X, Vel_dBottom_Y, DZ, v, d, dv, SlopeVel
        real                                        :: Vel1, Vel2, Vel3, dAux
        integer                                     :: STAT_CALL
        logical                                     :: PartInside

        !Begin-----------------------------------------------------------------

        


cd3:    if (Me%State%Deposition .and. Me%State%CriticalSlope) then 
    
d1:         do em = 1, Me%EulerModelNumber 


                WS_ILB = Me%EulerModel(em)%WorkSize%ILB
                WS_IUB = Me%EulerModel(em)%WorkSize%IUB
                WS_JLB = Me%EulerModel(em)%WorkSize%JLB
                WS_JUB = Me%EulerModel(em)%WorkSize%JUB
                WS_KUB = Me%EulerModel(em)%WorkSize%KUB

                do ig = 1, Me%NGroups
                do j = WS_JLB, WS_JUB
                do i = WS_ILB, WS_IUB

                    Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) = 0. 
                    Me%EulerModel(em)%Lag2Euler%GridBottomVolume     (i,j,ig) = 0. 

                enddo
                enddo
                enddo
    
        
dg:             do ig = 1, Me%NGroups 

                    !Integrates the Volume and the Mass in each GridCell
                    CurrentOrigin => Me%FirstOrigin
    CurrOr:         do while (associated(CurrentOrigin))

                        if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                            CurrentPartic => CurrentOrigin%FirstPartic
                            do while (associated(CurrentPartic))

       
                                if (em == CurrentPartic%Position%ModelID) then

                                    i = CurrentPartic%Position%I
                                    j = CurrentPartic%Position%J
                    
                                else

                                    PartInside = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid, &
                                                                   CurrentPartic%Position%CoordX,       &
                                                                   CurrentPartic%Position%CoordY,       &
                                                                   Referential = GridCoord_,            &
                                                                   STAT = STAT_CALL)

                                    if (STAT_CALL /= SUCCESS_) then
                                            stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR10'
                                    endif                                                                                    

                                    if (PartInside) then

                                        call GetXYCellZ(Me%EulerModel(em)%ObjHorizontalGrid,        &
                                                        CurrentPartic%Position%CoordX,              &
                                                        CurrentPartic%Position%CoordY, i, j,        &
                                                        Referential = GridCoord_,                   &
                                                        Iold        = CurrentPartic%Position%I,     &
                                                        Jold        = CurrentPartic%Position%J,     &
                                                        STAT        = STAT_CALL)

                                        if (STAT_CALL /= SUCCESS_) then
                                            stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR20'
                                        endif                                            

                                    else
                                        CurrentPartic => CurrentPartic%Next
                                        cycle
                                    endif
                    
                                endif
                    
                                if (CurrentPartic%Deposited) then

                                    Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) =      &
                                        Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) +  & 
                                        CurrentPartic%Geometry%Volume
                        

                                else                            

                                    Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) =      &
                                        Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) +  & 
                                        CurrentPartic%Geometry%Volume
                            
                                endif  
                                
                                CurrentPartic => CurrentPartic%Next
                                
                            enddo
                        endif
                        CurrentOrigin => CurrentOrigin%Next
                    enddo CurrOr
                    
                enddo dg

                    
                !Gets Horizontal Grid
                call GetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DUX = DUX, DVY = DVY, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR30'
                endif                    

g3:             do ig = 1, Me%NGroups

                    do j = WS_JLB, WS_JUB
                    do i = WS_ILB, WS_IUB

                        if (Me%EulerModel(em)%Waterpoints3D (i, j, WS_KUB) == WaterPoint) then

                            ! Volume / m2 = m
                            Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) = &
                                    Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) / DUX(I, j) / DVY(i, j)

                            ! Volume / m2 = m
                            Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) = &
                                    Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) / DUX(I, j) / DVY(i, j)
                            
                        endif

                    enddo
                    enddo                            

                    do j = WS_JLB, WS_JUB
                    do i = WS_ILB, WS_IUB

                        if (Me%EulerModel(em)%Waterpoints3D (i, j, WS_KUB) == WaterPoint) then

                            dBottom_dx = 0.
                            dBottom_dy = 0.
                            
                            Bathym1  =   Me%EulerModel(em)%Bathymetry(i, j) - Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig)
                                    
                            if (Me%EulerModel(em)%Waterpoints3D (i-1, j, WS_KUB) == WaterPoint) then
                                Bathym2   =   Me%EulerModel(em)%Bathymetry(i-1, j)
                                Bathym2   =   Bathym2 - Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i-1,j,ig)
                                dBottom_dy = (Bathym1 - Bathym2) / DVY(i, j) 
                            endif     
                                    
                            if (Me%EulerModel(em)%Waterpoints3D (i+1, j, WS_KUB) == WaterPoint) then
                                Bathym2   =   Me%EulerModel(em)%Bathymetry(i+1, j)
                                Bathym2   =   Bathym2 - Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i+1,j,ig)

                                dAux = (Bathym2 - Bathym1) / DVY(i, j)
                                if (abs(dBottom_dy) < abs(dAux)) then
                                    dBottom_dy = dAux
                                endif                                    
                            endif                                         
                                    
                            if (Me%EulerModel(em)%Waterpoints3D (i, j-1, WS_KUB) == WaterPoint) then
                                Bathym2   =   Me%EulerModel(em)%Bathymetry(i, j-1)
                                Bathym2   =   Bathym2 - Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j-1,ig)
                                dBottom_dx  = (Bathym1 - Bathym2) / DUX(i, j)
                            endif                                                                             

                            if (Me%EulerModel(em)%Waterpoints3D (i, j+1, WS_KUB) == WaterPoint) then
                                Bathym2   =   Me%EulerModel(em)%Bathymetry(i, j+1)
                                Bathym2   =   Bathym2 - Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j+1,ig)
                                dAux = (Bathym2 - Bathym1) / DUX(i, j)
                                if (abs(dBottom_dx) < abs(dAux)) then
                                    dBottom_dx = dAux
                                endif                                    
                            endif
                                    
                            dBottom_dxy = sqrt(dBottom_dx**2 + dBottom_dy**2)    
                            
                            Me%EulerModel(em)%Lag2Euler%GridBottomSlope(i,j,ig)  = dBottom_dxy
                            
                            if (dBottom_dxy > Me%FirstOrigin%Deposition%CriticalSlope .and.         &
                                    Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) >          &
                                    Me%FirstOrigin%Deposition%CriticalThickness) then
                                    
                                dv = 0.
                            
                                call RANDOM_NUMBER(v)
                                    
                                    
                                dv = Me%FirstOrigin%Deposition%CriticalSlopeVelUncertainty * (2 * v - 1) 
                                dv = dv + 1
                                
                                SlopeVel = Me%FirstOrigin%Deposition%CriticalSlopeVel *  dv
                                            
                                Vel_Dir  = atan2(dBottom_dy,dBottom_dx)
                                            
                                call RANDOM_NUMBER(d)
                                    
                                if (d > 0.5) then
                                    Vel_Dir     = Vel_Dir + pi / 4 * (1-d)
                                else
                                    Vel_Dir     = Vel_Dir - pi / 4 * d
                                endif    
                                            
                                Me%EulerModel(em)%Lag2Euler%GridVelSlope_X(i,j,ig) = SlopeVel * cos(Vel_Dir)
                                
                                Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y(i,j,ig) = SlopeVel * sin(Vel_Dir)
                                
                            else
                                
                                Me%EulerModel(em)%Lag2Euler%GridVelSlope_X(i,j,ig) = 0.
                                Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y(i,j,ig) = 0.
                                
                            endif
                            
                        endif

                    enddo
                    enddo
                    
                    
                enddo g3


dg4:            do ig = 1, Me%NGroups 

                    !Integrates the Volume and the Mass in each GridCell
                    CurrentOrigin => Me%FirstOrigin
                    
CurrOr4:            do while (associated(CurrentOrigin))

                        if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                            CurrentPartic => CurrentOrigin%FirstPartic
                            do while (associated(CurrentPartic))

       
                                if (em == CurrentPartic%Position%ModelID) then

                                    i = CurrentPartic%Position%I
                                    j = CurrentPartic%Position%J
                    
                                else

                                    PartInside = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid, &
                                                                   CurrentPartic%Position%CoordX,       &
                                                                   CurrentPartic%Position%CoordY,       &
                                                                   Referential = GridCoord_,            &
                                                                   STAT = STAT_CALL)

                                    if (STAT_CALL /= SUCCESS_) then
                                            stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR40'
                                    endif                                                                                    

                                    if (PartInside) then

                                        call GetXYCellZ(Me%EulerModel(em)%ObjHorizontalGrid,        &
                                                        CurrentPartic%Position%CoordX,              &
                                                        CurrentPartic%Position%CoordY, i, j,        &
                                                        Referential = GridCoord_,                   &
                                                        Iold        = CurrentPartic%Position%I,     &
                                                        Jold        = CurrentPartic%Position%J,     &
                                                        STAT        = STAT_CALL)

                                        if (STAT_CALL /= SUCCESS_) then
                                            stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR50'
                                        endif                                            

                                    else
                                        CurrentPartic => CurrentPartic%Next
                                        cycle
                                    endif
                    
                                endif
                    
                                if (CurrentPartic%Deposited) then
                                    
                                    dBottom_dxy = Me%EulerModel(em)%Lag2Euler%GridBottomSlope(i,j,ig)
                                        
                                    if (dBottom_dxy > CurrentOrigin%Deposition%CriticalSlope) then
                                        
                                        CurrentPartic%Deposited = .false.                                         

                                        Vel1 = Me%EulerModel(em)%Lag2Euler%GridVelSlope_X(i,j-1,ig)
                                        Vel2 = Me%EulerModel(em)%Lag2Euler%GridVelSlope_X(i,j  ,ig)
                                        Vel3 = Me%EulerModel(em)%Lag2Euler%GridVelSlope_X(i,j+1,ig)
                                        
                                        if (Vel2 > 0) then
                                            Vel_dBottom_X = 0.5 * Vel1 + 0.5 * Vel2
                                        else
                                            Vel_dBottom_X = 0.5 * Vel2 + 0.5 * Vel3
                                        endif                                            
                                        
                                        Vel1 =  Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y(i-i,j,ig)
                                        Vel2 =  Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y(i  ,j,ig)
                                        Vel3 =  Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y(i+1,j,ig)
                                        
                                        if (Vel2 > 0) then
                                            Vel_dBottom_Y = 0.5 * Vel1 + 0.5 * Vel2
                                        else
                                            Vel_dBottom_Y = 0.5 * Vel2 + 0.5 * Vel3
                                        endif                                              
                                        
                                        DZ = Me%EulerModel(em)%Bathymetry(i, j) - CurrentPartic%Position%Z
                                        
                                        call MoveSingleParticAlongBottom(CurrentOrigin, CurrentPartic, &
                                                                            Vel_dBottom_X, Vel_dBottom_Y, DZ)
                                            
                                    endif

                                endif                        
                            
                                CurrentPartic => CurrentPartic%Next
                            enddo
                        endif
                        CurrentOrigin => CurrentOrigin%Next
                    enddo CurrOr4
                    
                enddo dg4

                !UnGets Horizontal Grid
                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DUX, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR60'
                endif                    

                !UnGets Horizontal Grid
                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DVY,      &
                                        STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    stop 'CheckDepositionCriticalSlope - ModuleLagrangianGlobal - ERR70'
                endif

            enddo d1
            
        endif cd3

    
    end subroutine CheckDepositionCriticalSlope
!
!--------------------------------------------------------------------------   
    
    function FromGrid2DToParticleXY(CurrentPartic, Matrix2D, WaterPoints2D)    
    

        !Arguments-------------------------------------------------------------
        type (T_Partic),    pointer                 :: CurrentPartic
        real,     dimension(:,:), pointer           :: Matrix2D
        integer,  dimension(:,:), pointer           :: WaterPoints2D        
        real                                        :: FromGrid2DToParticleXY

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, em
        real                                        :: ValueSW, ValueNW, ValueSE, ValueNE, ValueN, ValueS
        integer                                     :: MaskSW, MaskNW, MaskSE, MaskNE, MaskN, MaskS       
        real                                        :: X_W, X_E, Xv, Y_S, Y_N, Yv, PercI, PercJ
        real                                        :: InterpolBilinear
        integer                                     :: jW, jE, iS, iN

        !Begin-----------------------------------------------------------------
        
                                 
        !Cell Postition
        i = CurrentPartic%Position%I
        j = CurrentPartic%Position%J

        !Fraction of the cell
        PercJ  = CurrentPartic%Position%CellJ - real(j) + 1
        PercI  = CurrentPartic%Position%CellI - real(i) + 1  
        
        if (PercJ > 0.5) then
            jW = j
            jE = j+1
            Xv = PercJ - 0.5
        else
            jW = j-1
            jE = j
            Xv = PercJ + 0.5
        endif
                
        if (PercI > 0.5) then
            iS = i
            iN = i+1
            Yv = PercI - 0.5
        else
            iS = i-1
            iN = i
            Yv = PercI + 0.5
        endif            
                
        X_W = 0.
        X_E = 1
        Y_S = 0.                
        Y_N = 1.
                
        ValueSW     = Matrix2D(iS, jW)
        ValueSE     = Matrix2D(iS, jE)
        ValueNW     = Matrix2D(iN, jW)
        ValueNE     = Matrix2D(iN, jE)
                
        em  = CurrentPartic%Position%ModelID         
        
        MaskSW      = WaterPoints2D (iS, jW)
        MaskSE      = WaterPoints2D (iS, jE)
        MaskNW      = WaterPoints2D (iN, jW)
        MaskNE      = WaterPoints2D (iN, jE)

        if (ValueSW < FillValueReal/1e4) ValueSW = 0.
        if (ValueSE < FillValueReal/1e4) ValueSE = 0.                
        if (ValueNW < FillValueReal/1e4) ValueNW = 0.                
        if (ValueNE < FillValueReal/1e4) ValueNE = 0.     
                    
                    
        if (MaskNW == WaterPoint .and. MaskNE == WaterPoint) then
            ValueN = LinearInterpolation (X_W, ValueNW, X_E, ValueNE, Xv)
            MaskN  = 1
        elseif (MaskNW == WaterPoint) then
            ValueN = ValueNW
            MaskN  = 1
        elseif (MaskNE == WaterPoint) then
            ValueN = ValueNE
            MaskN  = 1
        else
            MaskN  = 0
        endif

        if (MaskSW == WaterPoint .and. MaskSE == WaterPoint) then
            ValueS = LinearInterpolation (X_W, ValueSW, X_E, ValueSE, Xv)
            MaskS  = 1
        elseif (MaskSW == WaterPoint) then
            ValueS = ValueSW
            MaskS  = 1
        elseif (MaskSE == WaterPoint) then
            ValueS = ValueSE
            MaskS  = 1
        else
            MaskS  = 0
        endif
                        
        if (MaskN == WaterPoint .and. MaskS == WaterPoint) then
            InterpolBilinear = LinearInterpolation (Y_S, ValueS, Y_N, ValueN, Yv)
        else if (MaskN == WaterPoint) then
            InterpolBilinear = ValueN
        else if (MaskS == WaterPoint) then
            InterpolBilinear = ValueS
        else
            InterpolBilinear  = FillValueReal
        endif
        
        FromGrid2DToParticleXY = InterpolBilinear
        
    
    end function FromGrid2DToParticleXY
    
!--------------------------------------------------------------------------       
    
    subroutine MoveSingleParticAlongBottom(CurrentOrigin, CurrentPartic, VelX, VelY, DZ)    
    

        !Arguments-------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic
        real                                        :: VelX, VelY, DZ
   

        !Local-----------------------------------------------------------------
        type (T_Position)                           :: NewPosition
        real                                        :: DX, DY
        integer                                     :: i, j, em, KUB
        logical                                     :: ConvertOK

        !Begin-----------------------------------------------------------------
        
                
        DX = VelX * Me%DT_Partic
        DY = VelY * Me%DT_Partic     
        
        !New Position
        NewPosition%X = CurrentPartic%Position%X + DX 
        NewPosition%Y = CurrentPartic%Position%Y + DY 
                    
                
        !As a first approach
        NewPosition%ModelID = CurrentPartic%Position%ModelID
        NewPosition%I       = CurrentPartic%Position%I
        NewPosition%J       = CurrentPartic%Position%J
                
        call Convert_XY_CellIJ(Me%EulerModel(NewPosition%ModelID),NewPosition,  &
                                Referential = AlongGrid_, ConvertOK = ConvertOK)           
        
        if (ConvertOK) then
            
            i = NewPosition%I
            j = NewPosition%J
            
            em  = NewPosition%ModelID         
            KUB = Me%EulerModel(em)%WorkSize%KUB
            
            if (Me%EulerModel(em)%Waterpoints3D (i, j, KUB) == WaterPoint) then
            
                !Bottom distance is maintain 
                NewPosition%Z = Me%EulerModel(em)%Bathymetry(i, j) - DZ

                call Convert_Z_CellK (CurrentOrigin, Me%EulerModel(NewPosition%ModelID), &
                                                        NewPosition)
                call Convert_CellK_K (NewPosition)
            
                CurrentPartic%Position = NewPosition
                
            endif                
            
        endif            
    
    end subroutine MoveSingleParticAlongBottom
    
    !--------------------------------------------------------------------------        

    subroutine InternalParticHNS ()

        !Arguments-------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic    
        real, dimension(:, :, :), pointer           :: Temperature3D
        real, dimension(:, :, :), pointer           :: SPM3D
        integer                                     :: i, j, k, emp, KUB
        real                                        :: WaterTemperature, WaterDensity, SPM 
        real                                        :: UWIND, VWIND, Wind, AirTemperature, AtmPressure, WaveHeight, WavePeriod
        real                                        :: UCURRENT, VCURRENT, Currents
        type (T_Time)                               :: LagrangianTime
        integer                                     :: STAT_CALL
        integer                                     :: old_emp
        real                                        :: MassIn, MassOUT
        integer                                     :: HNSParticleStateNew, HNSParticleStateOld
        real                                        :: HNSParticleDepth


        !Local-----------------------------------------------------------------


        LagrangianTime = Me%Now

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

i1:         if (CurrentOrigin%nParticle > 0)  then
                CurrentOrigin%MEvaporated   = 0.
                CurrentOrigin%MVolatilized  = 0.
                CurrentOrigin%MEntrained    = 0.
                CurrentOrigin%MDissolved    = 0.
                CurrentOrigin%MSedimented   = 0.
                CurrentOrigin%MDeposited    = 0.
                CurrentOrigin%MSurface      = 0.
                CurrentOrigin%MDegraded     = 0.
                CurrentOrigin%HNSMass       = 0.
                CurrentOrigin%HNSTotalMass  = 0.
                CurrentPartic                           => CurrentOrigin%FirstPartic

                emp         = null_int
                old_emp     = null_int
                do while (associated(CurrentPartic))

                    i       = CurrentPartic%Position%I
                    j       = CurrentPartic%Position%J
                    k       = CurrentPartic%Position%K
                    emp     = CurrentPartic%Position%ModelID
                         
!                    if (emp /= old_emp) then
                        !Gets the temperature, the Density and the SPM from the Eulerian model
                        call GetConcentration(Me%EulerModel(emp)%ObjWaterProperties,             &
                                              ConcentrationX    = Temperature3D,                &
                                              PropertyXIDNumber = Temperature_,                 &
                                              STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'InternalParticHNS - ModuleLagrangianGlobal - ERR01'

                        if (CurrentOrigin%State%HNSSedimentation) then
                            call GetSPM          (Me%EulerModel(emp)%ObjWaterProperties,             &
                                                  SPM               = SPM3D,                        &
                                                  STAT              = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'InternalParticHNS - ModuleLagrangianGlobal - ERR02'
                        end if                 
!                    endif
                    
                    if (CurrentOrigin%State%HNSSedimentation) then
                        SPM                 = SPM3D(i,j,k)
                    else
                        SPM                 = FillValueReal
                    endif

                    WaterTemperature    = Temperature3D(i,j,k)
                    WaterDensity        = Me%EulerModel(emp)%Density (i, j, k)
                    
!                    if (emp /= old_emp) then
                        !Ungets Concentration from the eulerian module
                        call UngetWaterProperties (Me%EulerModel(emp)%ObjWaterProperties, Temperature3D, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'InternalParticHNS - ModuleLagrangianGlobal - ERR10'

                        if (CurrentOrigin%State%HNSSedimentation) then
                            call UngetWaterProperties (Me%EulerModel(emp)%ObjWaterProperties,  SPM3D, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'InternalParticHNS - ModuleLagrangianGlobal - ERR11'
                        end if
!                    endif
                   

                   if (CurrentPartic%WindX < HalfFillValueReal) then
                            if (associated(Me%EulerModel(emp)%WindX)) then
                                CurrentPartic%WindX = Me%EulerModel(emp)%WindX(i,j)
                            else
                                CurrentPartic%WindX = 0.
                            end if
                    endif

                   if (CurrentPartic%WindY < HalfFillValueReal) then
                            if (associated(Me%EulerModel(emp)%WindY)) then
                                CurrentPartic%WindY = Me%EulerModel(emp)%WindY(i,j)
                            else
                                CurrentPartic%WindY = 0.
                            end if
                    endif

                    UWIND = CurrentPartic%WindX
                    VWIND = CurrentPartic%WindY

                    Wind    = abs(cmplx(UWIND, VWIND))
                    
                    UCURRENT = CurrentPartic%CurrentX
                    VCURRENT = CurrentPartic%CurrentY
                    
                    Currents = abs(cmplx(UCURRENT, VCURRENT))
                    
                    !Adios do not support values larger than 35 m/s. The same methodology is followed in MOHID.
                    Wind    = min(35.,Wind) 
                    
                    AirTemperature      = Me%EulerModel(emp)%AirTemperature2D(i, j)

                    AtmPressure         = Me%EulerModel(emp)%AtmPressure(i, j)

                    if (CurrentPartic%WaveHeight < HalfFillValueReal) then
                        CurrentPartic%WaveHeight = Me%EulerModel(emp)%WaveHeight2D (i, j)  
                    endif
                    
                    WaveHeight = CurrentOrigin%FirstPartic%WaveHeight

                    if (CurrentPartic%WavePeriod < HalfFillValueReal) then
                        CurrentPartic%WavePeriod = Me%EulerModel(emp)%WavePeriod2D (i, j)  
                    endif
                    
                    WavePeriod = CurrentOrigin%FirstPartic%WavePeriod
                    
                    HNSParticleDepth =  CurrentPartic%Position%Z - &
                                        Me%EulerModel(emp)%SZZ(i, j,Me%EulerModel(emp)%WorkSize%KUB)
                    if (HNSParticleDepth < 0.)       HNSParticleDepth = 0. 


                    HNSParticleStateOld = CurrentPartic%HNSParticleState

                    MassIn = CurrentPartic%HNSMass
                    call HNSInternalProcesses(CurrentOrigin%ObjHNS,                               &
                                          Wind                  = Wind,                           &
                                          Currents              = Currents,                       &
                                          WaterTemperature      = WaterTemperature,               &
                                          WaterDensity          = WaterDensity,                   &
                                          SPM                   = SPM,                            &
                                          AirTemperature        = AirTemperature,                 &
                                          AtmPressure           = AtmPressure,                    &
                                          WaveHeight            = CurrentPartic%WaveHeight,       &
                                          WavePeriod            = CurrentPartic%WavePeriod,       &
                                          Area                  = CurrentPartic%Geometry%Area,    &
                                          InitialMass           = CurrentPartic%HNSInitialMass,   &
                                          MassIn                = MassIn,                         &
                                          DropletsDiameterIN    = CurrentPartic%Geometry%DropletsDiameter, &
                                          HNSParticleStateIN    = HNSParticleStateOld,            &
                                          Depth                 = HNSParticleDepth,               &
                                          Density               = CurrentPartic%HNSDensity,       &
                                          MassOUT               = MassOUT,                        &
                                          VolumeOUT             = CurrentPartic%Geometry%Volume,  &
                                          DropletsDiameterOUT   = CurrentPartic%Geometry%DropletsDiameter, &  
                                          HNSParticleStateOUT   = HNSParticleStateNew, &
                                          STAT                  = STAT_CALL)                    
                    CurrentPartic%HNSMass = MassOUT 
                    
                    if (CurrentOrigin%State%HNSEntrainment) then
                         KUB     = Me%EulerModel(emp)%WorkSize%KUB
                        !verifiy if particle is entrained
                        call VerifyEntrainment(HNSParticleStateOld = HNSParticleStateOld,                   &
                                              HNSParticleStateNew = HNSParticleStateNew,                    &
                                              WaveHeight          = WaveHeight,                             &
                                              BottomDepth         = Me%EulerModel(emp)%WaterColumn(i, j),   &
                                              SurfaceDepth        = Me%EulerModel(emp)%SZZ(i, j, KUB),      &
                                              ParticlePositionZ   = CurrentPartic%Position%Z)
                    endif
                                        

                    CurrentPartic%MDegraded        = CurrentPartic%MDegraded + MassIn - MassOut
                    CurrentPartic%HNSParticleState = HNSParticleStateNew
                    
                    old_emp = emp

                    !Update Mass Balances
                    CurrentOrigin%HNSMass           = CurrentOrigin%HNSMass +  CurrentPartic%HNSMass
                    CurrentOrigin%MDegraded = CurrentOrigin%MDegraded + CurrentPartic%MDegraded
                    Select Case (CurrentPartic%HNSParticleState)
                    Case(Air_Evaporated_)
                        CurrentOrigin%MEvaporated    = CurrentOrigin%MEvaporated + CurrentPartic%HNSMass
                    Case(Air_Volatilized_)
                        CurrentOrigin%MVolatilized   = CurrentOrigin%MVolatilized + CurrentPartic%HNSMass
                    case(Surface_)
                        CurrentOrigin%MSurface   = CurrentOrigin%MSurface + CurrentPartic%HNSMass
                    Case(WaterColumn_Droplet_)
                        CurrentOrigin%MEntrained     = CurrentOrigin%MEntrained + CurrentPartic%HNSMass
                    Case(WaterColumn_Dissolved_)
                        CurrentOrigin%MDissolved     = CurrentOrigin%MDissolved + CurrentPartic%HNSMass
                    Case(WaterColumn_Sedimented_)
                        CurrentOrigin%MSedimented    = CurrentOrigin%MSedimented + CurrentPartic%HNSMass
                    Case(Bottom_Deposited_)
                        CurrentOrigin%MDeposited     = CurrentOrigin%MDeposited + CurrentPartic%HNSMass
                    End Select
                    

                    CurrentPartic => CurrentPartic%Next

                enddo

                CurrentOrigin%HNSTotalMass = CurrentOrigin%HNSMass +  CurrentOrigin%MDegraded

            endif i1

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine InternalParticHNS

    !--------------------------------------------------------------------------

    subroutine UpdateHNSMass
    
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        type (T_Partic),    pointer                 :: CurrentPartic

        !Begin-----------------------------------------------------------------
       
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
            CurrentOrigin%MEvaporated = 0.
            CurrentOrigin%MVolatilized = 0.
            CurrentOrigin%MDissolved = 0.
            CurrentOrigin%MEntrained = 0.
            CurrentOrigin%MSedimented = 0.
            CurrentOrigin%MDeposited = 0.
            CurrentOrigin%MSurface = 0.
            CurrentOrigin%HNSFractionEvaporated = 0.
            CurrentOrigin%HNSFractionVolatilized = 0.
            CurrentOrigin%HNSFractionDissolved = 0.
            CurrentOrigin%HNSFractionEntrained = 0.
            CurrentOrigin%HNSFractionSedimented = 0.
            CurrentOrigin%HNSFractionDeposited = 0.
            CurrentOrigin%HNSFractionAtSurface = 0.
            CurrentOrigin%HNSFractionBeached = 0.
            CurrentOrigin%HNSFractionDegraded = 0.
            CurrentOrigin%MBeached = 0.
            CurrentOrigin%HNSTotalMass = 0.
            CurrentOrigin%HNSMass   = 0.
            CurrentOrigin%MDegraded = 0.

            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))
                if (.NOT. CurrentPartic%Beached) then

                    select case(CurrentPartic%HNSParticleState)

                    case(Air_Evaporated_)
                        CurrentOrigin%MEvaporated = CurrentOrigin%MEvaporated + CurrentPartic%HNSMass
                    
                    case(Air_Volatilized_)
                        CurrentOrigin%MVolatilized = CurrentOrigin%MVolatilized + CurrentPartic%HNSMass

                    case(Surface_)
                        CurrentOrigin%MSurface = CurrentOrigin%MSurface + CurrentPartic%HNSMass
                    
                    case (WaterColumn_Droplet_) 
                        CurrentOrigin%MEntrained = CurrentOrigin%MEntrained + CurrentPartic%HNSMass

                    case (WaterColumn_Dissolved_) 
                        CurrentOrigin%MDissolved = CurrentOrigin%MDissolved + CurrentPartic%HNSMass

                    case (WaterColumn_Sedimented_)
                        CurrentOrigin%MSedimented = CurrentOrigin%MSedimented + CurrentPartic%HNSMass

                    case (Bottom_Deposited_)
                        CurrentOrigin%MDeposited = CurrentOrigin%MDeposited + CurrentPartic%HNSMass
                    end select
                    
                elseif (CurrentPartic%Beached) then

                    CurrentOrigin%MBeached = CurrentOrigin%MBeached +  CurrentPartic%HNSMass

                end if

                CurrentOrigin%HNSMass   = CurrentOrigin%HNSMass +  CurrentPartic%HNSMass
                CurrentOrigin%MDegraded = CurrentOrigin%MDegraded + CurrentPartic%MDegraded
                
                CurrentPartic => CurrentPartic%Next
            enddo
            
            CurrentOrigin%HNSTotalMass = CurrentOrigin%HNSMass +  CurrentOrigin%MDegraded
            
            if (CurrentOrigin%HNSTotalMass .GT. 0.) then
                CurrentOrigin%HNSFractionEvaporated = CurrentOrigin%MEvaporated / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionVolatilized = CurrentOrigin%MVolatilized / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionDissolved = CurrentOrigin%MDissolved / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionEntrained = CurrentOrigin%MEntrained / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionSedimented = CurrentOrigin%MSedimented / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionDeposited = CurrentOrigin%MDeposited / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionAtSurface = CurrentOrigin%MSurface / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionBeached = CurrentOrigin%MBeached / CurrentOrigin%HNSTotalMass
                CurrentOrigin%HNSFractionDegraded = CurrentOrigin%MDegraded / CurrentOrigin%HNSTotalMass
            endif
            
            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
       
    end subroutine UpdateHNSMass
    
    !--------------------------------------------------------------------------

    subroutine ComputeHNSGridProperties()
    
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin),    pointer                 :: CurrentOrigin
        !Begin-----------------------------------------------------------------

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            call HNSGridConc3D(CurrentOrigin)
            call HNSGridConc2D(CurrentOrigin)
            call HNSGridMaxConc2D(CurrentOrigin)

!            !Deposited
!            call HNSGridConc3D(CurrentOrigin, "SedimentParticulates")
!            call HNSGridConc2D(CurrentOrigin, "SedimentParticulates")
!            call HNSGridDissolvedMaxConc2D(CurrentOrigin, "SedimentParticulates")

            CurrentOrigin => CurrentOrigin%Next
        enddo CurrOr
        
    end subroutine ComputeHNSGridProperties    

    !--------------------------------------------------------------------------

    subroutine  VerifyEntrainment(HNSParticleStateOld, HNSParticleStateNew, WaveHeight, BottomDepth, &
                                  SurfaceDepth, ParticlePositionZ)
    
        !Arguments-------------------------------------------------------------
        integer,           intent(IN )              :: HNSParticleStateOld
        integer,           intent(IN )              :: HNSParticleStateNew
        real,              intent(IN )              :: WaveHeight
        real,              intent(IN)               :: SurfaceDepth
        real,              intent(IN)               :: BottomDepth
        real,              intent(OUT )             :: ParticlePositionZ

        !Local-----------------------------------------------------------------
        real                                        :: r2
        !----------------------------------------------------------------------
        
        if ((HNSParticleStateOld .EQ. Surface_) .AND. (HNSParticleStateNew .EQ. WaterColumn_Droplet_)) then
            call random_number(r2)
!            BreakingWaveHeight = 1.5 * WaveHeight
            ParticlePositionZ = min(r2 * 1.5 * WaveHeight + SurfaceDepth, BottomDepth)          
        endif
           
    end subroutine VerifyEntrainment
    
    !--------------------------------------------------------------------------

    subroutine InternalParticOil ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic    
        real, dimension(:, :, :), pointer           :: Temperature3D
        real, dimension(:, :, :), pointer           :: SPM3D
        integer                                     :: i, j, k, emp 
        real                                        :: WaterTemperature, WaterDensity, SPM
        real                                        :: UWIND, VWIND, Wind
        real                                        :: AtmPressure 
        real                                        :: WaveHeight, WavePeriod
        real(8)                                     :: Factor
        real                                        :: VWaterContent, MWaterContent
        real                                        :: MDispersed
        real                                        :: OilDensity
        real                                        :: OilViscosity
        real                                        :: FMEvaporated
        real                                        :: FMDispersed     
        real                                        :: AreaTotalOUT
        real                                        :: VolumeTotalOUT, VolOld
        integer                                     :: STAT_CALL
        real                                        :: MassINI
        real                                        :: MDissolvedDT
        integer                                     :: NbrParticlesNotBeached
        type (T_Time)                               :: LagrangianTime


        LagrangianTime = Me%Now

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
            
i1:         if (CurrentOrigin%State%Oil .and. CurrentOrigin%nParticle > 0 .and.         &
                CurrentOrigin%Fblowout < CurrentOrigin%CDispOilOff) then

                i       = CurrentOrigin%FirstPartic%Position%I
                j       = CurrentOrigin%FirstPartic%Position%J
                k       = CurrentOrigin%FirstPartic%Position%K
                emp     = CurrentOrigin%FirstPartic%Position%ModelID


                !Gets the temperature, the Density and the SPM from the Eulerian model
                call GetConcentration(Me%EulerModel(emp)%ObjWaterProperties,             &
                                      ConcentrationX    = Temperature3D,                &
                                      PropertyXIDNumber = Temperature_,                 &
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'InternalParticOil - ModuleLagrangianGlobal - ERR01'

                if (CurrentOrigin%State%OilSedimentation) then
                    call GetSPM          (Me%EulerModel(emp)%ObjWaterProperties,             &
                                          SPM               = SPM3D,                        &
                                          STAT              = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'InternalParticOil - ModuleLagrangianGlobal - ERR02'
                    SPM = SPM3D                     (i, j, k)
                else
                    SPM = FillValueReal
                end if                 

               if (CurrentOrigin%FirstPartic%WindX < HalfFillValueReal) then
                        if (associated(Me%EulerModel(emp)%WindX)) then
                            CurrentOrigin%FirstPartic%WindX = Me%EulerModel(emp)%WindX(i,j)
                        else
                            CurrentOrigin%FirstPartic%WindX = 0.
                        end if
                endif

               if (CurrentOrigin%FirstPartic%WindY < HalfFillValueReal) then
                        if (associated(Me%EulerModel(emp)%WindY)) then
                            CurrentOrigin%FirstPartic%WindY = Me%EulerModel(emp)%WindY(i,j)
                        else
                            CurrentOrigin%FirstPartic%WindY = 0.
                        end if
                endif
                
                UWIND = CurrentOrigin%FirstPartic%WindX
                VWIND = CurrentOrigin%FirstPartic%WindY

                Wind    = abs(cmplx(UWIND, VWIND))
                
                !Adios do not support values larger than 35 m/s. The same methodology is followed in MOHID.
                Wind    = min(35.,Wind) 
                
                AtmPressure         = Me%EulerModel(emp)%AtmPressure(i, j)
                
                if (CurrentOrigin%FirstPartic%WaveHeight < HalfFillValueReal) then
                    CurrentOrigin%FirstPartic%WaveHeight = Me%EulerModel(emp)%WaveHeight2D (i, j)  
                endif
                
                WaveHeight = CurrentOrigin%FirstPartic%WaveHeight

                if (CurrentOrigin%FirstPartic%WavePeriod < HalfFillValueReal) then
                    CurrentOrigin%FirstPartic%WavePeriod = Me%EulerModel(emp)%WavePeriod2D (i, j)  
                endif
                
                WavePeriod = CurrentOrigin%FirstPartic%WavePeriod


                WaterTemperature    = Temperature3D             (i, j, k)

                !WaterTemperature = GetConcPartic (CurrentOrigin, CurrentOrigin%FirstPartic, Temperature_)
                
                WaterDensity        = Me%EulerModel(emp)%Density (i, j, k)
                !SPM                 = SPM3D                     (i, j, k)

                if (CurrentOrigin%AreaMethod == FayMethod_) then
                    CurrentOrigin%AreaTotal = -1.
                endif
                
                if (CurrentOrigin%VolTotBeached < HalfFillValueReal) then
                    CurrentOrigin%VolTotBeached     = 0.
                endif
                
                if (CurrentOrigin%VolTotOilBeached < HalfFillValueReal) then
                    CurrentOrigin%VolTotOilBeached  = 0.
                endif

                !Runs Oil Internal Processes
                call OilInternalProcesses(CurrentOrigin%ObjOil,                                   &
                                          LagrangianTime        = LagrangianTime,                 & 
                                          Wind                  = Wind,                           &
                                          AtmosphericPressure   = AtmPressure,                    &
                                          WaterTemperature      = WaterTemperature,               &
                                          WaterDensity          = WaterDensity,                   &
                                          SPM                   = SPM,                            &
                                          VWaterContent         = VWaterContent,                  &
                                          MWaterContent         = MWaterContent,                  &
                                          MDispersed            = MDispersed,                     &
                                          MDissolvedDT          = MDissolvedDT,                   &
                                          OilDensity            = OilDensity,                     &
                                          MassINI               = MassINI,                        &
                                          OilViscosity          = OilViscosity,                   &
                                          FMDispersed           = FMDispersed,                    &
                                          FMEvaporated          = FMEvaporated,                   &
                                          VolTotOilBeached      = CurrentOrigin%VolTotOilBeached, &
                                          VolTotBeached         = CurrentOrigin%VolTotBeached,    &
                                          VolumeTotalIN         = CurrentOrigin%VolumeOilTotal,   &   
                                          VolumeTotalOUT        = VolumeTotalOUT,                 &     
                                          AreaTotal             = CurrentOrigin%AreaTotal,        & 
                                          AreaTotalOUT          = AreaTotalOUT,                   & 
                                          WaveHeight            = WaveHeight,                     &
                                          WavePeriod            = WavePeriod,                     &
                                          STAT                  = STAT_CALL)                    
                if (STAT_CALL /= SUCCESS_) stop 'InternalParticOil - ModuleLagrangianGlobal - ERR07'


                Me%ExternalVar%VWaterContent = VWaterContent
                Me%ExternalVar%MWaterContent = MWaterContent
                Me%ExternalVar%MDispersed    = MDispersed
                Me%ExternalVar%OilDensity    = OilDensity
                Me%ExternalVar%OilViscosity  = OilViscosity
                Me%ExternalVar%FMEvaporated  = FMEvaporated
                Me%ExternalVar%FMDispersed   = FMDispersed
                Me%ExternalVar%AreaTotal     = AreaTotalOUT
                Me%ExternalVar%MDissolvedDT  = MDissolvedDT

                If (Me%ExternalVar%MassINI /= MassINI) then
                    !When it's the first step
                    Me%ExternalVar%MassINI = MassINI
    
                    CurrentPartic                           => CurrentOrigin%FirstPartic
                    do while (associated(CurrentPartic))

                        !Particle Mass
                        !É necessário depois acrescentar CurrentOrigin%NbrParticlesIteration para ser atribuido
                        !também na subrotina EmissionBox
                          
                        CurrentPartic%OilMass          = Me%ExternalVar%MassINI / CurrentOrigin%NbrParticlesIteration
                        CurrentPartic%OilDissolvedMass = 0.
                            
                        CurrentPartic => CurrentPartic%Next

                    enddo
                   
                End If              
                
                CurrentPartic                               => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                        CurrentPartic%FMDispersed           = Me%ExternalVar%FMDispersed
                        CurrentPartic%FMEvaporated          = Me%ExternalVar%FMEvaporated
                        CurrentPartic%VWaterContent         = Me%ExternalVar%VWaterContent
                        CurrentPartic%OilDensity            = Me%ExternalVar%OilDensity
                        CurrentPartic%OilViscosity          = Me%ExternalVar%OilViscosity

                        CurrentPartic                       => CurrentPartic%Next
                enddo
                

                ! Count Number of particles beached
                CurrentOrigin%NbrParticlesBeached           = 0
                CurrentPartic                               => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                    If (CurrentPartic%Beached) then
                        CurrentOrigin%NbrParticlesBeached   = CurrentOrigin%NbrParticlesBeached + 1                      
                    End if
                        CurrentPartic                       => CurrentPartic%Next
                enddo
                NbrParticlesNotBeached                      = CurrentOrigin%NbrParticlesIteration - &
                                                              CurrentOrigin%NbrParticlesBeached

                !Modifies OilVolume
                if (CurrentOrigin%VolumeOilTotal > 0) then
                    Factor                                  =  dble(VolumeTotalOUT) / dble(CurrentOrigin%VolumeOilTotal)
                else
                    Factor                                  = 1.
                endif
                CurrentPartic                           => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    if (.NOT. CurrentPartic%Beached ) then
                        
                        !Old Volume
                        VolOld  = CurrentPartic%Geometry%Volume
                    
                        !New Volume
                        CurrentPartic%Geometry%VolumeOil = CurrentPartic%Geometry%VolumeOil * real(Factor)
                        CurrentPartic%Geometry%Volume    = CurrentPartic%Geometry%VolumeOil / &
                                                           (1 - Me%ExternalVar%VWaterContent)
                                                           
                        if (CurrentPartic%Geometry%Volume    <=0) CurrentPartic%Geometry%Volume    = 0
                        if (CurrentPartic%Geometry%VolumeOil <=0) CurrentPartic%Geometry%VolumeOil = 0


                        !Volume Variation
                        CurrentPartic%Geometry%VolVar = CurrentPartic%Geometry%Volume - VolOld
                        
                         if (CurrentPartic%Position%Surface) then

                            !Particle Mass 
                            CurrentPartic%OilMass = CurrentPartic%Geometry%Volume*CurrentPartic%OilDensity
                            
!                            ! Atenção falta Corrects Density to include only evaporation (excludes water content, 
                             !which is at water column)
!                            CurrentPartic%OilDensity   = Me%ExternalVar%OilDensity
!                            CurrentPartic%OilViscosity = Me%ExternalVar%OilViscosity
                         else       
 
                            ! Atenção falta Corrects Density to include only water content (wxcludes evaporation, which is at surface)
!                            CurrentPartic%OilDensity   = Me%ExternalVar%OilDensity
!                            CurrentPartic%OilViscosity = Me%ExternalVar%OilViscosity

                         end if

                         If (Me%ExternalVar%MDissolvedDT > 0. .and. NbrParticlesNotBeached > 0) then
                             CurrentPartic%OilDissolvedMass = CurrentPartic%OilDissolvedMass + &
                                                              (Me%ExternalVar%MDissolvedDT / NbrParticlesNotBeached)
                         End If

                    else if (CurrentPartic%Beached) then

                        CurrentPartic%Geometry%VolVar = 0.0
         
                    end if 
         
                    CurrentPartic => CurrentPartic%Next

                enddo

                call OilGridConcentration  (CurrentOrigin, WaveHeight, WaterDensity)       

                !Calculates the OilConcentration3D
                call OilGridConcentration3D (CurrentOrigin) 
                
                call OilGridPresence (CurrentOrigin) 
                    
                !Calculate the dillution concentration
                call OilGridDissolution3D   (CurrentOrigin)
                
                !Ungets Concentration from the eulerian module
                call UngetWaterProperties (Me%EulerModel(emp)%ObjWaterProperties, Temperature3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'InternalParticOil - ModuleLagrangianGlobal - ERR10'

                if (CurrentOrigin%State%OilSedimentation) then
                    call UngetWaterProperties (Me%EulerModel(emp)%ObjWaterProperties,  SPM3D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'InternalParticOil - ModuleLagrangianGlobal - ERR11'
                end if

            endif i1

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        
    end subroutine InternalParticOil

    !--------------------------------------------------------------------------

    subroutine NewParticleMass ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%nProperties >= 1) then

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    CurrentPartic%Mass(:) = CurrentPartic%Concentration(:) *             &
                                            CurrentPartic%Geometry%Volume

                    CurrentPartic => CurrentPartic%Next
                enddo

            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine NewParticleMass

    !--------------------------------------------------------------------------
    
    subroutine ComputeOdourGridConcentration
    
    
    end subroutine ComputeOdourGridConcentration

    !--------------------------------------------------------------------------

    subroutine HNSInitialValues ()

        !Arguments-------------------------------------------------------------
    

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: HNSBehaviourClass
        integer                                     :: HNSInitialState
        integer                                     :: STAT_CALL
        
        
                
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%nProperties >= 1) then

                call GetHNSBehaviourClass(HNSID = CurrentOrigin%ObjHNS, HNSBehaviourClass = HNSBehaviourClass, STAT = STAT_CALL)

              
                call GetHNSInitialState(HNSID             = CurrentOrigin%ObjHNS,           &
                                        HNSBehaviourClass = HNSBehaviourClass,              &
                                        EmissionAtSurface = CurrentOrigin%Position%Surface, &
                                        HNSInitialState   = HNSInitialState,                &
                                        STAT              = STAT_CALL)
                          

                CurrentOrigin%HNSInitialState = HNSInitialState
                
                !Initialized Global Values
                CurrentOrigin%MEvaporated               = 0.
                CurrentOrigin%MVolatilized              = 0.
                CurrentOrigin%MDissolved                = 0.
                CurrentOrigin%MEntrained                = 0.
                CurrentOrigin%MSedimented               = 0.
                CurrentOrigin%MDeposited                = 0.
                CurrentOrigin%MSurface                  = 0.
                CurrentOrigin%HNSFractionEvaporated     = 0.
                CurrentOrigin%HNSFractionVolatilized    = 0.
                CurrentOrigin%HNSFractionDissolved      = 0.
                CurrentOrigin%HNSFractionEntrained      = 0.
                CurrentOrigin%HNSFractionSedimented     = 0.
                CurrentOrigin%HNSFractionDeposited      = 0.
                CurrentOrigin%HNSFractionAtSurface      = 0.
                CurrentOrigin%HNSFractionBeached        = 0.
                CurrentOrigin%HNSFractionDegraded       = 0.
                CurrentOrigin%MDegraded                 = 0.
                CurrentOrigin%MBeached                  = 0.
                CurrentOrigin%HNSMass                   = 0.
                CurrentOrigin%HNSTotalMass              = 0.

            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine HNSInitialValues

    !--------------------------------------------------------------------------
    

    subroutine CheckConcLimits ()

        !Arguments-------------------------------------------------------------
   

        !Local------------------------------------------------------------------
        type (T_Origin),   pointer                    :: CurrentOrigin
        type (T_Property), pointer                    :: CurrentProperty
        type (T_Partic),   pointer                    :: CurrentPartic
        integer                                       :: np

        !Begin------------------------------------------------------------------
        
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            CurrentProperty => CurrentOrigin%FirstProperty

            do np =1, CurrentOrigin%nProperties
              
                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    if (CurrentProperty%MinON) then
                        if (CurrentPartic%Concentration(np) < CurrentProperty%MinValue) then
                            CurrentPartic%KillPartic = ON
                        endif
                    endif


                    if (CurrentProperty%MaxON) then
                        if (CurrentPartic%Concentration(np) > CurrentProperty%MaxValue) then
                            CurrentPartic%KillPartic = ON
                        endif
                    endif

                    CurrentPartic => CurrentPartic%Next
                enddo

                CurrentProperty => CurrentProperty%Next

            enddo

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

    end subroutine CheckConcLimits
    

    !--------------------------------------------------------------------------
    subroutine NewParticleAge ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: nprop

        
        

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%State%Age) then

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    if (.not.(CurrentOrigin%AgeFreezeBeach.and.CurrentPartic%Beached)) then
                    
                        CurrentPartic%Age = CurrentPartic%Age + Me%DT_Partic
                        
                    endif                        
                
                    if (.not.CurrentOrigin%State%WQM) then

                        nprop = 1

                        CurrentProperty => CurrentOrigin%FirstProperty
                        
                        do while (associated(CurrentProperty))

                          if (CurrentProperty%ID==Age_) then
                          
                            if (.not.(CurrentOrigin%AgeFreezeBeach.and.CurrentPartic%Beached)) then

                               CurrentPartic%Concentration(nprop) = CurrentPartic%Concentration(nprop) + Me%DT_Partic/3600.
                            
                            endif
                            
                          endif
                         
                          nprop=nprop +1
                          
                          CurrentProperty=>CurrentProperty%Next  
                     
                        enddo
                    
                    endif
                    
                    !seconds
                    if (CurrentPartic%Age > CurrentOrigin%AgeLimit * 86400) then
                        CurrentPartic%KillPartic = ON
                    endif                        
                  
                    CurrentPartic => CurrentPartic%Next
                
                enddo
                
                nullify(CurrentPartic)

            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        
        nullify(CurrentOrigin)

    end subroutine NewParticleAge

    !--------------------------------------------------------------------------


    !--------------------------------------------------------------------------
    subroutine ProcessLitter ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        real(8),    dimension(:), pointer           :: Longitude, Latitude, Age
        integer,    dimension(:), pointer           :: Origin, ID   
        logical,    dimension(:), pointer           :: Beach, KillPartic        
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: n, nTotal
        
#ifdef _LITTER_
        integer                                     :: STAT_CALL
#endif

        !Begin-----------------------------------------------------------------

        nTotal = 0
        
        CurrentOrigin => Me%FirstOrigin
dw1:    do while (associated(CurrentOrigin))
            nTotal = nTotal + CurrentOrigin%nParticle
            CurrentOrigin => CurrentOrigin%Next
        enddo dw1

            
        allocate   (Longitude   (nTotal))
        allocate   (Latitude    (nTotal))
        allocate   (Age         (nTotal))
        allocate   (Origin      (nTotal))            
        allocate   (ID          (nTotal))                        
        allocate   (Beach       (nTotal))
        allocate   (KillPartic  (nTotal))
            
            n = 1
        
        CurrentOrigin => Me%FirstOrigin
        
dw2:    do while (associated(CurrentOrigin))

            CurrentPartic => CurrentOrigin%FirstPartic
           
            do while (associated(CurrentPartic))

                Longitude   (n) = CurrentPartic%Position%CoordX
                Latitude    (n) = CurrentPartic%Position%CoordY                
                Age         (n) = CurrentPartic%Age
                Origin      (n) = CurrentOrigin%ID
                ID          (n) = CurrentPartic%ID
                KillPartic  (n) = CurrentPartic%KillPartic            
                Beach       (n) = CurrentPartic%Beached
                
                CurrentPartic => CurrentPartic%Next
                n = n + 1
            enddo
            CurrentOrigin => CurrentOrigin%Next
        enddo dw2
            
            
#ifdef _LITTER_
            call ModifyLitter(ObjLitterID   = Me%ObjLitter,                             &
                            nParticles    = nTotal,                                   &
                              CurrentTime   = Me%Now,                                   &
                            NextCompute   = Me%NextCompute,                           &
                              Longitude     = Longitude,                                &
                              Latitude      = Latitude,                                 &
                              Age           = Age,                                      &
                              Origin        = Origin,                                   &
                              ID            = ID,                                       &
                              Beach         = Beach,                                    &
                              KillPartic    = KillPartic,                               &
                              STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ProcessLitter - ModuleLagrangianGlobal - ERR20'
#endif  
        n= 1

        CurrentOrigin => Me%FirstOrigin
dw3:    do while (associated(CurrentOrigin))

            CurrentPartic => CurrentOrigin%FirstPartic
 
            do while (associated(CurrentPartic))

                CurrentPartic%Beached    = Beach     (n)
                CurrentPartic%KillPartic = KillPartic(n)
                         
                CurrentPartic => CurrentPartic%Next
                n = n + 1                
            enddo
            CurrentOrigin => CurrentOrigin%Next
        enddo dw3            

            deallocate   (Longitude   )
            deallocate   (Latitude    )
            deallocate   (Age         )
            deallocate   (Origin      )            
            deallocate   (ID          )                        
            deallocate   (Beach       )
            deallocate   (KillPartic  )            

        nullify(CurrentPartic)
        nullify(CurrentOrigin)

    end subroutine ProcessLitter

    !--------------------------------------------------------------------------
        
    
    !--------------------------------------------------------------------------
    subroutine ProcessOutputGrid ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        real(8),    dimension(:), pointer           :: Longitude, Latitude
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: n, nTotal

#ifdef _OUTPUT_GRID_        
        integer                                     :: STAT_CALL        
#endif  

        !Begin-----------------------------------------------------------------
        
        nTotal = 0
        
        CurrentOrigin => Me%FirstOrigin
dw1:    do while (associated(CurrentOrigin))
            nTotal = nTotal + CurrentOrigin%nParticle
            CurrentOrigin => CurrentOrigin%Next
        enddo dw1
    

        allocate   (Longitude   (nTotal))
        allocate   (Latitude    (nTotal))
            
        n = 1
        
        CurrentOrigin => Me%FirstOrigin
        
dw2:    do while (associated(CurrentOrigin))

            CurrentPartic => CurrentOrigin%FirstPartic
           
            do while (associated(CurrentPartic))

                Longitude   (n) = CurrentPartic%Position%CoordX
                Latitude    (n) = CurrentPartic%Position%CoordY                
                
                CurrentPartic => CurrentPartic%Next
                n = n + 1
            enddo
            CurrentOrigin => CurrentOrigin%Next
        enddo dw2
            
#ifdef _OUTPUT_GRID_

        call ModifyOutputGrid(ObjOutputGridID   = Me%ObjOutputGrid,                     &
                                nParticles      = nTotal,                               &
                                CurrentTime     = Me%Now,                               &
                                Longitude       = Longitude,                            &
                                Latitude        = Latitude,                             &
                                STAT            = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ProcessOutputGrid - ModuleLagrangianGlobal - ERR20'
#endif  

        deallocate   (Longitude   )
        deallocate   (Latitude    )

        nullify(CurrentPartic)
        nullify(CurrentOrigin)

    end subroutine ProcessOutputGrid

    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------
    subroutine ComputeAccidentProbability ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        real                                        :: WaveHeight, CurrentIntensity, WindIntensity, DistanceToCoast
        integer                                     :: i, j, KUB, emp, nprop

        !Begin-----------------------------------------------------------------        
        

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%State%AccidentProbability) then

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                
                    if (.not. CurrentPartic%ComputeAccidentProb) then
                
                        emp = CurrentPartic%Position%ModelID
                        
                        i   = CurrentPartic%Position%i
                        j   = CurrentPartic%Position%j
                        
                        KUB = Me%EulerModel(emp)%WorkSize%KUB
                        
                        WaveHeight       = Me%EulerModel(emp)%WaveHeight2D(i, j)
                        
                        CurrentIntensity = sqrt(Me%EulerModel(emp)%Velocity_U(i,j,KUB)**2 + &
                                                Me%EulerModel(emp)%Velocity_V(i,j,KUB)**2)
                        
                        WindIntensity    = sqrt(Me%EulerModel(emp)%WindX(i,j)**2 +          &
                                                Me%EulerModel(emp)%WindY(i,j)**2)

                        DistanceToCoast  = Me%EulerModel(emp)%DistanceToCoast(i, j)

                        CurrentPartic%AccidentProbability = CurrentOrigin%AccidentProbDefault * &
                            AccidentCorrectionFactors(WaveHeight, CurrentIntensity, WindIntensity, &
                                                      DistanceToCoast, CurrentOrigin%AreaVTS)
                            
                        if (CurrentOrigin%State%ComputeRisk) then
                            do nprop=1,CurrentOrigin%nProperties 

                                   CurrentPartic%Concentration(nprop) = CurrentPartic%Concentration(nprop)* &
                                                                        CurrentPartic%AccidentProbability
                            enddo
                        endif
                        
                        CurrentPartic%ComputeAccidentProb = .true. 
                            
                    endif
                    
                    CurrentPartic => CurrentPartic%Next
                    
                enddo
                
                nullify(CurrentPartic)

            endif

            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr
        
        nullify(CurrentOrigin)

    end subroutine ComputeAccidentProbability

    !--------------------------------------------------------------------------    
    real  function AccidentCorrectionFactors(WaveHeight, CurrentIntensity, WindIntensity, DistanceToCoast, AreaVTS)


        !Arguments-------------------------------------------------------------
        
        real,    intent(in)     :: WaveHeight, CurrentIntensity, WindIntensity, DistanceToCoast
        logical, intent(in)     :: AreaVTS

        !Local-----------------------------------------------------------------       
        real, dimension(5)      :: TypeInPercentage, Limits
        real                    :: RAND, F_SeatState, F_SeaCurrents, F_Wind, F_Coast, F_VTS 
        integer                 :: i
        
        !Begin-----------------------------------------------------------------       
        
        call random_number(RAND)
        
        !Vessels accidents classified by type (MEHRA's - Factors Influence Vessel Risks in UK Waters - 1989 to 1998)

        !Ship to ship collision
        TypeInPercentage(1) = 0.21
        !Fire / Explosion
        TypeInPercentage(2) = 0.28
        !Foundering and structural failure
        TypeInPercentage(3) = 0.18
        !Grounding during navigation
        TypeInPercentage(4) = 0.29
        !Drift grounding
        TypeInPercentage(5) = 0.04
        
        do i=1,5
            Limits(i) = sum(TypeInPercentage(1:i))
        enddo
        
        
        if      (RAND < Limits(1)) then
            !Ship to ship collision        
            i=1
        else if (RAND < Limits(2) .and. RAND >= Limits(1)) then
            !Fire / Explosion        
            i=2
        else if (RAND < Limits(3) .and. RAND >= Limits(2)) then
            !Foundering and structural failure       
            i=3
        else if (RAND < Limits(4) .and. RAND >= Limits(3)) then
            !Grounding during navigation  
            i=4
        else if (RAND <=Limits(5) .and. RAND >= Limits(4)) then
            !Drift grounding       
            i=5
        endif    

        if      (i==1) then                
            F_SeatState    = 1
            F_SeaCurrents  = CurrentsCorrectionFactor(CurrentIntensity)
            F_Wind         = WindCorrectionFactor    (WindIntensity    )
            F_Coast        = 1
            if (AreaVTS) then
                F_VTS = 0.6
            else
                F_VTS = 1.4
            endif
        else if (i==2) then                
            F_SeatState    = 1
            F_SeaCurrents  = 1
            F_Wind         = 1
            F_Coast        = 1
            F_VTS          = 1  
        else if (i==3) then                
            if (TurbulentSeaState(WaveHeight))  then
                F_SeatState    = 1
            else
                F_SeatState    = 0.1
            endif
            F_SeaCurrents  = 1
            F_Wind         = 1
            F_Coast        = 1
            F_VTS          = 1              
        else if (i==4) then                
            if (TurbulentSeaState(WaveHeight))  then
                F_SeatState    = 1.4
            else
                F_SeatState    = 0.6
            endif
            F_SeaCurrents  = CurrentsCorrectionFactor      (CurrentIntensity)
            F_Wind         = WindCorrectionFactor          (WindIntensity   )
            F_Coast        = CoastProximityCorrectionFactor(DistanceToCoast )
            if (AreaVTS) then
                F_VTS = 0.8
            else
                F_VTS = 1.2
            endif
    
        else if (i==5) then                
            if (TurbulentSeaState(WaveHeight))  then
                F_SeatState    = 1.78
            else
                F_SeatState    = 0.22
            endif
            F_SeaCurrents  = CurrentsCorrectionFactor      (CurrentIntensity)
            F_Wind         = WindCorrectionFactor          (WindIntensity   )
            F_Coast        = CoastProximityCorrectionFactor(DistanceToCoast )
            F_VTS          = 1  
        endif
        
        AccidentCorrectionFactors = F_SeatState * F_SeaCurrents * F_Wind * F_Coast * F_VTS
    
    end function AccidentCorrectionFactors
    
   !--------------------------------------------------------------------------
   
   !--------------------------------------------------------------------------    
    real  function WindCorrectionFactor(WindIntensity)


        !Arguments-------------------------------------------------------------
        !                          m/s
        real,   intent(in)      :: WindIntensity

        !Local-----------------------------------------------------------------       
        real                    :: WindKmh
        !Begin-----------------------------------------------------------------    

        WindKmh = 3.6 * WindIntensity
         
        ! km/h
        if      (WindKmh >= 90 ) then
        
            WindCorrectionFactor = 2.
            
        else if (WindKmh < 90 .and. WindKmh >= 50) then
        
            WindCorrectionFactor = 1.6
            
        else if (WindKmh < 50 .and. WindKmh >= 30) then       
        
            WindCorrectionFactor = 1.2
            
        else if (WindKmh < 30                                ) then       
        
            WindCorrectionFactor = 0.8
        
        endif
        
    end function WindCorrectionFactor
    !--------------------------------------------------------------------------
   
   
    !--------------------------------------------------------------------------    
    real  function CurrentsCorrectionFactor(CurrentIntensity)


        !Arguments-------------------------------------------------------------
        !                          m/s
        real,   intent(in)      :: CurrentIntensity

        !Local-----------------------------------------------------------------       
        !                          Knots
        real                    :: CurrentsKnots        
        !Begin-----------------------------------------------------------------    

         
        CurrentsKnots = CurrentIntensity / 0.514
         
        ! knots
        if      (CurrentsKnots >= 3 ) then
        
            CurrentsCorrectionFactor = 2.
            
        else if (CurrentsKnots < 3 .and. CurrentsKnots >= 2) then
        
            CurrentsCorrectionFactor = 1.6
            
        else if (CurrentsKnots < 2 .and. CurrentsKnots >= 1) then
        
            CurrentsCorrectionFactor = 1.2
            
        else if (CurrentsKnots < 1 .and. CurrentsKnots >= 0.7) then
        
            CurrentsCorrectionFactor = 0.8      

        else if (CurrentsKnots < 0.7                         ) then
        
            CurrentsCorrectionFactor = 0.4
            
        endif
        
        
    end function CurrentsCorrectionFactor
    
    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------    
    real  function CoastProximityCorrectionFactor(DistanceToCoast)


        !Arguments-------------------------------------------------------------
        !                          m
        real,   intent(in)      :: DistanceToCoast

        !Local-----------------------------------------------------------------       
        !                          nautical miles
        real                    :: DistanceMiles        
        !Begin-----------------------------------------------------------------    

         
        DistanceMiles = DistanceToCoast / 1852.
         
        ! knots
        if      (DistanceMiles >= 8 ) then
        
            CoastProximityCorrectionFactor = 0.8
            
        else if (DistanceMiles < 8 .and. DistanceMiles >= 6) then
        
            CoastProximityCorrectionFactor = 1.
            
        else if (DistanceMiles < 6 ) then
        
            CoastProximityCorrectionFactor = 2.
            
        endif
        
        
    end function CoastProximityCorrectionFactor
    
    !--------------------------------------------------------------------------   
    !--------------------------------------------------------------------------    
    logical  function TurbulentSeaState(WaveHeight)


        !Arguments-------------------------------------------------------------
        !                          m
        real,   intent(in)      :: WaveHeight

        !Local-----------------------------------------------------------------       
       
        !Begin-----------------------------------------------------------------    

        !http://en.wikipedia.org/wiki/Sea_state
         
        if      (WaveHeight > 2.5 ) then
            TurbulentSeaState = .true.
        else
            TurbulentSeaState = .false.        
        endif
        
        
    end function TurbulentSeaState
    
    !--------------------------------------------------------------------------
    
    subroutine MonitorParticleLag ()



        !Local-----------------------------------------------------------------
        type (T_Origin),  pointer                       :: CurrentOrigin
        type (T_Partic),  pointer                       :: CurrentPartic
        type (T_PointF),  pointer                       :: Point        
        type (T_Polygon), pointer                       :: AuxPoly        
        integer                                         :: nP, nO
        integer                                         :: NumberOfOrigins
        integer                                         :: NumberOfPoly        
        integer                                         :: STAT_CALL
        real, dimension (:), pointer                    :: DataLine, TotalEmitted
        
        !Begin-----------------------------------------------------------------
        
        if (Me%Now >= Me%MonitorLag%NextOutPut) then

            NumberOfOrigins = Me%nOrigins
            NumberOfPoly    = Me%MonitorLag%NumberOfPoly
        
            allocate(DataLine       (1:2*NumberOfOrigins))
            allocate(TotalEmitted   (1:  NumberOfOrigins))            
            allocate(Point)
        
            Me%MonitorLag%NumTracersOrigin(1:NumberOfPoly,1:NumberOfOrigins) = 0
        
            nO = 0
        
            CurrentOrigin => Me%FirstOrigin
        
    d1:     do while (associated(CurrentOrigin))
    
                nO = nO + 1
                TotalEmitted(nO) = CurrentOrigin%nParticleEmit
            
                CurrentPartic => CurrentOrigin%FirstPartic
            
    d2:         do while (associated(CurrentPartic))
    
                    Point%X = CurrentPartic%Position%CoordX
                    Point%Y = CurrentPartic%Position%CoordY
                
    dP:             do nP = 1, NumberOfPoly    
    
                        AuxPoly => Me%MonitorLag%Poly(nP)
    
                        if (IsVisible(AuxPoly, Point)) then
                        
                            Me%MonitorLag%NumTracersOrigin(nP,nO) = &
                                Me%MonitorLag%NumTracersOrigin(nP,nO) + 1
                        
                        endif    
    
                    enddo dP

                    CurrentPartic => CurrentPartic%Next
                enddo d2

                CurrentOrigin => CurrentOrigin%Next
            enddo d1
        
    dP1:    do nP = 1, NumberOfPoly
            
                DataLine(1                 :   NumberOfOrigins) = Me%MonitorLag%NumTracersOrigin(nP,1:NumberOfOrigins)
                DataLine(NumberOfOrigins+1 : 2*NumberOfOrigins) = TotalEmitted                     (1:NumberOfOrigins)
            
                call WriteTimeSerieLine(TimeSerieID         = Me%MonitorLag%ObjTimeSerie(nP),&
                                        ExternalCurrentTime = Me%Now,                       &
                                        DataLine            = DataLine,                     &
                                        STAT                = STAT_CALL)            

                if (STAT_CALL /= SUCCESS_) then
                    stop 'MonitorParticleLag - ModuleLagrangianGlobal - ERR10'
                endif           

            enddo dP1

            deallocate (DataLine    )
            deallocate (TotalEmitted)
            deallocate (Point       )
            nullify    (AuxPoly     ) 
            
            Me%MonitorLag%NextOutPut = Me%MonitorLag%NextOutPut + Me%MonitorLag%DT

        endif
    end subroutine MonitorParticleLag
    
    !--------------------------------------------------------------------------
    
    !--------------------------------------------------------------------------    


    subroutine MonitorParticle ()


        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: NumberOfOrigins
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, Box, iO
        integer                                     :: STAT_CALL
        real, dimension(:), pointer                 :: AuxReal
        integer                                     :: nProp, em 
        real(8)                                     :: AuxReal2
        real(8), dimension(:), pointer              :: SumContaminatedTracerConc
        real(8), dimension(:,:), pointer            :: SumNegativeLogMassByOrigin
        real(8), dimension(:), pointer              :: SumNegativeLogMass

        !Begin--------------------------------------------------------------------------

        NumberOfOrigins = Me%nOrigins

d1:     do em =1, Me%EulerModelNumber

            !Shorten
            ILB    = Me%EulerModel(em)%WorkSize%ILB
            IUB    = Me%EulerModel(em)%WorkSize%IUB
            JLB    = Me%EulerModel(em)%WorkSize%JLB
            JUB    = Me%EulerModel(em)%WorkSize%JUB
            KLB    = Me%EulerModel(em)%WorkSize%KLB
            KUB    = Me%EulerModel(em)%WorkSize%KUB
        
            !Get the boxes
            call GetBoxes(Me%EulerModel(em)%ObjMonBox, Me%EulerModel(em)%Monitor%Boxes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'MonitorParticle - ModuleLagrangianGlobal - ERR01'
           
            call GetNumberOfBoxes(Me%EulerModel(em)%ObjMonBox, NumberOfBoxes3D = Me%EulerModel(em)%Monitor%NumberOfBoxes,       & 
                                  STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructMonitoring - ModuleLagrangianGlobal - ERR01'

            Me%EulerModel(em)%Monitor%SurfaceBoxVolume = 0.
            do j = JLB, JUB
            do i = ILB, IUB
                Box = Me%EulerModel(em)%Monitor%Boxes(i, j, KUB)
                if (Box > 0 .and. Me%EulerModel(em)%OpenPoints3D(i, j, KUB) == OpenPoint) then

                Me%EulerModel(em)%Monitor%SurfaceBoxVolume (Box) = Me%EulerModel(em)%Monitor%SurfaceBoxVolume (Box)              &
                                                    + (min(Me%EulerModel(em)%DWZ(i, j, KUB), Me%MonitorContaminationDepth)       &
                                                    * (Me%EulerModel(em)%VolumeZ   (i, j, KUB) /                                 &
                                                    Me%EulerModel(em)%DWZ(i, j, KUB))) 
                endif
            enddo
            enddo
            !Calculates the volume of each monitoring boxes
            Me%EulerModel(em)%Monitor%InstBoxVolume = 0.
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                Box = Me%EulerModel(em)%Monitor%Boxes(i, j, k)
                if (Box > 0 .and. Me%EulerModel(em)%OpenPoints3D(i, j, k) == OpenPoint) then
                    Me%EulerModel(em)%Monitor%InstBoxVolume (Box) = Me%EulerModel(em)%Monitor%InstBoxVolume (Box) + &
                                                                     Me%EulerModel(em)%VolumeZ   (i, j, k)
                endif
            enddo
            enddo
            enddo

            !Integrates the volume of each monitoring box
            do Box = 1, Me%EulerModel(em)%Monitor%NumberOfBoxes
                Me%EulerModel(em)%Monitor%IntgBoxVolume (Box) = Me%EulerModel(em)%Monitor%IntgBoxVolume (Box) + &
                                                                Me%EulerModel(em)%Monitor%InstBoxVolume (Box)
            enddo

        enddo d1


d2:     do em =1, Me%EulerModelNumber

            !Calculates the volume contributed from a given origin to the volume of a 
            !monitoring cell
            Me%EulerModel(em)%Monitor%InstVolumeByOrigin = 0.
            CurrentOrigin => Me%FirstOrigin
            do while (associated(CurrentOrigin))

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i  = CurrentPartic%Position%I
                    j  = CurrentPartic%Position%J
                    k  = CurrentPartic%Position%K
                    if (em /= CurrentPartic%Position%ModelID) then
                        CurrentPartic => CurrentPartic%Next
                        cycle
                    endif
               
                    !Number of box in which Particle is located
                    Box = Me%EulerModel(em)%Monitor%Boxes(i, j, k)

                    if (Box > 0 .and. Me%EulerModel(em)%OpenPoints3D(i, j, k) == OpenPoint) then
                        Me%EulerModel(em)%Monitor%InstVolumeByOrigin (Box, CurrentOrigin%ID) =     &
                            Me%EulerModel(em)%Monitor%InstVolumeByOrigin (Box, CurrentOrigin%ID) + &
                            dble(CurrentPartic%Geometry%Volume)
                    endif

                    CurrentPartic => CurrentPartic%Next
                enddo

                CurrentOrigin => CurrentOrigin%Next

            enddo

        enddo d2

MMass:  If (Me%State%MonitorPropMass) then

d3:         do em =1, Me%EulerModelNumber

                ! Calculates the mass contributed from a given origin to the volume of a 
                ! monitoring group of cells

                Me%EulerModel(em)%Monitor%InstMassByOrigin = 0.
                Me%EulerModel(em)%Monitor%InstLogMassByOrigin               = 0.
                Me%EulerModel(em)%Monitor%NumberOfTracersFromOrigin         = 0
                Me%EulerModel(em)%Monitor%ContaminationProbability    (:)   = 0.
                Me%EulerModel(em)%Monitor%AverageBoxContaminatedConc  (:)   = 0.
                Me%EulerModel(em)%Monitor%NbrBoxContaminatedTracers   (:)   = 0
                Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers   (:)   = 0.
                
                allocate (SumContaminatedTracerConc (Me%EulerModel(em)%Monitor%NumberOfBoxes))            
                !ROD to do : if geometric
                allocate (SumNegativeLogMassByOrigin (Me%EulerModel(em)%Monitor%NumberOfBoxes, NumberOfOrigins))            
                allocate (SumNegativeLogMass (Me%EulerModel(em)%Monitor%NumberOfBoxes))

                SumContaminatedTracerConc            = 0.            
                SumNegativeLogMassByOrigin           = 0.
                SumNegativeLogMass                   = 0.
                CurrentOrigin => Me%FirstOrigin
                do while (associated(CurrentOrigin))

                    nProp = 1
                    CurrentProperty => CurrentOrigin%FirstProperty
                    do while (associated(CurrentProperty))

                        if (CurrentProperty%Name == Me%MonitorProperty) then
                            CurrentPartic => CurrentOrigin%FirstPartic
                            do while (associated(CurrentPartic))
                                i  = CurrentPartic%Position%I
                                j  = CurrentPartic%Position%J
                                k  = CurrentPartic%Position%K

                                if (em /= CurrentPartic%Position%ModelID) then
                                    CurrentPartic => CurrentPartic%Next
                                    cycle
                                endif
           
                                !Number of box in which Particle is located
                                Box = Me%EulerModel(em)%Monitor%Boxes(i, j, k)

                                if (Box > 0 .and. Me%EulerModel(em)%OpenPoints3D(i, j, k) == OpenPoint) then
                                    Me%EulerModel(em)%Monitor%InstMassByOrigin (Box, CurrentOrigin%ID) =     &
                                    Me%EulerModel(em)%Monitor%InstMassByOrigin (Box, CurrentOrigin%ID) + &
                                    (CurrentPartic%Concentration(nProp) * dble(CurrentPartic%Geometry%Volume)) 
                                    !ROD to do : if geometric
                                    AuxReal2 = CurrentPartic%Concentration(nProp) * dble(CurrentPartic%Geometry%Volume)
                                    
                                    if (AuxReal2 .GT. 1.) then
                                        Me%EulerModel(em)%Monitor%InstLogMassByOrigin (Box, CurrentOrigin%ID) =     &
                                        Me%EulerModel(em)%Monitor%InstLogMassByOrigin (Box, CurrentOrigin%ID) + log10(AuxReal2)
                                    elseif (AuxReal2 .GT. 0. .and. AuxReal2 .LT.1) then
                                        SumNegativeLogMass(CurrentOrigin%ID) =                       &
                                        SumNegativeLogMassByOrigin(Box, CurrentOrigin%ID) + dabs(AuxReal2) 
                                    end if
                                
                                
                                    Me%EulerModel(em)%Monitor%NumberOfTracersFromOrigin(Box, CurrentOrigin%ID) =           &
                                    Me%EulerModel(em)%Monitor%NumberOfTracersFromOrigin(Box, CurrentOrigin%ID) + 1 
                                    
                            
                                    If ( CurrentPartic%Concentration(nProp) .GE. Me%MonitorBox_TracerMinConc) then
                                        If (Me%MonitorMassFractionType .EQ. Arithmetic) then
                                                SumContaminatedTracerConc(Box)=                                 &
                                                SumContaminatedTracerConc(Box) + CurrentPartic%Concentration(nProp)
                                            else
                                                SumContaminatedTracerConc(Box) =                                &
                                                SumContaminatedTracerConc(Box) +                                &
                                                log10(CurrentPartic%Concentration(nProp))                                           
                                        end if
                                        
                                        Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers(Box) =                             &
                                        Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers(Box) +                             &
                                        dble(CurrentPartic%Geometry%Volume)                              
                                        
                                        Me%EulerModel(em)%Monitor%NbrBoxContaminatedTracers(Box) =                             &
                                        Me%EulerModel(em)%Monitor%NbrBoxContaminatedTracers(Box) + 1
                                    End If
                                endif

                                CurrentPartic => CurrentPartic%Next
                            enddo

                        endif

                        nProp = nProp + 1
                        CurrentProperty => CurrentProperty%Next
                    enddo

                    CurrentOrigin => CurrentOrigin%Next
                enddo

                !Calculates Box Mass
                Me%EulerModel(em)%Monitor%NumberOfTracers             (:)   = 0
                Me%EulerModel(em)%Monitor%InstBoxMass                 (:)   = 0.
                Me%EulerModel(em)%Monitor%InstBoxLogMass              (:)   = 0.
                Me%EulerModel(em)%Monitor%InstBoxConc                 (:)   = 0.
                Me%EulerModel(em)%Monitor%InstBoxMassFractionByOrigin (:,:) = 0.
                SumNegativeLogMass                                    (:)   = 0.
                do Box = 1, Me%EulerModel(em)%Monitor%NumberOfBoxes
                    CurrentOrigin => Me%FirstOrigin
                    do while (associated(CurrentOrigin))

                        if (em /= CurrentOrigin%Position%ModelID) then
                            CurrentOrigin => CurrentOrigin%Next
                            cycle
                        endif

                        Me%EulerModel(em)%Monitor%InstBoxLogMass(Box) =       &
                        Me%EulerModel(em)%Monitor%InstBoxLogMass(Box) +   &
                        Me%EulerModel(em)%Monitor%InstLogMassByOrigin (Box, CurrentOrigin%ID)
                        Me%EulerModel(em)%Monitor%InstBoxMass(Box) =       &
                        Me%EulerModel(em)%Monitor%InstBoxMass(Box) +   &
                        Me%EulerModel(em)%Monitor%InstMassByOrigin (Box, CurrentOrigin%ID)

                        Me%EulerModel(em)%Monitor%NumberOfTracers(Box) =       &
                        Me%EulerModel(em)%Monitor%NumberOfTracers(Box) +       &
                        Me%EulerModel(em)%Monitor%NumberOfTracersFromOrigin (Box, CurrentOrigin%ID)

                        SumNegativeLogMass(Box) =               &
                        SumNegativeLogMass(Box) +               &
                        SumNegativeLogMassByOrigin(Box, CurrentOrigin%ID)
                        CurrentOrigin => CurrentOrigin%Next
                    enddo
                    ! Computes the Fraction of mass in a box from each origin
                    CurrentOrigin => Me%FirstOrigin
                    do while (associated(CurrentOrigin))

                        if (Me%MonitorMassFractionType .EQ. Arithmetic .and. Me%EulerModel(em)%Monitor%InstBoxMass(Box) .GT. 0) then
                            Me%EulerModel(em)%Monitor%InstBoxMassFractionByOrigin (Box, CurrentOrigin%ID) =     &
                            Me%EulerModel(em)%Monitor%InstMassByOrigin (Box, CurrentOrigin%ID) /                &
                            Me%EulerModel(em)%Monitor%InstBoxMass(Box)                 
                        elseif (Me%MonitorMassFractionType .EQ. Geometric .and.                                 &
                        Me%EulerModel(em)%Monitor%InstBoxLogMass(Box) .GT. 0) then
                            Me%EulerModel(em)%Monitor%InstBoxMassFractionByOrigin (Box, CurrentOrigin%ID) =     &
                            Me%EulerModel(em)%Monitor%InstLogMassByOrigin (Box, CurrentOrigin%ID) /             &
                            Me%EulerModel(em)%Monitor%InstBoxLogMass(Box)                   
                        end if
     
                       CurrentOrigin => CurrentOrigin%Next
                    enddo

                    if (Me%MonitorMassFractionType .EQ. Arithmetic) then
                        Me%EulerModel(em)%Monitor%InstBoxConc (Box) =                                           &
                        Me%EulerModel(em)%Monitor%InstBoxMass(Box) / Me%EulerModel(em)%Monitor%InstBoxVolume (Box)

                        if (Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers(Box) > 0.) then
                            Me%EulerModel(em)%Monitor%AverageBoxContaminatedConc (Box) =                            &
                            SumContaminatedTracerConc(Box) / Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers(Box)
                        else
                            Me%EulerModel(em)%Monitor%AverageBoxContaminatedConc (Box) = 0.
                        endif
                        
                    elseif (Me%MonitorMassFractionType .EQ. Geometric) then
                        if (Me%EulerModel(em)%Monitor%NumberOfTracers(Box) .GT. 0) then
                            Me%EulerModel(em)%Monitor%InstBoxConc (Box) =                                      &
                            10**((Me%EulerModel(em)%Monitor%InstBoxLogMass(Box) - SumNegativeLogMass(Box)) /   &
                            dble(Me%EulerModel(em)%Monitor%NumberOfTracers(Box)))                              &
                            * dble(Me%EulerModel(em)%Monitor%NumberOfTracers(Box)) /                           &
                            Me%EulerModel(em)%Monitor%InstBoxVolume (Box)
                        end if
                        if (Me%EulerModel(em)%Monitor%NbrBoxContaminatedTracers(Box) .GT. 0) then
                            Me%EulerModel(em)%Monitor%AverageBoxContaminatedConc (Box) =                       &
                            10**(SumContaminatedTracerConc(Box)/dble(Me%EulerModel(em)%Monitor%NbrBoxContaminatedTracers(Box)))     
                        end if                                             
                    end if

                    If (Me%MonitorContaminationDepth .GT. 0.) then
                        Me%EulerModel(em)%Monitor%ContaminationProbability(Box) =                              &
                        Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers(Box) /                             &
                                                                   Me%EulerModel(em)%Monitor%SurfaceBoxVolume (Box)
                    Else
                        Me%EulerModel(em)%Monitor%ContaminationProbability(Box) =                              &
                        Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers(Box) /                             &
                                                                   Me%EulerModel(em)%Monitor%InstBoxVolume (Box)                    
                    End If
                enddo

            enddo d3

        End If MMass

d4:     do em =1, Me%EulerModelNumber

            !Integrates the values of the volume contributing from a given origin to the volume
            do Box = 1, Me%EulerModel(em)%Monitor%NumberOfBoxes
                CurrentOrigin => Me%FirstOrigin
                do while (associated(CurrentOrigin))

!                    if (em /= CurrentOrigin%Position%ModelID) then
!                        CurrentOrigin => CurrentOrigin%Next
!                        cycle
!                    endif

                    Me%EulerModel(em)%Monitor%IntgVolumeByOrigin (Box, CurrentOrigin%ID) =       &
                        Me%EulerModel(em)%Monitor%IntgVolumeByOrigin (Box, CurrentOrigin%ID) +   &
                        Me%EulerModel(em)%Monitor%InstVolumeByOrigin (Box, CurrentOrigin%ID)

                    CurrentOrigin => CurrentOrigin%Next
                enddo
            enddo

        enddo d4


        if (Me%State%MonitorPropMass) then
            allocate (AuxReal (2 + 4*(NumberOfOrigins + 1)))
        else
            allocate (AuxReal (2*(NumberOfOrigins + 1)))
        end if


d5:     do em =1, Me%EulerModelNumber
            
            !Writes the Time Serie
d23:        do Box = 1, Me%EulerModel(em)%Monitor%NumberOfBoxes

                !Instant Volume Values
                AuxReal(1) = Me%EulerModel(em)%Monitor%InstBoxVolume (Box)
                CurrentOrigin => Me%FirstOrigin
                iO = 1
                do while (associated(CurrentOrigin))
                    AuxReal(iO+1) = Me%EulerModel(em)%Monitor%InstVolumeByOrigin (Box, CurrentOrigin%ID)

                    iO = iO + 1
                    CurrentOrigin => CurrentOrigin%Next
                enddo


                !Integrated Values 
                AuxReal ((NumberOfOrigins + 1) + 1) = Me%EulerModel(em)%Monitor%IntgBoxVolume (Box)
                CurrentOrigin => Me%FirstOrigin
                iO = 1
                do while (associated(CurrentOrigin))
                    AuxReal ((NumberOfOrigins + 1) + 1 + iO) = Me%EulerModel(em)%Monitor%IntgVolumeByOrigin (Box, CurrentOrigin%ID)
                    iO = iO + 1
                    CurrentOrigin => CurrentOrigin%Next
                enddo


                If (Me%State%MonitorPropMass) then

                !Instant Mass Values
                AuxReal(2 * (NumberOfOrigins + 1) + 1) = Me%EulerModel(em)%Monitor%InstBoxMass (Box)
                CurrentOrigin => Me%FirstOrigin
                iO = 1
                do while (associated(CurrentOrigin))
                    AuxReal(2 * (NumberOfOrigins + 1) + 1 + iO) = Me%EulerModel(em)%Monitor%InstMassByOrigin (Box, CurrentOrigin%ID)

                    iO = iO + 1
                    CurrentOrigin => CurrentOrigin%Next
                enddo

                    !Instant Geometric Concentration Values and Relative Mass values
                    AuxReal(3 * (NumberOfOrigins + 1) + 1) = Me%EulerModel(em)%Monitor%InstBoxConc (Box)
                    AuxReal(3 * (NumberOfOrigins + 1) + 2) = Me%EulerModel(em)%Monitor%AverageBoxContaminatedConc (Box)
                    AuxReal(3 * (NumberOfOrigins + 1) + 3) = Me%EulerModel(em)%Monitor%ContaminationProbability(Box)
                    CurrentOrigin => Me%FirstOrigin
                    iO = 1
                    do while (associated(CurrentOrigin))
                        AuxReal(3 * (NumberOfOrigins + 1) + 3 + iO) =                               &
                        Me%EulerModel(em)%Monitor%InstBoxMassFractionByOrigin (Box, CurrentOrigin%ID)

                        iO = iO + 1
                        CurrentOrigin => CurrentOrigin%Next
                    enddo

                End If

                call WriteTimeSerieLine (Me%EulerModel(em)%Monitor%ObjTimeSerie(Box),   &
                                         ExternalCurrentTime = Me%Now,                  &
                                         DataLine            = AuxReal,                 &
                                         STAT                = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'MonitorParticle - ModuleLagrangianGlobal - ERR02'
            enddo d23


            !Unget The Boxes
            call UngetBoxDif(Me%EulerModel(em)%ObjMonBox, Me%EulerModel(em)%Monitor%Boxes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'MonitorParticle - ModuleLagrangianGlobal - ERR03'

        enddo d5
        
        deallocate (AuxReal)
        
        If (Me%State%MonitorPropMass) then
            deallocate (SumContaminatedTracerConc)            
            deallocate (SumNegativeLogMassByOrigin)             
            deallocate (SumNegativeLogMass)
        end if

    end subroutine MonitorParticle
    
    !--------------------------------------------------------------------------

    subroutine MonitorEulerian
        
        !Local-----------------------------------------------------------------
        !real, dimension(:, :, :, :), pointer        :: GridMaxTracer
        real, dimension(:, :, :), pointer           :: AuxGrid3D 
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: iProp, STAT_CALL, i, j, k, em
        type (T_Property), pointer                  :: CurrentProperty

        !Begin-----------------------------------------------------------------

        !Fills Grid concentration
        if (Me%Now > Me%ExternalVar%LastConcCompute) call FillGridConcentration 

!d1:     do em =1, Me%EulerModelNumber

        ! In this version only writes and computes the concentration for the higher priority eulerian model

            em = Me%EulerModelNumber

            ILB     = Me%EulerModel(em)%Size%ILB   
            IUB     = Me%EulerModel(em)%Size%IUB   
            JLB     = Me%EulerModel(em)%Size%JLB   
            JUB     = Me%EulerModel(em)%Size%JUB   
            KLB     = Me%EulerModel(em)%Size%KLB   
            KUB     = Me%EulerModel(em)%Size%KUB   


            !Allocates auxiliar variable
            allocate (AuxGrid3D (ILB:IUB, JLB:JUB, KLB:KUB))

            iProp = 1
            CurrentProperty => Me%OriginDefault%FirstProperty
            do while (associated(CurrentProperty))

                AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridConc(:, :, :,iProp, 1)

                do K = KLB, KUB
                do J = JLB, JUB
                do I = ILB, IUB
                    if(Me%EulerModel(em)%Waterpoints3D(i,j,k) == WaterPoint) then
                        Me%EulerModel(em)%EulerianMonitor%Mass(i,j,k) = AuxGrid3D(i, j, k) * &
                                                         Me%EulerModel(em)%VolumeZ(i, j, k)
                    end if
                end do
                end do
                end do

                call BoxDif(Me%EulerModel(em)%ObjEulMonBox,                             &
                            Me%EulerModel(em)%EulerianMonitor%Mass,                     &
                            "Lagrangian_"//trim(CurrentProperty%Name),                  &
                            Me%EulerModel(em)%Waterpoints3D,                            &
                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'MonitorEulerian - ModuleLagrangianGlobal - ERR01'

                CurrentProperty => CurrentProperty%Next
                iProp = iProp + 1
            enddo

            !Deallocates auxiliar variable
            deallocate (AuxGrid3D)

            !if (Me%OutPut%ConcMaxTracer) deallocate (GridMaxTracer)

        !enddo d1



    end subroutine MonitorEulerian

    !--------------------------------------------------------------------------

    subroutine ModifyParticStatistic ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        real, dimension(:, :, :), pointer           :: AuxGrid3D 
        real, dimension(:, :   ), pointer           :: AuxGrid2D
        real                                        :: Aux
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: iProp, STAT_CALL, em, p, ig
        integer                                     :: ln, LayersNumber, MethodStatistic
        integer                                     :: Value3DStatLayers, Depth, Layer, LayerDefinition
        logical                                     :: PropNumber, PercentContamin


        !Begin--------------------------------------------------------------------------


        !Fills Grid concentration
        if (Me%Now > Me%ExternalVar%LastConcCompute) call FillGridConcentration 

d1:     do em =1, Me%EulerModelNumber

               
d2:     do ig = 1, Me%NGroups

            !Shorten
            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB
            KLB    = Me%EulerModel(em)%Size%KLB
            KUB    = Me%EulerModel(em)%Size%KUB

            !Allocates auxiliar variable
            allocate (AuxGrid3D (ILB:IUB, JLB:JUB, KLB:KUB))

dp:         do p=1, Me%Statistic%PropNumber

                if (OilThickness_ == Me%Statistic%OptionsStat(p)%ID%IDNumber) then

                    allocate (AuxGrid2D (ILB:IUB, JLB:JUB))
                    
                    Aux = 1e6 * (1.0 - Me%ExternalVar%VWaterContent)

                    AuxGrid2D(:,:) = Me%EulerModel(em)%OilSpreading(ig)%GridThickness (:,:) 
                    
                    AuxGrid2D = Aux * AuxGrid2D

                    call ModifyStatistic (Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig), &
                                          Value2D       = AuxGrid2D,                            &
                                          WaterPoints2D = Me%EulerModel(em)%WaterPoints2D,      &
                                          Now           = Me%Now,                               &        
                                          STAT          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR90'
                    
                    deallocate(AuxGrid2D) 
                            
                    cycle
                    
                endif 
                                                
                                
                                        
            
                iProp = Me%Statistic%OptionsStat(p)%PropOrder

                PropNumber      = .false.     
                PercentContamin = .false.           
                
                if (Me%Statistic%OptionsStat(p)%ID%IDNumber == IndividualsPerCell_)  then
                    PropNumber      = .true.
                endif

                if (Me%Statistic%OptionsStat(p)%ID%IDNumber == CellPercentContamin_) then
                    PercentContamin = .true.
                endif

                if (PropNumber .or. PercentContamin) then
                
                    if (PropNumber)      then
                        AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridTracerNumber(:, :, :, ig)
                    endif

                    if (PercentContamin) then
                        AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%PercentContamin (:, :, :, ig)
                    endif                        
                    
                else
                    AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridConc(:, :, :, iProp, ig)
                endif
                

                call GetStatisticMethod (Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig), &
                                         MethodStatistic, STAT = STAT_CALL)
                                                
                if (STAT_CALL /= SUCCESS_)                                               &
                    stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR10'

                call GetStatisticParameters (Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),&
                                             Value3DStatLayers = Value3DStatLayers,      &
                                             Depth             = Depth,                  &
                                             Layer             = Layer,                  &
                                             STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                               &
                    stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR20'



                if (MethodStatistic == Value3DStatLayers) then

                    call GetStatisticLayersNumber(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),&
                                                  LayersNumber, STAT = STAT_CALL)
                                                    
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR20'

                    do ln=1, LayersNumber

                        call GetStatisticLayerDef(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig), &
                                                  ln, LayerDefinition, STAT = STAT_CALL)
                                                    
                        if (STAT_CALL /= SUCCESS_)                                      &
                            stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR30'


                        !Statistic of properties values along the bottom 
                        if (LayerDefinition == Layer) then 


                            call AddStatisticLayers (StatisticID    = Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),        &
                                                     Value3D        = AuxGrid3D,        &
                                                     WaterPoints3D  = Me%EulerModel(em)%Waterpoints3D, &
                                                     DZ3D           = Me%EulerModel(em)%DWZ,           &
                                                     LayerNumber    = ln,               &
                                                     Now            = Me%Now,           &
                                                     STAT= STAT_CALL) 

                            if (STAT_CALL /= SUCCESS_)                                &
                                stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR40'


                        else if (LayerDefinition == Depth) then 

                            stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR50'

                        endif

                   
                    enddo

                endif
                
                call ModifyStatistic    (Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig), &
                                         Value3D       = AuxGrid3D,                     &
                                         WaterPoints3D = Me%EulerModel(em)%Waterpoints3D,&
                                         Now           = Me%Now,                        &
                                         STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_)                                              &
                    stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR60'

                if (Me%OutPut%ConcMaxTracer .and. .not. PropNumber .and. .not. PercentContamin) then

                    AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridMaxTracer(:, :, :, iProp, ig)

                    call ModifyStatistic (Me%EulerModel(em)%PropStatistic(p)%Statistic2_ID(ig), &
                                          Value3D       = AuxGrid3D,                    &
                                          WaterPoints3D = Me%EulerModel(em)%Waterpoints3D,      &
                                          Now           = Me%Now,                       &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR70'
                endif 
                
                if (Me%OutPut%MassTracer .and. .not. PropNumber .and. .not. PercentContamin) then

                    AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridMass(:, :, :, iProp, ig)

                    call ModifyStatistic (Me%EulerModel(em)%PropStatistic(p)%Statistic3_ID(ig), &
                                          Value3D       = AuxGrid3D,                    &
                                          WaterPoints3D = Me%EulerModel(em)%Waterpoints3D,      &
                                          Now           = Me%Now,                       &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_)                                          &
                        stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR80'
                        
                    if (Me%OutPut%ConcMaxTracer) then

                        AuxGrid3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridMaxMass(:, :, :, iProp, ig)

                        call ModifyStatistic (Me%EulerModel(em)%PropStatistic(p)%Statistic4_ID(ig), &
                                              Value3D       = AuxGrid3D,                            &
                                              WaterPoints3D = Me%EulerModel(em)%Waterpoints3D,      &
                                              Now           = Me%Now,                               &
                                              STAT          = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_)                                                  &
                            stop 'ModifyParticStatistic - ModuleLagrangianGlobal - ERR90'
                    endif                         
                endif                 

                if (Me%Statistic%OptionsStat(p)%Lag .and. .not. PropNumber .and. .not. PercentContamin) then

                    call ComputeStatisticsLag(Me%Statistic%OptionsStat(p)%ID%IDNumber, p, ig, iProp)

                endif


            enddo dp
            
    
            !Deallocates auxiliar variable
            deallocate (AuxGrid3D   )
            !if (Me%OutPut%ConcMaxTracer) deallocate (GridMaxTracer)

        enddo d2
        enddo d1


    end subroutine ModifyParticStatistic
    !--------------------------------------------------------------------------

    subroutine ComputeStatisticsLag(PropertyID, p, ig, iProp) 
        !Arguments-------------------------------------------------------------
        integer                                     :: PropertyID, p, ig, iProp

        !Local-----------------------------------------------------------------
        type (T_Origin  ), pointer                  :: CurrentOrigin
        type (T_Property), pointer                  :: CurrentProperty
        type (T_Partic  ), pointer                  :: CurrentPartic
        real, dimension(:, :, :   ), allocatable    :: VolTracers, MassTracers
        real, dimension(:, :, :, :), allocatable    :: PropTimeStep
        integer                                     :: ILB, IUB, i
        integer                                     :: JLB, JUB, j
        integer                                     :: KLB, KUB, k
        type (T_Position)                           :: DummYPos    
        integer                                     :: iClass, STAT_CALL, em
        real                                        :: DT, Aux, PropSpatial, Concentration

        !Begin--------------------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber

        ! In this version only writes and computes the statistic of tracers located in the higher priority eulerian model

!            em = Me%EulerModelNumber

            !Shorten
            ILB = Me%EulerModel(em)%WorkSize%ILB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KLB = Me%EulerModel(em)%WorkSize%KLB
            KUB = Me%EulerModel(em)%WorkSize%KUB

            call Search_Property(Me%OriginDefault, PropertyID, CurrentProperty)

            allocate (VolTracers  (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (MassTracers (ILB:IUB, JLB:JUB, KLB:KUB))
            allocate (PropTimeStep(ILB:IUB, JLB:JUB, KLB:KUB, 1 : Me%Statistic%OptionsStat(p)%nClassesLag))

            VolTracers  (:,:,:  ) = 0.
            MassTracers (:,:,:  ) = 0.
            PropTimeStep(:,:,:,:) = 0.

            !Gets global time step 
            call GetComputeTimeStep(Me%ExternalVar%ObjTime, DT, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeStatisticsLag - ModuleLagrangianGlobal - ERR01'


            call GetStatisticClasses(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),                          &
                                     Me%Statistic%OptionsStat(p)%ClassesLag, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ComputeStatisticsLag - ModuleLagrangianGlobal - ERR02'


            CurrentOrigin => Me%FirstOrigin

            do while (associated(CurrentOrigin))

                !Compute the total volume tracer by cell 
                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i  = CurrentPartic%Position%I
                    j  = CurrentPartic%Position%J
                    k  = CurrentPartic%Position%K

                    if (em /= CurrentPartic%Position%ModelID) then
                        CurrentPartic => CurrentPartic%Next
                        cycle
                    endif
       
    WP1:            if (Me%EulerModel(em)%Waterpoints3D(i, j, k) == WaterPoint) then

                        VolTracers (i, j, k) = VolTracers (i, j, k) + CurrentPartic%Geometry%Volume
                        MassTracers(i, j, k) = MassTracers(i, j, k) + CurrentPartic%Mass(iProp)

                    endif WP1

                    CurrentPartic => CurrentPartic%Next

                enddo


                !Compute the frequency by cell 
                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

                    i  = CurrentPartic%Position%I
                    j  = CurrentPartic%Position%J
                    k  = CurrentPartic%Position%K

                    if (em /= CurrentPartic%Position%ModelID) then
                        CurrentPartic => CurrentPartic%Next
                        cycle
                    endif
       
    WP2:            if (Me%EulerModel(em)%Waterpoints3D(i, j, k) == WaterPoint) then


    doClass:            do iClass = 1, Me%Statistic%OptionsStat(p)%nClassesLag
                            if (CurrentPartic%Concentration(iProp) >= Me%Statistic%OptionsStat(p)%ClassesLag(iClass, 1) .and. &
                                CurrentPartic%Concentration(iProp)  < Me%Statistic%OptionsStat(p)%ClassesLag(iClass, 2)) then

                                PropSpatial = CurrentPartic%Geometry%Volume / Me%EulerModel(em)%VolumeZ(i, j, k)


                            else
                                PropSpatial = 0
                            endif
                    
                            PropTimeStep(i, j, k, iClass) =  PropTimeStep(i, j, k, iClass) + PropSpatial

                        enddo doClass
                    endif WP2

                    CurrentPartic => CurrentPartic%Next

                enddo

                CurrentOrigin => CurrentOrigin%Next

            enddo

            do k= KLB, KUB
            do j= JLB, JUB
            do i= ILB, IUB

    WP3:        if (Me%EulerModel(em)%Waterpoints3D(i, j, k) == WaterPoint) then
                    
    VT:             if (VolTracers(i, j, k) < Me%EulerModel(em)%VolumeZ(i, j, k)) then

                        Aux = (Me%EulerModel(em)%VolumeZ(i, j, k) - VolTracers(i, j, k)) / Me%EulerModel(em)%VolumeZ(i, j, k)

                        DummyPos%I = i
                        DummyPos%J = j
                        DummyPos%K = k
               
                        call GetAmbientConcCell      (CurrentProperty,                      &
                                                      em,                                   &
                                                      DummyPos,                             &
                                                      Concentration)


                    else VT

                        Concentration = MassTracers(i, j, k) / VolTracers(i, j, k)
                        PropTimeStep(i, j, k, :)      = 0
                        Aux                           = 1

                    endif VT

               
    Class1:         do iClass = 1, Me%Statistic%OptionsStat(p)%nClassesLag
                        if (Concentration >= Me%Statistic%OptionsStat(p)%ClassesLag(iClass, 1) .and.     &
                            Concentration <  Me%Statistic%OptionsStat(p)%ClassesLag(iClass, 2)) then
                            PropSpatial = Aux

                        else
                            PropSpatial = 0
                        endif

                        PropTimeStep(i, j, k, iClass) =  PropTimeStep(i, j, k, iClass) + PropSpatial
        
                        Me%EulerModel(em)%PropStatistic(p)%FrequencyLag     (i, j, k, iClass, ig) = &
                            (Me%EulerModel(em)%PropStatistic(p)%FrequencyLag(i, j, k, iClass, ig) * &
                            (Me%ExternalVar%RunPeriod - DT) +                                       &
                             PropTimeStep(i, j, k, iClass)  * DT         ) /                        &
                            (Me%ExternalVar%RunPeriod)

                    enddo Class1

                    if (sum(Me%EulerModel(em)%PropStatistic(p)%FrequencyLag(i, j, k, :, ig)) < 0.90) then

                        write(*,*) 'ComputeStatisticsLag - ModuleLagrangianGlobal - WARN10'
                        write(*,*) i, j, k, sum(Me%EulerModel(em)%PropStatistic(p)%FrequencyLag(i, j, k, :, ig)),'< 90%'

                    endif

                    if (sum(Me%EulerModel(em)%PropStatistic(p)%FrequencyLag(i, j, k, :, ig)) > 1.1) then

                        write(*,*) 'ComputeStatisticsLag - ModuleLagrangianGlobal - WARN20'
                        write(*,*) i, j, k, sum(Me%EulerModel(em)%PropStatistic(p)%FrequencyLag(i, j, k, :, ig)),'> 110%'

                    endif


                endif WP3

            enddo
            enddo
            enddo


            call UnGetStatistic(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),                               &
                                Me%Statistic%OptionsStat(p)%ClassesLag, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeStatisticsLag - ModuleLagrangianGlobal - ERR05'


            deallocate (VolTracers )
            deallocate (MassTracers)
            deallocate (PropTimeStep)

        enddo d1
        

    end subroutine ComputeStatisticsLag

    !--------------------------------------------------------------------------


    subroutine Convert_XY_CellIJ (EulerModel,Position, Referential, ConvertOk)

        !Arguments-------------------------------------------------------------
        type (T_EulerModel)                         :: EulerModel   
        type (T_Position)                           :: Position
        integer,    optional, intent(IN)            :: Referential
        logical,    optional, intent(OUT)           :: ConvertOk        

        !Local-----------------------------------------------------------------
        integer                                     :: Ipos, Jpos, STAT_CALL, GridBorderType
        real                                        :: PercI, PercJ


        if (present(ConvertOk)) ConvertOk = .true.

        GridBorderType = GetGridBorderType(EulerModel%ObjHorizontalGrid, Referential = AlongGrid_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR10'


        if   (Referential == GridCoord_) then

            call GetXYCellZ(EulerModel%ObjHorizontalGrid, Position%CoordX,              &
                            Position%CoordY, Ipos, Jpos, PercI, PercJ,                  &
                            Referential = GridCoord_,                                   &
                            Iold        = Position%I,                                   &
                            Jold        = Position%J,                                   &
                            STAT        = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR20'

            Position%CartX   = Position%CoordX
            Position%CartY   = Position%CoordY

            Position%X       = Position%CoordX
            Position%Y       = Position%CoordY

            if (EulerModel%Grid%GeoGrid) then

                call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                          &
                                 Ipos, Jpos, PercI, PercJ,                              &
                                 Position%CartX, Position%CartY,                        &
                                 Referential = Cartesian_,                              &
                                 Xin = Position%CoordX, Yin = Position%CoordY,          &
                                 STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR30'

                Position%X       = Position%CartX
                Position%Y       = Position%CartY

            endif

            if (GridBorderType /= Rectang_) then

                call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                          &
                                 Ipos, Jpos, PercI, PercJ,                              &
                                 Position%X, Position%Y,                                &
                                 Referential = AlongGrid_,                              &
                                 Xin = Position%CoordX, Yin = Position%CoordY,          &
                                 STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR40'
            
            endif

        else if (Referential == AlongGrid_) then

            call GetXYCellZ(EulerModel%ObjHorizontalGrid, Position%X, Position%Y,       &
                            Ipos, Jpos, PercI, PercJ,                                   &
                            Referential = AlongGrid_,                                   &
                            Iold        = Position%I,                                   &
                            Jold        = Position%J,                                   &
                            STAT        = STAT_CALL)

sta:        if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then

                stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR50'
                
            elseif (present(ConvertOk) .and. STAT_CALL == OUT_OF_BOUNDS_ERR_)  then sta
            
                ConvertOk = .false.
                
            else sta

                Position%CartX   = Position%X
                Position%CartY   = Position%Y

                Position%CoordX  = Position%X
                Position%CoordY  = Position%Y

                if (EulerModel%Grid%GeoGrid) then

                    call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                      &
                                     Ipos, Jpos, PercI, PercJ,                          &
                                     Position%CoordX, Position%CoordY,                  &
                                     Referential = GridCoord_,                          &
                                     Xin = Position%CartX, Yin = Position%CartY,        &
                                     STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR60'

                endif

                if (GridBorderType /= Rectang_) then
                    call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                      &
                                     Ipos, Jpos, PercI, PercJ,                          &
                                     Position%CartX, Position%CartY,                    &
                                     Referential = Cartesian_,                          &
                                     Xin = Position%CoordX, Yin = Position%CoordY,      &
                                     STAT = STAT_CALL)

                    if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR70'

                    if (.not. EulerModel%Grid%GeoGrid) then

                        Position%CoordX = Position%CartX
                        Position%CoordY = Position%CartY
                        
                    endif
                endif

        endif sta

       else if (Referential == Cartesian_) then


            call GetXYCellZ(EulerModel%ObjHorizontalGrid, Position%CartX, Position%CartY,&
                            Ipos, Jpos, PercI, PercJ,                                   &
                            Referential = Cartesian_,                                   &
                            Iold        = Position%I,                                   &
                            Jold        = Position%J,                                   &
                            STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR90'


            Position%X       = Position%CartX
            Position%Y       = Position%CartY

            Position%CoordX  = Position%CartX
            Position%CoordY  = Position%CartY

            if (EulerModel%Grid%GeoGrid) then

                call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                          &
                                 Ipos, Jpos, PercI, PercJ,                              &
                                 Position%CoordX, Position%CoordY,                      &
                                 Referential = GridCoord_,                              &
                                 Xin = Position%CartX, Yin = Position%CartY,            &
                                 STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR100'

            endif

            if (GridBorderType /= Rectang_) then

                call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                          &
                                 Ipos, Jpos, PercI, PercJ,                              &
                                 Position%X, Position%Y,                                &
                                 Referential = AlongGrid_,                              &
                                 Xin = Position%CoordX, Yin = Position%CoordY,          &
                                 STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_) stop 'Convert_XY_CellIJ - ModuleLagrangianGlobal - ERR110'
 
            endif


        endif

        !CellJ Position
        Position%CellJ = (Jpos - 1) + PercJ                         
        Position%CellI = (Ipos - 1) + PercI


        Position%I = Ipos
        Position%J = Jpos


    end subroutine Convert_XY_CellIJ

    !--------------------------------------------------------------------------

    subroutine Convert_CellIJ_XY(EulerModel,Position)

        !Arguments-------------------------------------------------------------
        type (T_EulerModel)                         :: EulerModel   
        type (T_Position)                           :: Position


        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        real                                        :: PercI, PercJ

        !----------------------------------------------------------------------

        !Cell Position
        Position%i           = int(Position%CellI) + 1
        Position%j           = int(Position%CellJ) + 1

        PercI       =  Position%CellI - int(Position%CellI)
        PercJ       =  Position%CellJ - int(Position%CellJ)

        call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                                  &
                         Position%i, Position%j, PercI, PercJ,                          &
                         Position%CoordX, Position%CoordY,                              &
                         Referential = GridCoord_,                                      & 
                         STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'Convert_CellIJ_XY - ModuleLagrangianGlobal - ERR10'


        call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                                  &
                         Position%i, Position%j, PercI, PercJ,                          &
                         Position%X, Position%Y,                                        &
                         Referential = AlongGrid_,                                      &
                         STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'Convert_CellIJ_XY - ModuleLagrangianGlobal - ERR20'

        call GetCellZ_XY(EulerModel%ObjHorizontalGrid,                                  &
                         Position%i, Position%j, PercI, PercJ,                          &
                         Position%CartX, Position%CartY,                                &
                         Referential = Cartesian_,                                      &
                         STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'Convert_CellIJ_XY - ModuleLagrangianGlobal - ERR30'


    end subroutine Convert_CellIJ_XY

    !--------------------------------------------------------------------------


    subroutine Convert_Z_CellK (CurrentOrigin, EulerModel, Position, PositionCorrected)

        !Arguments-------------------------------------------------------------
   
        type (T_Origin),     pointer                :: CurrentOrigin
        type (T_EulerModel)                         :: EulerModel   
        type (T_Position)                           :: Position
        logical, optional                           :: PositionCorrected


        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k, kFloor
        real                                        :: Perc
        logical                                     :: PositionCorrected_

        !----------------------------------------------------------------------

        i       = Position%I
        j       = Position%J
        k       = EulerModel%WorkSize%KUB
        kFloor  = EulerModel%kFloor(i, j)
        
        PositionCorrected_ = .false.

        !If the Particle is located above the surface, its placed closed to the
        !surface
        if (Position%Z < EulerModel%SZZ(i, j, k)) then
            Position%Z = EulerModel%SZZ(i, j, k)
            PositionCorrected_ = .true.
        endif


        if (kFloor <= 0) then
            write(*,*) 'Kfloor =',KFloor,' i= ',i,' j= ',j
            stop 'LagrangianGlobal - Convert_Z_CellK - ERR10'
        endif
        
        !If the Particle is located below the bottom, its placed closed to the
        !bottom        
        if (Position%Z >= EulerModel%SZZ(i, j, kFloor-1)) then

            if (CurrentOrigin%State%Deposition) then

                !If the origin emit particles that can be deposited in the bottom and 
                !the particle tries to cross the bottom then is placed at distance from 
                !the bottom lower than the distance beyond each the particle is test 
                !if the shear stress is low enough to consider the particle deposited. 
                Position%Z = EulerModel%SZZ(I, J, KFloor-1) -  &
                             CurrentOrigin%Deposition%BottomDistance / 2.

            elseif(CurrentOrigin%State%HumanBody)then

                Position%Z = EulerModel%SZZ(I, J, KFloor)
                             
            else

                Position%Z = EulerModel%SZZ(I, J, KFloor) +  &
                             EulerModel%DWZ(I, J, KFloor) * 0.9
            endif

            PositionCorrected_ = .true.

        endif

        if (present(PositionCorrected)) PositionCorrected = PositionCorrected_


        !Checks the layer
        do while(EulerModel%SZZ(i, j, k) <= Position%Z)
            k = k - 1
        end do
        
        if (k < KFloor - 1) then
            k = KFloor - 1               
        endif        
        

        Perc = (EulerModel%SZZ(i, j, k) - Position%Z) / (EulerModel%SZZ(i, j, k) - EulerModel%SZZ(i, j, k+1))

        !Avoid Rounding erros
        if (Perc >= 0.999) Perc = 0.99000

        Position%CellK = k + Perc
        
        !----------------------------------------------------------------------

    end subroutine Convert_Z_CellK

    !--------------------------------------------------------------------------

    subroutine Convert_CellK_Z (EulerModel,Position)

        !Arguments-------------------------------------------------------------
        type (T_EulerModel)                         :: EulerModel   
        type (T_Position)                           :: Position

        !Local-----------------------------------------------------------------
        integer                                     :: i, j, k
        real                                        :: Perc

        !----------------------------------------------------------------------

        i = Position%I
        j = Position%J
        k = int (Position%CellK) + 1

        Perc       = Position%CellK - int(Position%CellK)

        Position%Z = EulerModel%SZZ(i, j, k-1) - Perc * EulerModel%DWZ(i, j, k) 
        
    end subroutine Convert_CellK_Z

    !--------------------------------------------------------------------------

    subroutine Convert_CellK_K (Position)

        !Arguments-------------------------------------------------------------
        type (T_Position)                           :: Position

        Position%K = int(Position%CellK) + 1

    end subroutine Convert_CellK_K

    
    !--------------------------------------------------------------------------

    integer function Locate_ModelDomain (X,Y, NoDomain, Referential, emDif)

        !Arguments-------------------------------------------------------------
        real                                        :: X, Y
        logical, optional, intent(OUT)              :: NoDomain
        integer, optional, intent(IN)               :: Referential,  emDif      
        !Local-----------------------------------------------------------------
        integer                                     :: Referential_, em, STAT_CALL, emDif_
        logical                                     :: NoDomain_
        !----------------------------------------------------------------------

        if (present(Referential)) then

            Referential_ = Referential

        else

            Referential_ = GridCoord_

        endif

        if (present(emDif)) then

            emDif_ = emDif

        else

            emDif_ = FillValueInt

        endif

        NoDomain_ = .true.

d1:     do em =1, Me%EulerModelNumber

            if (GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid, X, Y, Referential= Referential_, STAT = STAT_CALL) &
                .and. em /= emDif_) then
                if (STAT_CALL /= SUCCESS_) stop 'Locate_ModelDomain - ModuleLagrangianGlobal - ERR10'
                Locate_ModelDomain = em
                NoDomain_ = .false.
                exit
            endif


        enddo d1

        if (present(NoDomain)) then

            NoDomain = NoDomain_

        endif

        if (NoDomain_) Locate_ModelDomain = FillValueInt
 
        
    end function Locate_ModelDomain

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    integer function ReturnModelIndex (ModelName)

        !Arguments-------------------------------------------------------------
        character(len=*)                            :: ModelName

        !Local-----------------------------------------------------------------
        integer                                     :: em
        logical                                     :: NameFound = .false.

        !----------------------------------------------------------------------


d1:     do em =1, Me%EulerModelNumber

            if (trim(Me%EulerModel(em)%Name)==trim(ModelName)) then
                NameFound = .true.
                exit     
            endif

        enddo d1
        
        if (.not. NameFound) then
            stop 'ReturnModelIndex - ModuleLagrangianGlobal - ERR10'
        endif

        ReturnModelIndex = em
        
    end function ReturnModelIndex

    !--------------------------------------------------------------------------

    subroutine Search_Property(CurrentOrigin, PropertyID, CurrentProperty, ArrayIndex)

        !Arguments-------------------------------------------------------------
        type(T_Origin),    pointer                     :: CurrentOrigin
        type(T_Property),  pointer                     :: CurrentProperty
        integer         ,  intent (IN)                 :: PropertyID
        integer,           intent (OUT), optional      :: ArrayIndex
        !Local-----------------------------------------------------------------
        integer                                        :: nP
        !Begin-----------------------------------------------------------------
        
        CurrentProperty => CurrentOrigin%FirstProperty

        nP = 1

        do while (associated(CurrentProperty)) 
            if (CurrentProperty%ID ==PropertyID) then
                exit        
            else
                CurrentProperty => CurrentProperty%Next                 
            end if    
            nP = nP + 1
        end do    

        if (present(ArrayIndex)) ArrayIndex = nP
        
        if (.not. associated(CurrentProperty)) then

            call SetError(FATAL_, INTERNAL_, 'Search_Property - ModuleLagrangianGlobal - ERR10')

        end if 

 

    end subroutine Search_Property
    
    !-------------------------------------------------------------------------
    subroutine BacktrackingTime(NowIn, NowOut)

        !Arguments------------------------------------------------------------
        type (T_Time), intent(IN )                      :: NowIn
        type (T_Time), intent(OUT)                      :: NowOut
        !Local----------------------------------------------------------------
        real(8)                                         :: TotalTime, AuxPeriod

        !Begin----------------------------------------------------------------

        TotalTime = Me%ExternalVar%EndTime - Me%ExternalVar%BeginTime                  
        AuxPeriod = NowIn      - Me%ExternalVar%BeginTime
        AuxPeriod = TotalTime  - AuxPeriod
                    
        NowOut    = Me%ExternalVar%BeginTime + AuxPeriod        

    end subroutine BacktrackingTime
    
    !-------------------------------------------------------------------------
    

    !--------------------------------------------------------------------------

    subroutine ParticleOutput ()

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        real(8), dimension(:), pointer              :: Matrix1D, Matrix1DX, Matrix1DY
        real(8), dimension(:), pointer              :: Aux1DX, Aux1DY        
        integer                                     :: nP
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: OutPutNumber
        type (T_Time)                               :: Actual, Aux
        integer                                     :: STAT_CALL
        integer, dimension(:), allocatable          :: TotParticle
        integer                                     :: ParticleBeached
        integer                                     :: iProp, nProp, ig, nGroupProp
        type (T_Property), pointer                  :: CurrentProperty, FirstProperty
        type (T_Property), pointer                  :: AgeProperty
        integer                                     :: nPropAge, n
        real, dimension(6), target                  :: AuxTime
        real, dimension(:), pointer                 :: TimePtr
        integer, dimension(:, :, :), pointer        :: OpenPoints3D
        real, dimension(:, :, :), pointer           :: SZZ
        real, dimension(:, :   ), pointer           :: OutPutMatrix
        integer                                     :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        character(StringLength)                     :: AuxChar, GroupName
        real, dimension(:),       pointer           :: MaximumDepth
        integer                                     :: OutPutLines, JetTotalParticles, em, em1, emMax, emp
        type (T_Position)                           :: Position
        real(8)                                     :: AverageX, AverageY, Stdv, RadiusOfInfluence !,AuxPeriod,TotalTime
        integer                                     :: ParticSurface
        integer                                     :: Dim1D_av
        !Begin--------------------------------------------------------------------------
        
        if (Me%StopWithNoPart) then
            nP = 0                
            CurrentOrigin => Me%FirstOrigin
            do while (associated(CurrentOrigin))

                !XPosition
                CurrentPartic   => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))
                    nP = nP + 1
                    CurrentPartic => CurrentPartic%Next
                enddo
                CurrentOrigin => CurrentOrigin%Next
            enddo
            
            if (nP ==0) then
                Me%Output%Write_ = .false.
            endif
        endif
        
        if (Me%Output%Write_) then

            OutPutNumber = Me%OutPut%NextOutPut
            !Shorten Var
            Actual       =  Me%Now

TOut:       if (Actual >= Me%OutPut%OutTime(OutPutNumber)) then 

                if (Me%ExternalVar%Backtracking) then
                    OutPutNumber = Me%OutPut%TotalOutputs - OutPutNumber + 1 
                endif 

                emMax = Me%EulerModelNumber 

                allocate(MaximumDepth(1:emMax))

                do em1 = 1, Me%EulerModelNumber 

                    call GetMaximumValue(Me%EulerModel(em1)%ObjGridData, MaximumDepth(em1), STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR10'

                enddo

de:             do em = 1, Me%EulerModelNumber

                OpenPoints3D    => Me%EulerModel(em)%OpenPoints3D
                SZZ             => Me%EulerModel(em)%SZZ
                WorkILB         =  Me%EulerModel(em)%WorkSize%ILB 
                WorkIUB         =  Me%EulerModel(em)%WorkSize%IUB 
                        
                WorkJLB         =  Me%EulerModel(em)%WorkSize%JLB 
                WorkJUB         =  Me%EulerModel(em)%WorkSize%JUB 
                        
                WorkKLB         =  Me%EulerModel(em)%WorkSize%KLB 
                WorkKUB         =  Me%EulerModel(em)%WorkSize%KUB 

                nP = 0                
                CurrentOrigin => Me%FirstOrigin
d1:             do while (associated(CurrentOrigin))

                    !XPosition
                    CurrentPartic   => CurrentOrigin%FirstPartic
                    do while (associated(CurrentPartic))
                        nP = nP + 1
                        CurrentPartic => CurrentPartic%Next
                    enddo
                    CurrentOrigin => CurrentOrigin%Next
                enddo d1
                
                if (Me%StopWithNoPart .and. nP ==0) then
                    write(*,*) "Model ended because number of particles equal to zero"
                    stop
                endif


i0:             if (Me%RunOnline .and. em == emMax .and. Me%Online%EmissionTemporal == Instantaneous_) then 

                    if (nP == 0) then
                        call DummyParticleStartDate(em, OutPutNumber)
                    else
                        call WriteRunOnline(em, OutputNumber)
                    endif 

                    cycle

                endif i0
                
                if (Me%ExternalVar%Backtracking) then  
                    !TotalTime = Me%ExternalVar%EndTime - Me%ExternalVar%BeginTime                  
                    !AuxPeriod = Actual     - Me%ExternalVar%BeginTime
                    !AuxPeriod = TotalTime  - AuxPeriod
                    !
                    !Aux = Me%ExternalVar%BeginTime + AuxPeriod

                    call BacktrackingTime(NowIn = Actual, NowOut = Aux)                    
                else
                    Aux = Actual
                endif                 

                !Writes the Instant - HDF 5
                call ExtractDate   (Aux, AuxTime(1), AuxTime(2), AuxTime(3),          &
                                    AuxTime(4), AuxTime(5), AuxTime(6))
                TimePtr => AuxTime
                call HDF5SetLimits  (Me%ObjHDF5(em), 1, 6, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR20'

                call HDF5WriteData  (Me%ObjHDF5(em), "/Time", "Time", "YYYY/MM/DD HH:MM:SS",      &
                                     Array1D = TimePtr, OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR30'


                !Writes SZZ - HDF 5
                call HDF5SetLimits  (Me%ObjHDF5(em), WorkILB, WorkIUB, WorkJLB,   &
                                     WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR40'

                call HDF5WriteData  (Me%ObjHDF5(em), "/Grid/VerticalZ", "Vertical",  &
                                     "m", Array3D = SZZ, OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR50'


                !Writes OpenPoints - HDF 5
                call HDF5SetLimits  (Me%ObjHDF5(em), WorkILB, WorkIUB,            &
                                     WorkJLB, WorkJUB, WorkKLB, WorkKUB,                 &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR60'

                call HDF5WriteData  (Me%ObjHDF5(em), "/Grid/OpenPoints", "OpenPoints",  &
                                     "-", Array3D = OpenPoints3D, OutputNumber = OutPutNumber, &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR70'

                if (Me%Now > Me%ExternalVar%LastConcCompute .and. em == 1) call FillGridConcentration

                call WriteGridConcentration(em, OutputNumber) 

                !Flushes All pending HDF5 commands
                call HDF5FlushMemory (Me%ObjHDF5(em), ErrorMessage ='ParticleOutput - ModuleLagrangianGlobal - ERR75',&
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR75'

                if (Me%State%Oil) then
                    call WriteOilGridThickness       (em, OutputNumber) 
                    call WriteOilGridConcentration   (em, OutputNumber)
                    call WriteOilGridConcentration3D (em, OutputNumber)
                    call WriteOilGridDissolution3D   (em, OutputNumber)
                    call WriteOilPresence            (em, OutputNumber)
                endif

                if (Me%State%HNS) then
                    call WriteHNSGridConc3D (em, OutputNumber)
                    call WriteHNSGridConc2D (em, OutputNumber)
                endif

                if (em /= emMax) cycle

                allocate (TotParticle(Me%nGroups))
                TotParticle(:) = 0

                JetTotalParticles = 0
                
i1:             if (nP>0) then

                    !Writes Data for every origin
                    CurrentOrigin => Me%FirstOrigin
    CurrOr:         do while (associated(CurrentOrigin))

                        allocate   (Matrix1DX(CurrentOrigin%nParticle))
                        allocate   (Matrix1DY(CurrentOrigin%nParticle))
                        Matrix1DX(:) = FillValueReal
                        Matrix1DY(:) = FillValueReal

                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR80'

                        !XPosition
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            emp = CurrentPartic%Position%ModelID
                            Matrix1DX(nP)  = CurrentPartic%Position%CartX
                            Matrix1DY(nP)  = CurrentPartic%Position%CartY
                            CurrentPartic => CurrentPartic%Next
                        enddo
                        if (nP > 0) then

                            if (Me%AveragePositionON) then
                                AverageX = sum(Matrix1DX(1:nP)) / real(nP)
                                AverageY = sum(Matrix1DY(1:nP)) / real(nP)
                                if (nP > 1) then
                                    Stdv = 0
                                    do n = 1, nP
                                        Stdv = Stdv + ((Matrix1DX(n) - AverageX)**2. +      &
                                                       (Matrix1DY(n) - AverageY)**2.) / (real(nP) - 1)
                                
                                    enddo
                                    RadiusOfInfluence = Me%CoefRadius * sqrt(Stdv)
                                else
                                    RadiusOfInfluence = 0.
                                endif
                            else
                                AverageX          = FillValueReal
                                AverageY          = FillValueReal
                                RadiusOfInfluence = FillValueReal
                            endif 

                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/X Pos", &
                                                "X Position",  "m", Array1D = Matrix1DX,                      &
                                                 Average = AverageX, Radius = RadiusOfInfluence,              &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR90'
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Y Pos", &
                                                "Y Position",  "m", Array1D = Matrix1DY,                      &
                                                 Average = AverageY, Radius = RadiusOfInfluence,              &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR100'
                            

                            if (Me%OutPut%OriginEnvelope) then
                                call WriteOriginEnvelope(CurrentOrigin%Name, Matrix1DX, Matrix1DY, &
                                                          "X Pos", "Y Pos",  "m", OutputNumber, em)  
                            endif                            

                        endif

                      !GeoGraphic Position

                        !Longitude, Latitude
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1DX(nP)  =  GeographicCoordinates (CurrentPartic%Position%ModelID, CurrentPartic%Position, 1)
                            Matrix1DY(nP)  =  GeographicCoordinates (CurrentPartic%Position%ModelID, CurrentPartic%Position, 2)
                            CurrentPartic => CurrentPartic%Next
                        enddo

                        if (nP > 0) then

                            if (Me%AveragePositionON) then
                                AverageX = sum(Matrix1DX(1:nP)) / real(nP)
                                AverageY = sum(Matrix1DY(1:nP)) / real(nP)

                                if (nP > 1) then
                                    Stdv = 0.
                                    do n = 1, nP
                                        Stdv = Stdv + ((Matrix1DX(n) - AverageX)**2. +      &
                                                       (Matrix1DY(n) - AverageY)**2.) / (real(nP) - 1)
                            
                                    enddo
                                    RadiusOfInfluence = Me%CoefRadius * sqrt(Stdv)
                                else
                                    RadiusOfInfluence = 0.
                                endif

                            else
                                AverageX          = FillValueReal
                                AverageY          = FillValueReal
                                RadiusOfInfluence = FillValueReal
                            endif 


                            call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR80'


                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Longitude", &
                                                "Longitude",  "º", Array1D = Matrix1DX,                      &
                                                 Average = AverageX, Radius = RadiusOfInfluence,             &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR110'

                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Latitude", &
                                                "Latitude",  "º", Array1D = Matrix1DY,                       &
                                                 Average = AverageY, Radius = RadiusOfInfluence,             &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR120'

#ifndef _NO_NETCDF                                                     
                            if (Me%OutPut%NetCDF) then
                                call Open1DNetCDFFile    (CurrentOrigin, Aux)  
                                call SetDims1DNetCDFFile ("id", CurrentOrigin%nParticle, Me%OutPut%NetCDF_DimID)
                                call Write1DNetCDFFile   ("longitude", Matrix1DX, "o"  , Me%OutPut%NetCDF_DimID)  
                                call Write1DNetCDFFile   ("latitude",  Matrix1DY, "o"  , Me%OutPut%NetCDF_DimID)  
                            endif
#endif                            

                            if (Me%OutPut%OriginEnvelope) then
                                call WriteOriginEnvelope(CurrentOrigin%Name, Matrix1DX, Matrix1DY, &
                                                         "Longitude", "Latitude", "º", OutputNumber, em,    &
                                                         OutPutNetCDF = Me%OutPut%NetCDF)  
                            endif
                            
                            
                            allocate  (Aux1DX(1), Aux1DY(1))
                            
                            Aux1DX(1) = AverageX
                            Aux1DY(1) = AverageY
                            
                            call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR160'
    
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Longitude average", &
                                                "Longitude average",  "-", Array1D = Aux1DX,                      &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR170'

                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Latitude average", &
                                                "Latitude average",  "-", Array1D = Aux1DY,                       &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR180'
#ifndef _NO_NETCDF                         
                            if (Me%OutPut%NetCDF) then
                                call SetDims1DNetCDFFile("average", 1, Dim1D_av)
                                call Write1DNetCDFFile  ("lon_average", Aux1DX, "o", Dim1D_av)
                                call Write1DNetCDFFile  ("lat_average", Aux1DY, "o", Dim1D_av)
                            endif
#endif
                            deallocate   (Aux1DX)
                            deallocate   (Aux1DY)                                
                            
#ifdef _GOOGLEMAPS  

                            allocate   (Aux1DX(CurrentOrigin%nParticle))
                            allocate   (Aux1DY(CurrentOrigin%nParticle))
                            Aux1DX(:) = FillValueReal
                            Aux1DY(:) = FillValueReal

                            if (.not. (nP == 1 .and. Matrix1DX(1) < HalfFillValueReal)) then
    
                                call WGS84toGoogleMaps (Matrix1DX, Matrix1DY, CurrentOrigin%nParticle, Aux1DX, Aux1DY)
                                
                            endif                                

                            if (Me%AveragePositionON) then
                                AverageX = sum(Aux1DX(1:nP)) / real(nP)
                                AverageY = sum(Aux1DY(1:nP)) / real(nP)

                                if (nP > 1) then
                                    Stdv = 0.
                                    do n = 1, nP
                                        Stdv = Stdv + ((Aux1DY(n) - AverageX)**2. +      &
                                                       (Aux1DY(n) - AverageY)**2.) / (real(nP) - 1)
                            
                                    enddo
                                    RadiusOfInfluence = Me%CoefRadius * sqrt(Stdv)
                                else
                                    RadiusOfInfluence = 0.
                                endif

                            else
                                AverageX          = FillValueReal
                                AverageY          = FillValueReal
                                RadiusOfInfluence = FillValueReal
                            endif 

                            call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR130'

                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/googlemaps_x", &
                                                "googlemaps_x",  "-", Array1D = Aux1DX,                      &
                                                 Average = AverageX, Radius = RadiusOfInfluence,             &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR140'

                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/googlemaps_y", &
                                                "googlemaps_y",  "-", Array1D = Aux1DY,                       &
                                                 Average = AverageY, Radius = RadiusOfInfluence,             &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR150'


                            if (Me%OutPut%OriginEnvelope) then
                                call WriteOriginEnvelope(CurrentOrigin%Name, Aux1DX, Aux1DY, &
                                                          "googlemaps_x", "googlemaps_y", "-", OutputNumber, em)  
                            endif   

                            deallocate(Aux1DX, Aux1DY)
                            
                            allocate  (Aux1DX(1), Aux1DY(1))
                            
                            Aux1DX(1) = AverageX
                            Aux1DY(1) = AverageY
                            
                            call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR160'
    
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/googlemaps_x_average", &
                                                "googlemaps_x_average",  "-", Array1D = Aux1DX,                      &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR170'

                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/googlemaps_y_average", &
                                                "googlemaps_y_average",  "-", Array1D = Aux1DY,                       &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR180'


    
                            deallocate   (Aux1DX)
                            deallocate   (Aux1DY)    
#endif                                
                            
                        endif
 
                        deallocate   (Matrix1DX)
                        deallocate   (Matrix1DY)


                        allocate    (Matrix1D(CurrentOrigin%nParticle))
                        Matrix1D(:) = FillValueReal


                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR190'


                        !Real ZPosition
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  =  CurrentPartic%Position%Z
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Z Pos", &
                                                "Z Position",  "m", Array1D = Matrix1D, OutputNumber = OutPutNumber,    &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR200'
                            
#ifndef _NO_NETCDF                         
                            if (Me%OutPut%NetCDF) then
                                call Write1DNetCDFFile   ("Z Position", Matrix1D, "m"  , Me%OutPut%NetCDF_DimID) 
                            endif
#endif                                
                            
                        endif

                        !ZPosition for Vertical Cut
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            emp = CurrentPartic%Position%ModelID
                            Matrix1D(nP)  =  MaximumDepth(emp) - CurrentPartic%Position%Z
                            CurrentPartic => CurrentPartic%Next
                        enddo            

                        !Volume
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  =  CurrentPartic%Geometry%Volume
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Volume", &
                                                "Volume",  "m3", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR210'
                        endif
                        
                        !Freezed
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  = 0.
                            if (CurrentPartic%Freezed) Matrix1D(nP)  = 1.
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Freezed", &
                                                "Freezed",  "[]", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR220'
                        endif                        

                        !OriginNumber
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  =  CurrentOrigin%ID
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Origin ID", &
                                                "Origin ID",  "-", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR230'
                        endif
                        
                        !ParticNumber
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  =  CurrentPartic%ID
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Partic ID", &
                                                "Partic ID",  "-", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR230'
                        endif                        

                        !Model ID
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  =  CurrentPartic%Position%ModelID
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Model ID", &
                                                "Model ID",  "-", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR240'
                        endif

                    
                        if (CurrentOrigin%State%Age) then

                            !Age
                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                Matrix1D(nP)  =  CurrentPartic%Age / 86400.
                                CurrentPartic => CurrentPartic%Next
                            enddo  
                            
                            nullify(CurrentPartic)
                                      
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Age", &
                                                    "Age",  "days", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR250'
                            endif

                        endif

                        if (CurrentOrigin%State%Oil) then

                            !oil Thickness 
                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                emp = CurrentPartic%Position%ModelID
                                ig  = CurrentOrigin%GroupID
                                
                                if (CurrentOrigin%AreaMethod == VoronoiArea_) then
                                    Matrix1D(nP)  = CurrentPartic%Geometry%Thickness 
                                else                                
                                    Matrix1D(nP)  = InterpolXYPoint                                            &
                                        (HorizontalGridID = Me%EulerModel(emp)%ObjHorizontalGrid,              &
                                         Field2DFather    = Me%EulerModel(emp)%OilSpreading(ig)%GridThickness, &
                                         XInput           = CurrentPartic%Position%CoordX,                     &
                                         YInput           = CurrentPartic%Position%CoordY,                     &
                                         STAT             = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR260'
                                endif
                                Matrix1D(nP)  =  Matrix1D(nP) * 1e6 * (1 - Me%ExternalVar%VWaterContent)
                                CurrentPartic => CurrentPartic%Next
                                
                            enddo  
                            
                            nullify(CurrentPartic)
                                      
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Thickness", &
                                                    "Thickness",  "micro m", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR270'
                                
#ifndef _NO_NETCDF                         
                                if (Me%OutPut%NetCDF) then
                                    call Write1DNetCDFFile   ("Thickness", Matrix1D, "micro m"  , Me%OutPut%NetCDF_DimID) 
                                endif
#endif                                
                                
                                 
                            endif

                        endif                        
                        
                        
                        if (CurrentOrigin%State%FarFieldBuoyancy) then                        

                            !Density
                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                Matrix1D(nP)  =  CurrentPartic%SigmaDensity
                                CurrentPartic => CurrentPartic%Next
                            enddo  
                            
                            nullify(CurrentPartic)
                                      
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/density", &
                                                    "density",  "sigma density kg/m^3", Array1D = Matrix1D,             &
                                                    OutputNumber = OutPutNumber, STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR280'
                            endif

                        endif

                        !Beached Particles
                        if ((Me%State%AssociateBeachProb .and. CurrentOrigin%Beaching) .or. Me%LitterON) then

                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                if (.NOT. CurrentPartic%Beached) then 
                                    ParticleBeached = 1
                                else
                                    ParticleBeached = 2
                                end if

                                Matrix1D(nP)  = ParticleBeached
                                CurrentPartic => CurrentPartic%Next
                            enddo            
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Beached", &
                                                    "Beached",  "-", Array1D = Matrix1D, OutputNumber = OutPutNumber,   &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR290'
                            endif
                    
                        endif
                        
                        
                        if (CurrentOrigin%State%CalcPartDistToCoast) then

                            !Particle distance to coast
                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                Matrix1D(nP)  =  CurrentPartic%DistanceToCoast
                                CurrentPartic => CurrentPartic%Next
                            enddo  
                            
                            nullify(CurrentPartic)
                                      
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/DistanceToCoast", &
                                                    "DistanceToCoast",  "m", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR291'
                            endif

                        endif
                        
                        

                       if (CurrentOrigin%State%Oil) then

                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                if (CurrentPartic%Position%Surface) then 

                                    ParticSurface  = 1

                                else

                                    ParticSurface  = 2

                                end if


                                Matrix1D(nP) = ParticSurface
                                CurrentPartic => CurrentPartic%Next
                            enddo            
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em),                                              &
                                                     "/Results/"//trim(CurrentOrigin%Name)//"/Surface State",     &
                                                     "Surface State",                                             &
                                                     "ON/OFF",                                                    &
                                                     Array1D = Matrix1D, OutputNumber = OutPutNumber,             &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR295'
                            endif
                    
                        endif

                       if (CurrentOrigin%State%Deposition) then

                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                if (CurrentPartic%Deposited) then 

                                    Matrix1D(nP)  = 1 

                                else

                                    Matrix1D(nP)  = 2

                                end if


                                CurrentPartic => CurrentPartic%Next
                            enddo            
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Deposition State", &
                                                    "State",  "ON/OFF", Array1D = Matrix1D, OutputNumber = OutPutNumber,     &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR300'
                            endif
                    
                        endif
                        
                        
                        if (CurrentOrigin%State%HumanBody) then

                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                
                                nP = nP + 1
                                
                                if(.not. CurrentOrigin%HumanBody%Drowned)then
                                
                                    Matrix1D(nP)  = 0 
                                    
                                else
                                    
                                if (CurrentPartic%AtTheBottom) then 

                                    Matrix1D(nP)  = 1 

                                else

                                    Matrix1D(nP)  = 2

                                end if
                                endif

                                CurrentPartic => CurrentPartic%Next
                            enddo            
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//&
                                                    "/At The Bottom", "At The Bottom",  "ON/OFF",           &
                                                     Array1D = Matrix1D, OutputNumber = OutPutNumber,       &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR301'
                            endif
                    
                        endif

                        !Particle State
                        CurrentPartic   => CurrentOrigin%FirstPartic
                        nP = 0
                        do while (associated(CurrentPartic))
                            nP = nP + 1
                            Matrix1D(nP)  =  CurrentPartic%ParticleState
                            CurrentPartic => CurrentPartic%Next
                        enddo            
                        if (nP > 0) then
                            !HDF 5
                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//&
                                                "/Particle State", "Particle State",  "-",              &
                                                Array1D = Matrix1D, OutputNumber = OutPutNumber,        &
                                                STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR240'
                        endif

                        !HNS
                        if (CurrentOrigin%State%HNS) then

                            CurrentPartic   => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                Matrix1D(nP)  =  CurrentPartic%HNSParticleState
                                CurrentPartic => CurrentPartic%Next
                            enddo            
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//&
                                                    "/HNS Particle State", "HNS Particle State",  "-",      &
                                                    Array1D = Matrix1D, OutputNumber = OutPutNumber,        &
                                                    STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR240'
                            endif
                        endif                        
                        
                        CurrentProperty => CurrentOrigin%FirstProperty
                        do while (associated(CurrentProperty))

                            if (CurrentProperty%ID == Fecal_Coliforms_ .or.CurrentProperty%ID == E_Coli_) then

                                CurrentPartic   => CurrentOrigin%FirstPartic
                                nP = 0
                                do while (associated(CurrentPartic))
                                    nP = nP + 1
                                    !T90 in hours
                                    Matrix1D(nP)  = CurrentPartic%T90 / 3600.

                                    CurrentPartic => CurrentPartic%Next
                                enddo            
                                if (nP > 0) then
                                    !HDF 5
                                    call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)// &
                                                         "/"//trim(CurrentProperty%T90Name),                     &
                                                         trim(CurrentProperty%T90Name),  "hours",                &
                                                         Array1D = Matrix1D, OutputNumber = OutPutNumber,        &
                                                         STAT = STAT_CALL)
                                    if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR310'
                                endif


                            endif

                            CurrentProperty => CurrentProperty%Next
                        enddo



                        !Properties
                        nProp =  1
                        CurrentProperty => CurrentOrigin%FirstProperty
                        do while (associated(CurrentProperty))

                            nullify(AgeProperty)
                            nPropAge = 1
                            if (CurrentProperty%ID == Larvae_) then
                                AgeProperty => CurrentOrigin%FirstProperty
                                do while (AgeProperty%ID /= Age_)
                                    nPropAge = nPropAge + 1
                                    AgeProperty => AgeProperty%Next
                                enddo
                            endif

                            CurrentPartic => CurrentOrigin%FirstPartic
                            nP = 0
                            do while (associated(CurrentPartic))
                                nP = nP + 1
                                Matrix1D(nP)  =  CurrentPartic%Concentration(nProp)
                                CurrentPartic => CurrentPartic%Next
                            enddo            
                            if (nP > 0) then
                                !HDF 5
                                call HDF5WriteData  (Me%ObjHDF5(em),                  &
                                                     "/Results/"//trim(CurrentOrigin%Name)// &
                                                     "/"//trim(CurrentProperty%Name),        &
                                                     trim(CurrentProperty%Name),             &
                                                     trim(CurrentProperty%Units),            &
                                                     Array1D = Matrix1D,                     &
                                                     OutputNumber = OutPutNumber,            &
                                                     STAT = STAT_CALL)
                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR320'
                            endif
                            nProp = nProp + 1
                            CurrentProperty => CurrentProperty%Next
                        enddo
                        
                        if (CurrentOrigin%State%VariableGeom) then
                            call HDF5WriteParticAmbientConc(CurrentOrigin, em, OutPutNumber,Matrix1D)
                        endif                                

                        deallocate  (Matrix1D)
                        

                        if (Me%State%MeteoOcean) then
                            call HDF5WriteDataMeteoOcean(CurrentOrigin, em, OutPutNumber)
                        endif
                        
                        if (Me%State%Deposition) then
                            call HDF5WriteDataBottomStress(CurrentOrigin, em, OutPutNumber)
                        endif
                        
    iplume:             if (CurrentOrigin%State%ComputePlume .and. CurrentOrigin%Flow > 0.) then

                            emp = CurrentOrigin%Position%ModelID

                            call GetOutPutMatrix(CurrentOrigin%Movement%ObjJet, OutPutMatrix, &
                                                 OutPutLines = OutPutLines, STAT=STAT_CALL)

                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR330'

                            if (OutPutLines < 1) then

                                call UnGetJet(CurrentOrigin%Movement%ObjJet, OutPutMatrix, STAT=STAT_CALL)

                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR340'

                                call ActualizeJetProperties(CurrentOrigin)

                                call GetOutPutMatrix(CurrentOrigin%Movement%ObjJet, OutPutMatrix, &
                                                     OutPutLines = OutPutLines, STAT=STAT_CALL)

                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR350'

                                if (OutPutLines < 1) then
                                    stop 'ParticleOutput - ModuleLagrangianGlobal - ERR360'
                                endif

                            endif

                            JetTotalParticles = JetTotalParticles + OutPutLines

                            allocate   (Matrix1DX(OutPutLines))
                            allocate   (Matrix1DY(OutPutLines))

                            Matrix1DX(:) = FillValueReal
                            Matrix1DY(:) = FillValueReal

                            call HDF5SetLimits  (Me%ObjHDF5(em), 1, OutPutLines, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR370'

                            do np = 1, OutPutLines
                                Position%CartX = OutPutMatrix(np,2)
                                Position%CartY = OutPutMatrix(np,3)
                                call Convert_XY_CellIJ(Me%EulerModel(emp), Position, Referential = Cartesian_)
                                Matrix1DX(np) = GeographicCoordinates (emp, Position, 1)
                                Matrix1DY(np) = GeographicCoordinates (emp, Position, 2)
                            enddo

                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Plume X", &
                                                "Plume X",  "m", Array1D = Matrix1DX, OutputNumber = OutPutNumber,    &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR380'

                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Plume Y", &
                                                "Plume Y",  "m", Array1D = Matrix1DY, OutputNumber = OutPutNumber,    &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR390'


                            Matrix1DX(1:OutPutLines) = OutPutMatrix(1:OutPutLines,4)
                            Matrix1DY(1:OutPutLines) = OutPutMatrix(1:OutPutLines,6)


                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Plume Z", &
                                                "Plume Z",  "m", Array1D = Matrix1DX, OutputNumber = OutPutNumber,    &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR400'

                            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Plume Conc", &
                                                "Plume Conc",  "a", Array1D = Matrix1DY, OutputNumber = OutPutNumber,    &
                                                 STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR410'

                            call UnGetJet(CurrentOrigin%Movement%ObjJet, OutPutMatrix, STAT=STAT_CALL)

                            if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR420'

                            deallocate   (Matrix1DX)
                            deallocate   (Matrix1DY)

                        endif iplume


                        !Integrates the sum of the particle which belong to the same 
                        !Group
                        do ig = 1, Me%nGroups
                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                TotParticle(ig) = TotParticle(ig) + CurrentOrigin%nParticle
                            endif
                        enddo


                        CurrentOrigin => CurrentOrigin%Next

                    enddo CurrOr
                    
#ifndef _NO_NETCDF                         
                    if (Me%OutPut%NetCDF) then
                        call KillNETCDF(NCDFID = Me%Output%ObjNetCDF, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR425'
                    endif
#endif             
                    
                endif i1


                    !Writes 1D data for every group

dig:                do ig = 1, Me%nGroups
iTP:                    if (TotParticle(ig) == 0) then
                            TotParticle(ig) = 1
                        endif iTP


                        allocate    (Matrix1DX(TotParticle(ig)))
                        allocate    (Matrix1DY(TotParticle(ig)))
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, TotParticle(ig),  &
                                             STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR430'
                        
                                                
                                                                        
                        Matrix1DX(:) = FillValueReal
                        Matrix1DY(:) = FillValueReal
                        
                        write (AuxChar, fmt='(i3)') Me%GroupIDs(ig)
                        
                        GroupName = "Group_"//trim(adjustl(AuxChar))//"/Data_1D"


                        !(XPosition)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    XPos:               do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    Matrix1DX(nP)  =  CurrentPartic%Position%CartX
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo XPos

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                          &
                                                   "/Results/"//trim(GroupName)//"/X Pos",  &
                                                   "X Position",                            &
                                                   "m",                                     &
                                                   Array1D = Matrix1DX,                     &
                                                   OutputNumber = OutPutNumber,             &
                                                   STAT = STAT_CALL)

                        !(YPosition)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    YPos:               do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    emp  = CurrentPartic%Position%ModelID
                                    Matrix1DY(nP)  =  CurrentPartic%Position%CartY
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo YPos
                    

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Y Pos",   &
                                                   "Y Position",                             &
                                                   "m",                                      &
                                                   Array1D = Matrix1DY,                      &
                                                   OutputNumber = OutPutNumber,              &
                                                   STAT = STAT_CALL)
                                                   
                        if (Me%OutPut%OriginEnvelope) then
                            call WriteOriginEnvelope(GroupName, Matrix1DX, Matrix1DY,   &
                                                      "X Pos", "Y Pos",  "m", OutputNumber, em)  
                        endif                            
                                               


                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
                        do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    emp = CurrentPartic%Position%ModelID
                                    Matrix1DX(nP)  =  GeographicCoordinates (emp, CurrentPartic%Position, 1)
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo
                            endif
                            CurrentOrigin => CurrentOrigin%Next
                        enddo
                        
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, TotParticle(ig), STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR440'
                        

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Longitude", &
                                                   "Longitude",                              &
                                                   "º",                                      &
                                                   Array1D = Matrix1DX,                      &
                                                   OutputNumber = OutPutNumber,              &
                                                   STAT = STAT_CALL)



                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
                        do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                
                                    emp = CurrentPartic%Position%ModelID
                                    Matrix1DY(nP)  =  GeographicCoordinates (emp, CurrentPartic%Position, 2)
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1

                                enddo
                            endif
                            CurrentOrigin => CurrentOrigin%Next
                        enddo
                        
                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Latitude",&
                                                   "Latitude",                               &
                                                   "º",                                      &
                                                   Array1D = Matrix1DY,                      &
                                                   OutputNumber = OutPutNumber,              &
                                                   STAT = STAT_CALL)
                                                   

                        if (Me%OutPut%OriginEnvelope) then
                            call WriteOriginEnvelope(trim(GroupName),Matrix1DX, Matrix1DY, &
                                                      "Longitude", "Latitude", "º", OutputNumber, em)  
                        endif
                                                   

                        nP = TotParticle(ig)
                        
                        if (nP > 0) then

                            if (Me%AveragePositionON) then
                                AverageX = sum(Matrix1DX(1:nP)) / real(nP)
                                AverageY = sum(Matrix1DY(1:nP)) / real(nP)

                                if (nP > 1) then
                                    Stdv = 0.
                                    do n = 1, nP
                                        Stdv = Stdv + ((Matrix1DX(n) - AverageX)**2. +      &
                                                       (Matrix1DY(n) - AverageY)**2.) / (real(nP) - 1)
                            
                                    enddo
                                    RadiusOfInfluence = Me%CoefRadius * sqrt(Stdv)
                                else
                                    RadiusOfInfluence = 0.
                                endif

                            else
                                AverageX          = FillValueReal
                                AverageY          = FillValueReal
                                RadiusOfInfluence = FillValueReal
                            endif    
                            
                        endif        
                        
                        allocate  (Aux1DX(1), Aux1DY(1))
                        
                        Aux1DX(1) = AverageX
                        Aux1DY(1) = AverageY 
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR442'
                                                             

                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(GroupName)//"/Longitude average", &
                                            "Longitude average",  "-", Array1D = Aux1DX,                      &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR444'

                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(GroupName)//"/Latitude average", &
                                            "Latitude average",  "-", Array1D = Aux1DY,                       &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR446'

                        deallocate  (Aux1DX, Aux1DY)
#ifdef _GOOGLEMAPS  

                        allocate   (Aux1DX(TotParticle(ig)))
                        allocate   (Aux1DY(TotParticle(ig)))
                        Aux1DX(:) = FillValueReal
                        Aux1DY(:) = FillValueReal
                        
                        if (.not. (nP == 1 .and. Matrix1DX(1) < HalfFillValueReal)) then

                            call WGS84toGoogleMaps (Matrix1DX, Matrix1DY, TotParticle(ig), Aux1DX, Aux1DY)
                            
                        endif                            
                        
                        nP = TotParticle(ig)
                        
                        if (Me%AveragePositionON) then
                            AverageX = sum(Aux1DX(1:nP)) / real(nP)
                            AverageY = sum(Aux1DY(1:nP)) / real(nP)

                            if (nP > 1) then
                                Stdv = 0.
                                do n = 1, nP
                                    Stdv = Stdv + ((Aux1DY(n) - AverageX)**2. +      &
                                                   (Aux1DY(n) - AverageY)**2.) / (real(nP) - 1)
                        
                                enddo
                                RadiusOfInfluence = Me%CoefRadius * sqrt(Stdv)
                            else
                                RadiusOfInfluence = 0.
                            endif

                        else
                            AverageX          = FillValueReal
                            AverageY          = FillValueReal
                            RadiusOfInfluence = FillValueReal
                        endif                         
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, TotParticle(ig), STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR450'
                        

                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em),  "/Results/"//trim(GroupName)//"/googlemaps_x",&
                                            "googlemaps_x",  "-", Array1D = Aux1DX,                     &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR460'

                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em),  "/Results/"//trim(GroupName)//"/googlemaps_y",&
                                            "googlemaps_y",  "-", Array1D = Aux1DY,                     &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR470'

                        if (Me%OutPut%OriginEnvelope) then
                            call WriteOriginEnvelope(GroupName, Aux1DX, Aux1DY,         &
                                                     "googlemaps_x", "googlemaps_y",    &
                                                     "-", OutputNumber, em)  
                        endif  

                        deallocate(Aux1DX, Aux1DY)
                        
                        allocate  (Aux1DX(1), Aux1DY(1))
                        
                        Aux1DX(1) = AverageX
                        Aux1DY(1) = AverageY
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR480'

                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(GroupName)//"/googlemaps_x_average", &
                                            "googlemaps_x_average",  "-", Array1D = Aux1DX,                      &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR490'

                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(GroupName)//"/googlemaps_y_average", &
                                            "googlemaps_y_average",  "-", Array1D = Aux1DY,                       &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR500'


                        deallocate   (Aux1DX)
                        deallocate   (Aux1DY)    
#endif 

                        deallocate   (Matrix1DX)
                        deallocate   (Matrix1DY)
                        
                        allocate     (Matrix1D(TotParticle(ig)))
                        
                        Matrix1D(:)  = FillValueReal


                        !(ZPosition)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    ZPos:               do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    Matrix1D(nP)  = CurrentPartic%Position%Z
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo
                            endif
                                        
                            CurrentOrigin => CurrentOrigin%Next
                        enddo ZPos
                        
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, TotParticle(ig), STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR510'

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Z Pos",   &
                                                   "Z Position",                             &
                                                   "m",                                      &
                                                   Array1D = Matrix1D,                       &
                                                   OutputNumber = OutPutNumber,              &
                                                   STAT = STAT_CALL)
                        
                        


                        !(ZPosition for Vertical cut)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    ZPosInv:            do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    emp = CurrentPartic%Position%ModelID
                                    Matrix1D(nP)  = MaximumDepth(emp) - CurrentPartic%Position%Z
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo ZPosInv


                        !(Volume)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    Volume:             do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    Matrix1D(nP)  = CurrentPartic%Geometry%Volume
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo Volume

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Volume",  &
                                                   "Volume",                                 &
                                                   "m3",                                     &
                                                   Array1D = Matrix1D,                       &
                                                   OutputNumber = OutPutNumber,              &
                                                   STAT = STAT_CALL)

                        !(OriginNumber)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    Origin:             do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    Matrix1D(nP)  = CurrentOrigin%ID
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo Origin


                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                      &
                                                   "/Results/"//trim(GroupName)//"/Origin ID",&
                                                   "Origin ID",                         &
                                                   "-",                                 &
                                                   Array1D = Matrix1D,                  &
                                                   OutputNumber = OutPutNumber,         &
                                                   STAT = STAT_CALL)
                                                   
                        !ParticNumber)
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
    Partic:             do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    Matrix1D(nP)  = CurrentPartic%ID
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo Partic


                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                      &
                                                   "/Results/"//trim(GroupName)//"/Partic ID",&
                                                   "Partic ID",                         &
                                                   "-",                                 &
                                                   Array1D = Matrix1D,                  &
                                                   OutputNumber = OutPutNumber,         &
                                                   STAT = STAT_CALL)
                                                   
                        !Model ID
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
ModelID:                do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))
                                    Matrix1D(nP)  = CurrentPartic%Position%ModelID
                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo ModelID


                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Model ID",&
                                                   "Model ID",                               &
                                                   "-",                                      &
                                                   Array1D = Matrix1D,                       &
                                                   OutputNumber = OutPutNumber,              &
                                                   STAT = STAT_CALL)

                        !Surface State
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
SurfaceState:           do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))

                                    if (CurrentPartic%Position%Surface) then 

                                        ParticSurface  = 1

                                    else

                                        ParticSurface  = 2

                                    end if

                                    Matrix1D(nP) = ParticSurface

                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo SurfaceState


                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Surface State",&
                                                   "Surface State",                               &
                                                   "ON/OFF",                                      &
                                                   Array1D = Matrix1D,                            &
                                                   OutputNumber = OutPutNumber,                   &
                                                   STAT = STAT_CALL)

                        !Particle State
                        nP = 1
                        CurrentOrigin => Me%FirstOrigin
ParticleState:          do while (associated(CurrentOrigin))

                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                CurrentPartic   => CurrentOrigin%FirstPartic
                                do while (associated(CurrentPartic))

                                    Matrix1D(nP) = CurrentPartic%ParticleState

                                    CurrentPartic => CurrentPartic%Next
                                    nP = nP + 1
                                enddo            
                            endif
                
                            CurrentOrigin => CurrentOrigin%Next
                        enddo ParticleState


                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                   "/Results/"//trim(GroupName)//"/Particle State",&
                                                   "Particle State",                               &
                                                   "-",                                            &
                                                   Array1D = Matrix1D,                             &
                                                   OutputNumber = OutPutNumber,                    &
                                                   STAT = STAT_CALL)

                        !(Oil-Beached Particles)
iobp:                   if (Me%State%AssociateBeachProb .or. Me%LitterON) then

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    TryOrigin:              do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
    IfBeaching:                     if (CurrentOrigin%Beaching  .or. Me%LitterON) then
                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))

                                            if (.NOT. CurrentPartic%Beached) then 
                                                ParticleBeached = 1
                                            else
                                                ParticleBeached = 2
                                            end if

                                            Matrix1D(nP)  = ParticleBeached
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                    end if IfBeaching
                               endif
                               CurrentOrigin => CurrentOrigin%Next
                            enddo TryOrigin


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                           &
                                                       "/Results/"//trim(GroupName)//"/Beached", &
                                                       "Beached",                                &
                                                       "-",                                      &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)


                        end if iobp


                        !(Deposited Particles)
idp:                    if (Me%State%Deposition) then

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    DepState:               do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    if (CurrentOrigin%State%Deposition) then

                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))

                                            if (CurrentPartic%Deposited) then 
                                                Matrix1D(nP)  = 1
                                            else
                                                Matrix1D(nP) = 2
                                            end if

                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                            
                                    endif

                                endif
                
                                CurrentOrigin => CurrentOrigin%Next

                            enddo DepState


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                    &
                                                       "/Results/"//trim(GroupName)//"/Deposition State", &
                                                       "Origin ID",                              &
                                                       "-",                                      &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)


                        end if idp

                        !T90
    iT90:               if (Me%State%T90Variable) then

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    dT90:                   do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    CurrentProperty => CurrentOrigin%FirstProperty
                                    do while (associated(CurrentProperty))

                                        if (CurrentProperty%ID == Fecal_Coliforms_ .or.CurrentProperty%ID == E_Coli_) then

                                            CurrentPartic   => CurrentOrigin%FirstPartic

                                            do while (associated(CurrentPartic))
                                                !T90 in hours
                                                Matrix1D(nP)  = CurrentPartic%T90 / 3600.

                                                CurrentPartic => CurrentPartic%Next
                                                nP = nP + 1
                                            enddo            
                                            exit
                                        endif

                                        CurrentProperty => CurrentProperty%Next
                                   
                                    enddo


                                endif
                            
                                CurrentOrigin => CurrentOrigin%Next

                            enddo dT90

                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                               &
                                                       "/Results/"//trim(GroupName)//"/T90-Fecal coli.",&
                                                       "T90",                                    &
                                                       "-",                                      &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)


                    
                        endif iT90



                        !Age
                        if (Me%State%Age) then

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    Age:                    do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    if (CurrentOrigin%State%Age) then

                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))

                                            Matrix1D(nP)  =  CurrentPartic%Age / 86400.
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                            
                                    endif

                                endif
                
                                CurrentOrigin => CurrentOrigin%Next
                            enddo Age


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                           &
                                                       "/Results/"//trim(GroupName)//"/Age",     &
                                                       "Age",                                    &
                                                       "days",                                   &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)


                        end if
                        
                        !Oil thickness
                        if (Me%State%Oil) then

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
thick:                      do while (associated(CurrentOrigin))
                            
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then                        
                        
                                    if (CurrentOrigin%State%Oil) then

                                        !oil Thickness 
                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))

                                            if (CurrentOrigin%AreaMethod == VoronoiArea_) then
                                                Matrix1D(nP)  = CurrentPartic%Geometry%Thickness 
                                            else 
                                                emp = CurrentPartic%Position%ModelID
                                                
                                                Matrix1D(nP)  = InterpolXYPoint                                            &
                                                    (HorizontalGridID = Me%EulerModel(emp)%ObjHorizontalGrid,              &
                                                     Field2DFather    = Me%EulerModel(emp)%OilSpreading(ig)%GridThickness, &
                                                     ComputeFather    = Me%EulerModel(emp)%WaterPoints2D,                  &
                                                     XInput           = CurrentPartic%Position%CoordX,                     &
                                                     YInput           = CurrentPartic%Position%CoordY,                     &
                                                     STAT             = STAT_CALL)
                                                if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR520'
                                                
                                                CurrentPartic%Geometry%Thickness = Matrix1D(nP)
                                            endif
                                                
                                            Matrix1D(nP)  =  Matrix1D(nP) * 1e6 * (1 - Me%ExternalVar%VWaterContent)
                                            
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo  
                                        nullify(CurrentPartic)
                                    endif
                                endif      
                                CurrentOrigin => CurrentOrigin%Next                              
                            enddo thick
                                      
                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                           &
                                                       "/Results/"//trim(GroupName)//"/Thickness",&
                                                       "Thickness",                              &
                                                       "micro m",                                &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)


                        endif                              
                        
                        !density
                        if (Me%State%FarFieldBuoyancy) then

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    dens:                   do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    if (CurrentOrigin%State%FarFieldBuoyancy) then

                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))

                                            Matrix1D(nP)  =  CurrentPartic%SigmaDensity
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                            
                                    endif

                                endif
                
                                CurrentOrigin => CurrentOrigin%Next
                            enddo dens


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                           &
                                                       "/Results/"//trim(GroupName)//"/density", &
                                                       "density",                                &
                                                       "sigma density kg/m^3",                   &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)


                        end if
                        
                        !D50
                        if (Me%State%D50) then                       
                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    d50Vel:                 do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    if (CurrentOrigin%State%D50) then

                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))
                                            !From m/s -> mm/s
                                            Matrix1D(nP)  =  CurrentPartic%D50Vel * 1000.
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                            
                                    endif

                                endif
                
                                CurrentOrigin => CurrentOrigin%Next
                            enddo D50Vel


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                           &
                                                       "/Results/"//trim(GroupName)//"/D50 Vel.",&
                                                       "D50 Vel.",                               &
                                                       "mm/s",                                   &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)
                            
                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    d50:                    do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    if (CurrentOrigin%State%D50) then

                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))
                                            !From m -> mm
                                            Matrix1D(nP)  =  CurrentPartic%D50 * 1000.
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                            
                                    endif

                                endif
                
                                CurrentOrigin => CurrentOrigin%Next
                            enddo D50


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                           &
                                                       "/Results/"//trim(GroupName)//"/D50",     &
                                                       "D50",                                   &
                                                       "mm",                                    &
                                                       Array1D = Matrix1D,                       &
                                                       OutputNumber = OutPutNumber,              &
                                                       STAT = STAT_CALL)                            
                            
                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
    dTau:                   do while (associated(CurrentOrigin))
                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                                    if (CurrentOrigin%State%D50) then

                                        CurrentPartic   => CurrentOrigin%FirstPartic
                                        do while (associated(CurrentPartic))
                                            !From m -> mm
                                            Matrix1D(nP)  =  CurrentPartic%TauErosionMix
                                            CurrentPartic => CurrentPartic%Next
                                            nP = nP + 1
                                        enddo
                                            
                                    endif

                                endif
                
                                CurrentOrigin => CurrentOrigin%Next
                            enddo DTau


                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       "/Results/"//trim(GroupName)//"/Tau Erosion Mix",     &
                                                       "Tau Erosion Mix",               &
                                                       "Pa",                            &
                                                       Array1D = Matrix1D,              &
                                                       OutputNumber = OutPutNumber,     &
                                                       STAT = STAT_CALL)                            
                            
                        endif

                        !(Properties)
                        !Just if in all origins are the same amount of properties and in the same
                        !order, writes the properties.
                        CurrentOrigin => Me%FirstOrigin 
    DoCatch:            do while (associated(CurrentOrigin))
                            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                FirstProperty   => CurrentOrigin%FirstProperty
                                nGroupProp      =  CurrentOrigin%nProperties
                                exit DoCatch
                            endif
                            CurrentOrigin => CurrentOrigin%Next
                        enddo DoCatch


                        nProp = 1
                        do while (nProp <= nGroupProp)

                            !Point to the right instant
                            CurrentProperty => FirstProperty
                            do iProp = 1, nProp-1
                                CurrentProperty => CurrentProperty%Next
                            enddo

                            nP = 1
                            CurrentOrigin => Me%FirstOrigin
                            do while (associated(CurrentOrigin))

                                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                                    CurrentPartic     => CurrentOrigin%FirstPartic
                                    do while (associated(CurrentPartic))
                                        Matrix1D(nP)  = CurrentPartic%Concentration(nProp)
                                        CurrentPartic => CurrentPartic%Next
                                        nP = nP + 1
                                    enddo            
                                endif
            
                                CurrentOrigin => CurrentOrigin%Next
                            enddo      

                            !HDF 5
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       "/Results/"//trim(GroupName)//"/"//&
                                                       trim(CurrentProperty%Name),      &
                                                       trim(CurrentProperty%Name),      &
                                                       trim(CurrentProperty%Units),     &
                                                       Array1D = Matrix1D,              &
                                                       OutputNumber = OutPutNumber,     &
                                                       STAT = STAT_CALL)

                            nProp = nProp + 1

                        enddo
                        
                       if (Me%State%VariableGeom) then
                            call HDF5WriteAllGroupParticAmbientConc(GroupName, ig, em, OutPutNumber,Matrix1D)
                        endif                                      


                        deallocate  (Matrix1D)

                    enddo dig
                
                    if (Me%State%Monitor) then
                        call WriteMonitorOutput (OutputNumber)
                    endif


                    !Flushes All pending HDF5 commands
                    call HDF5FlushMemory (Me%ObjHDF5(em), ErrorMessage =                &
                                         'ParticleOutput - ModuleLagrangianGlobal - ERR400', STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'ParticleOutput - ModuleLagrangianGlobal - ERR970'
                    
                    deallocate(TotParticle)


                enddo de


                !Increments Output number
                Me%OutPut%NextOutPut = Me%OutPut%NextOutPut + 1

                !Verifies if all outputs are done (necessary for partic DT smaller then global DT)
                if (Me%OutPut%NextOutPut > size(Me%OutPut%OutTime)) then
                    Me%Output%Write_ = .false.
                endif

                deallocate(MaximumDepth)

            endif  TOut
        endif


    end subroutine ParticleOutput

    !--------------------------------------------------------------------------

    subroutine HDF5WriteParticAmbientConc(CurrentOrigin, em, OutPutNumber,Matrix1D)    

        !Arguments------------------------------------------------------------------    
        type(T_Origin),                              pointer :: CurrentOrigin
        integer                                              :: em, OutPutNumber 
        real(8),                      dimension (:), pointer :: Matrix1D
        !Local----------------------------------------------------------------------                    
        type (T_Partic)                            , pointer :: CurrentPartic
        type (T_Property)                          , pointer :: CurrentProperty
        integer                                              :: nProp, nP, STAT_CALL
        
        !Begin----------------------------------------------------------------------    
    
        !Properties
        nProp =  1
        CurrentProperty => CurrentOrigin%FirstProperty
        do while (associated(CurrentProperty))

            CurrentPartic => CurrentOrigin%FirstPartic
            nP = 0
            do while (associated(CurrentPartic))
                nP = nP + 1
                Matrix1D(nP)  =  CurrentPartic%AmbientConc(nProp)
                CurrentPartic => CurrentPartic%Next
            enddo            
            if (nP > 0) then
                !HDF 5
                call HDF5WriteData  (Me%ObjHDF5(em),                  &
                                        "/Results/"//trim(CurrentOrigin%Name)//"/Background/" &
                                        //trim(CurrentProperty%Name),        &
                                        trim(CurrentProperty%Name),             &
                                        trim(CurrentProperty%Units),            &
                                        Array1D = Matrix1D,                     &
                                        OutputNumber = OutPutNumber,            &
                                        STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteParticAmbientConc - ModuleLagrangianGlobal - ERR10'
            endif
            nProp = nProp + 1
            CurrentProperty => CurrentProperty%Next
        enddo    
        
        nullify(CurrentPartic  )
        nullify(CurrentProperty)
                        
    end subroutine HDF5WriteParticAmbientConc
    
    !--------------------------------------------------------------------------    
    
    subroutine HDF5WriteAllGroupParticAmbientConc(GroupName, ig, em, OutPutNumber,Matrix1D)    
        !Arguments------------------------------------------------------------------    
        character(len=*)                                     :: GroupName
        integer                                              :: ig, em, OutPutNumber 
        real(8),                      dimension (:), pointer :: Matrix1D
        !Local----------------------------------------------------------------------                    
        type(T_Origin),                              pointer :: CurrentOrigin
        type (T_Partic)                            , pointer :: CurrentPartic
        type (T_Property)                          , pointer :: CurrentProperty, FirstProperty
        integer                                              :: nProp, nP, STAT_CALL
        integer                                              :: nGroupProp, iProp
        
        !Begin----------------------------------------------------------------------    

    
        !(Properties)
        !Just if in all origins are the same amount of properties and in the same
        !order, writes the properties.
        CurrentOrigin => Me%FirstOrigin 
DoCatch: do while (associated(CurrentOrigin))
            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                FirstProperty   => CurrentOrigin%FirstProperty
                nGroupProp      =  CurrentOrigin%nProperties
                exit DoCatch
            endif
            CurrentOrigin => CurrentOrigin%Next
        enddo DoCatch


        nProp = 1
        do while (nProp <= nGroupProp)

            !Point to the right instant
            CurrentProperty => FirstProperty
            do iProp = 1, nProp-1
                CurrentProperty => CurrentProperty%Next
            enddo

            nP = 1
            CurrentOrigin => Me%FirstOrigin
            do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then
                    CurrentPartic     => CurrentOrigin%FirstPartic
                    do while (associated(CurrentPartic))
                        Matrix1D(nP)  = CurrentPartic%AmbientConc(nProp)
                        CurrentPartic => CurrentPartic%Next
                        nP = nP + 1
                    enddo            
                endif
            
                CurrentOrigin => CurrentOrigin%Next
            enddo      

            !HDF 5
            call HDF5WriteData        (Me%ObjHDF5(em),                                  &
                                        "/Results/"//trim(GroupName)//                  &
                                        "/BackGround/"//                                &
                                        trim(CurrentProperty%Name),                     &
                                        trim(CurrentProperty%Name),                     &
                                        trim(CurrentProperty%Units),                    &
                                        Array1D = Matrix1D,                             &
                                        OutputNumber = OutPutNumber,                    &
                                        STAT = STAT_CALL)

            nProp = nProp + 1

        enddo
        
        nullify(CurrentOrigin,   CurrentPartic)
        nullify(CurrentProperty, FirstProperty)

    end subroutine HDF5WriteAllGroupParticAmbientConc
    
    !--------------------------------------------------------------------------
    
#ifndef _NO_NETCDF     
    
    subroutine Open1DNetCDFFile    (CurrentOrigin, CurrentTime)  
    
        !Arguments------------------------------------------------------------------    
        type(T_Origin),                  pointer    :: CurrentOrigin
        type(T_Time)                                :: CurrentTime
                                                
        !Local----------------------------------------------------------------------   
        character(len = PathLength)                 :: FileName
        integer                                     :: NCDF_CREATE, STAT_CALL


        !Begin----------------------------------------------------------------------    
        
        

    
        call GetNCDFFileAccess(NCDF_CREATE = NCDF_CREATE)
        
        Me%Output%ObjNetCDF = 0
        
        FileName = trim(adjustl(Me%OutPut%RootPath))//trim(CurrentOrigin%Name)//"_"//   &
                   trim(ConvertTimeToString(CurrentTime, "_"))//".nc"
        
        call ConstructNETCDF(Me%Output%ObjNetCDF, FileName, NCDF_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open1DNetCDFFile - ModuleLagrangianGlobal - ERR10'
        
        call NETCDFWriteHeader (NCDFID              = Me%Output%ObjNetCDF,                                  &
                                Title               = "Output MOHID Lagrangian Global",                     &
                                Convention          = "CF-1.0",                                             &
                                Version             = "4.4.1.1" ,                                           &
                                History             = "Output develop for the AquaSafe Oil Spill Simulator",&
                                iDate               =  2020,                                                &
                                Source              = "Software/MOHIDWater/ModuleLagrangianGlobal.F90",     &
                                Institution         = "HIDROMOD",                                           &
                                References          = "https://github.com/Mohid-Water-Modelling-System",    &
                                geospatial_lat_min  = -90.,                                                 & 
                                geospatial_lat_max  = +90.,                                                 &
                                geospatial_lon_min  = -360.,                                                &           
                                geospatial_lon_max  = +360.,                                                &
                                STAT                = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Open1DNetCDFFile - ModuleLagrangianGlobal - ERR20'
    
    end subroutine Open1DNetCDFFile

    !--------------------------------------------------------------------------    
                                
    subroutine SetDims1DNetCDFFile (DimName, DimN, Dim1DID)
    
        !Arguments------------------------------------------------------------------    
        character(len=*),   intent(IN)              :: DimName
        integer,            intent(IN)              :: DimN
        integer,            intent(OUT)             :: Dim1DID

        !Local----------------------------------------------------------------------                    
        integer                                     :: STAT_CALL        
        !Begin----------------------------------------------------------------------     
        
        call NETCDFSet1D_Dimension (NCDFID      = Me%Output%ObjNetCDF,                  &
                                    IUB         = DimN,                                 &
                                    DimName     = DimName,                              & 
                                    Dim1DID     = Dim1DID,                              &
                                    STAT        = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'SetDims1DNetCDFFile - ModuleLagrangianGlobal - ERR10'

    
    end subroutine SetDims1DNetCDFFile
    
    !--------------------------------------------------------------------------    
    
    subroutine Write1DNetCDFFile   (PropName, Array1D, Units, DimID)  
    
        !Arguments------------------------------------------------------------------    
        character(len=*)                            :: PropName, Units
        real,       dimension(:),  pointer          :: Array1D
        integer                                     :: DimID


        !Local----------------------------------------------------------------------                    
        integer                                     :: STAT_CALL        
        !Begin----------------------------------------------------------------------   

        
        call NETCDFWriteData(NCDFID         = Me%Output%ObjNetCDF,                      &
                             Name           = PropName,                                 & 
                             Units          = Units,                                    &
                             Array1D        = Array1D,                                  & 
                             DimID          = DimID,                                    &
                             STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write1DNetCDFFile - ModuleLagrangianGlobal - ERR10'
        
        
    
    end subroutine Write1DNetCDFFile
    
#endif    
    
    !--------------------------------------------------------------------------

    subroutine HDF5WriteDataBottomStress(CurrentOrigin, em, OutPutNumber)
    
        !Arguments------------------------------------------------------------------    
        type(T_Origin),                              pointer :: CurrentOrigin
        integer                                              :: em, OutPutNumber 

        !Local----------------------------------------------------------------------                    
        type (T_Partic)                            , pointer :: CurrentPartic
        real,                         dimension (:), pointer :: Matrix1D
        character (len = StringLength)                       :: Name, Units
        integer                                              :: nP, STAT_CALL
        
        !Begin----------------------------------------------------------------------    

        
        
        !bottom shear stress
        
        allocate(Matrix1D  (CurrentOrigin%nParticle))
        
        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D  (nP) =  CurrentPartic%BottomStress
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "Bottom Stress"
            Units ="Pa"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR10'

        endif

        deallocate(Matrix1D)
        
    end subroutine HDF5WriteDataBottomStress        
    
    !--------------------------------------------------------------------------
    subroutine HDF5WriteDataMeteoOcean(CurrentOrigin, em, OutPutNumber)
    
        !Arguments------------------------------------------------------------------    
        type(T_Origin),                              pointer :: CurrentOrigin
        integer                                              :: em, OutPutNumber 

        !Local----------------------------------------------------------------------                    
        type (T_Partic)                            , pointer :: CurrentPartic
        real,                         dimension (:), pointer :: Matrix1D
        integer,                      dimension (:), pointer :: Solution1D        
        character (len = StringLength)                       :: Name, Units
        integer                                              :: nP, STAT_CALL
        
        !Begin----------------------------------------------------------------------    

        
        
        !meteo ocean physical properties
        
        allocate(Matrix1D  (CurrentOrigin%nParticle))
        allocate(Solution1D(CurrentOrigin%nParticle))        
        
        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D  (nP)  =  CurrentPartic%CurrentX
            Solution1D(nP)  =  CurrentPartic%SolutionCX
            CurrentPartic => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "velocity U"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR10'

            Name = "velocity U Solution"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR20'
        endif
        
        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%CurrentY
            Solution1D(nP) =  CurrentPartic%SolutionCY
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "velocity V"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR30'
            
            Name = "velocity V Solution"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR40'            
        endif

        
        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%CurrentZ
            Solution1D(nP) =  CurrentPartic%SolutionCZ
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "velocity W"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR50'
            
            Name = "velocity W Solution"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR60'            
        endif

        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%WindX
            Solution1D(nP) =  CurrentPartic%SolutionWX
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "wind velocity X"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR70'
            
            Name = "wind velocity X Solution"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR80'      
                        
        endif

        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%WindY
            Solution1D(nP) =  CurrentPartic%SolutionWY
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "wind velocity Y"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR90'
            
            Name = "wind velocity Y Solution"
            Units ="m/s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR100'             
        endif

        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%WaveHeight
            Solution1D(nP) =  CurrentPartic%SolutionWH
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "wave height"
            Units ="m"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR110'

            Name = "wave height Solution"
            Units ="m"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR120'
        endif

        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%WavePeriod
            Solution1D(nP) =  CurrentPartic%SolutionWP
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "wave period"
            Units ="s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR130'
            

            Name = "wave period Solution"
            Units ="s"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR140'
            
        endif
        
        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%WaveDirection
            Solution1D(nP) =  CurrentPartic%SolutionWD
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "wave direction"
            Units ="degree"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR150'
            
            Name = "wave direction Solution"
            Units ="degree"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR160'
            
        endif
        
        CurrentPartic => CurrentOrigin%FirstPartic
        nP = 0
        do while (associated(CurrentPartic))
            nP = nP + 1
            Matrix1D(nP)   =  CurrentPartic%WaveLength
            Solution1D(nP) =  CurrentPartic%SolutionWL
            CurrentPartic  => CurrentPartic%Next
        enddo            
        if (nP > 0) then
            !HDF 5
            Name = "wave length"
            Units ="m"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Matrix1D,                                    &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR170'

            Name = "wave length Solution"
            Units ="m"
            call HDF5WriteData  (Me%ObjHDF5(em),                                        &
                                 "/Results/"//trim(CurrentOrigin%Name)//                &
                                 "/"//trim(Name),                                       &
                                 trim(Name),                                            &
                                 trim(Units),                                           &
                                 Array1D = Solution1D,                                  &
                                 OutputNumber = OutPutNumber,                           &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'HDF5WriteDataMeteoOcean - ModuleLagrangianGlobal - ERR180'
        endif

        deallocate(Matrix1D  )
        deallocate(Solution1D)
        
    end subroutine HDF5WriteDataMeteoOcean

!--------------------------------------------------------------------------

    subroutine DummyParticleStartDate(em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber
        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        real(8), dimension(:), pointer              :: Matrix1D, Matrix1DX, Matrix1DY
        integer                                     :: STAT_CALL
        real, dimension(6), target                  :: AuxTime
        real, dimension(:), pointer                 :: TimePtr
        real(8)                                     :: AverageX, AverageY, RadiusOfInfluence
        
        !Begin--------------------------------------------------------------------------


        !Writes the Instant - HDF 5
        call ExtractDate   (Me%Now, AuxTime(1), AuxTime(2), AuxTime(3),                 &
                            AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime
        call HDF5SetLimits  (Me%ObjHDF5(em), 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR10'

        call HDF5WriteData  (Me%ObjHDF5(em), "/Time", "Time", "YYYY/MM/DD HH:MM:SS",        &
                             Array1D = TimePtr, OutputNumber = OutputNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR20'


        !Writes Data for every origin
        CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

            allocate   (Matrix1DX(1))
            allocate   (Matrix1DY(1))

            call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR30'


          !GeoGraphic Position

            !Longitude, Latitude
            Matrix1DX(1)  =  CurrentOrigin%Position%CoordX
            Matrix1DY(1)  =  CurrentOrigin%Position%CoordY

            if (Me%AveragePositionON) then
                AverageX = CurrentOrigin%Position%CoordX
                AverageY = CurrentOrigin%Position%CoordY
                RadiusOfInfluence = 0.
            else
                AverageX          = FillValueReal
                AverageY          = FillValueReal
                RadiusOfInfluence = FillValueReal
            endif 


            call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR40'


            !HDF 5
            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Longitude", &
                                "Longitude",  "º", Array1D = Matrix1DX,                 &
                                 Average = AverageX, Radius = RadiusOfInfluence,        &
                                 OutputNumber = OutputNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR50'

            !HDF 5
            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Latitude", &
                                "Latitude",  "º", Array1D = Matrix1DY,                  &
                                 Average = AverageY, Radius = RadiusOfInfluence,        &
                                 OutputNumber = OutputNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR60'

            if (Me%OutPut%OriginEnvelope) then
                call WriteOriginEnvelope(CurrentOrigin%Name, Matrix1DX, Matrix1DY,      &
                                          "Longitude", "Latitude", "º", OutputNumber, em)  
            endif


            if (Me%AveragePositionON) then
            
                call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR70'

                Matrix1DX(1) = AverageX
                Matrix1DY(1) = AverageY
                
                !HDF 5
                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Longitude average", &
                                    "Longitude",  "º", Array1D = Matrix1DX,                                       &
                                     OutputNumber = OutputNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR80'
                !HDF 5
                call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Latitude average", &
                                    "Latitude",  "º", Array1D = Matrix1DY,                                       &
                                     OutputNumber = OutputNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR90'
            
             endif                            

            deallocate   (Matrix1DX)
            deallocate   (Matrix1DY)

            allocate    (Matrix1D(1))
            Matrix1D(:) = 0.

            call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR100'


         !HDF 5
            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Z Pos", &
                                "Z Position",  "m", Array1D = Matrix1D, OutputNumber = OutputNumber,    &
                                 STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR110'

            deallocate  (Matrix1D)


            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

        !Flushes All pending HDF5 commands
        call HDF5FlushMemory (Me%ObjHDF5(em), ErrorMessage =                            &
                             'DummyParticleStartDate - ModuleLagrangianGlobal - ERR130', STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'DummyParticleStartDate - ModuleLagrangianGlobal - ERR120'



    end subroutine DummyParticleStartDate

    !--------------------------------------------------------------------------

!--------------------------------------------------------------------------


    subroutine WriteRunOnline(em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber
        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic
        real(8), dimension(:), pointer              :: Matrix1D, Matrix1DX, Matrix1DY, MX1D, MY1D
        integer                                     :: STAT_CALL
        real, dimension(6), target                  :: AuxTime
        real, dimension(:), pointer                 :: TimePtr
        real(8)                                     :: AverageX, AverageY, Stdv, RadiusOfInfluence
        integer                                     :: nP, n

        
        !Begin--------------------------------------------------------------------------


        !Writes the Instant - HDF 5
        call ExtractDate   (Me%Now, AuxTime(1), AuxTime(2), AuxTime(3),                 &
                            AuxTime(4), AuxTime(5), AuxTime(6))
        TimePtr => AuxTime
        call HDF5SetLimits  (Me%ObjHDF5(em), 1, 6, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR10'

        call HDF5WriteData  (Me%ObjHDF5(em), "/Time", "Time", "YYYY/MM/DD HH:MM:SS",        &
                             Array1D = TimePtr, OutputNumber = OutputNumber, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR20'


        !Writes Data for every origin
        CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                allocate   (Matrix1DX(CurrentOrigin%nParticle))
                allocate   (Matrix1DY(CurrentOrigin%nParticle))
                Matrix1DX(:) = FillValueReal
                Matrix1DY(:) = FillValueReal

                call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR30'


              !GeoGraphic Position

                !Longitude, Latitude
                CurrentPartic   => CurrentOrigin%FirstPartic
                nP = 0
                do while (associated(CurrentPartic))
                    nP = nP + 1
                    Matrix1DX(nP)  =  GeographicCoordinates (CurrentPartic%Position%ModelID, CurrentPartic%Position, 1)
                    Matrix1DY(nP)  =  GeographicCoordinates (CurrentPartic%Position%ModelID, CurrentPartic%Position, 2)
                    CurrentPartic => CurrentPartic%Next
                enddo

                if (nP > 0) then

                    if (Me%AveragePositionON) then
                        AverageX = sum(Matrix1DX(1:nP)) / real(nP)
                        AverageY = sum(Matrix1DY(1:nP)) / real(nP)

                        if (nP > 1) then
                            Stdv = 0.
                            do n = 1, nP
                                Stdv = Stdv + ((Matrix1DX(n) - AverageX)**2. +      &
                                               (Matrix1DY(n) - AverageY)**2.) / (real(nP) - 1)
                    
                            enddo
                            RadiusOfInfluence = Me%CoefRadius * sqrt(Stdv)
                        else
                            RadiusOfInfluence = 0.
                        endif

                    else
                        AverageX          = FillValueReal
                        AverageY          = FillValueReal
                        RadiusOfInfluence = FillValueReal
                    endif 


                    call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR40'


                    !HDF 5
                    call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Longitude", &
                                        "Longitude",  "º", Array1D = Matrix1DX,                      &
                                         Average = AverageX, Radius = RadiusOfInfluence,             &
                                         OutputNumber = OutputNumber, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR50'

                    !HDF 5
                    call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Latitude", &
                                        "Latitude",  "º", Array1D = Matrix1DY,                       &
                                         Average = AverageY, Radius = RadiusOfInfluence,             &
                                         OutputNumber = OutputNumber, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR60'

                    if (Me%OutPut%OriginEnvelope) then
                        call WriteOriginEnvelope(CurrentOrigin%Name, Matrix1DX, Matrix1DY, &
                                                  "Longitude", "Latitude", "º", OutputNumber, em)  
                    endif
                    
                    if (Me%AveragePositionON) then
                    
                        allocate   (MX1D(1))
                        allocate   (MY1D(1))                                
                    
                        MX1D(1) = AverageX
                        MY1D(1) = AverageY
                        
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, 1, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR70'
                        
                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Longitude average", &
                                            "Longitude",  "º", Array1D = MX1D,                          &
                                             OutputNumber = OutputNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR80'
                        !HDF 5
                        call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Latitude average", &
                                            "Latitude",  "º", Array1D = MY1D,                           &
                                             OutputNumber = OutputNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR90'
                    
                        call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR100'
                        
                        deallocate   (MX1D)
                        deallocate   (MY1D)

                    endif
                    

        
                endif

                deallocate   (Matrix1DX)
                deallocate   (Matrix1DY)


                allocate    (Matrix1D(CurrentOrigin%nParticle))
                Matrix1D(:) = FillValueReal


                call HDF5SetLimits  (Me%ObjHDF5(em), 1, CurrentOrigin%nParticle, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR70'


                !Real ZPosition
                CurrentPartic   => CurrentOrigin%FirstPartic
                nP = 0
                do while (associated(CurrentPartic))
                    nP = nP + 1
                    Matrix1D(nP)  =  CurrentPartic%Position%Z
                    CurrentPartic => CurrentPartic%Next
                enddo            
                if (nP > 0) then
                    !HDF 5
                    call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(CurrentOrigin%Name)//"/Z Pos", &
                                        "Z Position",  "m", Array1D = Matrix1D, OutputNumber = OutputNumber,    &
                                         STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR80'
                        endif

            deallocate  (Matrix1D)


            CurrentOrigin => CurrentOrigin%Next

        enddo CurrOr

        !Flushes All pending HDF5 commands
        call HDF5FlushMemory (Me%ObjHDF5(em),  ErrorMessage = 'WriteRunOnline - ModuleLagrangianGlobal - ERR90', STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'WriteRunOnline - ModuleLagrangianGlobal - ERR90'



    end subroutine WriteRunOnline

    !--------------------------------------------------------------------------

    subroutine WriteOriginEnvelope(OriginName, Matrix1DX, Matrix1DY,                    &
                                   StringX, StringY, Units, OutputNumber, em,           &
                                   OutPutNetCDF)

        !Arguments------------------------------------------------------------
        character(Len=*)                    :: OriginName
        real(8),   dimension(:), pointer    :: Matrix1DX, Matrix1DY
        character(Len=*)                    :: StringX, StringY, Units
        integer                             :: OutputNumber, em
        logical, optional                   :: OutPutNetCDF

        !Local-----------------------------------------------------------------
        real,      dimension(:), pointer    :: NodeX, NodeY
        real(8),   dimension(:), pointer    :: Envelope1DX, Envelope1DY
        integer,   dimension(:), pointer    :: BoundaryNodes
        character(Len=StringLength)         :: StringXaux, StringYaux
        real(8)                             :: AverageX, AverageY, MaxX, MaxY, rand, AuxX, AuxY
        integer                             :: ObjTriangulation, NumberOfBoundaryNodes
        integer                             :: STAT_CALL, NumberOfNodes, i, j
        logical                             :: Coincident
        logical                             :: OutPutNetCDF_
        integer                             :: Dim1D_e
        !Begin-----------------------------------------------------------------

        StringXaux = trim(StringX)//' envelope'
        StringYaux = trim(StringY)//' envelope'

        NumberOfNodes = Size(Matrix1DX)
        
        !check if are not coincident points
        Coincident = .false.
        do i=1, NumberOfNodes-1
            if (Matrix1DX(i)==Matrix1DX(i+1) .and. Matrix1DY(i)==Matrix1DY(i+1)) then
                Coincident = .true. 
                exit
            endif
        enddo
        
        if (Coincident) NumberOfNodes = 1

        if (NumberOfNodes >= 3) then

            allocate(NodeX(1:NumberOfNodes), NodeY(1:NumberOfNodes))

            AverageX =sum(Matrix1DX) / real(NumberOfNodes)
            AverageY =sum(Matrix1DY) / real(NumberOfNodes)
            
            do i=1, NumberOfNodes
                AuxX = Matrix1DX(i) - AverageX                    
                NodeX(i) = AuxX
            enddo

            do i=1, NumberOfNodes
                AuxY = Matrix1DY(i) - AverageY                    
                NodeY(i) = AuxY
            enddo            
           

            MaxX = maxval(NodeX)
            MaxY = maxval(NodeY)
            MaxX = MaxX/1e5
            MaxY = MaxY/1e5
            do i=1,NumberOfNodes
                call RANDOM_NUMBER(rand)
                NodeX(i) = NodeX(i) + MaxX*(rand-0.5)
                call RANDOM_NUMBER(rand)                
                NodeY(i) = NodeY(i) + MaxY*(rand-0.5)
            enddo
            
            ObjTriangulation = 0

            call ConstructTriangulation(ObjTriangulation,                              &
                                        NumberOfNodes = NumberOfNodes, NodeX = NodeX,  &
                                        NodeY = NodeY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR10'

            call GetNumberOfBoundaryNodes (ObjTriangulation, NumberOfBoundaryNodes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR20'

            allocate(Envelope1DX  (1:NumberOfBoundaryNodes),                                &
                     Envelope1DY  (1:NumberOfBoundaryNodes),                                &
                     BoundaryNodes(1:NumberOfBoundaryNodes))


            call GetBoundaryNodes (ObjTriangulation, BoundaryNodes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR30'
            !call GetOuterLine

            do i=1, NumberOfBoundaryNodes
                j = BoundaryNodes(i)
                Envelope1DX(i) = NodeX(j) + AverageX
                Envelope1DY(i) = NodeY(j) + AverageY
            enddo

            call KillTriangulation(ObjTriangulation, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR70'

            deallocate(NodeX, NodeY)
            deallocate(BoundaryNodes)

        else if (NumberOfNodes < 3 .and. NumberOfNodes > 0) then
            NumberOfBoundaryNodes = 3

            allocate(Envelope1DX  (1:NumberOfBoundaryNodes),                                &
                     Envelope1DY  (1:NumberOfBoundaryNodes))
            
            Envelope1DX  (1:1) = Matrix1DX(1) - 1.e-5
            Envelope1DY  (1:1) = Matrix1DY(1) - 1.e-5
            Envelope1DX  (2:2) = Matrix1DX(1)
            Envelope1DY  (2:2) = Matrix1DY(1)
            Envelope1DX  (3:3) = Matrix1DX(1) + 1.e-5
            Envelope1DY  (3:3) = Matrix1DY(1) - 1.e-5

        endif
        
        if (NumberOfNodes > 0) then

            call HDF5SetLimits  (Me%ObjHDF5(em), 1, NumberOfBoundaryNodes, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR40'


            !HDF 5
            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(OriginName)//"/"//trim(StringXaux), &
                                trim(StringXaux),  trim(Units), Array1D = Envelope1DX,                     &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR50'

            !HDF 5
            call HDF5WriteData  (Me%ObjHDF5(em), "/Results/"//trim(OriginName)//"/"//trim(StringYaux), &
                                trim(StringYaux),  trim(Units), Array1D = Envelope1DY,                     &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteOriginEnvelope - ModuleLagrangianGlobal - ERR60'


            if (Me%OutPut%OutputEnvelopeTimeSeries) then
                If (Me%EulerModel(em)%Grid%HaveLatLongGrid) then
                    If (StringX == 'Longitude') then
                        Call WriteOutputEnvelopeTimeSerie(OriginName, Envelope1DX, Envelope1DY, NumberOfBoundaryNodes)
                    endif
                Else
                    If (StringX == 'X Pos') then
                        Call WriteOutputEnvelopeTimeSerie(OriginName, Envelope1DX, Envelope1DY, NumberOfBoundaryNodes)
                    Endif
                Endif
                
            endif
 
#ifndef _NO_NETCDF           
            if (present(OutPutNetCDF)) then
                OutPutNetCDF_ = OutPutNetCDF
            else
                OutPutNetCDF_ = .false. 
            endif

            if (OutPutNetCDF_) then
                call SetDims1DNetCDFFile  ("envelope", NumberOfBoundaryNodes, Dim1D_e)
                call Write1DNetCDFFile    ("lon_envelope", Envelope1DX, "o",  Dim1D_e)  
                call Write1DNetCDFFile    ("lat_envelope", Envelope1DY, "o",  Dim1D_e)  
            endif                    
        
#endif            
                                        
            
            

            deallocate(Envelope1DX, Envelope1DY)

        endif

    end subroutine WriteOriginEnvelope

    !--------------------------------------------------------------------------

    subroutine OutputRestartFile
        
        !Local-----------------------------------------------------------------
        real                                :: Year, Month, Day, Hour, Minute, Second
        logical                             :: WriteFinal

        !----------------------------------------------------------------------

        if(Me%NextCompute >= Me%OutPut%RestartOutTime(Me%OutPut%NextRestartOutput))then


            call ExtractDate(Me%Now,                         &
                             Year = Year, Month  = Month,  Day    = Day, &
                             Hour = Hour, Minute = Minute, Second = Second)

            WriteFinal = .true.
!#ifdef _CGI_
            if (Me%RunOnline) then
                WriteFinal = .false.
            endif
!#endif
            if (WriteFinal) call WriteFinalPartic

            

            Me%OutPut%NextRestartOutput = Me%OutPut%NextRestartOutput + 1

            call SetError(WARNING_, INTERNAL_, "lagrangianglobal restart file saved          : ", &
                          Year, Month, Day, Hour, Minute, Second)

        end if

    end subroutine OutputRestartFile
    
    !--------------------------------------------------------------------------

    subroutine OutPut_HNSTimeSerie

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                        :: CurrentOrigin
        real, dimension (:), pointer                    :: DataLine
        integer                                         :: STAT_CALL

        !Begin-----------------------------------------------------------------
        allocate(DataLine(21))
        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))
    
            DataLine(1)  = CurrentOrigin%AreaTotal
            DataLine(2)  = CurrentOrigin%HNSTotalMass
            DataLine(3)  = CurrentOrigin%HNSMass
            DataLine(4)  = CurrentOrigin%MDegraded
            DataLine(5)  = CurrentOrigin%MBeached
            DataLine(6)  = CurrentOrigin%MSurface
            DataLine(7)  = CurrentOrigin%MEvaporated
            DataLine(8)  = CurrentOrigin%MVolatilized
            DataLine(9)  = CurrentOrigin%MEntrained
            DataLine(10)  = CurrentOrigin%MDissolved
            DataLine(11) = CurrentOrigin%MSedimented
            DataLine(12) = CurrentOrigin%MDeposited
            DataLine(13) = CurrentOrigin%HNSFractionDegraded
            DataLine(14) = CurrentOrigin%HNSFractionBeached
            DataLine(15) = CurrentOrigin%HNSFractionAtSurface
            DataLine(16) = CurrentOrigin%HNSFractionEvaporated
            DataLine(17) = CurrentOrigin%HNSFractionVolatilized
            DataLine(18) = CurrentOrigin%HNSFractionEntrained
            DataLine(19) = CurrentOrigin%HNSFractionDissolved
            DataLine(20) = CurrentOrigin%HNSFractionSedimented
            DataLine(21) = CurrentOrigin%HNSFractionDeposited

            call WriteTimeSerieLine(CurrentOrigin%ObjTimeSerie,                         &
                                    ExternalCurrentTime = Me%Now,                       &
                                    DataLine = DataLine,                                &
                                    STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR01'

            CurrentOrigin => CurrentOrigin%Next
        enddo CurrOr
        nullify(DataLine)
    end subroutine OutPut_HNSTimeSerie

    !--------------------------------------------------------------------------

    subroutine OutPut_TimeSeries

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real, dimension(:, :, :), pointer               :: GridConc3D
        integer                                         :: STAT_CALL
        type (T_Property), pointer                      :: CurrentProperty
        integer                                         :: iProp, em, ig
        integer                                         :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                         :: TimeSerieNumber, dn, id, jd, kd
        logical                                         :: DepthON, IgnoreOK
        real                                            :: DepthLevel

        !Begin-----------------------------------------------------------------
        !Fills Grid concentration
        if (Me%Now > Me%ExternalVar%LastConcCompute) call FillGridConcentration 

d1:     do em =1, Me%EulerModelNumber

        ! In this version only writes times for the first origin group
!d2:    do ig =1, Me%NGroups

        !em = Me%EulerModelNumber
        ig = 1

        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        !Allocates auxiliar variable
        allocate (GridConc3D (ILB:IUB, JLB:JUB, KLB:KUB         ))

        !Corrects if necessary the cell of the time serie based in the time serie depth
        call GetNumberOfTimeSeries(Me%EulerModel(em)%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR10'

        do dn = 1, TimeSerieNumber
        
            call TryIgnoreTimeSerie(Me%EulerModel(em)%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR30'        

            if (IgnoreOK) cycle        

            call GetTimeSerieLocation(Me%EulerModel(em)%ObjTimeSerie, dn,               &  
                                      LocalizationI = id,                               &
                                      LocalizationJ = jd,                               &
                                      DepthLevel    = DepthLevel,                       &
                                      DepthON       = DepthON,                          & 
                                      STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR20'

            if (DepthON) then

                !if (Id < 0 .or. Jd < 0) then
                !
                !    call TryIgnoreTimeSerie(Me%EulerModel(em)%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                !    if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR30'
                !
                !    if (IgnoreOK) then
                !        cycle
                !    else
                !        stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR40'
                !    endif
                !
                !endif

                kd = GetLayer4Level(Me%EulerModel(em)%ObjGeometry, id, jd, DepthLevel, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR50'

                call CorrectsCellsTimeSerie(Me%EulerModel(em)%ObjTimeSerie, dn,  k = kd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR60'

                
                if (Me%EulerModel(em)%WaterPoints3D(id, jd, kd) /= WaterPoint .and. Me%FirstIteration) then

                    write(*,*) 'Time serie station I=',Id, 'J=',Jd,'K=',kd,'is located in land' 
                    write(*,*) 'OutPut_TimeSeries - ModuleWaterProperties - WRN100'

                endif
            endif


        enddo

        iProp = 0
        CurrentProperty => Me%OriginDefault%FirstProperty
        do while (associated(CurrentProperty))

            if (CurrentProperty%WritesTimeSerie) then
                iProp = iProp + 1
            
                GridConc3D = Me%EulerModel(em)%Lag2Euler%GridConc(:, :, :, iProp, ig)

                call WriteTimeSerie(Me%EulerModel(em)%ObjTimeSerie,                         &
                                    Data3D = GridConc3D,                                    &
                                    STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR70'

                if (CurrentProperty%T90ON) then

                    call ComputeT90Matrix(em, ig, CurrentProperty, GridConc3D)

                    call WriteTimeSerie(Me%EulerModel(em)%ObjTimeSerie,                     &
                                        Data3D = GridConc3D,                                &
                                        STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR80'

                endif
            endif

            CurrentProperty => CurrentProperty%Next
        enddo
        

        !Deallocates Temporary Matrixes
        deallocate (GridConc3D)
        
        call WriteTimeSerie(Me%EulerModel(em)%ObjTimeSerie,                             &
                            Data3D = Me%EulerModel(em)%Velocity_U,                      &
                            STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR80'        
        
        call WriteTimeSerie(Me%EulerModel(em)%ObjTimeSerie,                             &
                            Data3D = Me%EulerModel(em)%Velocity_V,                      &
                            STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR90'
        
        call WriteTimeSerie(Me%EulerModel(em)%ObjTimeSerie,                             &
                            Data3D = Me%EulerModel(em)%Velocity_W,                      &
                            STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleLagrangianGlobal - ERR100'                

!        enddo d2
        enddo d1

    
    end subroutine OutPut_TimeSeries

    !--------------------------------------------------------------------------

    subroutine FillGridConcentration

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                        :: CurrentOrigin
        type (T_Partic), pointer                        :: CurrentPartic
        type (T_Property), pointer                      :: FirstProperty, CurrentProperty
        real,    dimension(:, :      ), pointer         :: DUX, DVY
        integer                                         :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                         :: WS_KLB, WS_KUB
        integer                                         :: i, j, k, nProp, status
        integer                                         :: iV, jV, kV, Delta, iAP
        integer                                         :: iInf, iSup
        integer                                         :: jInf, jSup
        integer                                         :: kInf, kSup
        real(8)                                         :: VolumeTotal, Coef
        real                                            :: DiffVolCel
        type (T_Position)                               :: DummYPos    
        logical                                         :: FoundSediment, PartInside
        integer                                         :: Sediment_ID, np, em, ig, STAT_CALL
        real                                            :: VolCell, VolAllPart
                                
        !Begin----------------------------------------------------------------------

        Me%ExternalVar%LastConcCompute = Me%Now
        
d1:     do em = 1, Me%EulerModelNumber 


            WS_ILB = Me%EulerModel(em)%WorkSize%ILB
            WS_IUB = Me%EulerModel(em)%WorkSize%IUB
            WS_JLB = Me%EulerModel(em)%WorkSize%JLB
            WS_JUB = Me%EulerModel(em)%WorkSize%JUB
            WS_KLB = Me%EulerModel(em)%WorkSize%KLB
            WS_KUB = Me%EulerModel(em)%WorkSize%KUB


            nProp           =  Me%OriginDefault%nProperties 
                                                        !i,j,k,p,ig 
            !Me%EulerModel(em)%Lag2Euler%GridVolume      (:,:,:,  :) = 0.
            !Me%EulerModel(em)%Lag2Euler%GridTracerNumber(:,:,:,  :) = 0.
            !Me%EulerModel(em)%Lag2Euler%PercentContamin (:,:,:,  :) = 0.
            !Me%EulerModel(em)%Lag2Euler%GridMass        (:,:,:,:,:) = 0.
            !Me%EulerModel(em)%Lag2Euler%GridConc        (:,:,:,:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%MeanConc              (:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%AmbientConc           (:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%MinConc               (:,:) = 0.
            Me%EulerModel(em)%Lag2Euler%MassVolCel            (:,:) = 0.
            
            do ig = 1, Me%NGroups
            do k = WS_KLB, WS_KUB
            do j = WS_JLB, WS_JUB
            do i = WS_ILB, WS_IUB

                Me%EulerModel(em)%Lag2Euler%GridVolume       (i, j, k,  ig) = 0. 
                Me%EulerModel(em)%Lag2Euler%GridTracerNumber (i, j, k,  ig) = 0.

            enddo
            enddo
            enddo
            enddo
            
            do ig = 1, Me%NGroups
            do k = WS_KLB, WS_KUB
            do j = WS_JLB, WS_JUB
            do i = WS_ILB, WS_IUB

                Me%EulerModel(em)%Lag2Euler%PercentContamin  (i, j, k,  ig) = 0. 

            enddo
            enddo
            enddo
            enddo
            
            
            do ig = 1, Me%NGroups
            do nP = 1, nProp
            do k = WS_KLB, WS_KUB
            do j = WS_JLB, WS_JUB
            do i = WS_ILB, WS_IUB

                Me%EulerModel(em)%Lag2Euler%GridMass         (i, j, k,nP,ig) = 0.
                Me%EulerModel(em)%Lag2Euler%GridConc         (i, j, k,nP,ig) = 0.

            enddo
            enddo
            enddo
            enddo
            enddo
            
            if (Me%State%Deposition) then
                                                          !i,j,p,ig 
                Me%EulerModel(em)%Lag2Euler%GridBottomMass(:,:,:,  :) = 0.
                Me%EulerModel(em)%Lag2Euler%GridBottomConc(:,:,:,  :) = 0.
                
                                                                         !i,j,ig 
                Me%EulerModel(em)%Lag2Euler%GridBottomNumber             (:,:,:) = 0.
                Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber        (:,:,:) = 0.
                Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity(:,:,:) = 0.  
                
                Me%EulerModel(em)%Lag2Euler%GridBottomVolume             (:,:,:) = 0.
                Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume        (:,:,:) = 0.                

            endif

            if (Me%OutPut%ConcMaxTracer) then
                Me%EulerModel(em)%Lag2Euler%GridMaxTracer  (:,:,:,:,:) = 0.
                if (Me%OutPut%MassTracer) then
                    Me%EulerModel(em)%Lag2Euler%GridMaxMass(:,:,:,:,:) = 0.                
                endif
            endif

dg:         do ig = 1, Me%NGroups 

            !Integrates the Volume and the Mass in each GridCell
            CurrentOrigin => Me%FirstOrigin
    CurrOr: do while (associated(CurrentOrigin))

            if (CurrentOrigin%GroupID == Me%GroupIDs(ig)) then

                CurrentPartic => CurrentOrigin%FirstPartic
                do while (associated(CurrentPartic))

       
                    if (em == CurrentPartic%Position%ModelID) then

                        i = CurrentPartic%Position%I
                        j = CurrentPartic%Position%J
                    
                    else

                        PartInside = GetXYInsideDomain(Me%EulerModel(em)%ObjHorizontalGrid, CurrentPartic%Position%CoordX, &
                                                       CurrentPartic%Position%CoordY,Referential = GridCoord_, STAT = STAT_CALL)

                        if (STAT_CALL /= SUCCESS_) stop 'FillGridConcentration - ModuleLagrangianGlobal - ERR05'

                        if (PartInside) then

                            call GetXYCellZ(Me%EulerModel(em)%ObjHorizontalGrid,        &
                                            CurrentPartic%Position%CoordX,              &
                                            CurrentPartic%Position%CoordY, i, j,        &
                                            Referential = GridCoord_,                   &
                                            Iold        = CurrentPartic%Position%I,     &
                                            Jold        = CurrentPartic%Position%J,     &
                                            STAT        = STAT_CALL)

                            if (STAT_CALL /= SUCCESS_) stop 'FillGridConcentration - ModuleLagrangianGlobal - ERR10'

                        else
                            CurrentPartic => CurrentPartic%Next
                            cycle
                        endif
                    
                    endif
                    
                    if (j < WS_JLB .or. j > WS_JUB .or. i < WS_ILB .or. i > WS_IUB) then
                        write(*,*) 'ig, em, i, j=', ig, em, i, j
                        stop 'FillGridConcentration - ModuleLagrangianGlobal - ERR15'
                    endif
                    
                    if (Me%State%Deposition) then
                        
                        if (CurrentPartic%Deposited) then

                            Me%EulerModel(em)%Lag2Euler%GridBottomNumber(i,j,ig) =      &
                                Me%EulerModel(em)%Lag2Euler%GridBottomNumber(i,j,ig) + 1
                            
                            Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) =      &
                                Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) +  &
                                CurrentPartic%Geometry%Volume
                            
                        else


                            Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber(i,j,ig) =      &
                                Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber(i,j,ig) + 1          
                            
                            Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) =      &
                                Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) +  & 
                                CurrentPartic%Geometry%Volume
                            
                            
                        endif
                        
                    endif                        

cd1:                if (.not. CurrentPartic%Deposited) then


                        if (em == CurrentPartic%Position%ModelID) then
                            k = CurrentPartic%Position%K
                        else
                            k = GetLayer4Level(Me%EulerModel(em)%ObjGeometry, i, j, CurrentPartic%Position%Z, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'FillGridConcentration - ModuleLagrangianGlobal - ERR20'
                        endif
                        
                        if (k < WS_KLB .or. k > WS_KUB) then
                            write(*,*) 'ig, em, i, j, k=', ig, em, i, j, k
                            write(*,*) 'assumed k = KUB'
                            k = WS_KUB
                            !stop 'FillGridConcentration - ModuleLagrangianGlobal - ERR25'
                        endif                        


                        Me%EulerModel(em)%Lag2Euler%GridTracerNumber(i, j, k, ig) = &
                            Me%EulerModel(em)%Lag2Euler%GridTracerNumber(i, j, k, ig) + 1
                        

                        if (Me%OutPut%OutPutConcType == Analytic) then    
                            call AnalyticConcentration(CurrentPartic, em, i, j, k, ig, nProp)
                        endif    
                            
cd0:                    if (nProp > 0) then
                            
                            if (Me%OutPut%ConcMaxTracer) then
                            
                                do nP=1, nProp

                                    !In this grid is stored the maximum concentration of all tracers present in the cell
                                    Me%EulerModel(em)%Lag2Euler%GridMaxTracer(i, j, k, nP, ig) = &
                                        max(Me%EulerModel(em)%Lag2Euler%GridMaxTracer(i, j, k, nP, ig), &
                                        CurrentPartic%Concentration(nP))

                                    if (Me%OutPut%MassTracer) then
                                        !In this grid is stored the maximum mass of all tracers present in the cell
                                        Me%EulerModel(em)%Lag2Euler%GridMaxMass(i, j, k, nP, ig) = &
                                            max(Me%EulerModel(em)%Lag2Euler%GridMaxMass(i, j, k, nP, ig), &
                                            CurrentPartic%Mass(nP))
                                    endif     
                                    
                                enddo                                          
                            endif
                            
                            
                            !Particle fits inside Grid Cell?    
        cd2:                if (CurrentPartic%Geometry%Volume <= Me%EulerModel(em)%VolumeZ(i, j, k)) then
        
                                do nP=1, nProp

                                    Me%EulerModel(em)%Lag2Euler%GridMass  (i, j, k, nP, ig) = &
                                        Me%EulerModel(em)%Lag2Euler%GridMass  (i, j, k, nP, ig) + CurrentPartic%Mass(nP)
                                   
                                enddo
                                
                                 Me%EulerModel(em)%Lag2Euler%GridVolume (i, j, k, ig)   = &
                                        Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, k, ig)    + CurrentPartic%Geometry%Volume
                                
                            else  cd2

                                WS_ILB = Me%EulerModel(em)%WorkSize%ILB
                                WS_IUB = Me%EulerModel(em)%WorkSize%IUB
                                WS_JLB = Me%EulerModel(em)%WorkSize%JLB
                                WS_JUB = Me%EulerModel(em)%WorkSize%JUB
                                WS_KLB = Me%EulerModel(em)%WorkSize%KLB
                                WS_KUB = Me%EulerModel(em)%WorkSize%KUB

                                VolumeTotal = Me%EulerModel(em)%VolumeZ(i, j, k)
                                Delta = 0
                                do while (VolumeTotal < CurrentPartic%Geometry%Volume)

                                    Delta = Delta + 1

                                    iInf  = max (i-Delta, WS_ILB)
                                    jInf  = max (j-Delta, WS_JLB)
                                    kInf  = max (k-Delta, WS_KLB)

                                    iSup  = min (i+Delta, WS_IUB)
                                    jSup  = min (j+Delta, WS_JUB)
                                    kSup  = min (k+Delta, WS_KUB)

                                    if (iInf == WS_ILB .and. iSup == WS_IUB .and. &
                                        jInf == WS_JLB .and. jSup == WS_JUB .and. &
                                        kInf == WS_KLB .and. kSup == WS_KUB) then
                        
                                        write(*, *)'Particle bigger then domain'
                                        stop       'FillGridConcentration - ModuleLagrangianGlobal - ERR30'

                                    endif

                                    VolumeTotal = 0.
                                    do iV = iInf, iSup
                                    do jV = jInf, jSup
                                    do kV = kinf, kSup
                                        if (Me%EulerModel(em)%OpenPoints3D(iV, jV, kV) == OpenPoint) then
                                            VolumeTotal = VolumeTotal +                              &
                                                          Me%EulerModel(em)%VolumeZ(iV, jV, kV)
                                        endif
                                    enddo
                                    enddo
                                    enddo

                                enddo
                
                                do iV = iInf, iSup
                                do jV = jInf, jSup
                                do kV = kinf, kSup
                                    if (Me%EulerModel(em)%OpenPoints3D(iV, jV, kV) == OpenPoint) then
                        
                                        Coef = Me%EulerModel(em)%VolumeZ(iV, jV, kV) / VolumeTotal
                        
                                        Me%EulerModel(em)%Lag2Euler%GridMass  (iV, jV, kV, :, ig) = &
                                            Me%EulerModel(em)%Lag2Euler%GridMass  (iV, jV, kV, :, ig) + &
                                            CurrentPartic%Mass(:) * Coef

                                        Me%EulerModel(em)%Lag2Euler%GridVolume(iV, jV, kV, ig) = &
                                            Me%EulerModel(em)%Lag2Euler%GridVolume(iV, jV, kV, ig)    + &
                                            CurrentPartic%Geometry%Volume * Coef

                                    endif
                                enddo
                                enddo
                                enddo
                
                            endif cd2
                        
                        endif cd0

                    else if (nProp > 0) then cd1    ! The particle is deposited in the bottom
                    !In this case no test is made to verify if the the particle occupies more then one cell
                    !to maintain the algothim simple.

                  
                        Me%EulerModel(em)%Lag2Euler%GridBottomMass (i, j, :, ig) =  &
                            Me%EulerModel(em)%Lag2Euler%GridBottomMass (i, j, :, ig) + CurrentPartic%Mass(:)

                   
                    endif cd1

                    CurrentPartic => CurrentPartic%Next
                enddo

                if (.not. associated(FirstProperty)) FirstProperty => CurrentOrigin%FirstProperty

            endif

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr


            if (Me%State%Deposition) then !Find if exist the 'sediment' property

                !Ambient Concentration of the place of the particle
                Sediment_ID      = 0
                FoundSediment = .false.
                CurrentProperty => FirstProperty
                do while (associated(CurrentProperty) .and. .not. FoundSediment)
                    Sediment_ID = Sediment_ID + 1
                    if (CurrentProperty%ID == Sediment) FoundSediment = .true.
                    CurrentProperty => CurrentProperty%Next
                enddo
    
            endif

        enddo dg

        enddo d1
        

d2:     do em = 1, Me%EulerModelNumber 

            WS_ILB = Me%EulerModel(em)%WorkSize%ILB
            WS_IUB = Me%EulerModel(em)%WorkSize%IUB
            WS_JLB = Me%EulerModel(em)%WorkSize%JLB
            WS_JUB = Me%EulerModel(em)%WorkSize%JUB
            WS_KLB = Me%EulerModel(em)%WorkSize%KLB
            WS_KUB = Me%EulerModel(em)%WorkSize%KUB

            !Fills up Grid Concentration
g2:         do ig = 1, Me%NGroups
             
            do k = WS_KLB, WS_KUB
            do j = WS_JLB, WS_JUB
            do i = WS_ILB, WS_IUB

                if (Me%EulerModel(em)%Waterpoints3D (i, j, k) == WaterPoint) then

                    !Mean Concentration of the particle
                    Me%EulerModel(em)%Lag2Euler%MeanConc(:,ig) = 0.0
                    if (Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, k, ig) > 0.0) then
                        Me%EulerModel(em)%Lag2Euler%MeanConc  (:, ig) = &
                            Me%EulerModel(em)%Lag2Euler%GridMass  (i, j, k, :, ig) / &
                            Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, k, ig)
                    endif

                    !Ambient Concentration of the place of the particle
                    iAP = 1
!                    CurrentProperty => FirstProperty

                    CurrentProperty => Me%OriginDefault%FirstProperty

                    do while (associated(CurrentProperty))
            
                        DummYPos%I = i
                        DummYPos%J = j
                        DummYPos%K = k
                
                        call GetAmbientConcCell      (CurrentProperty,                  &
                                                      em,                               &
                                                      DummYPos,                         &
                                                      Me%EulerModel(em)%Lag2Euler%AmbientConc(iAP, ig))

                        Me%EulerModel(em)%Lag2Euler%MinConc (iAP,ig) = CurrentProperty%Min_concentration

                        iAP = iAP + 1
                        CurrentProperty => CurrentProperty%Next
                    enddo


                    select case (Me%OutPut%OutPutConcType)

                    ! If a particle volume is greater than the volume cell the particle mass and volume 
                    ! is distributed in a uniform way by the adjacent cells in the follower order I,J,K
                    
                    case (Maximum)


                        !"Maximum" method : In this case the maximum value between to option is assumed:
                        !   - total particle mass inside a cell devided by the volume cell
                        !   - total particle mass inside a cell devided by the total particle volume inside the cell 
                        !          
                        Me%EulerModel(em)%Lag2Euler%MassVolCel(:, ig) = &
                            Me%EulerModel(em)%Lag2Euler%GridMass(i, j, k, :, ig) / &
                            Me%EulerModel(em)%VolumeZ(i, j, k)
                        
                        Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig) = &
                            max(Me%EulerModel(em)%Lag2Euler%MassVolCel(:, ig), &
                            Me%EulerModel(em)%Lag2Euler%MeanConc(:, ig)) 

                    case (Mean)

                        !"Mean" method : In this case the concentration is assumed equal to the 
                        !  total particle mass inside a cell devided by the volume cell in sum of the total particle volume
                        !  is bigger than the cell volume. Otherwise the total particle mass is add to the ambient concentration 
                        ! multiply by the volume cell not covered by the particle volumes. The final concentration is mass describe 
                        ! before devide by the cell volume. 

                        if (Me%EulerModel(em)%VolumeZ(i, j, k) >=                       &
                            Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, k, ig)) then 
                            DiffVolCel = Me%EulerModel(em)%VolumeZ(i, j, k) -           &
                            Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, k, ig)  
            
                            Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig) =  &
                            (DiffVolCel * Me%EulerModel(em)%Lag2Euler%AmbientConc(:,ig) + &
                                          Me%EulerModel(em)%Lag2Euler%GridMass  (i, j, k, :,ig)) / &  
                                          Me%EulerModel(em)%VolumeZ(i, j, k)

                        else

                            Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig) =  &
                                Me%EulerModel(em)%Lag2Euler%MeanConc(:, ig)

                        endif
                        
                    case (Analytic)

                        !Method 3
                        !The concentration evolution of each particle is assumed equal to the analytic solution in particle center 
                        !The concentration of the cell becomes equal to max of particles center concentration
                        ! C = 2 * M / ((4 * pi * t)^1.5 * (2*Kh * Kv)^0.5)
                        ! C - center particle concentration
                        ! M - particle mass
                        ! t - particle age
                        ! Kh - turbulent horizontal diffusion 
                        ! Kv - turbulent vertical diffusion

                    end select
                    
                    VolCell    = Me%EulerModel(em)%VolumeZ             (i, j, k    )
                    VolAllPart = Me%EulerModel(em)%Lag2Euler%GridVolume(i, j, k, ig) 
                    
                    if (VolAllPart > VolCell) then
                        Me%EulerModel(em)%Lag2Euler%PercentContamin(i, j, k, ig) = 100.
                        
                    else
                        if (VolCell > 0.) then
                            Me%EulerModel(em)%Lag2Euler%PercentContamin(i, j, k, ig) = VolAllPart / VolCell * 100.
                        endif
                    
                    endif
                    
                    where (Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig).lt.     &
                           Me%EulerModel(em)%Lag2Euler%MinConc(:, ig))                  &
                           Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig) =       &
                           Me%EulerModel(em)%Lag2Euler%AmbientConc(:,ig)

                    where (Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig)  == 0.)                                   &
                           Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig)  =      &
                           Me%EulerModel(em)%Lag2Euler%AmbientConc(:,ig)

                else

                     Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, :, ig) = null_real

                end if

            end do
            end do
            end do

            end do g2

    cd3:    if (Me%State%Deposition) then ! fills up the bottom concentration in a simplified way

                !Gets Horizontal Grid
                call GetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DUX = DUX, DVY = DVY, STAT = status)
                if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_, 'FillGridConcentration - ModuleLagrangianGlobal - ERR40')

g3:             do ig = 1, Me%NGroups

                    do j = WS_JLB, WS_JUB
                    do i = WS_ILB, WS_IUB

                        if (Me%EulerModel(em)%Waterpoints3D (i, j, WS_KUB) == WaterPoint) then

                            if (FoundSediment) then
                                do np = 1, SIZE(Me%EulerModel(em)%Lag2Euler%GridBottomConc, DIM = 3)

                                    if (np /= Sediment_ID) then 
                                        !Mass contaminant / Mass sediment
                                        if (Me%EulerModel(em)%Lag2Euler%GridBottomMass(i, j, Sediment_ID, ig) > 1e-12) then
                                            Me%EulerModel(em)%Lag2Euler%GridBottomConc(i, j, np, ig) = &
                                            Me%EulerModel(em)%Lag2Euler%GridBottomMass(i, j, np, ig) / &
                                            Me%EulerModel(em)%Lag2Euler%GridBottomMass(i, j, Sediment_ID, ig)
                                        else
                                            Me%EulerModel(em)%Lag2Euler%GridBottomConc(i, j, np, ig) = 0.
                                        endif
                                    else
                                        ! Mass of sediment / m^2
                                        Me%EulerModel(em)%Lag2Euler%GridBottomConc(i, j, Sediment_ID, ig) = &
                                        Me%EulerModel(em)%Lag2Euler%GridBottomMass(i, j, Sediment_ID, ig) / DUX(I, j) / DVY(i, j)
                                        ! Mass of sediment / m2
                                        Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity(i, j, ig)= &
                                            sum(Me%EulerModel(em)%Lag2Euler%GridMass(i, j, WS_KLB:WS_KUB, Sediment_ID, ig)) &
                                            / DUX(I, j) / DVY(i, j)   
                                        
                                        ! Volume / m2 = m
                                        Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) = &
                                                Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(i,j,ig) / DUX(I, j) / DVY(i, j)

                                        ! Volume / m2 = m
                                        Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) = &
                                                Me%EulerModel(em)%Lag2Euler%GridBottomVolume(i,j,ig) / DUX(I, j) / DVY(i, j)
                                        
                                    endif
                   
                                enddo 
                            else !all properties are written in mass / m^2
                                ! Mass / m^2
                                Me%EulerModel(em)%Lag2Euler%GridBottomConc(i, j, :, ig) = &
                                    Me%EulerModel(em)%Lag2Euler%GridBottomMass(i, j, :, ig) / DUX(I, j) / DVY(i, j)

                            endif

                        endif

                    enddo
                    enddo

                enddo g3

                !UnGets Horizontal Grid
                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DUX,               &
                                       STAT = status)
                if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_, 'FillGridConcentration - ModuleLagrangianGlobal - ERR50')

                !UnGets Horizontal Grid
                call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DVY,               &
                                       STAT = status)
                if (status /= SUCCESS_) call SetError(FATAL_, INTERNAL_, 'FillGridConcentration - ModuleLagrangianGlobal - ERR60')

            endif cd3

        enddo d2
        

    end subroutine FillGridConcentration

    !--------------------------------------------------------------------------

    subroutine AnalyticConcentration (CurrentPartic, em, i, j, k, ig, nProp)   
    
        !Arguments-------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentPartic
        integer                                     :: em, i, j, k, ig, nProp

        !Local-----------------------------------------------------------------
        real                                        :: ParticleCenterConc, M, t, Kh, Kv, CellConc
        integer                                     :: nP
        
        !Begin-----------------------------------------------------------------        

        !Method 3
        !The concentration evolution of each particle is assumed equal to the analytic solution in particle center 
        !The concentration of the cell becomes equal to max of particles center concentration
        ! C = 2 * M / ((4 * pi * t)^1.5 * (2*Kh * Kv)^0.5)
        ! C - center particle concentration
        ! M - particle mass
        ! t - particle age
        ! Kh - turbulent horizontal diffusion 
        ! Kv - turbulent vertical diffusion
        
        
        do nP = 1, nProp
            M  = CurrentPartic%Mass(nP) 
            t  = CurrentPartic%Age
            !10 m mixing horizontal length - Ozmidov K(L) - function
            Kh = 4.64e-2
            !0.1 m mixing vertical length - Ozmidov K(L) - function
            Kv = 4.65e-4

            !Analytical solution for a emisson near a no flux boundary (e.g. sea surface)
            !Fischer, 1979 Mixing in Ilnad and Coastal Waters Academic Press, Inc., 
            ! pag. 47 - 48
            if (t > 0) then
                ParticleCenterConc = 2. * M / (4. * Pi * t) ** 1.5 / sqrt(Kh*Kh*Kv)
            else 
                ParticleCenterConc = CurrentPartic%Concentration(nP)
            endif       
            
            if (ParticleCenterConc > CurrentPartic%Concentration(nP)) then 
                ParticleCenterConc = CurrentPartic%Concentration(nP)
            endif
                            
            CellConc = Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, nP, ig)
            
            if (ParticleCenterConc > CellConc) then
                Me%EulerModel(em)%Lag2Euler%GridConc(i, j, k, nP, ig) = ParticleCenterConc
            endif                
            
        enddo            
    
    end subroutine AnalyticConcentration
    
    !--------------------------------------------------------------------------    

    subroutine WriteGridConcentration(em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber

        !Local-----------------------------------------------------------------
        integer, dimension(:, :, :   ), pointer     :: WaterPoints3D
        real, dimension(:, :, :), pointer           :: GridConc3D, GridGroupSum3D, GridTotalSum3D
        real, dimension(:, :   ), pointer           :: GridConc2D 
        integer                                     :: ig, p
        type (T_Property), pointer                  :: CurrentProperty
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB
        character(StringLength)                     :: AuxChar, AuxChar2, AuxChar3, AuxCharUnits

        !Shorten

        ig = 1

        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        WaterPoints3D    => Me%EulerModel(em)%WaterPoints3D


        !Allocates auxiliar variable
        allocate (GridConc3D (ILB:IUB, JLB:JUB, KLB:KUB         ))

        if (Me%State%Deposition) allocate (GridConc2D (ILB:IUB, JLB:JUB      ))

        if (Me%State%Odour) then
            allocate (GridGroupSum3D (ILB:IUB, JLB:JUB, KLB:KUB          ))
            allocate (GridTotalSum3D (ILB:IUB, JLB:JUB, KLB:KUB          ))
            GridGroupSum3D = 0.0
            GridTotalSum3D = 0.0
        endif
        
d2:     do ig = 1, Me%nGroups
            
            if (Me%State%Odour) GridGroupSum3D = 0.0
            
            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            !Sets limits for next write operations
            call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,           &
                                  WS_KLB, WS_KUB)

            if (Me%nGroups == 1) then

                AuxChar2 = "/Results/"

            else

                AuxChar2 = "/Results/Group_"//trim(adjustl(AuxChar))//"/Data_3D/"

            endif

            CurrentProperty => Me%OriginDefault%FirstProperty


dp:         do p = 1, Me%OriginDefault%NProperties

ih:             if (CurrentProperty%WritesPropHDF) then

                    GridConc3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridConc(:, :, :, p, ig)

                    AuxChar3 = trim(AuxChar2)//trim(CurrentProperty%Name)

                    !HDF 5
                    call HDF5WriteData        (Me%ObjHDF5(em),                          &
                                               trim(AuxChar3),                          &
                                               trim(CurrentProperty%Name),              &
                                               trim(CurrentProperty%Units),             &
                                               Array3D = GridConc3D,                    &
                                               OutputNumber = OutputNumber)

                    if (CurrentProperty%T90ON) then

                        call ComputeT90Matrix(em, ig, CurrentProperty, GridConc3D)


                        AuxChar3 = trim(AuxChar2)//trim(CurrentProperty%T90Name)

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                          &
                                                   trim(AuxChar3),                          &
                                                   trim(CurrentProperty%T90Name),           &
                                                   's',                                     &
                                                   Array3D = GridConc3D,                    &
                                                   OutputNumber = OutputNumber)


                    endif

                    if (Me%OutPut%ConcMaxTracer) then

                        GridConc3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridMaxTracer(:, :, :, p, ig)

                        AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                   "/Data_3D_MaxTracer/"//trim(CurrentProperty%Name)

                        !HDF 5
                        call HDF5WriteData    (Me%ObjHDF5(em),                          &
                                               trim(AuxChar3),                          &
                                               trim(CurrentProperty%Name),              &
                                               trim(CurrentProperty%Units),             &
                                               Array3D = GridConc3D,                    &
                                               OutputNumber = OutputNumber)

                        if (Me%OutPut%MassTracer) then

                            GridConc3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridMaxMass(:, :, :, p, ig)

                            AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                       "/Data_3D_MaxMassTracer/"//trim(CurrentProperty%Name)

                            !HDF 5
                            call HDF5WriteData    (Me%ObjHDF5(em),                      &
                                                   trim(AuxChar3),                      &
                                                   trim(CurrentProperty%Name),          &
                                                   trim(CurrentProperty%Units),         &
                                                   Array3D = GridConc3D,                &
                                                   OutputNumber = OutputNumber)
                        endif
                    endif

                    if (Me%State%Deposition) then

                        GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridBottomConc(:, :, p, ig)

                        AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                   "/Data_2D/Bottom/"//trim(CurrentProperty%Name)
                        
                        if (CurrentProperty%ID == Sediment) then
                            AuxCharUnits = "mass/m2"
                        else
                            AuxCharUnits = "mass/mass sed"
                        endif
                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                      &
                                                   trim(AuxChar3),                      &
                                                   trim(CurrentProperty%Name),          &
                                                   trim(AuxCharUnits),                  &
                                                   Array2D = GridConc2D,                &
                                                   OutputNumber = OutputNumber)
                        
                        if (CurrentProperty%ID == Sediment) then
                            
                            AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                       "/Data_2D/WaterColumn/"//trim(CurrentProperty%Name)
                            
                            GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity(:, :, ig)
                            
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       trim(AuxChar3),                  &
                                                       trim(CurrentProperty%Name),      &
                                                       trim(AuxCharUnits),              &
                                                       Array2D = GridConc2D,            &
                                                       OutputNumber = OutputNumber)
                            
                            AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                       "/Data_2D/Total/"//trim(CurrentProperty%Name)
                            
                            GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity(:, :, ig) + &
                                              Me%EulerModel(em)%Lag2Euler%GridBottomConc(:, :, p, ig)  
                            
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       trim(AuxChar3),                  &
                                                       trim(CurrentProperty%Name),      &
                                                       trim(AuxCharUnits),              &
                                                       Array2D = GridConc2D,            &
                                                       OutputNumber = OutputNumber)    
                            
                            AuxCharUnits = "m3/m2"
                            
                            AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                       "/Data_2D/WaterColumn/Sediment Volume"
                            
                            GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(:, :, ig)
                            
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       trim(AuxChar3),                  &
                                                       "Sediment Volume",               &
                                                       trim(AuxCharUnits),              &
                                                       Array2D = GridConc2D,            &
                                                       OutputNumber = OutputNumber)
                            
                            AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                       "/Data_2D/Bottom/Sediment Volume"
                            
                            GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridBottomVolume(:, :, ig)
                            
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       trim(AuxChar3),                  &
                                                       "Sediment Volume",               &
                                                       trim(AuxCharUnits),              &
                                                       Array2D = GridConc2D,            &
                                                       OutputNumber = OutputNumber)                            
                            
                            AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                       "/Data_2D/Total/Sediment Volume"
                            
                            GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume(:, :, ig) + &
                                              Me%EulerModel(em)%Lag2Euler%GridBottomVolume(:, :, ig)  
                            
                            call HDF5WriteData        (Me%ObjHDF5(em),                  &
                                                       trim(AuxChar3),                  &
                                                       "Sediment Volume",               &
                                                       trim(AuxCharUnits),              &
                                                       Array2D = GridConc2D,            &
                                                       OutputNumber = OutputNumber)  
                            
                            if (Me%State%CriticalSlope) then
                                
                                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                            "/Data_2D/Bottom/Slope"
                            
                                GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridBottomSlope(:, :, ig)
                                
                                AuxCharUnits ="-"
                                
                                call HDF5WriteData        (Me%ObjHDF5(em),              &
                                                            trim(AuxChar3),             &
                                                            "Slope",                    &
                                                            trim(AuxCharUnits),         &
                                                            Array2D = GridConc2D,       &
                                                            OutputNumber = OutputNumber)                                
                                
                                
                                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                            "/Data_2D/Bottom/Slope Vel. X"
                            
                                GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridVelSlope_X(:, :, ig)
                                
                                AuxCharUnits ="m/s"
                            
                                call HDF5WriteData        (Me%ObjHDF5(em),              &
                                                            trim(AuxChar3),             &
                                                            "Slope Vel. X",             &
                                                            trim(AuxCharUnits),         &
                                                            Array2D = GridConc2D,       &
                                                            OutputNumber = OutputNumber)                                 
                                
                                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                            "/Data_2D/Bottom/Slope Vel. Y"
                            
                                GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y(:, :, ig)
                                
                                AuxCharUnits ="m/s"
                            
                                call HDF5WriteData        (Me%ObjHDF5(em),              &
                                                            trim(AuxChar3),             &
                                                            "Slope Vel. Y",             &
                                                            trim(AuxCharUnits),         &
                                                            Array2D = GridConc2D,       &
                                                            OutputNumber = OutputNumber)
                            endif                            
                            
                        endif
                        
                    endif
                    
                    if (Me%State%Odour) then
                        
                        GridConc3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridConc(:, :, :, p, ig)
                        GridConc3D(:,:,:) = GridConc3D(:,:,:) * PeakFactor / CurrentProperty%OdourConcThreshold

                        GridGroupSum3D = GridGroupSum3D + GridConc3D
                        GridTotalSum3D = GridTotalSum3D + GridConc3D
                        
                        AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                                    "/Data_3D_Odour/"//trim(CurrentProperty%Name)

                        !HDF 5
                        call HDF5WriteData    (Me%ObjHDF5(em),                      &
                                                trim(AuxChar3),                     &
                                                trim(CurrentProperty%Name),         &
                                                'odour units',                      &
                                                Array3D = GridConc3D,               &
                                                OutputNumber = OutputNumber)
                    endif
                    
                endif ih

                CurrentProperty => CurrentProperty%Next


            enddo dp

            nullify(CurrentProperty)

            AuxChar3 = trim(AuxChar2)//"Number"

            GridConc3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%GridTracerNumber(:, :, :, ig)

            !HDF 5
            call HDF5WriteData        (Me%ObjHDF5(em),                                  &
                                       trim(AuxChar3),                                  &
                                       "Number", "a",                                   &
                                       Array3D = GridConc3D,                            &
                                       OutputNumber = OutputNumber)
            
            if (Me%State%Deposition) then            
            
                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                            "/Data_2D/WaterColumn/"//"Number"
                            
                GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber(:, :, ig)                        
                
                AuxCharUnits = "a"
                            
                call HDF5WriteData        (Me%ObjHDF5(em),                              &
                                            trim(AuxChar3),                             &
                                            "Number",                                   &
                                            trim(AuxCharUnits),                         &
                                            Array2D = GridConc2D,                       &
                                            OutputNumber = OutputNumber) 

                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                            "/Data_2D/Bottom/"//"Number"
                            
                GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridBottomNumber(:, :, ig)                        
                
                call HDF5WriteData        (Me%ObjHDF5(em),                              &
                                            trim(AuxChar3),                             &
                                            "Number",                                   &
                                            trim(AuxCharUnits),                         &
                                            Array2D = GridConc2D,                       &
                                            OutputNumber = OutputNumber) 
                
                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                            "/Data_2D/Total/"//"Number"
                            
                GridConc2D(:,:) = Me%EulerModel(em)%Lag2Euler%GridBottomNumber(:, :, ig) + &
                                  Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber(:, :, ig) 
                
                call HDF5WriteData        (Me%ObjHDF5(em),                              &
                                            trim(AuxChar3),                             &
                                            "Number",                                   &
                                            trim(AuxCharUnits),                         &
                                            Array2D = GridConc2D,                       &
                                            OutputNumber = OutputNumber)                 
                
            endif                

            if (Me%State%Odour) then
                 
                AuxChar3 = "/Results/Group_"//trim(adjustl(AuxChar))//&
                            "/Data_3D_Odour/Group_Odour"
            
                !HDF 5
                call HDF5WriteData    (Me%ObjHDF5(em),                                  &
                                        trim(AuxChar3),                                 &
                                        "Group_Odour",                                  &
                                        'odour units',                                  &
                                        Array3D = GridGroupSum3D,                       &
                                        OutputNumber = OutputNumber)
            endif
                        
            AuxChar3 = trim(AuxChar2)//"Percentage Contaminated"

            GridConc3D(:,:,:) = Me%EulerModel(em)%Lag2Euler%PercentContamin(:, :, :, ig)

            !HDF 5
            call HDF5WriteData        (Me%ObjHDF5(em),                                  &
                                       trim(AuxChar3),                                  &
                                       "Percentage Contaminated", "%",                  &
                                       Array3D = GridConc3D,                            &
                                       OutputNumber = OutputNumber)        

            
        enddo d2
!        enddo d1

        if (Me%State%Odour) then
                
            !HDF 5
            call HDF5WriteData    (Me%ObjHDF5(em),                      &
                                    "/Results/Total_Odour",             &
                                    "Total_Odour",                      &
                                    'odour units',                      &
                                    Array3D = GridTotalSum3D,           &
                                    OutputNumber = OutputNumber)
                    
        endif
        
        deallocate  (GridConc3D     )
        nullify     (GridConc3D     )
        nullify     (WaterPoints3D  )
        if (Me%State%Deposition) deallocate  (GridConc2D     )
        nullify     (GridConc2D     )  

        if (Me%State%Odour) then
            deallocate  (GridGroupSum3D )
            nullify     (GridGroupSum3D )
            deallocate  (GridTotalSum3D )
            nullify     (GridTotalSum3D )
        endif
        

    end subroutine WriteGridConcentration

    !--------------------------------------------------------------------------

    subroutine WriteFrequencyLag (em, p, ig)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, p, ig
        !Local-----------------------------------------------------------------
        real, dimension(:, :, :), pointer           :: GridConc3D 
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB, iClass, STAT_CALL
        character(StringLength)                     :: AuxChar1, AuxChar2, AuxChar


        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Allocates auxiliar variable
        allocate (GridConc3D (ILB:IUB, JLB:JUB, KLB:KUB         ))


        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,               &
                              WS_KLB, WS_KUB)


i1:     if (Me%Statistic%OptionsStat(p)%Lag) then
            
            call GetStatisticClassesNumber(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),&
                                           Me%Statistic%OptionsStat(p)%nClassesLag, STAT= STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'WriteFrequencyLag - ModuleLagrangianGlobal - ERR10'

            call GetStatisticClasses(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),                          &
                                     Me%Statistic%OptionsStat(p)%ClassesLag, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'WriteFrequencyLag - ModuleLagrangianGlobal - ERR20'


            do iClass = 1, Me%Statistic%OptionsStat(p)%nClassesLag

                write(AuxChar1, fmt='(E9.2)')Me%Statistic%OptionsStat(p)%ClassesLag(iClass, 1)
                write(AuxChar2, fmt='(E9.2)')Me%Statistic%OptionsStat(p)%ClassesLag(iClass, 2)

                AuxChar = trim(adjustl(AuxChar1))//"_"//trim(adjustl(AuxChar2))

        
                GridConc3D(:,:,:) = 100. * Me%EulerModel(em)%PropStatistic(p)%FrequencyLag(:,:,:,iClass, ig)

                        

                call HDF5WriteData   (Me%ObjHDF5(em), "/Statistics/Lagrangian/"         &
                                      //trim(Me%Statistic%OptionsStat(p)%ID%Name)       &
                                      //"/Classes", trim(adjustl(AuxChar)),             &
                                      "-", Array3D = GridConc3D,                        &
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteFrequencyLag - ModuleLagrangianGlobal - ERR10'

            enddo

            call UnGetStatistic(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig),       &
                                Me%Statistic%OptionsStat(p)%ClassesLag, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'WriteFrequencyLag - ModuleLagrangianGlobal - ERR20'

            deallocate (GridConc3D )

        endif i1
        
       
    end subroutine WriteFrequencyLag

    !--------------------------------------------------------------------------

    subroutine WriteOilPresence(em, OutputNumber) 

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB
        integer                                     :: ig
        real, dimension(:, :), pointer              :: Aux2D 
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB

        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)


Group:  do ig = 1, Me%nGroups

            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif
                                            
                call HDF5WriteData(Me%ObjHDF5(em),                          &
                                   "/Results/"//trim(CurrentOrigin%Name)    &
                                   //"/Data_2D/Oil Arrival Time",           &
                                   "Oil Arrival Time",                      &
                                   "-",                                     &
                                   Array2D = Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime, &
                                   OutputNumber = OutputNumber)
                                   
                                   
                if(Me%State%AssociateBeachProb)then                     
                                   
                    Aux2D => Me%EulerModel(em)%Lag2Euler%GridBeachingTime(WS_ILB:WS_IUB,WS_JLB:WS_JUB,ig)
                    
                    call HDF5WriteData(Me%ObjHDF5(em),                          &
                                       "/Results/"//trim(CurrentOrigin%Name)    &
                                       //"/Data_2D/Beaching Time",              &
                                       "Beaching Time",                         &
                                       "-",                                     &
                                       Array2D = Aux2D,                         &
                                       OutputNumber = OutputNumber)
                                   
                    nullify(Aux2D)
                    
                endif

                CurrentOrigin => CurrentOrigin%Next
                
            enddo CurrOr

        enddo Group
            
    end subroutine WriteOilPresence

    !--------------------------------------------------------------------------

    subroutine WriteOilGridThickness(em, OutputNumber) 

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB
        integer                                     :: ig
        real, dimension(:, :), pointer              :: OilGridThick2D 
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB, i, j


!em1:    do em =1, Me%EulerModelNumber

            !Shorten
            ILB    = Me%EulerModel(em)%Size%ILB
            IUB    = Me%EulerModel(em)%Size%IUB
            JLB    = Me%EulerModel(em)%Size%JLB
            JUB    = Me%EulerModel(em)%Size%JUB

            WS_ILB = Me%EulerModel(em)%WorkSize%ILB
            WS_IUB = Me%EulerModel(em)%WorkSize%IUB
            WS_JLB = Me%EulerModel(em)%WorkSize%JLB
            WS_JUB = Me%EulerModel(em)%WorkSize%JUB
            WS_KLB = Me%EulerModel(em)%WorkSize%KLB
            WS_KUB = Me%EulerModel(em)%WorkSize%KUB

            !Sets limits for next write operations
            call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                                  WS_KLB, WS_KUB)


            !Allocate GridVolume, GridMass
            allocate (OilGridThick2D (ILB:IUB, JLB:JUB))

Group:      do ig = 1, Me%nGroups

                !Writes the Group to an auxiliar string
                write (AuxChar, fmt='(i3)') ig

                CurrentOrigin => Me%FirstOrigin
CurrOr:         do while (associated(CurrentOrigin))

                    if (CurrentOrigin%GroupID /= ig) then
                        CurrentOrigin => CurrentOrigin%Next
                        cycle
                    endif
                    !Just writes the output if there are particle
!                    if (CurrentOrigin%nParticle > 0) then
                        do j = WS_JLB, WS_JUB
                        do i = WS_ILB, WS_IUB
                            OilGridThick2D(i,j) = Me%EulerModel(em)%OilSpreading(ig)%GridThickness (i,j) * &
                                                  1e6 * (1.0 - Me%ExternalVar%VWaterContent) 
                        enddo
                        enddo                        

                        !HDF 5
                        call HDF5WriteData        (Me%ObjHDF5(em),                       &
                                                   "/Results/"//trim(CurrentOrigin%Name)        &
                                                   //"/Data_2D/Thickness_2D",                   &
                                                   "Thickness_2D",                              &
                                                   "microns",                                   &
                                                   Array2D = OilGridThick2D,                    &
                                                   OutputNumber = OutputNumber)
!                    endif

                CurrentOrigin => CurrentOrigin%Next
                enddo CurrOr

            enddo Group
            
            deallocate (OilGridThick2D )

        !enddo em1

    end subroutine WriteOilGridThickness


    !--------------------------------------------------------------------------

    subroutine WriteOilGridConcentration(em, OutputNumber) 

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB
        integer                                     :: ig
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB


        !em = 1

        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)


Group:  do ig = 1, Me%nGroups

            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif

                !Just writes the output if there are particle
!                if (CurrentOrigin%nParticle > 0) then
                    !OilGridConc2D = CurrentOrigin%OilGridConcentration

                    !HDF 5
                    call HDF5WriteData        (Me%ObjHDF5(em),                       &
                                               "/Results/"//trim(CurrentOrigin%Name)        &
                                               //"/Data_2D/OilConcentration_2D",            &
                                               "OilConcentration_2D",                       &
                                               "ppm",                                       &
                                               Array2D = Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration,   &
                                               OutputNumber = OutputNumber)


!                endif

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

        enddo Group

    end subroutine WriteOilGridConcentration

    !--------------------------------------------------------------------------
   
    subroutine WriteHNSGridConc2D (em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber
  

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB
        integer                                     :: ig
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB

        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)

Group:  do ig = 1, Me%nGroups

            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif

                !Just writes the output if there are particle
!               if (CurrentOrigin%nParticle > 0) then
                    
                    !Corrected dataset names to be the same as group name
                    !HDF 5
                                              !"Air Concentration in surface",                      &
                    call HDF5WriteData        (Me%ObjHDF5(em),                                      &
                                               "/Results/"//trim(CurrentOrigin%Name)                &
                                               //"/Data_2D/AirConcentration_2D",                    &
                                               "AirConcentration_2D",                               &
                                               "mg/m3",                                             &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridAirConc2D,   &
                                               OutputNumber = OutputNumber)
                    
                                               !"Surface Floating Mass",                       &
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/SurfaceFloatingMass_2D",            &
                                               "SurfaceFloatingMass_2D",                       &
                                               "kg",                                           &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridSurfaceFloatingMass2D, &
                                               OutputNumber = OutputNumber)
                    
                                               !"Dissolved Mass in Water Column",              &
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DissolvedMass_2D",                  &
                                               "DissolvedMass_2D",                             &
                                               "kg",                                           &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D, &
                                               OutputNumber = OutputNumber)
                    
                                               !"Dissolved Concentration in Water Column",     &
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DissolvedConcentration_2D",         &
                                               "DissolvedConcentration_2D",                    &
                                               "mg/m3",                                        &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D, &
                                               OutputNumber = OutputNumber)

                                               !"Dissolved Maximum Concentration in Water Column", &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DissolvedMaximumConcentration_2D",  &
                                               "DissolvedMaximumConcentration_2D",             &
                                               "mg/m3",                                        &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Droplets Mass in Water Column",     &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DropletsMass_2D",                   &
                                               "DropletsMass_2D",                              &
                                               "kg",                                           &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D, &
                                               OutputNumber = OutputNumber)

                                               !"Droplets Concentration in Water Column",      &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DropletsConcentration_2D",          &
                                               "DropletsConcentration_2D",                     &
                                               "mg/m3",                                        &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D, &
                                               OutputNumber = OutputNumber)

                                               !"Droplets Maximum Concentration in Water Column",     &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DropletsMaximumConcentration_2D",   &
                                               "DropletsMaximumConcentration_2D",              &
                                               "mg/m3",                                        &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Particulate Mass in Water Column",   &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/SuspendedParticulateMass_2D",       &
                                               "SuspendedParticulateMass_2D",                  &
                                               "kg",                                           &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Particulate Concentration in Water Column",    &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/SuspendedParticulateConcentration_2D", &
                                               "SuspendedParticulateConcentration_2D",          &
                                               "mg/m3",                                         &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Particulate Maximum Concentration in Water Column",   &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                                   &
                                               "/Results/"//trim(CurrentOrigin%Name)                             &
                                               //"/Data_2D/SuspendedParticulateMaximumConcentration_2D",         &
                                               "SuspendedParticulateMaximumConcentration_2D",                    &
                                               "mg/m3",                                                          &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D, &
                                               OutputNumber = OutputNumber)

                                               !"Deposited Particulate Mass",                  &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DepositedParticulateMass_2D",       &
                                               "DepositedParticulateMass_2D",                  &
                                               "kg",                                           &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMass2D, &
                                               OutputNumber = OutputNumber)

                                               !"Deposited Particulate Mass Per Unit Area",     &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_2D/DepositedParticulateMassPerArea_2D", &
                                               "DepositedParticulateMassPerArea_2D",           &
                                               "mg/m3",                                        &
                                               Array2D = Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D, &
                                               OutputNumber = OutputNumber)

!                endif

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

        enddo Group

    end subroutine WriteHNSGridConc2D

    !--------------------------------------------------------------------------

    subroutine WriteOilGridConcentration3D (em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: ig
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB

        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)


Group:  do ig = 1, Me%nGroups

            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif

                !Just writes the output if there are particle
!                if (CurrentOrigin%nParticle > 0) then
!                   OilGridConc3D = CurrentOrigin%OilGridConcentration3D

                    !HDF 5
                    call HDF5WriteData        (Me%ObjHDF5(em),                              &
                                               "/Results/"//trim(CurrentOrigin%Name)        &
                                               //"/Data_3D/OilConcentration_3D",            &
                                               "OilConcentration_3D",                       &
                                               "Kg/m3",                                     &
                                               Array3D = Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration3D, &
                                               OutputNumber = OutputNumber)


!                endif

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

        enddo Group


    end subroutine WriteOilGridConcentration3D

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
   
    subroutine WriteOilGridDissolution3D (em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber
  

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: ig
        !real, dimension(:, :, :), pointer           :: OilDissolution3D 
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB


        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)


        !Allocate GridVolume, GridMass
        !allocate (OilDissolution3D (ILB:IUB, JLB:JUB, KLB:KUB))

Group:  do ig = 1, Me%nGroups

            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif

                !Just writes the output if there are particle
!               if (CurrentOrigin%nParticle > 0) then
                    !OilDissolution3D = Me%EulerModel(em)%OilSpreading(ig)%OilGridDissolution3D

                    !HDF 5
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/Dissolution_3D",                    &
                                               "Dissolution_3D",                               &
                                               "Kg/m3",                                        &
                                               Array3D = Me%EulerModel(em)%OilSpreading(ig)%OilGridDissolution3D,   &
                                               OutputNumber = OutputNumber)


!                endif

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

        enddo Group

        !deallocate (OilDissolution3D )


    end subroutine WriteOilGridDissolution3D

    !--------------------------------------------------------------------------
   
    subroutine WriteHNSGridConc3D    (em, OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: em, OutputNumber
  

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: ig
        character(StringLength)                     :: AuxChar
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB
        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)

Group:  do ig = 1, Me%nGroups

            !Writes the Group to an auxiliar string
            write (AuxChar, fmt='(i3)') ig

            CurrentOrigin => Me%FirstOrigin
CurrOr:     do while (associated(CurrentOrigin))

                if (CurrentOrigin%GroupID /= ig) then
                    CurrentOrigin => CurrentOrigin%Next
                    cycle
                endif

                !Just writes the output if there are particle
!               if (CurrentOrigin%nParticle > 0) then
                    
                    !Corrected dataset names to be the same as group name
                    !HDF 5
                                               !"Dissolved Mass",                              &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/DissolvedMass_3D",                  &
                                               "DissolvedMass_3D",                             &
                                               "kg",                                           &
                                               Array3D = Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D, &
                                               OutputNumber = OutputNumber)

                                               !"Dissolved Concentration",                      &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/DissolvedConcentration_3D",         &
                                               "DissolvedConcentration_3D",                    &
                                               "mg/m3",                                        &
                                               Array3D = Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Droplets Mass",                      &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/DropletsMass_3D",                   &
                                               "DropletsMass_3D",                              &
                                               "kg",                                           &
                                               Array3D = Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D, &
                                               OutputNumber = OutputNumber)

                                               !"Droplets Concentration",                      &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/DropletsConcentration_3D",          &
                                               "DropletsConcentration_3D",                     &
                                               "mg/m3",                                        &
                                               Array3D = Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Particulate Mass",                  &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/SuspendedParticulateMass_3D",       &
                                               "SuspendedParticulateMass_3D",                  &
                                               "kg",                                           &
                                               Array3D = Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D, &
                                               OutputNumber = OutputNumber)

                                               !"Suspended Particulate Concentration",         &                    
                    call HDF5WriteData        (Me%ObjHDF5(em),                                 &
                                               "/Results/"//trim(CurrentOrigin%Name)           &
                                               //"/Data_3D/SuspendedParticulateConcentration_3D", &
                                               "SuspendedParticulateConcentration_3D",         &
                                               "mg/m3",                                        &
                                               Array3D = Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D, &
                                               OutputNumber = OutputNumber)
!                endif

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

        enddo Group

    end subroutine WriteHNSGridConc3D

    !--------------------------------------------------------------------------

    real(8) function GeographicCoordinates (em, Position, Direction)

        !Arguments-------------------------------------------------------------
   
        integer                                     :: em
        type (T_Position)                           :: Position
        integer                                     :: Direction

        !Local-----------------------------------------------------------------



        if (Me%EulerModel(em)%Grid%HaveLatLongGrid) then

             if (Direction == 1) then
                GeographicCoordinates = Position%CoordX
            else
                GeographicCoordinates = Position%CoordY
            endif

        else
            if (Direction == 1) then
                GeographicCoordinates = Me%EulerModel(em)%Grid%LongDefault
            else
                GeographicCoordinates = Me%EulerModel(em)%Grid%LatDefault
            endif
        endif


    end function GeographicCoordinates 

    !--------------------------------------------------------------------------

    subroutine UpdateParticleState

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: emp, ig
        integer                                     :: i, j, k
        integer                                     :: kbottom        

            CurrentOrigin => Me%FirstOrigin
    CurrOr: do while (associated(CurrentOrigin))
                ig = CurrentOrigin%GroupID

                CurrentPartic => CurrentOrigin%FirstPartic

    CurrPartic: do while (associated(CurrentPartic))

                    i   = CurrentPartic%Position%I
                    j   = CurrentPartic%Position%J
                    k   = CurrentPartic%Position%K
                    emp = CurrentPartic%Position%ModelID

                    !default tracer status = on water column
                    CurrentPartic%ParticleState = 1 

                    !tracer status = on sea surface
                    If (CurrentPartic%Position%Surface)     CurrentPartic%ParticleState = 5             

                    !tracer status = beached
                    If (CurrentPartic%Beached)              CurrentPartic%ParticleState = 10             

                    !tracer status = at the bottom
                    kbottom = Me%EulerModel(emp)%KFloor(i, j)
                    
                    if (CurrentOrigin%State%FloatingObject) then
                        CurrentPartic%ParticleState = nint(CurrentOrigin%FloatingObject%ImmersionRatio * 0.1)
                    end if
                    
                    if (kbottom >= 1) then
                    
                        if (CurrentOrigin%State%Deposition) then
                            if (CurrentPartic%Position%Z >=         &
                            (Me%EulerModel(emp)%SZZ(i, j, kbottom -1)- CurrentOrigin%Deposition%BottomDistance)) &
                            CurrentPartic%ParticleState = 00
                        else
                            if (CurrentPartic%Position%Z >= Me%EulerModel(emp)%SZZ(i, j, kbottom -1)) &
                            CurrentPartic%ParticleState = 00
                        endif
                    
                    endif

                    CurrentPartic => CurrentPartic%Next
    
                enddo CurrPartic

            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

    end subroutine UpdateParticleState
    
    !--------------------------------------------------------------------------

    subroutine WriteIndividualTracerOutput

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Partic), pointer                    :: CurrentPartic
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, n, OutPutNumber
        integer                                     :: STAT_CALL
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB
        integer                                     :: em, ig
        real, dimension(:, :), pointer              :: OilGridThick2D 
        real                                        :: RunPeriod
        integer                                     :: TracerStatus
        real, dimension(:, :, :), pointer           :: Temperature3D
        real                                        :: WaterTemperature
        real, dimension(:, :, :), pointer           :: Velocity_U, Velocity_V
        real                                        :: CellI, CellJ
        real                                        :: BalX, BalY
        real                                        :: U, V
        real                                        :: WindX, WindY, WindIntensityInKnots, CurrentsIntensityInKnots
        real                                        :: CurrentsDirection, WindDirection
        real                                        :: MassOil
        integer                                     :: kbottom     
        real                                        :: NearCoastDistance
        logical                                     :: InsideDomain   
        real                                        :: ParticArea
        real                                        :: ParticVolume
        real                                        :: Mass
        
        WaterTemperature = -99
       
        RunPeriod = (Me%Now - Me%ExternalVar%BeginTime) / 3600

        NearCoastDistance = Me%NearCoastDistance        
        OutPutNumber = Me%OutPut%NextOutPut
if1:    if (Me%Now >= Me%OutPut%OutTime(OutPutNumber)) then 

            CurrentOrigin => Me%FirstOrigin
    CurrOr: do while (associated(CurrentOrigin))
                em = CurrentOrigin%Position%ModelID
                ig = CurrentOrigin%GroupID
   
                ILB    = Me%EulerModel(em)%Size%ILB
                IUB    = Me%EulerModel(em)%Size%IUB
                JLB    = Me%EulerModel(em)%Size%JLB
                JUB    = Me%EulerModel(em)%Size%JUB
                KLB    = Me%EulerModel(em)%Size%KLB
                KUB    = Me%EulerModel(em)%Size%KUB

                !Allocate GridVolume, GridMass
                allocate (OilGridThick2D (ILB:IUB, JLB:JUB))

                WS_ILB = Me%EulerModel(em)%WorkSize%ILB
                WS_IUB = Me%EulerModel(em)%WorkSize%IUB
                WS_JLB = Me%EulerModel(em)%WorkSize%JLB
                WS_JUB = Me%EulerModel(em)%WorkSize%JUB
                WS_KLB = Me%EulerModel(em)%WorkSize%KLB
                WS_KUB = Me%EulerModel(em)%WorkSize%KUB

            !Sets limits for next write operations
            call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                                  WS_KLB, WS_KUB)

                !Shorten Var
                if (Me%OverLay) then
                    Velocity_U => Me%EulerModel(em)%OverLay%VelUFinal
                    Velocity_V => Me%EulerModel(em)%OverLay%VelVFinal
                else
                    Velocity_U => Me%EulerModel(em)%Velocity_U
                    Velocity_V => Me%EulerModel(em)%Velocity_V
                endif

                !Gets the temperature from the Eulerian model
                call GetConcentration(Me%EulerModel(em)%ObjWaterProperties,             &
                                      ConcentrationX    = Temperature3D,                &
                                      PropertyXIDNumber = Temperature_,                 &
                                      STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteIndividualTracerOutput - ModuleLagrangianGlobal - ERR01'

                If (CurrentOrigin%State%Oil)   then
                    call ReadLockEulerianDensity()
                    
                    !Just writes the output if there are particle
                    if (CurrentOrigin%nParticle > 0) then
                        !thickness in um
                        OilGridThick2D = Me%EulerModel(em)%OilSpreading(ig)%GridThickness * 1e6 &
                                         * (1 - Me%ExternalVar%VWaterContent)
                    endif
                end if

                ParticArea = Me%ExternalVar%AreaTotal
                
                Write(CurrentOrigin%troUnit,"(4X, i6)") CurrentOrigin%nParticle

                 !Compute the total volume tracer by cell 
                CurrentPartic => CurrentOrigin%FirstPartic
                n = 0
    CurrPartic: do while (associated(CurrentPartic))
                    n = n + 1
                    ParticVolume          = CurrentPartic%Geometry%Volume
                    
                If (CurrentOrigin%State%Oil)   then
                    MassOil               = CurrentPartic%Geometry%VolumeOil * Me%ExternalVar%OilDensity
                end if

                    i  = CurrentPartic%Position%I
                    j  = CurrentPartic%Position%J
                    k  = CurrentPartic%Position%K
                    
                    !Cell Postition
                    CellI = CurrentPartic%Position%CellI
                    CellJ = CurrentPartic%Position%CellJ

                    !Fraction of the cell
                    BALX  = CellJ - int(CellJ)
                    BALY  = CellI - int(CellI)


                    !default tracer status = on water column
                    TracerStatus = 1 

                    !tracer status = on sea surface
                    If (CurrentPartic%Position%Surface)     TracerStatus = 5             

                    !tracer status = beached
                    If (CurrentPartic%Beached)              TracerStatus = 10             

                    !check if tracer is near coastline
                    
                    InsideDomain = .true.
                    
                    if (j <= WS_JLB + 1) InsideDomain = .false.
                    if (i <= WS_ILB + 1) InsideDomain = .false.
                    
                    if (j >= WS_JUB - 1) InsideDomain = .false.
                    if (i >= WS_IUB - 1) InsideDomain = .false.
                    
IfParticNotBeached: if (.NOT. CurrentPartic%Beached .and. InsideDomain) then

                            if ((Me%EulerModel(em)%OpenPoints3D(i, j+1, k).NE. OpenPoint)  .AND. &
                                  ((1-BALX) *  (Me%EulerModel(em)%Grid%ParticXX(i, j+1) - &
                                   Me%EulerModel(em)%Grid%ParticXX(i, j)) .LT. (NearCoastDistance + F_BLimit(em,i,j+1)))) then
                                
                                if (TracerStatus .EQ. 1) TracerStatus = 110
                                if (TracerStatus .EQ. 5) TracerStatus = 510

           
                            else if ((Me%EulerModel(em)%OpenPoints3D(i, j-1, k).NE. OpenPoint)  .AND.  &
                                       (BALX *  (Me%EulerModel(em)%Grid%ParticXX(i, j+1) - &
                                        Me%EulerModel(em)%Grid%ParticXX(i, j)).LT. (NearCoastDistance + F_BLimit(em,i,j-1)))) then

                                if (TracerStatus .EQ. 1) TracerStatus = 110
                                if (TracerStatus .EQ. 5) TracerStatus = 510
         
                            else if ((Me%EulerModel(em)%OpenPoints3D(i+1, j, k).NE. OpenPoint)  .AND. &
                                       ((1-BALY) *  (Me%EulerModel(em)%Grid%ParticYY(i+1, j) - &
                                       Me%EulerModel(em)%Grid%ParticYY(i, j)).LT. (NearCoastDistance + F_BLimit(em,i+1,j)))) then

                                if (TracerStatus .EQ. 1) TracerStatus = 110
                                if (TracerStatus .EQ. 5) TracerStatus = 510
           
                            else if ((Me%EulerModel(em)%OpenPoints3D(i-1, j, k).NE. OpenPoint)  .AND. &
                                       (BALY *  (Me%EulerModel(em)%Grid%ParticYY(i+1, j) -            &
                                       Me%EulerModel(em)%Grid%ParticYY(i, j)) .LT. (NearCoastDistance + F_BLimit(em,i-1,j)))) then

                                if (TracerStatus .EQ. 1) TracerStatus = 110
                                if (TracerStatus .EQ. 5) TracerStatus = 510
                    
                            end if
                        
endif IfParticNotBeached


                    If (CurrentOrigin%State%Oil)   then
                        Mass = (1 - CurrentPartic%VWaterContent)*CurrentPartic%Geometry%Volume*Me%ExternalVar%OilDensity  + &
                               (CurrentPartic%VWaterContent)    *CurrentPartic%Geometry%Volume*Me%EulerModel(em)%Density (i, j, k)
                    end if
                    
                    !tracer status = at the bottom
                    kbottom = Me%EulerModel(em)%KFloor(i, j)
                    
                    if (CurrentOrigin%State%FloatingObject) then
                        TracerStatus = nint(CurrentOrigin%FloatingObject%ImmersionRatio * 0.1)
                    end if
                    
                    if (CurrentOrigin%State%Deposition) then
                        if (CurrentPartic%Position%Z >=         &
                        (Me%EulerModel(em)%SZZ(i, j, kbottom -1)- CurrentOrigin%Deposition%BottomDistance)) TracerStatus = 00
                    else
                        if (CurrentPartic%Position%Z >= Me%EulerModel(em)%SZZ(i, j, kbottom -1)) TracerStatus = 00
                    endif
                    



                    U = CurrentPartic%CurrentX
                    V = CurrentPartic%CurrentY

                    !Velocity due wind                      
                    WindX = CurrentPartic%WindX
                    WindY = CurrentPartic%WindY
                    
                    WindIntensityInKnots    = sqrt((WindX)**2. + (WindY)**2.) * 19.4384449411995
                    CurrentsIntensityInKnots= sqrt((U)**2. + (V)**2.) * 19.4384449411995
                    CurrentsDirection       = atan2(u,v) * 180. / Pi + 180
                    WindDirection           = atan2(WindX,WindY) * 180. / Pi + 180
                    
                    WaterTemperature        = Temperature3D             (i, j, k)


                100 format(4X, i6,4X,f12.2, 4X, f12.5, 4X, f12.5, 4X, i3, 4X, i6, 4X,   &
                           i7, 4X,  i3, 4X, i3, 4X, i3, 4X, f12.2, 4X, f12.2, 4X, i3.3, &
                           i3.3, 4X, i3.3, i3.3, 4X, i3, 4X, i3, 4X, f6.2, 4X, f12.2, 4X, i7, 4X, f12.2)
                110 format(4X, i6,4X,f12.2, 4X, f12.5, 4X, f12.5, 4X, i3, 4X, i3, 4X, i3, 4X,   &
                           i3.3, i3.3, 4X, i3.3, i3.3, 4X, i3, 4X, i3, 4X, f6.2, 4X, f12.2)
                                                                 
                    If (CurrentOrigin%State%Oil) then
                        Write(CurrentOrigin%troUnit,100) n, &
                        RunPeriod, &
                        GeographicCoordinates(em, CurrentPartic%Position, 2), &
                        GeographicCoordinates(em, CurrentPartic%Position, 1), &
                        TracerStatus, &
                        nint(OilGridThick2D(i,j)), &
                        nint(MassOil), &
                        nint(CurrentPartic%FMEvaporated  * 100), &
                        nint(CurrentPartic%VWaterContent * 100), &
                        nint(CurrentPartic%FMDispersed   * 100), &
                        CurrentPartic%OilViscosity, &
                        CurrentPartic%OilDensity, &
                        nint(WindDirection), &
                        nint(WindIntensityInKnots), &
                        nint(CurrentsDirection), &
                        nint(CurrentsIntensityInKnots), &
                        nint(WaterTemperature), &
                        -99, &
                        - CurrentPartic%Position%Z, &
                        ParticArea, &
                        nint(Mass), &
                        ParticVolume

                    Else                 
                    
                        Write(CurrentOrigin%troUnit,110) n, &
                        RunPeriod, &
                        GeographicCoordinates(em, CurrentPartic%Position, 2), &
                        GeographicCoordinates(em, CurrentPartic%Position, 1), &
                        CurrentPartic%Position%I, &
                        CurrentPartic%Position%J, &
                        TracerStatus, &                  
                        nint(WindDirection), &
                        nint(WindIntensityInKnots), &
                        nint(CurrentsDirection), &
                        nint(CurrentsIntensityInKnots), &
                        nint(WaterTemperature), &
                        -99, &
                        - CurrentPartic%Position%Z, & 
                        ParticVolume
                    End if

                    CurrentPartic => CurrentPartic%Next
    
                enddo CurrPartic
    
            deallocate (OilGridThick2D )
       
            !Ungets Concentration from the eulerian module
            call UngetWaterProperties (Me%EulerModel(em)%ObjWaterProperties, Temperature3D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteIndividualTracerOutput - ModuleLagrangianGlobal - ERR10'
            
            If (CurrentOrigin%State%Oil)   then
                call ReadUnLockEulerianDensity()
            end if
            
            CurrentOrigin => CurrentOrigin%Next
            enddo CurrOr

        endif if1


    end subroutine WriteIndividualTracerOutput
    
    subroutine WriteOutputEnvelopeTimeSerie(originName, Envelope1DX, Envelope1DY, NumberOfBoundaryNodes)

        character(Len=*)                    :: OriginName
        real(8),   dimension(:), pointer    :: Envelope1DX, Envelope1DY
        integer                             :: NumberOfBoundaryNodes
        integer                             :: i
        type (T_Origin), pointer            :: CurrentOrigin
        real                                :: RunPeriod

        CurrentOrigin => Me%FirstOrigin
        do while (associated(CurrentOrigin))
            if (CurrentOrigin%Name == OriginName) then

                RunPeriod = (Me%Now - Me%ExternalVar%BeginTime) / 3600
              
11              format(f7.2, A2)                                     
12              format(f11.7, f11.7)                                     
13              format(A2, f11.7, f11.7)                                      
14              format(A2, f11.7, f11.7)                                      

                Write (CurrentOrigin%eroUnit, 11, ADVANCE='NO') RunPeriod, ","
                Write(CurrentOrigin%eroUnit, 12, ADVANCE='NO') Envelope1DY(1), Envelope1DX(1)                    
                do i = 2, NumberOfBoundaryNodes - 1
                    Write(CurrentOrigin%eroUnit,13, ADVANCE="NO") ",", Envelope1DY(i), Envelope1DX(i)
                enddo
                Write(CurrentOrigin%eroUnit,14) ",", Envelope1DY(NumberOfBoundaryNodes), &
                                                Envelope1DX(NumberOfBoundaryNodes)                    
            endif
                
            CurrentOrigin => CurrentOrigin%Next
        enddo
    

    end subroutine
    
    
    real function F_BLimit(em, i,j)

        !Arguments-------------------------------------------------------------
        integer                                        :: em, i, j

        !Begin-------------------------------------------------------------

        if (Me%State%AssociateBeachProb) then
            F_BLimit = Me%EulerModel(em)%BeachingLimit(i,j)    
        else
            F_BLimit = 0.    
        end if

    end function F_BLimit
    
    !--------------------------------------------------------------------------

    subroutine WriteMonitorOutput(OutputNumber)

        !Arguments-------------------------------------------------------------
        integer                                     :: OutputNumber

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        integer                                     :: ILB, IUB, JLB, JUB, KLB, KUB
        integer                                     :: i, j, k, Box
        integer                                     :: STAT_CALL
        real,    dimension(:, :, :), pointer        :: OutputMatrix
        integer, dimension(:, :, :), pointer        :: MonitorBoxes
        integer                                     :: WS_ILB, WS_IUB, WS_JLB, WS_JUB
        integer                                     :: WS_KLB, WS_KUB, em

        em = 1

        !Shorten
        ILB    = Me%EulerModel(em)%Size%ILB
        IUB    = Me%EulerModel(em)%Size%IUB
        JLB    = Me%EulerModel(em)%Size%JLB
        JUB    = Me%EulerModel(em)%Size%JUB
        KLB    = Me%EulerModel(em)%Size%KLB
        KUB    = Me%EulerModel(em)%Size%KUB

        WS_ILB = Me%EulerModel(em)%WorkSize%ILB
        WS_IUB = Me%EulerModel(em)%WorkSize%IUB
        WS_JLB = Me%EulerModel(em)%WorkSize%JLB
        WS_JUB = Me%EulerModel(em)%WorkSize%JUB
        WS_KLB = Me%EulerModel(em)%WorkSize%KLB
        WS_KUB = Me%EulerModel(em)%WorkSize%KUB

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5(em), WS_ILB, WS_IUB, WS_JLB, WS_JUB,     &
                              WS_KLB, WS_KUB)


        allocate (OutputMatrix (ILB:IUB, JLB:JUB, KLB:KUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'WriteMonitorOutput - ModuleLagrangianGlobal - ERR00'

        !Get the boxes
        call GetBoxes(Me%EulerModel(em)%ObjMonBox, MonitorBoxes, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'WriteMonitorOutput - ModuleLagrangianGlobal - ERR01'

        !For every origin writes the instant percentage of the instant volume contributed to 
        !a given monitoring box, refering to the instant volume of the Monitoring Box
        CurrentOrigin => Me%FirstOrigin
        do while (associated(CurrentOrigin))
            OutputMatrix = null_real
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                Box = MonitorBoxes(i, j, k)
                if (Box > 0) then
                    OutputMatrix(i, j, k) = Me%EulerModel(em)%Monitor%InstVolumeByOrigin (Box, CurrentOrigin%ID) / &
                                            (max(dble(AllmostZero),Me%EulerModel(em)%Monitor%InstBoxVolume      (Box) * 100.))
                endif
            enddo
            enddo
            enddo


            !HDF 5
            call HDF5WriteData         (Me%ObjHDF5(em),                                &
                                        "/Results/"//trim(CurrentOrigin%Name)//"/InstVolume", &
                                        "InstVolumeContribution",  "%",                       &
                                        Array3D = OutputMatrix,                               &
                                        OutputNumber = OutputNumber,       &
                                        STAT = STAT_CALL)

            CurrentOrigin => CurrentOrigin%Next
        enddo


        !For every origin writes the percentage of the integrated volume contributed to 
        !a given monitoring box, refering to the integrated volume of the Monitoring Box
        CurrentOrigin => Me%FirstOrigin
        do while (associated(CurrentOrigin))
            OutputMatrix = null_real
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                Box = MonitorBoxes(i, j, k)
                if (Box > 0) then
                    OutputMatrix(i, j, k) = Me%EulerModel(em)%Monitor%IntgVolumeByOrigin (Box, CurrentOrigin%ID) / &
                                             (max(dble(AllmostZero),Me%EulerModel(em)%Monitor%IntgBoxVolume      (Box) * 100.))
                endif
            enddo
            enddo
            enddo


            !HDF 5
            call HDF5WriteData         (Me%ObjHDF5(em),                                &
                                        "/Results/"//trim(CurrentOrigin%Name)//"/IntgVolume", &
                                        "IntgVolumeContribution",  "%",                       &
                                        Array3D = OutputMatrix,                               &
                                        OutputNumber = OutputNumber,                    &
                                        STAT = STAT_CALL)


            CurrentOrigin => CurrentOrigin%Next
        enddo


        If (Me%State%MonitorPropMass) then

        !For every origin writes the instant percentage of the instant mass contributed to 
        !a given monitoring box, refering to the instant mass of the Monitoring Box
        CurrentOrigin => Me%FirstOrigin
        do while (associated(CurrentOrigin))
            OutputMatrix = null_real
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                Box = MonitorBoxes(i, j, k)
                if (Box > 0) then
                    OutputMatrix(i, j, k) = Me%EulerModel(em)%Monitor%InstMassByOrigin (Box, CurrentOrigin%ID) / &
                                            (max(dble(AllmostZero),Me%EulerModel(em)%Monitor%InstBoxMass      (Box) * 100.))
                endif
            enddo
            enddo
            enddo


            !HDF 5
            call HDF5WriteData         (Me%ObjHDF5(em),                                &
                                        "/Results/"//trim(CurrentOrigin%Name)//"/InstMass", &
                                        "InstMassContribution",  "%",                       &
                                        Array3D = OutputMatrix,                               &
                                        OutputNumber = OutPutNumber,       &
                                        STAT = STAT_CALL)

            CurrentOrigin => CurrentOrigin%Next
        enddo


        End IF

        !For every monitoring box fills as many cells as the get contributions (in volume)
        !from a given origin. The rest of the cells of the monitoring box is filled with the 
        !value zero
        !Calculates the number of cells in each box
        Me%EulerModel(em)%Monitor%NumberOfCellsPerBox = 0
        do Box = 1,  Me%EulerModel(em)%Monitor%NumberOfBoxes
        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB
            if (MonitorBoxes(i, j, k) == Box .and. Me%EulerModel(em)%OpenPoints3D(i, j, k) == OpenPoint) then
                Me%EulerModel(em)%Monitor%NumberOfCellsPerBox(Box) = Me%EulerModel(em)%Monitor%NumberOfCellsPerBox(Box) + 1
            endif
        enddo
        enddo
        enddo
        enddo
        !Number of Cells to fill
        Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin = 0
        CurrentOrigin => Me%FirstOrigin
        do while (associated(CurrentOrigin))
            do Box = 1,  Me%EulerModel(em)%Monitor%NumberOfBoxes
            do k = KLB, KUB
            do j = JLB, JUB
            do i = ILB, IUB
                if (MonitorBoxes(i, j, k) == Box) then
                    Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin    (Box, CurrentOrigin%ID) = &
                        int(Me%EulerModel(em)%Monitor%NumberOfCellsPerBox(Box) *                   &
                            Me%EulerModel(em)%Monitor%InstVolumeByOrigin (Box, CurrentOrigin%ID) / &
                            max(dble(AllmostZero),Me%EulerModel(em)%Monitor%InstBoxVolume      (Box)))
                endif
            enddo
            enddo
            enddo
            enddo
            CurrentOrigin => CurrentOrigin%Next
        enddo
        !Outputs
        OutputMatrix = null_real
        do k = KLB, KUB
        do j = JLB, JUB
        do i = ILB, IUB
            Box = MonitorBoxes(i, j, k)
            CurrentOrigin => Me%FirstOrigin
            if (Box > 0 .and. Me%EulerModel(em)%OpenPoints3D(i, j, k) == OpenPoint) then

                OutputMatrix(i, j, k) = 0.
                do while (Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin(Box, CurrentOrigin%ID) == 0)
                    CurrentOrigin => CurrentOrigin%Next
                    if (.not. associated(CurrentOrigin)) exit
                enddo

                if (associated(CurrentOrigin)) then
                    if (Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin(Box, CurrentOrigin%ID) > 0) then
                        OutputMatrix(i, j, k) = CurrentOrigin%ID
                        Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin(Box, CurrentOrigin%ID) = &
                            Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin(Box, CurrentOrigin%ID) - 1
                    endif
                endif
            endif
        enddo
        enddo
        enddo
            


        !HDF 5
        call HDF5WriteData         (Me%ObjHDF5(em),                          &
                                    "/Results/Monitor",                             &
                                    "VolumeContributedByOrigin",  "%",              &
                                    Array3D = OutputMatrix,                         &
                                    OutputNumber = OutPutNumber, &
                                    STAT = STAT_CALL)

        !Unget The Boxes
        call UngetBoxDif(Me%EulerModel(em)%ObjMonBox, MonitorBoxes, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'WriteMonitorOutput - ModuleLagrangianGlobal - ERR02'

        deallocate (OutputMatrix            )

    end subroutine WriteMonitorOutput

    logical function findLarvaeInOrigin(CurrentOrigin, LarvaePtr)
                
        type(T_Origin), pointer,intent(in)      :: CurrentOrigin
        
        type(T_Larvae), pointer,intent(out)     :: LarvaePtr
        
        type(T_Property), pointer               :: CurrentProperty        
                
        findLarvaeInOrigin = .false.
                
        CurrentProperty => CurrentOrigin%FirstProperty
                    
        do while ( associated(CurrentProperty) )
                
            if( CurrentProperty%ID == Larvae_ ) then
                    
                findLarvaeInOrigin = .true.
                
                LarvaePtr => CurrentProperty%Larvae
                   
            endif
                        
            CurrentProperty => CurrentProperty%Next
                    
        enddo
                
    end function findLarvaeInOrigin
    
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCT 

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    subroutine KillLagrangianGlobal (LagrangianID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_
        integer                                     :: nUsers

        !----------------------------------------------------------------------
           
        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_)    

cd1:    if (ready_ .NE. OFF_ERR_) then

            nUsers = DeassociateInstance(mLAGRANGIAN_,  Me%InstanceID)

            if (nUsers == 0) then

                call DeallocateInstance

                LagrangianID  = 0
                STAT_         = SUCCESS_

            end if

        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_



    end subroutine KillLagrangianGlobal

    !--------------------------------------------------------------------------
    subroutine DeallocateLagrangianGlobal (LagrangianID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        integer, optional                           :: STAT

        !Local-----------------------------------------------------------------
        type (T_Property),  pointer                 :: CurrentProperty
        integer                                     :: nB
        integer                                     :: STAT_, ready_
        integer                                     :: STAT_CALL, nUsers, em
        logical                                     :: WriteFinal

        !----------------------------------------------------------------------
           
        STAT_ = UNKNOWN_

        call Ready(LagrangianID, ready_)    

cd1:    if (ready_ .NE. OFF_ERR_) then

            if (Me%WritesTimeSerie) then
d3:             do em = 1, Me%EulerModelNumber
                    call KillTimeSerie(Me%EulerModel(em)%ObjTimeSerie, STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                        &
                        stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR10'
                enddo d3
            endif
            

            if (Me%State%Statistics) then

                call KillParticleStatistic 

            endif


            if (Me%OutPut%Write_) then
d4:             do em = 1, Me%EulerModelNumber
                    !Closes the transient result file
                    call KillHDF5          (Me%ObjHDF5(em), STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR20'
                enddo d4
            endif

            WriteFinal = .true.

            if (Me%RunOnline) then
!#ifdef _CGI_
                WriteFinal = .false.
!#endif
            endif
            !Writes the Final Output
            if (WriteFinal) call WriteFinalPartic(Final = .true.)

d1:         do em = 1, Me%EulerModelNumber

                !Kills the Light
                if (Me%State%WQM .or. Me%State%T90Compute) then
                    call KillLight(em) 
                endif

                !Kills Monitoring
                if (Me%State%Monitor) then

                    do nB = 1, Me%EulerModel(em)%Monitor%NumberOfBoxes
                        call KillTimeSerie (Me%EulerModel(em)%Monitor%ObjTimeSerie(nB), STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR30'
                    enddo

                    deallocate (Me%EulerModel(em)%Monitor%SurfaceBoxVolume           )
                    deallocate (Me%EulerModel(em)%Monitor%InstBoxVolume              )
                    deallocate (Me%EulerModel(em)%Monitor%InstVolumeByOrigin         )
                    deallocate (Me%EulerModel(em)%Monitor%InstBoxMass                )
                    deallocate (Me%EulerModel(em)%Monitor%InstMassByOrigin           )
                    deallocate (Me%EulerModel(em)%Monitor%IntgBoxVolume              )
                    deallocate (Me%EulerModel(em)%Monitor%IntgVolumeByOrigin         )
                    deallocate (Me%EulerModel(em)%Monitor%NumberOfCellsPerBox        )
                    deallocate (Me%EulerModel(em)%Monitor%NumberOfCellsFromOrigin    )
                    deallocate (Me%EulerModel(em)%Monitor%InstBoxLogMass             )         
                    deallocate (Me%EulerModel(em)%Monitor%InstBoxConc                )
                    deallocate (Me%EulerModel(em)%Monitor%NumberOfTracers            )
                    deallocate (Me%EulerModel(em)%Monitor%InstBoxMassFractionByOrigin)
                    deallocate (Me%EulerModel(em)%Monitor%InstLogMassByOrigin        )
                    deallocate (Me%EulerModel(em)%Monitor%NumberOfTracersFromOrigin  )
                    deallocate (Me%EulerModel(em)%Monitor%ContaminationProbability   )    
                    deallocate (Me%EulerModel(em)%Monitor%AverageBoxContaminatedConc )
                    deallocate (Me%EulerModel(em)%Monitor%NbrBoxContaminatedTracers  )
                    deallocate (Me%EulerModel(em)%Monitor%VolBoxContaminatedTracers  )

                    call KillBoxDif (Me%EulerModel(em)%ObjMonBox, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR40'
                
                endif

                if (Me%State%EulerianMonitor) then

                    deallocate(Me%EulerModel(em)%EulerianMonitor%Mass)

                    call KillBoxDif (Me%EulerModel(em)%ObjEulMonBox, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR50'

                end if

                !Kills Oil-Beaching Properties
                if (Me%State%AssociateBeachProb) then
                    if (Me%State%HaveBeachingProbBox) then

                        call KillBoxDif(Me%EulerModel(em)%ObjBeachingProbBox, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR60'

                    end if

                    if (Me%State%HaveShoreTypeBox) then

                        call KillBoxDif(Me%EulerModel(em)%ObjShoreTypeBox, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR60'

                    end if
                    
                    deallocate (Me%EulerModel(em)%BeachingProbability)
                    deallocate (Me%EulerModel(em)%ShoreType)
                    deallocate (Me%EulerModel(em)%BeachingLimit)

                    deallocate (Me%EulerModel(em)%HorizontalBeachHoldingCapacity)
                    
                    deallocate (Me%EulerModel(em)%RemovalRateCoef)
                    deallocate (Me%EulerModel(em)%OldSurfaceDepth)
                                    
                end if
                
                if (Me%State%DistanceToCoast) then
                
                    deallocate(Me%EulerModel(em)%DistanceToCoast)
                
                endif
               

                if (Me%State%Deposition)  then

                    deallocate   (Me%EulerModel(em)%Lag2Euler%TauErosionGrid)
                    deallocate   (Me%EulerModel(em)%Lag2Euler%MassSedGrid   )

                endif

                if (Me%State%Filtration)  then

                    deallocate(Me%EulerModel(em)%RelativeMassFilter)

                    deallocate(Me%EulerModel(em)%MassFiltered)

                endif

            enddo d1
            
            if(Me%State%CalcPartDistToCoast)then
                deallocate(Me%AngleList)
                deallocate(Me%DistanceByDirection)
                deallocate(Me%Point)
            endif

            if (Me%State%Oil)  then
                if(Me%OutPut%ExportArrvlBeachTimes)then
                    call WriteArrivalBeachingTimes
                endif
                                
                if(Me%State%AssociateBeachProb)then
                    call WriteBeachingStats
                endif
                
                call DeAllocateOil
            endif

            if (Me%State%HNS) then
                call DeAllocateHNS
!                call KillTimeSerie(OriginToDelete%ObjTimeSerie, STAT = STAT_CALL)
!                if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR70'
            endif
            if (associated(Me%OriginDefault)) then
                CurrentProperty => Me%OriginDefault%FirstProperty
                do while (associated(CurrentProperty))

                    if (CurrentProperty%T90Variable .and. CurrentProperty%T90Var_Method == FromTimeSerie) then
                        call KillTimeSerie(CurrentProperty%TimeSerieT90, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR70'
                    endif

                    CurrentProperty => CurrentProperty%Next
                enddo

                nullify(CurrentProperty)

            endif

            !Kill the OriginList
            call DeallocateOriginList(Me%FirstOrigin, Me%nOrigins)

d2:         do em = 1, Me%EulerModelNumber

                !Kill Assimilation
                if (Me%Overlay) then

                    call KillAssimilation (Me%EulerModel(em)%ObjAssimilation,  STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR70'

                    deallocate (Me%EulerModel(em)%OverLay%VelUFinal)
                    deallocate (Me%EulerModel(em)%OverLay%VelVFinal)

                endif

                if (Me%EulerModel(em)%ObjBoxDif /= 0) then
                    call KillBoxDif (Me%EulerModel(em)%ObjBoxDif, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR80'
                endif

                !External Modules
                nUsers = DeassociateInstance (mTIME_,           Me%EulerModel(em)%ObjTime           )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR90'

                nUsers = DeassociateInstance (mGRIDDATA_,       Me%EulerModel(em)%ObjGridData       )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR100'

                nUsers = DeassociateInstance (mHORIZONTALMAP_,  Me%EulerModel(em)%ObjHorizontalMap  )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR110'

                nUsers = DeassociateInstance (mHORIZONTALGRID_, Me%EulerModel(em)%ObjHorizontalGrid )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR120'

                nUsers = DeassociateInstance (mGEOMETRY_,       Me%EulerModel(em)%ObjGeometry       )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR130'

                nUsers = DeassociateInstance (mMAP_,            Me%EulerModel(em)%ObjMap            )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR140'

                nUsers = DeassociateInstance (mHYDRODYNAMIC_,   Me%EulerModel(em)%ObjHydrodynamic   )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR150'

                nUsers = DeassociateInstance (mTURBULENCE_,     Me%EulerModel(em)%ObjTurbulence     )
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR160'

                nUsers = DeassociateInstance (mWATERPROPERTIES_,Me%EulerModel(em)%ObjWaterProperties)
                if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR170'

#ifndef _WAVES_
                if(Me%EulerModel(em)%ObjWaves /= 0)then
                    nUsers = DeassociateInstance (mWAVES_,  Me%EulerModel(em)%ObjWaves)
                    if (nUsers == 0) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR180'
                end if
#endif
            enddo d2
            
            if (Me%MeteoOcean%PropNumber>0) call KillMeteoOcean
            
#ifdef _LITTER_
            if (Me%LitterON) then
                call KillLitter(ObjLitterID   = Me%ObjLitter,                           &
                                  STAT          = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR190'
            endif                
#endif  

#ifdef _OUTPUT_GRID_
            call KillOutputGrid(ObjOutputGridID = Me%ObjOutputGrid,                     &
                                STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeallocateLagrangianGlobal - ModuleLagrangianGlobal - ERR200'
#endif  

            if (Me%State%MonitorLag) then
                call KillMonitorLag
            endif

            STAT_         = SUCCESS_

        else 
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_



    end subroutine DeallocateLagrangianGlobal

    !--------------------------------------------------------------------------
    
    subroutine KillMonitorLag

        !Arguments-------------------------------------------------------------
        
        !Local-----------------------------------------------------------------        
        integer                                     :: nP, STAT_CALL
        
        !Begin-----------------------------------------------------------------    
        
        do nP = 1, Me%MonitorLag%NumberOfPoly
            call KillTimeSerie(TimeSerieID = Me%MonitorLag%ObjTimeSerie(nP),            &
                               STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'KillMonitorLag - ModuleLagrangianGlobal - ERR10'        
            endif            
        enddo
        
        deallocate(Me%MonitorLag%ObjTimeSerie    )
        deallocate(Me%MonitorLag%Poly            )
        deallocate(Me%MonitorLag%NumTracersOrigin)

                    
    end subroutine KillMonitorLag    

    !-------------------------------------------------------------------------- 
    

    !--------------------------------------------------------------------------
        
    subroutine KillMeteoOcean    

        !Arguments-------------------------------------------------------------
        
        !Local-----------------------------------------------------------------        
        integer                                     :: nF, nFiles_total
        integer                                     :: nMOP, nMOPtotal, STAT_CALL
        
        !Begin-----------------------------------------------------------------    
        nMOPtotal = Me%MeteoOcean%PropNumber
        
do1:    do nMOP = 1, nMOPtotal
            nFiles_total = Me%MeteoOcean%Prop(nMOP)%FieldNumber
do2:        do nF = 1, nFiles_total

                if (Me%MeteoOcean%Prop(nMOP)%FileListMode) then
                    if (Me%MeteoOcean%Prop(nMOP)%Field(nF)%NFilesList < 1) cycle
                endif

                call KillField4D(Field4DID             = Me%MeteoOcean%Prop(nMOP)%Field(nF)%ID, &
                                 STAT                  = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'KillMeteoOcean - ModuleLagrangianGlobal - ERR10' 
            enddo do2
            if (associated(Me%MeteoOcean%Prop(nMOP)%Field)) deallocate(Me%MeteoOcean%Prop(nMOP)%Field)
        enddo do1
        
        deallocate(Me%MeteoOcean%Prop)
     
                    
    end subroutine KillMeteoOcean    

    !-------------------------------------------------------------------------- 

    subroutine DeallocateInstance 

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Lagrangian), pointer                      :: AuxLagrangian      => null()
        type (T_Lagrangian), pointer                      :: PreviousLagrangian => null()

        !Updates pointers
        if (Me%InstanceID == FirstLagrangian%InstanceID) then
            FirstLagrangian => FirstLagrangian%Next
        else
            PreviousLagrangian => FirstLagrangian
            AuxLagrangian      => FirstLagrangian%Next
            do while (AuxLagrangian%InstanceID /= Me%InstanceID)
                PreviousLagrangian => AuxLagrangian
                AuxLagrangian      => AuxLagrangian%Next
            enddo

            !Now update linked list
            PreviousLagrangian%Next => AuxLagrangian%Next

        endif

        deallocate(Me%EulerModel)

        !Deallocates instance
        deallocate (Me)
        nullify    (Me) 

            
    end subroutine DeallocateInstance

    !--------------------------------------------------------------------------

    subroutine DeallocateOriginList (FirstOrigin, nOrigins)

        !Arguments-------------------------------------------------------------
        type (T_origin), pointer                    :: FirstOrigin
        integer                                     :: nOrigins

        !Local-----------------------------------------------------------------
        type (T_origin), pointer                    :: CurrentOrigin => null()

        CurrentOrigin => FirstOrigin
        do while (associated(CurrentOrigin))

            call DeleteOrigin (FirstOrigin, CurrentOrigin, nOrigins)

            CurrentOrigin => FirstOrigin
        enddo


    end subroutine DeallocateOriginList 

    !--------------------------------------------------------------------------

    subroutine WriteFinalPartic(Final)

        !Arguments-------------------------------------------------------------
        logical, optional, intent (IN)               :: Final
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin   => null()
        type (T_Partic), pointer                    :: CurrentPartic   => null()
        type (T_Property), pointer                  :: CurrentProperty => null()
        integer                                     :: UnitID
        integer                                     :: STAT_CALL
        character (Len = Pathlength)                :: filename
        logical                                     :: Final_ = .false.
        real                                        :: Year, Month, Day, Hour, Minute, Second

        !Begin-----------------------------------------------------------------        

        if(present(Final)) Final_ = Final

        !Opens File
        call UnitsManager (UnitID, OPEN_FILE, STAT = STAT_CALL)

        !Checks if it's at the end of the run 
        !or !if it's supposed to overwrite the final HDF file
        if (Me%Output%RestartOverwrite .or. Final_) then

            filename = trim(Me%Files%Final)

        else

            filename =  ChangeSuffix(Me%Files%Final,                         &
                               "_"//trim(TimeToString(Me%Now))//".fin")


        endif

        open   (unit = UnitID, file = trim(filename), status = 'unknown',     &
                form = 'unformatted')
        rewind (unit = UnitID)

        write(UnitID) Me%nOrigins

        CurrentOrigin => Me%FirstOrigin
CurrOr: do while (associated(CurrentOrigin))

            !Writes Origin Information
            write (UnitID) CurrentOrigin%Name
            write (UnitID) CurrentOrigin%ID
            write (UnitID) CurrentOrigin%Position%ModelID
            write (UnitID) CurrentOrigin%State%Oil
            write (UnitID) CurrentOrigin%State%Deposition
            write (UnitID) CurrentOrigin%State%Age
            write (UnitID) CurrentOrigin%State%ComputePlume
            write (UnitID) CurrentOrigin%State%PlumeShear
            write (UnitID) CurrentOrigin%State%FarFieldBuoyancy
            write (UnitID) CurrentOrigin%nParticle
            write (UnitID) CurrentOrigin%nParticleEmit            
            write (UnitID) CurrentOrigin%nProperties
            write (UnitID) CurrentOrigin%NextParticID            

!            If (CurrentOrigin%State%Oil)   then
!                write (UnitID) CurrentOrigin%OilSpreading%GridThickness                      
!                write (UnitID) CurrentOrigin%OilGridConcentration
!            endif

            !Writes Particle Information
            CurrentPartic => CurrentOrigin%FirstPartic
            do while (associated(CurrentPartic))

                write (UnitID) CurrentPartic%ID

                write (UnitID) CurrentPartic%Position%ModelID

                write (UnitID) CurrentPartic%Position%I
                write (UnitID) CurrentPartic%Position%J
                write (UnitID) CurrentPartic%Position%K
                write (UnitID) CurrentPartic%Position%CellI
                write (UnitID) CurrentPartic%Position%CellJ
                write (UnitID) CurrentPartic%Position%CellK
                write (UnitID) CurrentPartic%Position%CoordX
                write (UnitID) CurrentPartic%Position%CoordY
                write (UnitID) CurrentPartic%Position%CartX
                write (UnitID) CurrentPartic%Position%CartY
                write (UnitID) CurrentPartic%Position%X
                write (UnitID) CurrentPartic%Position%Y
                write (UnitID) CurrentPartic%Position%Z

                write (UnitID) CurrentPartic%Geometry%Volume
                write (UnitID) CurrentPartic%Geometry%InitialVolume
                write (UnitID) CurrentPartic%Geometry%VolVar
                write (UnitID) CurrentPartic%Beached

                if (CurrentOrigin%State%Oil) then
                    write (UnitID) CurrentPartic%Geometry%VolumeOil
                endif  

                if (CurrentOrigin%State%Deposition) then
                
                    write (UnitID) CurrentPartic%Deposited
                    write (UnitID) CurrentPartic%TauErosion
                    write (UnitID) CurrentPartic%TauDeposition

                endif

                if (CurrentOrigin%State%Age) then
                
                    write (UnitID) CurrentPartic%Age

                endif

                if (CurrentOrigin%State%PlumeShear) then
                    write (UnitID) CurrentPartic%U
                    write (UnitID) CurrentPartic%V
                endif

                if (CurrentOrigin%State%FarFieldBuoyancy) then
                    write (UnitID) CurrentPartic%W
                endif

                if (associated(CurrentPartic%Concentration)) then
                    write (UnitID) CurrentPartic%Concentration
                endif
                
                if (associated(CurrentPartic%Mass)) then
                    write (UnitID) CurrentPartic%Mass
                endif

                write (UnitID) CurrentPartic%TpercursoH
                !To maintain old versions of the fin results valid
                write (UnitID) CurrentPartic%TpercursoH                
                write (UnitID) CurrentPartic%TpercursoZ
                write (UnitID) CurrentPartic%UD_old
                write (UnitID) CurrentPartic%VD_old
                write (UnitID) CurrentPartic%WD_old
                
                call ExtractDate(CurrentPartic%EmissionTime, Year, Month, Day, Hour, Minute, Second)                
                
                write (UnitID) Year, Month, Day, Hour, Minute, Second

                CurrentPartic => CurrentPartic%Next
            enddo

            !Writes Property information
            CurrentProperty => CurrentOrigin%FirstProperty
            do while (associated(CurrentProperty))

                write (UnitID) CurrentProperty%Name

                CurrentProperty => CurrentProperty%Next
            enddo

            !Writes Oil information
            If (CurrentOrigin%State%Oil)                                       &
                call WriteFinalOil(CurrentOrigin%ObjOil, UnitID)

            CurrentOrigin => CurrentOrigin%Next


        enddo CurrOr
            
        !Closes File
        call UnitsManager (UnitID, CLOSE_FILE, STAT = STAT_CALL)


    end subroutine WriteFinalPartic

    !--------------------------------------------------------------------------

    subroutine ReadFinalPartic 

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: NewOrigin    => null()
        type (T_Partic), pointer                    :: NewParticle  => null()
        type (T_Property), pointer                  :: NewProperty  => null()
        integer                                     :: OldOrigins
        integer                                     :: UnitID
        integer                                     :: STAT_CALL
        integer                                     :: nO, nP
        integer                                     :: nParticle, nProperties
        integer                                     :: em        
!        integer                                     :: Dummy
        real                                        :: Year, Month, Day, Hour, Minute, Second
        
        !Begin-----------------------------------------------------------------

        !Opens File
        call UnitsManager (UnitID, OPEN_FILE, STAT = STAT_CALL)

        open   (unit = UnitID, file = Me%Files%Initial, status = 'old', form = 'unformatted')


        read(UnitID) OldOrigins

d1:     do nO = 1, OldOrigins

            call AllocateNewOrigin (NewOrigin)
            
            NewOrigin%Old   = ON 

            
            call AllocateNewOrigin (NewOrigin)            
            

            !Reads Origin Information
            read (UnitID) NewOrigin%Name            
            read (UnitID) NewOrigin%ID
            read (UnitID) NewOrigin%Position%ModelID
            read (UnitID) NewOrigin%State%Oil
            read (UnitID) NewOrigin%State%Deposition
            read (UnitID) NewOrigin%State%Age
            read (UnitID) NewOrigin%State%ComputePlume
            read (UnitID) NewOrigin%State%PlumeShear
            read (UnitID) NewOrigin%State%FarFieldBuoyancy
            read (UnitID) nParticle
            read (UnitID) NewOrigin%nParticleEmit
            read (UnitID) nProperties
            read (UnitID) NewOrigin%NextParticID                                    
            

            if (NewOrigin%State%Oil) then
        
                !Allocates GridThickness
!                allocate (NewOrigin%OilSpreading%GridThickness(EulerModel%Size%ILB:            &
!                                                  EulerModel%Size%IUB,            &
!                                                  EulerModel%Size%JLB:            &
!                                                  EulerModel%Size%JUB),           &
!                                                  STAT = STAT_CALL)

!                if (STAT_CALL /= SUCCESS_) stop 'ReadFinalPartic - ModuleLagrangianGlobal - ERR04'

!                read (UnitID) NewOrigin%OilSpreading%GridThickness
            
!                !Allocates GridThickness
!                allocate (NewOrigin%OilGridConcentration(EulerModel%Size%ILB:            &
!                                                         EulerModel%Size%IUB,            &
!                                                         EulerModel%Size%JLB:            &
!                                                         EulerModel%Size%JUB),           &
!                                                         STAT = STAT_CALL)

!                if (STAT_CALL /= SUCCESS_) stop 'ReadFinalPartic - ModuleLagrangianGlobal - ERR04a'

!                read (UnitID) NewOrigin%OilGridConcentration

            end if

            !Reads Particle Information
d2:         do nP = 1, nParticle


!                read (UnitID) Dummy !Does not read NewParticle%ID any more
!                                    !This is due to an error in attributing 
!                                    !identical ID's to different particles
!                                    !This error was not completely understood
!                                    !but the problem was solved. If you find 
!                                    !any problem regarding memory errors and 
!                                    !particle ID's please warn Luis or Frank

                call AllocateNewParticle (NewParticle, nProperties, NewOrigin%NextParticID, DefineID = .false.)

                read (UnitID) NewParticle%ID 
                read (UnitID) NewParticle%Position%ModelID

                read (UnitID) NewParticle%Position%I
                read (UnitID) NewParticle%Position%J
                read (UnitID) NewParticle%Position%K
                read (UnitID) NewParticle%Position%CellI
                read (UnitID) NewParticle%Position%CellJ
                read (UnitID) NewParticle%Position%CellK
                read (UnitID) NewParticle%Position%CoordX
                read (UnitID) NewParticle%Position%CoordY
                read (UnitID) NewParticle%Position%CartX
                read (UnitID) NewParticle%Position%CartY
                read (UnitID) NewParticle%Position%X
                read (UnitID) NewParticle%Position%Y

                read (UnitID) NewParticle%Position%Z

                read (UnitID) NewParticle%Geometry%Volume
                read (UnitID) NewParticle%Geometry%InitialVolume
                read (UnitID) NewParticle%Geometry%VolVar
                read (UnitID) NewParticle%Beached

                if (NewOrigin%State%Oil) then
                    read (UnitID) NewParticle%Geometry%VolumeOil
                endif  

                if (NewOrigin%State%Deposition) then
                
                    read (UnitID) NewParticle%Deposited
                    read (UnitID) NewParticle%TauErosion
                    read (UnitID) NewParticle%TauDeposition
                    
                endif

                if (NewOrigin%State%Age) then
                
                    read (UnitID) NewParticle%Age

                endif

                if (NewOrigin%State%PlumeShear) then
                    read (UnitID) NewParticle%U
                    read (UnitID) NewParticle%V
                endif

                if (NewOrigin%State%FarFieldBuoyancy) then
                    read (UnitID) NewParticle%W
                endif
                
                if (associated(NewParticle%Concentration)) then
                    read (UnitID) NewParticle%Concentration
                endif                

                if (associated(NewParticle%Mass)) then
                    read (UnitID) NewParticle%Mass
                endif      

                read (UnitID) NewParticle%TpercursoH
                !To maintain old versions of the fin results valid
                read (UnitID) NewParticle%TpercursoH                
                read (UnitID) NewParticle%TpercursoZ
                read (UnitID) NewParticle%UD_old
                read (UnitID) NewParticle%VD_old
                read (UnitID) NewParticle%WD_old
                
                read (UnitID) Year, Month, Day, Hour, Minute, Second      
                
                call SetDate(NewParticle%EmissionTime, Year, Month, Day, Hour, Minute, Second)

                call InsertParticleToList (NewOrigin, NewParticle, .false.)

            enddo d2

            !Reads Property Information
d3:         do nP = 1, nProperties

                call AllocateNewProperty (NewProperty)
                read (UnitID) NewProperty%Name

                call InsertPropertyToList(NewOrigin, NewProperty, SetStates = .false.)

            enddo d3

            !Reads OilInformation
i3:         if (NewOrigin%State%Oil) then
                
                em = NewOrigin%Position%ModelID

                !Starts Oil
                call StartOil(OilID             = NewOrigin%ObjOil,                     &
                              TimeID            = Me%EulerModel(em)%ObjTime,            &
                              EnterDataID       = Me%ObjEnterData,                      &
                              DT                = Me%DT_PARTIC,                         &     
                              ContCalc          = NewOrigin%Old,                        &
                              ExtractType       = FromBlockInBlock,                     &                   
                              STAT              = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadFinalPartic - ModuleLagrangianGlobal - ERR01'

                call ReadFinalOil(NewOrigin%ObjOil, UnitID) 

            end if i3


            call InsertOriginToList (Me%FirstOldOrigin, NewOrigin, Me%nOldOrigins)

        enddo d1

        !Closes File
        call UnitsManager (UnitID, CLOSE_FILE, STAT = STAT_CALL)


    end subroutine ReadFinalPartic

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    subroutine KillLight (em)

        !Arguments-------------------------------------------------------------
        integer                                     :: em

        !Local-----------------------------------------------------------------
        integer                                     :: ig, STAT_CALL

        !Begin-----------------------------------------------------------------

        !Updates light
        do ig = 1, Me%nGroups

            call KillLightExtinction(Me%EulerModel(em)%Light(ig)%ObjLightExtinction, STAT = STAT_CALL)

            deallocate (Me%EulerModel(em)%Light(ig)%TopRadiationCells)

        enddo

    end subroutine KillLight

    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------

    subroutine KillParticleStatistic 

        !Arguments-------------------------------------------------------------
   

        !Local-----------------------------------------------------------------
        integer                                     :: nProp, em, STAT_CALL, p, ig

        !Begin-----------------------------------------------------------------

d1:     do em = 1, Me%EulerModelNumber 

            nProp   =  Me%Statistic%PropNumber
            
d2:         do p = 1, nProp
                                
d3:             do ig = 1, Me%NGroups

                    call WriteFrequencyLag(em, p, ig)
                
                    call KillStatistic    (Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID(ig), STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillParticleStatistic - ModuleLagrangianGlobal - ERR10'
                    
                    if (OilThickness_ == Me%Statistic%OptionsStat(p)%ID%IDNumber) cycle

                    if (Me%OutPut%ConcMaxTracer) then

                        call KillStatistic(Me%EulerModel(em)%PropStatistic(p)%Statistic2_ID(ig), STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'KillParticleStatistic - ModuleLagrangianGlobal - ERR20'

                    endif
                    
                    if (Me%OutPut%MassTracer) then

                        call KillStatistic(Me%EulerModel(em)%PropStatistic(p)%Statistic3_ID(ig), STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'KillParticleStatistic - ModuleLagrangianGlobal - ERR30'

                        if (Me%OutPut%ConcMaxTracer) then

                            call KillStatistic(Me%EulerModel(em)%PropStatistic(p)%Statistic4_ID(ig), STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'KillParticleStatistic - ModuleLagrangianGlobal - ERR40'

                        endif                        

                    endif

                    
                enddo d3

                deallocate(Me%EulerModel(em)%PropStatistic(p)%Statistic1_ID)

                if (Me%OutPut%ConcMaxTracer) then

                    deallocate(Me%EulerModel(em)%PropStatistic(p)%Statistic2_ID)

                endif
                    
                if (Me%OutPut%MassTracer) then

                    deallocate(Me%EulerModel(em)%PropStatistic(p)%Statistic3_ID)
                    
                        if (Me%OutPut%ConcMaxTracer) then

                            deallocate(Me%EulerModel(em)%PropStatistic(p)%Statistic4_ID)
                            if (STAT_CALL /= SUCCESS_) stop 'KillParticleStatistic - ModuleLagrangianGlobal - ERR40'

                        endif                          

                endif

                if (Me%Statistic%OptionsStat(p)%Lag) then
                    deallocate(Me%EulerModel(em)%PropStatistic(p)%FrequencyLag)
                endif

            enddo d2

            deallocate(Me%EulerModel(em)%PropStatistic)

        enddo d1

    end subroutine KillParticleStatistic

    !--------------------------------------------------------------------------

    subroutine KillLag2Euler

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        integer             :: em
        !Begin------------------------------------------------------------------
                
d1:     do em = 1, Me%EulerModelNumber 

            !deAllocate 
            deallocate (Me%EulerModel(em)%Lag2Euler%GridVolume        )
            deallocate (Me%EulerModel(em)%Lag2Euler%GridTracerNumber  )
            deallocate (Me%EulerModel(em)%Lag2Euler%PercentContamin   )

            deallocate (Me%EulerModel(em)%Lag2Euler%GridMass          )
            deallocate (Me%EulerModel(em)%Lag2Euler%GridConc          )

            deallocate (Me%EulerModel(em)%Lag2Euler%MeanConc          )
            deallocate (Me%EulerModel(em)%Lag2Euler%AmbientConc       )
            deallocate (Me%EulerModel(em)%Lag2Euler%MinConc           )
            deallocate (Me%EulerModel(em)%Lag2Euler%MassVolCel        )

            if (Me%State%Deposition) then
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBottomMass)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBottomConc)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridWaterColumnSedAreaDensity)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridWaterColumnNumber)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBottomNumber)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridWaterColumnVolume)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBottomVolume)
                
                if (Me%State%CriticalSlope) then
                    deallocate (Me%EulerModel(em)%Lag2Euler%GridBottomSlope)
                    deallocate (Me%EulerModel(em)%Lag2Euler%GridVelSlope_X )
                    deallocate (Me%EulerModel(em)%Lag2Euler%GridVelSlope_Y )
                endif                
                             
            endif

            if (Me%OutPut%ConcMaxTracer) then
                deallocate (Me%EulerModel(em)%Lag2Euler%GridMaxTracer)
                if (Me%OutPut%MassTracer) then
                    deallocate (Me%EulerModel(em)%Lag2Euler%GridMaxMass  )                
                endif
            endif


            if (Me%State%AssociateBeachProb) then
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBeachedVolume)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBeachedVolVar)
                deallocate (Me%EulerModel(em)%Lag2Euler%PreviousGridBeachedVolume)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBeachedVolumeByType)
                deallocate (Me%EulerModel(em)%Lag2Euler%TheoricBeachedVolAfterRemoval)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridVolToRemove)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridVolToRemoveFraction)
                deallocate (Me%EulerModel(em)%Lag2Euler%GridBeachingTime)
            endif


        enddo d1

        !----------------------------------------------------------------------

    end subroutine KillLag2Euler

    !--------------------------------------------------------------------------


    !------------------------------------------------------------------------------

    subroutine DeAllocateOil

        !Local---------------------------------------------------------------------
        integer                     :: em, ig, STAT_CALL                          

        !Begin---------------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber 

            deallocate (Me%EulerModel(em)%MassDissolvedSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR10'
            
            deallocate (Me%EulerModel(em)%MassSumParticCell, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)  stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR11'


d2:         do ig = 1, Me%NGroups

            !Allocates GridThickness
            deallocate (Me%EulerModel(em)%OilSpreading(ig)%GridThickness, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR20'


            !Allocates OilGridConcentration
            deallocate (Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR30'

            deallocate (Me%EulerModel(em)%OilSpreading(ig)%OilGridConcentration3D, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR31'

            deallocate (Me%EulerModel(em)%OilSpreading(ig)%OilGridDissolution3D, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR32'

            deallocate (Me%EulerModel(em)%OilSpreading(ig)%VelocityX, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR40'

            deallocate (Me%EulerModel(em)%OilSpreading(ig)%VelocityY, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR50'

            deallocate (Me%EulerModel(em)%OilSpreading(ig)%AreaFlag, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR60'

            deallocate (Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime, STAT = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR61'
            enddo d2

            deallocate (Me%EulerModel(em)%OilSpreading, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateOil - ModuleLagrangianGlobal - ERR70'

        enddo d1
        

    end subroutine DeAllocateOil

    !------------------------------------------------------------------------------
        
    subroutine WriteBeachingStats
       
        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_Origin), pointer                    :: CurrentOrigin
        type (T_Partic), pointer                    :: CurrentPartic   => null()
        integer                                     :: em, ig
        integer                                     :: unit, STAT_CALL
        character(len=PathLength)                   :: BeachingStatsFileName 
        character(len=1)                            :: iGroupStr
        real, dimension(:, :), pointer              :: Aux2D 
        real                                        :: MinBeachingTime, MinDistanceToCoast
        integer                                     :: ILB, IUB, JLB, JUB, KUB, i, j
        real                                        :: BeachingCoastLineLength
        real, dimension(:, :), pointer              :: DXX, DYY               

        !Begin-----------------------------------------------------------------

        
        do em = 1, Me%EulerModelNumber 
        
            call GetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DXX = DXX, DYY = DYY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR00'

        
            call GetWaterPoints3D(Me%EulerModel(em)%ObjMap, Me%EulerModel(em)%WaterPoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR01'
            
            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB
            
            do ig = 1, Me%NGroups
            
                write(iGroupStr, ('(i1)'))ig
                BeachingStatsFileName = trim(adjustl(Me%OutPut%RootPath))//"OilBeachingStats_"//iGroupStr//".dat"
                
                call UnitsManager(Unit, OPEN_FILE, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR10'
                
                open (Unit, file = BeachingStatsFileName, status = 'replace', IOSTAT = STAT_CALL) 
                if (STAT_CALL /= SUCCESS_) stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR11'
                
                call WriteDataLine(unit, 'START', Me%ExternalVar%BeginTime)
                call WriteDataLine(unit, 'END',   Me%ExternalVar%EndTime  )
                
                CurrentOrigin => Me%FirstOrigin
                do while (associated(CurrentOrigin))

                    if (CurrentOrigin%Beaching) then
                    
                        if(CurrentOrigin%MaxVolTotOilBeached > 0.)then
                            call WriteDataLine(unit, 'HAS_BEACHED', .true.)
                        else
                            call WriteDataLine(unit, 'HAS_BEACHED', .false.)
                        endif
                        
                        call WriteDataLine(unit, 'MAX_VOL_OIL_BEACHED', CurrentOrigin%MaxVolTotOilBeached)
                       
                        MinDistanceToCoast = -null_real
                        
                        CurrentPartic => CurrentOrigin%FirstPartic
                        do while (associated(CurrentPartic))
                   
                            if(CurrentPartic%MinDistanceToCoast < MinDistanceToCoast)then
                                MinDistanceToCoast = CurrentPartic%MinDistanceToCoast
                            endif       
                    
                            CurrentPartic => CurrentPartic%Next

                        enddo
                        
                        call WriteDataLine(unit, 'MIN_DISTANCE_TO_COAST', MinDistanceToCoast)

                    
                    endif

                    CurrentOrigin => CurrentOrigin%Next

                enddo     
            
                Aux2D => Me%EulerModel(em)%Lag2Euler%GridBeachingTime(ILB:IUB,JLB:JUB,ig)
                
                MinBeachingTime         = -1.0 * null_real
                BeachingCoastLineLength = 0.
                
                do j = JLB, JUB
                do i = ILB, IUB
                    
                    if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) == WaterPoint) then
                        if(Me%EulerModel(em)%Lag2Euler%GridBeachingTime(i,j,ig)> 0.)then
                        
                            if(Me%EulerModel(em)%Lag2Euler%GridBeachingTime(i,j,ig) < MinBeachingTime)then
                                MinBeachingTime = Me%EulerModel(em)%Lag2Euler%GridBeachingTime(i,j,ig)
                            endif

                            !East face
                            if ((Me%EulerModel(em)%WaterPoints3D(i, j+1, KUB).NE. WaterPoint)) then
                                BeachingCoastLineLength = BeachingCoastLineLength + DYY(i,j+1)
                            !West face
                            elseif ((Me%EulerModel(em)%WaterPoints3D(i, j-1, KUB).NE. WaterPoint)) then
                                BeachingCoastLineLength = BeachingCoastLineLength + DYY(i,j)
                            !North face
                            elseif ((Me%EulerModel(em)%WaterPoints3D(i+1, j, KUB).NE. WaterPoint)) then
                                BeachingCoastLineLength = BeachingCoastLineLength + DXX(i+1,j)
                            !South face
                            elseif ((Me%EulerModel(em)%WaterPoints3D(i-1, j, KUB).NE. WaterPoint)) then
                                BeachingCoastLineLength = BeachingCoastLineLength + DXX(i,j)
                            end if
                        
                        endif
                    endif

                enddo
                enddo
                
                call WriteDataLine(unit, 'MINIMUM_BEACHING_TIME',     MinBeachingTime)
                call WriteDataLine(unit, 'BEACH_COASTLINE_LENGTH',    BeachingCoastLineLength)
                
                
                call UnitsManager(Unit, CLOSE_FILE, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR20'


            enddo
            
            call UnGetMap (Me%EulerModel(em)%ObjMap, Me%EulerModel(em)%Waterpoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR30'
            
            call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DXX, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR40'

            call UnGetHorizontalGrid(Me%EulerModel(em)%ObjHorizontalGrid, DYY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'WriteBeachingStats - ModuleLagrangianGlobal - ERR50'


        enddo
    
    
    end subroutine WriteBeachingStats
    
    !------------------------------------------------------------------------------

    subroutine WriteArrivalBeachingTimes
    
    
        !Local---------------------------------------------------------------------
        integer                             :: em,ig, STAT_CALL  
        character(len=PathLength)           :: ArrivalTimesFileName, BeachingTimesFileName   
        real, dimension(:, :), pointer      :: Aux2D 
        character(len=1)                    :: iGroupStr
        integer                             :: ILB, IUB, JLB, JUB, KUB, i, j

        !Begin---------------------------------------------------------------------
        
d1:     do em =1, Me%EulerModelNumber 

            call GetWaterPoints3D(Me%EulerModel(em)%ObjMap, Me%EulerModel(em)%WaterPoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'WriteArrivalBeachingTimes - ModuleLagrangianGlobal - ERR00'

            ILB = Me%EulerModel(em)%WorkSize%ILB
            JLB = Me%EulerModel(em)%WorkSize%JLB
            IUB = Me%EulerModel(em)%WorkSize%IUB
            JUB = Me%EulerModel(em)%WorkSize%JUB
            KUB = Me%EulerModel(em)%WorkSize%KUB

d2:         do ig = 1, Me%NGroups

                write(iGroupStr, ('(i1)'))ig

                ArrivalTimesFileName = trim(adjustl(Me%OutPut%RootPath))//"OilArrivalTimes_"//iGroupStr//".dat"
                
                do j  = JLB, JUB
                do i  = ILB, IUB
                    if (Me%EulerModel(em)%WaterPoints3D(i, j, KUB) .ne. WaterPoint) then
                        Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime(i, j) = -99.0
                        Me%EulerModel(em)%Lag2Euler%GridBeachingTime(i,j,ig)        = -99.0
                    endif
                enddo
                enddo

                call WriteGridData (FileName            = ArrivalTimesFileName,                                     &
                                    COMENT1             = "Oil Arrival Times",                                      &
                                    COMENT2             = "",                                                       &
                                    HorizontalGridID    = Me%EulerModel(em)%ObjHorizontalGrid,                      &
                                    FillValue           = -99.,                                                     &
                                    Overwrite           = ON,                                                       &
                                    GridData2D_Real     = Me%EulerModel(em)%OilSpreading(ig)%GridOilArrivalTime,    &
                                    STAT                = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteArrivalBeachingTimes - ModuleLagrangianGlobal - ERR10'
                
                nullify(Aux2D)
                
                Aux2D => Me%EulerModel(em)%Lag2Euler%GridBeachingTime(ILB:IUB,JLB:JUB,ig)

                BeachingTimesFileName = trim(adjustl(Me%OutPut%RootPath))//"OilBeachingTimes_"//iGroupStr//".dat"

                call WriteGridData (FileName            = BeachingTimesFileName,                                    &
                                    COMENT1             = "Oil Beaching Times",                                     &
                                    COMENT2             = "",                                                       &
                                    HorizontalGridID    = Me%EulerModel(em)%ObjHorizontalGrid,                      &
                                    FillValue           = -99.,                                                     &
                                    Overwrite           = ON,                                                       &
                                    GridData2D_Real     = Aux2D,                                                    &
                                    STAT                = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'WriteArrivalBeachingTimes - ModuleLagrangianGlobal - ERR20'
                
                nullify(Aux2D)

            enddo d2
            
            call UnGetMap (Me%EulerModel(em)%ObjMap, Me%EulerModel(em)%Waterpoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'WriteArrivalBeachingTimes - ModuleLagrangianGlobal - ERR30'
            
        enddo d1
    
    
    end subroutine WriteArrivalBeachingTimes 

    !------------------------------------------------------------------------------

    subroutine DeAllocateHNS

        !Local---------------------------------------------------------------------
        integer                     :: em, ig, STAT_CALL                          

        !Begin---------------------------------------------------------------------

d1:     do em =1, Me%EulerModelNumber 
d2:         do ig =1, Me%NGroups 


                deallocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR10'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDissolvedConc3D)
                
                deallocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR20'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDissolvedConc2D)
                
                deallocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR30'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDissolvedMaxConc2D)
                
                deallocate (Me%EulerModel(em)%HNS(ig)%GridAirConc3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR40'
                nullify(Me%EulerModel(em)%HNS(ig)%GridAirConc3D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridAirConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR50'
                nullify(Me%EulerModel(em)%HNS(ig)%GridAirConc2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridAirMaxConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR60'
                nullify(Me%EulerModel(em)%HNS(ig)%GridAirMaxConc2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR70'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDropletsConc3D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR80'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDropletsConc2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR90'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDropletsMaxConc2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR100'
                nullify(Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc3D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR110'
                nullify(Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateConc2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR120'
                nullify(Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMaxConc2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridAirMass2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR130'
                nullify(Me%EulerModel(em)%HNS(ig)%GridAirMass2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridSurfaceFloatingMass2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR140'
                nullify(Me%EulerModel(em)%HNS(ig)%GridSurfaceFloatingMass2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR150'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDissolvedMass2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR160'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDropletsMass2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR170'
                nullify(Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass3D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR180'
                nullify(Me%EulerModel(em)%HNS(ig)%GridSuspendedParticulateMass2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR190'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDissolvedMass3D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR200'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDropletsMass3D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMass2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR210'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMass2D)

                deallocate (Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR220'
                nullify(Me%EulerModel(em)%HNS(ig)%GridDepositedParticulateMassPerArea2D)

            end do d2

            deallocate (Me%EulerModel(em)%HNS, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'DeAllocateHNS - ModuleLagrangianGlobal - ERR200'

        enddo d1
        

    end subroutine DeAllocateHNS

    !------------------------------------------------------------------------------

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    subroutine Ready (ObjLagrangian_ID, ready_) 

        !Arguments-------------------------------------------------------------
        integer                                     :: ObjLagrangian_ID
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (Me)

cd1:    if (ObjLagrangian_ID > 0) then
            call LocateObjLagrangian(ObjLagrangian_ID)
            ready_ = VerifyReadLock (mLAGRANGIAN_,  Me%InstanceID)
        else
            ready_ = OFF_ERR_
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Ready

    !--------------------------------------------------------------------------

    subroutine LocateObjLagrangian (LagrangianID)

        !Arguments-------------------------------------------------------------
   
        integer                                     :: LagrangianID

        !Local-----------------------------------------------------------------

        Me => FirstLagrangian
        do while (associated (Me))
            if (Me%InstanceID == LagrangianID) exit
            Me => Me%Next
        enddo

        if (.not. associated (Me))                                          &
            stop 'ModuleLagrangianGlobal - LocateObjLagrangian - ERR01'

    end subroutine LocateObjLagrangian

    !--------------------------------------------------------------------------

    subroutine ReadLockHorizontalGrid(EulerModel)
        
        !Arguments-------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel
        !External--------------------------------------------------------------
        integer                                     :: STAT_CALL, GEOG, UTM, MIL_PORT
        integer                                     :: SIMPLE_GEOG, GRID_COORD, NLRD, CoordType 
        
        !----------------------------------------------------------------------
        

        !XX, YY
        call GetHorizontalGrid (EulerModel%ObjHorizontalGrid, XX = EulerModel%XX,       &
                                YY = EulerModel%YY, DZX = EulerModel%DZX,               &
                                DZY = EulerModel%DZY, STAT = STAT_CALL)

        if (STAT_CALL /= SUCCESS_) stop 'ReadLockHorizontalGrid - ModuleLagrangianGlobal - ERR20'

        call GetCoordTypeList (GEOG = GEOG, UTM = UTM, MIL_PORT = MIL_PORT,             &
                               SIMPLE_GEOG = SIMPLE_GEOG, GRID_COORD = GRID_COORD,      &
                               NLRD = NLRD)

        !Gets Coordinates in use
        call GetGridCoordType(EulerModel%ObjHorizontalGrid, CoordType, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockHorizontalGrid - ModuleLagrangianGlobal - ERR30'


        if(CoordType == UTM .or. CoordType == MIL_PORT .or.                             &
           CoordType == GRID_COORD .or. CoordType == NLRD)then

            call GetHorizontalGrid(EulerModel%ObjHorizontalGrid,                        &
                                   XX_IE = EulerModel%XX_IE,                            &
                                   YY_IE = EulerModel%YY_IE,                            &
                                   STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockHorizontalGrid - ModuleLagrangianGlobal - ERR40'

        else

            call GetGridLatitudeLongitude(EulerModel%ObjHorizontalGrid,                 &
                                          GridLatitudeConn  = EulerModel%YY_IE,         &
                                          GridLongitudeConn = EulerModel%XX_IE,         &
                                          STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockHorizontalGrid - ModuleLagrangianGlobal - ERR50'

        end if

        call GetGridCellArea (EulerModel%ObjHorizontalGrid, EulerModel%GridCellArea, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockHorizontalGrid - ModuleLagrangianGlobal - ERR60'


    end subroutine ReadLockHorizontalGrid

    !--------------------------------------------------------------------------

    subroutine ReadLockExternalVar

        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel
        integer                                     :: STAT_CALL, em
        
        !----------------------------------------------------------------------
        
        !Gets Time
        call GetComputeCurrentTime(Me%ExternalVar%ObjTime, Me%ExternalVar%Now, STAT = STAT_CALL)              
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR10'

        Me%ExternalVar%RunPeriod = Me%ExternalVar%Now - Me%ExternalVar%BeginTime

em1:    do em =1, Me%EulerModelNumber

            EulerModel => Me%EulerModel(em)

            call ReadLockHorizontalGrid(EulerModel)


            call GetGridData          (EulerModel%ObjGridData, EulerModel%Bathymetry, STAT = STAT_CALL)     
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR20'


            !Gets ExteriorPoints 2D
            call GetBoundaries      (EulerModel%ObjHorizontalMap, EulerModel%BoundaryPoints2D, &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR30'

            !Gets water points 2D
            call GetWaterPoints2D   (EulerModel%ObjHorizontalMap, EulerModel%WaterPoints2D, &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR35'


            !WaterColumn
            call GetGeometryWaterColumn(EulerModel%ObjGeometry, EulerModel%WaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR40'


            !SZZ, DWZ    
            call GetGeometryDistances(EulerModel%ObjGeometry,                       & 
                                        SZZ         = EulerModel%SZZ,                 &
                                        ZCellCenter = EulerModel%ZCellCenter,         &
                                        DWZ         = EulerModel%DWZ,                 &
                                        DWZ_Xgrad   = EulerModel%DWZ_Xgrad,           &
                                        DWZ_Ygrad   = EulerModel%DWZ_Ygrad,           &
                                        STAT        = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR50'

            !VolumeZ
            call GetGeometryVolumes(EulerModel%ObjGeometry,                         &
                                    VolumeZ = EulerModel%VolumeZ,                   &
                                    STAT    = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR60'

            !kFloorZ
            call GetGeometryKFloor (EulerModel%ObjGeometry,                         &
                                    Z       = EulerModel%kFloor,                    &
                                    STAT    = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR70'


            !WaterPoints3D
            call GetWaterPoints3D(EulerModel%ObjMap, EulerModel%Waterpoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR80'


            !LandPoints3D
            call GetLandPoints3D(EulerModel%ObjMap, EulerModel%LandPoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR90'


            !OpenPoints3D
            call GetOpenPoints3D(EulerModel%ObjMap, EulerModel%OpenPoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR100'


            !Compute faces
            call GetComputeFaces3D(EulerModel%ObjMap,                               &
                                    ComputeFacesU3D = EulerModel%ComputeFaces3D_U,   &
                                    ComputeFacesV3D = EulerModel%ComputeFaces3D_V,   &
                                    STAT= STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR110'


            !Lupward, Ldownward
            call GetMixingLengthVertical(EulerModel%ObjTurbulence,                  &
                                            Lupward   = EulerModel%Lupward,            &
                                            Ldownward = EulerModel%Ldownward,          &
                                            STAT      = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR120'


            !MixingLengthX, MixingLengthY
            call GetMixingLengthHorizontal(EulerModel%ObjTurbulence,                &
                                            MixingLengthX = EulerModel%MixingLengthX,&
                                            MixingLengthY = EulerModel%MixingLengthY,&
                                            STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR130'
            
            call GetHorizontalViscosity(TurbulenceID                = EulerModel%ObjTurbulence, &
                                        HorizontalCenterViscosity   = EulerModel%DiffusionH,    &
                                        STAT                        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR132'


            call GetVerticalDiffusivity(TurbulenceID                = EulerModel%ObjTurbulence, &
                                        VerticalDiffusivityCenter   = EulerModel%DiffusionV,    &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR134'

        
            !Velocity_U, Velocity_V
            call GetHorizontalVelocity(EulerModel%ObjHydrodynamic,                  &
                                        Velocity_U = EulerModel%Velocity_U,          &
                                        Velocity_V = EulerModel%Velocity_V,          &
                                        STAT       = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR140'

        
            !Velocity_W
            call GetVerticalVelocity(EulerModel%ObjHydrodynamic,                    &
                                        Velocity_W      = EulerModel%Velocity_W,       &
                                        STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR150'
                
               
#ifndef _WAVES_
            if (Me%State%Waves .and. .not. Me%ConstructLag) then
                
                call GetWaves (WavesID      = EulerModel%ObjWaves,                    &
                                WavePeriod   = EulerModel%WavePeriod2D,                &
                                WaveHeight   = EulerModel%WaveHeight2D,                &
                                WaveDirection= EulerModel%WaveDirection2D,             &
                                WaveLength   = EulerModel%WaveLength2D,                &
                                STAT       = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) then
                    write(*,*) 
                    write(*,*) 'Error opening Wave properties'
                    write(*,*) 'Check if Wave module is properly configured'                   
                    stop 'ReadLockExternalVar - ModuleLagrangianGlobal - ERR160'
                end if
            endif      
#endif          

        enddo em1

        nullify(EulerModel)


        !----------------------------------------------------------------------

    end subroutine ReadLockExternalVar

    !--------------------------------------------------------------------------

    subroutine ReadLockEulerianDensity

        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel
        integer                                     :: STAT_CALL, em
        
        !----------------------------------------------------------------------

em1:    do em =1, Me%EulerModelNumber

            EulerModel => Me%EulerModel(em)

            !Density
            if (Me%State%FarFieldBuoyancy  .or. Me%State%ComputePlume) then
                call GetSigma       (EulerModel%ObjWaterProperties,                     &
                                     Sigma             = EulerModel%SigmaDensity,       &
                                     CurrentTime       = Me%Now,            &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadLockEulerianDensity - ModuleLagrangianGlobal - ERR10'
            else
                nullify(EulerModel%SigmaDensity)
            endif
    
    
            if (Me%State%Density) then
                call GetDensity     (EulerModel%ObjWaterProperties,                     &
                                     Density           = EulerModel%Density,            &
                                     CurrentTime       = Me%Now,            &
                                     STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadLockEulerianDensity - ModuleLagrangianGlobal - ERR20'
            else
                nullify(EulerModel%Density)
            endif

        enddo em1

        nullify(EulerModel)

    end subroutine ReadLockEulerianDensity

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------
    subroutine ReadUnLockHorizontalGrid(EulerModel)
    
        !Arguments-------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        
        !----------------------------------------------------------------------

        !XX, YY
        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%XX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR10'

        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%YY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR20'

        !XX_IE, YY_IE
        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%XX_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR30'

        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%YY_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR40'

        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%DZX, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR50'

        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%DZY, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR60'

        call UnGetHorizontalGrid (EulerModel%ObjHorizontalGrid, EulerModel%GridCellArea, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockHorizontalGrid - ModuleLagrangianGlobal - ERR70'
        
    

    end subroutine ReadUnLockHorizontalGrid

    !--------------------------------------------------------------------------

    subroutine ReadUnLockExternalVar

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel
        integer                                     :: STAT_CALL, em

        !Begin-----------------------------------------------------------------

em1:    do em =1, Me%EulerModelNumber

            EulerModel => Me%EulerModel(em)

            call ReadUnLockHorizontalGrid(EulerModel)

            !Gets Bathymetry
            call UnGetGridData (EulerModel%ObjGridData, EulerModel%Bathymetry, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR50'


            !Gets ExteriorPoints 2D
            call UngetHorizontalMap (EulerModel%ObjHorizontalMap, EulerModel%BoundaryPoints2D,   &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR60'

            call UngetHorizontalMap (EulerModel%ObjHorizontalMap, EulerModel%WaterPoints2D,   &
                                        STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR65'


            !WaterColumn
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%WaterColumn, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR70'

            !SZZ
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%SZZ, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR80'

            !ZCellCenter
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%ZCellCenter, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR90'

            !DWZ    
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%DWZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR100'

            !VolumeZ
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%VolumeZ, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR110'

            !kFloorZ
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%kFloor, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR120'

            !DWZ_Xgrad
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%DWZ_Xgrad, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR122'

            !DWZ_Ygrad
            call UnGetGeometry (EulerModel%ObjGeometry, EulerModel%DWZ_Ygrad, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR124'


            !WaterPoints3D
            call UnGetMap      (EulerModel%ObjMap, EulerModel%Waterpoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR130'


            !LandPoints3D
            call UnGetMap      (EulerModel%ObjMap, EulerModel%LandPoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR140'


            !OpenPoints3D
            call UnGetMap      (EulerModel%ObjMap, EulerModel%OpenPoints3D, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR150'

            !Compute faces U
            call UnGetMap      (EulerModel%ObjMap, EulerModel%ComputeFaces3D_U, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR160'

            !Compute faces V
            call UnGetMap      (EulerModel%ObjMap, EulerModel%ComputeFaces3D_V, STAT = STAT_CALL) 
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR170'


            !Lupward
            call UngetTurbulence(EulerModel%ObjTurbulence, EulerModel%Lupward, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR180'

            !Ldownward
            call UngetTurbulence(EulerModel%ObjTurbulence, EulerModel%Ldownward, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR190'


            !MixingLengthX
            call UngetTurbulence(EulerModel%ObjTurbulence, EulerModel%MixingLengthX, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR200'
            
            !MixingLengthY
            call UngetTurbulence(EulerModel%ObjTurbulence, EulerModel%MixingLengthY, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR210'
        
            !DiffusionH
            call UngetTurbulence(EulerModel%ObjTurbulence, EulerModel%DiffusionH, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR212'
            
            !DiffusionV
            call UngetTurbulence(EulerModel%ObjTurbulence, EulerModel%DiffusionV, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR214'
            
            !Velocity_U
            call UngetHydrodynamic (EulerModel%ObjHydrodynamic, EulerModel%Velocity_U, STAT  = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR220'


            !Velocity_V
            call UngetHydrodynamic (EulerModel%ObjHydrodynamic, EulerModel%Velocity_V, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR230'


            !Velocity_W
            call UngetHydrodynamic (EulerModel%ObjHydrodynamic, EulerModel%Velocity_W, STAT = STAT_CALL)                    
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR240'
                
#ifndef _WAVES_
            if (Me%State%Waves  .and. .not. Me%ConstructLag) then

                call UnGetWaves (EulerModel%ObjWaves, EulerModel%WavePeriod2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR250'

                call UnGetWaves (EulerModel%ObjWaves, EulerModel%WaveHeight2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR260'

                call UnGetWaves (EulerModel%ObjWaves, EulerModel%WaveDirection2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR270'

                call UnGetWaves (EulerModel%ObjWaves, EulerModel%WaveLength2D, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockExternalVar - ModuleLagrangianGlobal - ERR270'

            endif      
#endif                         

        enddo em1

        nullify(EulerModel)
        !----------------------------------------------------------------------

    end subroutine ReadUnLockExternalVar

    !--------------------------------------------------------------------------

    subroutine ReadUnLockEulerianDensity

        !Local-----------------------------------------------------------------
        type (T_EulerModel), pointer                :: EulerModel
        integer                                     :: STAT_CALL, em

        !Begin-----------------------------------------------------------------

em1:    do em =1, Me%EulerModelNumber

            EulerModel => Me%EulerModel(em)

            !Sigma Density
            if ((Me%State%FarFieldBuoyancy  .or. Me%State%ComputePlume) .and.           &
                associated(EulerModel%SigmaDensity)) then

                call UngetWaterProperties (EulerModel%ObjWaterProperties, EulerModel%SigmaDensity, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockEulerianDensity - ModuleLagrangianGlobal - ERR10'

            endif

            !Density
            if ((Me%State%Density) .and.  associated(EulerModel%Density)) then
                call UngetWaterProperties (EulerModel%ObjWaterProperties, EulerModel%Density, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ReadUnLockEulerianDensity - ModuleLagrangianGlobal - ERR20'
            endif

        enddo em1

        nullify(EulerModel)
        !----------------------------------------------------------------------

    end subroutine ReadUnLockEulerianDensity

    !--------------------------------------------------------------------------
    
#ifdef _OPENMI_    
        
    !DEC$ IFDEFINED (VF66)
    !dec$ attributes dllexport::SetBoomLocation
    !DEC$ ELSE
    !dec$ attributes dllexport,alias:"_SETBOOMLOCATION"::SetBoomLocation
    !DEC$ ENDIF
    !logical function SetBoomLocation(LagrangianID, nPoints, boomCoordsX, boomCoordsY, boomHasBuffer)
    logical function SetBoomLocation(LagrangianID, nPoints, boomCoordsX, boomCoordsY)
    
        !Arguments-------------------------------------------------------------
        integer                                     :: LagrangianID
        integer                                     :: nPoints
        real(8), dimension(nPoints)                 :: boomCoordsX
        real(8), dimension(nPoints)                 :: boomCoordsY
        !logical, optional                           :: boomHasBuffer
        
        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: ready_         
        integer                                     :: iPoint
        type(T_Polygon), pointer                    :: CurrPolygon
        type(T_Lines), pointer                      :: CurrLine

        call Ready(LagrangianID, ready_)    
        
        if ((ready_ .EQ. IDLE_ERR_) .OR. (ready_ .EQ. READ_LOCK_ERR_)) then
        
            !Deallocates current boom
            !if (associated(Me%Booms%Individual)) then
            !    deallocate(Me%Booms%Individual)
            !endif

            
            if (nPoints == 0) then

                Me%Booms%Number = 0
                
            else
                               
                !Me%Booms%Number = 1
                !allocate(Me%Booms%Individual(Me%Booms%Number))
                !
                !Me%Booms%Individual(1)%Name = "External Imposed Boom"
                !
                !Me%Booms%Individual(1)%Description = "Description"
                !
                !Me%Booms%Individual(1)%VelLimit = 0.4
                !
                !Me%Booms%Individual(1)%WaveLimit = 0.6
                
                !!check if in the openMI is sent a line or a polygon
                !if (present (boomHasBuffer)) then                
                !    Me%Booms%Individual(1)%BoomHasBuffer = boomHasBuffer
                !else
                !    Me%Booms%Individual(1)%BoomHasBuffer = .false.
                !endif
                
                !Me%Booms%Individual(1)%BoomHasBuffer = .true.
                
                !will be using a polygon - defined now in data file
                !if (Me%Booms%Individual(1)%BoomHasBuffer) then
                !    
                !    nullify(Me%Booms%Individual(1)%Polygon)
                !
                !    call Add(Me%Booms%Individual(1)%Polygon, CurrPolygon)
                !
                !    CurrPolygon%Count = nPoints
                !
                !    allocate(CurrPolygon%VerticesF(1:CurrPolygon%Count))
                !
                !    do iPoint = 1, nPoints
                !        CurrPolygon%VerticesF(iPoint)%X = boomCoordsX(iPoint)
                !        CurrPolygon%VerticesF(iPoint)%Y = boomCoordsY(iPoint)
                !    enddo
                !                        
                !    call SetLimits(CurrPolygon)                    
                !
                !else !will be using a line
                    
                !will use the associated (the first) boom defined in Lagrangian data file
                if (.not. associated(Me%Booms%Individual)) then
                    write(*,*) 'Need to have one Boom associated in Langrangian data file.'
                    stop 'Module LagrangianGlobal - SetBoomLocation - ERR001'
                endif
                
                !use only one boom (the first)
                Me%Booms%Number = 1
                    
                !it will overwrite the first boom line and use all other info
                nullify(Me%Booms%Individual(1)%Lines)

                call Add(Me%Booms%Individual(1)%Lines, CurrLine)
                
                CurrLine%nNodes = nPoints
                

                allocate(CurrLine%X(1:CurrLine%nNodes))
                allocate(CurrLine%Y(1:CurrLine%nNodes))

                do iPoint = 1, nPoints
                    CurrLine%X(iPoint) = boomCoordsX(iPoint)
                    CurrLine%Y(iPoint) = boomCoordsY(iPoint)
                enddo
                                        
                call SetLimits(CurrLine)     
                
                !endif
                
            endif
                

            SetBoomLocation = .true.
        else 
            call PlaceErrorMessageOnStack("Lagrangian not ready")
            SetBoomLocation = .false.
        end if
           

    end function SetBoomLocation
    
    !--------------------------------------------------------------------------

    
#endif    

end Module ModuleLagrangianGlobal

!----------------------------------------------------------------------------------------------------------
!MOHID Water Modelling System.
!Copyright (C) 1985, 1998, 2002, 2005. Instituto Superior Técnico, Technical University of Lisbon. 
!----------------------------------------------------------------------------------------------------------
