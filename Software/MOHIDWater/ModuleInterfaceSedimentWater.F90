!------------------------------------------------------------------------------
!        IST/MARETEC, Water Modelling Group, Mohid modelling system
!------------------------------------------------------------------------------
!
! TITLE         : Mohid Model
! PROJECT       : Mohid Base 1
! MODULE        : InterfaceSedimentWater
! URL           : http://www.mohid.com
! AFFILIATION   : IST/MARETEC, Marine Modelling Group
! DATE          : May 2003
! REVISION      : Luis Fernandes - v4.0
! DESCRIPTION   : Module to compute water-sediment interface fluxes
!
!------------------------------------------------------------------------------
!
!This program is free software; you can redistribute it and/or
!modify it under the terms of the GNU General Public License
!version 2, as published by the Free Software Foundation.
!
!This program is distributed in the hope that it will be useful,
!but WITHOUT ANY WARRANTY; without even the implied warranty of
!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!GNU General Public License for more details.
!
!You should have received a copy of the GNU General Public License
!along with this program; if not, write to the Free Software
!Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
!
!------------------------------------------------------------------------------
!DataFile
!   <begin_manning>
!   See module FillMatrix       : -                -            !Initialization of Manning coefficients
!                                                               !NOTE: mandatory to be included in data file
!                                                               !if not found searches rugosity block
!   <end_manning>

!   <begin_rugosity>
!   See module FillMatrix       : -                [m]          !Initialization of rugosity coefficients
!                                                               !NOTE: mandatory to be included in data file
!   <end_rugosity>

!   <begin_waverugosity>
!   See module FillMatrix       : -                [m]          !Initialization of wave rugosity coefficients
!   <end_waverugosity>

!   <begin_consolidation_rate>
!   See module FillMatrix       : -               [s-1]         !Initialization of consolidation rate
!   <end_consolidation_rate>

!   <begin_critical_shear_deposition>
!   See module FillMatrix       : -               [N/m2]        !Initialization of critical shear stress for deposition
!   <end_critical_shear_deposition>

!   <begin_critical_shear_erosion>
!   See module FillMatrix       : -               [N/m2]        !Initialization of critical shear stress for erosion
!   <end_critical_shear_erosion>
!
!   <begin_erosion_rate>
!   See module FillMatrix       : -              [kg/m2s]       !Initialization of erosion rate
!   <end_erosion_rate>


!   CONSOLIDATION               : 0/1              [0]          !Compute consolidation
!   WAVETENSION                 : 0/1              [0]          !Compute wave induced shear stress
!   SAND_TRANSPORT              : 0/1              [0]          !Compute sand tranport
!   SHEAR_STRESS_METHOD         : 1/2              [1]          !1-Default Mohid Method 2-Soulsby and Clarke(2005) GFranz
!   SHEAR_STRESS_LIMITATION     : 0/1              [0]          !Limit shear stress values in shallow zones
!       REFERENCE_DEPTH         : real           [0.2 m]        !Reference depth below which shear stress is
!                                                               !is limited
!       REFERENCE_SHEAR_STRESS  : real         [0.25 N/m2]      !Shear stress value assumed in limited cells
!   STATISTICS_SHEAR            : 0/1              [0]          !Perform statistics to shear velocity
!       STATISTICS_SHEAR_FILE   : char              -           !Path to statistics input data file
!   OUTPUT_SHEAR_STRESS         : 0/1              [0]          !Output shear stress in HDF format
!   OUTPUT_TIME                 : sec. sec. sec.    -           !Output Time
!   RESTART_FILE_OUTPUT_TIME    : sec. sec. sec.    -           !Output Time to write restart files
!   RESTART_FILE_OVERWRITE      : 0/1              [1]          !Overwrite intermediate restart files
!   TIME_SERIE_LOCATION         : char              -           !Path to time serie location file
!   BOXFLUXES                   : char              -           !If specified computes box integration
!                                                               !based on boxes file defined by this keyword

!<beginproperty>
!   NAME                        : char              -           !Property name
!   UNITS                       : char              -           !Property units
!   DESCRIPTION                 : char              -           !Small description of the property
!   See module FillMatrix       : -                 -           !Initialization of concentration values
!                                                               !NOTE: Dissolved properties don?t have mass available
!   MASS_LIMITATION             : 0/1               -           !Property mass is finite
!   MASS_MIN                    : real         [1e-6 kg/m2]     !Minimum mass allowed
!   PARTICULATE                 : 0/1              [0]          !Property physical state: 0 - Dissolved ; 1 - Particulate
!   OLD                         : 0/1              [0]          !Initialization from previous run (overrides FillMatrix)
!   BENTHOS                     : 0/1              [0]          !Compute benthic ecological processes
!   BENTHICECOLOGY              : 0/1              [0]          !Compute benthic ecological processes with module BenthicEcology
!   CEQUALW2                    : 0/1              [0]          !Compute CEQUALW2 benthic ecological processes
!   DETRITUS                    : 0/1              [0]          !Computed as detritus
!   SEDIMENT_WATER_FLUXES       : 0/1              [0]          !Compute fluxes between sediment and water column
!       <<begin_diff_coef>>
!       See module FillMatrix   : -              [m2/s]         !Initialization of diffusion coefficient at the ISW
!       <<end_diff_coef>>
!   SEDIMENT_FLUXES             : 0/1              [0]          !Compute fluxes between ISW and sediment column
!   WATER_FLUXES                : 0/1              [0]          !Compute fluxes to/from water column
!   EROSION                     : 0/1              [0]          !Compute erosion
!   DEPOSITION                  : 0/1              [0]          !Compute deposition
!   DT_INTERVAL                 : real          [ModelDT]       !Property evolution time step (seconds)
!   TIME_SERIE                  : 0/1              [0]          !Ouputs results in time series
!   BOX_TIME_SERIE              : 0/1              [0]          !Ouputs results in box time series
!   OUTPUT_HDF                  : 0/1              [0]          !Ouputs results in HDF5 format
!   OUTHDF_ORIGIN_UNIT          : 0/1              [0]          !Ouputs results in the original units (other than concentration)
!<endproperty>
!

!<beginbenthicrate>
!   NAME                        : char              -           !Name of the rate to perform output
!   DESCRIPTION                 : char              -           !Description of the rate to perform output
!   FIRSTPROP                   : char              -           !Name of the first property involved in the rate
!   SECONDPROP                  : char              -           !Name of the second property involved in the rate
!<endbenthicrate>


Module ModuleInterfaceSedimentWater

    use ModuleGlobalData
    use ModuleEnterData
    use ModuleDrawing
    use ModuleTime
    use ModuleFunctions,            only: ConstructPropertyID, TimeToString, ChangeSuffix,  &
                                          CHUNK_J, CHUNK_I
    use ModuleHDF5,                 only: ConstructHDF5, GetHDF5FileAccess, HDF5SetLimits,  &
                                          HDF5WriteData, HDF5FlushMemory, HDF5ReadWindow,   &
                                          GetHDF5GroupExist, KillHDF5
    use ModuleGridData,             only: GetGridData, UngetGridData
    use ModuleHorizontalGrid,       only: GetHorizontalGrid, GetHorizontalGridSize,         &
                                          WriteHorizontalGrid, UnGetHorizontalGrid,         &
                                          GetGridCellArea, GetXYCellZ, GetDDecompMPI_ID,    &
                                          GetDDecompON, GetGridOutBorderPolygon,            &
                                          GetDDecompParameters, GetDDecompWorkSize2D
    use ModuleHorizontalMap,        only: GetOpenPoints2D, GetWaterPoints2D, GetBoundaries, &
                                          UnGetHorizontalMap
    use ModuleGeometry,             only: GetGeometrySize, GetGeometryWaterColumn,          &
                                          UnGetGeometry, GetGeometryKFloor,                 &
                                          GetGeometryVolumes, GetGeometryDistances,         &
                                          GetGeometryMinWaterColumn, GetGeometryKtop
    use ModuleMap,                  only: GetWaterPoints3D, GetOpenPoints3D,                &
                                          GetLandPoints3D, UngetMap
    use ModuleBoxDif,               only: StartBoxDif, GetBoxes, GetNumberOfBoxes, BoxDif,  &
                                          UngetBoxDif, KillBoxDif
    use ModuleTimeSerie,            only: StartTimeSerie, WriteTimeSerie, KillTimeSerie,    &
                                          GetTimeSerieLocation, CorrectsCellsTimeSerie,     &
                                          GetNumberOfTimeSeries, TryIgnoreTimeSerie, GetTimeSerieName
    use ModuleStatistic,            only: ConstructStatistic, GetStatisticMethod,           &
                                          GetStatisticParameters, ModifyStatistic,          &
                                          KillStatistic
    use ModuleStopWatch,            only: StartWatch, StopWatch
    use ModuleWaterProperties,      only: GetWaterPropertiesSubModulesID, GetConcentration, &
                                          UnGetWaterProperties, GetWaterPropertyOptions,    &
                                          SetFluxToWaterProperties, WaterPropertyExists,    &
                                          GetWaterPropertiesBottomOptions,                  &
                                          SetMacroAlgaeParameters,                          &
                                          GetShortWaveRadiationAverage,                     &
                                          GetSeagrassesLeavesRates, GetSeagrassArray2D
    use ModuleHydrodynamic,         only: GetChezy,GetHorizontalVelocity, UnGetHydrodynamic,&
                                          SetHydrodynamicManning, SetBottomWaterFlux,       &
                                          SetHydrodynamicRugosityMatrix, GetWavesStressON,  &
                                          SetWaveChezyVel, SetHydrodynamicChezy,            &
                                          GetResidualVelocityON,                            &
                                          GetResidualHorizontalVelocity,                    &
                                          SetShearStressMethod, SetWaveShearStress,         &
                                          GetResidualVelocityPeriod

#ifndef _LAGRANGIAN_
#ifdef  _LAGRANGIAN_GLOBAL_
    use ModuleLagrangianGlobal,     only: SetLagrangianShearGlobal
#else
    use ModuleLagrangian,           only: SetLagrangianShear
#endif
#endif



    use ModuleTurbGOTM,             only: SetTurbGOTMBottomRugosity,                        &
                                          SetTurbGOTMBottomShearVelocity
    use ModuleTurbulence,           only: SetTurbulenceBottomRugosity
    use ModuleFreeVerticalMovement, only: Get_FreeConvFlux, SetDepositionProbability,       &
                                          UngetFreeVerticalMovement, FreeVertPropertyExists,&
                                          Get_FreeVelocity, FreeVertPropertyHasDeposition,  &
                                          SetShearVelocity, GetDepositionIntertidalZones,   &
                                          SetSandParameters
#ifndef _SEDIMENT_
    use ModuleSedimentProperties,   only: SedimentPropertyExists,GetSedimentPropertyOptions,&
                                          GetSedimentConcentration, UnGetSedimentProperties,&
                                          SetFluxToSedimentProperties, SetSedimentWaterFlux,&
                                          GetSedimentDryDensity,                            &
                                          GetSeagrassesRootsRates, GetRootsArray2D             ! Isabella


    use ModuleConsolidation,        only: GetConsolidationWaterFluxes,                      &
                                          GetConsolidationOptions,                          &
                                          GetConsolidationPorosity,                         &
                                          GetConsolidationCriticalShear,                    &
                                          GetConsolidationDrySedVolume,                     &
                                          SetConsolidationFlux,                             &
                                          GetSedimentColumnFull,                            &
                                          GetConsolidationMinThickness, UngetConsolidation
#endif
    use ModuleInterface,            only: ConstructInterface, SetSOD, Modify_Interface, GetRateFlux,&
                                          KillInterface
#ifndef _WAVES_
    use ModuleWaves,                only: GetWaves, UnGetWaves
#endif
    use ModuleFillMatrix,           only: ConstructFillMatrix, GetIfMatrixRemainsConstant,  &
                                          GetDefaultValue, KillFillMatrix
    use ModuleSand,                 only: StartSand, ModifySand, KillSand,                  &
                                          GetSandDiameters, GetSandDensity, UnGetSand
    use ModuleSediment,             only: ConstructSediment, ModifySediment,                &
                                          SetCohesiveFlux, SetNonCohesiveFlux,              &
                                          GetTopCriticalShear, GetConcRef,                  &
                                          GetCohesiveMass, GetCohesiveContent, GetSandMass, &
                                          GetSandContent, GetCriticalShearStress,           &
                                          GetReferenceLevel, SetWaveTensionON,              &
                                          GetGrainRoughness, GetD50, UnGetSediment,         &
                                          SetWaterPointsOpenPoints2D, GetNumberOfClasses,   &
                                          GetSandParameters
    implicit none

    private

    !Subroutines---------------------------------------------------------------

    !Constructor
    public  :: StartInterfaceSedimentWater
    private ::      AllocateInstance
    private ::      ReadWaterSedimentFilesName
    private ::      ConstructGlobalVariables
    private ::      ConstructShearStress
    private ::          ConstructShearLimitation
    private ::          ConstructShearStatistics
    private ::          ConstructWaveShearStress
    private ::      ConstructRugosity
    private ::      Construct_PropertyList
    private ::          Construct_Property
    private ::              Construct_PropertyValues
    private ::                  Read_Property_2D
    private ::                  Read_Old_Properties_2D
    private ::              Construct_PropertyEvolution
    private ::              Construct_PropertyOutPut
    private ::          Add_Property
    private ::      Construct_BenthicRateList
    private ::          Construct_BenthicRate
    private ::              Construct_BenthicRateID
    private ::              Construct_BenthicRateValues
    private ::          Add_BenthicRate
    private ::      ConstructConsolidation
    private ::      Construct_Sub_Modules
    private ::          CoupleBenthos
    private ::          CoupleBenthicEcology
    private ::          CoupleCEQUALW2
    private ::          CheckOptionsWaterFluxes
#ifndef _SEDIMENT_
    private ::          CheckOptionsSedimentFluxes
    private ::          CheckOptionsSedimentWaterFluxes
#endif
    private ::          Construct_Time_Serie
    private ::          StartOutputBoxFluxes
    private ::      ConstructSandTransport
    private ::      ConstructSedimentTransport


    private ::      SetSubModulesConstructor

    !Selector
    private :: Search_Property


    !Modifier
    public  :: ModifyInterfaceSedimentWater
    private ::      ModifyShearStress
    private ::          ComputeWaveRugosity
    private ::          ComputeWaveTension
    private ::          Compute_DragCoef
    private ::      Benthos_Processes
    private ::      BenthicEcology_Processes
    private ::      Detritus_Processes
    private ::      CEQUALW2_Processes
    private ::      ModifyWaterColumnFluxes
    private ::          InitializeFluxesToWaterColumn
    private ::          InitializeFluxesToWaterColumn_Benthic
    private ::          ModifyErosionFluxes
    private ::              ModifyErosionCoefficient
    private ::              ErosionFlux             !Function
    private ::              ShearStressLimitation   !Function
    private ::          ModifyDepositionFluxes
    private ::              DepositionProbability   !Function
    private ::          ModifyNonCohesiveErosionFluxes
    private ::          ModifyNonCohesiveDepositionFluxes
    private ::          ModifyDissolvedFluxes
    private ::      ModifySedimentColumnFluxes
    private ::          InitializeFluxesToSediment
    private ::          ComputeConsolidation
    private ::          ModifyConsolidatedErosionFluxes
    private ::      ModifySedimentWaterFluxes
    private ::          ComputeWaterFlux
    private ::          DissolvedSedimentWaterFluxes
    private ::          ParticulateSedimentWaterFluxes
    private ::      ModifySandTransport
    private ::      ModifySedimentTransport
    private ::      ModifyRugosity
    private ::      ComputeEfficiencyFactor
    private ::      Output_TimeSeries
    private ::      Output_BoxTimeSeries
    private ::      OutPut_Results_HDF
    private ::      OutPut_Statistics
    private ::      TimeStepActualization
    private ::      Actualize_Time_Evolution
    private ::      OutputRestartFile

    private ::      SetSubModulesModifier
    private ::          SetFluxesToWaterColumn
#ifndef _SEDIMENT_
    private ::          SetFluxesToSedimentColumn
#endif

    !Destructor
    public  :: KillInterfaceSedimentWater
    private ::      DeAllocateInstance


    !Management
    private ::      Ready
    private ::          LocateObjInterfaceSedimentWater

    private ::              ReadLockExternalGlobal
#ifndef _SEDIMENT_
    private ::              ReadLockExternalSediment
    private ::              ReadUnlockExternalSediment
#endif
    private ::              ReadLockExternalWater
    private ::              ReadUnlockExternalGlobal
    private ::              ReadUnlockExternalWater


    !Interfaces----------------------------------------------------------------


    !Parameters----------------------------------------------------------------
    character(LEN = StringLength), parameter        :: cse_begin                = '<begin_critical_shear_erosion>'
    character(LEN = StringLength), parameter        :: cse_end                  = '<end_critical_shear_erosion>'
    character(LEN = StringLength), parameter        :: csd_begin                = '<begin_critical_shear_deposition>'
    character(LEN = StringLength), parameter        :: csd_end                  = '<end_critical_shear_deposition>'
    character(LEN = StringLength), parameter        :: erosion_begin            = '<begin_erosion_rate>'
    character(LEN = StringLength), parameter        :: erosion_end              = '<end_erosion_rate>'

    character(LEN = StringLength), parameter        :: manning_begin            = '<begin_manning>'
    character(LEN = StringLength), parameter        :: manning_end              = '<end_manning>'
    character(LEN = StringLength), parameter        :: rugosity_begin           = '<begin_rugosity>'
    character(LEN = StringLength), parameter        :: rugosity_end             = '<end_rugosity>'
    character(LEN = StringLength), parameter        :: SOD_begin                = '<begin_SOD_Rate>'
    character(LEN = StringLength), parameter        :: SOD_end                  = '<end_SOD_Rate>'


    character(LEN = StringLength), parameter        :: waverugosity_begin       = '<begin_waverugosity>'
    character(LEN = StringLength), parameter        :: waverugosity_end         = '<end_waverugosity>'

    character(LEN = StringLength), parameter        :: consolidation_begin      = '<begin_consolidation_rate>'
    character(LEN = StringLength), parameter        :: consolidation_end        = '<end_consolidation_rate>'

    character(LEN = StringLength), parameter        :: prop_block_begin         = '<beginproperty>'
    character(LEN = StringLength), parameter        :: prop_block_end           = '<endproperty>'
    character(LEN = StringLength), parameter        :: rate_block_begin         = '<beginbenthicrate>'
    character(LEN = StringLength), parameter        :: rate_block_end           = '<endbenthicrate>'

    character(LEN = StringLength), parameter        :: diff_coef_begin          = '<<begin_diff_coef>>'
    character(LEN = StringLength), parameter        :: diff_coef_end            = '<<end_diff_coef>>'

    !Types---------------------------------------------------------------------

    type     T_ID
        integer                                     :: IDNumber     = null_int !initialization: Jauch
        character(LEN = StringLength)               :: Name         = null_str !initialization: Jauch
        character(LEN = StringLength)               :: Description  = null_str !initialization: Jauch
        character(LEN = StringLength)               :: Units        = null_str !initialization: Jauch
    end type T_ID

    type       T_Files
         character(len=PathLength)                  :: InputData    = null_str !initialization: Jauch
         character(len=PathLength)                  :: Final        = null_str !initialization: Jauch
         character(len=PathLength)                  :: Initial      = null_str !initialization: Jauch
         character(len=PathLength)                  :: Results      = null_str !initialization: Jauch
         character(len=PathLength)                  :: BoxesFile    = null_str !initialization: Jauch
    end type T_Files

    type       T_OutPut
         type (T_Time), pointer, dimension(:)       :: OutTime          => null(), &
                                                       RestartOutTime   => null()

         integer                                    :: NextOutPut           = null_int, & !initialization: Jauch
                                                       NextRestartOutPut    = null_int    !initialization: Jauch
         logical                                    :: WriteRestartFile     = .false.
         logical                                    :: Yes                  = .false. !initialization: Jauch
         logical                                    :: WriteFinalFile       = .false.
         logical                                    :: RestartOverwrite     = .false. !initialization: Jauch
    end type T_OutPut

    type       T_Ext_Global
        type(T_Time)                                :: Now
        real,    pointer, dimension(:,:  )          :: XX_IE        => null(), &
                                                       YY_IE        => null(), &
                                                       GridCellArea => null()
    end type T_Ext_Global

    type       T_Ext_Water
        real,    pointer, dimension(:,:  )          :: Chezy            => null()
        real,    pointer, dimension(:,:,:)          :: DWZ              => null()
        real,    pointer, dimension(:,:,:)          :: SZZ              => null()
        real,    pointer, dimension(:,:,:)          :: Velocity_U       => null()
        real,    pointer, dimension(:,:,:)          :: Velocity_V       => null()
        real(8), pointer, dimension(:,:,:)          :: VolumeZ          => null()
        real(8), pointer, dimension(:,:,:)          :: VolumeZOld       => null()
        integer, pointer, dimension(:,:  )          :: WaterPoints2D    => null()
        integer, pointer, dimension(:,:  )          :: OpenPoints2D     => null()
        integer, pointer, dimension(:,:  )          :: BoundaryPoints2D => null()
        integer, pointer, dimension(:,:,:)          :: WaterPoints3D    => null()
        integer, pointer, dimension(:,:,:)          :: OpenPoints3D     => null()
        integer, pointer, dimension(:,:,:)          :: LandPoints3D     => null()
        real,    pointer, dimension(:,:  )          :: Bathymetry       => null()
        real,    pointer, dimension(:,:  )          :: WaterColumn      => null()
        real(8), pointer, dimension(:,:)            :: WaterVolume      => null()
        real,    pointer, dimension(:,:)            :: Sediment         => null()
        real                                        :: MinWaterColumn   = null_real !initialization: Jauch
        integer, pointer, dimension(:,:  )          :: KFloor_Z         => null()
        real,    pointer, dimension(:,:  )          :: WavePeriod       => null(), &
                                                       WaveHeight       => null(), &
                                                       WaveDirection    => null()
        real,    pointer, dimension(:,:,:)          :: DirectionH       => null()
        real,    pointer, dimension(:,:  )          :: Ubw              => null(), &
                                                       Abw              => null()
        type(T_Time)                                :: LastComputeWave

        real,    pointer, dimension(:,:,:)          :: VelocityResidual_U       => null()
        real,    pointer, dimension(:,:,:)          :: VelocityResidual_V       => null()
        logical                                     :: ResidualON               = .false.

    end type T_Ext_Water

    type       T_Ext_Sed
        real                                        :: MinLayerThickness    = null_real !initialization: Jauch
        real,    pointer, dimension(:,:,:)          :: DWZ                  => null()
        real,    pointer, dimension(:,:,:)          :: SZZ                  => null()
        real(8), pointer, dimension(:,:,:)          :: VolumeZ              => null()
        real(8), pointer, dimension(:,:,:)          :: VolumeZOld           => null()
        integer, pointer, dimension(:,:  )          :: WaterPoints2D        => null(), &
                                                       KTop                 => null()
        integer, pointer, dimension(:,:  )          :: OpenPoints2D         => null()
        integer, pointer, dimension(:,:  )          :: BoundaryPoints2D     => null()
        integer, pointer, dimension(:,:,:)          :: WaterPoints3D        => null()
        integer, pointer, dimension(:,:,:)          :: OpenPoints3D         => null()
        integer, pointer, dimension(:,:,:)          :: LandPoints3D         => null()
        real,    pointer, dimension(:,:,:)          :: Porosity             => null()
        real(8), pointer, dimension(:,:,:)          :: WaterFluxZ           => null(), &
                                                       DrySedVolume         => null()
        real   , pointer, dimension(:,:  )          :: TopCriticalShear     => null()
        real   , pointer, dimension(:,:,:)          :: SedimentDryDensity   => null()
        integer, pointer, dimension(:,:  )          :: SedimentColumnFull   => null()
        logical                                     :: ComputeConsolidation = .false.
        real(8), pointer, dimension(:,:,:)          :: CohesiveMass         => null()
        real, pointer, dimension(:,:,:)             :: CohesiveContent      => null()
        logical                                     :: CohesiveClassRun     = .false.
        !real                                        :: ReferenceLevel       = null_real
    end type T_Ext_Sed

    type       T_Property_2D
        type(T_PropertyID)                          :: ID
        real, pointer, dimension (:,:)              :: Field    => null()
        real                                        :: Scalar   = null_real
        logical                                     :: Constant = .false.
        logical                                     :: OLD      = .false.
    end type T_Property_2D

    type       T_Evolution
        logical                                     :: Variable             = .false.
        logical                                     :: Benthos              = .false.
        logical                                     :: BenthicEcology       = .false.
        logical                                     :: BenthicOnly          = .false.
        logical                                     :: CEQUALW2             = .false.
        logical                                     :: Detritus             = .false.
        logical                                     :: SedimentWaterFluxes  = .false.
        logical                                     :: SedimentFluxes       = .false.
        logical                                     :: WaterFluxes          = .false.
        logical                                     :: Erosion              = .false.
        logical                                     :: Deposition           = .false.
        real                                        :: DTInterval           =  null_real
        type(T_Time)                                :: LastCompute
        type(T_Time)                                :: NextCompute
    end type  T_Evolution

    type       T_Property
         type(T_PropertyID)                         :: ID
!~          logical                                    :: Particulate          = .false.
         real, dimension(:,:), pointer              :: Mass_Available           => null()
         real, dimension(:,:), pointer              :: WaterConcentration       => null()
         real, dimension(:,:), pointer              :: MassInKg                 => null()
         real, dimension(:,:), pointer              :: Mass_FromWater           => null()
         real, dimension(:,:), pointer              :: SedimentConcentration    => null()
         real, dimension(:,:), pointer              :: FluxToWater              => null()
         real, dimension(:,:), pointer              :: FluxToSediment           => null()
         real, dimension(:,:), pointer              :: ErosionFlux              => null()
         real, dimension(:,:), pointer              :: DepositionFlux           => null()
         real, dimension(:,:), pointer              :: ErosionCoefficient       => null()
         real                                       :: Mass_Min             = FillValueReal
         logical                                    :: Old                  = .false.
         logical                                    :: Mass_Limitation      = .false.
         logical                                    :: TimeSerie            = .false.
         logical                                    :: BoxTimeSerie         = .false.
         logical                                    :: OutputHDF            = .false.
         logical                                    :: OutHDFOrigin         = .false.
         logical                                    :: Non_Cohesive         = .false.
         type(T_Property_2D)                        :: MolecularDifCoef
         type(T_Evolution)                          :: Evolution
         type(T_Property), pointer                  :: Next => null()
         type(T_Property), pointer                  :: Prev => null()
    end type  T_Property

    type       T_BenthicRate
        type (T_ID)                                 :: ID
        type (T_ID)                                 :: FirstProp
        type (T_ID)                                 :: SecondProp
        real, pointer, dimension(:,:)               :: Field    => null()
        real, pointer, dimension(:,:)               :: Field2   => null()
        type(T_BenthicRate), pointer                :: Next => null(), &
                                                       Prev => null()
    end type   T_BenthicRate


    type      T_Coupling
         type(T_Time)                               :: NextCompute
         real                                       :: DT_Compute           = FillValueReal
         logical                                    :: Yes                  = .false.
         integer                                    :: NumberOfProperties   = 0
    end type T_Coupling

    type       T_Coupled
         type(T_Coupling)                           :: Benthos
         type(T_Coupling)                           :: BenthicEcology
         type(T_Coupling)                           :: CEQUALW2
         type(T_Coupling)                           :: Detritus
         type(T_Coupling)                           :: SedimentFluxes
         type(T_Coupling)                           :: WaterFluxes
         type(T_Coupling)                           :: SedimentWaterFluxes
         type(T_Coupling)                           :: Erosion
         type(T_Coupling)                           :: Deposition
         type(T_Coupling)                           :: TimeSerie
         type(T_Coupling)                           :: BoxTimeSerie
         type(T_Coupling)                           :: OutputHDF
         type(T_Coupling)                           :: OutHDFOrigin
    end type T_Coupled

    type       T_Statistics
         integer                                    :: ID   = null_int !initialization: Jauch
         character(LEN = StringLength)              :: File = null_str !initialization: Jauch
         logical                                    :: ON   = .false.  !initialization: Jauch
    end type   T_Statistics

    type       T_Consolidation
         logical                                    :: Yes                  = .false.
         real, pointer, dimension(:,:)              :: Flux
         type(T_Property_2D)                        :: Rate
         type(T_Time)                               :: LastCompute
    end type  T_Consolidation

   Type T_Seagrasses     ! Isabella
   type(T_PropertyID)                               :: ID
        real,    pointer, dimension(:,:  )          :: UptakeNH4NO3w2D  => null()
        real,    pointer, dimension(:,:  )          :: UptakeNH4s2D     => null()
        real,    pointer, dimension(:,:  )          :: UptakePO4w2D     => null()
        real,    pointer, dimension(:,:  )          :: UptakePO4s2D     => null()
        real,    pointer, dimension(:,:  )          :: LightFactor2D    => null()
        real, pointer, dimension(:,:  )             :: Array2D          => null()
   end type T_Seagrasses


    type       T_Shear
         real, pointer, dimension (:,:)             :: CurrentVel       => null()
         real, pointer, dimension (:,:)             :: CurrentU         => null()
         real, pointer, dimension (:,:)             :: CurrentV         => null()
         real, pointer, dimension (:,:)             :: CurrentResidualU => null()
         real, pointer, dimension (:,:)             :: CurrentResidualV => null()
         real, pointer, dimension (:,:)             :: UFace            => null()
         real, pointer, dimension (:,:)             :: VFace            => null()
         real, pointer, dimension (:,:)             :: Velocity         => null()
         real, pointer, dimension (:,:)             :: Tension          => null()
         real, pointer, dimension (:,:)             :: Tension_X        => null()
         real, pointer, dimension (:,:)             :: Tension_Y        => null()
         logical                                    :: Limitation           = .false.
         real                                       :: ReferenceDepth       = null_real
         real                                       :: ReferenceShearStress = null_real
         type (T_Time)                              :: LastCompute
         real                                       :: DT                   = null_real
         type (T_Statistics)                        :: Statistics
         logical                                    :: IntertidalRunOff     = .false.
         integer                                    :: Method               = 1
         real, pointer, dimension (:,:)             :: EfficiencyFactorCurrent => null()
         real, pointer, dimension (:,:)             :: EfficiencyFactorMean    => null()
         real, pointer, dimension (:,:)             :: EfficiencyFactorWaves   => null()

         real                                       :: Residual_Period      = FillValueReal
         real, pointer, dimension (:,:)             :: Residual_Tau         => null()
         real, pointer, dimension (:,:)             :: Residual_Tau_X       => null()
         real, pointer, dimension (:,:)             :: Residual_Tau_Y       => null()

         logical                                    :: OutputON             = .false.
    end type T_Shear

    type       T_WaveShear
         logical                                    :: Yes                  = .false.
         logical                                    :: NonLinear            = .false.
         real, pointer, dimension (:,:)             :: Tension          => null()
         real, pointer, dimension (:,:)             :: TensionMean      => null()
         real, pointer, dimension (:,:)             :: TensionCurrents  => null()
         real, pointer, dimension (:,:)             :: ChezyVel         => null()
         real, pointer, dimension (:,:)             :: CWphi            => null()
         real, pointer, dimension (:,:)             :: Cphi             => null()
         type(T_Property_2D)                        :: Rugosity
         logical                                    :: RugosityRead = .false. !initialization: Jauch
         type(T_Time)                               :: LastCompute
    end type   T_WaveShear

    private :: T_InterfaceSedimentWater
    type       T_InterfaceSedimentWater
        integer                                     :: InstanceID
        character(PathLength)                       :: ModelName
        type(T_Time       )                         :: BeginTime
        type(T_Time       )                         :: EndTime
        type(T_Time       )                         :: ActualTime
        type(T_Size2D     )                         :: Size2D
        type(T_Size2D     )                         :: WorkSize2D
        type(T_Size3D     )                         :: WaterSize3D
        type(T_Size3D     )                         :: WaterWorkSize3D
        type(T_Size3D     )                         :: SedimentSize3D
        type(T_Size3D     )                         :: SedimentWorkSize3D
        type(T_Files      )                         :: Files
        type(T_OutPut     )                         :: Output
        type(T_Coupled    )                         :: Coupled
        type(T_Shear      )                         :: Shear_Stress
        type(T_WaveShear  )                         :: WaveShear_Stress
        type(T_Property_2D)                         :: Critical_Shear_Erosion
        type(T_Property_2D)                         :: Critical_Shear_Deposition
        type(T_Property_2D)                         :: ErosionRate
        type(T_Ext_Global )                         :: ExternalVar
        type(T_Ext_Water  )                         :: ExtWater
        type(T_Ext_Sed    )                         :: ExtSed
        type(T_Property   ), pointer                :: FirstProperty            => null()
        type(T_Property   ), pointer                :: LastProperty             => null()
        type(T_BenthicRate), pointer                :: FirstBenthicRate         => null()
        type(T_BenthicRate), pointer                :: LastBenthicRate          => null()
        real,dimension(:,:), pointer                :: DepositionProbability    => null()
        real,dimension(:,:), pointer                :: BottomSWRadiationAverage => null()
        logical                                     :: RunsSediments            = .false.
        logical                                     :: RunsSandTransport        = .false.
        logical                                     :: RunSedimentModule        = .false.
        logical                                     :: ComputeRugosity          = .false.
        real                                        :: RugosityDecayTime        = null_real
        logical                                     :: Manning                  = .false.
        logical                                     :: UseSOD                   = .false.
        logical                                     :: MacroAlgae               = .false.
        type(T_Property_2D)                         :: SOD
        type(T_Property_2D)                         :: Rugosity
        type(T_Property_2D)                         :: ManningCoef
        logical                                     :: Chezy    = .false. !initialization: Jauch
        real                                        :: ChezyCoef    = null_real !initialization: Jauch
        real(8), pointer, dimension(:,:)            :: Scalar2D     => null()
        real(8), pointer, dimension(:,:)            :: WaterFlux    => null()
        integer                                     :: PropertiesNumber         = 0
        integer                                     :: BenthicRatesNumber       = 0
        type(T_Consolidation)                       :: Consolidation
        type(T_Seagrasses )                         :: Seagrasses   ! Isabella
        real                                        :: Dewatering_Rate           = FillValueReal
        logical                                     :: DepositionIntertidalZones = .false.
        integer, pointer, dimension(:,:)            :: WaterPointsorOpenPoints2D   => null()

        !Instance of ModuleBoxDif
        integer                                     :: ObjBoxDif                = 0

        !Instance of ModuleEnterData
        integer                                     :: ObjEnterData             = 0

        !Instance of ModuleTimeSerie
        integer                                     :: ObjTimeSerie             = 0

        !Instance of ModuleHDF5
        integer                                     :: ObjHDF5                  = 0

        !Instance of ModuleTime
        integer                                     :: ObjTime                  = 0

        !Instance of ModuleDischarges
        integer                                     :: ObjDischarges            = 0

        !Instance of ModuleHorizontalGrid
        integer                                     :: ObjHorizontalGrid        = 0

        !Instance of ModuleGridData
        integer                                     :: ObjSedimentGridData      = 0

        !Instance of ModuleGridData
        integer                                     :: ObjWaterGridData         = 0

        !Instance of ModuleGeometry
        integer                                     :: ObjSedimentGeometry      = 0

        !Instance of ModuleGeometry
        integer                                     :: ObjWaterGeometry         = 0

        !Instance of ModuleHorizontalMap
        integer                                     :: ObjSedimentHorizontalMap = 0

        !Instance of ModuleHorizontalMap
        integer                                     :: ObjWaterHorizontalMap    = 0

        !Instance of ModuleMap
        integer                                     :: ObjSedimentMap           = 0

        !Instance of ModuleMap
        integer                                     :: ObjWaterMap              = 0

        !Instance of ModuleSand
        integer                                     :: ObjSand                  = 0

        !Instance of ModuleSediment
        integer                                     :: ObjSediment              = 0

        !Instance of ModuleHydrodynamic
        integer                                     :: ObjHydrodynamic          = 0

        !Instance of ModuleTurbulence
        integer                                     :: ObjTurbulence            = 0

        !Instance of ModuleTurbGOTM
        integer                                     :: ObjTurbGOTM              = 0

        !Instance of ModuleWaves
        integer                                     :: ObjWaves                 = 0

        !Instance of ModuleInterfaceSedimentWater
        integer                                     :: ObjWaterProperties       = 0

        !Instance of ModuleFreeVerticalMovement
        integer                                     :: ObjFreeVerticalMovement  = 0

        !Instance of ModuleSedimentProperties
        integer                                     :: ObjSedimentProperties    = 0

        !Instance of ModuleConsolidation
        integer                                     :: ObjConsolidation         = 0

        !Instance of ModuleInterface
        integer                                     :: ObjInterface             = 0

        !Instance of ModuleLagrangian
        integer                                     :: ObjLagrangian            = 0

        type(T_InterfaceSedimentWater), pointer     :: Next => null()
    end type  T_InterfaceSedimentWater

    !Global Module Variables
    type (T_InterfaceSedimentWater), pointer        :: FirstObjInterfaceSedimentWater   => null()
    type (T_InterfaceSedimentWater), pointer        :: Me                               => null()

    !--------------------------------------------------------------------------

    contains


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONSTRUCTOR CONS

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    subroutine StartInterfaceSedimentWater( ModelName,                      &
                                            ObjInterfaceSedimentWaterID,    &
                                            TimeID,                         &
                                            HorizontalGridID,               &
                                            WaterGridDataID,                &
                                            WaterHorizontalMapID,           &
                                            WaterMapID,                     &
                                            WaterGeometryID,                &
                                            SedimentGridDataID,             &
                                            SedimentHorizontalMapID,        &
                                            SedimentMapID,                  &
                                            SedimentGeometryID,             &
                                            HydrodynamicID,                 &
                                            TurbulenceID,                   &
                                            TurbGOTMID,                     &
                                            WavesID,                        &
                                            WaterPropertiesID,              &
                                            LagrangianID,                   &
                                            SedimentID,                     &
                                            SedimentPropertiesID,           &
                                            ConsolidationID,                &
                                            DischargesID,                   &
                                            RunsSediments,                  &
                                            SedimentModule,                 &
                                            STAT)

        !Arguments---------------------------------------------------------------
        character(Len=*)                                :: ModelName
        integer                                         :: ObjInterfaceSedimentWaterID
        integer                                         :: TimeID
        integer                                         :: HorizontalGridID
        integer                                         :: WaterGridDataID
        integer                                         :: WaterHorizontalMapID
        integer                                         :: WaterMapID
        integer                                         :: WaterGeometryID
        integer                                         :: SedimentGridDataID
        integer                                         :: SedimentHorizontalMapID
        integer                                         :: SedimentMapID
        integer                                         :: SedimentGeometryID
        integer                                         :: HydrodynamicID
        integer                                         :: LagrangianID
        integer                                         :: TurbulenceID
        integer                                         :: TurbGOTMID
        integer                                         :: WavesID
        integer                                         :: WaterPropertiesID
        integer                                         :: SedimentID
        integer                                         :: SedimentPropertiesID
        integer                                         :: ConsolidationID
        integer                                         :: DischargesID
        logical                                         :: RunsSediments
        logical                                         :: SedimentModule
        integer, optional, intent(OUT)                  :: STAT

        !External----------------------------------------------------------------
        integer                                         :: ready_, STAT_CALL

        !Local-------------------------------------------------------------------
        integer                                         :: STAT_

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        !Assures nullification of the global variable
        if (.not. ModuleIsRegistered(mInterfaceSedimentWater_)) then
            nullify (FirstObjInterfaceSedimentWater)
            call RegisterModule (mInterfaceSedimentWater_)
        endif

        call Ready(ObjInterfaceSedimentWaterID, ready_)

cd0 :   if (ready_ .EQ. OFF_ERR_) then

            call AllocateInstance

            Me%ModelName = ModelName

            nullify(Me%FirstProperty    )
            nullify(Me%LastProperty     )
            nullify(Me%FirstBenthicRate )
            nullify(Me%LastBenthicRate  )

            !Associates External Instances
            Me%ObjTime                 = AssociateInstance(mTIME_,           TimeID                     )
            Me%ObjHorizontalGrid       = AssociateInstance(mHORIZONTALGRID_, HorizontalGridID           )
            Me%ObjDischarges           = DischargesID


            !Water column
            Me%ObjWaterGridData        = AssociateInstance(mGRIDDATA_,          WaterGridDataID         )
            Me%ObjWaterHorizontalMap   = AssociateInstance(mHORIZONTALMAP_,     WaterHorizontalMapID    )
            Me%ObjWaterGeometry        = AssociateInstance(mGEOMETRY_,          WaterGeometryID         )
            Me%ObjWaterMap             = AssociateInstance(mMAP_,               WaterMapID              )
            Me%ObjHydrodynamic         = AssociateInstance(mHYDRODYNAMIC_,      HydrodynamicID          )
            Me%ObjWaterProperties      = AssociateInstance(mWATERPROPERTIES_,   WaterPropertiesID       )
            Me%ObjTurbulence           = AssociateInstance(mTURBULENCE_,        TurbulenceID            )

            if(LagrangianID /= 0)then
                Me%ObjLagrangian       = AssociateInstance(mLAGRANGIAN_,        LagrangianID            )
            end if

            if(TurbGOTMID /= 0)then
                Me%ObjTurbGOTM         = AssociateInstance(mTURBGOTM_,          TurbGOTMID              )
            end if

            if(WavesID /= 0)then
                Me%ObjWaves            = AssociateInstance(mWAVES_,             WavesID                 )
            end if

            Me%RunsSediments = RunsSediments

            Me%RunSedimentModule = SedimentModule

            !Sediment column
            if(Me%RunsSediments.or.Me%RunSedimentModule)then
                Me%ObjSedimentGridData     = AssociateInstance(mGRIDDATA_,          SedimentGridDataID      )
                Me%ObjSedimentHorizontalMap= AssociateInstance(mHORIZONTALMAP_,     SedimentHorizontalMapID )
                Me%ObjSedimentGeometry     = AssociateInstance(mGEOMETRY_,          SedimentGeometryID      )
                Me%ObjSedimentMap          = AssociateInstance(mMAP_,               SedimentMapID           )
                if(Me%RunSedimentModule)then
                    Me%ObjSediment             = AssociateInstance(mSEDIMENT_,          SedimentID          )
                    else
                    Me%ObjConsolidation        = AssociateInstance(mCONSOLIDATION_,     ConsolidationID     )
                    Me%ObjSedimentProperties   = AssociateInstance(mSEDIMENTPROPERTIES_,SedimentPropertiesID)
                endif
            end if

            call ReadLockExternalGlobal

            call ReadLockExternalWater

#ifndef _SEDIMENT_
            if(Me%RunsSediments.or.Me%RunSedimentModule) call ReadLockExternalSediment
#endif

            call ConstructGlobalVariables

            call ReadWaterSedimentFilesName

            call ConstructEnterData(Me%ObjEnterData, Me%Files%InPutData, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                 &
                stop 'StartInterfaceSedimentWater - InterfaceSedimentWater - ERR02'

            call ConstructShearStress

            call ConstructRugosity

            call Construct_PropertyList

            call Construct_BenthicRateList

            call ConstructConsolidation

            call Construct_Sub_Modules

            call ConstructSandTransport

            if (Me%RunSedimentModule) call ConstructSedimentTransport

            call ConstructLog

            if(Me%Coupled%OutputHDF%Yes) call OutPut_Results_HDF

            call KillEnterData(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                 &
                stop 'StartInterfaceSedimentWater - InterfaceSedimentWater - ERR03'

#ifndef _SEDIMENT_
            if(Me%RunsSediments.or.Me%RunSedimentModule) call ReadUnlockExternalSediment
#endif

            call ReadUnlockExternalWater

            call ReadUnlockExternalGlobal

            call SetSubModulesConstructor

            !Returns ID
            ObjInterfaceSedimentWaterID = Me%InstanceID

            STAT_ = SUCCESS_

        else cd0

            stop 'ModuleInterfaceSedimentWater - StartInterfaceSedimentWater - ERR99'

        end if cd0


        if (present(STAT)) STAT = STAT_

        !----------------------------------------------------------------------

    end subroutine StartInterfaceSedimentWater

    !--------------------------------------------------------------------------

    subroutine AllocateInstance

        !Local-----------------------------------------------------------------
        type (T_InterfaceSedimentWater), pointer    :: NewObjWaterSedInterface
        type (T_InterfaceSedimentWater), pointer    :: PreviousObjWaterSedInterface


        !Allocates new instance
        allocate (NewObjWaterSedInterface)
        nullify  (NewObjWaterSedInterface%Next)

        !Insert New Instance into list and makes Current point to it
        if (.not. associated(FirstObjInterfaceSedimentWater)) then
            FirstObjInterfaceSedimentWater      => NewObjWaterSedInterface
            Me                                  => NewObjWaterSedInterface
        else
            PreviousObjWaterSedInterface        => FirstObjInterfaceSedimentWater
            Me                                  => FirstObjInterfaceSedimentWater%Next
            do while (associated(Me))
                PreviousObjWaterSedInterface    => Me
                Me                              => Me%Next
            enddo
            Me                                  => NewObjWaterSedInterface
            PreviousObjWaterSedInterface%Next   => NewObjWaterSedInterface
        endif

        Me%InstanceID = RegisterNewInstance (mINTERFACESEDIMENTWATER_)


    end subroutine AllocateInstance


    !--------------------------------------------------------------------------


    subroutine ReadWaterSedimentFilesName

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL
        character(len = StringLength)       :: Message

        !----------------------------------------------------------------------

        Message ='ASCII file used to construct new sediment-water properties.'
        Message = trim(Message)

        call ReadFileName('BOT_DAT', Me%Files%InPutData, Message = Message, STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)stop 'StartInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR01'

        Message   ='Instant fields of bottom properties in HDF format.'
        Message   = trim(Message)

        call ReadFileName('BOT_HDF', Me%Files%Results, Message = Message, TIME_END = Me%EndTime, &
                           Extension = 'bot',                                           &
                           MPI_ID    = GetDDecompMPI_ID(Me%ObjHorizontalGrid),&
                           DD_ON     = GetDDecompON    (Me%ObjHorizontalGrid),&
                           STAT      = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)stop 'StartInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR02'

        ! ---> Bottom properties final values in HDF format
        Message   ='Bottom properties final values in HDF format.'
        Message   = trim(Message)

        call ReadFileName('BOT_FIN', Me%Files%Final, Message = Message, TIME_END = Me%EndTime, &
                           Extension = 'bof',                                           &
                           MPI_ID    = GetDDecompMPI_ID(Me%ObjHorizontalGrid),&
                           DD_ON     = GetDDecompON    (Me%ObjHorizontalGrid),&
                           STAT      = STAT_CALL)

        if(STAT_CALL .ne. SUCCESS_)stop 'StartInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR03'



        ! ---> Bottom properties initial values in HDF format
        Message   ='Bottom properties initial values in HDF format.'
        Message   = trim(Message)

        call ReadFileName('BOT_INI', Me%Files%Initial, Message = Message, TIME_END = Me%ActualTime, &
                           STAT      = STAT_CALL)

cd1 :   if      (STAT_CALL .EQ. FILE_NOT_FOUND_ERR_   ) then

            write(*,*)'Initial file not found.'
            stop 'StartInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR04'

        else if (STAT_CALL .EQ. KEYWORD_NOT_FOUND_ERR_) then cd1

            Message   = 'Keyword BOT_INI not found - StartInterfaceSedimentWater - ModuleInterfaceSedimentWater'
            Message   = trim(Message)

            call SetError(WARNING_, KEYWORD_, Message, Screen = .false.)

        else if (STAT_CALL .EQ. SUCCESS_              ) then cd1

            continue

        else cd1

            stop 'StartInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR06'

        end if cd1

        !----------------------------------------------------------------------

    end subroutine ReadWaterSedimentFilesName

    !--------------------------------------------------------------------------

    subroutine ConstructGlobalVariables

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call GetHorizontalGridSize(Me%ObjHorizontalGrid,                        &
                                   Size        = Me%Size2D,                     &
                                   WorkSize    = Me%WorkSize2D,                 &
                                   STAT        = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructGlobalVariables - ModuleInterfaceSedimentWater - ERR01'

        call GetGeometrySize(Me%ObjWaterGeometry,                               &
                             Size       = Me%WaterSize3D,                       &
                             WorkSize   = Me%WaterWorkSize3D,                   &
                             STAT       = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructGlobalVariables - ModuleInterfaceSedimentWater - ERR02'

        if(Me%RunsSediments.or.Me%RunSedimentModule)then

            call GetGeometrySize(Me%ObjSedimentGeometry,                        &
                                 Size       = Me%SedimentSize3D,                &
                                 WorkSize   = Me%SedimentWorkSize3D,            &
                                 STAT       = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructGlobalVariables - ModuleInterfaceSedimentWater - ERR03'

        end if

        call GetComputeTimeLimits(Me%ObjTime,                                   &
                                  BeginTime = Me%BeginTime,                     &
                                  EndTime   = Me%EndTime,                       &
                                  STAT      = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructGlobalVariables - ModuleInterfaceSedimentWater - ERR04'


        !Actualize the time
        Me%ActualTime = Me%BeginTime

    end subroutine ConstructGlobalVariables


    !--------------------------------------------------------------------------


    subroutine ConstructShearStress

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB, iflag

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        Me%Shear_Stress%LastCompute = Me%BeginTime

        nullify(Me%Shear_Stress%Tension)

        !Shear stress - intensity
        allocate(Me%Shear_Stress%Tension(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR10'
        endif
        Me%Shear_Stress%Tension(:,:) = 0.

        nullify(Me%Shear_Stress%Tension_X)

        !Shear stress - X component
        allocate(Me%Shear_Stress%Tension_X(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR20'
        endif

        Me%Shear_Stress%Tension_X(:,:) = 0.

        nullify(Me%Shear_Stress%Tension_Y)

        !Shear stress - Y component
        allocate(Me%Shear_Stress%Tension_Y(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR30'
        endif
        Me%Shear_Stress%Tension_Y(:,:) = 0.


        nullify(Me%Shear_Stress%Velocity)

        !Shear velocity
        allocate(Me%Shear_Stress%Velocity(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR40'
        Me%Shear_Stress%Velocity(:,:) = 0.


        call GetData(Me%Shear_Stress%OutputON,                                      &
                     Me%ObjEnterData, iflag,                                        &
                     SearchType   = FromFile,                                       &
                     Keyword      = 'OUTPUT_SHEAR_STRESS',                          &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     Default      = .false.,                                        &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR50'

        if (Me%Shear_Stress%OutputON) then

            Me%Coupled%OutputHDF%Yes = ON

            if (Me%ExtWater%ResidualON) then
                call ConstructShearStressResidual
            endif

        end if

        call ConstructShearLimitation

        call ConstructShearStatistics

        call ConstructWaveShearStress

        call GetData(Me%Shear_Stress%IntertidalRunOff,                              &
                     Me%ObjEnterData, iflag,                                        &
                     SearchType   = FromFile,                                       &
                     Keyword      = 'INTERTIDAL_RUN_OFF_SHEAR',                     &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     Default      = .false.,                                        &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR40'

       call GetData(Me%Shear_Stress%Method,                                         &
                     Me%ObjEnterData, iflag,                                        &
                     SearchType   = FromFile,                                       &
                     Keyword      = 'SHEAR_STRESS_METHOD',                          &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     Default      = 1,                                              &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructShearStress - ModuleInterfaceSedimentWater - ERR41'


    end subroutine ConstructShearStress

    !--------------------------------------------------------------------------

    subroutine ConstructShearStressResidual

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: HDF5_READ, ObjHDF5
        logical                             :: FileExist, CheckResidual

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        call GetResidualVelocityPeriod(HydrodynamicID = Me%ObjHydrodynamic,             &
                                        ResidualPeriod = Me%Shear_Stress%Residual_Period,&
                                        STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR10'

        !Shear stress - intensity
        nullify(Me%Shear_Stress%Residual_Tau)

        allocate(Me%Shear_Stress%Residual_Tau(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR20'
        endif
        Me%Shear_Stress%Residual_Tau(:,:) = 0.

        !Shear stress - component X
        nullify(Me%Shear_Stress%Residual_Tau_X)

        allocate(Me%Shear_Stress%Residual_Tau_X(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR30'
        endif
        Me%Shear_Stress%Residual_Tau_X(:,:) = 0.

        !Shear stress - component Y
        nullify(Me%Shear_Stress%Residual_Tau_Y)

        allocate(Me%Shear_Stress%Residual_Tau_Y(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR40'
        endif
        Me%Shear_Stress%Residual_Tau_Y(:,:) = 0.

        FileExist     = .false.
        CheckResidual = .false.

        if (Me%Shear_Stress%Residual_Period > 0) then

            inquire(File = trim(Me%Files%Initial), Exist = FileExist)
            
            if (FileExist) then
                
                !Gets File Access Code
                call GetHDF5FileAccess  (HDF5_READ = HDF5_READ)

                !Opens HDF5 File
                call ConstructHDF5 (ObjHDF5, trim(Me%Files%Initial), HDF5_READ, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR50'
                
                call GetHDF5GroupExist (ObjHDF5, "Residual", CheckResidual, STAT = STAT_CALL)                
                if (STAT_CALL /= SUCCESS_) stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR60'                
                
                call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'ConstructShearStressResidual - ModuleInterfaceSedimentWater - ERR70'
                
                if (CheckResidual) then
            
                    call Read_Old_Properties_2D(Me%Shear_Stress%Residual_Tau_X, "Residual",     &
                                                GetPropertyName(ShearStressX_))
                    call Read_Old_Properties_2D(Me%Shear_Stress%Residual_Tau_Y, "Residual",     &
                                                GetPropertyName(ShearStressY_))            
                endif
            endif
        endif

        if (Me%Shear_Stress%Residual_Period <= 0 .or. .not. FileExist .or. .not. CheckResidual) then
            write(*,*) "Residual bottom shear stress has a cold start in this run"
            Me%Shear_Stress%Residual_Period = 0.
        endif



    end subroutine ConstructShearStressResidual

    !--------------------------------------------------------------------------

    subroutine ConstructWaveShearStress

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL, iflag

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        call GetData(Me%WaveShear_Stress%Yes,                                       &
                     Me%ObjEnterData, iflag,                                        &
                     SearchType   = FromFile,                                       &
                     Keyword      = 'WAVETENSION',                                  &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     Default      = .false.,                                        &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructWaveShearStress - ModuleInterfaceSedimentWater - ERR01'

        !call GetWavesStressON (Me%ObjHydrodynamic,                                  &
        !                       WavesStressON = Me%WaveShear_Stress%NonLinear, STAT = STAT_CALL)
        !if  (STAT_CALL .ne. SUCCESS_)&
        !    stop 'ConstructWaveShearStress - ModuleInterfaceSedimentWater - ERR02'

        if(Me%WaveShear_Stress%Yes)then
            if(Me%ObjWaves == 0)then
                write(*,*)
                write(*,*)'Must activate Module Waves in order to'
                write(*,*)'compute wave shear stress'
                stop 'ConstructWaveShearStress - ModuleInterfaceSedimentWater - ERR03'
            end if
            !Shear stress
            allocate(Me%WaveShear_Stress%Tension   (ILB:IUB, JLB:JUB))
            Me%WaveShear_Stress%Tension   (:,:) = FillValueReal

            allocate(Me%WaveShear_Stress%ChezyVel  (ILB:IUB, JLB:JUB))
            Me%WaveShear_Stress%ChezyVel  (:,:) = FillValueReal

            allocate(Me%WaveShear_Stress%Cphi(ILB:IUB, JLB:JUB))
            Me%WaveShear_Stress%Cphi(:,:) = 0.

            allocate(Me%WaveShear_Stress%CWphi(ILB:IUB, JLB:JUB))
            Me%WaveShear_Stress%CWphi(:,:) = 0.

            allocate(Me%WaveShear_Stress%TensionMean(ILB:IUB, JLB:JUB))
            Me%WaveShear_Stress%TensionMean(:,:) = 0.

        end if


    end subroutine ConstructWaveShearStress

    !--------------------------------------------------------------------------

    subroutine ReadSOD

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------

        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: ClientNumber
        logical                             :: BlockFound

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,          &
                                    SOD_begin, SOD_end, BlockFound,         &
                                    STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) stop 'ReadSOD - ModuleInterfaceSedimentWater - ERR01'

        if(BlockFound)then

            Me%UseSOD = ON

            nullify(Me%SOD%Field)
            allocate(Me%SOD%Field(ILB:IUB, JLB:JUB))

            call ConstructFillMatrix  (PropertyID           = Me%SOD%ID,                        &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill2D       = Me%ExtWater%WaterPoints2D,        &
                                       Matrix2D             = Me%SOD%Field,                     &
                                       TypeZUV              = TypeZ_,                           &
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ReadSOD - ModuleInterfaceSedimentWater - ERR02'


            call GetDefaultValue(Me%SOD%ID%ObjFillMatrix, Me%SOD%Scalar, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ReadSOD - ModuleInterfaceSedimentWater - ERR03'

            call KillFillMatrix(Me%SOD%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ReadSOD - ModuleInterfaceSedimentWater - ERR04'

            call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ReadSOD - ModuleInterfaceSedimentWater - ERR05'

        endif

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) stop 'ReadSOD - ModuleInterfaceSedimentWater - ERR06'


    end subroutine ReadSOD

    !--------------------------------------------------------------------------

    subroutine ConstructSandTransport

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL, iflag

        !Local-----------------------------------------------------------------

        integer                             :: ILB, IUB, JLB, JUB

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        call GetData(Me%RunsSandTransport,                                               &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromFile,                                            &
                     Keyword      = 'SAND_TRANSPORT',                                    &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     Default      = .false.,                                             &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)                                                      &
            stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR10.'

        if (Me%RunsSandTransport) then

            if (.not. associated(Me%Rugosity%Field))then

                write(*,*) 'When SAND TRANSPORT is ON is necessary to defined the RUGOSITY'
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR20.'

            endif

            call StartSand(ObjSandID            = Me%ObjSand,                            &
                           ObjGridDataID        = Me%ObjWaterGridData,                   &
                           ObjHorizontalGridID  = Me%ObjHorizontalGrid,                  &
                           ObjHorizontalMapID   = Me%ObjWaterHorizontalMap,              &
                           ObjTimeID            = Me%ObjTime,                            &
                           ObjWavesID           = Me%ObjWaves,                           &
                           ObjDischargesID      = Me%ObjDischarges,                      &
                           WaterDensity         = SigmaDensityReference,          &
                           WaveTensionON        = Me%WaveShear_Stress%Yes,               &
                           STAT                 = STAT_CALL)

            if(STAT_CALL /= SUCCESS_)                                                    &
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR30.'



            if(Me%WaveShear_Stress%Yes)then
                allocate(Me%WaveShear_Stress%TensionCurrents(ILB:IUB, JLB:JUB))
                Me%WaveShear_Stress%TensionCurrents(:,:) = FillValueReal
            endif

            !Current velocity
            allocate(Me%Shear_Stress%CurrentVel(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR40'
            Me%Shear_Stress%CurrentVel(:,:) = FillValueReal

            allocate(Me%Shear_Stress%CurrentU(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR50'
            Me%Shear_Stress%CurrentU(:,:) = FillValueReal

            allocate(Me%Shear_Stress%CurrentV(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR60'
            Me%Shear_Stress%CurrentV(:,:) = FillValueReal

            allocate(Me%Shear_Stress%UFace(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR70'
            Me%Shear_Stress%UFace(:,:) = FillValueReal

            allocate(Me%Shear_Stress%VFace(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR80'
            Me%Shear_Stress%VFace(:,:) = FillValueReal

            allocate(Me%Shear_Stress%CurrentResidualU(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR90'
            Me%Shear_Stress%CurrentResidualU(:,:) = FillValueReal

            allocate(Me%Shear_Stress%CurrentResidualV(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSandTransport - ModuleInterfaceSedimentWater - ERR100'
            Me%Shear_Stress%CurrentResidualV(:,:) = FillValueReal


        endif

    end subroutine ConstructSandTransport

     !--------------------------------------------------------------------------

    subroutine ConstructSedimentTransport

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------

        integer                             :: ILB, IUB, JLB, JUB
        !real                                :: ReferenceLevel

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        call SetWaveTensionON(ObjSedimentID = Me%ObjSediment,            &
                              WaveTensionON = Me%WaveShear_Stress%Yes,   &
                              STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_)                                      &
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR10'

        !Current velocity
        allocate(Me%Shear_Stress%CurrentVel(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR40'
        Me%Shear_Stress%CurrentVel(:,:) = FillValueReal

        allocate(Me%Shear_Stress%CurrentU(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR50'
        Me%Shear_Stress%CurrentU(:,:) = FillValueReal

        allocate(Me%Shear_Stress%CurrentV(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR60'
        Me%Shear_Stress%CurrentV(:,:) = FillValueReal

        allocate(Me%Shear_Stress%UFace(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR70'
        Me%Shear_Stress%UFace(:,:) = FillValueReal

        allocate(Me%Shear_Stress%VFace(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR80'
        Me%Shear_Stress%VFace(:,:) = FillValueReal

        allocate(Me%Shear_Stress%EfficiencyFactorCurrent(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR90'
         Me%Shear_Stress%EfficiencyFactorCurrent(:,:) = FillValueReal

        if(Me%WaveShear_Stress%Yes)then
            allocate(Me%Shear_Stress%EfficiencyFactorMean(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR100'
            Me%Shear_Stress%EfficiencyFactorMean(:,:) = FillValueReal

            allocate(Me%Shear_Stress%EfficiencyFactorWaves(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructSedimentTransport - ModuleInterfaceSedimentWater - ERR110'
            Me%Shear_Stress%EfficiencyFactorWaves(:,:) = FillValueReal
        endif

    end subroutine ConstructSedimentTransport


    !--------------------------------------------------------------------------

    subroutine ConstructConsolidation

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL, iflag
        integer                             :: ILB, IUB, JLB, JUB

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        call GetData(Me%Consolidation%Yes,                                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromFile,                                           &
                     Keyword      = 'CONSOLIDATION',                                    &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructConsolidation - ModuleInterfaceSedimentWater - ERR10'


        if(Me%Consolidation%Yes)then

            allocate(Me%Consolidation%Flux(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructConsolidation - ModuleInterfaceSedimentWater - ERR20'

            Me%Consolidation%Flux(:,:) = 0.

            if(Me%RunSedimentModule) then

                !Dewatering rate (kg/m2/s)
                call GetData(Me%Dewatering_Rate,                                            &
                             Me%ObjEnterData, iflag,                                        &
                             SearchType   = FromFile,                                       &
                             Keyword      = 'DEWATERING_RATE',                              &
                             ClientModule = 'ModuleInterfaceSedimentWater',                 &
                             Default      = 10E-3,                                          &
                             STAT         = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                    stop 'ConstructConsolidation - ModuleInterfaceSedimentWater - ERR30'

            elseif(Me%RunsSediments)then

                !Me%Coupled%SedimentFluxes%Yes      = ON  !review this
                !Me%Coupled%SedimentWaterFluxes%Yes = ON  !review this

                call Read_Property_2D (Me%Consolidation%Rate, FromBlock, &
                                       consolidation_begin, consolidation_end)

                call GetConsolidationMinThickness(Me%ObjConsolidation, Me%ExtSed%MinLayerThickness, &
                                                      STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                        stop 'ConstructConsolidation - ModuleInterfaceSedimentWater - ERR40'
            endif

        end if

    end subroutine ConstructConsolidation

    !--------------------------------------------------------------------------


    subroutine ConstructShearLimitation

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL, iflag

        !Begin-----------------------------------------------------------------

        !Keyword so shear stress is limited in low depth waters
        call GetData(Me%Shear_Stress%Limitation,                                        &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromFile,                                           &
                     Keyword      = 'SHEAR_STRESS_LIMITATION',                          &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     Default      = .false.,                                            &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructShearLimitation - ModuleInterfaceSedimentWater - ERR01'

        if(Me%Shear_Stress%Limitation)then

            !Reference depth to compute shear stress limitation [m]
            call GetData(Me%Shear_Stress%ReferenceDepth,                                &
                         Me%ObjEnterData, iflag,                                        &
                         SearchType   = FromFile,                                       &
                         Keyword      = 'REFERENCE_DEPTH',                              &
                         ClientModule = 'ModuleInterfaceSedimentWater',                 &
                         Default      = 0.2,                                            &
                         STAT         = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructShearLimitation - ModuleInterfaceSedimentWater - ERR02'

            !Reference shear stress in low low depth waters [N/m2]
            call GetData(Me%Shear_Stress%ReferenceShearStress,                          &
                         Me%ObjEnterData, iflag,                                        &
                         SearchType   = FromFile,                                       &
                         Keyword      = 'REFERENCE_SHEAR_STRESS',                       &
                         ClientModule = 'ModuleInterfaceSedimentWater',                 &
                         Default      = 0.25,                                           &
                         STAT         = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'ConstructShearLimitation - ModuleInterfaceSedimentWater - ERR03'

        end if

    end subroutine ConstructShearLimitation

    !--------------------------------------------------------------------------

    subroutine ConstructShearStatistics

        !Local ------------------------------------------------------------------------------
        integer                                         :: STAT_CALL
        integer                                         :: iflag

        !Begin----------------------------------------------------------------------------

        !Checks out if the user pretends the statistics of bottom shear velocity
        call GetData(Me%Shear_Stress%Statistics%ON,                                     &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'STATISTICS_SHEAR',                               &
                     Default        = .false.,                                          &
                     SearchType     = FromFile,                                         &
                     ClientModule   = 'ModuleInterfaceSedimentWater',                   &
                     STAT           = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructShearStatistics - ModuleInterfaceSedimentWater - ERR01'


        if (Me%Shear_Stress%Statistics%ON) then

            call GetData(Me%Shear_Stress%Statistics%File,                               &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'STATISTICS_SHEAR_FILE',                      &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleInterfaceSedimentWater',               &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_ .or. iflag /= 1)                                  &
                stop 'ConstructShearStatistics - ModuleInterfaceSedimentWater - ERR02'


            call ConstructStatistic (StatisticID      = Me%Shear_Stress%Statistics%ID,  &
                                     ObjTime          = Me%ObjTime,                     &
                                     ObjHDF5          = Me%ObjHDF5,                     &
                                     DataFile         = Me%Shear_Stress%Statistics%File,&
                                     Size             = Me%WaterSize3D,                 &
                                     WorkSize         = Me%WaterWorkSize3D,             &
                                     Name             = GetPropertyName (ShearVelocity_),&
                                     STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ConstructShearStatistics - ModuleInterfaceSedimentWater - ERR04'

        endif


    end subroutine ConstructShearStatistics


    !--------------------------------------------------------------------------

    subroutine ConstructRugosity

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: WILB, WIUB, WJLB, WJUB
        integer                             :: ClientNumber, iflag
        logical                             :: BlockFound

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        WILB = Me%WorkSize2D%ILB
        WIUB = Me%WorkSize2D%IUB
        WJLB = Me%WorkSize2D%JLB
        WJUB = Me%WorkSize2D%JUB

        Me%Manning = OFF
        Me%Chezy   = OFF

        call GetData(Me%ComputeRugosity,                                            &
                     Me%ObjEnterData, iflag,                                        &
                     SearchType   = FromFile,                                       &
                     Keyword      = 'COMPUTE_RUGOSITY',                             &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     Default      = .false.,                                        &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR00a'

        if(Me%ComputeRugosity .and. .not. Me%RunSedimentModule) then
            write(*,*) 'To compute the rugosity the module Sediment must be activated'
            stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR00b'
        endif

        call GetData(Me%RugosityDecayTime,                                          &
                     Me%ObjEnterData, iflag,                                        &
                     SearchType   = FromFile,                                       &
                     Keyword      = 'RUGOSITY_DECAY_TIME',                          &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     Default      = 100.,                                           &
                     STAT         = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR00c'


        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                  &
                                    manning_begin, manning_end, BlockFound,         &
                                    STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR01'

        if(BlockFound)then


            if(Me%WaterWorkSize3D%KUB > 1)then

                write(*,*)'Cannot use Manning coefficient in 3D.'
                stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR02'
            end if

            Me%Manning = ON

            nullify(Me%ManningCoef%Field)
            allocate(Me%ManningCoef%Field(ILB:IUB, JLB:JUB))

            call ConstructFillMatrix  (PropertyID           = Me%ManningCoef%ID,                &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       ExtractType          = FromBlock,                        &
                                       PointsToFill2D       = Me%ExtWater%WaterPoints2D,        &
                                       Matrix2D             = Me%ManningCoef%Field,             &
                                       TypeZUV              = TypeZ_,                           &
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR03'


            call GetDefaultValue(Me%ManningCoef%ID%ObjFillMatrix, Me%ManningCoef%Scalar, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR04'

            call KillFillMatrix(Me%ManningCoef%ID%ObjFillMatrix, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR05'

            call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR07'

        endif

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR06'

        call ExtractBlockFromBuffer(Me%ObjEnterData, ClientNumber,                          &
                                    rugosity_begin, rugosity_end, BlockFound,               &
                                    STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR08'

        if(BlockFound)then

            nullify(Me%Rugosity%Field)
            allocate(Me%Rugosity%Field(ILB:IUB, JLB:JUB))
            Me%Rugosity%Field(:,:) = FillValueReal


            call GetData(Me%Rugosity%Old,                                       &
                         Me%ObjEnterData, iflag,                                &
                         keyword      ='OLD',                                   &
                         SearchType   = FromBlock,                              &
                         ClientModule = 'ModuleInterfaceSedimentWater',         &
                         Default      = .false.,                                &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                        &
                stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR090'

            if(Me%Rugosity%Old)then

                call Read_Old_Properties_2D(Me%Rugosity%Field, "Rugosity", "Rugosity")

            else

                call ConstructFillMatrix  (PropertyID           = Me%Rugosity%ID,                   &
                                           EnterDataID          = Me%ObjEnterData,                  &
                                           TimeID               = Me%ObjTime,                       &
                                           HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                           ExtractType          = FromBlock,                        &
                                           PointsToFill2D       = Me%ExtWater%WaterPoints2D,        &
                                           Matrix2D             = Me%Rugosity%Field,                &
                                           TypeZUV              = TypeZ_,                           &
                                           ClientID             = ClientNumber,                     &
                                           STAT                 = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR09'


                call GetDefaultValue(Me%Rugosity%ID%ObjFillMatrix, Me%Rugosity%Scalar, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR10'

                call KillFillMatrix(Me%Rugosity%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR11'

            endif

            call RewindBuffer(Me%ObjEnterData, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR13'

        else if (.not. BlockFound .and. .not. Me%Manning) then

            call GetData(Me%ChezyCoef,                                                  &
                         Me%ObjEnterData, iflag,                                        &
                         Keyword        = 'CHEZY_COEFFICIENT',                          &
                         SearchType     = FromFile,                                     &
                         ClientModule   = 'ModuleInterfaceSedimentWater',               &
                         STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ConstructShearStatistics - ModuleInterfaceSedimentWater - ERR200'
            if (iflag == 1) then

                Me%Chezy = ON

            else
                write(*,*)'Must define rugosity in ModuleInterfaceSedimentWater'
                stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR14'
            endif

        end if

        call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_) stop 'ConstructRugosity - ModuleInterfaceSedimentWater - ERR12'


        if (BlockFound .and. Me%Manning) then

            write(*,*)'Both absolute rugosity and Manning coefficient were defined'
            write(*,*)'by default the hydrodynamic module use the Manning coefficient'
            write(*,*)'ConstructRugosity - ModuleInterfaceSedimentWater - WARN01'

        endif

        if (Me%WaveShear_Stress%Yes .and. Me%Shear_Stress%Method==1) then

            call Read_Property_2D(Me%WaveShear_Stress%Rugosity, FromBlock, &
                                  waverugosity_begin, waverugosity_end)

        endif

    end subroutine ConstructRugosity


    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------


    subroutine Construct_PropertyList

        !External----------------------------------------------------------------
        integer                                 :: ClientNumber
        integer                                 :: STAT_CALL
        logical                                 :: BlockFound

        !Local-------------------------------------------------------------------
        type (T_Property), pointer              :: NewProperty

        !------------------------------------------------------------------------

        !Initialize the properties number
        Me%PropertiesNumber = 0


do1 :   do
            call ExtractBlockFromBuffer(Me%ObjEnterData,                        &
                                        ClientNumber    = ClientNumber,         &
                                        block_begin     = prop_block_begin,     &
                                        block_end       = prop_block_end,       &
                                        BlockFound      = BlockFound,           &
                                        STAT            = STAT_CALL)
cd1 :       if      (STAT_CALL .EQ. SUCCESS_     ) then
cd2 :           if (BlockFound) then
                    ! Construct a New Property
                    Call Construct_Property(NewProperty, ClientNumber)

                    ! Add new Property to the WaterProperties List
                    Call Add_Property(NewProperty)
                else cd2
                    call Block_Unlock(Me%ObjEnterData , ClientNumber, STAT = STAT_CALL)

                    if (STAT_CALL .NE. SUCCESS_)                                &
                        stop 'Construct_PropertyList - ModuleInterfaceSedimentWater - ERR01'

                    exit do1    !No more blocks
                end if cd2

            else if (STAT_CALL .EQ. BLOCK_END_ERR_) then cd1
                write(*,*)
                write(*,*) 'Error calling ExtractBlockFromBuffer. '
                stop 'Construct_PropertyList - ModuleInterfaceSedimentWater - ERR02'
            else cd1
                stop 'Construct_PropertyList - ModuleInterfaceSedimentWater - ERR03'
            end if cd1
        end do do1

        !------------------------------------------------------------------------

    end subroutine Construct_PropertyList

    !----------------------------------------------------------------------------


    subroutine Construct_Property(NewProperty, ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property), pointer       :: NewProperty
        integer                         :: ClientNumber

        !External--------------------------------------------------------------
        integer                         :: STAT_CALL

        !----------------------------------------------------------------------

        allocate (NewProperty, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) &
            stop 'Construct_Property - ModuleInterfaceSedimentWater - ERR01'

        nullify(NewProperty%Mass_Available       )
        nullify(NewProperty%FluxToWater          )
        nullify(NewProperty%FluxToSediment       )
        nullify(NewProperty%ErosionCoefficient   )
        nullify(NewProperty%Prev,NewProperty%Next)
        nullify(NewProperty%Mass_Available       )

        !Construct property ID
        call ConstructPropertyID        (NewProperty%ID, Me%ObjEnterData, FromBlock)

        !Construct property evolution parameters
        call Construct_PropertyEvolution(NewProperty, ClientNumber)

        if (NewProperty%Evolution%Variable) Me%OutPut%WriteFinalFile = .true.

        !Construct property values
        call Construct_PropertyValues   (NewProperty)


        !Defines the property output
        call Construct_PropertyOutPut   (NewProperty)


    end subroutine Construct_Property

    !--------------------------------------------------------------------------

    subroutine Construct_PropertyValues(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_property),        pointer    :: NewProperty

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: iflag, i, j
        integer                             :: ILB, IUB, JLB, JUB
        integer                             :: WILB, WIUB, WJLB, WJUB
        real, dimension(:,:),     pointer   :: Biomass

        !----------------------------------------------------------------------

        ILB = Me%Size2D%ILB;  IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB;  JUB = Me%Size2D%JUB

        WILB = Me%WorkSize2D%ILB;  WJLB = Me%WorkSize2D%JLB
        WIUB = Me%WorkSize2D%IUB;  WJUB = Me%WorkSize2D%JUB

        !By default there's always mass limitation for every property
        call GetData(NewProperty%Mass_Limitation,                               &
                     Me%ObjEnterData, iflag,                                    &
                     keyword      ='MASS_LIMITATION',                           &
                     SearchType   = FromBlock,                                  &
                     ClientModule = 'ModuleInterfaceSedimentWater',             &
                     Default      = .true.,                                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR01'

        !By default the minimum mass available is 1e-6 kg/m^2
        if (NewProperty%Mass_Limitation) then

            call GetData(NewProperty%Mass_Min,                                  &
                         Me%ObjEnterData, iflag,                                &
                         keyword      ='MASS_MIN',                              &
                         SearchType   = FromBlock,                              &
                         ClientModule = 'ModuleInterfaceSedimentWater',         &
                         Default      = 1e-6,                                   &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR02'

            call GetData(NewProperty%Old,                                       &
                         Me%ObjEnterData, iflag,                                &
                         keyword      ='OLD',                                   &
                         SearchType   = FromBlock,                              &
                         ClientModule = 'ModuleInterfaceSedimentWater',         &
                         Default      = .false.,                                &
                         STAT         = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR03'

            allocate(NewProperty%Mass_Available(ILB:IUB, JLB:JUB))
            NewProperty%Mass_Available  = null_real
            allocate(NewProperty%MassInKg      (ILB:IUB, JLB:JUB))
            NewProperty%MassInKg        = null_real
            allocate(NewProperty%Mass_FromWater(ILB:IUB, JLB:JUB))
            NewProperty%Mass_FromWater        = null_real

            if(NewProperty%Old)then

                call Read_Old_Properties_2D(NewProperty%Mass_Available, "Mass", NewProperty%ID%Name)

                  ! In the module interfacesediment water properties are initialized
                    if(  (NewProperty%ID%IDNumber == SeagrassesLeaves_ )  .or.  &
                       (NewProperty%ID%IDNumber == SeagrassesRoots_    )  .or.  &
                       (NewProperty%ID%IDNumber == SeagrassesP_        )  .or.  &
                       (NewProperty%ID%IDNumber == SeagrassesN_        )         )   then

                        do i=ILB,IUB
                        do j=JLB,JUB
                            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                            ! kg =                   Kg/m2  * m2
                            NewProperty%MassInKg(i,j)=NewProperty%Mass_Available(i,j)* Me%ExternalVar%GridCellArea(i,j)
                            endif
                        enddo
                        enddo
                   endif

            else

                call ConstructFillMatrix  (PropertyID           = NewProperty%ID,                   &
                                           EnterDataID          = Me%ObjEnterData,                  &
                                           TimeID               = Me%ObjTime,                       &
                                           HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                           ExtractType          = FromBlock,                        &
                                           PointsToFill2D       = Me%ExtWater%WaterPoints2D,        &
                                           Matrix2D             = NewProperty%Mass_Available,       &
                                           TypeZUV              = TypeZ_,                           &
                                           STAT                 = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR04'

                call KillFillMatrix(NewProperty%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL  /= SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR05'

            if (NewProperty%ID%IDNumber== SeagrassesLeaves_) then

                call GetSeagrassArray2D(Me%ObjWaterProperties, Biomass, ArrayID= SeagrassesLeaves_, STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

                    ! get the value in kg (this is necessary to initialize the leaves when running modulebenthicEcology)
                    do i=ILB,IUB
                    do j=JLB,JUB
                        if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                        ! gets the mass  in gDW/m2 and convert to kg DW/m2
                        NewProperty%Mass_Available(i,j)=Biomass(i,j)/1000.  ! convert to kg DW/m2


                        ! kg DW=                   kg DW/m2  * m2
                        NewProperty%MassInKg(i,j)=NewProperty%Mass_Available(i,j)* Me%ExternalVar%GridCellArea(i,j)
                        endif
                    enddo
                    enddo

                call UnGetWaterProperties(Me%ObjWaterProperties, Biomass, STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'
              endif


              if (NewProperty%ID%IDNumber== SeagrassesRoots_) then

                call GetRootsArray2D(Me%ObjSedimentProperties, Biomass,ArrayID=SeagrassesRoots_, STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR11'

                  ! gets the mass from the water column in g DW/m2

                   NewProperty%Mass_Available=Biomass/1000.  ! convert to kg DW/m2

                   ! get the value in kg DW(this is necessary to initialize the roots when running modulebenthicEcology)
                    do i=ILB,IUB
                    do j=JLB,JUB
                        if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then  ! not sure what to put here
                        !if(Me%ExtSed%OpenPoints2D(i,j) == OpenPoint)
                            ! i put the waterpoints to say that i have roots where i have leaves

                            ! kg DW =                   Kg DW/m2  * m2
                            NewProperty%MassInKg(i,j)=NewProperty%Mass_Available(i,j)* Me%ExternalVar%GridCellArea(i,j)
                        endif
                    enddo
                    enddo

                    call UnGetSedimentProperties(Me%ObjSedimentProperties, Biomass, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR15'

              endif

                !Test to verify mass matrix consistence
                do j = WJLB, WJUB
                do i = WILB, WIUB
                    if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then
                        if(NewProperty%Mass_Available(i,j) < NewProperty%Mass_Min)then

                            NewProperty%Mass_Available(i,j) = NewProperty%Mass_Min

                        end if
                    end if
                enddo
                enddo

            end if

        end if

        if((.not. NewProperty%ID%IsParticulate) .or. NewProperty%Evolution%WaterFluxes)then

            allocate(NewProperty%WaterConcentration(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR07'
            NewProperty%WaterConcentration(:,:) = null_real

        end if


       if(NewProperty%Evolution%BenthicOnly)then

            allocate(NewProperty%WaterConcentration(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR07.1'
            NewProperty%WaterConcentration(:,:) = 0.

        end if


        if(NewProperty%Evolution%WaterFluxes .or. NewProperty%Evolution%SedimentWaterFluxes)then

            allocate(NewProperty%FluxToWater(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR06'
            NewProperty%FluxToWater(:,:) = 0.

            if(NewProperty%Evolution%Erosion)then

                allocate(NewProperty%ErosionCoefficient(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR08'
                NewProperty%ErosionCoefficient(:,:) = null_real

                allocate(NewProperty%ErosionFlux(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'
                NewProperty%ErosionFlux(:,:) = null_real

            end if

            if(NewProperty%Evolution%Deposition)then
                allocate(NewProperty%DepositionFlux(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'
                NewProperty%DepositionFlux(:,:) = null_real
            end if

        end if

        if(NewProperty%Evolution%SedimentFluxes .or. NewProperty%Evolution%SedimentWaterFluxes)then

            allocate(NewProperty%FluxToSediment(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR11'
            NewProperty%FluxToSediment(:,:) = 0.

            allocate(NewProperty%SedimentConcentration(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR12'
            NewProperty%FluxToSediment(:,:) = null_real

        end if

    end subroutine Construct_PropertyValues


    !--------------------------------------------------------------------------


    subroutine Construct_PropertyEvolution(NewProperty, ClientNumber)

        !Arguments-------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty
        integer                                 :: ClientNumber

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL
        real                                    :: ModelDT

        !Local-----------------------------------------------------------------
        integer                                 :: iflag
        real                                    :: ErrorAux, auxFactor, DTaux
        logical                                 :: VariableDT

        !----------------------------------------------------------------------

!~         !Checks if the user wants this property to be particulate.
!~         !This property will be used to define particulated properties
!~         call GetData(NewProperty%Particulate,                                            &
!~                      Me%ObjEnterData,iflag,                                              &
!~                      SearchType   = FromBlock,                                           &
!~                      keyword      = 'PARTICULATE',                                       &
!~                      Default      = .false.,                                             &
!~                      ClientModule = 'ModuleInterfaceSedimentWater',                      &
!~                      STAT         = STAT_CALL)
!~         if (STAT_CALL .NE. SUCCESS_)&
!~             stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR00'

!~         if (NewProperty%Particulate)then
!~             !if(.not. Check_Particulate_Property(NewProperty%ID%IDNumber)) then
!~             if (.not. NewProperty%ID%IsParticulate) then
!~                 write(*,*) 'Property '//trim(NewProperty%ID%Name)// ' is not'
!~                 write(*,*) 'recognised as PARTICULATE'
!~                 stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR10'
!~             end if
!~         endif

        call GetData(NewProperty%Evolution%Benthos,                                     &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'BENTHOS',                                          &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR20'

        if(NewProperty%evolution%Benthos) NewProperty%Evolution%Variable = .true.


        call GetData(NewProperty%Evolution%BenthicEcology,                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'BENTHICECOLOGY',                                   &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR25'

         if(NewProperty%evolution%BenthicEcology) NewProperty%Evolution%Variable = .true.


        call GetData(NewProperty%Evolution%BenthicOnly,                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'BENTHICONLY',                                   &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR25'

        !CEQUALW2 as a sink and source
        call GetData(NewProperty%Evolution%CEQUALW2,                                    &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'CEQUALW2',                                         &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR30'

        if(NewProperty%Evolution%CEQUALW2) NewProperty%Evolution%Variable = .true.

        ! This property is a DETRITUS component
        call GetData(NewProperty%Evolution%Detritus,                                    &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'DETRITUS',                                         &
                     Default      = OFF,                                                &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR40'

        if(NewProperty%Evolution%Detritus) NewProperty%Evolution%Variable = .true.


        !Fluxes between water and sediment column
        call GetData(NewProperty%Evolution%SedimentWaterFluxes,                          &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'SEDIMENT_WATER_FLUXES',                             &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR60'

        if (NewProperty%Evolution%SedimentWaterFluxes)then

            NewProperty%Evolution%Variable = .true.

            if(.not. NewProperty%ID%IsParticulate)then

                call Read_Property_2D(NewProperty%MolecularDifCoef, FromBlockInBlock,          &
                                      diff_coef_begin, diff_coef_end, ClientNumber = ClientNumber)

            end if

        end if


        !Fluxes between water and interface sediment-water
        call GetData(NewProperty%Evolution%WaterFluxes,                                  &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'WATER_FLUXES',                                      &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR80'

        if (NewProperty%Evolution%WaterFluxes)then
            NewProperty%Evolution%Variable = .true.
        end if


        !Compute erosion fluxes  no - 0;  yes - 1
        call GetData(NewProperty%Evolution%Erosion,                                      &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'EROSION',                                           &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR90'

        if (NewProperty%Evolution%Erosion)then
            if(.not. NewProperty%ID%IsParticulate)then
                write(*,*)
                write(*,*)'Cannot specify EROSION for a dissolved property.'
                write(*,*)'Property: '//trim(NewProperty%ID%Name)
                write(*,*)
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR100'
            end if
            if(.not. NewProperty%Evolution%WaterFluxes)then
                write(*,*)
                write(*,*)'Must specify WATER_FLUXES to property '//trim(NewProperty%ID%Name)
                write(*,*)'in order to compute its EROSION'
                write(*,*)
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR110'
            end if

            NewProperty%Evolution%Variable = .true.

        end if


        !Compute deposition fluxes  no - 0;  yes - 1
        call GetData(NewProperty%Evolution%Deposition,                                   &
                     Me%ObjEnterData, iflag,                                             &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'DEPOSITION',                                        &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                     &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR120'

        if (NewProperty%Evolution%Deposition)then
            if(.not. NewProperty%ID%IsParticulate)then
                write(*,*)'Cannot specify DEPOSITION for a dissolved property.'
                write(*,*)'Property: '//trim(NewProperty%ID%Name)
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR130'
            end if
            if(.not. NewProperty%Evolution%WaterFluxes)then
                write(*,*)
                write(*,*)'Must specify WATER_FLUXES to property '//trim(NewProperty%ID%Name)
                write(*,*)'in order to compute its DEPOSITION'
                write(*,*)
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR140'
            end if

            NewProperty%Evolution%Variable = .true.

        end if


        ! This property has fluxes between sediment and
        ! sediment-water interface? no - 0;  yes - 1
        call GetData(NewProperty%Evolution%SedimentFluxes,                              &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromBlock,                                          &
                     keyword      = 'SEDIMENT_FLUXES',                                  &
                     Default      = .false.,                                            &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR150'

        if (NewProperty%Evolution%SedimentFluxes)NewProperty%Evolution%Variable = .true.

        call GetData(NewProperty%Non_Cohesive,                                           &
                     Me%ObjEnterData,iflag,                                              &
                     SearchType   = FromBlock,                                           &
                     keyword      = 'NON_COHESIVE',                                      &
                     Default      = .false.,                                             &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)&
            stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR155'

        if (NewProperty%Non_Cohesive .and. .not. Me%RunSedimentModule) then
                write(*,*)
                write(*,*) 'Property : '//trim(NewProperty%ID%Name), ' is defined as non-cohesive (sand).'
                write(*,*)'Define the keyword NON_COHESIVE as 0 or '
                write(*,*)'include the keyword SEDIMENT : 1 in module Model to activate the module Sediment.'
                write(*,*)
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR156'
        endif

        !Time Step if the property field is variable in time
        if ((NewProperty%Evolution%Variable         ).or. &
            (NewProperty%ID%IDNumber.eq.Temperature_).or. &
            (NewProperty%ID%IDNumber.eq.Salinity_   )) then

            call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR160'

            call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                                 &
                stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR170'

            if (VariableDT) then

                NewProperty%Evolution%DTInterval = ModelDT

            else

                call GetData(NewProperty%Evolution%DTInterval,                          &
                             Me%ObjEnterData, iflag,                                    &
                             SearchType     = FromBlock,                                &
                             keyword        = 'DT_INTERVAL',                            &
                             Default        = ModelDT,                                  &
                             ClientModule   = 'ModuleInterfaceSedimentWater',           &
                             STAT           = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                            &
                    stop 'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR180'


                if (NewProperty%evolution%DTInterval < (ModelDT)) then
                    write(*,*)
                    write(*,*) ' Time step error.'
                    stop       'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR190'

                elseif (NewProperty%evolution%DTInterval > (ModelDT)) then

                    !Property DT  must be a multiple of the ModelDT
                    auxFactor = NewProperty%evolution%DTInterval  / ModelDT

                    Erroraux = auxFactor - int(auxFactor)

                    if (Erroraux /= 0) then
                        write(*,*)
                        write(*,*) ' Time step error.'
                        stop       'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR200'
                    endif

                        ! Run period in seconds
                        DTaux = Me%EndTime - Me%ExternalVar%Now

                        !The run period must be a multiple of the Property DT
                        auxFactor = DTaux / NewProperty%evolution%DTInterval

                        ErrorAux = auxFactor - int(auxFactor)

                        if (ErrorAux /= 0) then
                            write(*,*)
                            write(*,*) ' Time step error.'
                            stop       'Construct_PropertyEvolution - ModuleInterfaceSedimentWater - ERR210'
                        endif

                    end if

                endif

            NewProperty%Evolution%NextCompute = Me%ExternalVar%Now + NewProperty%Evolution%DTInterval

        else

            call null_time(NewProperty%Evolution%NextCompute)

            NewProperty%evolution%DTInterval = FillValueReal

        endif

    end subroutine Construct_PropertyEvolution


    !-------------------------------------------------------------------------


    subroutine Construct_PropertyOutPut(NewProperty)

        !Arguments------------------------------------------------------------
        type(T_property),           pointer     :: NewProperty

        !Local-----------------------------------------------------------------
        integer                                 :: STAT_CALL
        integer                                 :: iflag

        !Begin----------------------------------------------------------------

        !Checks out if the user pretends to write a HDF format file for this property
        call GetData(NewProperty%OutputHDF,                                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTPUT_HDF',                                     &
                     Default        = .false.,                                          &
                     SearchType     = FromBlock,                                        &
                     ClientModule   = 'ModuleInterfaceSedimentWater',                   &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'Construct_PropertyOutPut - ModuleInterfaceSedimentWater - ERR01a'

        !Checks out if the user pretends to write property values in the original units
        !(when units are other than concentration)
        call GetData(NewProperty%OutHDForigin,                                          &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'OUTHDF_ORIGIN_UNITS',                            &
                     Default        = .false.,                                          &
                     SearchType     = FromBlock,                                        &
                     ClientModule   = 'ModuleInterfaceSedimentWater',                   &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'Construct_PropertyOutPut - ModuleInterfaceSedimentWater - ERR01b'

        ! Checks out if the user pretends to write a time serie for this property
        call GetData(NewProperty%TimeSerie,                                             &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'TIME_SERIE',                                     &
                     Default        = .false.,                                          &
                     SearchType     = FromBlock,                                        &
                     ClientModule   = 'ModuleInterfaceSedimentWater',                   &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'Construct_PropertyOutPut - ModuleInterfaceSedimentWater - ERR02'

        ! Checks out if the user pretends to write a time serie inside each box for this property
        call GetData(NewProperty%BoxTimeSerie,                                          &
                     Me%ObjEnterData, iflag,                                            &
                     Keyword        = 'BOX_TIME_SERIE',                                 &
                     Default        = .false.,                                          &
                     SearchType     = FromBlock,                                        &
                     ClientModule   = 'ModuleInterfaceSedimentWater',                   &
                     STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'Construct_PropertyOutPut - ModuleInterfaceSedimentWater - ERR03'

    end subroutine Construct_PropertyOutPut

    !--------------------------------------------------------------------------

    subroutine Add_Property(NewProperty)

        !Arguments-------------------------------------------------------------
        type(T_Property),           pointer     :: NewProperty

        !----------------------------------------------------------------------

        ! Add to the WaterProperty List a new property
        if (.not.associated(Me%FirstProperty)) then
            Me%PropertiesNumber  = 1
            Me%FirstProperty     => NewProperty
            Me%LastProperty      => NewProperty
        else
            NewProperty%Prev     => Me%LastProperty
            Me%LastProperty%Next => NewProperty
            Me%LastProperty      => NewProperty
            Me%PropertiesNumber  = Me%PropertiesNumber + 1
        end if

        !----------------------------------------------------------------------

    end subroutine Add_Property

    !--------------------------------------------------------------------------


    subroutine Add_BenthicRate(NewBenthicRate)

        !Arguments-------------------------------------------------------------
        type(T_BenthicRate), pointer       :: NewBenthicRate

        !----------------------------------------------------------------------

        ! Add to the WaterProperty List a new property
        if (.not.associated(Me%FirstBenthicRate)) then
            Me%BenthicRatesNumber      = 1
            Me%FirstBenthicRate        => NewBenthicRate
            Me%LastBenthicRate         => NewBenthicRate
        else
            NewBenthicRate%Prev        => Me%LastBenthicRate
            Me%LastBenthicRate%Next    => NewBenthicRate
            Me%LastBenthicRate         => NewBenthicRate
            Me%BenthicRatesNumber      = Me%BenthicRatesNumber + 1
        end if

    end subroutine Add_BenthicRate

    !--------------------------------------------------------------------------

    subroutine Open_HDF5_OutPut_File

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: WorkILB, WorkIUB
        integer                                     :: WorkJLB, WorkJUB
        integer                                     :: WorkKLB, WorkKUB
        integer                                     :: HDF5_CREATE

        !----------------------------------------------------------------------

        WorkILB = Me%WaterWorkSize3D%ILB
        WorkIUB = Me%WaterWorkSize3D%IUB
        WorkJLB = Me%WaterWorkSize3D%JLB
        WorkJUB = Me%WaterWorkSize3D%JUB
        WorkKLB = Me%WaterWorkSize3D%KLB
        WorkKUB = Me%WaterWorkSize3D%KUB

        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        !Opens HDF5 File
        call ConstructHDF5(Me%ObjHDF5, trim(Me%Files%Results), HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR01'

        !Write the Horizontal Grid
        call WriteHorizontalGrid(Me%ObjHorizontalGrid, Me%ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR02'

        !Sets limits for next write operations
        call HDF5SetLimits   (Me%ObjHDF5, WorkILB, WorkIUB, WorkJLB, WorkJUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR03'

        !Writes the Grid
        call HDF5WriteData   (Me%ObjHDF5, "/Grid", "Bathymetry", "m",               &
                              Array2D = Me%ExtWater%Bathymetry,                     &
                              STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR04'

        !call HDF5WriteData  (Me%ObjHDF5, "/Grid/CellArea", "CellArea",           &
        !                         'm2', Array2D = Me%ExternalVar%GridCellArea,    &
        !                      STAT = STAT_CALL)
        !if (STAT_CALL /= SUCCESS_) &
        !   stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR05'

        call HDF5SetLimits  (Me%ObjHDF5, WorkILB, WorkIUB,                          &
                             WorkJLB, WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR06'

        call HDF5WriteData  (Me%ObjHDF5, "/Grid", "WaterPoints3D",                    &
                             "-", Array3D = Me%ExtWater%WaterPoints3D,              &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR07'


        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                  &
           stop 'Open_HDF5_OutPut_File - ModuleInterfaceSedimentWater - ERR08'

        !----------------------------------------------------------------------

    end subroutine Open_HDF5_OutPut_File

    !--------------------------------------------------------------------------

    subroutine ConstructGlobalOutput

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_CALL
        integer                                     :: iflag

        !Begin-----------------------------------------------------------------

        nullify(Me%OutPut%OutTime)

        call GetOutPutTime(Me%ObjEnterData,                              &
                           CurrentTime = Me%ExternalVar%Now,             &
                           EndTime     = Me%EndTime,                     &
                           keyword     = 'OUTPUT_TIME',                  &
                           SearchType  = FromFile,                       &
                           OutPutsTime = Me%OutPut%OutTime,              &
                           OutPutsOn   = Me%OutPut%Yes,                  &
                           STAT        = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                       &
            stop 'ConstructGlobalOutput - ModuleInterfaceSedimentWater - ERR01'

        if (Me%OutPut%Yes) then

            Me%OutPut%NextOutPut = 1

            call Open_HDF5_OutPut_File

        else
            write(*,*)'Keyword OUTPUT_TIME must be defined if at least'
            write(*,*)'one property has HDF format outputs.'
            stop 'ConstructGlobalOutput - ModuleInterfaceSedimentWater - ERR02'
        endif

        call GetOutPutTime(Me%ObjEnterData,                                         &
                           CurrentTime = Me%ExternalVar%Now,                        &
                           EndTime     = Me%EndTime,                                &
                           keyword     = 'RESTART_FILE_OUTPUT_TIME',                &
                           SearchType  = FromFile,                                  &
                           OutPutsTime = Me%OutPut%RestartOutTime,                  &
                           OutPutsOn   = Me%OutPut%WriteRestartFile,                &
                           STAT        = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                       &
            stop 'ConstructGlobalOutput - ModuleInterfaceSedimentWater - ERR03'

        if(Me%OutPut%WriteRestartFile)then

            Me%OutPut%NextRestartOutput = 1

        end if

        !<BeginKeyword>
            !Keyword          : RESTART_FILE_OVERWRITE
            !<BeginDescription>
               !
               ! This option checks wether the restart file is to be overwritten or not
               !
            !<EndDescription>
            !Type             : logical
            !Default          : .true.
            !Multiple Options : Do not have
            !Search Type      : FromFile
        !<EndKeyword>

        call GetData(Me%OutPut%RestartOverwrite,                                        &
                     Me%ObjEnterData,                                                   &
                     iflag,                                                             &
                     SearchType   = FromFile,                                           &
                     keyword      = 'RESTART_FILE_OVERWRITE',                           &
                     Default      = .true.,                                             &
                     ClientModule = 'ModuleWaterProperties',                            &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'ConstructGlobalOutput - ModuleInterfaceSedimentWater - ERR04'



    end subroutine ConstructGlobalOutput

    !------------------------------------------------------------------------

    subroutine Construct_BenthicRateList

        !External----------------------------------------------------------------
        integer                                :: ClientNumber
        integer                                :: STAT_CALL
        logical                                :: BlockFound

        !Local-------------------------------------------------------------------
        type (T_BenthicRate),    pointer      :: NewBenthicRate

        !------------------------------------------------------------------------


do1 :   do
            call ExtractBlockFromBuffer(Me%ObjEnterData,                    &
                                        ClientNumber    = ClientNumber,     &
                                        block_begin     = rate_block_begin, &
                                        block_end       = rate_block_end,   &
                                        BlockFound      = BlockFound,       &
                                        STAT            = STAT_CALL)
            if(STAT_CALL .EQ. SUCCESS_)then
                if (BlockFound) then

                    !Construct a New Benthic Rate
                    Call Construct_BenthicRate  (NewBenthicRate)

                    !Add new Rate to the Benthic Rates List
                    Call Add_BenthicRate    (NewBenthicRate)

                else
                    call Block_Unlock(Me%ObjEnterData, ClientNumber, STAT = STAT_CALL)

                    if (STAT_CALL .NE. SUCCESS_)                                            &
                        stop 'Construct_BenthicRateList - ModuleInterfaceSedimentWater - ERR01'

                    exit do1    !No more blocks
                end if


            else if (STAT_CALL .EQ. BLOCK_END_ERR_) then
                write(*,*)
                write(*,*) 'Error calling ExtractBlockFromBuffer. '
                stop       'Construct_BenthicRateList - ModuleInterfaceSedimentWater - ERR02'
            else
                stop       'Construct_BenthicRateList - ModuleInterfaceSedimentWater - ERR03'
            end if
        end do do1

    end subroutine Construct_BenthicRateList

    !--------------------------------------------------------------------------

    subroutine Construct_BenthicRate(NewBenthicRate)

        !Arguments-------------------------------------------------------------
        type(T_BenthicRate), pointer        :: NewBenthicRate

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !----------------------------------------------------------------------

        allocate (NewBenthicRate, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                          &
            stop 'Construct_BenthicRate - ModuleInterfaceSedimentWater - ERR01'

        nullify(NewBenthicRate%Field, NewBenthicRate%Prev, NewBenthicRate%Next)

        call Construct_BenthicRateID       (NewBenthicRate)

        call Construct_BenthicRateValues   (NewBenthicRate)


    end subroutine Construct_BenthicRate

    !--------------------------------------------------------------------------

    subroutine Construct_BenthicRateID(NewBenthicRate)

        !Arguments-------------------------------------------------------------
        type(T_BenthicRate), pointer       :: NewBenthicRate

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: iflag, PropNumber
        logical                             :: CheckName
        !type (T_Property), pointer          :: PropertyX

        !----------------------------------------------------------------------

        !First Property defined in a rate relation
        call GetData(NewBenthicRate%FirstProp%name,                                     &
                     Me%ObjEnterData, iflag,                                            &
                     keyword      = 'FIRSTPROP',                                        &
                     ClientModule = 'ModuleInterfaceSedimentWater',                     &
                     SearchType   = FromBlock,                                          &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR01'
        if (iflag==0)                                                                   &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR02'

        !Check if the property name is valid
        CheckName = CheckPropertyName(NewBenthicRate%FirstProp%Name, Number = PropNumber)
        if (CheckName) then
            NewBenthicRate%FirstProp%IDnumber = PropNumber
        else
            write(*,*)
            write(*,*) 'The first property name is not recognised by the model.'
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR03'
        end if

        !call Search_Property(PropertyX, PropertyXID = PropNumber, STAT = STAT_CALL)
       ! if (STAT_CALL /= SUCCESS_)                                                     &
         !   stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR04'

        !second Property defined in a rate relation
        call GetData(NewBenthicRate%SecondProp%Name,                                     &
                     Me%ObjEnterData, iflag,                                             &
                     keyword      = 'SECONDPROP',                                        &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     SearchType   = FromBlock,                                           &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR05'
        if (iflag==0)                                                                    &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR06'

        ! Check if the property name is valid OR not
        CheckName = CheckPropertyName(NewBenthicRate%SecondProp%name, Number = PropNumber)
        if (CheckName) then
            NewBenthicRate%SecondProp%IDnumber = PropNumber
        else
            write(*,*)
            write(*,*) 'The Second property name is not recognised by the model.'
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR07'
        end if

       ! call Search_Property(PropertyX, PropertyXID = PropNumber, STAT = STAT_CALL)
       ! if (STAT_CALL /= SUCCESS_)                                                       &
       !     stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR08'


       !Rate description ex: zooplankton grazing over phytoplankton
        call GetData(NewBenthicRate%ID%Description,                                      &
                     Me%ObjEnterData, iflag,                                             &
                     keyword      = 'DESCRIPTION',                                       &
                     Default      = 'No description was given.',                         &
                     ClientModule = 'ModuleInterfaceSedimentWater',                      &
                     SearchType   = FromBlock,                                           &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                       &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR09'

        !Rate name (this is the name of the output boxes file)
        call GetData(NewBenthicRate%ID%Name,                                               &
                     Me%ObjEnterData, iflag,                                               &
                     keyword      = 'NAME',                                                &
                     ClientModule = 'ModuleInterfaceSedimentWater',                        &
                     SearchType   = FromBlock,                                             &
                     Default      = 'No name was given to sediment rate.',                 &
                     STAT         = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                         &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR10'
        if (iflag==0)                                                                      &
            stop 'Construct_BenthicRateID - ModuleInterfaceSedimentWater - ERR11'

    end subroutine Construct_BenthicRateID


    !--------------------------------------------------------------------------


    subroutine Construct_BenthicRateValues(NewBenthicRate)

        !Arguments-------------------------------------------------------------
        type(T_BenthicRate), pointer        :: NewBenthicRate

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                             :: ILB, IUB, JLB, JUB

        !----------------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB


        allocate(NewBenthicRate%Field(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) &
            stop 'Construct_BenthicRateValues - ModuleInterfaceSedimentWater - ERR01'
        NewBenthicRate%Field(:,:) = FillValueReal

    end subroutine Construct_BenthicRateValues


    !----------------------------------------------------------------------


    subroutine ConstructLog


        !Local-----------------------------------------------------------------
        type (T_Property), pointer                  :: CurrentProperty


#ifndef _OUTPUT_OFF_
        write(*, *)"---------------- INTERFACE SEDIMENT-WATER -----------------"
        write(*, *)
        write(*, *)"Num of Properties : ", Me%PropertiesNumber
        write(*, *)

        CurrentProperty => Me%FirstProperty
        do while (associated(CurrentProperty))

            write(*, *)"Property          : ", trim(CurrentProperty%ID%Name)
            write(*, *)"---Benthos        : ", CurrentProperty%Evolution%Benthos
            write(*, *)"---BenthicEcology : ", CurrentProperty%Evolution%BenthicEcology
            write(*, *)"---BenthicCEQUALW2: ", CurrentProperty%Evolution%CEQUALW2
            write(*, *)"---Detritus       : ", CurrentProperty%Evolution%Detritus
            write(*, *)"---WaterFluxes    : ", CurrentProperty%Evolution%WaterFluxes
            write(*, *)"---SedimentFluxes : ", CurrentProperty%Evolution%SedimentFluxes
            write(*, *)"---Sed-Water Flux : ", CurrentProperty%Evolution%SedimentWaterFluxes
            write(*, *)"---Erosion        : ", CurrentProperty%Evolution%Erosion
            write(*, *)"---Deposition     : ", CurrentProperty%Evolution%Deposition
            write(*, *)

            CurrentProperty=>CurrentProperty%Next
        enddo
#endif

    end subroutine ConstructLog


    !--------------------------------------------------------------------------


    subroutine Construct_Sub_Modules

        !Local-----------------------------------------------------------------
        type (T_Property),           pointer                 :: PropertyX
        integer                                              :: STAT_CALL
        integer                                              :: FreeVerticalMovementID
        integer                                              :: ILB, IUB, JLB, JUB
        integer                                              :: NumberOfClasses, SandIDNumber, n
        real                                                 :: RelativeDensity
        real(8)                                              :: D50

        !----------------------------------------------------------------------

        Me%Coupled%WaterFluxes%NumberOfProperties          = 0
        Me%Coupled%SedimentWaterFluxes%NumberOfProperties  = 0
        Me%Coupled%SedimentFluxes%NumberOfProperties       = 0
        Me%Coupled%Benthos%NumberOfProperties              = 0
        Me%Coupled%CEQUALW2%NumberOfProperties             = 0
        Me%Coupled%Detritus%NumberOfProperties             = 0
        Me%Coupled%TimeSerie%NumberOfProperties            = 0
        Me%Coupled%BoxTimeSerie%NumberOfProperties         = 0
        Me%Coupled%OutputHDF%NumberOfProperties            = 0
        Me%Coupled%BenthicEcology%NumberOfProperties       = 0

        PropertyX => Me%FirstProperty

do1 :   do while (associated(PropertyX))

            if (PropertyX%Evolution%WaterFluxes) then
                Me%Coupled%WaterFluxes%NumberOfProperties           = &
                Me%Coupled%WaterFluxes%NumberOfProperties           + 1
                Me%Coupled%WaterFluxes%Yes                          = ON
            endif


            if (PropertyX%Evolution%SedimentWaterFluxes) then
                Me%Coupled%SedimentWaterFluxes%NumberOfProperties   = &
                Me%Coupled%SedimentWaterFluxes%NumberOfProperties   + 1
                Me%Coupled%SedimentWaterFluxes%Yes                  = ON

            endif

            if (PropertyX%Evolution%SedimentFluxes) then
                Me%Coupled%SedimentFluxes%NumberOfProperties        = &
                Me%Coupled%SedimentFluxes%NumberOfProperties        + 1
                Me%Coupled%SedimentFluxes%Yes                       = ON
            endif

            if (PropertyX%Evolution%Benthos) then
                Me%Coupled%Benthos%NumberOfProperties               = &
                Me%Coupled%Benthos%NumberOfProperties               + 1
                Me%Coupled%Benthos%Yes                              = ON
            endif

             if (PropertyX%Evolution%BenthicEcology) then
                Me%Coupled%BenthicEcology%NumberOfProperties        = &
                Me%Coupled%BenthicEcology%NumberOfProperties        + 1
                Me%Coupled%BenthicEcology%Yes                       = ON
            endif

            if (PropertyX%Evolution%CEQUALW2) then
                Me%Coupled%CEQUALW2%NumberOfProperties              = &
                Me%Coupled%CEQUALW2%NumberOfProperties              + 1
                Me%Coupled%CEQUALW2%Yes                             = ON
            endif

            if (PropertyX%Evolution%Detritus) then
                Me%Coupled%Detritus%NumberOfProperties              = &
                Me%Coupled%Detritus%NumberOfProperties              + 1
                Me%Coupled%Detritus%Yes                             = ON
            endif

            if (PropertyX%Evolution%Erosion .and. .not.PropertyX%Non_Cohesive) then
                Me%Coupled%Erosion%NumberOfProperties               = &
                Me%Coupled%Erosion%NumberOfProperties               + 1
                Me%Coupled%Erosion%Yes                              = ON
            endif

            if (PropertyX%Evolution%Deposition .and. .not.PropertyX%Non_Cohesive) then
                Me%Coupled%Deposition%NumberOfProperties            = &
                Me%Coupled%Deposition%NumberOfProperties            + 1
                Me%Coupled%Deposition%Yes                           = ON
            endif


            if (PropertyX%TimeSerie) then
                Me%Coupled%TimeSerie%NumberOfProperties             = &
                Me%Coupled%TimeSerie%NumberOfProperties             + 1
                Me%Coupled%TimeSerie%Yes                            = ON
            endif

            if (PropertyX%BoxTimeSerie) then
                Me%Coupled%BoxTimeSerie%NumberOfProperties          = &
                Me%Coupled%BoxTimeSerie%NumberOfProperties          + 1
                Me%Coupled%BoxTimeSerie%Yes                         = ON
            endif

            if (PropertyX%OutputHDF) then
                Me%Coupled%OutputHDF%NumberOfProperties             = &
                Me%Coupled%OutputHDF%NumberOfProperties             + 1
                Me%Coupled%OutputHDF%Yes                            = ON
            endif

            PropertyX=>PropertyX%Next

        end do do1

        if(Me%Coupled%Benthos%Yes .and. Me%Coupled%CEQUALW2%Yes)then

            write(*,*)'Benthos and CEQUALW2 models cannot be simulated at the same time.'
            stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR01'

        end if

        if(Me%Coupled%Benthos%Yes .and. Me%Coupled%BenthicEcology%Yes)then

            write(*,*)'Benthos and BenthicEcology models cannot be simulated at the same time.'
            stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR01.1'

        end if

        if(Me%Coupled%BenthicEcology%Yes .and. Me%Coupled%CEQUALW2%Yes)then

            write(*,*)'BenthicEcology and CEQUALW2 models cannot be simulated at the same time.'
            stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR01.2'

        end if


        if(Me%Coupled%Detritus%Yes .and. .not. Me%Coupled%CEQUALW2%Yes)then

            write(*,*)'Detritus and CEQUALW2 must be simulated at the same time.'
            stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR02'

        end if


        if(Me%Coupled%WaterFluxes%Yes) then

            call GetWaterPropertiesSubModulesID(WaterPropertiesID      = Me%ObjWaterProperties, &
                                                FreeVerticalMovementID = FreeVerticalMovementID,&
                                                STAT                   = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                        &
                stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR03'

            if(FreeVerticalMovementID /= 0)then
                Me%ObjFreeVerticalMovement = AssociateInstance(mFREEVERTICALMOVEMENT_,FreeVerticalMovementID)

                call GetDepositionIntertidalZones(FreeVerticalMovementID = FreeVerticalMovementID, &
                                                  DepositionIntertidalZones = Me%DepositionIntertidalZones, &
                                                  STAT                   = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                        &
                    stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR04'

                if(Me%DepositionIntertidalZones) then
                    Me%WaterPointsorOpenPoints2D => Me%ExtWater%WaterPoints2D
                else
                    Me%WaterPointsorOpenPoints2D => Me%ExtWater%OpenPoints2D
                endif


                if (Me%RunSedimentModule) then

                    !get and set information in Module Sediment so that it does not need to comunicate with free vertical
                    !movement
                    call SetWaterPointsOpenPoints2D(ObjSedimentID = Me%ObjSediment,                         &
                                                  WaterPointsOpenPoints2D = Me%WaterPointsorOpenPoints2D,   &
                                                  STAT = STAT_CALL)
                    if (STAT_CALL  /= SUCCESS_)                                                             &
                        stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR4.5'


                    call GetNumberOfClasses(ObjSedimentID = Me%ObjSediment,                         &
                                                  NumberOfClasses = NumberOfClasses,                &
                                                  STAT = STAT_CALL)
                    if (STAT_CALL  /= SUCCESS_)                                                     &
                        stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR4.6'


                    do n=1, NumberOfClasses
                        call GetSandParameters(ObjSedimentID = Me%ObjSediment,                      &
                                               SandID = n,                                          &
                                               SandIDNumber = SandIDNumber,                         &
                                               SandD50 = D50,                                       &
                                               RelativeDensity = RelativeDensity,                   &
                                               STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_) stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR4.7'

                        call SetSandParameters(FreeVerticalMovementID = FreeVerticalMovementID,     &
                                               PropertyID = SandIDNumber,                           &
                                               SandDiameter = D50,                                  &
                                               RelativeDensity = RelativeDensity,                   &
                                               STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_) stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR4.8'
                    enddo
                endif

            end if

            ILB = Me%Size2D%ILB
            IUB = Me%Size2D%IUB
            JLB = Me%Size2D%JLB
            JUB = Me%Size2D%JUB

            allocate(Me%DepositionProbability(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR05'
            Me%DepositionProbability(:,:) = 1.

            call CheckOptionsWaterFluxes

        end if

#ifndef _SEDIMENT_

        if(Me%RunsSediments)then
            if(Me%Coupled%SedimentFluxes%Yes) then

                call CheckOptionsSedimentFluxes

            end if

            if(Me%Coupled%SedimentWaterFluxes%Yes) then

                call CheckOptionsSedimentWaterFluxes

            end if
        endif
#endif

        if(Me%Coupled%Benthos%Yes)then

            call CoupleBenthos

            call ReadSOD

            if (Me%UseSOD)then
                call SetSOD(Me%SOD%Field, Me%ExtWater%OpenPoints2D, Me%ExtWater%WaterPoints2D)
            end if

        end if

       if(Me%Coupled%BenthicEcology%Yes)then

            call CoupleBenthicEcology

        end if

        if(Me%Coupled%CEQUALW2%Yes)then

            call CoupleCEQUALW2

            call ReadSOD

            if (Me%UseSOD)then
                call SetSOD(Me%SOD%Field, Me%ExtWater%OpenPoints2D, Me%ExtWater%WaterPoints2D)
            end if

        end if


        if(Me%Coupled%TimeSerie%Yes)then

            call Construct_Time_Serie

        end if

        if(Me%Coupled%BoxTimeSerie%Yes)then

            call StartOutputBoxFluxes

        end if

        if(Me%Coupled%OutputHDF%Yes)then

            call ConstructGlobalOutput

        end if

        call GetWaterPropertiesBottomOptions(WaterPropertiesID = Me%ObjWaterProperties, &
                                             MacroAlgae        = Me%MacroAlgae,         &
                                             STAT              = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Sub_Modules - ModuleInterfaceSedimentWater - ERR06'


    end subroutine Construct_Sub_Modules


    !--------------------------------------------------------------------------


    subroutine Construct_Time_Serie

        !External--------------------------------------------------------------
        character(len=PathLength)                           :: TimeSerieLocationFile
        integer                                             :: STAT_CALL, iflag

        !Local-----------------------------------------------------------------
        real                                                :: CoordX, CoordY
        logical                                             :: CoordON, IgnoreOK
        integer                                             :: dn, Id, Jd, TimeSerieNumber
        type (T_Property), pointer                          :: PropertyX
        integer                                             :: nProperties
        character(len=StringLength), dimension(:), pointer  :: PropertyList
        character(len=StringLength)                         :: TimeSerieName
        type (T_Polygon), pointer                           :: ModelDomainLimit

        !----------------------------------------------------------------------

        !First checks out how many properties will have time series
        PropertyX   => Me%FirstProperty
        nProperties =  1
        do while (associated(PropertyX))
            if (PropertyX%TimeSerie) then
                nProperties = nProperties + 1
                if(PropertyX%Evolution%Deposition) then
                    nProperties = nProperties + 1
                    if(PropertyX%Non_Cohesive) then
                        nProperties = nProperties + 1
                    endif
                endif
                if(PropertyX%Evolution%Erosion) then
                    nProperties = nProperties + 1
                endif
            endif

            PropertyX=>PropertyX%Next
        enddo


        !Allocates PropertyList
        allocate(PropertyList(nProperties), STAT = STAT_CALL)
        if (STAT_CALL /= 0) stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR10'

        PropertyList(1) = 'ShearStress'

        !Fills up PropertyList
        PropertyX   => Me%FirstProperty
        nProperties =  1
        do while (associated(PropertyX))
            if (PropertyX%TimeSerie) then
                nProperties = nProperties + 1
                PropertyList(nProperties) = trim(adjustl(PropertyX%ID%name))

                if(PropertyX%Evolution%Deposition) then
                    nProperties = nProperties + 1
                    PropertyList(nProperties) = 'Deposition_'//trim(adjustl(PropertyX%ID%name))
                    if(PropertyX%Non_Cohesive) then
                        nProperties = nProperties + 1
                        PropertyList(nProperties) = 'BottomConcentration_'//trim(adjustl(PropertyX%ID%name))
                    endif
                endif
                if(PropertyX%Evolution%Erosion) then
                    nProperties = nProperties + 1
                    PropertyList(nProperties) = 'Erosion_'//trim(adjustl(PropertyX%ID%name))
                endif

            endif
            PropertyX=>PropertyX%Next
        enddo

        call GetData(TimeSerieLocationFile,                                             &
                     Me%ObjEnterData, iflag,                                            &
                     SearchType   = FromFile,                                           &
                     keyword      = 'TIME_SERIE_LOCATION',                              &
                     ClientModule = 'ModuleWaterProperties',                            &
                     Default      = Me%Files%InputData,                                 &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                    &
            stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR20'

        call GetGridOutBorderPolygon(HorizontalGridID = Me%ObjHorizontalGrid,           &
                                     Polygon          = ModelDomainLimit,               &
                                     STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR25'

        !Constructs TimeSerie
        call StartTimeSerie(Me%ObjTimeSerie, Me%ObjTime,                                &
                            trim(TimeSerieLocationFile),                                &
                            PropertyList, "srb",                                        &
                            WaterPoints3D = Me%ExtWater%WaterPoints3D,                  &
                            ModelName     = Me%ModelName,                               &
                            ModelDomain   = ModelDomainLimit,                           &
                            STAT          = STAT_CALL)
        if (STAT_CALL /= 0) stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR30'

        call UngetHorizontalGrid(HorizontalGridID = Me%ObjHorizontalGrid,               &
                                 Polygon          = ModelDomainLimit,                   &
                                 STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleInterfaceSedimentWater - ERR35'

        !Deallocates PropertyList
        deallocate(PropertyList, STAT = STAT_CALL)
        if (STAT_CALL /= 0) stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR40'

        !Corrects if necessary the cell of the time serie based in the time serie coordinates
        call GetNumberOfTimeSeries(Me%ObjTimeSerie, TimeSerieNumber, STAT  = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR50'

        do dn = 1, TimeSerieNumber

            call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleInterfaceSedimentWater - ERR60'

            if (IgnoreOK) cycle

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                      CoordX   = CoordX,                                &
                                      CoordY   = CoordY,                                &
                                      CoordON  = CoordON,                               &
                                      STAT     = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleInterfaceSedimentWater - ERR70'

            call GetTimeSerieName(Me%ObjTimeSerie, dn, TimeSerieName, STAT  = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleInterfaceSedimentWater - ERR80'

            if (CoordON) then
                call GetXYCellZ(Me%ObjHorizontalGrid, CoordX, CoordY, Id, Jd, STAT = STAT_CALL)

                if (STAT_CALL /= SUCCESS_ .and. STAT_CALL /= OUT_OF_BOUNDS_ERR_) then
                    stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR90'
                endif

                !if (STAT_CALL == OUT_OF_BOUNDS_ERR_ .or. Id < 0 .or. Jd < 0) then

                !    call TryIgnoreTimeSerie(Me%ObjTimeSerie, dn, IgnoreOK, STAT = STAT_CALL)
                !    if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR70'

                !    if (IgnoreOK) then
                !        cycle
                !    else
                !        stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR80'
                !    endif

                !endif


                call CorrectsCellsTimeSerie(Me%ObjTimeSerie, dn, Id, Jd, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Construct_Time_Serie - ModuleInterfaceSedimentWater - ERR100'
            endif

            call GetTimeSerieLocation(Me%ObjTimeSerie, dn,                              &
                                      LocalizationI   = Id,                             &
                                      LocalizationJ   = Jd,                             &
                                      STAT     = STAT_CALL)

            if (STAT_CALL /= SUCCESS_) stop 'ConstructTimeSerie - ModuleInterfaceSedimentWater - ERR120'

            if (Me%ExtWater%WaterPoints3D(Id, Jd,Me%WaterWorkSize3D%KUB) /= WaterPoint) then

                 write(*,*) 'Time Serie in a land cell - ',trim(TimeSerieName),' - ',' ModuleInterfaceSedimentWater'
            endif

        enddo


    end subroutine Construct_Time_Serie

    !----------------------------------------------------------------------

    subroutine StartOutputBoxFluxes

        !External--------------------------------------------------------------
        integer                                             :: iflag, STAT_CALL
        integer                                             :: ILB, IUB, JLB, JUB
        logical                                             :: Exist, Opened

        !Local-----------------------------------------------------------------
        type(T_Property),                           pointer :: PropertyX
        type(T_BenthicRate    ),                    pointer :: BenthicRateX
        character(len=StringLength), dimension(:),  pointer :: ScalarOutputList
        integer                                             :: nScalars, n

        !----------------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        ! This keyword have two functions if exist fluxes between boxes are compute
        ! and the value read is the name file where the boxes are defined
        call GetData(Me%Files%BoxesFile,                                            &
                     Me%ObjEnterData, iflag,                                        &
                     keyword      = 'BOXFLUXES',                                    &
                     ClientModule = 'ModuleInterfaceSedimentWater',                 &
                     STAT         = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)                                                &
            stop 'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR01'
        if (iflag .EQ. 0)                                                           &
            stop 'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR02'

        inquire(File = Me%Files%BoxesFile, Exist = exist)
        if (exist) then
            inquire(File = Me%Files%BoxesFile, Opened  = Opened)
            if (opened) then
                write(*,*    )
                write(*,'(A)') 'BoxesFile = ',trim(adjustl(Me%Files%BoxesFile))
                write(*,*    ) 'Already opened.'
                stop           'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR03'
            end if
        else
            write(*,*)
            write(*,*)     'Could not find the boxes file.'
            write(*,'(A)') 'BoxFileName = ', Me%Files%BoxesFile
            stop           'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR04'
        end if

        nScalars = Me%Coupled%BoxTimeSerie%NumberOfProperties + Me%BenthicRatesNumber

        allocate(ScalarOutputList(nScalars), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR06'

        PropertyX  => Me%FirstProperty
        n = 0
        do while (associated(PropertyX))
            if (PropertyX%BoxTimeSerie) then
                n = n + 1
                ScalarOutputList(n) = "Bottom "//trim(PropertyX%ID%name)
            end if

            PropertyX=>PropertyX%Next
        end do

        BenthicRateX => Me%FirstBenthicRate
        do while(associated(BenthicRateX))
            n = n + 1
            ScalarOutputList(n) = "Bottom "//trim(BenthicRateX%ID%name)
            BenthicRateX => BenthicRateX%Next
        end do

        call StartBoxDif(BoxDifID           = Me%ObjBoxDif,                 &
                         TimeID             = Me%ObjTime,                   &
                         HorizontalGridID   = Me%ObjHorizontalGrid,         &
                         BoxesFilePath      = Me%Files%BoxesFile,           &
                         ScalarOutputList   = ScalarOutputList,             &
                         WaterPoints2D      = Me%ExtWater%WaterPoints2D,    &
                         STAT               = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR07'

        deallocate(ScalarOutputList, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR07'

        allocate(Me%Scalar2D(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'StartOutputBoxFluxes - ModuleInterfaceSedimentWater - ERR12'
        Me%Scalar2D(:,:) = 0.

    end subroutine StartOutputBoxFluxes


    !--------------------------------------------------------------------------

    subroutine CoupleBenthos

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX, Temperature
        integer, pointer, dimension(:)                      :: BenthosPropertyList
        integer                                             :: STAT_CALL
        real                                                :: BenthosDT
        integer                                             :: Index = 0

        !----------------------------------------------------------------------

        Index = 0

        nullify (BenthosPropertyList)
        allocate(BenthosPropertyList(1:Me%Coupled%Benthos%NumberOfProperties))


        call Search_Property(Temperature, PropertyXID = Temperature_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            write(*,*)'Please define property temperature in the'
            write(*,*)'InterfaceSedimentWater data file.'
            stop 'CoupleBenthos - ModuleInterfaceSedimentWater - ERR00'
        end if


        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%Benthos)then
                Index = Index + 1
                BenthosPropertyList(Index)  = PropertyX%ID%IDNumber
            end if

            PropertyX => PropertyX%Next

        enddo

        nullify(PropertyX)

        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = BenthosModel,                  &
                                DT                  = BenthosDT,                     &
                                PropertiesList      = BenthosPropertyList,           &
                                WaterPoints2D       = Me%ExtWater%WaterPoints2D,     &
                                Size2D              = Me%WorkSize2D,                 &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            stop 'CoupleBenthos - ModuleInterfaceSedimentWater - ERR01'

        Me%Coupled%Benthos%DT_Compute  = BenthosDT
        Me%Coupled%Benthos%NextCompute = Me%ExternalVar%Now

        deallocate(BenthosPropertyList)
        nullify   (BenthosPropertyList)

    end subroutine CoupleBenthos



    !--------------------------------------------------------------------------

    subroutine CoupleBenthicEcology

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX, Temperature
        integer, pointer, dimension(:)                      :: BenthicEcologyPropertyList
        integer                                             :: STAT_CALL
        real                                                :: BenthicEcologyDT
        integer                                             :: Index = 0
        integer                                             :: ILB,IUB,JLB,JUB
        integer                                             :: KLBW,KUBW, KLBS, KUBS
        !----------------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB

        KLBW=Me%WaterWorkSize3D%KLB     ! 1
        KUBW=Me%WaterWorkSize3D%KUB     ! 1
        KLBS=Me%SedimentWorkSize3D%KLB  ! 1
        KUBS=Me%SedimentWorkSize3D%KUB  ! 2

        Index = 0

        nullify (BenthicEcologyPropertyList)
        allocate(BenthicEcologyPropertyList(1:Me%Coupled%BenthicEcology%NumberOfProperties))


        call Search_Property(Temperature, PropertyXID = Temperature_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            write(*,*)'Please define property temperature in the'
            write(*,*)'InterfaceSedimentWater data file.'
            stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR00'
        end if


        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%BenthicEcology)then
                Index = Index + 1
                BenthicEcologyPropertyList(Index)  = PropertyX%ID%IDNumber
            end if

            PropertyX => PropertyX%Next

        enddo

        nullify(PropertyX)

        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = BenthicEcologyModel,                  &
                                DT                  = BenthicEcologyDT,                     &
                                PropertiesList      = BenthicEcologyPropertyList,           &
                                WaterPoints2D       = Me%ExtWater%WaterPoints2D,     &
                                Size2D              = Me%WorkSize2D,                 &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR01'

        Me%Coupled%BenthicEcology%DT_Compute  = BenthicEcologyDT
        Me%Coupled%BenthicEcology%NextCompute = Me%ExternalVar%Now



        allocate(Me%ExtWater%WaterVolume(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR05'

       allocate(Me%ExtWater%Sediment(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR06'

      allocate(Me%BottomSWRadiationAverage(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR14'


      allocate(Me%Seagrasses%UptakeNH4s2D(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR08'

      allocate(Me%Seagrasses%UptakeNH4NO3w2D(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                    stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR09'


        allocate(Me%Seagrasses%UptakePO4w2D(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                    stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR10'



        allocate(Me%Seagrasses%LightFactor2D(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                    stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR12'

        allocate(Me%Seagrasses%UptakePO4s2D(ILB:IUB, JLB:JUB), STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'CoupleBenthicEcology - ModuleInterfaceSedimentWater - ERR13'

        Me%Seagrasses%UptakeNH4s2D  = 0.
        Me%Seagrasses%LightFactor2D = 0.
        Me%Seagrasses%UptakePO4w2D  = 0.
        Me%Seagrasses%UptakePO4s2D  = 0.
        Me%Seagrasses%UptakeNH4NO3w2D =0.



        deallocate(BenthicEcologyPropertyList)
        nullify   (BenthicEcologyPropertyList)

    end subroutine CoupleBenthicEcology
    !--------------------------------------------------------------------------



    subroutine CoupleCEQUALW2

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        integer, pointer, dimension(:)                      :: CEQUALW2PropertyList
        integer                                             :: STAT_CALL
        real                                                :: CEQUALW2DT
        integer                                             :: Index = 0

        !----------------------------------------------------------------------

        Index = 0

        nullify (CEQUALW2PropertyList)
        allocate(CEQUALW2PropertyList(1:Me%Coupled%CEQUALW2%NumberOfProperties))

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%CEQUALW2)then
                Index = Index + 1
                CEQUALW2PropertyList(Index)  = PropertyX%ID%IDNumber
            end if

            PropertyX => PropertyX%Next

        enddo

        nullify(PropertyX)

        call ConstructInterface(InterfaceID         = Me%ObjInterface,               &
                                TimeID              = Me%ObjTime,                    &
                                SinksSourcesModel   = BenthicCEQUALW2Model,          &
                                DT                  = CEQUALW2DT,                    &
                                PropertiesList      = CEQUALW2PropertyList,          &
                                WaterPoints2D       = Me%ExtWater%WaterPoints2D,     &
                                Size2D              = Me%WorkSize2D,                 &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                   &
            stop 'CoupleCEQUALW2 - ModuleInterfaceSedimentWater - ERR01'

        Me%Coupled%CEQUALW2%DT_Compute  = CEQUALW2DT
        Me%Coupled%CEQUALW2%NextCompute = Me%ExternalVar%Now

        deallocate(CEQUALW2PropertyList)
        nullify   (CEQUALW2PropertyList)

    end subroutine CoupleCEQUALW2


    !--------------------------------------------------------------------------


    subroutine CheckOptionsWaterFluxes

        !External--------------------------------------------------------------
        integer                                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        type(T_Property), pointer                           :: PropertyX
        real                                                :: DTInterval
        logical                                             :: WaterFluxes
        logical                                             :: FreeVerticalMovement

        !Begin-----------------------------------------------------------------


        if(Me%Coupled%Deposition%Yes)then

            call Read_Property_2D (Me%Critical_Shear_Deposition, FromBlock, csd_begin, csd_end)

        end if

        if(Me%Coupled%Erosion%Yes)then

            call Read_Property_2D (Me%Critical_Shear_Erosion, FromBlock, cse_begin, cse_end)

            call Read_Property_2D (Me%ErosionRate, FromBlock, erosion_begin, erosion_end)

        end if

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))

            if(PropertyX%Evolution%WaterFluxes)then

                if(.not. WaterPropertyExists(Me%ObjWaterProperties, PropertyX%ID%IDNumber))then
                    write(*,*)
                    write(*,*)'Property : '//trim(PropertyX%ID%Name)
                    write(*,*)'must be defined as a water property.'
                    stop 'CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - ERR50'
                end if

                call GetWaterPropertyOptions(Me%ObjWaterProperties,                 &
                                             PropertyX%ID%IDNumber,                 &
                                             DTInterval,                            &
                                             WaterFluxes,                           &
                                             FreeVerticalMovement,                  &
                                             STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_)                                        &
                    stop 'CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - ERR60'

                if(.not. WaterFluxes)then
                    write(*,*)
                    write(*,*) 'Property '//trim(PropertyX%ID%Name)//' has option WATER_FLUXES'
                    write(*,*) 'activated, but does not have option BOTTOM_FLUXES activated'
                    write(*,*) 'in the Water Properties file. Please review your options.'
                    write(*,*)
                    stop 'CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - ERR70'
                end if

                if(DTInterval /= PropertyX%Evolution%DTInterval)then
                    write(*,*)
                    write(*,*) ' Assumed time step for sediment-water interface '
                    write(*,*) ' property '//trim(PropertyX%ID%Name)
                    write(*,*) ' equal to the water property time step.'
                    write(*,*)
                    write(*,*) ' CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - WRN01'

                    PropertyX%Evolution%DTInterval  = DTInterval

                    PropertyX%Evolution%NextCompute = Me%ExternalVar%Now + PropertyX%Evolution%DTInterval

                end if

                if(PropertyX%Evolution%Deposition)then

                    if(.not. FreeVerticalMovement)then
                        write(*,*)
                        write(*,*)'Property : '//trim(PropertyX%ID%Name)//' must be defined'
                        write(*,*)'with option VERTICAL_MOVEMENT in WaterProperties file.'
                        stop 'CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - ERR80'
                    end if

                    if(.not. FreeVertPropertyExists(Me%ObjFreeVerticalMovement, PropertyX%ID%IDNumber))then
                        write(*,*)
                        write(*,*)'Property : '//trim(PropertyX%ID%Name)//' must be defined in'
                        write(*,*)'ModuleFreeVerticalMovement.'
                        stop 'CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - ERR90'
                    end if

                    if(.not. FreeVertPropertyHasDeposition(Me%ObjFreeVerticalMovement, PropertyX%ID%IDNumber))then
                        write(*,*)
                        write(*,*)'Property : '//trim(PropertyX%ID%Name)//' must be defined in'
                        write(*,*)'ModuleFreeVerticalMovement with DEPOSITION option activated.'
                        stop 'CheckOptionsWaterFluxes - ModuleInterfaceSedimentWater - ERR100'
                    end if

                end if

            endif

            PropertyX=>PropertyX%Next
        enddo

        Me%Coupled%WaterFluxes%NextCompute = Me%ExternalVar%Now

    end subroutine CheckOptionsWaterFluxes


    !--------------------------------------------------------------------------

#ifndef _SEDIMENT_
    subroutine CheckOptionsSedimentFluxes

        !External--------------------------------------------------------------
        integer                                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                          :: PropertyX
        real                                                :: DTInterval
        logical                                             :: SedimentFluxes
        !----------------------------------------------------------------------

        PropertyX => Me%FirstProperty
        do while (associated(PropertyX))
            if(PropertyX%Evolution%SedimentFluxes)then

                if(.not. SedimentPropertyExists(Me%ObjSedimentProperties, PropertyX%ID%IDNumber))then
                    write(*,*)
                    write(*,*)'Property : '//trim(PropertyX%ID%Name)
                    write(*,*)'must be defined as a sediment property.'
                    stop 'CheckOptionsSedimentFluxes - ModuleInterfaceSedimentWater - ERR10'
                end if

                call GetSedimentPropertyOptions(Me%ObjSedimentProperties,               &
                                                PropertyX%ID%IDNumber,                  &
                                                DTInterval,                             &
                                                SedimentFluxes,                         &
                                                STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)                                             &
                    stop 'CheckOptionsSedimentFluxes - ModuleInterfaceSedimentWater - ERR20'

                if(.not. SedimentFluxes)then
                    write(*,*)
                    write(*,*) 'Property '//trim(PropertyX%ID%Name)//' has option SEDIMENT_FLUXES'
                    write(*,*) 'activated, but does not have option SURFACE_FLUXES or            '
                    write(*,*) 'SEDIMENT_WATER_FLUXES activated in the Sediment Properties file.'
                    write(*,*) 'Please review your options.'
                    write(*,*)
                    stop 'CheckOptionsSedimentFluxes - ModuleInterfaceSedimentWater - ERR30'
                end if

                !if(DTInterval /= PropertyX%Evolution%DTInterval)then
                !    write(*,*)
                !    write(*,*) ' Property '//trim(PropertyX%ID%Name)//' must have the same'
                !    write(*,*) ' time step for sediment-water interface and the sediment column.'
                !    write(*,*)
                !    stop       'CheckOptionsSedimentFluxes - ModuleInterfaceSedimentWater - ERR40'
                !end if

                if(PropertyX%Mass_Min > 0.)then
                    write(*,*)
                    write(*,*) ' Property '//trim(PropertyX%ID%Name)//' must have MASS_MIN'
                    write(*,*) ' set to zero, as there are fluxes being computed from the'
                    write(*,*) ' sediment compartment.'
                    write(*,*)
                    stop       'CheckOptionsSedimentFluxes - ModuleInterfaceSedimentWater - ERR50'
                endif

            end if

            PropertyX=>PropertyX%Next

        enddo

        Me%Coupled%SedimentFluxes%NextCompute = Me%ExternalVar%Now

    end subroutine CheckOptionsSedimentFluxes

    !--------------------------------------------------------------------------

    subroutine CheckOptionsSedimentWaterFluxes

        !Local-----------------------------------------------------------------
        type (T_Property), pointer                          :: PropertyX
        integer                                             :: ILB, IUB, JLB, JUB
        integer                                             :: STAT_CALL

        !Begin-----------------------------------------------------------------

        ILB = Me%Size2D%ILB
        IUB = Me%Size2D%IUB
        JLB = Me%Size2D%JLB
        JUB = Me%Size2D%JUB


        PropertyX   => Me%FirstProperty
        do while (associated(PropertyX))

            if(PropertyX%Evolution%SedimentWaterFluxes)then

                if((.not. PropertyX%Evolution%SedimentFluxes) .or. &
                   (.not. PropertyX%Evolution%WaterFluxes)  )then

                    write(*,*)
                    write(*,*)'Property : '//trim(PropertyX%ID%Name)
                    write(*,*)'must have both WATER_FLUXES and SEDIMENT_FLUXES.'
                    stop 'CheckOptionsSedimentWaterFluxes - ModuleInterfaceSedimentWater - ERR10'

                end if

            end if

            PropertyX=>PropertyX%Next
        enddo


        Me%Coupled%SedimentWaterFluxes%NextCompute = Me%ExternalVar%Now

        call GetConsolidationOptions (Me%ObjConsolidation, Me%ExtSed%ComputeConsolidation, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'CheckOptionsSedimentWaterFluxes - ModuleInterfaceSedimentWater - ERR30'

        if(Me%ExtSed%ComputeConsolidation .and. .not. Me%Consolidation%Yes)then
            write(*,*)'Please activate option CONSOLIDATION'
            stop 'CheckOptionsSedimentWaterFluxes - ModuleInterfaceSedimentWater - ERR35'
        endif

        if(.not. Me%ExtSed%ComputeConsolidation .and. Me%Consolidation%Yes)then
            write(*,*)'CONSOLIDATION option is active and ModuleConsolidation is not.'
            stop 'CheckOptionsSedimentWaterFluxes - ModuleInterfaceSedimentWater - ERR36'
        endif

        allocate(Me%WaterFlux (ILB:IUB, JLB:JUB), STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_)&
            stop 'CheckOptionsSedimentWaterFluxes - ModuleInterfaceSedimentWater - ERR40'
        Me%WaterFlux(:,:) = 0.

    end subroutine CheckOptionsSedimentWaterFluxes
#endif

    !--------------------------------------------------------------------------


    subroutine Read_Old_Properties_2D(Scalar_2D, GroupName, PropertyName)

        !Arguments--------------------------------------------------------------
        real, dimension(:,:), pointer               :: Scalar_2D
        character (Len=*), Intent(IN)               :: GroupName
        character (Len=*), Intent(IN)               :: PropertyName

        !Local-----------------------------------------------------------------
        integer                                     :: IUB, JUB, ILB, JLB
        integer                                     :: STAT_CALL
        integer                                     :: HDF5_READ
        integer                                     :: ObjHDF5 = 0
        logical                                     :: exist
        integer                                     :: ILW, IUW, JLW, JUW
        type (T_Size2D)                             :: WindowLimitsJI
        real,    dimension(:,:), pointer            :: Aux2D
        logical                                     :: MasterOrSlave

        !----------------------------------------------------------------------

        ILB = Me%WorkSize2D%ILB
        JLB = Me%WorkSize2D%JLB
        IUB = Me%WorkSize2D%IUB
        JUB = Me%WorkSize2D%JUB

        ObjHDF5 = 0

        inquire(File = trim(Me%Files%Initial), Exist = exist)

        if(.not. exist)then
            write(*,*)
            write(*,*)     'Could not find the final InterfaceSedimentWater file.'
            write(*,'(A)') 'BoxFileName = ', trim(Me%Files%Initial)
            stop           'Read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR10'
        end if

        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_READ = HDF5_READ)

        !Opens HDF5 File
        call ConstructHDF5 (ObjHDF5, trim(Me%Files%Initial), HDF5_READ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR20'

        call GetDDecompParameters(HorizontalGridID = Me%ObjHorizontalGrid,          &
                                  MasterOrSlave    = MasterOrSlave,                 &
                                  STAT             = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR30'

ifMS:   if (MasterOrSlave) then

            call GetDDecompWorkSize2D(HorizontalGridID = Me%ObjHorizontalGrid,          &
                                      WorkSize         = WindowLimitsJI,                &
                                      STAT             = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR40'

            ILW = WindowLimitsJI%ILB
            IUW = WindowLimitsJI%IUB

            JLW = WindowLimitsJI%JLB
            JUW = WindowLimitsJI%JUB

        else ifMS

            ILW = ILB
            IUW = IUB

            JLW = JLB
            JUW = JUB

        endif ifMS

        !Reads from HDF file the Property concentration and open boundary values
        call HDF5SetLimits  (ObjHDF5, ILW, IUW, JLW, JUW, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR50'

        allocate(Aux2D(ILW:IUW, JLW:JUW))


           call HDF5ReadWindow (HDF5ID         = ObjHDF5,                               &
                            GroupName      = "/"//trim(GroupName)//"/"//                &
                                             trim(PropertyName),                        &
                                Name           = trim(PropertyName),                    &
                                Array2D        = Aux2D,                                 &
                                STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR60'


        Scalar_2D(ILB:IUB, JLB:JUB) = Aux2D(ILW:IUW, JLW:JUW)

        deallocate(Aux2D)

        call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'read_Old_Properties_2D - ModuleInterfaceSedimentWater - ERR70'

    end subroutine read_Old_Properties_2D


    !--------------------------------------------------------------------------


    subroutine Read_Property_2D(Property, ExtractType, BeginBlock, EndBlock, ClientNumber)

        !Arguments-------------------------------------------------------------
        type (T_Property_2D)                :: Property
        character(len=*)                    :: BeginBlock, EndBlock
        integer                             :: ExtractType
        integer, optional                   :: ClientNumber

        !Local-----------------------------------------------------------------
        integer                             :: STAT_CALL
        logical                             :: BlockFound
        integer                             :: LocalClientNumber

        !Begin-----------------------------------------------------------------

        select case(ExtractType)

            case(FromBlock)

                call ExtractBlockFromBuffer (Me%ObjEnterData, LocalClientNumber,    &
                                             BeginBlock, EndBlock,                  &
                                             BlockFound, STAT = STAT_CALL)
            case(FromBlockInBlock)

                call ExtractBlockFromBlock (Me%ObjEnterData, ClientNumber,          &
                                            BeginBlock, EndBlock,                   &
                                            BlockFound, STAT = STAT_CALL)
            case default

        end select


        if(present(ClientNumber)) LocalClientNumber = ClientNumber

        if (BlockFound) then

            !Allocates Variables
            allocate (Property%Field (Me%Size2D%ILB:Me%Size2D%IUB, Me%Size2D%JLB:Me%Size2D%JUB))

            Property%Field (:,:) = null_real

            call ConstructFillMatrix  (PropertyID           = Property%ID,                      &
                                       EnterDataID          = Me%ObjEnterData,                  &
                                       TimeID               = Me%ObjTime,                       &
                                       HorizontalGridID     = Me%ObjHorizontalGrid,             &
                                       ExtractType          = ExtractType,                      &
                                       PointsToFill2D       = Me%ExtWater%WaterPoints2D,        &
                                       Matrix2D             = Property%Field,                   &
                                       TypeZUV              = TypeZ_,                           &
                                       ClientID             = ClientNumber,                     &
                                       STAT                 = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR00'


            call GetDefaultValue(Property%ID%ObjFillMatrix, Property%Scalar, STAT = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR10'

            call GetIfMatrixRemainsConstant(FillMatrixID    = Property%ID%ObjFillMatrix,        &
                                            RemainsConstant = Property%Constant,                &
                                            STAT            = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR20'


            if(.not. Property%ID%SolutionFromFile)then
                call KillFillMatrix(Property%ID%ObjFillMatrix, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR30'
            end if

            if(ExtractType == FromBlock)then
                call Block_Unlock(Me%ObjEnterData, LocalClientNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR40'
            end if

        else

            write (*,*)'Block ',trim(BeginBlock),' ',trim(EndBlock),' not found'
            stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR60'

        endif


        select case(ExtractType)

            case(FromBlock)

                call RewindBuffer (Me%ObjEnterData, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR70'

            case(FromBlockInBlock)

                call RewindBlock  (Me%ObjEnterData, LocalClientNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'Read_Property_2D - ModuleInterfaceSedimentWater - ERR80'

            case default

        end select


    end subroutine Read_Property_2D


    !--------------------------------------------------------------------------


    subroutine SetSubModulesConstructor

        !External--------------------------------------------------------------
        integer                                         :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call SetHydrodynamicManning(HydrodynamicID = Me%ObjHydrodynamic,                &
                                    Manning        = Me%Manning,                        &
                                    STAT           = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_)                                                     &
            stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR10'

        call SetHydrodynamicChezy  (HydrodynamicID = Me%ObjHydrodynamic,                &
                                    Chezy          = Me%Chezy,                          &
                                    ChezyCoef      = Me%ChezyCoef,                      &
                                    STAT           = STAT_CALL)
        if (STAT_CALL  /= SUCCESS_)                                                     &
            stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR20'


        if(Me%Manning)then
            call SetHydrodynamicRugosityMatrix(HydrodynamicID = Me%ObjHydrodynamic,     &
                                               RugosityMatrix = Me%ManningCoef%Field,   &
                                               STAT           = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_)                                                 &
                stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR30'


        else
            call SetHydrodynamicRugosityMatrix(HydrodynamicID = Me%ObjHydrodynamic,     &
                                               RugosityMatrix = Me%Rugosity%Field,      &
                                               STAT           = STAT_CALL)
            if (STAT_CALL  /= SUCCESS_)                                                 &
                stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR40'

        end if

        call SetTurbulenceBottomRugosity(TurbulenceID   = Me%ObjTurbulence,             &
                                         BottomRugosity = Me%Rugosity%Scalar,           &
                                         STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR50'

        call SetWaveShearStress(Me%ObjHydrodynamic,                                  &
                               WaveShearStress = Me%WaveShear_Stress%Yes, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR60'

        call SetShearStressMethod (Me%ObjHydrodynamic,                                  &
                               ShearStressMethod = Me%Shear_Stress%Method, STAT = STAT_CALL)
        if  (STAT_CALL .ne. SUCCESS_)&
            stop 'SetSubModulesConstructor - ModuleInterfaceSedimentWater - ERR70'

    end subroutine SetSubModulesConstructor


    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SELECTOR SE

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !----------------------------------------------------------------------


    subroutine Search_Property(PropertyX, PropertyXID, STAT)

        !Arguments-------------------------------------------------------------
        type(T_Property),           pointer             :: PropertyX
        integer         ,           intent (IN)         :: PropertyXID
        integer         , optional, intent (OUT)        :: STAT

        !Local-----------------------------------------------------------------
        integer                                         :: STAT_

        !----------------------------------------------------------------------

        STAT_  = UNKNOWN_

        PropertyX => Me%FirstProperty

        do while (associated(PropertyX))
            if (PropertyX%ID%IDNumber==PropertyXID) then
                exit
            else
                PropertyX => PropertyX%Next
            end if
        end do

       if (associated(PropertyX)) then

            STAT_ = SUCCESS_

        else
            STAT_  = NOT_FOUND_ERR_
        end if

        if (present(STAT)) STAT = STAT_

    end subroutine Search_Property




    !--------------------------------------------------------------------------


    subroutine ReadLockExternalGlobal

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        !Now
        call GetComputeCurrentTime(Me%ObjTime, Me%ExternalVar%Now, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalGlobal - ModuleInterfaceSedimentWater - ERR01'

        !XX_IE and YY_IE
        call GetHorizontalGrid (Me%ObjHorizontalGrid,                                   &
                                XX_IE = Me%ExternalVar%XX_IE,                           &
                                YY_IE = Me%ExternalVar%YY_IE,                           &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalGlobal - ModuleInterfaceSedimentWater - ERR02'

        call GetGridCellArea (Me%ObjHorizontalGrid, Me%ExternalVar%GridCellArea, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalGlobal - ModuleInterfaceSedimentWater - ERR03'

    end subroutine ReadLockExternalGlobal


    !--------------------------------------------------------------------------


    subroutine ReadLockExternalWater

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        !WaterPoints2D
        call GetWaterPoints2D(Me%ObjWaterHorizontalMap, Me%ExtWater%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR01'

        !OpenPoints2D
        call GetOpenPoints2D(Me%ObjWaterHorizontalMap, Me%ExtWater%OpenPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR02'

        !WaterPoints3D
        call GetWaterPoints3D(Me%ObjWaterMap, Me%ExtWater%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR03'

        !OpenPoints3D
        call GetOpenPoints3D(Me%ObjWaterMap, Me%ExtWater%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR04'

        !BoundaryPoints2D
        call GetBoundaries(Me%ObjWaterHorizontalMap, Me%ExtWater%BoundaryPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR05'

        !LandPoints3D
        call GetLandPoints3D(Me%ObjWaterMap, Me%ExtWater%LandPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR06'

        !SZZ
        call GetGeometryDistances (Me%ObjWaterGeometry, SZZ = Me%ExtWater%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR08'


        call GetGeometryVolumes(Me%ObjWaterGeometry,                        &
                                VolumeZ    = Me%ExtWater%VolumeZ,           &
                                VolumeZOld = Me%ExtWater%VolumeZOld,        &
                                STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR09'

        call GetGeometryDistances (Me%ObjWaterGeometry, DWZ = Me%ExtWater%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR10'


        call GetChezy(HydrodynamicID = Me%ObjHydrodynamic,                  &
                      Chezy          = Me%ExtWater%Chezy,                   &
                      STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR12'

        call GetHorizontalVelocity(HydrodynamicID = Me%ObjHydrodynamic,     &
                                   Velocity_U     = Me%ExtWater%Velocity_U, &
                                   Velocity_V     = Me%ExtWater%Velocity_V, &
                                   STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR13'

        call GetGridData(Me%ObjWaterGridData, Me%ExtWater%Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleWaterProperties - ERR14'

        call GetGeometryWaterColumn(Me%ObjWaterGeometry,                    &
                                    WaterColumn = Me%ExtWater%WaterColumn,  &
                                    STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleWaterProperties - ERR15'

        call GetGeometryMinWaterColumn(Me%ObjWaterGeometry,                          &
                                       MinWaterColumn = Me%ExtWater%MinWaterColumn,  &
                                       STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleWaterProperties - ERR15a'

        call GetGeometryKFloor(Me%ObjWaterGeometry, Z = Me%ExtWater%KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleWaterProperties - ERR16'

#ifndef _WAVES_
        if (Me%ObjWaves /=0) then

            call GetWaves (WavesID       = Me%ObjWaves,                                  &
                           WavePeriod    = Me%ExtWater%WavePeriod,                       &
                           WaveHeight    = Me%ExtWater%WaveHeight,                       &
                           WaveDirection = Me%ExtWater%WaveDirection,                    &
                           Abw           = Me%ExtWater%Abw,                              &
                           Ubw           = Me%ExtWater%Ubw,                              &
                           LastCompute   = Me%ExtWater%LastComputeWave,                  &
                           STAT          = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalVar - ModuleInterfaceSedimentWater - ERR17'

        endif
#endif

        call GetResidualVelocityON(HydrodynamicID = Me%ObjHydrodynamic,                 &
                                   ResidualON     = Me%ExtWater%ResidualON,             &
                                   STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR200'

        if (Me%ExtWater%ResidualON) then

            call GetResidualHorizontalVelocity(HydrodynamicID     = Me%ObjHydrodynamic,             &
                                               VelocityResidual_U = Me%ExtWater%VelocityResidual_U, &
                                               VelocityResidual_V = Me%ExtWater%VelocityResidual_V, &
                                               STAT               = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadLockExternalWater - ModuleInterfaceSedimentWater - ERR210'

        endif

    end subroutine ReadLockExternalWater


    !--------------------------------------------------------------------------
#ifndef _SEDIMENT_
    subroutine ReadLockExternalSediment

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        !WaterPoints2D
        call GetWaterPoints2D(Me%ObjSedimentHorizontalMap, Me%ExtSed%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR01'

        !OpenPoints2D
        call GetOpenPoints2D(Me%ObjSedimentHorizontalMap, Me%ExtSed%OpenPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR02'

        !WaterPoints3D
        call GetWaterPoints3D(Me%ObjSedimentMap, Me%ExtSed%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR03'

        !OpenPoints3D
        call GetOpenPoints3D(Me%ObjSedimentMap, Me%ExtSed%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR04'


        !BoundaryPoints2D
        call GetBoundaries(Me%ObjSedimentHorizontalMap, Me%ExtSed%BoundaryPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR05'


        !SZZ
        call GetGeometryDistances (Me%ObjSedimentGeometry, SZZ = Me%ExtSed%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR07'

        !DWZ
        call GetGeometryDistances (Me%ObjSedimentGeometry, DWZ = Me%ExtSed%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR08'

        !Volumes
        call GetGeometryVolumes(Me%ObjSedimentGeometry,                             &
                                VolumeZ     = Me%ExtSed%VolumeZ,                    &
                                VolumeZOld  = Me%ExtSed%VolumeZOld,                 &
                                STAT        = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR09'

        !LandPoints3D
        call GetLandPoints3D(Me%ObjSedimentMap, Me%ExtSed%LandPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR10'

        call GetGeometryKTop(Me%ObjSedimentGeometry,                                    &
                             KTopZ  = Me%ExtSed%KTop,                                   &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)                                                      &
            stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR15'

        if(Me%RunsSediments)then

            !WaterFluxes
            call GetConsolidationWaterFluxes(Me%ObjConsolidation,                       &
                                             WaterFluxZ = Me%ExtSed%WaterFluxZ,         &
                                             STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR11'

            !TopCriticalShear
            call GetConsolidationCriticalShear(Me%ObjConsolidation,                     &
                                               TopCriticalShear = Me%ExtSed%TopCriticalShear,&
                                               STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                  &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR12'


            call GetConsolidationDrySedVolume(Me%ObjConsolidation,                          &
                                              DrySedimentVolume = Me%ExtSed%DrySedVolume,   &
                                              STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR13'


            call GetSedimentDryDensity(Me%ObjSedimentProperties,                            &
                                       SedimentDryDensity = Me%ExtSed%SedimentDryDensity,   &
                                       STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR14'

            call GetConsolidationPorosity(Me%ObjConsolidation,                              &
                                          Porosity = Me%ExtSed%Porosity,                    &
                                          STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR16'

            call GetSedimentColumnFull(Me%ObjConsolidation,                                 &
                                       SedimentColumnFull = Me%ExtSed%SedimentColumnFull,   &
                                       STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR17'
        endif

         if(Me%RunSedimentModule)then

            !TopCriticalShear
            call GetTopCriticalShear(Me%ObjSediment,                                         &
                                               TopCriticalShear = Me%ExtSed%TopCriticalShear,&
                                               STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                       &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR18'


            call GetCohesiveMass(Me%ObjSediment,                                            &
                                          CohesiveMass = Me%ExtSed%CohesiveMass,            &
                                          STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR20'

            call GetCohesiveContent(Me%ObjSediment,                                         &
                                          CohesiveClassRun = Me%ExtSed%CohesiveClassRun,    &
                                          CohesiveContent = Me%ExtSed%CohesiveContent,      &
                                          STAT       = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)                                                      &
                stop 'ReadLockExternalSediment - ModuleInterfaceSedimentWater - ERR30'

        endif

    end subroutine ReadLockExternalSediment

#endif
    !----------------------------------------------------------------------


    subroutine ReadUnlockExternalGlobal

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%ExternalVar%XX_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalGlobal - ModuleInterfaceSedimentWater - ERR01'

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%ExternalVar%YY_IE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalGlobal - ModuleInterfaceSedimentWater - ERR03'

        call UnGetHorizontalGrid(Me%ObjHorizontalGrid, Me%ExternalVar%GridCellArea, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalGlobal - ModuleInterfaceSedimentWater - ERR03'


        call null_time(Me%ExternalVar%Now)

    end subroutine ReadUnlockExternalGlobal


    !----------------------------------------------------------------------


    subroutine ReadUnlockExternalWater

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call UnGetHorizontalMap(Me%ObjWaterHorizontalMap, Me%ExtWater%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR01'

        call UnGetHorizontalMap(Me%ObjWaterHorizontalMap, Me%ExtWater%OpenPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR02'

        call UngetHorizontalMap (Me%ObjWaterHorizontalMap, Me%ExtWater%BoundaryPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR03'

        call UnGetMap(Me%ObjWaterMap, Me%ExtWater%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR04'

        call UnGetMap(Me%ObjWaterMap, Me%ExtWater%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR05'

        call UnGetMap(Me%ObjWaterMap, Me%ExtWater%LandPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR06'

        call UnGetGeometry(Me%ObjWaterGeometry,Me%ExtWater%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR07'

        call UnGetGeometry(Me%ObjWaterGeometry,Me%ExtWater%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR08'

        call UnGetGeometry(Me%ObjWaterGeometry, Me%ExtWater%VolumeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR09'

        call UnGetGeometry(Me%ObjWaterGeometry, Me%ExtWater%VolumeZOld, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR10'

        call UnGetHydrodynamic(Me%ObjHydrodynamic, Me%ExtWater%Chezy, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR12'

        call UnGetHydrodynamic(Me%ObjHydrodynamic, Me%ExtWater%Velocity_U, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR13'

        call UnGetHydrodynamic(Me%ObjHydrodynamic, Me%ExtWater%Velocity_V, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR14'

        call UnGetGridData(Me%ObjWaterGridData, Me%ExtWater%Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR15'

        call UnGetGeometry(Me%ObjWaterGeometry, Me%ExtWater%WaterColumn, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR16'

        call UnGetGeometry(Me%ObjWaterGeometry, Me%ExtWater%KFloor_Z, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR17'


#ifndef _WAVES_
        if (Me%ObjWaves /=0) then

            call UnGetWaves(Me%ObjWaves, Me%ExtWater%WavePeriod, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR18'

            call UnGetWaves(Me%ObjWaves, Me%ExtWater%WaveHeight, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR19'

            call UnGetWaves(Me%ObjWaves, Me%ExtWater%Abw, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR20'

            call UnGetWaves(Me%ObjWaves, Me%ExtWater%Ubw, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR21'

            call UnGetWaves(Me%ObjWaves, Me%ExtWater%WaveDirection, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR22'

        endif
#endif

        if (Me%ExtWater%ResidualON) then

            call UnGetHydrodynamic(Me%ObjHydrodynamic, Me%ExtWater%VelocityResidual_U, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR130'

            call UnGetHydrodynamic(Me%ObjHydrodynamic, Me%ExtWater%VelocityResidual_V, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ReadUnlockExternalWater - ModuleInterfaceSedimentWater - ERR140'

        endif

    end subroutine ReadUnlockExternalWater


    !----------------------------------------------------------------------

#ifndef _SEDIMENT_
    subroutine ReadUnlockExternalSediment

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call UnGetHorizontalMap(Me%ObjSedimentHorizontalMap, Me%ExtSed%WaterPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR01'

        call UnGetHorizontalMap(Me%ObjSedimentHorizontalMap, Me%ExtSed%OpenPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR02'

        call UnGetMap(Me%ObjSedimentMap, Me%ExtSed%OpenPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR03'

        call UnGetMap(Me%ObjSedimentMap, Me%ExtSed%WaterPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR04'

        call UnGetMap(Me%ObjSedimentMap, Me%ExtSed%LandPoints3D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR05'

        call UnGetGeometry(Me%ObjSedimentGeometry,Me%ExtSed%DWZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR06'

        call UnGetGeometry(Me%ObjSedimentGeometry,Me%ExtSed%SZZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR07'

        call UnGetGeometry(Me%ObjSedimentGeometry, Me%ExtSed%VolumeZ, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR15'

        call UnGetGeometry(Me%ObjSedimentGeometry, Me%ExtSed%VolumeZOld, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR16'

        call UngetHorizontalMap (Me%ObjSedimentHorizontalMap, Me%ExtSed%BoundaryPoints2D, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR17'

        call UnGetGeometry(Me%ObjSedimentGeometry, Me%ExtSed%KTop, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR20'

        if(Me%RunsSediments)then

            call UngetConsolidation(Me%ObjConsolidation, Me%ExtSed%WaterFluxZ, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR13'

            call UngetConsolidation(Me%ObjConsolidation, Me%ExtSed%TopCriticalShear, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR14'

            call UngetConsolidation(Me%ObjConsolidation, Me%ExtSed%DrySedVolume, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR18'

            call UngetSedimentProperties(Me%ObjConsolidation, Me%ExtSed%SedimentDryDensity, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR19'

            call UngetConsolidation(Me%ObjConsolidation, Me%ExtSed%Porosity, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR21'

            call UngetConsolidation(Me%ObjConsolidation, Me%ExtSed%SedimentColumnFull, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR22'

        endif

        if(Me%RunSedimentModule)then

            call UngetSediment(Me%ObjSediment, Me%ExtSed%TopCriticalShear, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR23'

            call UngetSediment(Me%ObjSediment, Me%ExtSed%CohesiveMass, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR24'

            call UngetSediment(Me%ObjSediment, Me%ExtSed%CohesiveContent, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ReadUnlockExternalSediment - ModuleInterfaceSedimentWater - ERR25'
        endif


    end subroutine ReadUnlockExternalSediment

#endif
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODIFIER MODI

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    subroutine ModifyInterfaceSedimentWater(ObjInterfaceSedimentWaterID, LagrangianID, STAT)

        !Arguments-------------------------------------------------------------
        integer                                     :: ObjInterfaceSedimentWaterID, LagrangianID
        integer, intent(OUT), optional              :: STAT

        !Local-----------------------------------------------------------------
        integer                                     :: STAT_, ready_

        !----------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(ObjInterfaceSedimentWaterID, ready_)

        if (ready_ .EQ. IDLE_ERR_) then

            if(Me%ObjLagrangian == 0 .and. LagrangianID /= 0)then
                Me%ObjLagrangian  = AssociateInstance(mLAGRANGIAN_, LagrangianID)
            endif

            if (MonitorPerformance)                 &
                call StartWatch ("ModuleInterfaceSedimentWater", "ModifyInterfaceSedimentWater")

            call ReadLockExternalGlobal

            call ReadLockExternalWater

#ifndef _SEDIMENT_
            if(Me%RunsSediments.or.Me%RunSedimentModule) call ReadLockExternalSediment
#endif

            call TimeStepActualization

            call ModifyShearStress

            if(Me%Coupled%SedimentFluxes%Yes)       &
                call ModifySedimentColumnFluxes

            if(Me%Coupled%WaterFluxes%Yes)          &
                call ModifyWaterColumnFluxes

            if(Me%Coupled%Detritus%Yes)             &
                call Detritus_Processes

            if(Me%Coupled%Benthos%Yes)              &
                call Benthos_Processes

            if(Me%Coupled%BenthicEcology%Yes)       &
                call BenthicEcology_Processes

            if(Me%Coupled%CEQUALW2%Yes)             &
                call CEQUALW2_Processes

            if(Me%Coupled%SedimentWaterFluxes%Yes)  &
                call ModifySedimentWaterFluxes

            if (Me%RunsSandTransport)               &
                call ModifySandTransport

            if(Me%Coupled%TimeSerie%Yes)            &
                call Output_TimeSeries

            if(Me%Coupled%BoxTimeSerie%Yes)         &
                call Output_BoxTimeSeries

            if(Me%Coupled%OutputHDF%Yes)            &
                call OutPut_Results_HDF

            if(Me%Output%WriteRestartFile)          &
                call OutputRestartFile

            call Actualize_Time_Evolution

            if(Me%ComputeRugosity)                  &
                call ModifyRugosity

            if (Me%RunSedimentModule)               &
                call ComputeEfficiencyFactor

#ifndef _SEDIMENT_
            if(Me%RunsSediments.or.Me%RunSedimentModule) call ReadUnlockExternalSediment
#endif
            call ReadUnlockExternalWater

            call ReadUnlockExternalGlobal

            call SetSubModulesModifier

            if (Me%RunSedimentModule) &
                call ModifySedimentTransport

            if (MonitorPerformance)                 &
                call StopWatch ("ModuleInterfaceSedimentWater", "ModifyInterfaceSedimentWater")



            STAT_ = SUCCESS_
        else
            STAT_ = ready_
        end if

        if (present(STAT)) STAT = STAT_

    end subroutine ModifyInterfaceSedimentWater


    !--------------------------------------------------------------------------

    subroutine TimeStepActualization

        !Local-----------------------------------------------------------------
        type (T_Property), pointer       :: Property
        real                             :: NewDT
        integer                          :: STAT_CALL
        logical                          :: VariableDT

        !Begin-----------------------------------------------------------------


        call GetVariableDT (Me%ObjTime, VariableDT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) &
            stop 'TimeStepActualization - ModuleInterfaceSedimentWater - ERR01'

cd1:    if (VariableDT) then

            call GetComputeTimeStep(Me%ObjTime, NewDT, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'TimeStepActualization - ModuleInterfaceSedimentWater - ERR02'

            Property => Me%FirstProperty

do1 :       do while (associated(Property))

                Property%Evolution%DTInterval = NewDT

                Property => Property%Next

            enddo do1

            nullify(Property)

        endif cd1


    end subroutine TimeStepActualization

    !------------------------------------------------------------------------


    subroutine ModifyShearStress

        !Local-----------------------------------------------------------------
        real,    pointer, dimension(:, :, :)    :: Velocity_U, Velocity_V
        real,    pointer, dimension(:, :, :)    :: VelRes_U, VelRes_V
        real,    pointer, dimension(:, :   )    :: Chezy
        integer, pointer, dimension(:, :, :)    :: LandPoints3D, OpenPoints3D
        integer, pointer, dimension(:, :   )    :: KFloorZ
        real                                    :: VC,UC, UVC2,UVC, WaterDensity
        integer                                 :: IUB, JUB, ILB, JLB, KUB,KLB
        integer                                 :: i, j, kbottom
        integer                                 :: CHUNK
        real                                    :: CWphi,Cphi,Wphi
        real                                    :: TAUM,TAUMAX
        real                                    :: CDM,CDMAX, Z0
        real                                    :: DWZ, Abw, Ubw, FW

        !Begin-----------------------------------------------------------------

        !A if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ModifyShearStress")


        if (Me%Shear_Stress%LastCompute .LT. Me%ExternalVar%Now) then

            Me%Shear_Stress%DT = Me%ExternalVar%Now - Me%Shear_Stress%LastCompute

            IUB = Me%WaterWorkSize3D%IUB
            JUB = Me%WaterWorkSize3D%JUB
            ILB = Me%WaterWorkSize3D%ILB
            JLB = Me%WaterWorkSize3D%JLB
            KUB = Me%WaterWorkSize3D%KUB
            KLB = Me%WaterWorkSize3D%KLB

            Velocity_U      => Me%ExtWater%Velocity_U
            Velocity_V      => Me%ExtWater%Velocity_V
            VelRes_U        => Me%ExtWater%VelocityResidual_U
            VelRes_V        => Me%ExtWater%VelocityResidual_V
            Chezy           => Me%ExtWater%Chezy
            WaterDensity    =  SigmaDensityReference
            LandPoints3D    => Me%ExtWater%LandPoints3D
            OpenPoints3D    => Me%ExtWater%OpenPoints3D
            KFloorZ         => Me%ExtWater%KFloor_Z

            Me%Shear_Stress%Tension (:,:) = 0.
            Me%Shear_Stress%Velocity(:,:) = 0.

            if (Me%Shear_Stress%Method==1) then

                if (Me%WaveShear_Stress%Yes) then

                    if (Me%ExtWater%LastComputeWave > Me%WaveShear_Stress%LastCompute) then


                        if (.not. Me%WaveShear_Stress%Rugosity%Constant) then
                            call ComputeWaveRugosity
                        endif
                        call ComputeWaveTension

                        Me%WaveShear_Stress%LastCompute = Me%ExternalVar%Now

                    endif

                end if

                if (MonitorPerformance) then
                    call StartWatch ("ModuleInterfaceSedimentWater", "ModifyShearStress_Method1")
                endif

                CHUNK = CHUNK_J(JLB, JUB)

                !$OMP PARALLEL PRIVATE(i,j,kbottom,VC,UC,UVC2)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                ! Se alisa cantos com terra. Aumenta artificialmente a tens?o de corte
                ! nos cantos com terra para evitar que estes se tornem em zonas
                ! de deposi??o acentuada
                do j = JLB, JUB
                do i = ILB, IUB

                    if (Me%ExtWater%OpenPoints3D(i, j, KUB) == OpenPoint) then

                        kbottom = KFloorZ(i, j)

                        if (((LandPoints3D(i,  j+1, kbottom)==1 .or. LandPoints3D(i,  j-1, kbottom)==1) .and.   &
                             (LandPoints3D(i+1,j,   kbottom)==1 .or. LandPoints3D(i-1,j,   kbottom)==1))) then

                            !VC = max(abs(Velocity_V(i+1,j,kbottom)),abs(Velocity_V(i,j,  kbottom)))
                            !UC = max(abs(Velocity_U(i,  j,kbottom)),abs(Velocity_U(i,j+1,kbottom)))

                            if (abs(Velocity_V(i+1,j,kbottom)) > abs(Velocity_V(i,j,  kbottom))) then
                                VC = Velocity_V(i+1,j,kbottom)
                            else
                                VC = Velocity_V(i,j,kbottom)
                            endif

                            if (abs(Velocity_U(i,j+1,kbottom)) > abs(Velocity_U(i,j,  kbottom))) then
                                UC = Velocity_U(i,j+1,kbottom)
                            else
                                UC = Velocity_U(i,j,kbottom)
                            endif

                        else

                            VC = (Velocity_V(i+1,j,kbottom)+Velocity_V(i,j,  kbottom))/2.
                            UC = (Velocity_U(i,  j,kbottom)+Velocity_U(i,j+1,kbottom))/2.

                        endif

                        UVC2 = UC*UC+VC*VC
                        UVC  = sqrt(UVC2)

                        Me%Shear_Stress%Tension (i,j) = Chezy(i,j) * UVC2 * WaterDensity

                        if (UVC > 0) then
                            Me%Shear_Stress%Tension_X (i,j) = Me%Shear_Stress%Tension(i,j) * UC / UVC
                            Me%Shear_Stress%Tension_Y (i,j) = Me%Shear_Stress%Tension(i,j) * VC / UVC
                        else
                            Me%Shear_Stress%Tension_X (i,j) = 0
                            Me%Shear_Stress%Tension_Y (i,j) = 0
                        endif

                        if (Me%RunSedimentModule.or.Me%RunsSandTransport) then

                            Me%Shear_Stress%CurrentVel(i, j) = sqrt(UVC2)
                            Me%Shear_Stress%CurrentU  (i, j) = UC
                            Me%Shear_Stress%CurrentV  (i, j) = VC
                            Me%Shear_Stress%UFace     (i, j) = Velocity_U(i,j,kbottom)
                            Me%Shear_Stress%VFace     (i, j) = Velocity_V(i,j,kbottom)

                        endif

                        if (Me%RunsSandTransport) then
                            if (Me%ExtWater%ResidualON) then

                                Me%Shear_Stress%CurrentResidualU(i, j) = (VelRes_U(i,  j,kbottom)+VelRes_U(i,j+1,kbottom))/2.
                                Me%Shear_Stress%CurrentResidualV(i, j) = (VelRes_V(i+1,j,kbottom)+VelRes_V(i,j,  kbottom))/2.

                            else

                                if (associated(Me%Shear_Stress%CurrentResidualU)) then
                                    deallocate(Me%Shear_Stress%CurrentResidualU)
                                    nullify   (Me%Shear_Stress%CurrentResidualU)
                                endif

                                if (associated(Me%Shear_Stress%CurrentResidualV)) then
                                    deallocate(Me%Shear_Stress%CurrentResidualV)
                                    nullify   (Me%Shear_Stress%CurrentResidualV)
                                endif

                            endif
                        endif

                        if (Me%WaveShear_Stress%Yes) then

                            !if (Me%WaveShear_Stress%NonLinear) then

                            !    Me%WaveShear_Stress%Tension (i,j) = Me%WaveShear_Stress%ChezyVel   (i,j) * &
                            !                                        sqrt(UVC2) * WaterDensity


                            !else

                                Me%WaveShear_Stress%Tension (i,j) = Me%WaveShear_Stress%ChezyVel   (i,j) * &
                                                                    Me%ExtWater%Ubw (i,j) * WaterDensity
                            !endif

                            !Currents contribution
                            if (Me%RunsSandTransport) then
                                Me%WaveShear_Stress%TensionCurrents(i, j) = Me%Shear_Stress%Tension (i,j)
                            endif

                            !Wave contribution
                            Me%Shear_Stress%Tension(i, j) = Me%Shear_Stress%Tension (i,j) + Me%WaveShear_Stress%Tension(i, j)

                        endif

                        if (Me%Shear_Stress%IntertidalRunOff) then

                            if (Me%ExtWater%WaterColumn(i,j) < 2. * Me%ExtWater%MinWaterColumn) then

                                Me%Shear_Stress%Tension(i, j) = Me%Shear_Stress%Tension (i,j) + 1.

                            endif

                        endif

                        ! [m/s]                       = [N/m^2/ (kg/m^3)]^0.5 =
                        Me%Shear_Stress%Velocity(i,j) = sqrt(Me%Shear_Stress%Tension (i,j) / WaterDensity)

                    endif

                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

                if (MonitorPerformance) then
                    call StopWatch ("ModuleInterfaceSedimentWater", "ModifyShearStress_Method1")
                endif

            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            elseif (Me%Shear_Stress%Method==2) then !GFranz

                if (MonitorPerformance) then
                    call StartWatch ("ModuleInterfaceSedimentWater", "ModifyShearStress_Method2")
                endif

                if (Me%WaveShear_Stress%Yes) then
                    Me%WaveShear_Stress%CWphi(:,:) = 0.
                endif

do1:            do j = JLB, JUB
do2:            do i = ILB, IUB

                    if (Me%ExtWater%OpenPoints3D(i, j,KUB) == OpenPoint) then

                        !TAUM is used for determining the friction governing the current
                        TAUM=0.
                        !TAUMAX is used to determine the threshold of sediment motion
                        TAUMAX=0.

                        kbottom = KFloorZ(i, j)

                        DWZ = Me%ExtWater%DWZ(i,j,kbottom)

                        VC = (Velocity_V(i+1,j,kbottom)+Velocity_V(i,j,  kbottom))/2.
                        UC = (Velocity_U(i,  j,kbottom)+Velocity_U(i,j+1,kbottom))/2.

                        UVC2 = UC*UC+VC*VC

                        UVC = sqrt(UVC2)

                        if (Me%RunSedimentModule.or.Me%RunsSandTransport) then

                            Me%Shear_Stress%CurrentVel(i, j) = sqrt(UVC2)
                            Me%Shear_Stress%CurrentU  (i, j) = UC
                            Me%Shear_Stress%CurrentV  (i, j) = VC
                            Me%Shear_Stress%UFace     (i, j) = Velocity_U(i,j,kbottom)
                            Me%Shear_Stress%VFace     (i, j) = Velocity_V(i,j,kbottom)

                        endif

                        Z0 = Me%Rugosity%Field(i,j)

                        if (Me%WaveShear_Stress%Yes) then

                            Ubw = Me%ExtWater%Ubw(i,j)
                            Abw = Me%ExtWater%Abw(i,j)

                            if (Ubw.gt.1e-3) then

                                !Current angle in cartesian convention (angle between the vector and positive x-axis)
                                Cphi = atan2(VC, UC) * 180./pi
                                !(0, 360)
                                If(Cphi < 0.) Cphi = Cphi + 360
                                Me%WaveShear_Stress%Cphi(i,j) = Cphi !Current angle
                                Wphi = Me%ExtWater%WaveDirection(i,j)
                                !CWphi = Cphi - Wphi !Current-wave angle
                                CWphi = Wphi - Cphi !Wave - Current angle
                                Me%WaveShear_Stress%CWphi(i,j) = CWphi

                                !Compute drag coefficient
                                call Compute_DragCoef(DWZ, Z0, UVC, CDMAX, CDM, FW, CWphi, Ubw, Abw)

                                if(UVC < 1e-3)then !wave-only flow
                                    TAUM=0.
                                    TAUMAX=0.5*WaterDensity*FW*Ubw**2

                                    Me%WaveShear_Stress%Tension(i,j) = TAUMAX

                                else if(UVC.gt.1e-3)then !combined wave and current flow
                                    TAUM=WaterDensity*CDM*UVC**2
                                    TAUMAX=WaterDensity*CDMAX*UVC**2

                                    Me%WaveShear_Stress%Tension(i,j) = 0.5*WaterDensity*FW*Ubw**2
                                endif

                                Me%WaveShear_Stress%TensionMean(i,j) = TAUM
                            else !Ubw==0.
                                call Compute_DragCoef(DWZ, Z0, UVC, CDMAX, CDM, FW)
                                TAUMAX=WaterDensity*CDMAX*UVC**2

                                Me%WaveShear_Stress%TensionMean(i,j) = TAUMAX
                                Me%WaveShear_Stress%Tension(i,j) = 0.
                            endif
                        else
                            call Compute_DragCoef(DWZ, Z0, UVC, CDMAX, CDM, FW)

                            TAUMAX=WaterDensity*CDMAX*UVC**2
                        endif

                    Me%Shear_Stress%Tension(i,j) = TAUMAX

                    !Limit shear stress values in small depths
                    if(Me%Shear_Stress%Limitation) then

                        Me%Shear_Stress%Tension(i,j) = ShearStressLimitation(Me%ExtWater%WaterColumn(i,j),&
                                                        Me%Shear_Stress%Tension(i,j))

                        if (Me%WaveShear_Stress%Yes) then

                           Me%WaveShear_Stress%Tension(i,j) = ShearStressLimitation(Me%ExtWater%WaterColumn(i,j),&
                                                             Me%WaveShear_Stress%Tension(i,j))

                           Me%WaveShear_Stress%TensionMean(i,j) = ShearStressLimitation(Me%ExtWater%WaterColumn(i,j),&
                                                                 Me%WaveShear_Stress%TensionMean(i,j))

                        endif
                    end if

                    Me%Shear_Stress%Velocity(i,j) = sqrt(Me%Shear_Stress%Tension(i,j)/ WaterDensity)

                    if (UVC > 0) then
                        Me%Shear_Stress%Tension_X (i,j) = Me%Shear_Stress%Tension(i,j) * UC / UVC
                        Me%Shear_Stress%Tension_Y (i,j) = Me%Shear_Stress%Tension(i,j) * VC / UVC
                    else
                        Me%Shear_Stress%Tension_X (i,j) = 0
                        Me%Shear_Stress%Tension_Y (i,j) = 0
                    endif

                endif

                enddo do2
                enddo do1

                if (MonitorPerformance) then
                    call StopWatch ("ModuleInterfaceSedimentWater", "ModifyShearStress_Method2")
                endif

            endif !Method==2

            if (Me%Shear_Stress%Statistics%ON) then

                call OutPut_Statistics (Me%Shear_Stress%Velocity, Me%Shear_Stress%Statistics%ID)

            endif

            if (Me%Shear_Stress%OutputON .and. Me%ExtWater%ResidualON) then
                call ComputeShearStressResidual
            endif

            Me%Shear_Stress%LastCompute = Me%ExternalVar%Now


        endif

        !A if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ModifyShearStress")


    end subroutine ModifyShearStress

    !--------------------------------------------------------------------------

    subroutine ComputeShearStressResidual

        !Local-----------------------------------------------------------------
        real                                    :: DT_Old, DT_New
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------


        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB
        KUB = Me%WaterWorkSize3D%KUB

        DT_New   = Me%Shear_Stress%DT
        DT_Old   = Me%Shear_Stress%Residual_Period



        if (MonitorPerformance) then
            call StartWatch ("ModuleInterfaceSedimentWater", "ComputeShearStressResidual")
        endif

        CHUNK = CHUNK_J(JLB, JUB)

        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        ! Se alisa cantos com terra. Aumenta artificialmente a tens?o de corte
        ! nos cantos com terra para evitar que estes se tornem em zonas
        ! de deposi??o acentuada
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExtWater%OpenPoints3D(i, j, KUB) == OpenPoint) then

                Me%Shear_Stress%Residual_Tau_X(i, j) = (DT_Old * Me%Shear_Stress%Residual_Tau_X(i,j) + &
                                                        DT_New * Me%Shear_Stress%Tension_X(i,j)) / (DT_Old + DT_New)

                Me%Shear_Stress%Residual_Tau_Y(i, j) = (DT_Old * Me%Shear_Stress%Residual_Tau_Y(i,j) + &
                                                        DT_New * Me%Shear_Stress%Tension_Y(i,j)) / (DT_Old + DT_New)

                Me%Shear_Stress%Residual_Tau  (i, j) = sqrt(Me%Shear_Stress%Residual_Tau_X(i, j)**2. +   &
                                                            Me%Shear_Stress%Residual_Tau_Y(i, j)**2.)

            endif

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleInterfaceSedimentWater", "ComputeShearStressResidual")
        endif

        Me%Shear_Stress%Residual_Period = DT_Old + DT_New

    end subroutine ComputeShearStressResidual

    !--------------------------------------------------------------------------

    subroutine Compute_DragCoef (DWZ, Z0, UVC, CDMAX, CDM, FW, CWphi, Ubw, Abw)

        !Arguments-----------------------------------------------------------------
        real                                    :: DWZ, Z0, UVC
        real, intent(IN), optional              :: Ubw, Abw, CWphi
        real, intent(OUT)                       :: CDMAX, CDM, FW
        !Local---------------------------------------------------------------------
        real    ::  REC, REW, FWS, FWR, as, ar, T1, T2, T3, A1, A2
        real    ::  CDS, CDR, CDMS, CDMAXS, CDMR, CDMAXR

        !Begin----------------------------------------------------------------

        if (DWZ < Z0*Exp(1.001)) DWZ = Z0*Exp(1.001)

        CDR = 0.
        if(Z0 > 0.) CDR=(0.40/(log(DWZ/Z0)-1.))**2

        REC=UVC*DWZ/WaterCinematicVisc
        CDS = 0.
        if(UVC > 1e-3) CDS=0.0001615*EXP(6.*REC**(-0.08))

        CDMAX = MAX(CDR,CDS)
        CDM = CDMAX
        FW = 0.

        if (present(Ubw)) then

            if (Ubw.gt.1e-3)then

                    REW=Ubw*Abw/WaterCinematicVisc
                    FWS=0.0521*REW**(-0.187)
                    FWR=1.39*(Abw/Z0)**(-0.52)

                    FW=MAX(FWS,FWR)

                if(UVC < 1e-3)then !wave-only flow

                    CDMAX=FW
                    CDM=0.

                else if(UVC.gt.1e-3)then !combined wave and current flow

                    !turbulent flow
                    !Rough-turbulent wave-plus-current shear-stress
                    ar=0.24
                    T1=MAX(ar*(FWR/2)**0.5*(Abw/Z0),12.)
                    T2=DWZ/(T1*Z0)
                    T3=(CDR**2+(FWR/2)**2*(Ubw/UVC)**4)**(1./4)
                    A1=T3*(LOG(T2)-1)/(2*LOG(T1))
                    A2=0.40*T3/LOG(T1)
                    if (A1<0) A1 = 0
                    if (A2<0) A2 = 0
                    CDMR=((A1**2+A2)**0.5-A1)**2
                    CDMAXR=((CDMR+T3*Ubw/UVC*(FWR/2)**0.5*abs(COS(CWphi*pi/180.)))**2+        &
                    (T3*Ubw/UVC*(FWR/2)**0.5*abs(SIN(CWphi*pi/180.)))**2)**0.5

                    !Smooth-turbulent wave-plus-current shear-stress
                    as=0.24
                    T1=9*as*REW*(FWS/2)**0.5*(CDS**2*(UVC/Ubw)**4+(FWS/2)**2)**(1./4)
                    T2=(REC/REW)*(Ubw/UVC)*1/as*(2/FWS)**0.5
                    T3=(CDS**2+(FWS/2)**2*(Ubw/UVC)**4)**(1./4)
                    A1=T3*(LOG(T2)-1)/(2*LOG(T1))
                    A2=0.40*T3/LOG(T1)
                    if (A1<0) A1 = 0
                    if (A2<0) A2 = 0
                    CDMS=((A1**2+A2)**0.5-A1)**2
                    CDMAXS=((CDMS+T3*Ubw/UVC*(FWS/2)**0.5*abs(COS(CWphi*pi/180.)))**2+         &
                    (T3*Ubw/UVC*(FWS/2)**0.5*abs(SIN(CWphi*pi/180.)))**2)**0.5

                    if(CDMAXR.gt.CDMAXS)then !flow is rough turbulent
                        CDMAX=CDMAXR
                        CDM=CDMR

                    else !flow is smooth turbulent
                        CDMAX=CDMAXS
                        CDM=CDMS
                    endif
                endif
            endif
        endif

    end subroutine Compute_DragCoef

    !------------------------------------------------------------------------------

    subroutine ComputeEfficiencyFactor

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB,KLB
        integer                                 :: i, j, KTOP
        real                                    :: Z0, H, CDM, CDMAX, U, CWphi, FW
        real(8), dimension(:,:),  pointer       :: GrainRoughness
        real                                    ::  Z0_, Abw, Ubw, CDM_, CDMAX_, FW_
        real                                    :: fc, fc1, ks
        integer                                 :: STAT_CALL
        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB
        KUB = Me%WaterWorkSize3D%KUB
        KLB = Me%WaterWorkSize3D%KLB

        Me%Shear_Stress%EfficiencyFactorCurrent(:,:) = 0.

        if (Me%WaveShear_Stress%Yes) then
            Me%Shear_Stress%EfficiencyFactorMean(:,:) = 0.
            Me%Shear_Stress%EfficiencyFactorWaves(:,:) = 0.
        endif

        call GetGrainRoughness(Me%ObjSediment, GrainRoughness, STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ComputeEfficiencyFactor - ModuleInterfaceSedimentWater - ERR10'

        if (Me%Shear_Stress%Method==2) then

do1:        do j = JLB, JUB
do2:        do i = ILB, IUB

                if (Me%ExtWater%OpenPoints2D(i,j) == OpenPoint) then

                    KTOP = Me%ExtSed%KTop(i, j)

                    if(Me%ExtSed%OpenPoints3D(i,j,KTOP) == OpenPoint) then

                        H  = Me%ExtWater%WaterColumn(i,j)
                        Z0_ = GrainRoughness(i,j)/30.
                        Z0 = Me%Rugosity%Field(i,j)

                        !Average velocity
                        U = Me%Shear_Stress%Velocity(i,j)/0.4* &
                            (log(H/Me%Rugosity%Field(i,j)) - 1 + Me%Rugosity%Field(i,j)/H)

                        if (Me%WaveShear_Stress%Yes) then

                            CWphi = Me%WaveShear_Stress%CWphi(i,j)
                            Ubw = Me%ExtWater%Ubw(i,j)
                            Abw = Me%ExtWater%Abw(i,j)

                            call Compute_DragCoef(H, Z0, U, CDMAX, CDM, FW, CWphi, Ubw, Abw)
                            call Compute_DragCoef(H, Z0_, U, CDMAX_, CDM_, FW_, CWphi, Ubw, Abw)

                            if(CDMAX .gt. 0.) Me%Shear_Stress%EfficiencyFactorCurrent(i,j) = MIN(CDMAX_/CDMAX, 1.0)

                            if (Me%ExtWater%Ubw(i,j).gt.1e-3) then
                                if(CDM .gt. 0.) Me%Shear_Stress%EfficiencyFactorMean(i,j)    = MIN(CDM_/CDM, 1.0)
                                if (FW .gt. 0.) Me%Shear_Stress%EfficiencyFactorWaves(i,j)   = MIN(FW_/FW, 1.0)
                            else
                                Me%Shear_Stress%EfficiencyFactorMean(i,j) = Me%Shear_Stress%EfficiencyFactorCurrent(i,j)
                                Me%Shear_Stress%EfficiencyFactorWaves(i,j) = 0.
                            endif
                        else
                            call Compute_DragCoef(H, Z0, U, CDMAX, CDM, FW)
                            call Compute_DragCoef(H, Z0_, U, CDMAX_, CDM_, FW_)

                            if(CDMAX .gt. 0.) Me%Shear_Stress%EfficiencyFactorCurrent(i,j) = MIN(CDMAX_/CDMAX, 1.0)
                        endif
                    endif
                endif
            enddo do2
            enddo do1


        elseif (Me%Shear_Stress%Method==1) then

do3:        do j = JLB, JUB
do4:        do i = ILB, IUB

                if (Me%ExtWater%OpenPoints2D(i,j) == OpenPoint) then
                    KTOP = Me%ExtSed%KTop(i, j)

                    if(Me%ExtSed%OpenPoints3D(i,j,KTOP) == OpenPoint) then

                        ks = Me%Rugosity%Field(i,j) * 30 !z0 = ks/30

                        if(GrainRoughness(i,j) .ge. ks) then

                            Me%Shear_Stress%EfficiencyFactorCurrent(i,j) = 1.
                        else
                            H  = Me%ExtWater%WaterColumn(i,j)

                            fc = 0.24*(log10(12*H/ks))**(-2.)
                            fc1= 0.24*(log10(12*H/GrainRoughness(i,j)))**(-2.)

                            Me%Shear_Stress%EfficiencyFactorCurrent(i,j) = fc1/fc
                        endif
                    else
                        Me%Shear_Stress%EfficiencyFactorCurrent(i,j) = 0.
                    endif
                endif
            enddo do4
            enddo do3
        endif

        call UngetSediment(Me%ObjSediment, GrainRoughness, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) &
                stop 'ComputeEfficiencyFactor - ModuleInterfaceSedimentWater - ERR20'

    end subroutine ComputeEfficiencyFactor
    !--------------------------------------------------------------------------

    !Based on van Rijn (2007a)
    subroutine ModifyRugosity

        !External--------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real,    pointer, dimension(:, :   )    :: Depth
        real(8), dimension(:,:),  pointer       :: GrainRoughness, D50
        real                                    :: Psi, WaterDensity, U, Uwc2, Ubw
        real                                    :: sedimentdensity, relativedensity
        real(8)                                 :: dsilt, dsand, dgravel
        real                                    :: Kscr, Kscmr, Kscd, Ksc, Ks, ffs, fcs
        real                                    :: Kscr_max, Kscmr_max, Kscd_max
        real                                    :: alfa, Td, ModelDT
        integer                                 :: IUB, JUB, ILB, JLB, KUB,KLB
        integer                                 :: i, j
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB
        KUB = Me%WaterWorkSize3D%KUB
        KLB = Me%WaterWorkSize3D%KLB

        WaterDensity    =  SigmaDensityReference
        Depth           => Me%ExtWater%WaterColumn

        dsilt = 32e-6
        dsand = 62e-6
        dgravel = 0.002

        sedimentdensity = 2650.
        relativedensity = sedimentdensity/WaterDensity

        call GetD50(Me%ObjSediment, D50, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyRugosity - ModuleInterfaceSedimentWater - ERR10'

        call GetGrainRoughness(Me%ObjSediment, GrainRoughness, STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyRugosity - ModuleInterfaceSedimentWater - ERR20'

        call GetComputeTimeStep(Me%ObjTime, ModelDT, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyRugosity - ModuleInterfaceSedimentWater - ERR25'

do1:    do j = JLB, JUB
do2:    do i = ILB, IUB

            if (Me%ExtWater%OpenPoints3D(i, j,KUB) == OpenPoint) then

                if (d50(i,j) > 0. ) then

                    !Average velocity
                    U = Me%Shear_Stress%Velocity(i,j)/0.4* &
                        (log(Depth(i,j)/Me%Rugosity%Field(i,j)) - 1 + Me%Rugosity%Field(i,j)/Depth(i,j))

                    if (Me%WaveShear_Stress%Yes) then
                        Ubw = Me%ExtWater%Ubw(i,j)
                        Uwc2 = U**2 + Ubw**2
                    else
                        Uwc2 = U**2
                    endif

                    !Mobility parameter
                    Psi = Uwc2/((relativedensity-1)*gravity*d50(i,j))

                    if(d50(i,j) < dsilt) then
                        Kscr = 20 * dsilt
                        Kscmr = 0.
                        Kscd = 0.
                    else

                        if(d50(i,j) .gt. 0.25*dgravel) then
                            fcs = (0.25*dgravel/d50(i,j))**1.5
                        else
                            fcs = 1.
                        endif

                        if(d50(i,j) .lt. 1.5*dsand) then
                            ffs = d50(i,j)/(1.5*dsand)
                        else
                            ffs = 1.
                        endif

                        !Ripples
                        Kscr_max = 0.075
                        Kscr = fcs*d50(i,j)*(85-65*tanh(0.015*(Psi-150)))
                        Kscr = min(Kscr, Kscr_max)

                        !Mega-ripples
                        Kscmr_max = min(0.01*Depth(i,j), 0.2)
                        Kscmr = 2e-6*ffs*Depth(i,j)*(1-exp(-0.05*Psi))*(550-Psi)
                        Kscmr = min(Kscmr, Kscmr_max)

                        !Dunes
                        Kscd_max = min(0.04*Depth(i,j), 0.4)
                        Kscd = 8e-6*ffs*Depth(i,j)*(1-exp(-0.02*Psi))*(600-Psi)
                        Kscd = min(Kscd, Kscd_max)
                    endif

                    !Current-related bed rougnhness
                    Ksc = (Kscr**2 + Kscmr**2 + Kscd**2)**0.5

                    !Bed rougnhness
                    Ks =  GrainRoughness(i,j) + Ksc

                    !Decay time
                    Td = Me%RugosityDecayTime
                    !Relaxation factor
                    alfa = ModelDT/Td
                    !z0
                    Me%Rugosity%Field(i,j) = (1-alfa)*Ks/30. + alfa*Me%Rugosity%Field(i,j)
                endif
            endif

        enddo do2
        enddo do1

         call UngetSediment(Me%ObjSediment, D50, STAT = STAT_CALL)
         if (STAT_CALL /= SUCCESS_) stop 'ModifyRugosity - ModuleInterfaceSedimentWater - ERR30'

        call UngetSediment(Me%ObjSediment, GrainRoughness, STAT = STAT_CALL)
         if (STAT_CALL /= SUCCESS_) stop 'ModifyRugosity - ModuleInterfaceSedimentWater - ERR40'


    end subroutine ModifyRugosity
    !--------------------------------------------------------------------------

    subroutine ComputeWaveRugosity

        !External--------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real, dimension(:,:), pointer :: D50Field2D, D90Field2D
        real                          :: Roughness, WaterDensity, Abw, Ubw
        real                          :: D50,D90,SedimentDryDensity,RelativeDensity
        real                          :: Klsw, Kllsw, psi, RippleHeight, RippleLength
        integer                       :: IUB, JUB, ILB, JLB, i, j
        real                          :: WaveHeight, WaterColumn, WavePeriod, LimitMin
        integer                       :: STAT_CALL
        integer                       :: CHUNK

        !Begin-----------------------------------------------------------------


        if (Me%RunsSandTransport) then

            call GetSandDiameters(ObjSandID = Me%ObjSand,                                &
                                  D50       = D50Field2D,                                &
                                  D90       = D90Field2D,                                &
                                  STAT      = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeWaveRugosity - ModuleInterfaceSedimentWater - ERR02'

            call GetSandDensity (ObjSandID   = Me%ObjSand,                               &
                                 SandDensity = SedimentDryDensity,                       &
                                 STAT        = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeWaveRugosity - ModuleInterfaceSedimentWater - ERR03'

        else

            D50                 = 2E-3
            D90                 = 3E-3
            SedimentDryDensity  = 2300.

        endif


        IUB = Me%WorkSize2D%IUB
        JUB = Me%WorkSize2D%JUB
        ILB = Me%WorkSize2D%ILB
        JLB = Me%WorkSize2D%JLB

        if (MonitorPerformance) then
            call StartWatch ("ModuleInterfaceSedimentWater", "ComputeWaveRugosity")
        endif

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,WavePeriod,WaveHeight,Abw,Ubw,WaterColumn,WaterDensity) &
        !$OMP PRIVATE(RelativeDensity,Psi,LimitMin,Klsw,Kllsw,RippleHeight,RippleLength) &
        !$OMP PRIVATE(Roughness) &
        !$OMP FIRSTPRIVATE(D50,D90)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

cd0:        if (Me%ExtWater%WaterPoints2D(i, j) == WaterPoint) then

                WavePeriod      = Me%ExtWater%WavePeriod(i,j)
                WaveHeight      = Me%ExtWater%WaveHeight(i,j)
                Abw             = Me%ExtWater%Abw(i,j)
                Ubw             = Me%ExtWater%Ubw(i,j)
                WaterColumn     = Me%ExtWater%WaterColumn(i,j)

                WaterDensity    = SigmaDensityReference

cd1:            if (WavePeriod .ne. 0. .or. WaveHeight .ne. 0.) then

                    if (Me%RunsSandTransport) then

                        D50 = D50Field2D(i, j)
                        D90 = D90Field2D(i, j)

                    endif


                    RelativeDensity     = (SedimentDryDensity - WaterDensity) / &
                                           WaterDensity

cd6:                if(WaveHeight.LT.0.10)then

                        Me%WaveShear_Stress%Rugosity%Field(i,j) = 3. * D90

                    else cd6

! ---> Computes Ripple Height and Lenght (Eq. 6.3.7 and 6.3.8 VanRijn)

                        Psi = Ubw**2./(RelativeDensity*Gravity*D50)

                        LimitMin = 1e-6

cd4:                    if(Psi .LT. LimitMin**2)then

                            Klsw            = 3.  * D90
                            Kllsw           = 0.

                        elseif(Psi.LE.10 .and. Psi .GT. LimitMin**2)then

                            RippleHeight    = Abw * 0.2
                            RippleLength    = RippleHeight / 0.18
                            Klsw            = 3.  * D90
                            Kllsw           = 16. * RippleHeight * (RippleHeight / RippleLength)

                        elseif (Psi .GT. 10. .AND. Psi .LE. 250.)then cd4

                            RippleHeight    = Abw * 2.8E-13 * (250   - Psi)**5.
                            RippleLength    = RippleHeight  / (2.E-7 * (250 - Psi)**2.5)
                            Klsw            = 3.  * D90
                            Kllsw           = 16. * RippleHeight * (RippleHeight / RippleLength)

                        else cd4

                            RippleHeight    = 0.
                            RippleLength    = 0.
                            Klsw            = 3.  * (0.04 * Psi - 9.) * D90
                            Kllsw           = 0.

                        end if cd4

! ---> Computes Wave Related bed BedRoughnesshness

                        Roughness                         = Klsw+Kllsw
                        Me%WaveShear_Stress%Rugosity%Field(i,j) = Roughness
                        !Me%WaveShear_Stress%Rugosity%Field(i,j) = min(Roughness, 0.1)

                    end if  cd6  ! WaveHeight>0

                endif cd1

            endif cd0


        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) then
            call StopWatch ("ModuleInterfaceSedimentWater", "ComputeWaveRugosity")
        endif

        if (Me%RunsSandTransport) then

            call UnGetSand(Me%ObjSand, D50Field2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeWaveRugosity - ModuleInterfaceSedimentWater - ERR09'

            call UnGetSand(Me%ObjSand, D90Field2D, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'ComputeWaveRugosity - ModuleInterfaceSedimentWater - ERR10'

        endif


    end subroutine ComputeWaveRugosity

    !--------------------------------------------------------------------------

    !--------------------------------------------------------------------------

    subroutine ComputeWaveTension

        !External--------------------------------------------------------------

        !Local-----------------------------------------------------------------
        real                          :: fw, WaterDensity, Abw, Ubw
        real                          :: C1
        integer                       :: IUB, JUB, ILB, JLB, i, j
        real                          :: WaveHeight, WavePeriod, LimitMin
        integer                       :: CHUNK

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ComputeWaveTension")


        IUB = Me%WorkSize2D%IUB
        JUB = Me%WorkSize2D%JUB
        ILB = Me%WorkSize2D%ILB
        JLB = Me%WorkSize2D%JLB

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,WavePeriod,WaveHeight,Abw,Ubw,WaterDensity,LimitMin,C1) &
        !$OMP PRIVATE(Fw)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

cd0:        if (Me%ExtWater%WaterPoints2D(i, j) == WaterPoint) then

                WavePeriod      = Me%ExtWater%WavePeriod(i,j)
                WaveHeight      = Me%ExtWater%WaveHeight(i,j)
                Abw             = Me%ExtWater%Abw(i,j)
                Ubw             = Me%ExtWater%Ubw(i,j)

                WaterDensity    = SigmaDensityReference

cd1:            if (WavePeriod .ne. 0. .or. WaveHeight .ne. 0.) then

! ---> Finally WaveShearStress

                    LimitMin = 1.e-6

                    C1       = -0.194

cd7:                if(WaveHeight .GT. 0.05 .and. Abw > LimitMin)then

                        Fw = exp(-5.977 + 5.213 * (Abw / Me%WaveShear_Stress%Rugosity%Field(i,j))**C1)

                        if (Fw.GT.0.3) Fw = 0.3

                    else cd7

                        Fw = 0.

                    end if cd7

                    Me%WaveShear_Stress%ChezyVel  (i,j)    = 0.25 * Fw * Ubw


                else cd1

                    Me%WaveShear_Stress%ChezyVel  (i,j)    = 0.

                endif cd1


            end if cd0

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ComputeWaveTension")

    end subroutine ComputeWaveTension

    !--------------------------------------------------------------------------


    subroutine ModifyWaterColumnFluxes

        !Local-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

       !Begin-----------------------------------------------------------------

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                !if (Me%Coupled%BenthicEcology%Yes)then
                if (PropertyX%Evolution%BenthicEcology)then
                    call InitializeFluxesToWaterColumn_Benthic(PropertyX)
                else
                    call InitializeFluxesToWaterColumn(PropertyX)
                endif

                !if(Me%Coupled%Erosion%Yes)then
                if(PropertyX%Evolution%Erosion)then

                    if(.not.PropertyX%Non_Cohesive) then
                       !Proportional factor between property mass and cohesive sediment mass
                        call ModifyErosionCoefficient(PropertyX)

                        call ModifyErosionFluxes(PropertyX)
                    else
                        call ModifyNonCohesiveErosionFluxes(PropertyX)
                    endif
                end if

                !if(Me%Coupled%Deposition%Yes)then
                if(PropertyX%Evolution%Deposition)then

                    if(.not.PropertyX%Non_Cohesive) then
                        call ModifyDepositionFluxes(PropertyX)
                    else
                        call ModifyNonCohesiveDepositionFluxes(PropertyX)
                    endif
                endif

                if(PropertyX%Evolution%WaterFluxes .and. (.not. PropertyX%ID%IsParticulate))then

                    call ModifyDissolvedFluxes(PropertyX)
                endif

            end if

            PropertyX => PropertyX%Next

        end do

    end subroutine ModifyWaterColumnFluxes

    !--------------------------------------------------------------------------


    subroutine ModifySedimentColumnFluxes

#ifndef _SEDIMENT_

        call InitializeFluxesToSediment

        if(Me%Consolidation%Yes)then

            call ComputeConsolidation

        end if

#endif

    end subroutine ModifySedimentColumnFluxes


    !--------------------------------------------------------------------------


    subroutine ModifySedimentWaterFluxes

        !Local-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

       !Begin-----------------------------------------------------------------


#ifndef _SEDIMENT_

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                if(PropertyX%Evolution%SedimentWaterFluxes .and.    &
                    .not. PropertyX%Non_Cohesive) then

                    if(PropertyX%ID%IsParticulate)then
                        call ParticulateSedimentWaterFluxes(PropertyX)

                    else
                        call DissolvedSedimentWaterFluxes(PropertyX)
                    endif
                endif

            end if

            PropertyX => PropertyX%Next

        end do

        if(Me%Consolidation%Yes)then

            call ModifyConsolidatedErosionFluxes

            if(Me%RunsSediments)then

                call ComputeWaterFlux

            endif

        end if

#endif

    end subroutine ModifySedimentWaterFluxes


    !--------------------------------------------------------------------------

    subroutine InitializeFluxesToWaterColumn(PropertyX)

        !Arguments-------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB
        integer                                 :: i, j, kbottom
        real, dimension(:,:,:), pointer         :: WaterPropertyConcentration
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB

                if (MonitorPerformance) then
                    call StartWatch ("ModuleInterfaceSedimentWater", "InitializeFluxesToWaterColumn")
                endif

                if(.not. PropertyX%ID%IsParticulate)then

                    call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,            &
                                          ConcentrationX    = WaterPropertyConcentration,       &
                                          PropertyXIDNumber = PropertyX%ID%IDNumber,            &
                                          PropertyXUnits    = WaterPropertyUnits,               &
                                          PropertyXISCoef   = WaterPropertyISCoef,              &
                                          STAT              = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'InitializeFluxesToWaterColumn - ModuleInterfaceSedimentWater - ERR01'

                    CHUNK = CHUNK_I(ILB, IUB)
                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do i = ILB, IUB
                    do j = JLB, JUB

                        if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                            kbottom = Me%ExtWater%KFloor_Z(i, j)

                            PropertyX%WaterConcentration(i,j) = WaterPropertyConcentration(i,j,kbottom) * &
                                                                WaterPropertyISCoef
                        end if

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    call UnGetWaterProperties(Me%ObjWaterProperties, WaterPropertyConcentration, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'InitializeFluxesToWaterColumn - ModuleInterfaceSedimentWater - ERR02'
                end if

                if(PropertyX%Evolution%WaterFluxes .or. PropertyX%Evolution%SedimentWaterFluxes)then

                    CHUNK = CHUNK_I(ILB, IUB)
                    !$OMP PARALLEL PRIVATE(i,j)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do i = ILB, IUB
                    do j = JLB, JUB

                        if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then
                            PropertyX%FluxToWater(i,j) = 0.
                        end if

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                end if

                if (MonitorPerformance) then
                    call StopWatch ("ModuleInterfaceSedimentWater", "InitializeFluxesToWaterColumn")
                endif

    end subroutine InitializeFluxesToWaterColumn

    !--------------------------------------------------------------------------

    subroutine InitializeFluxesToWaterColumn_Benthic(PropertyX)

        !Arguments-------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB
        integer                                 :: i, j, kbottom
        real, dimension(:,:,:), pointer         :: WaterPropertyConcentration
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB

        if (MonitorPerformance) then
            call StartWatch ("ModuleInterfaceSedimentWater", "InitializeFluxesToWaterColumn_Benthic")
        endif

        !if(.not. PropertyX%Particulate)then
        if(.not. PropertyX%Evolution%BenthicOnly)then
            call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,            &
                                    ConcentrationX    = WaterPropertyConcentration,       &
                                    PropertyXIDNumber = PropertyX%ID%IDNumber,            &
                                    PropertyXUnits    = WaterPropertyUnits,               &
                                    PropertyXISCoef   = WaterPropertyISCoef,              &
                                    STAT              = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'InitializeFluxesToWaterColumn_Benthic - ModuleInterfaceSedimentWater - ERR01'

            CHUNK = CHUNK_I(ILB, IUB)
            !$OMP PARALLEL PRIVATE(i,j,kbottom)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do i = ILB, IUB
            do j = JLB, JUB

                if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                    kbottom = Me%ExtWater%KFloor_Z(i, j)

                    PropertyX%WaterConcentration(i,j) = WaterPropertyConcentration(i,j,kbottom) * &
                                                        WaterPropertyISCoef


                    PropertyX%Mass_FromWater(i,j) =  PropertyX%WaterConcentration(i,j) * &
                                                            Me%ExtWater%VolumeZ(i,j,kbottom)

                end if

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            call UnGetWaterProperties(Me%ObjWaterProperties, WaterPropertyConcentration, STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_)&
                stop 'InitializeFluxesToWaterColumn_Benthic - ModuleInterfaceSedimentWater - ERR02'
        end if

        if(PropertyX%Evolution%WaterFluxes .or. PropertyX%Evolution%SedimentWaterFluxes)then

            CHUNK = CHUNK_I(ILB, IUB)
            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do i = ILB, IUB
            do j = JLB, JUB

                if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then
                    PropertyX%FluxToWater(i,j) = 0.
                end if
            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL
        end if

        if (MonitorPerformance) then
            call StopWatch ("ModuleInterfaceSedimentWater", "InitializeFluxesToWaterColumn_Benthic")
        endif

    end subroutine InitializeFluxesToWaterColumn_Benthic

    !--------------------------------------------------------------------------

    subroutine InitializeFluxesToSediment

#ifndef _SEDIMENT_

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j
        type(T_Property), pointer               :: PropertyX
        real, dimension(:,:,:), pointer         :: SedimentPropertyConcentration
        character(len=StringLength)             :: SedimentPropertyUnits
        real                                    :: SedimentPropertyISCoef
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        IUB = Me%SedimentWorkSize3D%IUB
        JUB = Me%SedimentWorkSize3D%JUB
        ILB = Me%SedimentWorkSize3D%ILB
        JLB = Me%SedimentWorkSize3D%JLB

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(Me%ExternalVar%Now .ge. PropertyX%Evolution%NextCompute)then

                if(PropertyX%Evolution%SedimentFluxes .or. PropertyX%Evolution%SedimentWaterFluxes)then

                    if(Me%RunsSediments)then

                        call GetSedimentConcentration(SedimentPropertiesID = Me%ObjSedimentProperties,  &
                                                      ConcentrationX    = SedimentPropertyConcentration,&
                                                      PropertyXIDNumber = PropertyX%ID%IDNumber,        &
                                                      PropertyXUnits    = SedimentPropertyUnits,        &
                                                      PropertyXISCoef   = SedimentPropertyISCoef,       &
                                                      STAT              = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'InitializeFluxesToSediment - ModuleInterfaceSedimentWater - ERR01'

                        if (MonitorPerformance) then
                            call StartWatch ("ModuleInterfaceSedimentWater", "InitializeFluxesToSediment")
                        endif

                        CHUNK = CHUNK_J(JLB, JUB)
                        !$OMP PARALLEL PRIVATE(i,j,KUB)
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = JLB, JUB
                        do i = ILB, IUB

                            if(Me%ExtSed%WaterPoints2D(i,j) == WaterPoint)then

                                KUB = Me%ExtSed%KTop(i,j)

                                PropertyX%SedimentConcentration(i,j) = SedimentPropertyConcentration(i,j,KUB) * &
                                                                       SedimentPropertyISCoef

                            end if

                        enddo
                        enddo
                        !$OMP END DO

                        !$OMP MASTER
                        call UnGetSedimentProperties(Me%ObjSedimentProperties, SedimentPropertyConcentration, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                                stop 'InitializeFluxesToSediment - ModuleInterfaceSedimentWater - ERR02'
                        !$OMP END MASTER
                        !$OMP END PARALLEL

                    endif

                    !$OMP PARALLEL PRIVATE(i,j)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = JLB, JUB
                    do i = ILB, IUB

                        if(Me%ExtSed%WaterPoints2D(i,j) == WaterPoint)then

                            PropertyX%FluxToSediment(i,j) = 0.

                        end if

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    if (MonitorPerformance) then
                        call StopWatch ("ModuleInterfaceSedimentWater", "InitializeFluxesToSediment")
                    endif

                end if

            end if

            PropertyX => PropertyX%Next

        end do

#endif

    end subroutine InitializeFluxesToSediment


    !--------------------------------------------------------------------------

    subroutine ModifyErosionCoefficient(PropertyX)

        !Argument-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB
        integer                                 :: i, j
        integer                                 :: STAT_CALL
        type(T_Property), pointer               :: CohesiveSediment
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB

        call Search_Property(CohesiveSediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'ModifyErosionCoefficient - ModuleInterfaceSedimentWater - ERR01'

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ModifyErosionCoefficient")

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j)
        if(PropertyX%Mass_Limitation)then
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                    if(CohesiveSediment%Mass_Available(i,j) > 0.) then

                        PropertyX%ErosionCoefficient(i,j) = Me%ErosionRate%Field(i,j)      * &
                                                            PropertyX%Mass_Available (i,j) / &
                                                            CohesiveSediment%Mass_Available (i,j)
                    else

                        PropertyX%ErosionCoefficient(i,j) = 0.

                    end if

                end if
            enddo
            enddo
            !$OMP END DO

        else
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                    PropertyX%ErosionCoefficient(i,j) = Me%ErosionRate%Field(i,j)
                else

                    PropertyX%ErosionCoefficient(i,j) = 0.

                end if

            enddo
            enddo
            !$OMP END DO
        end if
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ModifyErosionCoefficient")

        nullify(CohesiveSediment)

    end subroutine ModifyErosionCoefficient


    !--------------------------------------------------------------------------


    subroutine ModifyErosionFluxes(PropertyX)

        !Argument-----------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: i, j
        real                                    :: ShearStress
        real                                    :: PotentialNewMass, ReallyErodedMass

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ModifyErosionFluxes")

        !$OMP PARALLEL PRIVATE(i,j,ShearStress,PotentialNewMass, ReallyErodedMass)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNKJ)
        do j = Me%WaterWorkSize3D%JLB, Me%WaterWorkSize3D%JUB
        do i = Me%WaterWorkSize3D%ILB, Me%WaterWorkSize3D%IUB

            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                !Limit shear stress values in small depths
                if(Me%Shear_Stress%Limitation)then

                    ShearStress = ShearStressLimitation(Me%ExtWater%WaterColumn(i,j),&
                                                        Me%Shear_Stress%Tension(i,j))
                else

                    ShearStress = Me%Shear_Stress%Tension(i,j)

                end if

                if(PropertyX%Mass_Limitation)then


                    ![kg/m2s]
                    PropertyX%ErosionFlux(i,j) =                                                 &
                        ErosionFlux(CriticalShearErosion = Me%Critical_Shear_Erosion%Field(i,j), &
                                    ShearStress          = ShearStress,                          &
                                    ErosionRate          = PropertyX%ErosionCoefficient(i,j),    &
                                    Mass_Available       = PropertyX%Mass_Available(i,j),        &
                                    MinimumMass          = PropertyX%Mass_Min)


                    ![kg/m2] = [kg/m2] - [kg/m2/s * s]
                    PotentialNewMass                     = PropertyX%Mass_Available(i,j)       - &
                                                            PropertyX%ErosionFlux(i,j)          * &
                                                            PropertyX%Evolution%DTInterval

                    !if erosion flux will erode more than it exists
                    if(PotentialNewMass <= PropertyX%Mass_Min)then

                        !erosion will happen until mass minimum
                        ReallyErodedMass                = PropertyX%Mass_Available(i,j) - PropertyX%Mass_Min

                        !Re-compute real erosion flux
                        PropertyX%ErosionFlux(i,j)      = ReallyErodedMass / PropertyX%Evolution%DTInterval

                        PropertyX%Mass_Available(i,j)   = PropertyX%Mass_Min

                    else

                        PropertyX%Mass_Available(i,j)   = PotentialNewMass

                    end if

                else

                    ![kg/m2s]
                    PropertyX%ErosionFlux(i,j) =                                                 &
                        ErosionFlux(CriticalShearErosion = Me%Critical_Shear_Erosion%Field(i,j), &
                                    ShearStress          = ShearStress,                          &
                                    ErosionRate          = PropertyX%ErosionCoefficient(i,j))
                end if


                !Sum erosion flux to the flux to water
                PropertyX%FluxToWater(i,j) = PropertyX%FluxToWater(i,j) + PropertyX%ErosionFlux(i,j)

            end if

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL


        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ModifyErosionFluxes")

    end subroutine ModifyErosionFluxes


    !--------------------------------------------------------------------------

    real function ErosionFlux (CriticalShearErosion, ShearStress, ErosionRate, &
                               Mass_Available, MinimumMass)

        !Arguments-------------------------------------------------------------
        real, intent(IN)                        :: CriticalShearErosion
        real, intent(IN)                        :: ShearStress
        real, intent(IN)                        :: ErosionRate
        real, intent(IN), optional              :: Mass_Available
        real, intent(IN), optional              :: MinimumMass

        !Begin-----------------------------------------------------------------


        if (present(Mass_Available).and.present(MinimumMass)) then

            if (ShearStress >= CriticalShearErosion .and. Mass_Available > MinimumMass)then

                ErosionFlux = ErosionRate * (ShearStress / CriticalShearErosion - 1.)

            else

                ErosionFlux = 0.
            endif

        else

            if (ShearStress >= CriticalShearErosion) then

                ErosionFlux = ErosionRate * (ShearStress / CriticalShearErosion - 1.)

            else

                ErosionFlux = 0.

            endif

        endif

    end function ErosionFlux

    !--------------------------------------------------------------------------

    real function ShearStressLimitation(WaterColumn, ComputedShearStress)

        !Arguments-------------------------------------------------------------
        real, intent(IN)                        :: WaterColumn
        real, intent(IN)                        :: ComputedShearStress

        !Local-----------------------------------------------------------------
        real                                    :: ReferenceDepth
        real                                    :: ReferenceShearStress

        !Begin-----------------------------------------------------------------

        ReferenceDepth       = Me%Shear_Stress%ReferenceDepth
        ReferenceShearStress = Me%Shear_Stress%ReferenceShearStress

        if(WaterColumn < ReferenceDepth) then

            ShearStressLimitation = min(ComputedShearStress, ReferenceShearStress)
        else
            ShearStressLimitation = ComputedShearStress

        end if

    end function ShearStressLimitation

    !--------------------------------------------------------------------------

    subroutine ModifyConsolidatedErosionFluxes
#ifndef _SEDIMENT_


        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j, STAT_CALL
        type(T_Property), pointer               :: CohesiveSediment
        real                                    :: MaximumFlux, MaxErosionDepth
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ModifyConsolidatedErosionFluxes")


        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB

        call Search_Property(CohesiveSediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_) stop 'ModifyConsolidatedErosionCoef - ModuleInterfaceSedimentWater - ERR01'

        if(CohesiveSediment%Evolution%Erosion)then

            if(Me%ExternalVar%Now .ge. CohesiveSediment%Evolution%NextCompute)then

                CHUNK = CHUNK_J(JLB, JUB)
                !$OMP PARALLEL PRIVATE(i,j,KUB,MaxErosionDepth,MaximumFlux)
                !$OMP DO SCHEDULE(DYNAMIC, CHUNK)
                do j = JLB, JUB
                do i = ILB, IUB

                    if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint .and. &
                       Me%ExtSed%WaterPoints2D (i,j) == WaterPoint)then

                        KUB = Me%ExtSed%KTop(i, j)

                        !if(CohesiveSediment%Mass_Available(i,j) .le. CohesiveSediment%Mass_Min)then

                            if(Me%RunSedimentModule)then

                                MaximumFlux = Me%ExtSed%CohesiveMass(i,j,KUB)/Me%ExternalVar%GridCellArea(i,j)/  &
                                              CohesiveSediment%Evolution%DTInterval
                            else

                                MaxErosionDepth = Me%ExtSed%DWZ(i,j,KUB) - Me%ExtSed%MinLayerThickness

                                !kgsed/m2s = msed * m3sed / m3 / s * kgsed / m3sed
                                MaximumFlux = MaxErosionDepth * (1.-Me%ExtSed%Porosity(i, j, KUB))/ &
                                              CohesiveSediment%Evolution%DTInterval               * &
                                              Me%ExtSed%SedimentDryDensity(i, j, KUB)
                            endif

                            if(MaximumFlux .lt. 0.)then
                                !$OMP CRITICAL (MCEF1_ERR02)
                                write(*,*)'Maximum erosion flux cannot negative.', 'i,j', i,j, 'KUB = ', KUB
                                stop 'ModifyConsolidatedErosionFluxes - ModuleInterfaceSedimentWater - ERR02'
                                !MaximumFlux = 0.
                                !$OMP END CRITICAL (MCEF1_ERR02)
                            end if

                            if(Me%ExtSed%TopCriticalShear(i, j) < Me%Shear_Stress%Tension(i,j) .and.        &
                                Me%ExtSed%CohesiveMass(i,j,KUB) > 0.)then

                                !$OMP CRITICAL (MCEF2_FNC01)
                                !kgsed/m2s

                                CohesiveSediment%ErosionFlux(i,j) =                                         &
                                ErosionFlux(CriticalShearErosion = Me%ExtSed%TopCriticalShear(i, j),        &
                                            ShearStress          = Me%Shear_Stress%Tension(i,j),            &
                                            ErosionRate          = Me%ErosionRate%Field(i,j))
                                !$OMP END CRITICAL (MCEF2_FNC01)

                                if(CohesiveSediment%ErosionFlux(i,j) .gt. MaximumFlux)then

                                    CohesiveSediment%ErosionFlux(i,j) = MaximumFlux

                                end if

                                if(Me%RunSedimentModule)then
                                    CohesiveSediment%ErosionFlux(i,j) = CohesiveSediment%ErosionFlux(i,j) * &
                                        Me%ExtSed%CohesiveContent(i,j,KUB)
                                endif

                            else

                                CohesiveSediment%ErosionFlux(i,j) = 0.

                            end if

                            Me%Consolidation%Flux(i,j) = Me%Consolidation%Flux(i,j) -                   &
                                                         CohesiveSediment%ErosionFlux(i,j)

                            CohesiveSediment%FluxToWater(i,j) = CohesiveSediment%FluxToWater(i,j)     + &
                                                                CohesiveSediment%ErosionFlux(i,j)

                        !endif

                    end if

                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

            end if

        end if


        nullify(CohesiveSediment)


        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ModifyConsolidatedErosionFluxes")

#endif
    end subroutine ModifyConsolidatedErosionFluxes

    !--------------------------------------------------------------------------

    subroutine ModifyDepositionFluxes(PropertyX)

        !External--------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j, kbottom
        real, dimension(:,:,:), pointer         :: FreeConvFlux
        real, dimension(:,:,:), pointer         :: WaterPropertyConcentration
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB; JUB = Me%WaterWorkSize3D%JUB; KUB = Me%WaterWorkSize3D%KUB
        ILB = Me%WaterWorkSize3D%ILB; JLB = Me%WaterWorkSize3D%JLB

        call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,            &
                                ConcentrationX    = WaterPropertyConcentration,       &
                                PropertyXIDNumber = PropertyX%ID%IDNumber,            &
                                PropertyXUnits    = WaterPropertyUnits,               &
                                PropertyXISCoef   = WaterPropertyISCoef,              &
                                STAT              = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyDepositionFluxes - ModuleInterfaceSedimentWater - ERR01'

        call Get_FreeConvFlux(FreeVerticalMovementID = Me%ObjFreeVerticalMovement,  &
                                PropertyID             = PropertyX%ID%IDNumber,       &
                                FreeConvFlux           = FreeConvFlux,                &
                                STAT                   = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyDepositionFluxes - ModuleInterfaceSedimentWater - ERR02'

        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%WaterPointsorOpenPoints2D(i,j) == WaterPoint)then

                kbottom = Me%ExtWater%KFloor_Z(i, j)

                Me%DepositionProbability(i,j) =                                       &
                    DepositionProbability(Me%Critical_Shear_Deposition%Field(i,j),     &
                                            Me%Shear_Stress%Tension(i,j))

                !   kg          kg        1
                !--------- = ------- * -------
                ! m2 * s        s         m2
                PropertyX%DepositionFlux(i,j) = -1. * FreeConvFlux(i,j,kbottom)     * &
                                                WaterPropertyISCoef                 / &
                                                Me%ExternalVar%GridCellArea(i,j)

            end if

        enddo
        enddo

        if(PropertyX%Mass_Limitation)then

            if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ModifyDepositionFluxes")

            CHUNK = CHUNK_J(JLB, JUB)
            !$OMP PARALLEL PRIVATE(i,j)
            !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
            do j = JLB, JUB
            do i = ILB, IUB

                if(Me%WaterPointsorOpenPoints2D(i,j) == OpenPoint)then

                    PropertyX%Mass_Available(i,j) = PropertyX%Mass_Available(i,j)       + &
                                                    PropertyX%DepositionFlux(i,j)       * &
                                                    PropertyX%Evolution%DTInterval

                end if

            enddo
            enddo
            !$OMP END DO
            !$OMP END PARALLEL

            if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ModifyDepositionFluxes")

        end if

        call UnGetWaterProperties(Me%ObjWaterProperties, WaterPropertyConcentration, STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyDepositionFluxes - ModuleInterfaceSedimentWater - ERR03'

        call UngetFreeVerticalMovement(Me%ObjFreeVerticalMovement, FreeConvFlux, STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyDepositionFluxes - ModuleInterfaceSedimentWater - ERR04'

    end subroutine ModifyDepositionFluxes

    !--------------------------------------------------------------------------


    real function DepositionProbability (CriticalShearDeposition, ShearStress)

        !Arguments-------------------------------------------------------------
        real, intent(IN)                        :: CriticalShearDeposition
        real, intent(IN)                        :: ShearStress

        !Begin-----------------------------------------------------------------

        if (ShearStress <= CriticalShearDeposition .and. ShearStress >= 0.)then

            DepositionProbability = 1. - ShearStress / CriticalShearDeposition

        elseif (ShearStress < 0.) then
            stop 'DepositionProbability - ModuleInterfaceSedimentWater - ERR01'
        else
            DepositionProbability = 0.
        endif

    end function DepositionProbability

    !--------------------------------------------------------------------------


    subroutine ModifyDissolvedFluxes(PropertyX)

        !Argument--------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j, kbottom
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------
        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ModifyDissolvedFluxes")

        IUB = Me%WaterWorkSize3D%IUB;  JUB = Me%WaterWorkSize3D%JUB;  KUB = Me%WaterWorkSize3D%KUB
        ILB = Me%WaterWorkSize3D%ILB;  JLB = Me%WaterWorkSize3D%JLB

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,kbottom)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint) then

                kbottom = Me%ExtWater%KFloor_Z(i, j)

                PropertyX%FluxToWater(i,j) = PropertyX%FluxToWater(i,j)     + &
                                                PropertyX%Mass_Available(i,j)  / &
                                                PropertyX%Evolution%DTInterval
            end if

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ModifyDissolvedFluxes")

    end subroutine ModifyDissolvedFluxes

    !--------------------------------------------------------------------------

    subroutine ComputeWaterFlux

#ifndef _SEDIMENT_

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ComputeWaterFlux")

        IUB = Me%WorkSize2D%IUB;  JUB = Me%WorkSize2D%JUB
        ILB = Me%WorkSize2D%ILB;  JLB = Me%WorkSize2D%JLB

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,KUB)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%ExtSed%WaterPoints2D(i,j) == WaterPoint)then

                KUB = Me%ExtSed%KTop(i, j)

                !m3water/s  = kgsed.m-2.s-1 * m2 * m3water/m3 /(kgsed.m-3sed * m3sed.m3)
                Me%WaterFlux(i,j) = -1. * Me%Consolidation%Flux(i,j)            * &
                                    Me%ExternalVar%GridCellArea(i,j)            * &
                                    Me%ExtSed%Porosity(i, j, KUB)               / &
                                    (Me%ExtSed%SedimentDryDensity(i, j, KUB)    * &
                                    (1.- Me%ExtSed%Porosity(i, j, KUB)))

            end if

        end do
        end do
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ComputeWaterFlux")

#endif

    end subroutine ComputeWaterFlux


    !--------------------------------------------------------------------------


    subroutine ComputeConsolidation

#ifndef _SEDIMENT_

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB
        integer                                 :: i, j, STAT_CALL
        type(T_Property), pointer               :: CohesiveSediment
        real                                    :: Initial_Mass_Available
        integer                                 :: CHUNK
        real                                    :: Max_Flux

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ComputeConsolidation")

        ILB = Me%WorkSize2D%ILB;  JLB = Me%WorkSize2D%JLB
        IUB = Me%WorkSize2D%IUB;  JUB = Me%WorkSize2D%JUB

        call Search_Property(CohesiveSediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)stop 'ComputeConsolidation - ModuleInterfaceSedimentWater - ERR10'

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB
            if(Me%ExtSed%WaterPoints2D(i,j) == WaterPoint)then
                Me%Consolidation%Flux(i,j) = 0.
            end if
        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ComputeConsolidation")

        !T !$OMP PARALLEL PRIVATE(i,j,Initial_Mass_Available)
        !T !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if (Me%ExtWater%WaterPoints2D(i,j) .eq. WaterPoint) then

                if(Me%Shear_Stress%Tension(i,j)                     &
                        < Me%Critical_Shear_Deposition%Field(i,j).and.  &
                        CohesiveSediment%Mass_Available(i,j)            &
                        > CohesiveSediment%Mass_Min) then

                    !Consolidation is solved implicitly to avoid instability
                    Initial_Mass_Available = CohesiveSediment%Mass_Available(i,j)

                    if(Me%RunSedimentModule) then
                    !When running the module sediment, it's considered that the cohesive sediment
                    !present in the interface sediment-water is fluid mud (concentration below the gel point) -
                    !a matrix structure is not formed yet and self-weight consolidation is not possible.
                    !A constant dewatering rate is considered to transfer cohesive sediment from the fluid mud
                    !(interface) to the active layer, considering the concentration in the hindered settling regime.
                    !This flux should be called Dewatering_Flux, however to maintain the code structure it's called Consolidation_Flux.

                        if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then
                            Me%DepositionProbability(i,j) =                                    &
                                DepositionProbability(Me%Critical_Shear_Deposition%Field(i,j), &
                                                        Me%Shear_Stress%Tension(i,j))
                        else
                            Me%DepositionProbability(i,j) = 1.
                        endif

                        !kg/m2/s
                        Me%Consolidation%Flux(i,j) = Me%Dewatering_Rate *    &
                                                     Me%DepositionProbability(i,j)

                        Max_Flux = (Initial_Mass_Available - CohesiveSediment%Mass_Min) /  &
                                    Me%ExternalVar%GridCellArea(i,j)/                      &
                                    CohesiveSediment%Evolution%DTInterval

                        If (Me%Consolidation%Flux(i,j) > Max_Flux) then

                            Me%Consolidation%Flux(i,j) = Max_Flux

                        endif

                    elseif(Me%RunsSediments) then

                        !kg/m2 = kg/m2 / (s * s-1)
                        CohesiveSediment%Mass_Available(i,j) = &
                            CohesiveSediment%Mass_Available(i,j)        / &
                            (1. + CohesiveSediment%Evolution%DTInterval * &
                            Me%Consolidation%Rate%Field(i,j))


                        !kg/m2s = kg/m2 / s  (Positive if it entering consolidated sediment compartment)
                        Me%Consolidation%Flux(i,j) = Me%Consolidation%Flux(i,j)            + &
                                                    (Initial_Mass_Available                - &
                                                        CohesiveSediment%Mass_Available(i,j)) / &
                                                        CohesiveSediment%Evolution%DTInterval


                        if(Me%ExtSed%SedimentColumnFull(i,j) > 0) &
                            Me%Consolidation%Flux(i,j) = 0.

                    endif
                 endif
            endif
        end do
        end do
        !T !$OMP END DO
        !T !$OMP END PARALLEL

#endif

    end subroutine ComputeConsolidation


    !--------------------------------------------------------------------------


    subroutine DissolvedSedimentWaterFluxes(PropertyX)

        !Argument--------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB
        integer                                 :: i, j, kbottom
        real                                    :: DiffusiveFlux
        real                                    :: AdvectiveFlux
        real                                    :: BoundaryLayerThickness
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------
        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "DissolvedSedimentWaterFluxes")

        IUB = Me%WorkSize2D%IUB
        JUB = Me%WorkSize2D%JUB
        ILB = Me%WorkSize2D%ILB
        JLB = Me%WorkSize2D%JLB

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,kbottom,BoundaryLayerThickness,AdvectiveFlux,DiffusiveFlux)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%ExtWater%OpenPoints2D(i,j) == WaterPoint .and. &
                Me%ExtSed%WaterPoints2D (i,j) == WaterPoint)then

                kbottom = Me%ExtWater%KFloor_Z(i, j)

                if(Me%Shear_Stress%Velocity(i, j) > 0.)then
                    BoundaryLayerThickness = 2. * WaterCinematicVisc / Me%Shear_Stress%Velocity(i,j)
                else
                    BoundaryLayerThickness = Me%ExtWater%DWZ(i,j,kbottom)/2.
                end if


                if  (Me%WaterFlux(i,j) > 0.)then

                    AdvectiveFlux = PropertyX%SedimentConcentration(i,j) * Me%WaterFlux(i,j) / &
                                    Me%ExternalVar%GridCellArea(i,j)

                    DiffusiveFlux = 0.

                elseif(Me%WaterFlux(i,j) < 0.)then

                    AdvectiveFlux = PropertyX%WaterConcentration(i,j)    * Me%WaterFlux(i,j) / &
                                    Me%ExternalVar%GridCellArea(i,j)


                    !kg/m2s = (kg/m3 - kg/m3) * m2/s / m
                    DiffusiveFlux = (PropertyX%SedimentConcentration(i,j)               - &
                                        PropertyX%WaterConcentration(i,j))                 * &
                                        PropertyX%MolecularDifCoef%Field(i,j)              / &
                                        BoundaryLayerThickness



                elseif(Me%WaterFlux(i,j)== 0.)then

                    AdvectiveFlux = 0.

                    !kg/m2s = (kg/m3 - kg/m3) * m2/s / m
                    DiffusiveFlux = (PropertyX%SedimentConcentration(i,j)               - &
                                        PropertyX%WaterConcentration(i,j))                 * &
                                        PropertyX%MolecularDifCoef%Field(i,j)              / &
                                        BoundaryLayerThickness


                end if

                PropertyX%FluxToWater(i,j)    = PropertyX%FluxToWater(i,j)    + DiffusiveFlux + AdvectiveFlux

                PropertyX%FluxToSediment(i,j) = PropertyX%FluxToSediment(i,j) - DiffusiveFlux - AdvectiveFlux

            end if

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "DissolvedSedimentWaterFluxes")

    end subroutine DissolvedSedimentWaterFluxes


    !--------------------------------------------------------------------------

    subroutine ParticulateSedimentWaterFluxes(PropertyX)

        !Argument--------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, KUB
        integer                                 :: i, j
        type(T_Property),       pointer         :: CohesiveSediment
        integer                                 :: STAT_CALL
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------
        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "ParticulateSedimentWaterFluxes")

        IUB = Me%WorkSize2D%IUB
        JUB = Me%WorkSize2D%JUB
        ILB = Me%WorkSize2D%ILB
        JLB = Me%WorkSize2D%JLB

        call Search_Property(CohesiveSediment, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
        if (STAT_CALL .NE. SUCCESS_)stop 'ParticulateSedimentWaterFluxes - ModuleInterfaceSedimentWater - ERR10'

        CHUNK = CHUNK_J(JLB, JUB)
        !$OMP PARALLEL PRIVATE(i,j,KUB)
        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                !if (Me%Consolidation%Yes) then

                    if(Me%Consolidation%Flux(i,j) > 0. .and.  &
                        CohesiveSediment%Mass_Available(i,j)  &
                        > CohesiveSediment%Mass_Min)then !consolidation

                        PropertyX%FluxToSediment(i,j) = PropertyX%FluxToSediment(i,j)        + &
                                                        PropertyX%Mass_Available(i,j)        / &
                                                        CohesiveSediment%Mass_Available(i,j) * &
                                                        Me%Consolidation%Flux(i,j)

                    elseif(Me%Consolidation%Flux(i,j) < 0.)then !erosion

                        KUB = Me%ExtSed%Ktop(i, j)

                        if(Me%RunsSediments)    &
                            PropertyX%FluxToWater(i,j)    = PropertyX%FluxToWater(i,j)          - &
                                                        Me%Consolidation%Flux(i,j)          * &
                                                        PropertyX%SedimentConcentration(i,j)

                        if(Me%RunSedimentModule)    &
                            PropertyX%FluxToWater(i,j)    = PropertyX%FluxToWater(i,j)          - &
                                                        Me%Consolidation%Flux(i,j)


                        PropertyX%FluxToSediment(i,j) = PropertyX%FluxToSediment(i,j)       - &
                                                        PropertyX%FluxToWater(i,j)

                    else

                        PropertyX%FluxToSediment(i,j) = 0.

                    end if

            !else   ! no consolidation
            !PropertyX%FluxToSediment(i,j) = 0.
            !endif

                    PropertyX%Mass_Available(i,j) = PropertyX%Mass_Available(i,j)        - &
                                                    PropertyX%FluxToSediment(i,j)        * &
                                                    PropertyX%Evolution%DTInterval

                    if(PropertyX%Mass_Available(i,j) < PropertyX%Mass_Min)         &
                        PropertyX%Mass_Available(i,j) = PropertyX%Mass_Min

            endif

        enddo
        enddo
        !$OMP END DO
        !$OMP END PARALLEL

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "ParticulateSedimentWaterFluxes")

    end subroutine ParticulateSedimentWaterFluxes


    !--------------------------------------------------------------------------

    subroutine ModifyNonCohesiveErosionFluxes(PropertyX)
#ifndef _SEDIMENT_

        !Argument--------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, kbottom
        integer                                 :: KTOP
        integer                                 :: i, j, STAT_CALL
        real(8), dimension(:,:,:),pointer       :: SandMass
        real, dimension(:,:),pointer            :: CriticalShearStress
        real, pointer, dimension(:,:,:)         :: SettlingVelocity, SandContent
        real, dimension(:,:),  pointer          :: ConcRef
        real, dimension(:,:),  pointer          :: ReferenceLevel
        real                                    :: MaximumFlux, ConcRefz
        real                                    :: z, H, Ws, K0, b, u, a
        real                                    :: RouseProfile
        real, dimension(:,:,:), pointer         :: FreeConvFlux

        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB
        JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB
        JLB = Me%WaterWorkSize3D%JLB

        call GetSandMass(Me%ObjSediment,PropertyX%ID%IDNumber,SandMass, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR10'

        call GetSandContent(Me%ObjSediment,PropertyX%ID%IDNumber,SandContent, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR20'

        call GetCriticalShearStress(Me%ObjSediment,PropertyX%ID%IDNumber,CriticalShearStress, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR30'

        call GetConcRef(Me%ObjSediment,PropertyX%ID%IDNumber,ConcRef, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR40'

        call GetReferenceLevel(Me%ObjSediment,PropertyX%ID%IDNumber,ReferenceLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR45'

        call Get_FreeVelocity(FreeVerticalMovementID = Me%ObjFreeVerticalMovement,&
                                    PropertyID             = PropertyX%ID%IDNumber,     &
                                    Free_Velocity          = SettlingVelocity,          &
                                    STAT                   = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR50'

         call Get_FreeConvFlux(FreeVerticalMovementID = Me%ObjFreeVerticalMovement,  &
                                PropertyID             = PropertyX%ID%IDNumber,       &
                                FreeConvFlux           = FreeConvFlux,                &
                                STAT                   = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR70'

        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint .and. &
                Me%ExtSed%WaterPoints2D (i,j) == WaterPoint)then

                KTOP = Me%ExtSed%KTop(i, j)

                MaximumFlux = SandMass(i,j,KTOP)/Me%ExternalVar%GridCellArea(i,j)/  &
                                PropertyX%Evolution%DTInterval


                if(MaximumFlux .lt. 0.)then
                    write(*,*)'Maximum erosion flux cannot negative.', 'i,j', i,j, 'KTOP = ', KTOP
                    write(*,*) 'Sand Mass', SandMass(i,j,KTOP), 'Property : '//trim(PropertyX%ID%Name)
                    stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR80'
                end if

                if(SandMass(i,j,KTOP) > 0.)then

                    kbottom = Me%ExtWater%KFloor_Z(i, j)

                    !height above bed
                    z = Me%ExtWater%DWZ(i,j,kbottom) / 2.

                    !Reference Level
                    a = ReferenceLevel(i,j)
                    !WaterColumn
                    H = Me%ExtWater%WaterColumn(i,j)
                    !Settling velocity
                    Ws = - SettlingVelocity(i,j,kbottom)
                    !Von Karmann coefficient
                    K0 = 0.4
                    !bed-shear velocity
                    u = Me%Shear_Stress%Velocity(i,j)
                    !u,min= 0.001 to avoid numerical errors
                    if(u < 0.01)  u = 0.01
                    !Suspension number
                    b = Ws / (K0 * u)
                    !Rouse profile term
                    RouseProfile = (a * (H - z) / (z * (H - a))) **b
                    !Reference concentration in the middle of the bottom grid cell
                    ConcRefz = ConcRef(i,j) * RouseProfile

                    !The erosion flux is equal to the entrainment rate under equilibrium conditions
                    !(Garcia and Parker, 1991).
                    ![kg m-2 s-1]               [m s-1]*[kg m-3]

                    PropertyX%ErosionFlux(i,j) = - SettlingVelocity(i,j,kbottom) * ConcRefz

                    if(Me%ExtSed%CohesiveClassRun) then

                        if(Me%ExtSed%CohesiveContent(i,j,KTOP) > 0.6) then
                        !For fully cohesive beds (mud content > 0.6) the erosion flux for sand is calculated by using
                        !the same formulation of cohesive sediments

                            if(CriticalShearStress(i,j) < Me%Shear_Stress%Tension(i,j))then

                                PropertyX%ErosionFlux(i,j) =                                         &
                                ErosionFlux(CriticalShearErosion = CriticalShearStress(i, j),        &
                                            ShearStress          = Me%Shear_Stress%Tension(i,j),     &
                                            ErosionRate          = Me%ErosionRate%Field(i,j))

                                PropertyX%ErosionFlux(i,j) = PropertyX%ErosionFlux(i,j) * SandContent(i,j,KTOP)

                            else
                                PropertyX%ErosionFlux(i,j) = 0.
                            endif
                        endif
                    endif

                    if(PropertyX%ErosionFlux(i,j) .gt. MaximumFlux)then

                        PropertyX%ErosionFlux(i,j) = MaximumFlux

                    end if

                else

                    PropertyX%ErosionFlux(i,j) = 0.

                end if

                PropertyX%FluxToWater(i,j) = PropertyX%ErosionFlux(i,j)

            end if

        enddo
        enddo

        call UngetSediment(Me%ObjSediment, SandMass, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR100'

        call UngetSediment(Me%ObjSediment, CriticalShearStress, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR110'

        call UngetSediment(Me%ObjSediment, ConcRef, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR120'

        call UngetSediment(Me%ObjSediment, ReferenceLevel, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR125'

        call UngetSediment(Me%ObjSediment, SandContent, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR130'

        call UngetFreeVerticalMovement(Me%ObjFreeVerticalMovement, SettlingVelocity, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR140'

        call UngetFreeVerticalMovement(Me%ObjFreeVerticalMovement, FreeConvFlux, STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyNonCohesiveErosionFluxes - ModuleInterfaceSedimentWater - ERR160'

#endif
    end subroutine ModifyNonCohesiveErosionFluxes

        !--------------------------------------------------------------------------

    subroutine ModifyNonCohesiveDepositionFluxes(PropertyX)
#ifndef _SEDIMENT_

        !Argument--------------------------------------------------------------
        type(T_Property), pointer               :: PropertyX

        !Local-----------------------------------------------------------------
        integer                                 :: IUB, JUB, ILB, JLB, kbottom
        integer                                 :: i, j, STAT_CALL
        real, dimension(:,:,:), pointer         :: WaterPropertyConcentration
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef
        real, dimension(:,:,:), pointer         :: FreeConvFlux
        !Begin-----------------------------------------------------------------

        IUB = Me%WaterWorkSize3D%IUB;  JUB = Me%WaterWorkSize3D%JUB
        ILB = Me%WaterWorkSize3D%ILB;  JLB = Me%WaterWorkSize3D%JLB

        call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,            &
                                ConcentrationX    = WaterPropertyConcentration,       &
                                PropertyXIDNumber = PropertyX%ID%IDNumber,            &
                                PropertyXUnits    = WaterPropertyUnits,               &
                                PropertyXISCoef   = WaterPropertyISCoef,              &
                                STAT              = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyNonCohesiveDepositionFluxes - ModuleInterfaceSedimentWater - ERR10'


         call Get_FreeConvFlux(FreeVerticalMovementID = Me%ObjFreeVerticalMovement,  &
                                PropertyID             = PropertyX%ID%IDNumber,       &
                                FreeConvFlux           = FreeConvFlux,                &
                                STAT                   = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyNonCohesiveDepositionFluxes - ModuleInterfaceSedimentWater - ERR20'


        do j = JLB, JUB
        do i = ILB, IUB

            if(Me%WaterPointsorOpenPoints2D(i,j) == WaterPoint)then

                kbottom = Me%ExtWater%KFloor_Z(i, j)

                PropertyX%DepositionFlux(i,j) = -1. * FreeConvFlux(i,j,kbottom)     * &
                                                WaterPropertyISCoef                 / &
                                                Me%ExternalVar%GridCellArea(i,j)

                PropertyX%FluxToSediment(i,j) = PropertyX%DepositionFlux(i,j) - PropertyX%FluxToWater(i,j)
            endif
        enddo
        enddo

        call UnGetWaterProperties(Me%ObjWaterProperties, WaterPropertyConcentration, STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyNonCohesiveDepositionFluxes - ModuleInterfaceSedimentWater - ERR30'

        call UngetFreeVerticalMovement(Me%ObjFreeVerticalMovement, FreeConvFlux, STAT = STAT_CALL)
        if(STAT_CALL .ne. SUCCESS_) stop 'ModifyNonCohesiveDepositionFluxes - ModuleInterfaceSedimentWater - ERR40'

#endif
    end subroutine ModifyNonCohesiveDepositionFluxes


    !--------------------------------------------------------------------------


    subroutine SetFluxesToWaterColumn

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type(T_Property),       pointer         :: PropertyX

        !Begin-----------------------------------------------------------------

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%WaterFluxes)then

                call SetFluxToWaterProperties(WaterPropertiesID = Me%ObjWaterProperties, &
                                              PropertyID        = PropertyX%ID%IDNumber, &
                                              Flux              = PropertyX%FluxToWater, &
                                              STAT              = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'SetFluxesToWaterColumn - ModuleInterfaceSedimentWater - ERR01'

            end if

            PropertyX => PropertyX%Next

        enddo


    end subroutine SetFluxesToWaterColumn

    !--------------------------------------------------------------------------


#ifndef _SEDIMENT_
    subroutine SetFluxesToSedimentColumn

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type(T_Property),       pointer         :: PropertyX

        !Begin-----------------------------------------------------------------

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%SedimentWaterFluxes)then

                call SetFluxToSedimentProperties(SedimentPropertiesID = Me%ObjSedimentProperties, &
                                                 PropertyID           = PropertyX%ID%IDNumber,    &
                                                 Flux                 = PropertyX%FluxToSediment, &
                                                 STAT                 = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'SetFluxesToSedimentColumn - ModuleInterfaceSedimentWater - ERR01'

            end if

            PropertyX => PropertyX%Next

        enddo


    end subroutine SetFluxesToSedimentColumn

    !--------------------------------------------------------------------------

#endif

    !--------------------------------------------------------------------------


    subroutine ModifySandTransport

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call UnGetGridData(Me%ObjWaterGridData, Me%ExtWater%Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifySandTransport - ModuleInterfaceSedimentWater - ERR01'

        call ModifySand(Me%ObjSand, Me%Shear_Stress%Tension,                     &
                        Me%Rugosity%Field,                                       &
                        Me%WaveShear_Stress%Rugosity%Field,                      &
                        Me%ExtWater%WaterColumn,                                 &
                        Me%Shear_Stress%CurrentU,                                &
                        Me%Shear_Stress%CurrentV,                                &
                        Me%Shear_Stress%CurrentVel,                              &
                        Me%WaveShear_Stress%Tension,                             &
                        Me%WaveShear_Stress%TensionCurrents,                     &
                        Me%Shear_Stress%Velocity,                                &
                        Me%ExtWater%MinWaterColumn,                              &
                        Me%Shear_Stress%UFace,                                   &
                        Me%Shear_Stress%VFace,                                   &
                        Me%Shear_Stress%CurrentResidualU,                        &
                        Me%Shear_Stress%CurrentResidualV,                        &
                        STAT = STAT_CALL)
        if(STAT_CALL /= SUCCESS_) stop 'ModifySandTransport - ModuleInterfaceSedimentWater - ERR02'

        call GetGridData(Me%ObjWaterGridData, Me%ExtWater%Bathymetry, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'ModifySandTransport - ModuleInterfaceSedimentWater - ERR03'


    end subroutine ModifySandTransport

       !--------------------------------------------------------------------------


    subroutine ModifySedimentTransport

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Begin-----------------------------------------------------------------


        call ModifySediment(Me%ObjSediment,                                      &
                        Me%Shear_Stress%Tension,                                 &
                        Me%Shear_Stress%EfficiencyFactorCurrent,                 &
                        Me%Shear_Stress%CurrentU,                                &
                        Me%Shear_Stress%CurrentV,                                &
                        Me%Shear_Stress%CurrentVel,                              &
                        Me%WaveShear_Stress%Tension,                             &
                        Me%WaveShear_Stress%TensionMean,                         &
                        Me%WaveShear_Stress%Cphi,                                &
                        Me%WaveShear_Stress%CWphi,                               &
                        Me%Shear_Stress%EfficiencyFactorMean,                    &
                        Me%Shear_Stress%EfficiencyFactorWaves,                   &
                        STAT = STAT_CALL)
        if(STAT_CALL /= SUCCESS_) stop 'ModifySedimentTransport - ModuleInterfaceSedimentWater - ERR02'


    end subroutine ModifySedimentTransport

    !--------------------------------------------------------------------------

    subroutine OutPut_TimeSeries

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX

        !Begin-----------------------------------------------------------------

        call WriteTimeSerie(Me%ObjTimeSerie,                                    &
                            Data2D  = Me%Shear_Stress%Tension,                  &
                            STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleInterfaceSedimentWater - ERR010'


        PropertyX   => Me%FirstProperty
        do while (associated(PropertyX))
            if (PropertyX%TimeSerie) then

                if(PropertyX%OutHDForigin) then

                        call WriteTimeSerie(Me%ObjTimeSerie,                         &
                                    Data2D  = PropertyX%MassInKg,                    &
                                    STAT    = STAT_CALL)
                     if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleInterfaceSedimentWater - ERR020'

                    else

                        call WriteTimeSerie(Me%ObjTimeSerie,                            &
                                            Data2D  = PropertyX%Mass_Available,         &
                                            STAT    = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleInterfaceSedimentWater - ERR030'

                    end if


                    if(PropertyX%Evolution%Deposition)then

                        call WriteTimeSerie(Me%ObjTimeSerie,                            &
                                            Data2D  = PropertyX%DepositionFlux,         &
                                            STAT    = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleInterfaceSedimentWater - ERR040'

                    end if

                    if(PropertyX%Evolution%Erosion)then

                        call WriteTimeSerie(Me%ObjTimeSerie,                            &
                                            Data2D  = PropertyX%ErosionFlux,            &
                                            STAT    = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OutPut_TimeSeries - ModuleInterfaceSedimentWater - ERR050'
                    end if

            endif
            PropertyX=>PropertyX%Next
        enddo

    end subroutine OutPut_TimeSeries


    !--------------------------------------------------------------------------

    subroutine OutPut_BoxTimeSeries

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property), pointer              :: PropertyX
        integer                                 :: ILB, IUB, JLB, JUB
        integer                                 :: i, j
        integer                                 :: CHUNK

        !----------------------------------------------------------------------

        ILB = Me%Size2D%ILB;  JLB = Me%Size2D%JLB
        IUB = Me%Size2D%IUB;  JUB = Me%Size2D%JUB

        PropertyX  => Me%FirstProperty

        do while (associated(PropertyX))
            if (PropertyX%BoxTimeSerie) then

                Me%Scalar2D(:,:) = 0.

                if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "OutPut_BoxTimeSeries")

                CHUNK = CHUNK_J(JLB, JUB)
                !$OMP PARALLEL PRIVATE(I,J)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do J = JLB, JUB
                do I = ILB, IUB
                    if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                        if(PropertyX%OutHDForigin) then

                            Me%Scalar2D(i,j) = PropertyX%MassinKg(i, j) * &
                                               Me%ExternalVar%GridCellArea(i,j)

                        else

                            Me%Scalar2D(i,j) = PropertyX%Mass_Available(i, j) * &
                                               Me%ExternalVar%GridCellArea(i,j)
                        end if

                    end if
                end do
                end do
                !$OMP END DO
                !$OMP END PARALLEL

                if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "OutPut_BoxTimeSeries")

                call BoxDif(Me%ObjBoxDif,                       &
                            Me%Scalar2D,                        &
                            "Bottom "//trim(PropertyX%ID%name), &
                            Me%ExtWater%WaterPoints2D,          &
                            STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_BoxTimeSeries - ModuleInterfaceSedimentWater - ERR01'

                Me%Scalar2D(:,:) = null_real

            endif
            PropertyX=>PropertyX%Next
        enddo

    end subroutine OutPut_BoxTimeSeries

    !--------------------------------------------------------------------------

    subroutine OutPut_Statistics (Value2D, StatisticsID)

        !Arguments-------------------------------------------------------------
        real, dimension(:,:), pointer :: Value2D
        integer                       :: StatisticsID

        !Local-----------------------------------------------------------------
        integer                       :: MethodStatistic, Value2DStat2D
        integer                       :: STAT_CALL

        !Begin-----------------------------------------------------------------

        call GetStatisticMethod (StatisticsID, MethodStatistic, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Statistics - ModuleInterfaceSedimentWater - ERR01'

        call GetStatisticParameters (StatisticsID,                                   &
                                     Value2DStat2D = Value2DStat2D,                  &
                                     STAT          = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Statistics - ModuleInterfaceSedimentWater - ERR02'

        if (MethodStatistic /= Value2DStat2D) stop 'OutPut_Statistics - ModuleInterfaceSedimentWater - ERR03'


        call ModifyStatistic (StatisticsID,                                              &
                              Value2D       = Value2D,                                   &
                              WaterPoints2D = Me%ExtWater%WaterPoints2D,                 &
                              STAT          = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Statistics - ModuleInterfaceSedimentWater - ERR04'

    end subroutine OutPut_Statistics


    !--------------------------------------------------------------------------


    subroutine Benthos_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property   ),       pointer     :: PropertyX
        type (T_BenthicRate),       pointer     :: BenthicRateX
        integer                                 :: WILB, WIUB, WJLB, WJUB
        integer                                 :: i, j, kbottom
        real, dimension(:,:,:),     pointer     :: ConcentrationOld
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        WIUB = Me%WorkSize2D%IUB;  WJUB = Me%WorkSize2D%JUB
        WILB = Me%WorkSize2D%ILB;  WJLB = Me%WorkSize2D%JLB

        CHUNK = CHUNK_J(WJLB, WJUB)

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "Benthos_Processes")

        if (Me%ExternalVar%Now .GE. Me%Coupled%Benthos%NextCompute) then

            PropertyX => Me%FirstProperty

            do while(associated(PropertyX))

                if(PropertyX%ID%IDNumber == Temperature_)then

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%WaterConcentration,     &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR01'

                elseif(PropertyX%ID%IDNumber == Oxygen_  )then

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = WJLB, WJUB
                    do i = WILB, WIUB

                        if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                            kbottom = Me%ExtWater%KFloor_Z(i, j)

                            PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                      Me%ExtWater%VolumeZ(i,j,kbottom)

                        end if

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          Oxygen2D      = PropertyX%WaterConcentration,     &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR04'

                else
                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    if(PropertyX%ID%IsParticulate)then
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%Mass_Available(i,j)     * &
                                                          Me%ExternalVar%GridCellArea(i,j)
                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    else
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    end if
                    !$OMP END PARALLEL

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR05'

                end if

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%Benthos%NextCompute = Me%Coupled%Benthos%NextCompute +               &
                                             Me%Coupled%Benthos%DT_Compute
        end if

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if (PropertyX%Evolution%Benthos) then

                if (Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    if(PropertyX%ID%IsParticulate)then
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%Mass_Available(i,j)     * &
                                                          Me%ExternalVar%GridCellArea(i,j)
                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    else
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                            end if

                        enddo
                        enddo
                        !$OMP END DO
                    end if
                    !$OMP END PARALLEL


                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          DTProp        = PropertyX%Evolution%DTInterval,   &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR06'

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    if(.not. PropertyX%ID%IsParticulate)then
                        !$OMP MASTER
                        call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,    &
                                              ConcentrationX    = ConcentrationOld,         &
                                              PropertyXIDNumber = PropertyX%ID%IDNumber,    &
                                              PropertyXUnits    = WaterPropertyUnits,       &
                                              PropertyXISCoef   = WaterPropertyISCoef,      &
                                              STAT              = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR07'
                        !$OMP END MASTER
                        !$OMP BARRIER

                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)
                                !kg m-2 s-1                = kg m-2 s-1 + (kg - kg/m3 * m3)/(m2 * s)
                                PropertyX%FluxToWater(i,j) = PropertyX%FluxToWater(i,j)                           +   &
                                                             (PropertyX%MassInKg(i,j)                             -   &
                                                              ConcentrationOld(i,j,kbottom) * WaterPropertyISCoef *   &
                                                              Me%ExtWater%VolumeZ(i,j,kbottom))                   /   &
                                                             (Me%ExternalVar%GridCellArea(i,j)                    *   &
                                                              PropertyX%Evolution%DTInterval)

                            end if

                        enddo
                        enddo
                        !$OMP END DO

                        !$OMP MASTER
                        call UnGetWaterProperties(Me%ObjWaterProperties, ConcentrationOld, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR08'
                        !$OMP END MASTER
                    else
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%Mass_Available(i,j) =  PropertyX%MassInKg(i,j) / &
                                                                 Me%ExternalVar%GridCellArea(i,j)
                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    end if
                    !$OMP END PARALLEL
                end if

            end if

            PropertyX => PropertyX%Next

        end do

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "Benthos_Processes")

        BenthicRateX => Me%FirstBenthicRate

        do while (associated(BenthicRateX))

            call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
                             FirstProp      = BenthicRateX%FirstProp%IDNumber,          &
                             SecondProp     = BenthicRateX%SecondProp%IDNumber,         &
                             RateFlux2D     = BenthicRateX%Field,                       &
                             WaterPoints2D  = Me%ExtWater%WaterPoints2D,                &
                             STAT           = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR09'

            where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
                BenthicRateX%Field = BenthicRateX%Field * Me%ExternalVar%GridCellArea / &
                                     Me%Coupled%Benthos%DT_Compute


            call BoxDif(Me%ObjBoxDif,                                                   &
                        BenthicRateX%Field,                                             &
                        BenthicRateX%ID%Name,                                           &
                        Me%ExtWater%WaterPoints2D,                                      &
                        STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR10'

            BenthicRateX => BenthicRateX%Next
        enddo


    end subroutine Benthos_Processes


!--------------------------------------------------------------------------

subroutine BenthicEcology_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property   ),       pointer     :: PropertyX
        type (T_BenthicRate),       pointer     :: BenthicRateX
        integer                                 :: WILB, WIUB, WJLB, WJUB
        integer                                 :: KLBW,KUBW, KLBS, KUBS
        integer                                 :: i, j, k, kbottom, ktop
        real, dimension(:,:,:),     pointer     :: ConcentrationOld
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef
        !real, dimension(:,:,:), pointer         :: WaterPropertyConcentration
        real, dimension(:,:,:),     pointer     :: ShortWaveRadiationAverage
        real, dimension(:,:,:),     pointer     :: UptakeNH4NO3w3D
        real, dimension(:,:,:),     pointer     :: UptakePO4w3D
        real, dimension(:,:,:),     pointer     :: LightFactor3D
        real, dimension(:,:,:),     pointer     :: UptakeNH4s3D
        real, dimension(:,:,:),     pointer     :: UptakePO4s3D
        real, dimension(:,:  ),     pointer     :: Biomass
        real, dimension(:,:  ),     pointer     :: Array2D
        integer                                 :: CHUNK


        !Begin-----------------------------------------------------------------
        KLBW = Me%WaterWorkSize3D%KLB   ; KUBW = Me%WaterWorkSize3D%KUB
        KLBS = Me%SedimentWorkSize3D%KLB; KUBS = Me%SedimentWorkSize3D%KUB

        WIUB = Me%WorkSize2D%IUB;  WJUB = Me%WorkSize2D%JUB
        WILB = Me%WorkSize2D%ILB;  WJLB = Me%WorkSize2D%JLB

        CHUNK = CHUNK_J(WJLB, WJUB)

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "BenthicEcology_Processes")

        if (Me%ExternalVar%Now .GE. Me%Coupled%BenthicEcology%NextCompute) then

         call GetShortWaveRadiationAverage(Me%ObjWaterProperties, ShortWaveRadiationAverage, STAT = STAT_CALL)
         if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR01'

                !$OMP PARALLEL PRIVATE(i,j,kbottom)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WJLB, WJUB
                do i = WILB, WIUB

                    if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                        kbottom = Me%ExtWater%KFloor_Z(i, j)

                        Me%ExtWater%WaterVolume(i,j) =  Me%ExtWater%VolumeZ(i,j,kbottom)
                        Me%BottomSWRadiationAverage(i,j) = ShortWaveRadiationAverage(i,j,kbottom)

                    end if

                enddo
                enddo
                !$OMP END DO
                !$OMP END PARALLEL

            call UnGetWaterProperties(Me%ObjWaterProperties, ShortWaveRadiationAverage, STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR02'

            PropertyX => Me%FirstProperty

            do while(associated(PropertyX))

                if(PropertyX%ID%IDNumber == Temperature_)  then

                    call Modify_Interface(InterfaceID      = Me%ObjInterface,                  &
                                          PropertyID       = PropertyX%ID%IDNumber,            &
                                          Concentration    = PropertyX%WaterConcentration,     &
                                          WaterPoints2D    = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D     = Me%ExtWater%OpenPoints2D,         &
                                          WaterVolume2D    = Me%ExtWater%WaterVolume ,         &
                                          CellArea2D       = Me%ExternalVar%GridCellArea,      &
                                          ShortWave2D      = Me%BottomSWRadiationAverage,      &
                                          ShearStress2D    = Me%Shear_Stress%Tension,          &
                                          STAT             = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR01'

                elseif(PropertyX%ID%IDNumber == Cohesive_Sediment_  )then

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                    do j = WJLB, WJUB
                    do i = WILB, WIUB

                        if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                            kbottom = Me%ExtWater%KFloor_Z(i, j)

                            PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                      Me%ExtWater%VolumeZ(i,j,kbottom)
                        end if

                    enddo
                    enddo
                    !$OMP END DO
                    !$OMP END PARALLEL

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          Sediment      = PropertyX%WaterConcentration,     &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR04'


             elseif(PropertyX%ID%IDNumber == SeagrassesRoots_) then

                Me%Seagrasses%UptakeNH4s2D =0.
                Me%Seagrasses%UptakePO4s2D =0.

                call GetSeagrassesRootsRates(Me%ObjSedimentProperties, RootsUptakeN_, UptakeNH4s3D, STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR08'

                call GetSeagrassesRootsRates(Me%ObjSedimentProperties, RootsUptakeP_, UptakePO4s3D, STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR09'

                    do j = WJLB, WJUB
                        do i = WILB, WIUB

                        if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                            ktop = Me%ExtSed%KTop(i,j)
                            if(Me%SedimentWorkSize3D%KUB > 1)then

                                do k=KLBS, ktop
                                    Me%Seagrasses%UptakeNH4s2D(i,j)=Me%Seagrasses%UptakeNH4s2D(i,j)+UptakeNH4s3D(i,j,k)
                                    Me%Seagrasses%UptakePO4s2D(i,j)=Me%Seagrasses%UptakePO4s2D(i,j)+UptakePO4s3D(i,j,k)
                                enddo
                            else
                                Me%Seagrasses%UptakeNH4s2D(i,j)=UptakeNH4s3D(i,j,ktop)
                                Me%Seagrasses%UptakePO4s2D(i,j)=UptakePO4s3D(i,j,ktop)
                            endif

                        endif
                    enddo
                    enddo

                        call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                            PropertyID    = PropertyX%ID%IDNumber,            &
                                            Concentration = PropertyX%MassInKg,               &
                                            UptakeNH4s2D  = Me%Seagrasses%UptakeNH4s2D,     &
                                            UptakePO4s2D  = Me%Seagrasses%UptakePO4s2D,     &
                                            WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                            OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                            STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR10'

                    call UnGetSedimentProperties(Me%ObjSedimentProperties, UptakeNH4s3D, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR11'

                    call UnGetSedimentProperties(Me%ObjSedimentProperties, UptakePO4s3D, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR11'


                elseif (PropertyX%ID%IDNumber == SeagrassesLeaves_) then

                    Me%Seagrasses%UptakeNH4NO3w2D = 0.
                    Me%Seagrasses%UptakePO4w2D    = 0.
                    Me%Seagrasses%LightFactor2D   = 0.

                    call GetSeagrassesLeavesRates(Me%ObjWaterProperties, LeavesUptakeN_, UptakeNH4NO3w3D, STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR20'

                    call GetSeagrassesLeavesRates(Me%ObjWaterProperties, LeavesLightFactor_ , LightFactor3D, STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR23'

                    call GetSeagrassesLeavesRates(Me%ObjWaterProperties, LeavesUptakeP_   , UptakePO4w3D, STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_)                                            &
                    stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR25'

                    do j = WJLB, WJUB
                    do i = WILB, WIUB

                        if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                            kbottom = Me%ExtWater%KFloor_Z(i, j)

                            if(Me%WaterWorkSize3D%KUB > 1)then
                            ! if the run is 3D in the water column
                                do k=kbottom, KUBW

                                    Me%Seagrasses%UptakeNH4NO3w2D(i,j)=Me%Seagrasses%UptakeNH4NO3w2D(i,j)+ &
                                                                            UptakeNH4NO3w3D(i,j,k)   ! gN/day

                                    Me%Seagrasses%UptakePO4w2D(i,j)=Me%Seagrasses%UptakePO4w2D(i,j)+ &
                                                                            UptakePO4w3D(i,j,k)         ! gP/day

                                    Me%Seagrasses%LightFactor2D(i,j) =Me%Seagrasses%LightFactor2D(i,j)+ &
                                                                            LightFactor3D(i,j,k)

                                enddo
                            else
                                ! if the run is 2D in the water column
                                Me%Seagrasses%UptakeNH4NO3w2D(i,j)= UptakeNH4NO3w3D(i,j,kbottom)   ! gN/day
                                Me%Seagrasses%UptakePO4w2D(i,j) = UptakePO4w3D(i,j,kbottom)         ! gP/day
                                Me%Seagrasses%LightFactor2D(i,j) =LightFactor3D(i,j,kbottom) !dimensionless
                            endif
                        endif
                    enddo
                    enddo

                ! The BenthicEcology modifier is called and the

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                        PropertyID    = PropertyX%ID%IDNumber,            &
                                        Concentration = PropertyX%MassInKg,               &
                                        UptakePO4w2D  = Me%Seagrasses%UptakePO4w2D,     &
                                        UptakeNH4NO3w2D  = Me%Seagrasses%UptakeNH4NO3w2D,     &
                                        LightFactor2D   = Me%Seagrasses%LightFactor2D,     &
                                        WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                        OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                        STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR30'

                    call UnGetWaterProperties(Me%ObjWaterProperties, UptakeNH4NO3w3D, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR31'

                    call UnGetWaterProperties(Me%ObjWaterProperties, UptakePO4w3D, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR32'

                    call UnGetWaterProperties(Me%ObjWaterProperties, LightFactor3D, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR33'

                else

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                    if(PropertyX%ID%IsParticulate)then
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)
                       !For particulate properties, MassInkg is different from Mass_FromWater
                       ! MassInKg is the mass of particulate material (In Kg) laying on the bottom;
                       ! Mass_FromWater is the mass of particulate material (In Kg) in the water cell closest to the bottom
                                PropertyX%MassInKg(i,j) = PropertyX%Mass_Available(i,j)     * &
                                                          Me%ExternalVar%GridCellArea(i,j)
                                PropertyX%WaterConcentration(i,j) = PropertyX%Mass_FromWater(i,j)     / &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)
                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    else
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)
                                !For dissolved properties, MassInkg and Mass_FromWater are the same
                                !PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                !                          Me%ExtWater%VolumeZ(i,j,kbottom)
                                PropertyX%Mass_FromWater(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    end if
                    !$OMP END PARALLEL

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                            PropertyID    = PropertyX%ID%IDNumber,            &
                                            Concentration = PropertyX%MassInKg,               &
                                        MassInKgFromWater = PropertyX%Mass_FromWater,      &
                                            WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                            OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                            STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR05'

                end if

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%BenthicEcology%NextCompute = Me%Coupled%BenthicEcology%NextCompute +               &
                                             Me%Coupled%BenthicEcology%DT_Compute
        end if

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

       if01:   if (PropertyX%Evolution%BenthicEcology) then

        if02:   if (Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                   if1: if(PropertyX%ID%IsParticulate)then
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%Mass_Available(i,j)     * &
                                                          Me%ExternalVar%GridCellArea(i,j)

                                PropertyX%WaterConcentration(i,j) = PropertyX%Mass_FromWater(i,j)     / &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    else
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)
                                ! If the property is dissolved, the mass is retrieved from the water
                                PropertyX%Mass_FromWater(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                                PropertyX%MassInKg(i,j)=0. ! since the property is dissolved, it has no mass on the bottom

                            end if

                        enddo
                        enddo
                        !$OMP END DO
                    end if if1
                    !$OMP END PARALLEL

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                            PropertyID    = PropertyX%ID%IDNumber,            &
                                            Concentration = PropertyX%MassInKg,               &
                                        MassInKgFromWater = PropertyX%Mass_FromWater,      &
                                            WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                            OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                            DTProp        = PropertyX%Evolution%DTInterval,   &
                                            STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR06'

                    !$OMP PARALLEL PRIVATE(i,j,kbottom)
                if2: if(.not. PropertyX%ID%IsParticulate)then
                        !$OMP MASTER
                        call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,    &
                                              ConcentrationX    = ConcentrationOld,         &
                                              PropertyXIDNumber = PropertyX%ID%IDNumber,    &
                                              PropertyXUnits    = WaterPropertyUnits,       &
                                              PropertyXISCoef   = WaterPropertyISCoef,      &
                                              STAT              = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR07'
                        !$OMP END MASTER
                        !$OMP BARRIER

                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)
                                !kg m-2 s-1                = kg m-2 s-1 + (kg - kg/m3 * m3)/(m2 * s)

                                PropertyX%FluxToWater(i,j) = PropertyX%FluxToWater(i,j)                           +   &
                                                            ! (PropertyX%MassInKg(i,j)                             -   &
                                                            (PropertyX%Mass_FromWater(i,j)                             -   &
                                                              ConcentrationOld(i,j,kbottom) * WaterPropertyISCoef *   &
                                                              Me%ExtWater%VolumeZ(i,j,kbottom))                   /   &
                                                             (Me%ExternalVar%GridCellArea(i,j)                    *   &
                                                              PropertyX%Evolution%DTInterval)
                            end if

                        enddo
                        enddo
                        !$OMP END DO

                        !$OMP MASTER
                        call UnGetWaterProperties(Me%ObjWaterProperties, ConcentrationOld, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR08'
                        !$OMP END MASTER
                    else
                        !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%Mass_Available(i,j) =  PropertyX%MassInKg(i,j) / &
                                                                 Me%ExternalVar%GridCellArea(i,j)
                                PropertyX%WaterConcentration(i,j) = PropertyX%Mass_FromWater(i,j)  / &
                                                                 Me%ExtWater%VolumeZ(i,j,kbottom)

                                if(.not.PropertyX%Evolution%BenthicOnly)then

                                        call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,    &
                                                      ConcentrationX    = ConcentrationOld,         &
                                                      PropertyXIDNumber = PropertyX%ID%IDNumber,    &
                                                      PropertyXUnits    = WaterPropertyUnits,       &
                                                      PropertyXISCoef   = WaterPropertyISCoef,      &
                                                      STAT              = STAT_CALL)
                                if(STAT_CALL .ne. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR03'

                                    PropertyX%FluxToWater(i,j) = PropertyX%FluxToWater(i,j)                           +   &
                                                                 (PropertyX%Mass_FromWater(i,j)                    -   &
                                                                  ConcentrationOld(i,j,kbottom) * WaterPropertyISCoef *   &
                                                                  Me%ExtWater%VolumeZ(i,j,kbottom))                   /   &
                                                                 (Me%ExternalVar%GridCellArea(i,j)                    *   &
                                                                  PropertyX%Evolution%DTInterval)

                                    call UnGetWaterProperties(Me%ObjWaterProperties, ConcentrationOld, STAT = STAT_CALL)
                                    if(STAT_CALL .ne. SUCCESS_) &
                                        stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR08'

                                   endif
                            end if

                        enddo
                        enddo
                        !$OMP END DO

                    end if if2
                    !$OMP END PARALLEL
                end if if02

            end if if01

            PropertyX => PropertyX%Next

        end do

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "BenthicEcology_Processes")

            PropertyX => Me%FirstProperty

            do while(associated(PropertyX))

    if11:       if (Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

    if21:         if (PropertyX%ID%IDNumber==SeagrassesLeaves_) then
                        ! if property is seagrassesleaves get the  value
                        ! of their biomass and put it in the water property:
                        ! 1. get seagrassesleaves%biomass from waterproperty
                        ! 2. change seagrassesleaves%biomass equal to to the value of PropertyX%MassInKg/area*1000.
                        ! 3. unget the seagrassesleaves%biomass

                        call GetSeagrassArray2D(Me%ObjWaterProperties, Biomass, &
                                                ArrayID=SeagrassesLeaves_ , STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)&
                            stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

                        ! get the value in g
                        do i=WILB,WIUB
                        do j=WJLB,WJUB
                            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then
                            ! g/m2 =                   Kg       * 1000/m2
                            Biomass(i,j) = PropertyX%MassInKg(i,j)&
                                            * 1000./Me%ExternalVar%Gridcellarea(i,j)
                            endif
                        enddo
                        enddo

                        call UnGetWaterProperties(Me%ObjWaterProperties, Biomass, STAT = STAT_CALL)
                            if(STAT_CALL .ne. SUCCESS_)&
                                stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'

                    elseif(PropertyX%ID%IDNumber==SeagrassesRoots_) then

                        call GetRootsArray2D(Me%ObjSedimentProperties, Biomass, &
                                                ArrayID=SeagrassesRoots_ , STAT = STAT_CALL)
                        if (STAT_CALL .NE. SUCCESS_)                                            &
                        stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

                        ! get the value in g from waterproperties
                        do i=WILB,WIUB
                        do j=WJLB,WJUB
                            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then
                                ! g/m2 =                   Kg       * 1000/m2
                                Biomass(i,j) = PropertyX%MassInKg(i,j)*1000./Me%ExternalVar%Gridcellarea(i,j)
                                if( Biomass(i,j)==0. ) then
                                !write(*,*), 'Zero biomass', i, j ,'reset to minval'
                                Biomass(i,j)=0.000001
                                endif
                            endif
                        enddo
                        enddo

                        call UnGetSedimentProperties(Me%ObjSedimentProperties, Biomass, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'

                    endif if21
                endif if11

                PropertyX => PropertyX%Next

            enddo


        BenthicRateX => Me%FirstBenthicRate

        do while (associated(BenthicRateX))

            call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
                             FirstProp      = BenthicRateX%FirstProp%IDNumber,          &
                             SecondProp     = BenthicRateX%SecondProp%IDNumber,         &
                             RateFlux2D     = BenthicRateX%Field,                       &
                             WaterPoints2D  = Me%ExtWater%WaterPoints2D,                &
                             STAT           = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR55'

          ! This subroutine has been modified to transfer information from BenthicEcology to water properties:
          ! The rates calculated in the BenthicEcology model for seagrasses roots and leaves are transferred as 2D array
          ! to the module waterproperties.

    if111:  if (BenthicRateX%FirstProp%IDNumber==NintFactor_) then

                call GetSeagrassArray2D(Me%ObjWaterProperties, Array2D, ArrayID= NintFactor_, STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

                 Array2D = BenthicRateX%Field

                call UnGetWaterProperties(Me%ObjWaterProperties, Array2D, STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'

                BenthicRateX%Field2 => BenthicRateX%Field

                where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
                BenthicRateX%Field2 = BenthicRateX%Field2 * Me%ExternalVar%GridCellArea

                call BoxDif(Me%ObjBoxDif,                                                   &
                            BenthicRateX%Field2,                                             &
                            BenthicRateX%ID%Name,                                           &
                            Me%ExtWater%WaterPoints2D,                                      &
                            STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR60'

            elseif (BenthicRateX%FirstProp%IDNumber==PintFactor_) then

            call GetSeagrassArray2D(Me%ObjWaterProperties, Array2D, ArrayID= PintFactor_, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

            Array2D = BenthicRateX%Field

            call UnGetWaterProperties(Me%ObjWaterProperties, Array2D, STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'

            BenthicRateX%Field2 => BenthicRateX%Field

            where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
            BenthicRateX%Field2 = BenthicRateX%Field2 * Me%ExternalVar%GridCellArea


            call BoxDif(Me%ObjBoxDif,                                                   &
                        BenthicRateX%Field2,                                             &
                        BenthicRateX%ID%Name,                                           &
                        Me%ExtWater%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR60'

          elseif (BenthicRateX%FirstProp%IDNumber==RootsMort_) then


            call GetRootsArray2D(Me%ObjSedimentProperties, Array2D, ArrayID= RootsMort_, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_)                                            &
            stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

            Array2D = BenthicRateX%Field

            call UnGetSedimentProperties(Me%ObjSedimentProperties, Array2D, STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'

            ! I can eventually make an output for boxes as for the other BenthicEcology
            !rate fluxes, but I have to check how to do a unit conversion .
            BenthicRateX%Field2 => BenthicRateX%Field

            where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
            BenthicRateX%Field2 = BenthicRateX%Field2 * Me%ExternalVar%GridCellArea

            call BoxDif(Me%ObjBoxDif,                                                   &
                        BenthicRateX%Field2,                                             &
                        BenthicRateX%ID%Name,                                           &
                        Me%ExtWater%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR60'

        elseif (BenthicRateX%FirstProp%IDNumber==NintFactorR_) then

            call GetRootsArray2D(Me%ObjSedimentProperties, Array2D, ArrayID= NintFactorR_, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR09'

            Array2D = BenthicRateX%Field

            call UnGetSedimentProperties(Me%ObjSedimentProperties, Array2D, STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'Construct_PropertyValues - ModuleInterfaceSedimentWater - ERR10'

                ! I can eventually make an output for boxes as for the other BenthicEcology
                !rate fluxes, but I have to check how to do a unit conversion .
                BenthicRateX%Field2 => BenthicRateX%Field

                where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
                BenthicRateX%Field2 = BenthicRateX%Field2 * Me%ExternalVar%GridCellArea

            call BoxDif(Me%ObjBoxDif,                                                   &
                        BenthicRateX%Field2,                                             &
                        BenthicRateX%ID%Name,                                           &
                        Me%ExtWater%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR60'
        else

            where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
                BenthicRateX%Field = BenthicRateX%Field * Me%ExternalVar%GridCellArea / &  ! Kg/s?
                                        Me%Coupled%BenthicEcology%DT_Compute

            call BoxDif(Me%ObjBoxDif,                                                   &
                        BenthicRateX%Field,                                             &
                        BenthicRateX%ID%Name,                                           &
                        Me%ExtWater%WaterPoints2D, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR60'

         endif if111

            BenthicRateX => BenthicRateX%Next
        enddo

        !BenthicRateX => Me%FirstBenthicRate

       ! do while (associated(BenthicRateX))

        !    call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
        !                     FirstProp      = BenthicRateX%FirstProp%IDNumber,          &
        !                     SecondProp     = BenthicRateX%SecondProp%IDNumber,         &
        !!                     RateFlux2D     = BenthicRateX%Field,                       &
        !                    WaterPoints2D  = Me%ExtWater%WaterPoints2D,                &
        !                     STAT           = STAT_CALL)
        !    if (STAT_CALL .NE. SUCCESS_)                                                &
        !        stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR09'

        !    where (Me%ExtWater%WaterPoints2D == WaterPoint)                             &
        !        BenthicRateX%Field = BenthicRateX%Field * Me%ExternalVar%GridCellArea / &
        !                             Me%Coupled%BenthicEcology%DT_Compute


        !    call BoxDif(Me%ObjBoxDif,                                                   &
        !                BenthicRateX%Field,                                             &
        !                BenthicRateX%ID%Name,                                           &
        !                Me%ExtWater%WaterPoints2D,                                      &
        !                STAT = STAT_CALL)
         !   if (STAT_CALL .NE. SUCCESS_)                                                &
         !       stop 'BenthicEcology_Processes - ModuleInterfaceSedimentWater - ERR10'

         !   BenthicRateX => BenthicRateX%Next
        !enddo


    end subroutine BenthicEcology_Processes
    !--------------------------------------------------------------------------


    subroutine Detritus_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property),       pointer        :: Detritus
        type (T_Property),       pointer        :: PropertyX
        integer                                 :: WILB, WIUB, WJLB, WJUB, i, j
        integer                                 :: CHUNK

        !Begin-----------------------------------------------------------------

        WIUB = Me%WorkSize2D%IUB
        WJUB = Me%WorkSize2D%JUB
        WILB = Me%WorkSize2D%ILB
        WJLB = Me%WorkSize2D%JLB

        call Search_Property(Detritus, PropertyXID = Detritus_, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Detritus_Processes - ModuleInterfaceSedimentWater - ERR01'

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if(PropertyX%Evolution%Detritus)then

                if (MonitorPerformance) then
                    call StartWatch ("ModuleInterfaceSedimentWater", "Detritus_Processes")
                endif

                CHUNK = CHUNK_J(WJLB, WJUB)
                !$OMP PARALLEL PRIVATE(i,j)
                !$OMP DO SCHEDULE(DYNAMIC,CHUNK)
                do j = WJLB, WJUB
                do i = WILB, WIUB

                    if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                        !DepositionFlux is positive if deposition occurs
                        Detritus%Mass_Available(i,j) = Detritus%Mass_Available(i,j)   + &
                                                       PropertyX%DepositionFlux(i,j)  * &
                                                       PropertyX%Evolution%DTInterval

                        PropertyX%Mass_Available(i,j) = PropertyX%Mass_Available(i,j) - &
                                                        PropertyX%DepositionFlux(i,j) * &
                                                        PropertyX%Evolution%DTInterval
                    end if

                end do
                end do
                !$OMP END DO
                !$OMP END PARALLEL

                if (MonitorPerformance) then
                    call StopWatch ("ModuleInterfaceSedimentWater", "Detritus_Processes")
                endif

            end if

            PropertyX => PropertyX%Next

        end do


    end subroutine Detritus_Processes


    !--------------------------------------------------------------------------


    subroutine CEQUALW2_Processes

        !External--------------------------------------------------------------
        integer                                 :: STAT_CALL

        !Local-----------------------------------------------------------------
        type (T_Property   ),       pointer     :: PropertyX
        type (T_BenthicRate),       pointer     :: BenthicRateX
        integer                                 :: WILB, WIUB, WJLB, WJUB
        integer                                 :: i, j, kbottom
        real, dimension(:,:,:),     pointer     :: ConcentrationOld
        character(len=StringLength)             :: WaterPropertyUnits
        real                                    :: WaterPropertyISCoef

        !Begin-----------------------------------------------------------------

        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "CEQUALW2_Processes")

        WIUB = Me%WorkSize2D%IUB;  WJUB = Me%WorkSize2D%JUB
        WILB = Me%WorkSize2D%ILB;  WJLB = Me%WorkSize2D%JLB

        if (Me%ExternalVar%Now .GE. Me%Coupled%CEQUALW2%NextCompute) then

            PropertyX => Me%FirstProperty

            do while(associated(PropertyX))

                if(PropertyX%ID%IDNumber == Temperature_)then

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%WaterConcentration,     &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          CellArea2D    = Me%ExternalVar%GridCellArea,      &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR01'

                elseif( PropertyX%ID%IDNumber == Oxygen_  )then

                    do j = WJLB, WJUB
                    do i = WILB, WIUB

                        if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                            kbottom = Me%ExtWater%KFloor_Z(i, j)

                            PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                      Me%ExtWater%VolumeZ(i,j,kbottom)

                        end if

                    enddo
                    enddo

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          Oxygen2D      = PropertyX%WaterConcentration,     &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'Benthos_Processes - ModuleInterfaceSedimentWater - ERR04'

                else

                    if(PropertyX%ID%IsParticulate)then

                        do i = WILB, WIUB
                        do j = WJLB, WJUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%Mass_Available(i,j)     * &
                                                          Me%ExternalVar%GridCellArea(i,j)
                            end if

                        enddo
                        enddo

                    else

                        do i = WILB, WIUB
                        do j = WJLB, WJUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                            end if

                        enddo
                        enddo

                    end if

                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR01'

                end if

                PropertyX => PropertyX%Next

            end do

            Me%Coupled%CEQUALW2%NextCompute = Me%Coupled%CEQUALW2%NextCompute +         &
                                              Me%Coupled%CEQUALW2%DT_Compute

        end if

        PropertyX => Me%FirstProperty

        do while(associated(PropertyX))

            if (PropertyX%Evolution%CEQUALW2) then

                if (Me%ExternalVar%Now .GE. PropertyX%Evolution%NextCompute) then

                    if(PropertyX%ID%IsParticulate)then

                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%Mass_Available(i,j)     * &
                                                          Me%ExternalVar%GridCellArea(i,j)
                            end if

                        enddo
                        enddo

                    else

                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%MassInKg(i,j) = PropertyX%WaterConcentration(i,j) * &
                                                          Me%ExtWater%VolumeZ(i,j,kbottom)

                            end if

                        enddo
                        enddo

                    end if


                    call Modify_Interface(InterfaceID   = Me%ObjInterface,                  &
                                          PropertyID    = PropertyX%ID%IDNumber,            &
                                          Concentration = PropertyX%MassInKg,               &
                                          WaterPoints2D = Me%ExtWater%WaterPoints2D,        &
                                          OpenPoints2D  = Me%ExtWater%OpenPoints2D,         &
                                          DTProp        = PropertyX%Evolution%DTInterval,   &
                                          STAT          = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR02'

                    if(.not. PropertyX%ID%IsParticulate)then

                        call GetConcentration(WaterPropertiesID = Me%ObjWaterProperties,    &
                                              ConcentrationX    = ConcentrationOld,         &
                                              PropertyXIDNumber = PropertyX%ID%IDNumber,    &
                                              PropertyXUnits    = WaterPropertyUnits,       &
                                              PropertyXISCoef   = WaterPropertyISCoef,      &
                                              STAT              = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR03'

                        do j = WJLB, WJUB
                        do i = WILB, WIUB

                            if(Me%ExtWater%OpenPoints2D(i,j) == OpenPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)
                                !kg m-2 s-1                = kg m-2 s-1 + (kg - kg/m3 * m3)/(m2 * s)
                                PropertyX%FluxToWater(i,j) = PropertyX%FluxToWater(i,j)                           +   &
                                                             (PropertyX%MassInKg(i,j)                             -   &
                                                              ConcentrationOld(i,j,kbottom) * WaterPropertyISCoef *   &
                                                              Me%ExtWater%VolumeZ(i,j,kbottom))                   /   &
                                                             (Me%ExternalVar%GridCellArea(i,j)                    *   &
                                                              PropertyX%Evolution%DTInterval)

                            end if

                        enddo
                        enddo

                        call UnGetWaterProperties(Me%ObjWaterProperties, ConcentrationOld, STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR04'
                    else

                        do i = WILB, WIUB
                        do j = WJLB, WJUB

                            if(Me%ExtWater%WaterPoints2D(i,j) == WaterPoint)then

                                kbottom = Me%ExtWater%KFloor_Z(i, j)

                                PropertyX%Mass_Available(i,j) =  PropertyX%MassInKg(i,j) / &
                                                                 Me%ExternalVar%GridCellArea(i,j)
                            end if

                        enddo
                        enddo

                    end if

                end if

            end if

            PropertyX => PropertyX%Next

        end do

        BenthicRateX => Me%FirstBenthicRate

        do while (associated(BenthicRateX))

            call GetRateFlux(InterfaceID    = Me%ObjInterface,                          &
                             FirstProp      = BenthicRateX%FirstProp%IDNumber,          &
                             SecondProp     = BenthicRateX%SecondProp%IDNumber,         &
                             RateFlux2D     = BenthicRateX%Field,                       &
                             WaterPoints2D  = Me%ExtWater%WaterPoints2D,                &
                             STAT           = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR05'

            where (Me%ExtWater%WaterPoints2D == WaterPoint)           &
                BenthicRateX%Field = BenthicRateX%Field             * &
                                     Me%ExternalVar%GridCellArea    / &
                                     Me%Coupled%CEQUALW2%DT_Compute


            call BoxDif(Me%ObjBoxDif,                                                   &
                        BenthicRateX%Field,                                             &
                        BenthicRateX%ID%Name,                                           &
                        Me%ExtWater%WaterPoints2D,                                      &
                        STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'CEQUALW2_Processes - ModuleInterfaceSedimentWater - ERR06'

            BenthicRateX => BenthicRateX%Next

        enddo

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "CEQUALW2_Processes")


    end subroutine CEQUALW2_Processes

    !--------------------------------------------------------------------------

    subroutine OutPut_Results_HDF
        !Arguments--------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL
        real                                :: Year, Month, Day, Hour, Minute, Second

        !Local-----------------------------------------------------------------
        character(len=StringLength)         :: PropertyName, GroupName
        type (T_Property), pointer          :: PropertyX
        integer                             :: OutPutNumber
        integer, dimension(6)               :: TimeAux
        real,    dimension(6), target       :: AuxTime
        real,    dimension(:), pointer      :: TimePtr
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        integer                             :: WorkKLB, WorkKUB
        !----------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "OutPut_Results_HDF")

        WorkILB = Me%WaterWorkSize3D%ILB;  WorkJLB = Me%WaterWorkSize3D%JLB;  WorkKLB = Me%WaterWorkSize3D%KLB
        WorkIUB = Me%WaterWorkSize3D%IUB;  WorkJUB = Me%WaterWorkSize3D%JUB;  WorkKUB = Me%WaterWorkSize3D%KUB

        OutPutNumber = Me%OutPut%NextOutPut


TOut:   if (Me%ExternalVar%Now >= Me%OutPut%OutTime(OutPutNumber)) then

            call ExtractDate(Me%ExternalVar%Now,                         &
                             Year = Year, Month  = Month,  Day    = Day, &
                             Hour = Hour, Minute = Minute, Second = Second)

            TimeAux(1) = int(Year  )
            TimeAux(2) = int(Month )
            TimeAux(3) = int(Day   )
            TimeAux(4) = int(Hour  )
            TimeAux(5) = int(Minute)
            TimeAux(6) = int(Second)

            !Writes current time
            call ExtractDate   (Me%ExternalVar%Now,                  &
                                AuxTime(1), AuxTime(2), AuxTime(3),  &
                                AuxTime(4), AuxTime(5), AuxTime(6))
            TimePtr => AuxTime
            call HDF5SetLimits  (Me%ObjHDF5, 1, 6, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR10'

            call HDF5WriteData  (Me%ObjHDF5, "/Time", "Time", "YYYY/MM/DD HH:MM:SS", &
                                 Array1D = TimePtr, OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR20'

            call HDF5SetLimits  (Me%ObjHDF5, WorkILB, WorkIUB,                 &
                                 WorkJLB, WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR30'

            call HDF5WriteData  (Me%ObjHDF5, "/Grid/OpenPoints", "OpenPoints", &
                                 "-", Array3D = Me%ExtWater%OpenPoints3D,      &
                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR40'

            PropertyName = GetPropertyName(ShearStress_)
            GroupName    = "/Results/"//trim(PropertyName)

            call HDF5WriteData (HDF5ID         = Me%ObjHDF5,                            &
                                GroupName      = trim(GroupName),                       &
                                Name           = trim(PropertyName),                    &
                                Units          = "Pa",                                  &
                                Array2D        = Me%Shear_Stress%Tension,               &
                                OutputNumber   = OutPutNumber,                          &
                                STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR50'

            PropertyName = GetPropertyName(ShearStressX_)
            GroupName    = "/Results/"//trim(PropertyName)

            call HDF5WriteData (HDF5ID         = Me%ObjHDF5,                            &
                                GroupName      = trim(GroupName),                       &
                                Name           = trim(PropertyName),                    &
                                Units          = "Pa",                                  &
                                Array2D        = Me%Shear_Stress%Tension_X,             &
                                OutputNumber   = OutPutNumber,                          &
                                STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR60'

            PropertyName = GetPropertyName(ShearStressY_)
            GroupName    = "/Results/"//trim(PropertyName)

            call HDF5WriteData (HDF5ID         = Me%ObjHDF5,                            &
                                GroupName      = trim(GroupName),                       &
                                Name           = trim(PropertyName),                    &
                                Units          = "Pa",                                  &
                                Array2D        = Me%Shear_Stress%Tension_Y,             &
                                OutputNumber   = OutPutNumber,                          &
                                STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR70'

            if(Me%ComputeRugosity)then
                call HDF5WriteData  (Me%ObjHDF5, "/Results/Rugosity", "Rugosity",  &
                                     "N/m2", Array2D = Me%Rugosity%Field,          &
                                     OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR080'
            endif

            if(Me%Consolidation%Yes)then

                call HDF5WriteData  (Me%ObjHDF5, "/Results/Consolidation",          &
                                     "consolidation flux",                          &
                                     "kg/m2s", Array2D = Me%Consolidation%Flux,     &
                                     OutputNumber = OutPutNumber, STAT = STAT_CALL)
                if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR90'

            end if

            PropertyX => Me%FirstProperty

PropX:      do while (associated(PropertyX))

                if(PropertyX%OutputHDF)then

                    if(PropertyX%Mass_Limitation)then

                        if(PropertyX%OutHDForigin) then

                            call HDF5WriteData  (Me%ObjHDF5, "/Results/"//PropertyX%ID%Name,                &
                                                 PropertyX%ID%Name, PropertyX%ID%Units,                     &
                                                 Array2D = PropertyX%MassInKg,                              &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater -ERR100'

                        else

                            call HDF5WriteData  (Me%ObjHDF5, "/Results/"//PropertyX%ID%Name,                &
                                                 PropertyX%ID%Name, PropertyX%ID%Units,                     &
                                                 Array2D = PropertyX%Mass_Available,                        &
                                                 OutputNumber = OutPutNumber, STAT = STAT_CALL)
                            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater -ERR110'

                        end if

                    end if

                    if(PropertyX%Evolution%WaterFluxes)then

                        call HDF5WriteData  (Me%ObjHDF5, "/Results/FluxToWater/"//PropertyX%ID%Name,    &
                                             PropertyX%ID%Name, 'kg/m2s',                               &
                                             Array2D = PropertyX%FluxToWater,                           &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR07'

                    end if

                    if(PropertyX%Evolution%SedimentWaterFluxes)then

                        call HDF5WriteData  (Me%ObjHDF5, "/Results/FluxToSediment/"//PropertyX%ID%Name, &
                                             PropertyX%ID%Name, 'kg/m2s',                               &
                                             Array2D = PropertyX%FluxToSediment,                        &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR120'

                    end if

                    if(PropertyX%Evolution%Deposition)then

                        call HDF5WriteData  (Me%ObjHDF5, "/Results/Deposition/"//PropertyX%ID%Name,     &
                                             PropertyX%ID%Name, 'kg/m2s',                               &
                                             Array2D = PropertyX%DepositionFlux,                        &
                                             OutputNumber = OutPutNumber, STAT = STAT_CALL)
                        if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR130'

                    end if

                end if

                PropertyX => PropertyX%Next

            enddo PropX

            !Writes everything to disk
            call HDF5FlushMemory (Me%ObjHDF5, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'OutPut_Results_HDF - ModuleInterfaceSedimentWater - ERR140'

            Me%OutPut%NextOutPut = OutPutNumber + 1

        endif  TOut

        nullify(PropertyX)

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "OutPut_Results_HDF")

    end subroutine OutPut_Results_HDF

    !--------------------------------------------------------------------------

    subroutine OutPut_Residual_HDF
        !Arguments--------------------------------------------------------------

        !External--------------------------------------------------------------
        integer                             :: STAT_CALL

        !Local-----------------------------------------------------------------
        character(len=StringLength)         :: PropertyName, GroupName
        integer                             :: WorkILB, WorkIUB, WorkJLB, WorkJUB
        !----------------------------------------------------------------------


        if (MonitorPerformance) call StartWatch ("ModuleInterfaceSedimentWater", "OutPut_Residual_HDF")

        WorkILB = Me%WaterWorkSize3D%ILB
        WorkIUB = Me%WaterWorkSize3D%IUB
        WorkJLB = Me%WaterWorkSize3D%JLB
        WorkJUB = Me%WaterWorkSize3D%JUB

        call HDF5SetLimits  (Me%ObjHDF5, WorkILB, WorkIUB,                              &
                             WorkJLB, WorkJUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'OutPut_Residual_HDF - ModuleInterfaceSedimentWater - ERR10'
        endif


        PropertyName = GetPropertyName(ShearStress_)
        GroupName    = "/Residual/"//trim(PropertyName)

        call HDF5WriteData (HDF5ID         = Me%ObjHDF5,                                &
                            GroupName      = trim(GroupName),                           &
                            Name           = trim(PropertyName),                        &
                            Units          = "Pa",                                      &
                            Array2D        = Me%Shear_Stress%Residual_Tau,              &
                            STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'OutPut_Residual_HDF - ModuleInterfaceSedimentWater - ERR20'
        endif

        PropertyName = GetPropertyName(ShearStressX_)
        GroupName    = "/Residual/"//trim(PropertyName)

        call HDF5WriteData (HDF5ID         = Me%ObjHDF5,                                &
                            GroupName      = trim(GroupName),                           &
                            Name           = trim(PropertyName),                        &
                            Units          = "Pa",                                      &
                            Array2D        = Me%Shear_Stress%Residual_Tau_X,            &
                            STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'OutPut_Residual_HDF - ModuleInterfaceSedimentWater - ERR30'
        endif

        PropertyName = GetPropertyName(ShearStressY_)
        GroupName    = "/Residual/"//trim(PropertyName)

        call HDF5WriteData (HDF5ID         = Me%ObjHDF5,                                &
                            GroupName      = trim(GroupName),                           &
                            Name           = trim(PropertyName),                        &
                            Units          = "Pa",                                      &
                            Array2D        = Me%Shear_Stress%Residual_Tau_Y,            &
                            STAT           = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'OutPut_Residual_HDF - ModuleInterfaceSedimentWater - ERR40'
        endif

        !Writes everything to disk
        call HDF5FlushMemory (Me%ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) then
            stop 'OutPut_Residual_HDF - ModuleInterfaceSedimentWater - ERR50'
        endif

        if (MonitorPerformance) call StopWatch ("ModuleInterfaceSedimentWater", "OutPut_Residual_HDF")

    end subroutine OutPut_Residual_HDF

    !--------------------------------------------------------------------------


    subroutine OutputRestartFile

        !Local-----------------------------------------------------------------
        real                                :: Year, Month, Day, Hour, Minute, Second

        !----------------------------------------------------------------------


        if(Me%ExternalVar%Now >= Me%OutPut%RestartOutTime(Me%OutPut%NextRestartOutput))then

            call ExtractDate(Me%ExternalVar%Now,                         &
                             Year = Year, Month  = Month,  Day    = Day, &
                             Hour = Hour, Minute = Minute, Second = Second)

            call Write_Final_HDF

            Me%OutPut%NextRestartOutput = Me%OutPut%NextRestartOutput + 1

            call SetError(WARNING_, INTERNAL_, "Interface Sed.Water restart file saved : ", &
                                  Year, Month, Day, Hour, Minute, Second)

        end if


    end subroutine OutputRestartFile


    !--------------------------------------------------------------------------
    ! This subroutine is responsable for defining
    ! the next time to actualize the value of each
    ! property
    subroutine Actualize_Time_Evolution

        !Local-----------------------------------------------------------------
        type (T_Property), pointer :: Property

        !----------------------------------------------------------------------

        Property => Me%FirstProperty

        do while (associated(Property))

            if (Property%Evolution%Variable) then
                if (Me%ExternalVar%Now.GE.Property%Evolution%NextCompute) then
                        Property%Evolution%LastCompute = Property%Evolution%NextCompute
                        Property%Evolution%NextCompute = Property%Evolution%NextCompute &
                                                       + Property%Evolution%DTInterval
                end if
            end if


            Property => Property%Next
        end do

        nullify(Property)

    end subroutine Actualize_Time_Evolution


    !--------------------------------------------------------------------------


    subroutine SetSubModulesModifier

        !Local-----------------------------------------------------------------
        !logical                                         :: WavesStressON
        integer                                         :: STAT_CALL
        type(T_Property), pointer                       :: SPM
        type(T_Property), pointer                       :: PropertyX

        !Begin-----------------------------------------------------------------


        call SetFluxesToWaterColumn

        if(Me%MacroAlgae)then

            call Search_Property(SPM, PropertyXID = Cohesive_Sediment_, STAT = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR10'

            call SetMacroAlgaeParameters(WaterPropertiesID = Me%ObjWaterProperties,     &
                                         ShearStress       = Me%Shear_Stress%Tension,   &
                                         SPMFlux           = SPM%DepositionFlux,        &
                                         STAT              = STAT_CALL)
            if (STAT_CALL .NE. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR20'

            nullify(SPM)

        endif

#ifndef _SEDIMENT_

        if(Me%RunSedimentModule)then

            PropertyX => Me%FirstProperty

            do while(associated(PropertyX))

                if(PropertyX%Non_Cohesive) then

                    call SetNonCohesiveFlux(Me%ObjSediment, PropertyX%ID%IDNumber, PropertyX%FluxToSediment,    &
                                              STAT = STAT_CALL)
                    if (STAT_CALL .NE. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR30'
                endif

                PropertyX => PropertyX%Next

            enddo

            if(Me%Consolidation%Yes)then
                call SetCohesiveFlux(Me%ObjSediment, Me%Consolidation%Flux,                                     &
                                          STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR40'
            endif

        endif

        if(Me%RunsSediments)then
            if(Me%Consolidation%Yes)then

                call SetFluxesToSedimentColumn

                call SetConsolidationFlux(Me%ObjConsolidation, Me%Consolidation%Flux,               &
                                            STAT = STAT_CALL)
                if (STAT_CALL .NE. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR50'

                call SetBottomWaterFlux(Me%ObjHydrodynamic,                                         &
                                        Me%WaterFlux,                                               &
                                        STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR60'

                call SetSedimentWaterFlux(Me%ObjSedimentProperties,                                 &
                                            Me%WaterFlux,                                             &
                                            STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR70'

            endif
        endif

#endif

        if(Me%ObjTurbGOTM /= 0)then
            call SetTurbGOTMBottomShearVelocity(TurbGOTMID          = Me%ObjTurbGOTM,           &
                                                BottomShearVelocity = Me%Shear_Stress%Velocity, &
                                                STAT                = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR80'

            call SetTurbGOTMBottomRugosity(TurbGOTMID     = Me%ObjTurbGOTM,                     &
                                           BottomRugosity = Me%Rugosity%Field,                  &
                                           STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR90'
        end if

#ifndef _LAGRANGIAN_
        if(Me%ObjLagrangian /= 0)then
#ifdef  _LAGRANGIAN_GLOBAL_
            call SetLagrangianShearGlobal                                               &
                                   (LagrangianID   = Me%ObjLagrangian,                  &
                                    ModelName      = Me%ModelName,                      &
                                    ShearStress    = Me%Shear_Stress%Tension,           &
                                    ShearVelocity  = Me%Shear_Stress%Velocity,          &
                                    STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR100'
#else
            call SetLagrangianShear(LagrangianID   = Me%ObjLagrangian,                  &
                                    ShearStress    = Me%Shear_Stress%Tension,           &
                                    ShearVelocity  = Me%Shear_Stress%Velocity,          &
                                    STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR110'
#endif
        end if
#endif

        if(Me%ObjFreeVerticalMovement /= 0)then

            call SetDepositionProbability(Me%ObjFreeVerticalMovement,                   &
                                          Me%DepositionProbability,                     &
                                          STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR120'

            call SetShearVelocity (Me%ObjFreeVerticalMovement,                          &
                                          Me%Shear_Stress%Velocity,                     &
                                          STAT = STAT_CALL)
            if(STAT_CALL .ne. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR121'
        end if

        if (Me%ObjHydrodynamic /= 0) then

            !call GetWavesStressON(Me%ObjHydrodynamic,                                &
            !                     WavesStressON, STAT = STAT_CALL)
            !if(STAT_CALL .ne. SUCCESS_)                                              &
            !    stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR130'

            if (Me%WaveShear_Stress%Yes) then

                if (Me%Shear_Stress%Method==1) then

                    call SetWaveChezyVel(Me%ObjHydrodynamic,                             &
                                         Me%WaveShear_Stress%ChezyVel,                   &
                                         STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'SetSubModulesModifier - ModuleInterfaceSedimentWater - ERR140'
                endif
            endif
        endif


    end subroutine SetSubModulesModifier

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR DESTRUCTOR

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



    subroutine KillInterfaceSedimentWater(ObjInterfaceSedimentWaterID, STAT)

        !Arguments---------------------------------------------------------------
        integer                             :: ObjInterfaceSedimentWaterID
        integer, optional, intent(OUT)      :: STAT

        !External----------------------------------------------------------------
        integer                             :: ready_, STAT_CALL, nUsers

        !Local-------------------------------------------------------------------
        integer                             :: STAT_
        type (T_Property),    pointer       :: PropertyX
        type (T_BenthicRate), pointer       :: BenthicRateX

        !------------------------------------------------------------------------

        STAT_ = UNKNOWN_

        call Ready(ObjInterfaceSedimentWaterID, ready_)

cd1 :   if (ready_ .NE. OFF_ERR_) then

            nUsers = DeassociateInstance(mINTERFACESEDIMENTWATER_,  Me%InstanceID)

            if (nUsers == 0) then

                if (Me%OutPut%Yes) then

                    if (Me%Shear_Stress%OutputON .and. Me%ExtWater%ResidualON) then
                        call OutPut_Residual_HDF
                    endif

                    call KillHDF5 (Me%ObjHDF5, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR10'
                endif

                if (Me%Shear_Stress%Statistics%ON) then
                    call KillStatistic (Me%Shear_Stress%Statistics%ID, STAT = STAT_CALL)
                    stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR20'
                endif

                if (Me%RunsSandTransport) then

                    call KillSand(Me%ObjSand, STAT = STAT_CALL)

                    if(STAT_CALL /= SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR20'

                endif

                call ReadLockExternalGlobal

                call ReadLockExternalWater
#ifndef _SEDIMENT_
                if(Me%RunsSediments.or.Me%RunSedimentModule) call ReadLockExternalSediment
#endif
                if (Me%OutPut%WriteFinalFile) call Write_Final_HDF( Final = .true.)

#ifndef _SEDIMENT_
                if(Me%RunsSediments.or.Me%RunSedimentModule) call ReadUnlockExternalSediment
#endif
                call ReadUnlockExternalWater

                call ReadUnlockExternalGlobal


                nUsers = DeassociateInstance(mTIME_,            Me%ObjTime)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR40'

                nUsers = DeassociateInstance(mHORIZONTALGRID_,  Me%ObjHorizontalGrid)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR50'

                nUsers = DeassociateInstance(mGRIDDATA_,        Me%ObjWaterGridData)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR60'

                nUsers = DeassociateInstance(mHORIZONTALMAP_,   Me%ObjWaterHorizontalMap)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR70'

                nUsers = DeassociateInstance(mGEOMETRY_,        Me%ObjWaterGeometry)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR80'

                nUsers = DeassociateInstance(mMAP_,             Me%ObjWaterMap)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR90'

                nUsers = DeassociateInstance(mTURBULENCE_,      Me%ObjTurbulence)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR110'

                nUsers = DeassociateInstance(mHYDRODYNAMIC_,    Me%ObjHydrodynamic)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR120'

                nUsers = DeassociateInstance(mWATERPROPERTIES_, Me%ObjWaterProperties)
                if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR130'

#ifndef _LAGRANGIAN_
                if(Me%ObjLagrangian /= 0)then
                    nUsers = DeassociateInstance(mLAGRANGIAN_, Me%ObjLagrangian)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR140'
                end if
#endif

                if(Me%ObjTurbGOTM /= 0)then
                    nUsers = DeassociateInstance(mTURBGOTM_, Me%ObjTurbGOTM)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR150'
                end if


                if(Me%ObjFreeVerticalMovement /= 0)then
                    nUsers = DeassociateInstance(mFREEVERTICALMOVEMENT_, Me%ObjFreeVerticalMovement)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR160'
                end if

                if(Me%RunsSediments.or.Me%RunSedimentModule)then

                    nUsers = DeassociateInstance(mGRIDDATA_,        Me%ObjSedimentGridData)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR170'

                    nUsers = DeassociateInstance(mHORIZONTALMAP_,   Me%ObjSedimentHorizontalMap)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR180'

                    nUsers = DeassociateInstance(mGEOMETRY_,        Me%ObjSedimentGeometry)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR190'

                    nUsers = DeassociateInstance(mMAP_,             Me%ObjSedimentMap)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR200'
#ifndef _SEDIMENT_
                    if(Me%RunSedimentModule)then
                        nUsers = DeassociateInstance(mSEDIMENT_, Me%ObjSediment)
                        if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR210'
                    else
                        nUsers = DeassociateInstance(mSEDIMENTPROPERTIES_, Me%ObjSedimentProperties)
                        if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR220'

                        nUsers = DeassociateInstance(mCONSOLIDATION_,   Me%ObjConsolidation)
                        if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR230'
                    endif
#endif
                end if

                if (Me%Coupled%BoxTimeSerie%Yes) then

                    call KillBoxDif(Me%ObjBoxDif, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater -ERR240'

                    deallocate(Me%Scalar2D, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater -ERR250'
                    nullify(Me%Scalar2D)

                end if

                !Kills the TimeSerie
                if (Me%Coupled%TimeSerie%Yes) then
                    call KillTimeSerie(Me%ObjTimeSerie, STAT = STAT_CALL)
                    if (STAT_CALL /= SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater -ERR260'
                endif

                deallocate(Me%Shear_Stress%Tension,    STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR270'
                nullify(Me%Shear_Stress%Tension)

                deallocate(Me%Shear_Stress%Tension_X,    STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                    stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR270'
                nullify(Me%Shear_Stress%Tension_X)

                deallocate(Me%Shear_Stress%Tension_Y,    STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_)&
                    stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR280'
                nullify(Me%Shear_Stress%Tension_Y)


                deallocate(Me%Shear_Stress%Velocity,   STAT = STAT_CALL)
                if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR280'
                nullify(Me%Shear_Stress%Velocity)

                if(Me%UseSOD)then
                    deallocate(Me%SOD%Field,   STAT = STAT_CALL)
                    if(STAT_CALL /= SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR290'
                    nullify(Me%SOD%Field)
                endif

                if (Me%RunsSandTransport.or.Me%RunSedimentModule) then

                    deallocate(Me%Shear_Stress%CurrentVel,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR300'
                    nullify(Me%Shear_Stress%CurrentVel)

                    deallocate(Me%Shear_Stress%CurrentU,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR310'
                    nullify(Me%Shear_Stress%CurrentU)

                    deallocate(Me%Shear_Stress%CurrentV,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR320'
                    nullify(Me%Shear_Stress%CurrentV)

                    if (associated(Me%Shear_Stress%CurrentResidualU)) then
                        deallocate(Me%Shear_Stress%CurrentResidualU,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_) &
                          stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR330'
                        nullify(Me%Shear_Stress%CurrentResidualU)
                    endif

                    if (associated(Me%Shear_Stress%CurrentResidualV)) then
                        deallocate(Me%Shear_Stress%CurrentResidualV,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR340'
                        nullify(Me%Shear_Stress%CurrentResidualV)
                    endif

                    deallocate(Me%Shear_Stress%UFace,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater -ERR350'
                    nullify(Me%Shear_Stress%UFace)

                    deallocate(Me%Shear_Stress%VFace,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater -ERR360'
                    nullify(Me%Shear_Stress%VFace)

                endif

                if (Me%RunSedimentModule) then

                    deallocate(Me%Shear_Stress%EfficiencyFactorCurrent,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR370'
                    nullify(Me%Shear_Stress%EfficiencyFactorCurrent)

                endif

                if (Me%WaveShear_Stress%Yes) then

                    !Shear stress
                    deallocate(Me%WaveShear_Stress%Tension        )

                    deallocate(Me%WaveShear_Stress%ChezyVel       )

                    if (Me%Shear_Stress%Method==1) then
                        deallocate(Me%WaveShear_Stress%Rugosity%Field )
                    endif

                    if (Me%RunsSandTransport) then
                        deallocate(Me%WaveShear_Stress%TensionCurrents)
                    endif

                    if (Me%RunSedimentModule) then
                        deallocate(Me%WaveShear_Stress%Cphi, Me%WaveShear_Stress%CWphi)
                        deallocate(Me%Shear_Stress%EfficiencyFactorMean)
                        deallocate(Me%Shear_Stress%EfficiencyFactorWaves)
                    endif

                endif

                if (.not. Me%Chezy) then

                    if(Me%Manning)then
                        deallocate(Me%ManningCoef%Field,    STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR28'
                        nullify(Me%ManningCoef%Field)
                    else
                        deallocate(Me%Rugosity%Field,       STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR29'
                        nullify(Me%Rugosity%Field)
                    endif

                endif

#ifndef _WAVES_

                if (Me%ObjWaves /= 0) then
                    nUsers = DeassociateInstance (mWAVES_,Me%ObjWaves)
                    if (nUsers == 0) stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR30'
                end if
#endif

                if(Me%Consolidation%Yes)then

                    deallocate(Me%Consolidation%Flux,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR310'
                    nullify(Me%Consolidation%Flux)

                    if(Me%RunsSediments)then
                        deallocate(Me%Consolidation%Rate%Field,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR311'
                        nullify(Me%Consolidation%Rate%Field)
                    endif

                endif

                if(Me%Coupled%Erosion%Yes)then

                    deallocate(Me%ErosionRate%Field,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR31'
                    nullify(Me%ErosionRate%Field)

                    deallocate(Me%Critical_Shear_Deposition%Field,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR32'
                    nullify(Me%Critical_Shear_Deposition%Field)

                    deallocate(Me%Critical_Shear_Erosion%Field,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR33'
                    nullify(Me%Critical_Shear_Erosion%Field)

                end if

                if(Me%Coupled%Deposition%Yes)then
                    deallocate(Me%DepositionProbability, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ER41'
                    nullify(Me%DepositionProbability)
                end if

                if (Me%Coupled%Benthos%Yes) then
                    call KillInterface (Me%ObjInterface, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ER41a'
                endif


                if (Me%Coupled%CEQUALW2%Yes) then
                    call KillInterface (Me%ObjInterface, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ER41b'
                endif


                if (Me%Coupled%BenthicEcology%Yes) then
                    call KillInterface (Me%ObjInterface, STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR601'


                    deallocate(Me%ExtWater%WaterVolume, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR602'

                    deallocate(Me%ExtWater%Sediment, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR603'

                    deallocate(Me%BottomSWRadiationAverage, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR604'


                    deallocate(Me%Seagrasses%UptakeNH4s2D, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR605'

                    deallocate(Me%Seagrasses%UptakeNH4NO3w2D, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR606'

                    deallocate(Me%Seagrasses%UptakePO4w2D, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR607'


                    deallocate(Me%Seagrasses%LightFactor2D, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR608'

                    deallocate(Me%Seagrasses%UptakePO4s2D, STAT = STAT_CALL)
                     if(STAT_CALL .ne. SUCCESS_)&
                     stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR609'

                endif

                PropertyX => Me%FirstProperty

                do while(associated(PropertyX))

                    deallocate(PropertyX%Mass_Available,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR36'
                    nullify(PropertyX%Mass_Available)

                    deallocate(PropertyX%MassInKg,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR36a'
                    nullify(PropertyX%MassInKg)

                    deallocate(PropertyX%Mass_FromWater,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR36b'
                    nullify(PropertyX%Mass_FromWater)


                    if(PropertyX%Evolution%Deposition)then

                        deallocate(PropertyX%DepositionFlux,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR37'
                        nullify(PropertyX%DepositionFlux)
                    end if

                    if(PropertyX%Evolution%Erosion)then

                        deallocate(PropertyX%ErosionCoefficient,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR38'
                        nullify(PropertyX%ErosionCoefficient)

                        deallocate(PropertyX%ErosionFlux,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR39'
                        nullify(PropertyX%ErosionFlux)

                    end if


                    if((.not. PropertyX%ID%IsParticulate) .or. PropertyX%Evolution%WaterFluxes)then

                        deallocate(PropertyX%WaterConcentration,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR40'
                        nullify(PropertyX%WaterConcentration)

                    end if


                    if(PropertyX%Evolution%WaterFluxes .or. PropertyX%Evolution%SedimentWaterFluxes)then

                        deallocate(PropertyX%FluxToWater,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR41'
                        nullify(PropertyX%FluxToWater)

                    end if

                    if(PropertyX%Evolution%SedimentFluxes .or. PropertyX%Evolution%SedimentWaterFluxes)then

                        deallocate(PropertyX%FluxToSediment,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR41a'
                        nullify(PropertyX%FluxToSediment)

                        deallocate(PropertyX%SedimentConcentration,   STAT = STAT_CALL)
                        if(STAT_CALL .ne. SUCCESS_)&
                            stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR41b'
                        nullify(PropertyX%SedimentConcentration)

                    end if


                    PropertyX => PropertyX%Next

                end do

                BenthicRateX => Me%FirstBenthicRate

                do while(associated(BenthicRateX))

                    deallocate(BenthicRateX%Field,   STAT = STAT_CALL)
                    if(STAT_CALL .ne. SUCCESS_)&
                        stop 'KillInterfaceSedimentWater - ModuleInterfaceSedimentWater - ERR42'
                    nullify(BenthicRateX%Field)

                    BenthicRateX => BenthicRateX%Next

                end do

                if (associated(Me%Shear_Stress%Residual_Tau_X)) then
                    deallocate(Me%Shear_Stress%Residual_Tau_X)
                    nullify   (Me%Shear_Stress%Residual_Tau_X)
                endif

                if (associated(Me%Shear_Stress%Residual_Tau_Y)) then
                    deallocate(Me%Shear_Stress%Residual_Tau_Y)
                    nullify   (Me%Shear_Stress%Residual_Tau_Y)
                endif

                if (associated(Me%Shear_Stress%Residual_Tau)) then
                    deallocate(Me%Shear_Stress%Residual_Tau  )
                    nullify   (Me%Shear_Stress%Residual_Tau  )
                endif

                !Deallocates Instance
                call DeallocateInstance

                ObjInterfaceSedimentWaterID = 0
                STAT_      = SUCCESS_

            end if
        else
            STAT_ = ready_
        end if cd1

        if (present(STAT)) STAT = STAT_


    end subroutine KillInterfaceSedimentWater


    !------------------------------------------------------------------------


    subroutine DeallocateInstance ()

        !Arguments-------------------------------------------------------------

        !Local-----------------------------------------------------------------
        type (T_InterfaceSedimentWater), pointer          :: AuxObjInterfaceSedimentWater
        type (T_InterfaceSedimentWater), pointer          :: PreviousObjWaterSedInterface

        !Updates pointers
        if (Me%InstanceID == FirstObjInterfaceSedimentWater%InstanceID) then
            FirstObjInterfaceSedimentWater      => FirstObjInterfaceSedimentWater%Next
        else
            PreviousObjWaterSedInterface        => FirstObjInterfaceSedimentWater
            AuxObjInterfaceSedimentWater        => FirstObjInterfaceSedimentWater%Next
            do while (AuxObjInterfaceSedimentWater%InstanceID /= Me%InstanceID)
                PreviousObjWaterSedInterface    => AuxObjInterfaceSedimentWater
                AuxObjInterfaceSedimentWater    => AuxObjInterfaceSedimentWater%Next
            enddo

            !Now update linked list
            PreviousObjWaterSedInterface%Next   => AuxObjInterfaceSedimentWater%Next

        endif

        !Deallocates instance
        deallocate (Me)
        nullify    (Me)


    end subroutine DeallocateInstance

    !--------------------------------------------------------------------------

    subroutine Write_Final_HDF( Final )

        !Arguments ---------------------------------------------------------
        logical, optional, intent(IN)           :: Final

        !Local--------------------------------------------------------------
        type(T_Property),           pointer     :: Property
        integer                                 :: ObjHDF5
        character (Len = StringLength)          :: PropertyName, GroupName
        integer                                 :: WorkILB, WorkIUB
        integer                                 :: WorkJLB, WorkJUB
        integer                                 :: WorkKLB, WorkKUB
        integer                                 :: STAT_CALL
        integer(4)                              :: HDF5_CREATE
        logical                                 :: Final_ = .false.
        character (Len = Pathlength)            :: filename

        !----------------------------------------------------------------------

        WorkILB = Me%WaterWorkSize3D%ILB;  WorkJLB = Me%WaterWorkSize3D%JLB;  WorkKLB = Me%WaterWorkSize3D%KLB
        WorkIUB = Me%WaterWorkSize3D%IUB;  WorkJUB = Me%WaterWorkSize3D%JUB;  WorkKUB = Me%WaterWorkSize3D%KUB

        if(present(Final)) Final_ = Final

        !Checks if it's at the end of the run
        !or !if it's supposed to overwrite the final HDF file
        if (Final_ .or. Me%Output%RestartOverwrite) then
            filename = trim(Me%Files%Final)
        else
            filename =  ChangeSuffix(Me%Files%Final,                         &
                            "_"//trim(TimeToString(Me%ExternalVar%Now))//".fin")
        endif

        !Gets File Access Code
        call GetHDF5FileAccess  (HDF5_CREATE = HDF5_CREATE)

        ObjHDF5 = 0

        !Opens HDF5 File
        call ConstructHDF5 (ObjHDF5,trim(filename), HDF5_CREATE, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR10'

        !Write the Horizontal Grid
        call WriteHorizontalGrid(Me%ObjHorizontalGrid, ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_) stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR100'

        !Sets limits for next write operations
        call HDF5SetLimits   (ObjHDF5, WorkILB, WorkIUB, WorkJLB, WorkJUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR20'

        !Writes the Grid
        call HDF5WriteData   (ObjHDF5, "/Grid", "Bathymetry", "m",                      &
                              Array2D = Me%ExtWater%Bathymetry,                         &
                              STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR30'

        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                                 &
                             WorkJLB, WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR40'

        call HDF5WriteData   (ObjHDF5, "/Grid", "WaterPoints3D", "-",                   &
                              Array3D = Me%ExtWater%WaterPoints3D,                      &
                              STAT    = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR50'

        !Writes SZZ
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB,                        &
                             WorkJUB, WorkKLB-1, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR60'

        call HDF5WriteData  (ObjHDF5, "/Grid", "VerticalZ",                             &
                             "m", Array3D = Me%ExtWater%SZZ,                            &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR70'

        !Writes OpenPoints
        call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB,                                 &
                             WorkJLB, WorkJUB, WorkKLB, WorkKUB, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR80'

        call HDF5WriteData  (ObjHDF5, "/Grid", "OpenPoints",                            &
                             "-", Array3D = Me%ExtWater%OpenPoints3D,                   &
                             STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR90'


        Property => Me%FirstProperty

        do while (associated(Property))

            PropertyName = trim(Property%ID%name)

            call HDF5SetLimits  (ObjHDF5, WorkILB, WorkIUB, WorkJLB, WorkJUB, STAT = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR100'

            !Final concentration
            call HDF5WriteData  (ObjHDF5, "/Mass/"//Property%ID%Name,                   &
                                 Property%ID%Name, Property%ID%Units,                   &
                                 Array2D = Property%Mass_Available,                     &
                                 STAT    = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR110'

            Property => Property%Next

        enddo

        nullify (Property)

        if(Me%ComputeRugosity)then
            !Final rugosity
            call HDF5WriteData  (ObjHDF5, "/Rugosity/"//"Rugosity",                    &
                                 "Rugosity", "m",                                      &
                                 Array2D = Me%Rugosity%Field,                          &
                                 STAT    = STAT_CALL)
            if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR120'
        endif


        if (Me%Shear_Stress%OutputON .and. Me%ExtWater%ResidualON) then

            PropertyName = GetPropertyName(ShearStressX_)
            GroupName    = "/Residual/"//trim(PropertyName)

            call HDF5WriteData  (HDF5ID        = ObjHDF5,                               &
                                GroupName      = trim(GroupName),                       &
                                Name           = trim(PropertyName),                    &
                                Units          = "Pa",                                  &
                                Array2D        = Me%Shear_Stress%Residual_Tau_X,        &
                                STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR130'
            endif

            PropertyName = GetPropertyName(ShearStressY_)
            GroupName    = "/Residual/"//trim(PropertyName)

            call HDF5WriteData  (HDF5ID        = ObjHDF5,                               &
                                GroupName      = trim(GroupName),                       &
                                Name           = trim(PropertyName),                    &
                                Units          = "Pa",                                  &
                                Array2D        = Me%Shear_Stress%Residual_Tau_Y,        &
                                STAT           = STAT_CALL)
            if (STAT_CALL /= SUCCESS_) then
                stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR140'
            endif
        endif

        !Writes everything to disk
        call HDF5FlushMemory (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR150'

        call KillHDF5 (ObjHDF5, STAT = STAT_CALL)
        if (STAT_CALL /= SUCCESS_)stop 'Write_Final_HDF - ModuleInterfaceSedimentWater - ERR160'

    end subroutine Write_Final_HDF

    !--------------------------------------------------------------------------
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    !MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEMENT MANAGEME

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


    !--------------------------------------------------------------------------

    subroutine Ready (ObjInterfaceSedimentWater_ID, ready_)

        !Arguments-------------------------------------------------------------
        integer                                     :: ObjInterfaceSedimentWater_ID
        integer                                     :: ready_

        !----------------------------------------------------------------------

        nullify (Me)

cd1:    if (ObjInterfaceSedimentWater_ID > 0) then
            call LocateObjInterfaceSedimentWater (ObjInterfaceSedimentWater_ID)
            ready_ = VerifyReadLock (mINTERFACESEDIMENTWATER_, Me%InstanceID)
        else
            ready_ = OFF_ERR_
        end if cd1

        !----------------------------------------------------------------------

    end subroutine Ready

    !--------------------------------------------------------------------------

    subroutine LocateObjInterfaceSedimentWater (ObjInterfaceSedimentWaterID)

        !Arguments-------------------------------------------------------------
        integer                                     :: ObjInterfaceSedimentWaterID

        !Local-----------------------------------------------------------------

        Me => FirstObjInterfaceSedimentWater
        do while (associated (Me))
            if (Me%InstanceID == ObjInterfaceSedimentWaterID) exit
            Me => Me%Next
        enddo

        if (.not. associated(Me)) stop 'ModuleInterfaceSedimentWater - LocateObjInterfaceSedimentWater - ERR01'

    end subroutine LocateObjInterfaceSedimentWater

    !--------------------------------------------------------------------------

end module ModuleInterfaceSedimentWater

!----------------------------------------------------------------------------------------------------------
!MOHID Water Modelling System.
!Copyright (C) 1985, 1998, 2002, 2005. Instituto Superior T?cnico, Technical University of Lisbon.
!----------------------------------------------------------------------------------------------------------
